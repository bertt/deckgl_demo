"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  GeoJSONTiler: () => GeoJSONTiler,
  MVTLoader: () => MVTLoader,
  MVTSource: () => MVTSource,
  MVTWorkerLoader: () => MVTWorkerLoader,
  TileJSONLoader: () => TileJSONLoader
});
module.exports = __toCommonJS(dist_exports);

// dist/lib/parse-mvt.js
var import_gis = require("@loaders.gl/gis");
var import_pbf = __toESM(require("pbf"), 1);

// dist/helpers/mapbox-util-functions.js
function classifyRings(rings) {
  const len = rings.length;
  if (len <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i2 = 0; i2 < len; i2++) {
    const area = signedArea(rings[i2]);
    if (area === 0)
      continue;
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i2]];
    } else if (polygon)
      polygon.push(rings[i2]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function signedArea(ring) {
  let sum = 0;
  for (let i2 = 0, j = ring.length - 1, p1, p2; i2 < ring.length; j = i2++) {
    p1 = ring[i2];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function readFeature(tag, feature, pbf) {
  if (feature && pbf) {
    if (tag === 1)
      feature.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature);
    else if (tag === 3)
      feature.type = pbf.readVarint();
    else if (tag === 4)
      feature._geometry = pbf.pos;
  }
}
function readTag(pbf, feature) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature._keys[pbf.readVarint()];
    const value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}

// dist/lib/mapbox-vector-tile/vector-tile-feature.js
var VectorTileFeature = class {
  properties;
  extent;
  type;
  id;
  _pbf;
  _geometry;
  _keys;
  _values;
  static get types() {
    return ["Unknown", "Point", "LineString", "Polygon"];
  }
  constructor(pbf, end, extent, keys, values) {
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    pbf.readFields(readFeature, this, end);
  }
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    const lines = [];
    let line;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (cmd2 === 1) {
          if (line)
            lines.push(line);
          line = [];
        }
        if (line)
          line.push([x2, y2]);
      } else if (cmd2 === 7) {
        if (line) {
          line.push(line[0].slice());
        }
      } else {
        throw new Error(`unknown command ${cmd2}`);
      }
    }
    if (line)
      lines.push(line);
    return lines;
  }
  // eslint-disable-next-line max-statements
  bbox() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    let x1 = Infinity;
    let x22 = -Infinity;
    let y1 = Infinity;
    let y22 = -Infinity;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (x2 < x1)
          x1 = x2;
        if (x2 > x22)
          x22 = x2;
        if (y2 < y1)
          y1 = y2;
        if (y2 > y22)
          y22 = y2;
      } else if (cmd2 !== 7) {
        throw new Error(`unknown command ${cmd2}`);
      }
    }
    return [x1, y1, x22, y22];
  }
  _toGeoJSON(transform) {
    let coords = this.loadGeometry();
    let type = VectorTileFeature.types[this.type];
    let i2;
    let j;
    switch (this.type) {
      case 1:
        const points = [];
        for (i2 = 0; i2 < coords.length; i2++) {
          points[i2] = coords[i2][0];
        }
        coords = points;
        transform(coords, this);
        break;
      case 2:
        for (i2 = 0; i2 < coords.length; i2++) {
          transform(coords[i2], this);
        }
        break;
      case 3:
        coords = classifyRings(coords);
        for (i2 = 0; i2 < coords.length; i2++) {
          for (j = 0; j < coords[i2].length; j++) {
            transform(coords[i2][j], this);
          }
        }
        break;
    }
    if (coords.length === 1) {
      coords = coords[0];
    } else {
      type = `Multi${type}`;
    }
    const result = {
      type: "Feature",
      geometry: {
        type,
        coordinates: coords
      },
      properties: this.properties
    };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toGeoJSON(options) {
    if (typeof options === "function") {
      return this._toGeoJSON(options);
    }
    const { x: x2, y: y2, z } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    function project2(line) {
      for (let j = 0; j < line.length; j++) {
        const p = line[j];
        p[0] = (p[0] + x0) * 360 / size - 180;
        const y22 = 180 - (p[1] + y0) * 360 / size;
        p[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
      }
    }
    return this._toGeoJSON(project2);
  }
};

// dist/lib/mapbox-vector-tile/vector-tile-layer.js
var VectorTileLayer = class {
  version;
  name;
  extent;
  length;
  _pbf;
  _keys;
  _values;
  _features;
  constructor(pbf, end) {
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `VectorTileFeature`
   * @param index
   * @returns feature
   */
  feature(i2) {
    if (i2 < 0 || i2 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i2];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  }
};
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// dist/lib/mapbox-vector-tile/vector-tile.js
var VectorTile = class {
  layers;
  constructor(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
  }
};
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// dist/helpers/binary-util-functions.js
var import_polygon = require("@math.gl/polygon");
function classifyRings2(geom) {
  const len = geom.indices.length;
  const type = "Polygon";
  if (len <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[(0, import_polygon.getPolygonSignedArea)(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i2 = 0, startIndex; i2 < len; i2++) {
    startIndex = geom.indices[i2] - offset;
    endIndex = geom.indices[i2 + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area = (0, import_polygon.getPolygonSignedArea)(shape);
    if (area === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area];
    } else {
      ringAreas.push(area);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return { type, areas, indices: polygons, data: geom.data };
}
function project(data, x0, y0, size) {
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function readFeature2(tag, feature, pbf) {
  if (feature && pbf) {
    if (tag === 1)
      feature.id = pbf.readVarint();
    else if (tag === 2)
      readTag2(pbf, feature);
    else if (tag === 3)
      feature.type = pbf.readVarint();
    else if (tag === 4)
      feature._geometry = pbf.pos;
  }
}
function readTag2(pbf, feature) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature._keys[pbf.readVarint()];
    const value = feature._values[pbf.readVarint()];
    feature.properties[key] = value;
  }
}

// dist/lib/binary-vector-tile/vector-tile-feature.js
var endPos;
var cmd;
var cmdLen;
var length;
var x;
var y;
var i;
var BinaryVectorTileFeature = class {
  properties;
  extent;
  type;
  id;
  _pbf;
  _geometry;
  _keys;
  _values;
  _geometryInfo;
  // eslint-disable-next-line max-params
  constructor(pbf, end, extent, keys, values, geometryInfo) {
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    this._geometryInfo = geometryInfo;
    pbf.readFields(readFeature2, this, end);
  }
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    endPos = pbf.readVarint() + pbf.pos;
    cmd = 1;
    length = 0;
    x = 0;
    y = 0;
    i = 0;
    const indices = [];
    const data = [];
    while (pbf.pos < endPos) {
      if (length <= 0) {
        cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          indices.push(i);
        }
        data.push(x, y);
        i += 2;
      } else if (cmd === 7) {
        if (i > 0) {
          const start = indices[indices.length - 1];
          data.push(data[start], data[start + 1]);
          i += 2;
        }
      } else {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return { data, indices };
  }
  /**
   *
   * @param transform
   * @returns result
   */
  _toBinaryCoordinates(transform) {
    const geom = this.loadGeometry();
    let geometry;
    transform(geom.data, this);
    const coordLength = 2;
    switch (this.type) {
      case 1:
        this._geometryInfo.pointFeaturesCount++;
        this._geometryInfo.pointPositionsCount += geom.indices.length;
        geometry = { type: "Point", ...geom };
        break;
      case 2:
        this._geometryInfo.lineFeaturesCount++;
        this._geometryInfo.linePathsCount += geom.indices.length;
        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
        geometry = { type: "LineString", ...geom };
        break;
      case 3:
        geometry = classifyRings2(geom);
        this._geometryInfo.polygonFeaturesCount++;
        this._geometryInfo.polygonObjectsCount += geometry.indices.length;
        for (const indices of geometry.indices) {
          this._geometryInfo.polygonRingsCount += indices.length;
        }
        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
        break;
      default:
        throw new Error(`Invalid geometry type: ${this.type}`);
    }
    const result = { type: "Feature", geometry, properties: this.properties };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toBinaryCoordinates(options) {
    if (typeof options === "function") {
      return this._toBinaryCoordinates(options);
    }
    const { x: x2, y: y2, z } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
  }
};

// dist/lib/binary-vector-tile/vector-tile-layer.js
var BinaryVectorTileLayer = class {
  version;
  name;
  extent;
  length;
  _pbf;
  _keys;
  _values;
  _features;
  constructor(pbf, end) {
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer2, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `BinaryVectorTileFeature`
   *
   * @param index
   * @param geometryInfo
   * @returns {BinaryVectorTileFeature}
   */
  feature(i2, geometryInfo) {
    if (i2 < 0 || i2 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i2];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new BinaryVectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
  }
};
function readLayer2(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage2(pbf));
  }
}
function readValueMessage2(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// dist/lib/binary-vector-tile/vector-tile.js
var BinaryVectorTile = class {
  layers;
  constructor(pbf, end) {
    this.layers = pbf.readFields(readTile2, {}, end);
  }
};
function readTile2(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new BinaryVectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// dist/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _a, _b;
  const mvtOptions = normalizeOptions(options);
  const shape = ((_a = options == null ? void 0 : options.gis) == null ? void 0 : _a.format) || ((_b = options == null ? void 0 : options.mvt) == null ? void 0 : _b.shape) || (options == null ? void 0 : options.shape);
  switch (shape) {
    case "columnar-table":
      return { shape: "columnar-table", data: parseToBinary(arrayBuffer, mvtOptions) };
    case "geojson-table": {
      const table = {
        shape: "geojson-table",
        type: "FeatureCollection",
        features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape || "undefined shape");
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = (0, import_gis.flatGeojsonToBinary)(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features, geometryInfo];
  }
  const tile = new BinaryVectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
      const vectorTileFeature = vectorTileLayer.feature(i2, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return [features, geometryInfo];
}
function parseToGeojsonFeatures(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i2 = 0; i2 < vectorTileLayer.length; i2++) {
      const vectorTileFeature = vectorTileLayer.feature(i2);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return features;
}
function normalizeOptions(options) {
  var _a;
  if (!(options == null ? void 0 : options.mvt)) {
    throw new Error("mvt options required");
  }
  const wgs84Coordinates = ((_a = options.mvt) == null ? void 0 : _a.coordinates) === "wgs84";
  const { tileIndex } = options.mvt;
  const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
  if (wgs84Coordinates && !hasTileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  return options.mvt;
}
function getDecodedFeature(feature, options, layerName) {
  const decodedFeature = feature.toGeoJSON(
    // @ts-expect-error What is going on here?
    options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates
  );
  if (options.layerProperty) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature, options, layerName) {
  const decodedFeature = feature.toBinaryCoordinates(
    // @ts-expect-error
    options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary
  );
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function transformToLocalCoordinates(line, feature) {
  const { extent } = feature;
  for (let i2 = 0; i2 < line.length; i2++) {
    const p = line[i2];
    p[0] /= extent;
    p[1] /= extent;
  }
}
function transformToLocalCoordinatesBinary(data, feature) {
  const { extent } = feature;
  for (let i2 = 0, il = data.length; i2 < il; ++i2) {
    data[i2] /= extent;
  }
}

// dist/mvt-loader.js
var VERSION = true ? "4.2.0-beta.2" : "latest";
var MVTWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: VERSION,
  // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
  extensions: ["mvt", "pbf"],
  mimeTypes: [
    // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
    "application/vnd.mapbox-vector-tile",
    "application/x-protobuf"
    // 'application/octet-stream'
  ],
  worker: true,
  category: "geometry",
  options: {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: null
    }
  }
};
var MVTLoader = {
  ...MVTWorkerLoader,
  parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
  parseSync: parseMVT,
  binary: true
};

// dist/lib/parse-tilejson.js
var isObject = (x2) => x2 !== null && typeof x2 === "object";
function parseTileJSON(jsonMetadata, options) {
  var _a;
  if (!jsonMetadata || !isObject(jsonMetadata)) {
    return null;
  }
  let tileJSON = {
    name: jsonMetadata.name || "",
    description: jsonMetadata.description || ""
  };
  if (typeof jsonMetadata.generator === "string") {
    tileJSON.generator = jsonMetadata.generator;
  }
  if (typeof jsonMetadata.generator_options === "string") {
    tileJSON.generatorOptions = jsonMetadata.generator_options;
  }
  tileJSON.boundingBox = parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);
  tileJSON.center = parseCenter(jsonMetadata.center);
  tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);
  tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);
  if (typeof (jsonMetadata == null ? void 0 : jsonMetadata.json) === "string") {
    try {
      tileJSON.metaJson = JSON.parse(jsonMetadata.json);
    } catch (error) {
      console.warn("Failed to parse tilejson.json field", error);
    }
  }
  const tilestats = jsonMetadata.tilestats || ((_a = tileJSON.metaJson) == null ? void 0 : _a.tilestats);
  const tileStatsLayers = parseTilestatsLayers(tilestats, options);
  const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers);
  const layers = mergeLayers(tileJSONlayers, tileStatsLayers);
  tileJSON = {
    ...tileJSON,
    layers
  };
  if (tileJSON.maxZoom === null && layers.length > 0) {
    tileJSON.maxZoom = layers[0].maxZoom || null;
  }
  if (tileJSON.minZoom === null && layers.length > 0) {
    tileJSON.minZoom = layers[0].minZoom || null;
  }
  return tileJSON;
}
function parseTileJSONLayers(layers) {
  if (!Array.isArray(layers)) {
    return [];
  }
  return layers.map((layer) => parseTileJSONLayer(layer));
}
function parseTileJSONLayer(layer) {
  const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({
    name: key,
    ...attributeTypeToFieldType(String(datatype))
  }));
  const layer2 = { ...layer };
  delete layer2.fields;
  return {
    name: layer.id || "",
    ...layer2,
    fields
  };
}
function parseTilestatsLayers(tilestats, options) {
  if (isObject(tilestats) && Array.isArray(tilestats.layers)) {
    return tilestats.layers.map((layer) => parseTilestatsForLayer(layer, options));
  }
  return [];
}
function parseTilestatsForLayer(layer, options) {
  const fields = [];
  const indexedAttributes = {};
  const attributes = layer.attributes || [];
  for (const attribute of attributes) {
    const name = attribute.attribute;
    if (typeof name === "string") {
      if (name.split("|").length > 1) {
        const fname = name.split("|")[0];
        indexedAttributes[fname] = indexedAttributes[fname] || [];
        indexedAttributes[fname].push(attribute);
        console.warn("ignoring tilestats indexed field", fname);
      } else if (!fields[name]) {
        fields.push(attributeToField(attribute, options));
      } else {
      }
    }
  }
  return {
    name: layer.layer || "",
    dominantGeometry: layer.geometry,
    fields
  };
}
function mergeLayers(layers, tilestatsLayers) {
  return layers.map((layer) => {
    const tilestatsLayer = tilestatsLayers.find((tsLayer) => tsLayer.name === layer.name);
    const fields = (tilestatsLayer == null ? void 0 : tilestatsLayer.fields) || [];
    const layer2 = { ...layer };
    delete layer2.fields;
    return {
      ...layer2,
      ...tilestatsLayer,
      fields
    };
  });
}
function parseBounds(bounds) {
  const result = fromArrayOrString(bounds);
  if (Array.isArray(result) && result.length === 4 && [result[0], result[2]].every(isLng) && [result[1], result[3]].every(isLat)) {
    return [
      [result[0], result[1]],
      [result[2], result[3]]
    ];
  }
  return void 0;
}
function parseCenter(center) {
  const result = fromArrayOrString(center);
  if (Array.isArray(result) && result.length === 3 && isLng(result[0]) && isLat(result[1]) && isZoom(result[2])) {
    return result;
  }
  return null;
}
function safeParseFloat(input) {
  const result = typeof input === "string" ? parseFloat(input) : typeof input === "number" ? input : null;
  return result === null || isNaN(result) ? null : result;
}
function isLat(num) {
  return Number.isFinite(num) && num <= 90 && num >= -90;
}
function isLng(num) {
  return Number.isFinite(num) && num <= 180 && num >= -180;
}
function isZoom(num) {
  return Number.isFinite(num) && num >= 0 && num <= 22;
}
function fromArrayOrString(data) {
  if (typeof data === "string") {
    return data.split(",").map(parseFloat);
  } else if (Array.isArray(data)) {
    return data;
  }
  return null;
}
var attrTypeMap = {
  number: {
    type: "float32"
  },
  numeric: {
    type: "float32"
  },
  string: {
    type: "utf8"
  },
  vachar: {
    type: "utf8"
  },
  float: {
    type: "float32"
  },
  int: {
    type: "int32"
  },
  int4: {
    type: "int32"
  },
  boolean: {
    type: "boolean"
  },
  bool: {
    type: "boolean"
  }
};
function attributeToField(attribute = {}, options) {
  var _a;
  const fieldTypes = attributeTypeToFieldType(attribute.type);
  const field = {
    name: attribute.attribute,
    // what happens if attribute type is string...
    // filterProps: getFilterProps(fieldTypes.type, attribute),
    ...fieldTypes
  };
  if (typeof attribute.min === "number") {
    field.min = attribute.min;
  }
  if (typeof attribute.max === "number") {
    field.max = attribute.max;
  }
  if (typeof attribute.count === "number") {
    field.uniqueValueCount = attribute.count;
  }
  if (attribute.values) {
    field.values = attribute.values;
  }
  if (field.values && typeof options.maxValues === "number") {
    field.values = (_a = field.values) == null ? void 0 : _a.slice(0, options.maxValues);
  }
  return field;
}
function attributeTypeToFieldType(aType) {
  const type = aType.toLowerCase();
  if (!type || !attrTypeMap[type]) {
  }
  return attrTypeMap[type] || { type: "string" };
}

// dist/tilejson-loader.js
var VERSION2 = true ? "4.2.0-beta.2" : "latest";
var TileJSONLoader = {
  dataType: null,
  batchType: null,
  name: "TileJSON",
  id: "tilejson",
  module: "pmtiles",
  version: VERSION2,
  worker: true,
  extensions: ["json"],
  mimeTypes: ["application/json"],
  text: true,
  options: {
    tilejson: {
      maxValues: void 0
    }
  },
  parse: async (arrayBuffer, options) => {
    const jsonString = new TextDecoder().decode(arrayBuffer);
    const json = JSON.parse(jsonString);
    const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options == null ? void 0 : options.tilejson };
    return parseTileJSON(json, tilejsonOptions);
  },
  parseTextSync: (text, options) => {
    const json = JSON.parse(text);
    const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options == null ? void 0 : options.tilejson };
    return parseTileJSON(json, tilejsonOptions);
  }
};

// dist/mvt-source.js
var import_loader_utils = require("@loaders.gl/loader-utils");
var import_images = require("@loaders.gl/images");
var import_mvt = require("@loaders.gl/mvt");
var MVTSource = class extends import_loader_utils.DataSource {
  props;
  url;
  metadataUrl = null;
  data;
  schema = "tms";
  metadata;
  extension;
  mimeType = null;
  constructor(props) {
    super(props);
    this.props = props;
    this.url = (0, import_loader_utils.resolvePath)(props.url);
    this.metadataUrl = props.metadataUrl === void 0 ? `${this.url}/tilejson.json` : props.metadataUrl;
    this.extension = props.extension || ".png";
    this.data = this.url;
    this.getTileData = this.getTileData.bind(this);
    this.metadata = this.getMetadata();
    if (isURLTemplate(this.url)) {
      this.schema = "template";
    }
  }
  // @ts-ignore - Metadata type misalignment
  async getMetadata() {
    var _a, _b;
    if (!this.metadataUrl) {
      return null;
    }
    let response;
    try {
      response = await this.fetch(this.metadataUrl);
    } catch (error) {
      console.error(error.message);
      return null;
    }
    if (!response.ok) {
      console.error(response.statusText);
      return null;
    }
    const tileJSON = await response.text();
    const metadata = ((_b = (_a = import_mvt.TileJSONLoader).parseTextSync) == null ? void 0 : _b.call(_a, tileJSON)) || null;
    return metadata;
  }
  getTileMIMEType() {
    return this.mimeType;
  }
  async getTile(tileParams) {
    const { x: x2, y: y2, zoom: z } = tileParams;
    const tileUrl = this.getTileURL(x2, y2, z);
    const response = await this.fetch(tileUrl);
    if (!response.ok) {
      return null;
    }
    const arrayBuffer = await response.arrayBuffer();
    return arrayBuffer;
  }
  // Tile Source interface implementation: deck.gl compatible API
  // TODO - currently only handles image tiles, not vector tiles
  async getTileData(tileParams) {
    const { x: x2, y: y2, z } = tileParams.index;
    const arrayBuffer = await this.getTile({ x: x2, y: y2, zoom: z, layers: [] });
    if (arrayBuffer === null) {
      return null;
    }
    const imageMetadata = (0, import_images.getBinaryImageMetadata)(arrayBuffer);
    this.mimeType = this.mimeType || (imageMetadata == null ? void 0 : imageMetadata.mimeType) || "application/vnd.mapbox-vector-tile";
    switch (this.mimeType) {
      case "application/vnd.mapbox-vector-tile":
        return await this._parseVectorTile(arrayBuffer, { x: x2, y: y2, zoom: z, layers: [] });
      default:
        return await this._parseImageTile(arrayBuffer);
    }
  }
  // ImageTileSource interface implementation
  async getImageTile(tileParams) {
    const arrayBuffer = await this.getTile(tileParams);
    return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;
  }
  async _parseImageTile(arrayBuffer) {
    return await import_images.ImageLoader.parse(arrayBuffer, this.loadOptions);
  }
  // VectorTileSource interface implementation
  async getVectorTile(tileParams) {
    const arrayBuffer = await this.getTile(tileParams);
    return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;
  }
  async _parseVectorTile(arrayBuffer, tileParams) {
    var _a;
    const loadOptions = {
      shape: "geojson-table",
      mvt: {
        coordinates: "wgs84",
        tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.zoom },
        ...(_a = this.loadOptions) == null ? void 0 : _a.mvt
      },
      ...this.loadOptions
    };
    return await import_mvt.MVTLoader.parse(arrayBuffer, loadOptions);
  }
  getMetadataUrl() {
    return this.metadataUrl;
  }
  getTileURL(x2, y2, z) {
    switch (this.schema) {
      case "xyz":
        return `${this.url}/${x2}/${y2}/${z}${this.extension}`;
      case "tms":
        return `${this.url}/${z}/${x2}/${y2}${this.extension}`;
      case "template":
        return getURLFromTemplate(this.url, x2, y2, z, "0");
      default:
        throw new Error(this.schema);
    }
  }
};
function isURLTemplate(s) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);
}
var xRegex = new RegExp("{x}", "g");
var yRegex = new RegExp("{y}", "g");
var zRegex = new RegExp("{z}", "g");
function getURLFromTemplate(template, x2, y2, z, id = "0") {
  if (Array.isArray(template)) {
    const i2 = stringHash(id) % template.length;
    template = template[i2];
  }
  let url = template;
  url = url.replace(xRegex, String(x2));
  url = url.replace(yRegex, String(y2));
  url = url.replace(zRegex, String(z));
  if (Number.isInteger(y2) && Number.isInteger(z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, z) - y2 - 1));
  }
  return url;
}
function stringHash(s) {
  return Math.abs(s.split("").reduce((a, b) => (a << 5) - a + b.charCodeAt(0) | 0, 0));
}

// dist/lib/geojson-tiler/simplify.js
function simplify(coords, first, last, sqTolerance) {
  let maxSqDist = sqTolerance;
  const mid = last - first >> 1;
  let minPosToMid = last - first;
  let index;
  const ax = coords[first];
  const ay = coords[first + 1];
  const bx = coords[last];
  const by = coords[last + 1];
  for (let i2 = first + 3; i2 < last; i2 += 3) {
    const d = getSqSegDist(coords[i2], coords[i2 + 1], ax, ay, bx, by);
    if (d > maxSqDist) {
      index = i2;
      maxSqDist = d;
    } else if (d === maxSqDist) {
      const posToMid = Math.abs(i2 - mid);
      if (posToMid < minPosToMid) {
        index = i2;
        minPosToMid = posToMid;
      }
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 3)
      simplify(coords, first, index, sqTolerance);
    coords[index + 2] = maxSqDist;
    if (last - index > 3)
      simplify(coords, index, last, sqTolerance);
  }
}
function getSqSegDist(px, py, x2, y2, bx, by) {
  let dx = bx - x2;
  let dy = by - y2;
  if (dx !== 0 || dy !== 0) {
    const t = ((px - x2) * dx + (py - y2) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x2 = bx;
      y2 = by;
    } else if (t > 0) {
      x2 += dx * t;
      y2 += dy * t;
    }
  }
  dx = px - x2;
  dy = py - y2;
  return dx * dx + dy * dy;
}

// dist/lib/geojson-tiler/feature.js
function createFeature(id, type, geom, tags) {
  const feature = {
    // eslint-disable-next-line
    id: id == null ? null : id,
    type,
    geometry: geom,
    tags,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
  if (type === "Point" || type === "MultiPoint" || type === "LineString") {
    calcLineBBox(feature, geom);
  } else if (type === "Polygon") {
    calcLineBBox(feature, geom[0]);
  } else if (type === "MultiLineString") {
    for (const line of geom) {
      calcLineBBox(feature, line);
    }
  } else if (type === "MultiPolygon") {
    for (const polygon of geom) {
      calcLineBBox(feature, polygon[0]);
    }
  }
  return feature;
}
function calcLineBBox(feature, geom) {
  for (let i2 = 0; i2 < geom.length; i2 += 3) {
    feature.minX = Math.min(feature.minX, geom[i2]);
    feature.minY = Math.min(feature.minY, geom[i2 + 1]);
    feature.maxX = Math.max(feature.maxX, geom[i2]);
    feature.maxY = Math.max(feature.maxY, geom[i2 + 1]);
  }
}

// dist/lib/geojson-tiler/convert.js
function convert(data, options) {
  const features = [];
  if (data.type === "FeatureCollection") {
    for (let i2 = 0; i2 < data.features.length; i2++) {
      convertFeature(features, data.features[i2], options, i2);
    }
  } else if (data.type === "Feature") {
    convertFeature(features, data, options);
  } else {
    convertFeature(features, { geometry: data }, options);
  }
  return features;
}
function convertFeature(features, geojson, options, index) {
  if (!geojson.geometry) {
    return;
  }
  const coords = geojson.geometry.coordinates;
  const type = geojson.geometry.type;
  const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);
  let geometry = [];
  let id = geojson.id;
  if (options.promoteId) {
    id = geojson.properties[options.promoteId];
  } else if (options.generateId) {
    id = index || 0;
  }
  if (type === "Point") {
    convertPoint(coords, geometry);
  } else if (type === "MultiPoint") {
    for (const p of coords) {
      convertPoint(p, geometry);
    }
  } else if (type === "LineString") {
    convertLine(coords, geometry, tolerance, false);
  } else if (type === "MultiLineString") {
    if (options.lineMetrics) {
      for (const line of coords) {
        geometry = [];
        convertLine(line, geometry, tolerance, false);
        features.push(createFeature(id, "LineString", geometry, geojson.properties));
      }
      return;
    } else {
      convertLines(coords, geometry, tolerance, false);
    }
  } else if (type === "Polygon") {
    convertLines(coords, geometry, tolerance, true);
  } else if (type === "MultiPolygon") {
    for (const polygon of coords) {
      const newPolygon = [];
      convertLines(polygon, newPolygon, tolerance, true);
      geometry.push(newPolygon);
    }
  } else if (type === "GeometryCollection") {
    for (const singleGeometry of geojson.geometry.geometries) {
      convertFeature(features, {
        id,
        geometry: singleGeometry,
        properties: geojson.properties
      }, options, index);
    }
    return;
  } else {
    throw new Error("Input data is not a valid GeoJSON object.");
  }
  features.push(createFeature(id, type, geometry, geojson.properties));
}
function convertPoint(coords, out) {
  out.push(projectX(coords[0]), projectY(coords[1]), 0);
}
function convertLine(ring, out, tolerance, isPolygon) {
  let x0, y0;
  let size = 0;
  for (let j = 0; j < ring.length; j++) {
    const x2 = projectX(ring[j][0]);
    const y2 = projectY(ring[j][1]);
    out.push(x2, y2, 0);
    if (j > 0) {
      if (isPolygon) {
        size += (x0 * y2 - x2 * y0) / 2;
      } else {
        size += Math.sqrt(Math.pow(x2 - x0, 2) + Math.pow(y2 - y0, 2));
      }
    }
    x0 = x2;
    y0 = y2;
  }
  const last = out.length - 3;
  out[2] = 1;
  simplify(out, 0, last, tolerance);
  out[last + 2] = 1;
  out.size = Math.abs(size);
  out.start = 0;
  out.end = out.size;
}
function convertLines(rings, out, tolerance, isPolygon) {
  for (let i2 = 0; i2 < rings.length; i2++) {
    const geom = [];
    convertLine(rings[i2], geom, tolerance, isPolygon);
    out.push(geom);
  }
}
function projectX(x2) {
  return x2 / 360 + 0.5;
}
function projectY(y2) {
  const sin = Math.sin(y2 * Math.PI / 180);
  const y22 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
  return y22 < 0 ? 0 : y22 > 1 ? 1 : y22;
}

// dist/lib/geojson-tiler/clip.js
function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {
  k1 /= scale;
  k2 /= scale;
  if (minAll >= k1 && maxAll < k2) {
    return features;
  } else if (maxAll < k1 || minAll >= k2) {
    return null;
  }
  const clipped = [];
  for (const feature of features) {
    const geometry = feature.geometry;
    let type = feature.type;
    const min = axis === 0 ? feature.minX : feature.minY;
    const max = axis === 0 ? feature.maxX : feature.maxY;
    if (min >= k1 && max < k2) {
      clipped.push(feature);
      continue;
    } else if (max < k1 || min >= k2) {
      continue;
    }
    let newGeometry = [];
    if (type === "Point" || type === "MultiPoint") {
      clipPoints(geometry, newGeometry, k1, k2, axis);
    } else if (type === "LineString") {
      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);
    } else if (type === "MultiLineString") {
      clipLines(geometry, newGeometry, k1, k2, axis, false);
    } else if (type === "Polygon") {
      clipLines(geometry, newGeometry, k1, k2, axis, true);
    } else if (type === "MultiPolygon") {
      for (const polygon of geometry) {
        const newPolygon = [];
        clipLines(polygon, newPolygon, k1, k2, axis, true);
        if (newPolygon.length) {
          newGeometry.push(newPolygon);
        }
      }
    }
    if (newGeometry.length) {
      if (options.lineMetrics && type === "LineString") {
        for (const line of newGeometry) {
          clipped.push(createFeature(feature.id, type, line, feature.tags));
        }
        continue;
      }
      if (type === "LineString" || type === "MultiLineString") {
        if (newGeometry.length === 1) {
          type = "LineString";
          newGeometry = newGeometry[0];
        } else {
          type = "MultiLineString";
        }
      }
      if (type === "Point" || type === "MultiPoint") {
        type = newGeometry.length === 3 ? "Point" : "MultiPoint";
      }
      clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));
    }
  }
  return clipped.length ? clipped : null;
}
function clipPoints(geom, newGeom, k1, k2, axis) {
  for (let i2 = 0; i2 < geom.length; i2 += 3) {
    const a = geom[i2 + axis];
    if (a >= k1 && a <= k2) {
      addPoint(newGeom, geom[i2], geom[i2 + 1], geom[i2 + 2]);
    }
  }
}
function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {
  let slice = newSlice(geom);
  const intersect = axis === 0 ? intersectX : intersectY;
  let len = geom.start;
  let segLen;
  let t;
  for (let i2 = 0; i2 < geom.length - 3; i2 += 3) {
    const ax2 = geom[i2];
    const ay2 = geom[i2 + 1];
    const az2 = geom[i2 + 2];
    const bx = geom[i2 + 3];
    const by = geom[i2 + 4];
    const a2 = axis === 0 ? ax2 : ay2;
    const b = axis === 0 ? bx : by;
    let exited = false;
    if (trackMetrics) {
      segLen = Math.sqrt(Math.pow(ax2 - bx, 2) + Math.pow(ay2 - by, 2));
    }
    if (a2 < k1) {
      if (b > k1) {
        t = intersect(slice, ax2, ay2, bx, by, k1);
        if (trackMetrics) {
          slice.start = len + segLen * t;
        }
      }
    } else if (a2 > k2) {
      if (b < k2) {
        t = intersect(slice, ax2, ay2, bx, by, k2);
        if (trackMetrics) {
          slice.start = len + segLen * t;
        }
      }
    } else {
      addPoint(slice, ax2, ay2, az2);
    }
    if (b < k1 && a2 >= k1) {
      t = intersect(slice, ax2, ay2, bx, by, k1);
      exited = true;
    }
    if (b > k2 && a2 <= k2) {
      t = intersect(slice, ax2, ay2, bx, by, k2);
      exited = true;
    }
    if (!isPolygon && exited) {
      if (trackMetrics) {
        slice.end = len + segLen * t;
      }
      newGeom.push(slice);
      slice = newSlice(geom);
    }
    if (trackMetrics) {
      len += segLen;
    }
  }
  let last = geom.length - 3;
  const ax = geom[last];
  const ay = geom[last + 1];
  const az = geom[last + 2];
  const a = axis === 0 ? ax : ay;
  if (a >= k1 && a <= k2)
    addPoint(slice, ax, ay, az);
  last = slice.length - 3;
  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {
    addPoint(slice, slice[0], slice[1], slice[2]);
  }
  if (slice.length) {
    newGeom.push(slice);
  }
}
function newSlice(line) {
  const slice = [];
  slice.size = line.size;
  slice.start = line.start;
  slice.end = line.end;
  return slice;
}
function clipLines(geom, newGeom, k1, k2, axis, isPolygon) {
  for (const line of geom) {
    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);
  }
}
function addPoint(out, x2, y2, z) {
  out.push(x2, y2, z);
}
function intersectX(out, ax, ay, bx, by, x2) {
  const t = (x2 - ax) / (bx - ax);
  addPoint(out, x2, ay + (by - ay) * t, 1);
  return t;
}
function intersectY(out, ax, ay, bx, by, y2) {
  const t = (y2 - ay) / (by - ay);
  addPoint(out, ax + (bx - ax) * t, y2, 1);
  return t;
}

// dist/lib/geojson-tiler/wrap.js
function wrap(features, options) {
  const buffer = options.buffer / options.extent;
  let merged = features;
  const left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options);
  const right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
  if (left || right) {
    merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
    if (left) {
      merged = shiftFeatureCoords(left, 1).concat(merged);
    }
    if (right) {
      merged = merged.concat(shiftFeatureCoords(right, -1));
    }
  }
  return merged;
}
function shiftFeatureCoords(features, offset) {
  const newFeatures = [];
  for (let i2 = 0; i2 < features.length; i2++) {
    const feature = features[i2];
    const type = feature.type;
    let newGeometry;
    if (type === "Point" || type === "MultiPoint" || type === "LineString") {
      newGeometry = shiftCoords(feature.geometry, offset);
    } else if (type === "MultiLineString" || type === "Polygon") {
      newGeometry = [];
      for (const line of feature.geometry) {
        newGeometry.push(shiftCoords(line, offset));
      }
    } else if (type === "MultiPolygon") {
      newGeometry = [];
      for (const polygon of feature.geometry) {
        const newPolygon = [];
        for (const line of polygon) {
          newPolygon.push(shiftCoords(line, offset));
        }
        newGeometry.push(newPolygon);
      }
    }
    newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));
  }
  return newFeatures;
}
function shiftCoords(points, offset) {
  const newPoints = [];
  newPoints.size = points.size;
  if (points.start !== void 0) {
    newPoints.start = points.start;
    newPoints.end = points.end;
  }
  for (let i2 = 0; i2 < points.length; i2 += 3) {
    newPoints.push(points[i2] + offset, points[i2 + 1], points[i2 + 2]);
  }
  return newPoints;
}

// dist/lib/geojson-tiler/transform.js
function transformTile(tile, extent) {
  if (tile.transformed) {
    return tile;
  }
  const z2 = 1 << tile.z;
  const tx = tile.x;
  const ty = tile.y;
  for (const feature of tile.features) {
    const geom = feature.geometry;
    const type = feature.type;
    feature.geometry = [];
    if (type === 1) {
      for (let j = 0; j < geom.length; j += 2) {
        feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));
      }
    } else {
      for (let j = 0; j < geom.length; j++) {
        const ring = [];
        for (let k = 0; k < geom[j].length; k += 2) {
          ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));
        }
        feature.geometry.push(ring);
      }
    }
  }
  tile.transformed = true;
  return tile;
}
function transformPoint(x2, y2, extent, z2, tx, ty) {
  return [Math.round(extent * (x2 * z2 - tx)), Math.round(extent * (y2 * z2 - ty))];
}

// dist/lib/geojson-tiler/tile.js
function createTile(features, z, tx, ty, options) {
  const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);
  const tile = {
    features: [],
    numPoints: 0,
    numSimplified: 0,
    numFeatures: features.length,
    source: null,
    x: tx,
    y: ty,
    z,
    transformed: false,
    minX: 2,
    minY: 1,
    maxX: -1,
    maxY: 0
  };
  for (const feature of features) {
    addFeature(tile, feature, tolerance, options);
  }
  return tile;
}
function addFeature(tile, feature, tolerance, options) {
  const geom = feature.geometry;
  const type = feature.type;
  const simplified = [];
  tile.minX = Math.min(tile.minX, feature.minX);
  tile.minY = Math.min(tile.minY, feature.minY);
  tile.maxX = Math.max(tile.maxX, feature.maxX);
  tile.maxY = Math.max(tile.maxY, feature.maxY);
  if (type === "Point" || type === "MultiPoint") {
    for (let i2 = 0; i2 < geom.length; i2 += 3) {
      simplified.push(geom[i2], geom[i2 + 1]);
      tile.numPoints++;
      tile.numSimplified++;
    }
  } else if (type === "LineString") {
    addLine(simplified, geom, tile, tolerance, false, false);
  } else if (type === "MultiLineString" || type === "Polygon") {
    for (let i2 = 0; i2 < geom.length; i2++) {
      addLine(simplified, geom[i2], tile, tolerance, type === "Polygon", i2 === 0);
    }
  } else if (type === "MultiPolygon") {
    for (let k = 0; k < geom.length; k++) {
      const polygon = geom[k];
      for (let i2 = 0; i2 < polygon.length; i2++) {
        addLine(simplified, polygon[i2], tile, tolerance, true, i2 === 0);
      }
    }
  }
  if (simplified.length) {
    let tags = feature.tags || null;
    if (type === "LineString" && options.lineMetrics) {
      tags = {};
      for (const key in feature.tags)
        tags[key] = feature.tags[key];
      tags.mapbox_clip_start = geom.start / geom.size;
      tags.mapbox_clip_end = geom.end / geom.size;
    }
    const tileFeature = {
      geometry: simplified,
      type: type === "Polygon" || type === "MultiPolygon" ? 3 : type === "LineString" || type === "MultiLineString" ? 2 : 1,
      tags
    };
    if (feature.id !== null) {
      tileFeature.id = feature.id;
    }
    tile.features.push(tileFeature);
  }
}
function addLine(result, geom, tile, tolerance, isPolygon, isOuter) {
  const sqTolerance = tolerance * tolerance;
  if (tolerance > 0 && geom.size < (isPolygon ? sqTolerance : tolerance)) {
    tile.numPoints += geom.length / 3;
    return;
  }
  const ring = [];
  for (let i2 = 0; i2 < geom.length; i2 += 3) {
    if (tolerance === 0 || geom[i2 + 2] > sqTolerance) {
      tile.numSimplified++;
      ring.push(geom[i2], geom[i2 + 1]);
    }
    tile.numPoints++;
  }
  if (isPolygon)
    rewind(ring, isOuter);
  result.push(ring);
}
function rewind(ring, clockwise) {
  let area = 0;
  for (let i2 = 0, j = ring.length - 2; i2 < ring.length; j = i2, i2 += 2) {
    area += (ring[i2] - ring[j]) * (ring[i2 + 1] + ring[j + 1]);
  }
  if (area > 0 === clockwise) {
    for (let i2 = 0, len = ring.length; i2 < len / 2; i2 += 2) {
      const x2 = ring[i2];
      const y2 = ring[i2 + 1];
      ring[i2] = ring[len - 2 - i2];
      ring[i2 + 1] = ring[len - 1 - i2];
      ring[len - 2 - i2] = x2;
      ring[len - 1 - i2] = y2;
    }
  }
}

// dist/lib/geojson-tiler/geojson-tiler.js
var DEFAULT_OPTIONS = {
  maxZoom: 14,
  // max zoom to preserve detail on
  indexMaxZoom: 5,
  // max zoom in the tile index
  indexMaxPoints: 1e5,
  // max number of points per tile in the tile index
  tolerance: 3,
  // simplification tolerance (higher means simpler)
  extent: 4096,
  // tile extent
  buffer: 64,
  // tile buffer on each side
  lineMetrics: false,
  // whether to calculate line metrics
  // @ts-expect-error Ensures all these required params have defaults
  promoteId: void 0,
  // name of a feature property to be promoted to feature.id
  generateId: false,
  // whether to generate feature ids. Cannot be used with promoteId
  debug: 0
  // logging level (0, 1 or 2)
};
var GeoJSONTiler = class {
  options;
  // tiles and tileCoords are part of the public API
  tiles = {};
  tileCoords = [];
  stats = {};
  total = 0;
  constructor(data, options) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
    options = this.options;
    const debug = options.debug;
    if (debug)
      console.time("preprocess data");
    if (this.options.maxZoom < 0 || this.options.maxZoom > 24) {
      throw new Error("maxZoom should be in the 0-24 range");
    }
    if (options.promoteId && this.options.generateId) {
      throw new Error("promoteId and generateId cannot be used together.");
    }
    let features = convert(data, options);
    if (debug) {
      console.timeEnd("preprocess data");
      console.log("index: maxZoom: %d, maxPoints: %d", options.indexMaxZoom, options.indexMaxPoints);
      console.time("generate tiles");
    }
    features = wrap(features, this.options);
    if (features.length) {
      this.splitTile(features, 0, 0, 0);
    }
    if (debug) {
      if (features.length) {
        console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints);
      }
      console.timeEnd("generate tiles");
      console.log("tiles generated:", this.total, JSON.stringify(this.stats));
    }
  }
  /**
   * Get a tile at the specified index
   * @param z
   * @param x
   * @param y
   * @returns
   */
  // eslint-disable-next-line complexity, max-statements
  getTile(z, x2, y2) {
    const { extent, debug } = this.options;
    if (z < 0 || z > 24) {
      return null;
    }
    const z2 = 1 << z;
    x2 = x2 + z2 & z2 - 1;
    const id = toID(z, x2, y2);
    if (this.tiles[id]) {
      return transformTile(this.tiles[id], extent);
    }
    if (debug > 1)
      console.log("drilling down to z%d-%d-%d", z, x2, y2);
    let z0 = z;
    let x0 = x2;
    let y0 = y2;
    let parent;
    while (!parent && z0 > 0) {
      z0--;
      x0 = x0 >> 1;
      y0 = y0 >> 1;
      parent = this.tiles[toID(z0, x0, y0)];
    }
    if (!parent || !parent.source) {
      return null;
    }
    if (debug > 1) {
      console.log("found parent tile z%d-%d-%d", z0, x0, y0);
      console.time("drilling down");
    }
    this.splitTile(parent.source, z0, x0, y0, z, x2, y2);
    if (debug > 1) {
      console.timeEnd("drilling down");
    }
    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;
  }
  /**
   * splits features from a parent tile to sub-tiles.
   * @param z, x, and y are the coordinates of the parent tile
   * @param cz, cx, and cy are the coordinates of the target tile
   *
   * If no target tile is specified, splitting stops when we reach the maximum
   * zoom or the number of points is low as specified in the options.
   */
  // eslint-disable-next-line max-params, max-statements, complexity
  splitTile(features, z, x2, y2, cz, cx, cy) {
    const stack = [features, z, x2, y2];
    const options = this.options;
    const debug = options.debug;
    while (stack.length) {
      y2 = stack.pop();
      x2 = stack.pop();
      z = stack.pop();
      features = stack.pop();
      const z2 = 1 << z;
      const id = toID(z, x2, y2);
      let tile = this.tiles[id];
      if (!tile) {
        if (debug > 1) {
          console.time("creation");
        }
        tile = this.tiles[id] = createTile(features, z, x2, y2, options);
        this.tileCoords.push({ z, x: x2, y: y2 });
        if (debug) {
          if (debug > 1) {
            console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", z, x2, y2, tile.numFeatures, tile.numPoints, tile.numSimplified);
            console.timeEnd("creation");
          }
          const key = `z${z}`;
          this.stats[key] = (this.stats[key] || 0) + 1;
          this.total++;
        }
      }
      tile.source = features;
      if (cz === void 0) {
        if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints)
          continue;
      } else if (z === options.maxZoom || z === cz) {
        continue;
      } else if (cz !== void 0) {
        const zoomSteps = cz - z;
        if (x2 !== cx >> zoomSteps || y2 !== cy >> zoomSteps)
          continue;
      }
      tile.source = null;
      if (features.length === 0)
        continue;
      if (debug > 1)
        console.time("clipping");
      const k1 = 0.5 * options.buffer / options.extent;
      const k2 = 0.5 - k1;
      const k3 = 0.5 + k1;
      const k4 = 1 + k1;
      let tl = null;
      let bl = null;
      let tr = null;
      let br = null;
      let left = clip(features, z2, x2 - k1, x2 + k3, 0, tile.minX, tile.maxX, options);
      let right = clip(features, z2, x2 + k2, x2 + k4, 0, tile.minX, tile.maxX, options);
      features = null;
      if (left) {
        tl = clip(left, z2, y2 - k1, y2 + k3, 1, tile.minY, tile.maxY, options);
        bl = clip(left, z2, y2 + k2, y2 + k4, 1, tile.minY, tile.maxY, options);
        left = null;
      }
      if (right) {
        tr = clip(right, z2, y2 - k1, y2 + k3, 1, tile.minY, tile.maxY, options);
        br = clip(right, z2, y2 + k2, y2 + k4, 1, tile.minY, tile.maxY, options);
        right = null;
      }
      if (debug > 1)
        console.timeEnd("clipping");
      stack.push(tl || [], z + 1, x2 * 2, y2 * 2);
      stack.push(bl || [], z + 1, x2 * 2, y2 * 2 + 1);
      stack.push(tr || [], z + 1, x2 * 2 + 1, y2 * 2);
      stack.push(br || [], z + 1, x2 * 2 + 1, y2 * 2 + 1);
    }
  }
};
function toID(z, x2, y2) {
  return ((1 << z) * y2 + x2) * 32 + z;
}
//# sourceMappingURL=index.cjs.map
