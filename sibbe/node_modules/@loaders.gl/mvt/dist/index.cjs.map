{
  "version": 3,
  "sources": ["index.js", "lib/parse-mvt.js", "helpers/mapbox-util-functions.js", "lib/mapbox-vector-tile/vector-tile-feature.js", "lib/mapbox-vector-tile/vector-tile-layer.js", "lib/mapbox-vector-tile/vector-tile.js", "helpers/binary-util-functions.js", "lib/binary-vector-tile/vector-tile-feature.js", "lib/binary-vector-tile/vector-tile-layer.js", "lib/binary-vector-tile/vector-tile.js", "mvt-loader.js", "lib/parse-tilejson.js", "tilejson-loader.js", "mvt-source.js", "lib/geojson-tiler/simplify.js", "lib/geojson-tiler/feature.js", "lib/geojson-tiler/convert.js", "lib/geojson-tiler/clip.js", "lib/geojson-tiler/wrap.js", "lib/geojson-tiler/transform.js", "lib/geojson-tiler/tile.js", "lib/geojson-tiler/geojson-tiler.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { MVTLoader, MVTWorkerLoader } from \"./mvt-loader.js\";\nexport { TileJSONLoader } from \"./tilejson-loader.js\";\nexport { MVTSource } from \"./mvt-source.js\";\nexport { GeoJSONTiler } from \"./lib/geojson-tiler/geojson-tiler.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport { VectorTile } from \"./mapbox-vector-tile/vector-tile.js\";\nimport { BinaryVectorTile } from \"./binary-vector-tile/vector-tile.js\";\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport function parseMVT(arrayBuffer, options) {\n    const mvtOptions = normalizeOptions(options);\n    const shape = options?.gis?.format || options?.mvt?.shape || options?.shape;\n    switch (shape) {\n        case 'columnar-table': // binary + some JS arrays\n            return { shape: 'columnar-table', data: parseToBinary(arrayBuffer, mvtOptions) };\n        case 'geojson-table': {\n            const table = {\n                shape: 'geojson-table',\n                type: 'FeatureCollection',\n                features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)\n            };\n            return table;\n        }\n        case 'geojson':\n            return parseToGeojsonFeatures(arrayBuffer, mvtOptions);\n        case 'binary-geometry':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        case 'binary':\n            return parseToBinary(arrayBuffer, mvtOptions);\n        default:\n            throw new Error(shape || 'undefined shape');\n    }\n}\nfunction parseToBinary(arrayBuffer, options) {\n    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);\n    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);\n    // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n    // TODO decide where to store extra fields like byteLength (header etc) and document\n    // @ts-ignore\n    binaryData.byteLength = arrayBuffer.byteLength;\n    return binaryData;\n}\nfunction parseToFlatGeoJson(arrayBuffer, options) {\n    const features = [];\n    const geometryInfo = {\n        coordLength: 2,\n        pointPositionsCount: 0,\n        pointFeaturesCount: 0,\n        linePositionsCount: 0,\n        linePathsCount: 0,\n        lineFeaturesCount: 0,\n        polygonPositionsCount: 0,\n        polygonObjectsCount: 0,\n        polygonRingsCount: 0,\n        polygonFeaturesCount: 0\n    };\n    if (arrayBuffer.byteLength <= 0) {\n        return [features, geometryInfo];\n    }\n    const tile = new BinaryVectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n            const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return [features, geometryInfo];\n}\nfunction parseToGeojsonFeatures(arrayBuffer, options) {\n    if (arrayBuffer.byteLength <= 0) {\n        return [];\n    }\n    const features = [];\n    const tile = new VectorTile(new Protobuf(arrayBuffer));\n    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);\n    selectedLayers.forEach((layerName) => {\n        const vectorTileLayer = tile.layers[layerName];\n        if (!vectorTileLayer) {\n            return;\n        }\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n            const vectorTileFeature = vectorTileLayer.feature(i);\n            const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);\n            features.push(decodedFeature);\n        }\n    });\n    return features;\n}\nfunction normalizeOptions(options) {\n    if (!options?.mvt) {\n        throw new Error('mvt options required');\n    }\n    // Validate\n    const wgs84Coordinates = options.mvt?.coordinates === 'wgs84';\n    const { tileIndex } = options.mvt;\n    const hasTileIndex = tileIndex &&\n        Number.isFinite(tileIndex.x) &&\n        Number.isFinite(tileIndex.y) &&\n        Number.isFinite(tileIndex.z);\n    if (wgs84Coordinates && !hasTileIndex) {\n        throw new Error('MVT Loader: WGS84 coordinates need tileIndex property');\n    }\n    return options.mvt;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(feature, options, layerName) {\n    const decodedFeature = feature.toGeoJSON(\n    // @ts-expect-error What is going on here?\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty) {\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(feature, options, layerName) {\n    const decodedFeature = feature.toBinaryCoordinates(\n    // @ts-expect-error\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary);\n    // Add layer name to GeoJSON properties\n    if (options.layerProperty && decodedFeature.properties) {\n        decodedFeature.properties[options.layerProperty] = layerName;\n    }\n    return decodedFeature;\n}\n/**\n * @param line\n * @param feature\n */\nfunction transformToLocalCoordinates(line, feature) {\n    // This function transforms local coordinates in a\n    // [0 - bufferSize, this.extent + bufferSize] range to a\n    // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n    // The resulting extent would be 1.\n    const { extent } = feature;\n    for (let i = 0; i < line.length; i++) {\n        const p = line[i];\n        p[0] /= extent;\n        p[1] /= extent;\n    }\n}\nfunction transformToLocalCoordinatesBinary(data, feature) {\n    // For the binary code path, the feature data is just\n    // one big flat array, so we just divide each value\n    const { extent } = feature;\n    for (let i = 0, il = data.length; i < il; ++i) {\n        data[i] /= extent;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n    if (len <= 1)\n        return [rings];\n    const polygons = [];\n    let polygon;\n    let ccw;\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0)\n            continue; // eslint-disable-line no-continue\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon)\n                polygons.push(polygon);\n            polygon = [rings[i]];\n        }\n        else if (polygon)\n            polygon.push(rings[i]);\n    }\n    if (polygon)\n        polygons.push(polygon);\n    return polygons;\n}\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n    }\n    return sum;\n}\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag, feature, pbf) {\n    if (feature && pbf) {\n        if (tag === 1)\n            feature.id = pbf.readVarint();\n        else if (tag === 2)\n            readTag(pbf, feature);\n        else if (tag === 3)\n            feature.type = pbf.readVarint();\n        else if (tag === 4)\n            feature._geometry = pbf.pos;\n    }\n}\n/**\n *\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const key = feature._keys[pbf.readVarint()];\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { readFeature, classifyRings } from \"../../helpers/mapbox-util-functions.js\";\nexport class VectorTileFeature {\n    properties;\n    extent;\n    type;\n    id;\n    _pbf;\n    _geometry;\n    _keys;\n    _values;\n    static get types() {\n        return ['Unknown', 'Point', 'LineString', 'Polygon'];\n    }\n    constructor(pbf, end, extent, keys, values) {\n        // Public\n        this.properties = {};\n        this.extent = extent;\n        this.type = 0;\n        this.id = null;\n        // Private\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n        pbf.readFields(readFeature, this, end);\n    }\n    // eslint-disable-next-line complexity, max-statements\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        const lines = [];\n        let line;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) {\n                    // moveTo\n                    if (line)\n                        lines.push(line);\n                    line = [];\n                }\n                if (line)\n                    line.push([x, y]);\n            }\n            else if (cmd === 7) {\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (line) {\n                    line.push(line[0].slice()); // closePolygon\n                }\n            }\n            else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        if (line)\n            lines.push(line);\n        return lines;\n    }\n    // eslint-disable-next-line max-statements\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n        let x1 = Infinity;\n        let x2 = -Infinity;\n        let y1 = Infinity;\n        let y2 = -Infinity;\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1)\n                    x1 = x;\n                if (x > x2)\n                    x2 = x;\n                if (y < y1)\n                    y1 = y;\n                if (y > y2)\n                    y2 = y;\n            }\n            else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return [x1, y1, x2, y2];\n    }\n    _toGeoJSON(transform) {\n        let coords = this.loadGeometry();\n        let type = VectorTileFeature.types[this.type];\n        let i;\n        let j;\n        // eslint-disable-next-line default-case\n        switch (this.type) {\n            case 1:\n                const points = [];\n                for (i = 0; i < coords.length; i++) {\n                    points[i] = coords[i][0];\n                }\n                coords = points;\n                transform(coords, this);\n                break;\n            case 2:\n                for (i = 0; i < coords.length; i++) {\n                    transform(coords[i], this);\n                }\n                break;\n            case 3:\n                coords = classifyRings(coords);\n                for (i = 0; i < coords.length; i++) {\n                    for (j = 0; j < coords[i].length; j++) {\n                        transform(coords[i][j], this);\n                    }\n                }\n                break;\n        }\n        if (coords.length === 1) {\n            coords = coords[0];\n        }\n        else {\n            type = `Multi${type}`;\n        }\n        const result = {\n            type: 'Feature',\n            geometry: {\n                type,\n                coordinates: coords\n            },\n            properties: this.properties\n        };\n        if (this.id !== null) {\n            result.id = this.id;\n        }\n        return result;\n    }\n    toGeoJSON(options) {\n        if (typeof options === 'function') {\n            return this._toGeoJSON(options);\n        }\n        const { x, y, z } = options;\n        const size = this.extent * Math.pow(2, z);\n        const x0 = this.extent * x;\n        const y0 = this.extent * y;\n        function project(line) {\n            for (let j = 0; j < line.length; j++) {\n                const p = line[j];\n                p[0] = ((p[0] + x0) * 360) / size - 180;\n                const y2 = 180 - ((p[1] + y0) * 360) / size;\n                p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n            }\n        }\n        return this._toGeoJSON(project);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { VectorTileFeature } from \"./vector-tile-feature.js\";\nexport class VectorTileLayer {\n    version;\n    name;\n    extent;\n    length;\n    _pbf;\n    _keys;\n    _values;\n    _features;\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n        // Private\n        this._pbf = pbf;\n        this._keys = [];\n        this._values = [];\n        this._features = [];\n        pbf.readFields(readLayer, this, end);\n        this.length = this._features.length;\n    }\n    /**\n     * return feature `i` from this layer as a `VectorTileFeature`\n     * @param index\n     * @returns feature\n     */\n    feature(i) {\n        if (i < 0 || i >= this._features.length) {\n            throw new Error('feature index out of bounds');\n        }\n        this._pbf.pos = this._features[i];\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    }\n}\n/**\n *\n * @param tag\n * @param layer\n * @param pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (layer && pbf) {\n        if (tag === 15)\n            layer.version = pbf.readVarint();\n        else if (tag === 1)\n            layer.name = pbf.readString();\n        else if (tag === 5)\n            layer.extent = pbf.readVarint();\n        else if (tag === 2)\n            layer._features.push(pbf.pos);\n        else if (tag === 3)\n            layer._keys.push(pbf.readString());\n        else if (tag === 4)\n            layer._values.push(readValueMessage(pbf));\n    }\n}\n/**\n *\n * @param pbf\n * @returns value\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n        value =\n            tag === 1\n                ? pbf.readString()\n                : tag === 2\n                    ? pbf.readFloat()\n                    : tag === 3\n                        ? pbf.readDouble()\n                        : tag === 4\n                            ? pbf.readVarint64()\n                            : tag === 5\n                                ? pbf.readVarint()\n                                : tag === 6\n                                    ? pbf.readSVarint()\n                                    : tag === 7\n                                        ? pbf.readBoolean()\n                                        : null;\n    }\n    return value;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport { VectorTileLayer } from \"./vector-tile-layer.js\";\nexport class VectorTile {\n    layers;\n    constructor(pbf, end) {\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n/**\n *\n * @param tag\n * @param layers\n * @param pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        if (pbf) {\n            const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n            if (layer.length && layers) {\n                layers[layer.name] = layer;\n            }\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRings(geom) {\n    const len = geom.indices.length;\n    const type = 'Polygon';\n    if (len <= 1) {\n        return {\n            type,\n            data: geom.data,\n            areas: [[getPolygonSignedArea(geom.data)]],\n            indices: [geom.indices]\n        };\n    }\n    const areas = [];\n    const polygons = [];\n    let ringAreas = [];\n    let polygon = [];\n    let ccw;\n    let offset = 0;\n    for (let endIndex, i = 0, startIndex; i < len; i++) {\n        startIndex = geom.indices[i] - offset;\n        endIndex = geom.indices[i + 1] - offset || geom.data.length;\n        const shape = geom.data.slice(startIndex, endIndex);\n        const area = getPolygonSignedArea(shape);\n        if (area === 0) {\n            // This polygon has no area, so remove it from the shape\n            // Remove the section from the data array\n            const before = geom.data.slice(0, startIndex);\n            const after = geom.data.slice(endIndex);\n            geom.data = before.concat(after);\n            // Need to offset any remaining indices as we have\n            // modified the data buffer\n            offset += endIndex - startIndex;\n            // Do not add this index to the output and process next shape\n            continue; // eslint-disable-line no-continue\n        }\n        if (ccw === undefined)\n            ccw = area < 0;\n        if (ccw === area < 0) {\n            if (polygon.length) {\n                areas.push(ringAreas);\n                polygons.push(polygon);\n            }\n            polygon = [startIndex];\n            ringAreas = [area];\n        }\n        else {\n            ringAreas.push(area);\n            polygon.push(startIndex);\n        }\n    }\n    if (ringAreas)\n        areas.push(ringAreas);\n    if (polygon.length)\n        polygons.push(polygon);\n    return { type, areas, indices: polygons, data: geom.data };\n}\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function project(data, x0, y0, size) {\n    for (let j = 0, jl = data.length; j < jl; j += 2) {\n        data[j] = ((data[j] + x0) * 360) / size - 180;\n        const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n        data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n    }\n}\n/**\n * All code below is unchanged from the original Mapbox implemenation\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag, feature, pbf) {\n    if (feature && pbf) {\n        if (tag === 1)\n            feature.id = pbf.readVarint();\n        else if (tag === 2)\n            readTag(pbf, feature);\n        else if (tag === 3)\n            feature.type = pbf.readVarint();\n        else if (tag === 4)\n            feature._geometry = pbf.pos;\n    }\n}\n/**\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const key = feature._keys[pbf.readVarint()];\n        const value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { classifyRings, project, readFeature } from \"../../helpers/binary-util-functions.js\";\n// Reduce GC by reusing variables\nlet endPos;\nlet cmd;\nlet cmdLen;\nlet length;\nlet x;\nlet y;\nlet i;\nexport const TEST_EXPORTS = {\n    classifyRings\n};\nexport class BinaryVectorTileFeature {\n    properties;\n    extent;\n    type;\n    id;\n    _pbf;\n    _geometry;\n    _keys;\n    _values;\n    _geometryInfo;\n    // eslint-disable-next-line max-params\n    constructor(pbf, end, extent, keys, values, geometryInfo) {\n        // Public\n        this.properties = {};\n        this.extent = extent;\n        this.type = 0;\n        this.id = null;\n        // Private\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n        this._geometryInfo = geometryInfo;\n        pbf.readFields(readFeature, this, end);\n    }\n    // eslint-disable-next-line complexity, max-statements\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n        endPos = pbf.readVarint() + pbf.pos;\n        cmd = 1;\n        length = 0;\n        x = 0;\n        y = 0;\n        i = 0;\n        // Note: I attempted to replace the `data` array with a\n        // Float32Array, but performance was worse, both using\n        // `set()` and direct index access. Also, we cannot\n        // know how large the buffer should be, so it would\n        // increase memory usage\n        const indices = []; // Indices where geometries start\n        const data = []; // Flat array of coordinate data\n        while (pbf.pos < endPos) {\n            if (length <= 0) {\n                cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n            length--;\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (cmd === 1) {\n                    // New line\n                    indices.push(i);\n                }\n                data.push(x, y);\n                i += 2;\n            }\n            else if (cmd === 7) {\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (i > 0) {\n                    const start = indices[indices.length - 1]; // start index of polygon\n                    data.push(data[start], data[start + 1]); // closePolygon\n                    i += 2;\n                }\n            }\n            else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n        return { data, indices };\n    }\n    /**\n     *\n     * @param transform\n     * @returns result\n     */\n    _toBinaryCoordinates(transform) {\n        // Expands the protobuf data to an intermediate Flat GeoJSON\n        // data format, which maps closely to the binary data buffers.\n        // It is similar to GeoJSON, but rather than storing the coordinates\n        // in multidimensional arrays, we have a 1D `data` with all the\n        // coordinates, and then index into this using the `indices`\n        // parameter, e.g.\n        //\n        // geometry: {\n        //   type: 'Point', data: [1,2], indices: [0]\n        // }\n        // geometry: {\n        //   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n        // }\n        // geometry: {\n        //   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n        // }\n        // Thus the indices member lets us look up the relevant range\n        // from the data array.\n        // The Multi* versions of the above types share the same data\n        // structure, just with multiple elements in the indices array\n        const geom = this.loadGeometry();\n        let geometry;\n        // Apply the supplied transformation to data\n        transform(geom.data, this);\n        const coordLength = 2;\n        // eslint-disable-next-line default-case\n        switch (this.type) {\n            case 1: // Point\n                this._geometryInfo.pointFeaturesCount++;\n                this._geometryInfo.pointPositionsCount += geom.indices.length;\n                geometry = { type: 'Point', ...geom };\n                break;\n            case 2: // LineString\n                this._geometryInfo.lineFeaturesCount++;\n                this._geometryInfo.linePathsCount += geom.indices.length;\n                this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n                geometry = { type: 'LineString', ...geom };\n                break;\n            case 3: // Polygon\n                geometry = classifyRings(geom);\n                // Unlike Point & LineString geom.indices is a 2D array, thanks\n                // to the classifyRings method\n                this._geometryInfo.polygonFeaturesCount++;\n                this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n                for (const indices of geometry.indices) {\n                    this._geometryInfo.polygonRingsCount += indices.length;\n                }\n                this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n                break;\n            default:\n                throw new Error(`Invalid geometry type: ${this.type}`);\n        }\n        const result = { type: 'Feature', geometry, properties: this.properties };\n        if (this.id !== null) {\n            result.id = this.id;\n        }\n        return result;\n    }\n    toBinaryCoordinates(options) {\n        if (typeof options === 'function') {\n            return this._toBinaryCoordinates(options);\n        }\n        const { x, y, z } = options;\n        const size = this.extent * Math.pow(2, z);\n        const x0 = this.extent * x;\n        const y0 = this.extent * y;\n        return this._toBinaryCoordinates((data) => project(data, x0, y0, size));\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n/* eslint-disable indent */\n// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport { BinaryVectorTileFeature } from \"./vector-tile-feature.js\";\nexport class BinaryVectorTileLayer {\n    version;\n    name;\n    extent;\n    length;\n    _pbf;\n    _keys;\n    _values;\n    _features;\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n        // Private\n        this._pbf = pbf;\n        this._keys = [];\n        this._values = [];\n        this._features = [];\n        pbf.readFields(readLayer, this, end);\n        this.length = this._features.length;\n    }\n    /**\n     * return feature `i` from this layer as a `BinaryVectorTileFeature`\n     *\n     * @param index\n     * @param geometryInfo\n     * @returns {BinaryVectorTileFeature}\n     */\n    feature(i, geometryInfo) {\n        if (i < 0 || i >= this._features.length) {\n            throw new Error('feature index out of bounds');\n        }\n        this._pbf.pos = this._features[i];\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new BinaryVectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);\n    }\n}\n/**\n *\n * @param tag\n * @param layer\n * @param pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (layer && pbf) {\n        if (tag === 15)\n            layer.version = pbf.readVarint();\n        else if (tag === 1)\n            layer.name = pbf.readString();\n        else if (tag === 5)\n            layer.extent = pbf.readVarint();\n        else if (tag === 2)\n            layer._features.push(pbf.pos);\n        else if (tag === 3)\n            layer._keys.push(pbf.readString());\n        else if (tag === 4)\n            layer._values.push(readValueMessage(pbf));\n    }\n}\n/**\n *\n * @param pbf\n * @returns value\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n        value =\n            tag === 1\n                ? pbf.readString()\n                : tag === 2\n                    ? pbf.readFloat()\n                    : tag === 3\n                        ? pbf.readDouble()\n                        : tag === 4\n                            ? pbf.readVarint64()\n                            : tag === 5\n                                ? pbf.readVarint()\n                                : tag === 6\n                                    ? pbf.readSVarint()\n                                    : tag === 7\n                                        ? pbf.readBoolean()\n                                        : null;\n    }\n    return value;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport { BinaryVectorTileLayer } from \"./vector-tile-layer.js\";\nexport class BinaryVectorTile {\n    layers;\n    constructor(pbf, end) {\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n/**\n *\n * @param tag\n * @param layers\n * @param pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        if (pbf) {\n            const layer = new BinaryVectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n            if (layer.length && layers) {\n                layers[layer.name] = layer;\n            }\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { parseMVT } from \"./lib/parse-mvt.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n/**\n * Worker loader for the Mapbox Vector Tile format\n */\nexport const MVTWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Mapbox Vector Tile',\n    id: 'mvt',\n    module: 'mvt',\n    version: VERSION,\n    // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'\n    extensions: ['mvt', 'pbf'],\n    mimeTypes: [\n        // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile\n        'application/vnd.mapbox-vector-tile',\n        'application/x-protobuf'\n        // 'application/octet-stream'\n    ],\n    worker: true,\n    category: 'geometry',\n    options: {\n        mvt: {\n            shape: 'geojson',\n            coordinates: 'local',\n            layerProperty: 'layerName',\n            layers: undefined,\n            tileIndex: null\n        }\n    }\n};\n/**\n * Loader for the Mapbox Vector Tile format\n */\nexport const MVTLoader = {\n    ...MVTWorkerLoader,\n    parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),\n    parseSync: parseMVT,\n    binary: true\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst isObject = (x) => x !== null && typeof x === 'object';\n/**\n * Parse TileJSON from metadata\n * @param jsonMetadata - metadata object\n * @param options - options\n * @returns - parsed TileJSON\n */\n// eslint-disable-next-line complexity\nexport function parseTileJSON(jsonMetadata, options) {\n    if (!jsonMetadata || !isObject(jsonMetadata)) {\n        return null;\n    }\n    let tileJSON = {\n        name: jsonMetadata.name || '',\n        description: jsonMetadata.description || ''\n    };\n    // tippecanoe\n    if (typeof jsonMetadata.generator === 'string') {\n        tileJSON.generator = jsonMetadata.generator;\n    }\n    if (typeof jsonMetadata.generator_options === 'string') {\n        tileJSON.generatorOptions = jsonMetadata.generator_options;\n    }\n    // Tippecanoe emits `antimeridian_adjusted_bounds` instead of `bounds`\n    tileJSON.boundingBox =\n        parseBounds(jsonMetadata.bounds) || parseBounds(jsonMetadata.antimeridian_adjusted_bounds);\n    // TODO - can be undefined - we could set to center of bounds...\n    tileJSON.center = parseCenter(jsonMetadata.center);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.maxZoom = safeParseFloat(jsonMetadata.maxzoom);\n    // TODO - can be undefined, we could extract from layers...\n    tileJSON.minZoom = safeParseFloat(jsonMetadata.minzoom);\n    // Look for nested metadata embedded in .json field\n    // TODO - document what source this applies to, when is this needed?\n    if (typeof jsonMetadata?.json === 'string') {\n        // try to parse json\n        try {\n            tileJSON.metaJson = JSON.parse(jsonMetadata.json);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.warn('Failed to parse tilejson.json field', error);\n            // do nothing\n        }\n    }\n    // Look for fields in tilestats\n    const tilestats = jsonMetadata.tilestats || tileJSON.metaJson?.tilestats;\n    const tileStatsLayers = parseTilestatsLayers(tilestats, options);\n    const tileJSONlayers = parseTileJSONLayers(jsonMetadata.vector_layers); // eslint-disable-line camelcase\n    // TODO - merge in description from tilejson\n    const layers = mergeLayers(tileJSONlayers, tileStatsLayers);\n    tileJSON = {\n        ...tileJSON,\n        layers\n    };\n    if (tileJSON.maxZoom === null && layers.length > 0) {\n        tileJSON.maxZoom = layers[0].maxZoom || null;\n    }\n    if (tileJSON.minZoom === null && layers.length > 0) {\n        tileJSON.minZoom = layers[0].minZoom || null;\n    }\n    return tileJSON;\n}\nfunction parseTileJSONLayers(layers) {\n    // Look for fields in vector_layers\n    if (!Array.isArray(layers)) {\n        return [];\n    }\n    return layers.map((layer) => parseTileJSONLayer(layer));\n}\nfunction parseTileJSONLayer(layer) {\n    const fields = Object.entries(layer.fields || []).map(([key, datatype]) => ({\n        name: key,\n        ...attributeTypeToFieldType(String(datatype))\n    }));\n    const layer2 = { ...layer };\n    delete layer2.fields;\n    return {\n        name: layer.id || '',\n        ...layer2,\n        fields\n    };\n}\n/** parse Layers array from tilestats */\nfunction parseTilestatsLayers(tilestats, options) {\n    if (isObject(tilestats) && Array.isArray(tilestats.layers)) {\n        // we are in luck!\n        return tilestats.layers.map((layer) => parseTilestatsForLayer(layer, options));\n    }\n    return [];\n}\nfunction parseTilestatsForLayer(layer, options) {\n    const fields = [];\n    const indexedAttributes = {};\n    const attributes = layer.attributes || [];\n    for (const attribute of attributes) {\n        const name = attribute.attribute;\n        if (typeof name === 'string') {\n            // TODO - code copied from kepler.gl, need sample tilestats files to test\n            if (name.split('|').length > 1) {\n                // indexed field\n                const fname = name.split('|')[0];\n                indexedAttributes[fname] = indexedAttributes[fname] || [];\n                indexedAttributes[fname].push(attribute);\n                // eslint-disable-next-line no-console\n                console.warn('ignoring tilestats indexed field', fname);\n            }\n            else if (!fields[name]) {\n                fields.push(attributeToField(attribute, options));\n            }\n            else {\n                // return (fields[name], attribute);\n            }\n        }\n    }\n    return {\n        name: layer.layer || '',\n        dominantGeometry: layer.geometry,\n        fields\n    };\n}\nfunction mergeLayers(layers, tilestatsLayers) {\n    return layers.map((layer) => {\n        const tilestatsLayer = tilestatsLayers.find((tsLayer) => tsLayer.name === layer.name);\n        // For aesthetics in JSON dumps, we preserve field order (make sure layers is last)\n        const fields = tilestatsLayer?.fields || [];\n        const layer2 = { ...layer };\n        delete layer2.fields;\n        return {\n            ...layer2,\n            ...tilestatsLayer,\n            fields\n        };\n    });\n}\n/**\n * bounds should be [minLng, minLat, maxLng, maxLat]\n *`[[w, s], [e, n]]`, indicates the limits of the bounding box using the axis units and order of the specified CRS.\n */\nfunction parseBounds(bounds) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [ -180, -85.05112877980659, 180, 85.0511287798066 ]\n    const result = fromArrayOrString(bounds);\n    // validate bounds\n    if (Array.isArray(result) &&\n        result.length === 4 &&\n        [result[0], result[2]].every(isLng) &&\n        [result[1], result[3]].every(isLat)) {\n        return [\n            [result[0], result[1]],\n            [result[2], result[3]]\n        ];\n    }\n    return undefined;\n}\nfunction parseCenter(center) {\n    // supported formats\n    // string: \"-96.657715,40.126127,-90.140061,43.516689\",\n    // array: [-91.505127,41.615442,14]\n    const result = fromArrayOrString(center);\n    if (Array.isArray(result) &&\n        result.length === 3 &&\n        isLng(result[0]) &&\n        isLat(result[1]) &&\n        isZoom(result[2])) {\n        return result;\n    }\n    return null;\n}\nfunction safeParseFloat(input) {\n    const result = typeof input === 'string' ? parseFloat(input) : typeof input === 'number' ? input : null;\n    return result === null || isNaN(result) ? null : result;\n}\n// https://github.com/mapbox/tilejson-spec/tree/master/2.2.0\nfunction isLat(num) {\n    return Number.isFinite(num) && num <= 90 && num >= -90;\n}\nfunction isLng(num) {\n    return Number.isFinite(num) && num <= 180 && num >= -180;\n}\nfunction isZoom(num) {\n    return Number.isFinite(num) && num >= 0 && num <= 22;\n}\nfunction fromArrayOrString(data) {\n    if (typeof data === 'string') {\n        return data.split(',').map(parseFloat);\n    }\n    else if (Array.isArray(data)) {\n        return data;\n    }\n    return null;\n}\n// possible types https://github.com/mapbox/tippecanoe#modifying-feature-attributes\nconst attrTypeMap = {\n    number: {\n        type: 'float32'\n    },\n    numeric: {\n        type: 'float32'\n    },\n    string: {\n        type: 'utf8'\n    },\n    vachar: {\n        type: 'utf8'\n    },\n    float: {\n        type: 'float32'\n    },\n    int: {\n        type: 'int32'\n    },\n    int4: {\n        type: 'int32'\n    },\n    boolean: {\n        type: 'boolean'\n    },\n    bool: {\n        type: 'boolean'\n    }\n};\nfunction attributeToField(attribute = {}, options) {\n    const fieldTypes = attributeTypeToFieldType(attribute.type);\n    const field = {\n        name: attribute.attribute,\n        // what happens if attribute type is string...\n        // filterProps: getFilterProps(fieldTypes.type, attribute),\n        ...fieldTypes\n    };\n    // attribute: \"_season_peaks_color\"\n    // count: 1000\n    // max: 0.95\n    // min: 0.24375\n    // type: \"number\"\n    if (typeof attribute.min === 'number') {\n        field.min = attribute.min;\n    }\n    if (typeof attribute.max === 'number') {\n        field.max = attribute.max;\n    }\n    if (typeof attribute.count === 'number') {\n        field.uniqueValueCount = attribute.count;\n    }\n    if (attribute.values) {\n        // Too much data? Add option?\n        field.values = attribute.values;\n    }\n    if (field.values && typeof options.maxValues === 'number') {\n        // Too much data? Add option?\n        field.values = field.values?.slice(0, options.maxValues);\n    }\n    return field;\n}\nfunction attributeTypeToFieldType(aType) {\n    const type = aType.toLowerCase();\n    if (!type || !attrTypeMap[type]) {\n        // console.warn(\n        //   `cannot convert attribute type ${type} to loaders.gl data type, use string by default`\n        // );\n    }\n    return attrTypeMap[type] || { type: 'string' };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseTileJSON } from \"./lib/parse-tilejson.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n/**\n * Loader for TileJSON metadata\n */\nexport const TileJSONLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'TileJSON',\n    id: 'tilejson',\n    module: 'pmtiles',\n    version: VERSION,\n    worker: true,\n    extensions: ['json'],\n    mimeTypes: ['application/json'],\n    text: true,\n    options: {\n        tilejson: {\n            maxValues: undefined\n        }\n    },\n    parse: async (arrayBuffer, options) => {\n        const jsonString = new TextDecoder().decode(arrayBuffer);\n        const json = JSON.parse(jsonString);\n        const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };\n        return parseTileJSON(json, tilejsonOptions);\n    },\n    parseTextSync: (text, options) => {\n        const json = JSON.parse(text);\n        const tilejsonOptions = { ...TileJSONLoader.options.tilejson, ...options?.tilejson };\n        return parseTileJSON(json, tilejsonOptions);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DataSource, resolvePath } from '@loaders.gl/loader-utils';\nimport { ImageLoader, getBinaryImageMetadata } from '@loaders.gl/images';\nimport { MVTLoader, TileJSONLoader } from '@loaders.gl/mvt';\n/**\n * MVT data source for Mapbox Vector Tiles v1.\n */\n/**\n * A PMTiles data source\n * @note Can be either a raster or vector tile source depending on the contents of the PMTiles file.\n */\nexport class MVTSource extends DataSource {\n    props;\n    url;\n    metadataUrl = null;\n    data;\n    schema = 'tms';\n    metadata;\n    extension;\n    mimeType = null;\n    constructor(props) {\n        super(props);\n        this.props = props;\n        this.url = resolvePath(props.url);\n        this.metadataUrl =\n            props.metadataUrl === undefined ? `${this.url}/tilejson.json` : props.metadataUrl;\n        this.extension = props.extension || '.png';\n        this.data = this.url;\n        this.getTileData = this.getTileData.bind(this);\n        this.metadata = this.getMetadata();\n        if (isURLTemplate(this.url)) {\n            this.schema = 'template';\n        }\n    }\n    // @ts-ignore - Metadata type misalignment\n    async getMetadata() {\n        if (!this.metadataUrl) {\n            return null;\n        }\n        let response;\n        try {\n            // Annoyingly, on CORS errors, fetch doesn't use the response status/ok mechanism but instead throws\n            // CORS errors are common when requesting an unavailable sub resource such as a metadata file or an unavailable tile)\n            response = await this.fetch(this.metadataUrl);\n        }\n        catch (error) {\n            // eslint-disable-next-line no-console\n            console.error(error.message);\n            return null;\n        }\n        if (!response.ok) {\n            // eslint-disable-next-line no-console\n            console.error(response.statusText);\n            return null;\n        }\n        const tileJSON = await response.text();\n        const metadata = TileJSONLoader.parseTextSync?.(tileJSON) || null;\n        // TODO add metadata attributions\n        // metadata.attributions = [...this.props.attributions, ...(metadata.attributions || [])];\n        // if (metadata?.mimeType) {\n        //   this.mimeType = metadata?.tileMIMEType;\n        // }\n        return metadata;\n    }\n    getTileMIMEType() {\n        return this.mimeType;\n    }\n    async getTile(tileParams) {\n        const { x, y, zoom: z } = tileParams;\n        const tileUrl = this.getTileURL(x, y, z);\n        const response = await this.fetch(tileUrl);\n        if (!response.ok) {\n            return null;\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        return arrayBuffer;\n    }\n    // Tile Source interface implementation: deck.gl compatible API\n    // TODO - currently only handles image tiles, not vector tiles\n    async getTileData(tileParams) {\n        const { x, y, z } = tileParams.index;\n        // const metadata = await this.metadata;\n        // mimeType = metadata?.tileMIMEType || 'application/vnd.mapbox-vector-tile';\n        const arrayBuffer = await this.getTile({ x, y, zoom: z, layers: [] });\n        if (arrayBuffer === null) {\n            return null;\n        }\n        const imageMetadata = getBinaryImageMetadata(arrayBuffer);\n        this.mimeType =\n            this.mimeType || imageMetadata?.mimeType || 'application/vnd.mapbox-vector-tile';\n        switch (this.mimeType) {\n            case 'application/vnd.mapbox-vector-tile':\n                return await this._parseVectorTile(arrayBuffer, { x, y, zoom: z, layers: [] });\n            default:\n                return await this._parseImageTile(arrayBuffer);\n        }\n    }\n    // ImageTileSource interface implementation\n    async getImageTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseImageTile(arrayBuffer) : null;\n    }\n    async _parseImageTile(arrayBuffer) {\n        return await ImageLoader.parse(arrayBuffer, this.loadOptions);\n    }\n    // VectorTileSource interface implementation\n    async getVectorTile(tileParams) {\n        const arrayBuffer = await this.getTile(tileParams);\n        return arrayBuffer ? this._parseVectorTile(arrayBuffer, tileParams) : null;\n    }\n    async _parseVectorTile(arrayBuffer, tileParams) {\n        const loadOptions = {\n            shape: 'geojson-table',\n            mvt: {\n                coordinates: 'wgs84',\n                tileIndex: { x: tileParams.x, y: tileParams.y, z: tileParams.zoom },\n                ...this.loadOptions?.mvt\n            },\n            ...this.loadOptions\n        };\n        return await MVTLoader.parse(arrayBuffer, loadOptions);\n    }\n    getMetadataUrl() {\n        return this.metadataUrl;\n    }\n    getTileURL(x, y, z) {\n        switch (this.schema) {\n            case 'xyz':\n                return `${this.url}/${x}/${y}/${z}${this.extension}`;\n            case 'tms':\n                return `${this.url}/${z}/${x}/${y}${this.extension}`;\n            case 'template':\n                return getURLFromTemplate(this.url, x, y, z, '0');\n            default:\n                throw new Error(this.schema);\n        }\n    }\n}\nexport function isURLTemplate(s) {\n    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))|(?=.*{x})(?=.*({y}|{-y})(?=.*{z}))/.test(s);\n}\nconst xRegex = new RegExp('{x}', 'g');\nconst yRegex = new RegExp('{y}', 'g');\nconst zRegex = new RegExp('{z}', 'g');\n/**\n * Get a URL from a URL template\n * @note copied from deck.gl/modules/geo-layers/src/tileset-2d/utils.ts\n * @param template - URL template\n * @param x - tile x coordinate\n * @param y - tile y coordinate\n * @param z - tile z coordinate\n * @param id - tile id\n * @returns URL\n */\nexport function getURLFromTemplate(template, x, y, z, id = '0') {\n    if (Array.isArray(template)) {\n        const i = stringHash(id) % template.length;\n        template = template[i];\n    }\n    let url = template;\n    url = url.replace(xRegex, String(x));\n    url = url.replace(yRegex, String(y));\n    url = url.replace(zRegex, String(z));\n    // Back-compatible support for {-y}\n    if (Number.isInteger(y) && Number.isInteger(z)) {\n        url = url.replace(/\\{-y\\}/g, String(Math.pow(2, z) - y - 1));\n    }\n    return url;\n}\nfunction stringHash(s) {\n    return Math.abs(s.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0));\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Calculate simplification data using optimized Douglas-Peucker algorithm\n *\n * @param coords contiguous list of coordinates\n * @param first first coord to simplify\n * @param last last coord to simplify\n * @param sqTolerance tolerance (square distance)\n */\nexport function simplify(coords, first, last, sqTolerance) {\n    let maxSqDist = sqTolerance;\n    const mid = (last - first) >> 1;\n    let minPosToMid = last - first;\n    let index;\n    const ax = coords[first];\n    const ay = coords[first + 1];\n    const bx = coords[last];\n    const by = coords[last + 1];\n    for (let i = first + 3; i < last; i += 3) {\n        const d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n        }\n        else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            const posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3)\n            simplify(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3)\n            simplify(coords, index, last, sqTolerance);\n    }\n}\n/** square distance from a point to a segment */\n// eslint-disable-next-line max-params\nfunction getSqSegDist(px, py, x, y, bx, by) {\n    let dx = bx - x;\n    let dy = by - y;\n    if (dx !== 0 || dy !== 0) {\n        const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n        if (t > 1) {\n            x = bx;\n            y = by;\n        }\n        else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n    dx = px - x;\n    dy = py - y;\n    return dx * dx + dy * dy;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nexport function createFeature(id, type, geom, tags) {\n    const feature = {\n        // eslint-disable-next-line\n        id: id == null ? null : id,\n        type,\n        geometry: geom,\n        tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n        calcLineBBox(feature, geom);\n    }\n    else if (type === 'Polygon') {\n        // the outer ring (ie [0]) contains all inner rings\n        calcLineBBox(feature, geom[0]);\n    }\n    else if (type === 'MultiLineString') {\n        for (const line of geom) {\n            calcLineBBox(feature, line);\n        }\n    }\n    else if (type === 'MultiPolygon') {\n        for (const polygon of geom) {\n            // the outer ring (ie [0]) contains all inner rings\n            calcLineBBox(feature, polygon[0]);\n        }\n    }\n    return feature;\n}\nfunction calcLineBBox(feature, geom) {\n    for (let i = 0; i < geom.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geom[i]);\n        feature.minY = Math.min(feature.minY, geom[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geom[i]);\n        feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { simplify } from \"./simplify.js\";\nimport { createFeature } from \"./feature.js\";\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\nexport function convert(data, options) {\n    const features = [];\n    if (data.type === 'FeatureCollection') {\n        for (let i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], options, i);\n        }\n    }\n    else if (data.type === 'Feature') {\n        convertFeature(features, data, options);\n    }\n    else {\n        // single geometry or a geometry collection\n        convertFeature(features, { geometry: data }, options);\n    }\n    return features;\n}\nfunction convertFeature(features, geojson, options, index) {\n    if (!geojson.geometry) {\n        return;\n    }\n    const coords = geojson.geometry.coordinates;\n    const type = geojson.geometry.type;\n    const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    let geometry = [];\n    let id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    }\n    else if (options.generateId) {\n        id = index || 0;\n    }\n    if (type === 'Point') {\n        convertPoint(coords, geometry);\n    }\n    else if (type === 'MultiPoint') {\n        for (const p of coords) {\n            convertPoint(p, geometry);\n        }\n    }\n    else if (type === 'LineString') {\n        convertLine(coords, geometry, tolerance, false);\n    }\n    else if (type === 'MultiLineString') {\n        if (options.lineMetrics) {\n            // explode into linestrings to be able to track metrics\n            for (const line of coords) {\n                geometry = [];\n                convertLine(line, geometry, tolerance, false);\n                features.push(createFeature(id, 'LineString', geometry, geojson.properties));\n            }\n            return;\n        }\n        else {\n            convertLines(coords, geometry, tolerance, false);\n        }\n    }\n    else if (type === 'Polygon') {\n        convertLines(coords, geometry, tolerance, true);\n    }\n    else if (type === 'MultiPolygon') {\n        for (const polygon of coords) {\n            const newPolygon = [];\n            convertLines(polygon, newPolygon, tolerance, true);\n            geometry.push(newPolygon);\n        }\n    }\n    else if (type === 'GeometryCollection') {\n        for (const singleGeometry of geojson.geometry.geometries) {\n            convertFeature(features, {\n                id,\n                geometry: singleGeometry,\n                properties: geojson.properties\n            }, options, index);\n        }\n        return;\n    }\n    else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n    features.push(createFeature(id, type, geometry, geojson.properties));\n}\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]), projectY(coords[1]), 0);\n}\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    let x0, y0;\n    let size = 0;\n    for (let j = 0; j < ring.length; j++) {\n        const x = projectX(ring[j][0]);\n        const y = projectY(ring[j][1]);\n        out.push(x, y, 0);\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            }\n            else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n    const last = out.length - 3;\n    out[2] = 1;\n    simplify(out, 0, last, tolerance);\n    out[last + 2] = 1;\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (let i = 0; i < rings.length; i++) {\n        const geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\nfunction projectY(y) {\n    const sin = Math.sin((y * Math.PI) / 180);\n    const y2 = 0.5 - (0.25 * Math.log((1 + sin) / (1 - sin))) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { createFeature } from \"./feature.js\";\n/* eslint-disable no-continue */\n/**\n * Clip features between two vertical or horizontal axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n *\n * @param k1 and k2 are the line coordinates\n * @param axis: 0 for x, 1 for y\n * @param minAll and maxAll: minimum and maximum coordinate value for all features\n */\n// eslint-disable-next-line max-params, complexity, max-statements\nexport function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n    k1 /= scale;\n    k2 /= scale;\n    if (minAll >= k1 && maxAll < k2) {\n        return features;\n    }\n    // trivial accept\n    else if (maxAll < k1 || minAll >= k2) {\n        return null; // trivial reject\n    }\n    const clipped = [];\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        let type = feature.type;\n        const min = axis === 0 ? feature.minX : feature.minY;\n        const max = axis === 0 ? feature.maxX : feature.maxY;\n        if (min >= k1 && max < k2) {\n            // trivial accept\n            clipped.push(feature);\n            continue;\n        }\n        else if (max < k1 || min >= k2) {\n            // trivial reject\n            continue;\n        }\n        let newGeometry = [];\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n        }\n        else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n        }\n        else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n        }\n        else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n        }\n        else if (type === 'MultiPolygon') {\n            for (const polygon of geometry) {\n                const newPolygon = [];\n                clipLines(polygon, newPolygon, k1, k2, axis, true);\n                if (newPolygon.length) {\n                    newGeometry.push(newPolygon);\n                }\n            }\n        }\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (const line of newGeometry) {\n                    clipped.push(createFeature(feature.id, type, line, feature.tags));\n                }\n                continue;\n            }\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    // @ts-expect-error TODO - use proper GeoJSON geometry types\n                    newGeometry = newGeometry[0];\n                }\n                else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n            clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n    return clipped.length ? clipped : null;\n}\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (let i = 0; i < geom.length; i += 3) {\n        const a = geom[i + axis];\n        if (a >= k1 && a <= k2) {\n            addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);\n        }\n    }\n}\n// eslint-disable-next-line max-params, complexity, max-statements\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n    let slice = newSlice(geom);\n    const intersect = axis === 0 ? intersectX : intersectY;\n    let len = geom.start;\n    let segLen;\n    let t;\n    for (let i = 0; i < geom.length - 3; i += 3) {\n        const ax = geom[i];\n        const ay = geom[i + 1];\n        const az = geom[i + 2];\n        const bx = geom[i + 3];\n        const by = geom[i + 4];\n        const a = axis === 0 ? ax : ay;\n        const b = axis === 0 ? bx : by;\n        let exited = false;\n        if (trackMetrics) {\n            segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n        }\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) {\n                    slice.start = len + segLen * t;\n                }\n            }\n        }\n        else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n        if (!isPolygon && exited) {\n            if (trackMetrics) {\n                slice.end = len + segLen * t;\n            }\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n        if (trackMetrics) {\n            len += segLen;\n        }\n    }\n    // add the last point\n    let last = geom.length - 3;\n    const ax = geom[last];\n    const ay = geom[last + 1];\n    const az = geom[last + 2];\n    const a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2)\n        addPoint(slice, ax, ay, az);\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\nclass Slice extends Array {\n    size;\n    start;\n    end;\n}\nfunction newSlice(line) {\n    const slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n// eslint-disable-next-line max-params\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (const line of geom) {\n        clipLine(line, newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\nfunction addPoint(out, x, y, z) {\n    out.push(x, y, z);\n}\n// eslint-disable-next-line max-params\nfunction intersectX(out, ax, ay, bx, by, x) {\n    const t = (x - ax) / (bx - ax);\n    addPoint(out, x, ay + (by - ay) * t, 1);\n    return t;\n}\n// eslint-disable-next-line max-params\nfunction intersectY(out, ax, ay, bx, by, y) {\n    const t = (y - ay) / (by - ay);\n    addPoint(out, ax + (bx - ax) * t, y, 1);\n    return t;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { clip } from \"./clip.js\";\nimport { createFeature } from \"./feature.js\";\n/**\n * Wrap across antemeridian, by clipping into two tiles, shifting the overflowing x coordinates\n * @param features list of features to be wrapped\n * @param options buffer and extent\n * @returns\n */\nexport function wrap(features, options) {\n    const buffer = options.buffer / options.extent;\n    let merged = features;\n    const left = clip(features, 1, -1 - buffer, buffer, 0, -1, 2, options); // left world copy\n    const right = clip(features, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n    if (left || right) {\n        merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n        if (left) {\n            merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        }\n        if (right) {\n            merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n        }\n    }\n    return merged;\n}\n/**\n * Shift the x coordinates of a list of features\n * @param features list of features to shift x coordinates for\n * @param offset\n * @returns\n */\nfunction shiftFeatureCoords(features, offset) {\n    const newFeatures = [];\n    for (let i = 0; i < features.length; i++) {\n        const feature = features[i];\n        const type = feature.type;\n        let newGeometry;\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            newGeometry = shiftCoords(feature.geometry, offset);\n        }\n        else if (type === 'MultiLineString' || type === 'Polygon') {\n            newGeometry = [];\n            for (const line of feature.geometry) {\n                newGeometry.push(shiftCoords(line, offset));\n            }\n        }\n        else if (type === 'MultiPolygon') {\n            newGeometry = [];\n            for (const polygon of feature.geometry) {\n                const newPolygon = [];\n                for (const line of polygon) {\n                    // @ts-expect-error TODO\n                    newPolygon.push(shiftCoords(line, offset));\n                }\n                newGeometry.push(newPolygon);\n            }\n        }\n        newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n    }\n    return newFeatures;\n}\nclass Points extends Array {\n    size;\n    start;\n    end;\n}\n/**\n * Shift the x coordinate of every point\n * @param points\n * @param offset\n * @returns\n */\nfunction shiftCoords(points, offset) {\n    const newPoints = [];\n    newPoints.size = points.size;\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n    for (let i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Transforms the coordinates of each feature in the given tile from\n * mercator-projected space into (extent x extent) tile space.\n */\nexport function transformTile(tile, extent) {\n    if (tile.transformed) {\n        return tile;\n    }\n    const z2 = 1 << tile.z;\n    const tx = tile.x;\n    const ty = tile.y;\n    for (const feature of tile.features) {\n        const geom = feature.geometry;\n        const type = feature.type;\n        feature.geometry = [];\n        if (type === 1) {\n            for (let j = 0; j < geom.length; j += 2) {\n                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        }\n        else {\n            for (let j = 0; j < geom.length; j++) {\n                const ring = [];\n                for (let k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                feature.geometry.push(ring);\n            }\n        }\n    }\n    tile.transformed = true;\n    return tile;\n}\n// eslint-disable-next-line max-params\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [Math.round(extent * (x * z2 - tx)), Math.round(extent * (y * z2 - ty))];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\n/**\n * Create a tile from features and tile index\n */\nexport function createTile(features, z, tx, ty, options) {\n    const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    const tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: features.length,\n        source: null,\n        x: tx,\n        y: ty,\n        z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (const feature of features) {\n        addFeature(tile, feature, tolerance, options);\n    }\n    return tile;\n}\n// eslint-disable-next-line complexity, max-statements\nfunction addFeature(tile, feature, tolerance, options) {\n    const geom = feature.geometry;\n    const type = feature.type;\n    const simplified = [];\n    tile.minX = Math.min(tile.minX, feature.minX);\n    tile.minY = Math.min(tile.minY, feature.minY);\n    tile.maxX = Math.max(tile.maxX, feature.maxX);\n    tile.maxY = Math.max(tile.maxY, feature.maxY);\n    if (type === 'Point' || type === 'MultiPoint') {\n        for (let i = 0; i < geom.length; i += 3) {\n            simplified.push(geom[i], geom[i + 1]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n    }\n    else if (type === 'LineString') {\n        addLine(simplified, geom, tile, tolerance, false, false);\n    }\n    else if (type === 'MultiLineString' || type === 'Polygon') {\n        for (let i = 0; i < geom.length; i++) {\n            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);\n        }\n    }\n    else if (type === 'MultiPolygon') {\n        for (let k = 0; k < geom.length; k++) {\n            const polygon = geom[k];\n            for (let i = 0; i < polygon.length; i++) {\n                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);\n            }\n        }\n    }\n    if (simplified.length) {\n        let tags = feature.tags || null;\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (const key in feature.tags)\n                tags[key] = feature.tags[key];\n            // eslint-disable-next-line camelcase\n            tags.mapbox_clip_start = geom.start / geom.size;\n            // eslint-disable-next-line camelcase\n            tags.mapbox_clip_end = geom.end / geom.size;\n        }\n        // @ts-expect-error TODO - create sub type?\n        const tileFeature = {\n            geometry: simplified,\n            type: type === 'Polygon' || type === 'MultiPolygon'\n                ? 3\n                : type === 'LineString' || type === 'MultiLineString'\n                    ? 2\n                    : 1,\n            tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n// eslint-disable-next-line max-params, max-statements\nfunction addLine(result, geom, tile, tolerance, isPolygon, isOuter) {\n    const sqTolerance = tolerance * tolerance;\n    if (tolerance > 0 && geom.size < (isPolygon ? sqTolerance : tolerance)) {\n        tile.numPoints += geom.length / 3;\n        return;\n    }\n    const ring = [];\n    for (let i = 0; i < geom.length; i += 3) {\n        if (tolerance === 0 || geom[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geom[i], geom[i + 1]);\n        }\n        tile.numPoints++;\n    }\n    if (isPolygon)\n        rewind(ring, isOuter);\n    result.push(ring);\n}\nfunction rewind(ring, clockwise) {\n    let area = 0;\n    for (let i = 0, j = ring.length - 2; i < ring.length; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (let i = 0, len = ring.length; i < len / 2; i += 2) {\n            const x = ring[i];\n            const y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from https://github.com/mapbox/geojson-vt under compatible ISC license\nimport { convert } from \"./convert.js\"; // GeoJSON conversion and preprocessing\nimport { clip } from \"./clip.js\"; // stripe clipping algorithm\nimport { wrap } from \"./wrap.js\"; // date line processing\nimport { transformTile } from \"./transform.js\"; // coordinate transformation\nimport { createTile } from \"./tile.js\"; // final simplified tile generation\nconst DEFAULT_OPTIONS = {\n    maxZoom: 14, // max zoom to preserve detail on\n    indexMaxZoom: 5, // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3, // simplification tolerance (higher means simpler)\n    extent: 4096, // tile extent\n    buffer: 64, // tile buffer on each side\n    lineMetrics: false, // whether to calculate line metrics\n    // @ts-expect-error Ensures all these required params have defaults\n    promoteId: undefined, // name of a feature property to be promoted to feature.id\n    generateId: false, // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0 // logging level (0, 1 or 2)\n};\nexport class GeoJSONTiler {\n    options;\n    // tiles and tileCoords are part of the public API\n    tiles = {};\n    tileCoords = [];\n    stats = {};\n    total = 0;\n    constructor(data, options) {\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        options = this.options;\n        const debug = options.debug;\n        if (debug)\n            console.time('preprocess data');\n        if (this.options.maxZoom < 0 || this.options.maxZoom > 24) {\n            throw new Error('maxZoom should be in the 0-24 range');\n        }\n        if (options.promoteId && this.options.generateId) {\n            throw new Error('promoteId and generateId cannot be used together.');\n        }\n        // projects and adds simplification info\n        let features = convert(data, options);\n        if (debug) {\n            console.timeEnd('preprocess data');\n            console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n            console.time('generate tiles');\n        }\n        // wraps features (ie extreme west and extreme east)\n        features = wrap(features, this.options);\n        // start slicing from the top tile down\n        if (features.length) {\n            this.splitTile(features, 0, 0, 0);\n        }\n        if (debug) {\n            if (features.length) {\n                console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n            }\n            console.timeEnd('generate tiles');\n            console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n        }\n    }\n    /**\n     * Get a tile at the specified index\n     * @param z\n     * @param x\n     * @param y\n     * @returns\n     */\n    // eslint-disable-next-line complexity, max-statements\n    getTile(z, x, y) {\n        // z = +z;\n        // x = +x;\n        // y = +y;\n        const { extent, debug } = this.options;\n        if (z < 0 || z > 24) {\n            return null;\n        }\n        const z2 = 1 << z;\n        x = (x + z2) & (z2 - 1); // wrap tile x coordinate\n        const id = toID(z, x, y);\n        if (this.tiles[id]) {\n            return transformTile(this.tiles[id], extent);\n        }\n        if (debug > 1)\n            console.log('drilling down to z%d-%d-%d', z, x, y);\n        let z0 = z;\n        let x0 = x;\n        let y0 = y;\n        let parent;\n        while (!parent && z0 > 0) {\n            z0--;\n            x0 = x0 >> 1;\n            y0 = y0 >> 1;\n            parent = this.tiles[toID(z0, x0, y0)];\n        }\n        if (!parent || !parent.source) {\n            return null;\n        }\n        // if we found a parent tile containing the original geometry, we can drill down from it\n        if (debug > 1) {\n            console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n            console.time('drilling down');\n        }\n        this.splitTile(parent.source, z0, x0, y0, z, x, y);\n        if (debug > 1) {\n            console.timeEnd('drilling down');\n        }\n        return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;\n    }\n    /**\n     * splits features from a parent tile to sub-tiles.\n     * @param z, x, and y are the coordinates of the parent tile\n     * @param cz, cx, and cy are the coordinates of the target tile\n     *\n     * If no target tile is specified, splitting stops when we reach the maximum\n     * zoom or the number of points is low as specified in the options.\n     */\n    // eslint-disable-next-line max-params, max-statements, complexity\n    splitTile(features, z, x, y, cz, cx, cy) {\n        const stack = [features, z, x, y];\n        const options = this.options;\n        const debug = options.debug;\n        // avoid recursion by using a processing queue\n        while (stack.length) {\n            y = stack.pop();\n            x = stack.pop();\n            z = stack.pop();\n            features = stack.pop();\n            const z2 = 1 << z;\n            const id = toID(z, x, y);\n            let tile = this.tiles[id];\n            if (!tile) {\n                if (debug > 1) {\n                    console.time('creation');\n                }\n                tile = this.tiles[id] = createTile(features, z, x, y, options);\n                this.tileCoords.push({ z, x, y });\n                if (debug) {\n                    if (debug > 1) {\n                        console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                        console.timeEnd('creation');\n                    }\n                    const key = `z${z}`;\n                    this.stats[key] = (this.stats[key] || 0) + 1;\n                    this.total++;\n                }\n            }\n            // save reference to original geometry in tile so that we can drill down later if we stop now\n            tile.source = features;\n            // if it's the first-pass tiling\n            if (cz === undefined) {\n                // stop tiling if we reached max zoom, or if the tile is too simple\n                if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints)\n                    continue;\n                // if a drilldown to a specific tile\n            }\n            else if (z === options.maxZoom || z === cz) {\n                // stop tiling if we reached base zoom or our target tile zoom\n                continue;\n            }\n            else if (cz !== undefined) {\n                // stop tiling if it's not an ancestor of the target tile\n                const zoomSteps = cz - z;\n                // @ts-expect-error TODO fix the types of cx cy\n                if (x !== cx >> zoomSteps || y !== cy >> zoomSteps)\n                    continue;\n            }\n            // if we slice further down, no need to keep source geometry\n            tile.source = null;\n            if (features.length === 0)\n                continue;\n            if (debug > 1)\n                console.time('clipping');\n            // values we'll use for clipping\n            const k1 = (0.5 * options.buffer) / options.extent;\n            const k2 = 0.5 - k1;\n            const k3 = 0.5 + k1;\n            const k4 = 1 + k1;\n            let tl = null;\n            let bl = null;\n            let tr = null;\n            let br = null;\n            let left = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n            let right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n            // @ts-expect-error - unclear why this is needed?\n            features = null;\n            if (left) {\n                tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                left = null;\n            }\n            if (right) {\n                tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n                br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n                right = null;\n            }\n            if (debug > 1)\n                console.timeEnd('clipping');\n            stack.push(tl || [], z + 1, x * 2, y * 2);\n            stack.push(bl || [], z + 1, x * 2, y * 2 + 1);\n            stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n            stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n        }\n    }\n}\nfunction toID(z, x, y) {\n    return ((1 << z) * y + x) * 32 + z;\n}\n"],
  "mappings": "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",
  "names": ["i", "cmd", "length", "x", "y", "cmdLen", "x2", "y2", "i", "project", "i", "classifyRings", "i", "readFeature", "readTag", "readFeature", "classifyRings", "x", "y", "readLayer", "i", "readValueMessage", "readTile", "Protobuf", "i", "x", "VERSION", "x", "y", "i", "i", "x", "y", "i", "i", "x", "y", "y2", "i", "ax", "ay", "az", "a", "x", "y", "i", "i", "x", "y", "i", "x", "y", "x", "y"]
}
