"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  CSWCapabilitiesLoader: () => CSWCapabilitiesLoader,
  CSWDomainLoader: () => CSWDomainLoader,
  CSWRecordsLoader: () => CSWRecordsLoader,
  CSWService: () => CSWService,
  ImageService: () => ImageService,
  ImageSource: () => import_loader_utils5.ImageSource,
  WMSCapabilitiesLoader: () => WMSCapabilitiesLoader,
  WMSErrorLoader: () => WMSErrorLoader,
  WMSService: () => WMSService,
  WMSSource: () => WMSSource,
  _ArcGISImageService: () => ArcGISImageService,
  _GMLLoader: () => GMLLoader,
  _WFSCapabilitiesLoader: () => WFSCapabilitiesLoader,
  _WMSFeatureInfoLoader: () => WMSFeatureInfoLoader,
  _WMSLayerDescriptionLoader: () => WMSLayerDescriptionLoader,
  _getArcGISServices: () => getArcGISServices,
  createImageService: () => createImageService,
  createImageSource: () => createImageSource
});
module.exports = __toCommonJS(dist_exports);

// dist/lib/parsers/csw/parse-csw-capabilities.js
var import_xml = require("@loaders.gl/xml");

// dist/lib/parsers/csw/parse-exception-report.js
function parseExceptionReport(parsedXML) {
  var _a, _b, _c;
  const exceptionReport = parsedXML.exceptionReport;
  if (!exceptionReport) {
    return;
  }
  const errorMessage = ((_a = exceptionReport.exception) == null ? void 0 : _a.exceptionText) || ((_b = exceptionReport.exception) == null ? void 0 : _b.exceptionCode) || ((_c = exceptionReport.exception) == null ? void 0 : _c.locator) || "server error";
  throw new Error(`Catalog Server: ${errorMessage}`);
}

// dist/lib/parsers/csw/parse-csw-capabilities.js
function parseCSWCapabilities(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = import_xml.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, {
    ...options,
    xml: {
      ...options == null ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true
    }
  });
  parseExceptionReport(parsedXML);
  const xmlCapabilities = parsedXML.capabilities || parsedXML;
  return xmlCapabilities;
}

// dist/csw-capabilities-loader.js
var VERSION = true ? "4.2.0-beta.2" : "latest";
var CSWCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "csw-capabilities",
  name: "CSW Capabilities",
  module: "wms",
  version: VERSION,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWCapabilities(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWCapabilities(text, options)
};
function testXMLFile(text) {
  return text.startsWith("<?xml");
}

// dist/lib/parsers/csw/parse-csw-domain.js
var import_xml2 = require("@loaders.gl/xml");
function parseCSWDomain(text, options) {
  var _a, _b, _c;
  const parsedXML = (_b = (_a = import_xml2.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, {
    ...options,
    xml: {
      ...options == null ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true,
      arrayPaths: [
        "GetDomainResponse.DomainValues",
        "GetDomainResponse.DomainValues.ListOfValues.value"
      ]
    }
  });
  parseExceptionReport(parsedXML);
  const xmlDomain = parsedXML.getDomainResponse;
  for (const domainValue of xmlDomain.domainValues) {
    domainValue.values = (_c = domainValue.listOfValues) == null ? void 0 : _c.value;
    delete domainValue.listOfValues;
  }
  return xmlDomain;
}

// dist/csw-domain-loader.js
var VERSION2 = true ? "4.2.0-beta.2" : "latest";
var CSWDomainLoader = {
  dataType: null,
  batchType: null,
  id: "csw-domain",
  name: "CSW Domain",
  module: "wms",
  version: VERSION2,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile2,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWDomain(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWDomain(text, options)
};
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}

// dist/lib/parsers/csw/parse-csw-records.js
var import_xml3 = require("@loaders.gl/xml");
var import_xml4 = require("@loaders.gl/xml");
function parseCSWRecords(text, options) {
  var _a, _b, _c;
  const parsedXML = (_c = (_b = import_xml4.XMLLoader).parseTextSync) == null ? void 0 : _c.call(_b, text, {
    ...options,
    xml: {
      ...options == null ? void 0 : options.xml,
      removeNSPrefix: true,
      uncapitalizeKeys: true,
      arrayPaths: [],
      _fastXML: {
        ...(_a = options == null ? void 0 : options.xml) == null ? void 0 : _a._fastXML,
        parseAttributeValue: true
      }
    }
  });
  parseExceptionReport(parsedXML);
  const xmlRecords = parsedXML.getRecordsResponse;
  const elementSet = xmlRecords.searchResults.elementSet;
  const recordsFieldName = `${elementSet}Record`;
  xmlRecords.records = xmlRecords.searchResults[recordsFieldName];
  delete xmlRecords.searchResults[recordsFieldName];
  (0, import_xml3.convertXMLFieldToArrayInPlace)(xmlRecords, "records");
  for (const record of xmlRecords.records) {
    record.boundingBoxes = record.boundingBox;
    delete record.boundingBox;
    (0, import_xml3.convertXMLFieldToArrayInPlace)(record, "boundingBoxes");
    for (const boundingBox of record.boundingBoxes) {
      boundingBox.value = [
        boundingBox.upperCorner[0],
        boundingBox.upperCorner[1],
        boundingBox.lowerCorner[0],
        boundingBox.lowerCorner[1]
      ];
      delete boundingBox.upperCorner;
      delete boundingBox.lowerCorner;
    }
  }
  return xmlRecords;
}

// dist/csw-records-loader.js
var VERSION3 = true ? "4.2.0-beta.2" : "latest";
var CSWRecordsLoader = {
  dataType: null,
  batchType: null,
  id: "csw-records",
  name: "CSW Records",
  module: "wms",
  version: VERSION3,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.csw_xml", "application/xml", "text/xml"],
  testText: testXMLFile3,
  options: {
    csw: {}
  },
  parse: async (arrayBuffer, options) => parseCSWRecords(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseCSWRecords(text, options)
};
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}

// dist/lib/parsers/wms/parse-wms-error.js
var import_xml5 = require("@loaders.gl/xml");
function parseWMSError(text, options) {
  var _a, _b, _c, _d;
  const parsedXML = (_b = (_a = import_xml5.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const serviceExceptionXML = ((_c = parsedXML == null ? void 0 : parsedXML.ServiceExceptionReport) == null ? void 0 : _c.ServiceException) || ((_d = parsedXML == null ? void 0 : parsedXML["ogc:ServiceExceptionReport"]) == null ? void 0 : _d["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
  return message;
}

// dist/wms-error-loader.js
var VERSION4 = true ? "4.2.0-beta.2" : "latest";
var WMSErrorLoader = {
  dataType: null,
  batchType: null,
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: VERSION4,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: testXMLFile4,
  options: {
    wms: {
      throwOnError: false
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseSync: (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync(text, options)
};
function testXMLFile4(text) {
  return text.startsWith("<?xml");
}
function parseTextSync(text, options) {
  const wmsOptions = { ...WMSErrorLoader.options.wms, ...options == null ? void 0 : options.wms };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}

// dist/lib/parsers/wms/parse-wms-capabilities.js
var import_xml6 = require("@loaders.gl/xml");

// dist/lib/parsers/xml/parse-xml-helpers.js
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function getXMLStringArray(xmlValue) {
  const xmlArray = getXMLArray(xmlValue);
  if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
    return xmlArray;
  }
  return [];
}
function getXMLFloat(xmlValue, defaultValue = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseFloat(xmlValue);
    default:
      return void 0;
  }
}
function getXMLInteger(xmlValue, defaultValue = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseInt(xmlValue, 10);
    default:
      return void 0;
  }
}
function getXMLBoolean(xmlValue) {
  switch (xmlValue) {
    case "true":
      return true;
    case "false":
      return false;
    case "1":
      return true;
    case "0":
      return false;
    default:
      return false;
  }
}

// dist/lib/parsers/wms/parse-wms-capabilities.js
function parseWMSCapabilities(xmlText, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = import_xml6.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options == null ? void 0 : options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options == null ? void 0 : options.includeRawJSON) {
    capabilities.json = xmlCapabilities;
  }
  if (options == null ? void 0 : options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const capabilities = {
    version: String(xml.version || ""),
    name: String(((_a = xml.Service) == null ? void 0 : _a.Name) || "unnamed"),
    title: ((_b = xml.Service) == null ? void 0 : _b.Title) ? String((_c = xml.Service) == null ? void 0 : _c.Title) : void 0,
    abstract: ((_d = xml.Service) == null ? void 0 : _d.Abstract) ? String((_e = xml.Service) == null ? void 0 : _e.Abstract) : void 0,
    keywords: getXMLStringArray((_g = (_f = xml.Service) == null ? void 0 : _f.KeywordList) == null ? void 0 : _g.Keyword),
    fees: ((_h = xml.Service) == null ? void 0 : _h.Fees) ? JSON.stringify((_i = xml.Service) == null ? void 0 : _i.Fees) : void 0,
    accessConstraints: ((_j = xml.Service) == null ? void 0 : _j.AccessConstraints) ? JSON.stringify((_k = xml.Service) == null ? void 0 : _k.AccessConstraints) : void 0,
    layerLimit: getXMLInteger((_l = xml.Service) == null ? void 0 : _l.LayerLimit),
    maxWidth: getXMLInteger((_m = xml.Service) == null ? void 0 : _m.maxWidth),
    maxHeight: getXMLInteger((_n = xml.Service) == null ? void 0 : _n.maxHeight),
    layers: [],
    requests: extractRequests((_o = xml.Capability) == null ? void 0 : _o.Request),
    exceptions: extractExceptions(xml.Exception)
    // contact field is a mess of largely irrelevant information, put it last
    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
  };
  const xmlLayers = getXMLArray((_p = xml.Capability) == null ? void 0 : _p.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === void 0) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest == null ? void 0 : xmlRequest.Format);
    requests[name] = { mimeTypes };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException == null ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return void 0;
}
function extractLayer(xmlLayer) {
  var _a;
  const layer = {
    // All layers must have a title
    title: String((xmlLayer == null ? void 0 : xmlLayer.Title) || ""),
    // Name is required only if renderable
    name: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_a = xmlLayer.KeywordList) == null ? void 0 : _a.Keyword)
  };
  const crs = (xmlLayer == null ? void 0 : xmlLayer.CRS) || (xmlLayer == null ? void 0 : xmlLayer.SRS);
  if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === "string")) {
    layer.crs = crs;
  }
  let geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer == null ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer == null ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer == null ? void 0 : xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === void 0) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const { westBoundLongitude: w, northBoundLatitude: n, eastBoundLongitude: e, southBoundLatitude: s } = xmlBoundingBox;
  return [
    [w, s],
    [e, n]
  ];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const { minx, miny, maxx, maxy } = xmlBoundingBox;
  return [
    [minx, miny],
    [maxx, maxy]
  ];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const { CRS, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
  const boundingBox = {
    // CRS in 1.3.0, SRS in 1.1.1
    crs: CRS || SRS,
    boundingBox: [
      [getXMLFloat(minx), getXMLFloat(miny)],
      [getXMLFloat(maxx), getXMLFloat(maxy)]
    ]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const { name, units, value: extent } = xmlDimension;
  const dimension = { name, units, extent };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if ((parent == null ? void 0 : parent.geographicBoundingBox) && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if ((parent == null ? void 0 : parent.crs) && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if ((parent == null ? void 0 : parent.boundingBoxes) && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if ((parent == null ? void 0 : parent.dimensions) && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}

// dist/wms-capabilities-loader.js
var VERSION5 = true ? "4.2.0-beta.2" : "latest";
var WMSCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: VERSION5,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: testXMLFile5,
  options: {
    wms: {}
  },
  parse: async (arrayBuffer, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options == null ? void 0 : options.wms)
  ),
  parseTextSync: (text, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(text, options == null ? void 0 : options.wms)
  )
};
function testXMLFile5(text) {
  return text.startsWith("<?xml");
}

// dist/lib/parsers/wms/parse-wms-features.js
var import_xml7 = require("@loaders.gl/xml");
function parseWMSFeatureInfo(text, options) {
  var _a, _b, _c;
  const parsedXML = (_b = (_a = import_xml7.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const xmlFeatureInfo = ((_c = parsedXML.FeatureInfoResponse) == null ? void 0 : _c.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}

// dist/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
};

// dist/lib/parsers/wms/parse-wms-layer-description.js
var import_xml8 = require("@loaders.gl/xml");
function parseWMSLayerDescription(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = import_xml8.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  return parsedXML;
}

// dist/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
};

// dist/wip/lib/wfs/parse-wfs-capabilities.js
var import_xml9 = require("@loaders.gl/xml");
function parseWFSCapabilities(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = import_xml9.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, { ...options, xml: {
    ...options == null ? void 0 : options.xml,
    removeNSPrefix: true,
    uncapitalizeKeys: true
  } });
  const xmlCapabilities = parsedXML.Capabilities || parsedXML;
  return xmlCapabilities;
}

// dist/wip/wfs-capabilities-loader.js
var VERSION6 = true ? "4.2.0-beta.2" : "latest";
var WFSCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "wfs-capabilities",
  name: "WFS Capabilities",
  module: "wms",
  version: VERSION6,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wfs_xml", "application/xml", "text/xml"],
  testText: testXMLFile6,
  options: {
    wfs: {}
  },
  parse: async (arrayBuffer, options) => parseWFSCapabilities(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWFSCapabilities(text, options)
};
function testXMLFile6(text) {
  return text.startsWith("<?xml");
}

// dist/lib/parsers/gml/parse-gml.js
var import_xml10 = require("@loaders.gl/xml");

// dist/lib/parsers/gml/deep-strict-equal.js
function deepStrictEqual(actual, expected, strict) {
  if (actual === expected) {
    return true;
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();
  } else if (actual instanceof RegExp && expected instanceof RegExp) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
    return strict ? actual === expected : actual == expected;
  }
  return objEquiv(actual, expected, strict);
}
var pSlice = Array.prototype.slice;
function isPrimitive(arg) {
  return arg === null || typeof arg !== "object" && typeof arg !== "function";
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == "[object Arguments]";
}
function objEquiv(a, b, strict) {
  if (a === null || a === void 0 || b === null || b === void 0)
    return false;
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  const aIsArgs = isArguments(a);
  const bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepStrictEqual(a, b, strict);
  }
  const ka = Object.keys(a);
  const kb = Object.keys(b);
  let key;
  let i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepStrictEqual(a[key], b[key], strict))
      return false;
  }
  return true;
}

// dist/lib/parsers/gml/parse-gml.js
var import_rewind = __toESM(require("@turf/rewind"), 1);
function noTransform(...coords) {
  return coords;
}
function parseGML(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = import_xml10.XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  options = { transformCoords: noTransform, stride: 2, ...options };
  const context = createChildContext(parsedXML, options, {});
  return parseGMLToGeometry(parsedXML, options, context);
}
function parseGMLToGeometry(inputXML, options, context) {
  const childContext = createChildContext(inputXML, options, context);
  let geometry = null;
  const [name, xml] = getFirstKeyValue(inputXML);
  switch (name) {
    case "gml:LineString":
      geometry = {
        type: "LineString",
        coordinates: parseLinearRingOrLineString(xml, options, childContext)
      };
      break;
    case "gml:Polygon":
    case "gml:Rectangle":
      geometry = {
        type: "Polygon",
        coordinates: parsePolygonOrRectangle(xml, options, childContext)
      };
      break;
    case "gml:Surface":
      geometry = {
        type: "MultiPolygon",
        coordinates: parseSurface(xml, options, childContext)
      };
      break;
    case "gml:MultiSurface":
      geometry = {
        type: "MultiPolygon",
        coordinates: parseMultiSurface(xml, options, childContext)
      };
      break;
    default:
      return null;
  }
  return (0, import_rewind.default)(geometry, { mutate: true });
}
function parseCoords(s, options, context) {
  var _a;
  const stride = context.srsDimension || options.stride || 2;
  const coords = s.replace(/\s+/g, " ").trim().split(" ");
  if (coords.length === 0 || coords.length % stride !== 0) {
    throw new Error(`invalid coordinates list (stride ${stride})`);
  }
  const points = [];
  for (let i = 0; i < coords.length - 1; i += stride) {
    const point = coords.slice(i, i + stride).map(parseFloat);
    points.push(((_a = options.transformCoords) == null ? void 0 : _a.call(options, ...point)) || point);
  }
  return points;
}
function parsePosList(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const coords = textOf(xml);
  if (!coords) {
    throw new Error("invalid gml:posList element");
  }
  return parseCoords(coords, options, childContext);
}
function parsePos(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const coords = textOf(xml);
  if (!coords) {
    throw new Error("invalid gml:pos element");
  }
  const points = parseCoords(coords, options, childContext);
  if (points.length !== 1) {
    throw new Error("gml:pos must have 1 point");
  }
  return points[0];
}
function parsePoint(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const pos = findIn(xml, "gml:pos");
  if (!pos) {
    throw new Error("invalid gml:Point element, expected a gml:pos subelement");
  }
  return parsePos(pos, options, childContext);
}
function parseLinearRingOrLineString(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  let points = [];
  const posList = findIn(xml, "gml:posList");
  if (posList) {
    points = parsePosList(posList, options, childContext);
  } else {
    for (const [childName, childXML] of Object.entries(xml)) {
      switch (childName) {
        case "gml:Point":
          points.push(parsePoint(childXML, options, childContext));
          break;
        case "gml:pos":
          points.push(parsePos(childXML, options, childContext));
          break;
        default:
          continue;
      }
    }
  }
  if (points.length === 0) {
    throw new Error(`${xml.name} must have > 0 points`);
  }
  return points;
}
function parseCurveSegments(xml, options, context) {
  const points = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:LineStringSegment":
        const points2 = parseLinearRingOrLineString(childXML, options, context);
        const end = points[points.length - 1];
        const start = points2[0];
        if (end && start && deepStrictEqual(end, start)) {
          points2.shift();
        }
        points.push(...points2);
        break;
      default:
        continue;
    }
  }
  if (points.length === 0) {
    throw new Error("gml:Curve > gml:segments must have > 0 points");
  }
  return points;
}
function parseRing(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const points = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:curveMember":
        let points2;
        const lineString = findIn(childXML, "gml:LineString");
        if (lineString) {
          points2 = parseLinearRingOrLineString(lineString, options, childContext);
        } else {
          const segments = findIn(childXML, "gml:Curve", "gml:segments");
          if (!segments) {
            throw new Error(`invalid ${childName} element`);
          }
          points2 = parseCurveSegments(segments, options, childContext);
        }
        const end = points[points.length - 1];
        const start = points2[0];
        if (end && start && deepStrictEqual(end, start)) {
          points2.shift();
        }
        points.push(...points2);
        break;
    }
  }
  if (points.length < 4) {
    throw new Error(`${xml.name} must have >= 4 points`);
  }
  return points;
}
function parseExteriorOrInterior(xml, options, context) {
  const linearRing = findIn(xml, "gml:LinearRing");
  if (linearRing) {
    return parseLinearRingOrLineString(linearRing, options, context);
  }
  const ring = findIn(xml, "gml:Ring");
  if (!ring) {
    throw new Error(`invalid ${xml.name} element`);
  }
  return parseRing(ring, options, context);
}
function parsePolygonOrRectangle(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const exterior = findIn(xml, "gml:exterior");
  if (!exterior) {
    throw new Error(`invalid ${xml.name} element`);
  }
  const pointLists = [parseExteriorOrInterior(exterior, options, childContext)];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:interior":
        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));
        break;
    }
  }
  return pointLists;
}
function parseSurface(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const patches = findIn(xml, "gml:patches");
  if (!patches) {
    throw new Error(`invalid ${xml.name} element`);
  }
  const polygons = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:PolygonPatch":
      case "gml:Rectangle":
        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));
        break;
      default:
        continue;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseCompositeSurface(xml, options, context) {
  const childContext = createChildContext(xml, options, context);
  const polygons = [];
  for (const [childName, childXML] of Object.entries(xml)) {
    switch (childName) {
      case "gml:surfaceMember":
      case "gml:surfaceMembers":
        const [c2Name, c2Xml] = getFirstKeyValue(childXML);
        switch (c2Name) {
          case "gml:Surface":
            polygons.push(...parseSurface(c2Xml, options, childContext));
            break;
          case "gml:Polygon":
            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));
            break;
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseMultiSurface(xml, options, context) {
  let el = xml;
  const surfaceMembers = findIn(xml, "gml:LinearRing");
  if (surfaceMembers) {
    el = surfaceMembers;
  }
  const polygons = [];
  for (const [childName, childXML] of Object.entries(el)) {
    switch (childName) {
      case "gml:Surface":
        const polygons2 = parseSurface(childXML, options, context);
        polygons.push(...polygons2);
        break;
      case "gml:surfaceMember":
        const polygons3 = parseSurfaceMember(childXML, options, context);
        polygons.push(...polygons3);
        break;
      case "gml:surfaceMembers":
        const polygonXML = findIn(childXML, "gml:Polygon");
        for (const surfaceMemberXML of polygonXML) {
          const polygons32 = parseSurfaceMember(surfaceMemberXML, options, context);
          polygons.push(...polygons32);
        }
        break;
    }
  }
  if (polygons.length === 0) {
    throw new Error(`${xml.name} must have > 0 polygons`);
  }
  return polygons;
}
function parseSurfaceMember(xml, options, context) {
  const [childName, childXml] = getFirstKeyValue(xml);
  switch (childName) {
    case "gml:CompositeSurface":
      return parseCompositeSurface(childXml, options, context);
    case "gml:Surface":
      return parseSurface(childXml, options, context);
    case "gml:Polygon":
      return [parsePolygonOrRectangle(childXml, options, context)];
  }
  throw new Error(`${childName} must have polygons`);
}
function textOf(el) {
  if (typeof el !== "string") {
    throw new Error("expected string");
  }
  return el;
}
function findIn(root, ...tags) {
  let el = root;
  for (const tag of tags) {
    const child = el[tag];
    if (!child) {
      return null;
    }
    el = child;
  }
  return el;
}
function getFirstKeyValue(object) {
  if (object && typeof object === "object") {
    for (const [key, value] of Object.entries(object)) {
      return [key, value];
    }
  }
  return ["", null];
}
function createChildContext(xml, options, context) {
  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;
  if (srsDimensionAttribute) {
    const srsDimension = parseInt(srsDimensionAttribute);
    if (Number.isNaN(srsDimension) || srsDimension <= 0) {
      throw new Error(`invalid srsDimension attribute value "${srsDimensionAttribute}", expected a positive integer`);
    }
    const childContext = Object.create(context);
    childContext.srsDimension = srsDimension;
    return childContext;
  }
  return context;
}

// dist/gml-loader.js
var VERSION7 = true ? "4.2.0-beta.2" : "latest";
var GMLLoader = {
  dataType: null,
  batchType: null,
  name: "GML",
  id: "gml",
  module: "wms",
  version: VERSION7,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.gml", "application/xml", "text/xml"],
  testText: testXMLFile7,
  options: {
    gml: {}
  },
  parse: async (arrayBuffer, options) => parseGML(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseGML(text, options)
};
function testXMLFile7(text) {
  return text.startsWith("<?xml");
}

// dist/index.js
var import_loader_utils5 = require("@loaders.gl/loader-utils");

// dist/lib/services/create-image-service.js
function createImageService(props, services) {
  const { type = "auto" } = props;
  const service = type === "auto" ? guessServiceType(props.url, services) : getServiceOfType(type, services);
  if (!service) {
    throw new Error("Not a valid image source type");
  }
  return service.create(props);
}
function getServiceOfType(type, services) {
  for (const service of services) {
    if (service.type === type) {
      return service;
    }
  }
  return null;
}
function guessServiceType(url, services) {
  for (const service of services) {
    if (service.testURL && service.testURL(url)) {
      return service;
    }
  }
  return null;
}

// dist/services/ogc/wms-service.js
var import_images = require("@loaders.gl/images");
var import_loader_utils = require("@loaders.gl/loader-utils");
var import_loader_utils2 = require("@loaders.gl/loader-utils");
var WMSService = {
  type: "wms",
  testURL: (url) => url.toLowerCase().includes("wms"),
  create: (props) => new WMSSource(props)
};
var WMSSource = class extends import_loader_utils2.ImageSource {
  /** Base URL to the service */
  url;
  data;
  /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
  substituteCRS84;
  /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
  flipCRS;
  /** Default static WMS parameters */
  wmsParameters;
  /** Default static vendor parameters */
  vendorParameters;
  capabilities = null;
  /** Create a WMSSource */
  constructor(props) {
    super(props);
    this.url = props.url;
    this.data = props.url;
    this.substituteCRS84 = props.substituteCRS84 ?? false;
    this.flipCRS = ["EPSG:4326"];
    this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...props.wmsParameters
    };
    this.vendorParameters = props.vendorParameters || {};
  }
  // ImageService implementation
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  async getImage(parameters) {
    const { boundingBox, bbox, ...rest } = parameters;
    const wmsParameters = {
      bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
      ...rest
    };
    return await this.getMap(wmsParameters);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  // WMS Service API Stubs
  /** Get Capabilities */
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
    this.capabilities = capabilities;
    return capabilities;
  }
  /** Get a map image */
  async getMap(wmsParameters, vendorParameters) {
    const url = this.getMapURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await import_images.ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfo(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfoText(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return new TextDecoder().decode(arrayBuffer);
  }
  /** Get more information about a layer */
  async describeLayer(wmsParameters, vendorParameters) {
    const url = this.describeLayerURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get an image with a semantic legend */
  async getLegendGraphic(wmsParameters, vendorParameters) {
    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await import_images.ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetCapabilities", options, vendorParameters);
  }
  /** Generate a URL for the GetMap request */
  getMapURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const options = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      ...wmsParameters
    };
    return this._getWMSUrl("GetMap", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  getFeatureInfoURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const { boundingBox, bbox } = wmsParameters;
    wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;
    const options = {
      version: this.wmsParameters.version,
      // query_layers: [],
      // format: this.wmsParameters.format,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      // x: undefined!,
      // y: undefined!,
      ...wmsParameters
    };
    return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  describeLayerURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("DescribeLayer", options, vendorParameters);
  }
  getLegendGraphicURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      // format?
      ...wmsParameters
    };
    return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
  }
  // INTERNAL METHODS
  _parseWMSUrl(url) {
    const [baseUrl, search] = url.split("?");
    const searchParams = search.split("&");
    const parameters = {};
    for (const parameter of searchParams) {
      const [key, value] = parameter.split("=");
      parameters[key] = value;
    }
    return { url: baseUrl, parameters };
  }
  /**
   * Generate a URL with parameters
   * @note case _getWMSUrl may need to be overridden to handle certain backends?
   * @note at the moment, only URLs with parameters are supported (no XML payloads)
   * */
  _getWMSUrl(request, wmsParameters, vendorParameters) {
    let url = this.url;
    let first = true;
    const allParameters = {
      service: "WMS",
      version: wmsParameters.version,
      request,
      ...wmsParameters,
      ...this.vendorParameters,
      ...vendorParameters
    };
    const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
    for (const [key, value] of Object.entries(allParameters)) {
      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
        url += first ? "?" : "&";
        first = false;
        url += this._getURLParameter(key, value, wmsParameters);
      }
    }
    return encodeURI(url);
  }
  _getWMS130Parameters(wmsParameters) {
    const newParameters = { ...wmsParameters };
    if (newParameters.srs) {
      newParameters.crs = newParameters.crs || newParameters.srs;
      delete newParameters.srs;
    }
    return newParameters;
  }
  // eslint-disable-next-line complexity
  _getURLParameter(key, value, wmsParameters) {
    switch (key) {
      case "crs":
        if (wmsParameters.version !== "1.3.0") {
          key = "srs";
        } else if (this.substituteCRS84 && value === "EPSG:4326") {
          value = "CRS:84";
        }
        break;
      case "srs":
        if (wmsParameters.version === "1.3.0") {
          key = "crs";
        }
        break;
      case "bbox":
        const bbox = this._flipBoundingBox(value, wmsParameters);
        if (bbox) {
          value = bbox;
        }
        break;
      case "x":
        if (wmsParameters.version === "1.3.0") {
          key = "i";
        }
        break;
      case "y":
        if (wmsParameters.version === "1.3.0") {
          key = "j";
        }
        break;
      default:
    }
    key = key.toUpperCase();
    return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
  }
  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
  _flipBoundingBox(bboxValue, wmsParameters) {
    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
      return null;
    }
    const flipCoordinates = (
      // Only affects WMS 1.3.0
      wmsParameters.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
      this.flipCRS.includes(wmsParameters.crs || "") && // Don't flip if we are subsituting EPSG:4326 with CRS:84
      !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326")
    );
    const bbox = bboxValue;
    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  }
  /** Fetches an array buffer and checks the response (boilerplate reduction) */
  async _fetchArrayBuffer(url) {
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return arrayBuffer;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  _checkResponse(response, arrayBuffer) {
    var _a, _b;
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const loadOptions = (0, import_loader_utils.mergeLoaderOptions)(this.loadOptions, {
        wms: { throwOnError: true }
      });
      const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, loadOptions);
      throw new Error(error);
    }
  }
  /** Error situation detected */
  _parseError(arrayBuffer) {
    var _a, _b;
    const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.loadOptions);
    return new Error(error);
  }
};

// dist/lib/services/image-service.js
var import_images2 = require("@loaders.gl/images");
var import_loader_utils3 = require("@loaders.gl/loader-utils");
var ImageService = class extends import_loader_utils3.ImageSource {
  constructor(props) {
    super(props);
  }
  // IMAGE SOURCE API
  async getMetadata() {
    throw new Error("ImageSource.getMetadata not implemented");
  }
  async getImage(parameters) {
    const granularParameters = this.getGranularParameters(parameters);
    const url = this.getURLFromTemplate(granularParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    return await import_images2.ImageLoader.parse(arrayBuffer);
  }
  // HELPERS
  /** Break up bounding box in east, north, south, west */
  getGranularParameters(parameters) {
    const [[east, north], [west, south]] = parameters.boundingBox;
    return { ...parameters, east, north, south, west };
  }
  /** Supports both ${} and {} notations */
  getURLFromTemplate(parameters) {
    let url = this.props.url;
    for (const [key, value] of Object.entries(parameters)) {
      url = url.replace(`\${${key}}`, String(value));
      url = url.replace(`{${key}}`, String(value));
    }
    return url;
  }
};
__publicField(ImageService, "type", "template");
__publicField(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));

// dist/services/arcgis/arcgis-image-service.js
var ArcGISImageSource = class extends ImageService {
  data;
  constructor(props) {
    super(props);
    this.data = props.url;
  }
  // ImageSource (normalized endpoints)
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(parameters) {
    throw new Error("not implemented");
  }
  // ImageServer endpoints
  async metadata() {
    throw new Error("not implemented");
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
   */
  exportImage(options) {
    throw new Error("not implemented");
  }
  // URL creators
  metadataURL(options) {
    return `${this.props.url}?f=pjson`;
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
   //   f=image
   */
  exportImageURL(options) {
    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
    const size = `size=${options.width},${options.height}`;
    const arcgisOptions = { ...options, bbox, size };
    delete arcgisOptions.width;
    delete arcgisOptions.height;
    return this.getUrl("exportImage", arcgisOptions);
  }
  // INTERNAL METHODS
  /**
   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
   * @note if override is common, maybe add a callback prop?
   * */
  getUrl(path, options, extra) {
    let url = `${this.props.url}/${path}`;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += `${key.toUpperCase()}=${value.join(",")}`;
      } else {
        url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
      }
    }
    return url;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  async checkResponse(response) {
    if (!response.ok) {
      throw new Error("error");
    }
  }
};
var ArcGISImageService = {
  type: "arcgis-image-server",
  testURL: (url) => url.toLowerCase().includes("ImageServer"),
  create: (props) => new ArcGISImageSource(props)
};

// dist/services/create-image-source.js
var SERVICES = [WMSService, ArcGISImageService];
function createImageSource(props) {
  return createImageService(props, SERVICES);
}

// dist/services/ogc/csw-service.js
var import_loader_utils4 = require("@loaders.gl/loader-utils");
var CSWService = class extends import_loader_utils4.DataSource {
  capabilities = null;
  data;
  url;
  /** A list of loaders used by the CSWService methods */
  loaders = [WMSErrorLoader, CSWCapabilitiesLoader];
  /** Create a CSWService */
  constructor(props) {
    super(props);
    this.url = props.url;
    this.data = props.url;
  }
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  async getServiceDirectory(options) {
    const services = [];
    const unknownServices = [];
    const records = await this.getRecords();
    for (const record of records.records) {
      for (const reference of record.references) {
        const url = reference.value;
        switch (reference.scheme) {
          case "OGC:WMS":
            services.push({ name: record.title, type: "ogc-wms-service", ...this._parseOGCUrl(url) });
            break;
          case "OGC:WMTS":
            services.push({
              name: record.title,
              type: "ogc-wmts-service",
              ...this._parseOGCUrl(url)
            });
            break;
          case "OGC:WFS":
            services.push({ name: record.title, type: "ogc-wfs-service", ...this._parseOGCUrl(url) });
            break;
          default:
            unknownServices.push({
              name: record.title,
              type: "unknown",
              url: reference.value,
              scheme: reference.scheme
            });
        }
      }
    }
    return (options == null ? void 0 : options.includeUnknown) ? services.concat(unknownServices) : services;
  }
  _parseOGCUrl(url) {
    const parts = url.split("?");
    return {
      url: parts[0],
      params: parts[1] || ""
    };
  }
  // CSW Service API Stubs
  /** Get Capabilities */
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await CSWCapabilitiesLoader.parse(arrayBuffer, this.props.loadOptions);
    return capabilities;
  }
  /** Get Records */
  async getRecords(wmsParameters, vendorParameters) {
    const url = this.getRecordsURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await CSWRecordsLoader.parse(arrayBuffer, this.props.loadOptions);
  }
  /** Get Domain */
  async getDomain(wmsParameters, vendorParameters) {
    const url = this.getDomainURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await CSWDomainLoader.parse(arrayBuffer, this.props.loadOptions);
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetCapabilities"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  /** Generate a URL for the GetCapabilities request */
  getRecordsURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      typenames: "csw:Record",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetRecords"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  /** Generate a URL for the GetCapabilities request */
  getDomainURL(wmsParameters, vendorParameters) {
    const options = {
      version: "3.0.0",
      ...wmsParameters,
      ...vendorParameters,
      service: "CSW",
      request: "GetDomain"
    };
    return this._getCSWUrl(options, vendorParameters);
  }
  // INTERNAL METHODS
  /**
   * @note case _getCSWUrl may need to be overridden to handle certain backends?
   * */
  _getCSWUrl(options, vendorParameters) {
    let url = this.props.url;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += `${key.toUpperCase()}=${value.join(",")}`;
      } else {
        url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
      }
    }
    return encodeURI(url);
  }
  /** Checks for and parses a CSW XML formatted ServiceError and throws an exception */
  _checkResponse(response, arrayBuffer) {
    var _a, _b;
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.props.loadOptions);
      throw new Error(error);
    }
  }
  /** Error situation detected */
  _parseError(arrayBuffer) {
    var _a, _b;
    const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.props.loadOptions);
    return new Error(error);
  }
};
__publicField(CSWService, "type", "csw");
__publicField(CSWService, "testURL", (url) => url.toLowerCase().includes("csw"));

// dist/services/arcgis/arcgis-server.js
async function getArcGISServices(url, fetchFile = fetch) {
  if (url.includes("rest/services")) {
    const serverUrl = url.replace(/rest\/services.*$/i, "rest/services");
    return loadServiceDirectory(serverUrl, fetchFile, []);
  }
  return null;
}
async function loadServiceDirectory(serverUrl, fetch2, path) {
  const serviceUrl = `${serverUrl}/${path.join("/")}`;
  const response = await fetch2(`${serviceUrl}?f=pjson`);
  const directory = await response.json();
  const services = extractServices(directory, serviceUrl);
  const folders = directory.folders || [];
  const promises = folders.map((folder) => loadServiceDirectory(`${serverUrl}`, fetch2, [...path, folder]));
  for (const folderServices of await Promise.all(promises)) {
    services.push(...folderServices);
  }
  return services;
}
function extractServices(directory, url) {
  const arcgisServices = directory.services || [];
  const services = [];
  for (const service of arcgisServices) {
    services.push({
      name: service.name,
      type: `arcgis-${service.type.toLocaleLowerCase().replace("server", "-server")}`,
      url: `${url}${service.name}/${service.type}`
    });
  }
  return services;
}
//# sourceMappingURL=index.cjs.map
