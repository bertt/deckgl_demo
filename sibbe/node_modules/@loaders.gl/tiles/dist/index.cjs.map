{
  "version": 3,
  "sources": ["index.js", "tileset/tileset-3d.js", "utils/doubly-linked-list-node.js", "utils/doubly-linked-list.js", "tileset/tileset-cache.js", "tileset/helpers/transform-utils.js", "tileset/helpers/frame-state.js", "tileset/helpers/zoom.js", "tileset/tile-3d.js", "constants.js", "tileset/helpers/bounding-volume.js", "tileset/helpers/tiles-3d-lod.js", "tileset/helpers/i3s-lod.js", "tileset/helpers/3d-tiles-options.js", "utils/managed-array.js", "tileset/tileset-traverser.js", "tileset/format-3d-tiles/tileset-3d-traverser.js", "tileset/format-i3s/i3s-tileset-traverser.js", "tileset/format-i3s/i3s-pending-tiles-register.js", "tileset/format-i3s/i3s-tile-manager.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport { Tileset3D } from \"./tileset/tileset-3d.js\";\nexport { Tile3D } from \"./tileset/tile-3d.js\";\nexport { TilesetTraverser } from \"./tileset/tileset-traverser.js\";\nexport { TilesetCache } from \"./tileset/tileset-cache.js\";\nexport { createBoundingVolume } from \"./tileset/helpers/bounding-volume.js\";\nexport { calculateTransformProps } from \"./tileset/helpers/transform-utils.js\";\nexport { getFrameState } from \"./tileset/helpers/frame-state.js\";\nexport { getLodStatus } from \"./tileset/helpers/i3s-lod.js\";\nexport { TILE_CONTENT_STATE, TILE_REFINEMENT, TILE_TYPE, TILESET_TYPE, LOD_METRIC_TYPE } from \"./constants.js\";\n", "// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Stats } from '@probe.gl/stats';\nimport { RequestScheduler, path } from '@loaders.gl/loader-utils';\nimport { TilesetCache } from \"./tileset-cache.js\";\nimport { calculateTransformProps } from \"./helpers/transform-utils.js\";\nimport { getFrameState, limitSelectedTiles } from \"./helpers/frame-state.js\";\nimport { getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent } from \"./helpers/zoom.js\";\nimport { Tile3D } from \"./tile-3d.js\";\nimport { TILESET_TYPE } from \"../constants.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\n// TODO - these should be moved into their respective modules\nimport { Tileset3DTraverser } from \"./format-3d-tiles/tileset-3d-traverser.js\";\nimport { I3STilesetTraverser } from \"./format-i3s/i3s-tileset-traverser.js\";\nconst DEFAULT_PROPS = {\n    description: '',\n    ellipsoid: Ellipsoid.WGS84,\n    modelMatrix: new Matrix4(),\n    throttleRequests: true,\n    maxRequests: 64,\n    /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */\n    maximumMemoryUsage: 32,\n    memoryCacheOverflow: 1,\n    maximumTilesSelected: 0,\n    debounceTime: 0,\n    onTileLoad: () => { },\n    onTileUnload: () => { },\n    onTileError: () => { },\n    onTraversalComplete: (selectedTiles) => selectedTiles,\n    contentLoader: undefined,\n    viewDistanceScale: 1.0,\n    maximumScreenSpaceError: 8,\n    memoryAdjustedScreenSpaceError: false,\n    loadTiles: true,\n    updateTransforms: true,\n    viewportTraversersMap: null,\n    loadOptions: { fetch: {} },\n    attributions: [],\n    basePath: '',\n    i3s: {}\n};\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\nconst MAXIMUM_SSE = 'Maximum Screen Space Error';\n/**\n * The Tileset loading and rendering flow is as below,\n * A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n * `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n * to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n * `Tile3DLayer` will update rendering based on `selectedTiles`.\n * `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n * when new tiles are loaded.\n\n * As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n * During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n * after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n * Tile3DLayer\n *      |\n *  await load(tileset)\n *      |\n *  tileset.update()\n *      |                async load tileHeader\n *  tileset.traverse() -------------------------- Queued\n *      |        resume traversal after fetched  |\n *      |----------------------------------------|\n *      |\n *      |                     async load tile content\n * tilset.requestedTiles  ----------------------------- RequestScheduler\n *                                                             |\n * tilset.selectedTiles (ready for rendering)                  |\n *      |         Listen to                                    |\n *   Tile3DLayer ----------- onTileLoad  ----------------------|\n *      |                         |   notify new tile is available\n *   updateLayers                 |\n *                       tileset.update // trigger another round of update\n*/\nexport class Tileset3D {\n    // props: Tileset3DProps;\n    options;\n    loadOptions;\n    type;\n    tileset;\n    loader;\n    url;\n    basePath;\n    modelMatrix;\n    ellipsoid;\n    lodMetricType;\n    lodMetricValue;\n    refine;\n    root = null;\n    roots = {};\n    /** @todo any->unknown */\n    asset = {};\n    // Metadata for the entire tileset\n    description = '';\n    properties;\n    extras = null;\n    attributions = {};\n    credits = {};\n    stats;\n    /** flags that contain information about data types in nested tiles */\n    contentFormats = { draco: false, meshopt: false, dds: false, ktx2: false };\n    // view props\n    cartographicCenter = null;\n    cartesianCenter = null;\n    zoom = 1;\n    boundingVolume = null;\n    /** Updated based on the camera position and direction */\n    dynamicScreenSpaceErrorComputedDensity = 0.0;\n    // METRICS\n    /**\n     * The maximum amount of GPU memory (in MB) that may be used to cache tiles\n     * Tiles not in view are unloaded to enforce private\n     */\n    maximumMemoryUsage = 32;\n    /** The total amount of GPU memory in bytes used by the tileset. */\n    gpuMemoryUsageInBytes = 0;\n    /**\n     * If loading the level of detail required by maximumScreenSpaceError\n     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement\n     * will instead use this (larger) adjusted screen space error to achieve the\n     * best possible visual quality within the available memory.\n     */\n    memoryAdjustedScreenSpaceError = 0.0;\n    _cacheBytes = 0;\n    _cacheOverflowBytes = 0;\n    /** Update tracker. increase in each update cycle. */\n    _frameNumber = 0;\n    _queryParams = {};\n    _extensionsUsed = [];\n    _tiles = {};\n    /** counter for tracking tiles requests */\n    _pendingCount = 0;\n    /** Hold traversal results */\n    selectedTiles = [];\n    // TRAVERSAL\n    traverseCounter = 0;\n    geometricError = 0;\n    lastUpdatedVieports = null;\n    _requestedTiles = [];\n    _emptyTiles = [];\n    frameStateData = {};\n    _traverser;\n    _cache = new TilesetCache();\n    _requestScheduler;\n    // Promise tracking\n    updatePromise = null;\n    tilesetInitializationPromise;\n    /**\n     * Create a new Tileset3D\n     * @param json\n     * @param props\n     */\n    // eslint-disable-next-line max-statements\n    constructor(tileset, options) {\n        // PUBLIC MEMBERS\n        this.options = { ...DEFAULT_PROPS, ...options };\n        // raw data\n        this.tileset = tileset;\n        this.loader = tileset.loader;\n        // could be  3d tiles, i3s\n        this.type = tileset.type;\n        // The url to a tileset JSON file.\n        this.url = tileset.url;\n        this.basePath = tileset.basePath || path.dirname(this.url);\n        this.modelMatrix = this.options.modelMatrix;\n        this.ellipsoid = this.options.ellipsoid;\n        // Geometric error when the tree is not rendered at all\n        this.lodMetricType = tileset.lodMetricType;\n        this.lodMetricValue = tileset.lodMetricValue;\n        this.refine = tileset.root.refine;\n        this.loadOptions = this.options.loadOptions || {};\n        // TRAVERSAL\n        this._traverser = this._initializeTraverser();\n        this._requestScheduler = new RequestScheduler({\n            throttleRequests: this.options.throttleRequests,\n            maxRequests: this.options.maxRequests\n        });\n        this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;\n        this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;\n        this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;\n        // METRICS\n        // The total amount of GPU memory in bytes used by the tileset.\n        this.stats = new Stats({ id: this.url });\n        this._initializeStats();\n        this.tilesetInitializationPromise = this._initializeTileSet(tileset);\n    }\n    /** Release resources */\n    destroy() {\n        this._destroy();\n    }\n    /** Is the tileset loaded (update needs to have been called at least once) */\n    isLoaded() {\n        // Check that `_frameNumber !== 0` which means that update was called at least once\n        return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n    }\n    get tiles() {\n        return Object.values(this._tiles);\n    }\n    get frameNumber() {\n        return this._frameNumber;\n    }\n    get queryParams() {\n        return new URLSearchParams(this._queryParams).toString();\n    }\n    setProps(props) {\n        this.options = { ...this.options, ...props };\n    }\n    /** @deprecated */\n    // setOptions(options: Tileset3DProps): void {\n    //   this.options = {...this.options, ...options};\n    // }\n    /**\n     * Return a loadable tile url for a specific tile subpath\n     * @param tilePath a tile subpath\n     */\n    getTileUrl(tilePath) {\n        const isDataUrl = tilePath.startsWith('data:');\n        if (isDataUrl) {\n            return tilePath;\n        }\n        let tileUrl = tilePath;\n        if (this.queryParams.length) {\n            tileUrl = `${tilePath}${tilePath.includes('?') ? '&' : '?'}${this.queryParams}`;\n        }\n        return tileUrl;\n    }\n    // TODO CESIUM specific\n    hasExtension(extensionName) {\n        return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);\n    }\n    /**\n     * Update visible tiles relying on a list of viewports\n     * @param viewports - list of viewports\n     * @deprecated\n     */\n    update(viewports = null) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.tilesetInitializationPromise.then(() => {\n            if (!viewports && this.lastUpdatedVieports) {\n                viewports = this.lastUpdatedVieports;\n            }\n            else {\n                this.lastUpdatedVieports = viewports;\n            }\n            if (viewports) {\n                this.doUpdate(viewports);\n            }\n        });\n    }\n    /**\n     * Update visible tiles relying on a list of viewports.\n     * Do it with debounce delay to prevent update spam\n     * @param viewports viewports\n     * @returns Promise of new frameNumber\n     */\n    async selectTiles(viewports = null) {\n        await this.tilesetInitializationPromise;\n        if (viewports) {\n            this.lastUpdatedVieports = viewports;\n        }\n        if (!this.updatePromise) {\n            this.updatePromise = new Promise((resolve) => {\n                setTimeout(() => {\n                    if (this.lastUpdatedVieports) {\n                        this.doUpdate(this.lastUpdatedVieports);\n                    }\n                    resolve(this._frameNumber);\n                    this.updatePromise = null;\n                }, this.options.debounceTime);\n            });\n        }\n        return this.updatePromise;\n    }\n    adjustScreenSpaceError() {\n        if (this.gpuMemoryUsageInBytes < this._cacheBytes) {\n            this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);\n        }\n        else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {\n            this.memoryAdjustedScreenSpaceError *= 1.02;\n        }\n    }\n    /**\n     * Update visible tiles relying on a list of viewports\n     * @param viewports viewports\n     */\n    // eslint-disable-next-line max-statements, complexity\n    doUpdate(viewports) {\n        if ('loadTiles' in this.options && !this.options.loadTiles) {\n            return;\n        }\n        if (this.traverseCounter > 0) {\n            return;\n        }\n        const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n        this._cache.reset();\n        this._frameNumber++;\n        this.traverseCounter = preparedViewports.length;\n        const viewportsToTraverse = [];\n        // First loop to decrement traverseCounter\n        for (const viewport of preparedViewports) {\n            const id = viewport.id;\n            if (this._needTraverse(id)) {\n                viewportsToTraverse.push(id);\n            }\n            else {\n                this.traverseCounter--;\n            }\n        }\n        // Second loop to traverse\n        for (const viewport of preparedViewports) {\n            const id = viewport.id;\n            if (!this.roots[id]) {\n                this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n            }\n            if (!viewportsToTraverse.includes(id)) {\n                continue; // eslint-disable-line no-continue\n            }\n            const frameState = getFrameState(viewport, this._frameNumber);\n            this._traverser.traverse(this.roots[id], frameState, this.options);\n        }\n    }\n    /**\n     * Check if traversal is needed for particular viewport\n     * @param {string} viewportId - id of a viewport\n     * @return {boolean}\n     */\n    _needTraverse(viewportId) {\n        let traverserId = viewportId;\n        if (this.options.viewportTraversersMap) {\n            traverserId = this.options.viewportTraversersMap[viewportId];\n        }\n        if (traverserId !== viewportId) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * The callback to post-process tiles after traversal procedure\n     * @param frameState - frame state for tile culling\n     */\n    _onTraversalEnd(frameState) {\n        const id = frameState.viewport.id;\n        if (!this.frameStateData[id]) {\n            this.frameStateData[id] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] };\n        }\n        const currentFrameStateData = this.frameStateData[id];\n        const selectedTiles = Object.values(this._traverser.selectedTiles);\n        const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);\n        currentFrameStateData.selectedTiles = filteredSelectedTiles;\n        for (const tile of unselectedTiles) {\n            tile.unselect();\n        }\n        currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n        currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n        this.traverseCounter--;\n        if (this.traverseCounter > 0) {\n            return;\n        }\n        this._updateTiles();\n    }\n    /**\n     * Update tiles relying on data from all traversers\n     */\n    _updateTiles() {\n        this.selectedTiles = [];\n        this._requestedTiles = [];\n        this._emptyTiles = [];\n        for (const frameStateKey in this.frameStateData) {\n            const frameStateDataValue = this.frameStateData[frameStateKey];\n            this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n            this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n            this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n        }\n        this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n        for (const tile of this.selectedTiles) {\n            this._tiles[tile.id] = tile;\n        }\n        this._loadTiles();\n        this._unloadTiles();\n        this._updateStats();\n    }\n    _tilesChanged(oldSelectedTiles, selectedTiles) {\n        if (oldSelectedTiles.length !== selectedTiles.length) {\n            return true;\n        }\n        const set1 = new Set(oldSelectedTiles.map((t) => t.id));\n        const set2 = new Set(selectedTiles.map((t) => t.id));\n        let changed = oldSelectedTiles.filter((x) => !set2.has(x.id)).length > 0;\n        changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;\n        return changed;\n    }\n    _loadTiles() {\n        // Sort requests by priority before making any requests.\n        // This makes it less likely this requests will be cancelled after being issued.\n        // requestedTiles.sort((a, b) => a._priority - b._priority);\n        for (const tile of this._requestedTiles) {\n            if (tile.contentUnloaded) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                this._loadTile(tile);\n            }\n        }\n    }\n    _unloadTiles() {\n        // unload tiles from cache when hit maximumMemoryUsage\n        this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n    }\n    _updateStats() {\n        let tilesRenderable = 0;\n        let pointsRenderable = 0;\n        for (const tile of this.selectedTiles) {\n            if (tile.contentAvailable && tile.content) {\n                tilesRenderable++;\n                if (tile.content.pointCount) {\n                    pointsRenderable += tile.content.pointCount;\n                }\n                else {\n                    // Calculate vertices for non point cloud tiles.\n                    pointsRenderable += tile.content.vertexCount;\n                }\n            }\n        }\n        this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n        this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n        this.stats.get(POINTS_COUNT).count = pointsRenderable;\n        this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;\n    }\n    async _initializeTileSet(tilesetJson) {\n        if (this.type === TILESET_TYPE.I3S) {\n            this.calculateViewPropsI3S();\n            tilesetJson.root = await tilesetJson.root;\n        }\n        this.root = this._initializeTileHeaders(tilesetJson, null);\n        if (this.type === TILESET_TYPE.TILES3D) {\n            this._initializeTiles3DTileset(tilesetJson);\n            this.calculateViewPropsTiles3D();\n        }\n        if (this.type === TILESET_TYPE.I3S) {\n            this._initializeI3STileset();\n        }\n    }\n    /**\n     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n     * These metrics help apps center view on tileset\n     * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n     * @returns\n     */\n    calculateViewPropsI3S() {\n        // for I3S 1.8 try to calculate with fullExtent\n        const fullExtent = this.tileset.fullExtent;\n        if (fullExtent) {\n            const { xmin, xmax, ymin, ymax, zmin, zmax } = fullExtent;\n            this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);\n            this.cartesianCenter = new Vector3();\n            Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n            this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n            return;\n        }\n        // for I3S 1.6-1.7 try to calculate with extent\n        const extent = this.tileset.store?.extent;\n        if (extent) {\n            const [xmin, ymin, xmax, ymax] = extent;\n            this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n            this.cartesianCenter = new Vector3();\n            Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);\n            this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n            return;\n        }\n        // eslint-disable-next-line no-console\n        console.warn('Extent is not defined in the tileset header');\n        this.cartographicCenter = new Vector3();\n        this.zoom = 1;\n        return;\n    }\n    /**\n     * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n     * These metrics help apps center view on tileset.\n     * For 3DTiles the root tile data is used to calculate view props.\n     * @returns\n     */\n    calculateViewPropsTiles3D() {\n        const root = this.root;\n        const { center } = root.boundingVolume;\n        // TODO - handle all cases\n        if (!center) {\n            // eslint-disable-next-line no-console\n            console.warn('center was not pre-calculated for the root tile');\n            this.cartographicCenter = new Vector3();\n            this.zoom = 1;\n            return;\n        }\n        // cartographic coordinates are undefined at the center of the ellipsoid\n        if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n            this.cartographicCenter = new Vector3();\n            Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);\n        }\n        else {\n            this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n        }\n        this.cartesianCenter = center;\n        this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n    }\n    _initializeStats() {\n        this.stats.get(TILES_TOTAL);\n        this.stats.get(TILES_LOADING);\n        this.stats.get(TILES_IN_MEMORY);\n        this.stats.get(TILES_IN_VIEW);\n        this.stats.get(TILES_RENDERABLE);\n        this.stats.get(TILES_LOADED);\n        this.stats.get(TILES_UNLOADED);\n        this.stats.get(TILES_LOAD_FAILED);\n        this.stats.get(POINTS_COUNT);\n        this.stats.get(TILES_GPU_MEMORY, 'memory');\n        this.stats.get(MAXIMUM_SSE);\n    }\n    // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n    // eslint-disable-next-line max-statements\n    _initializeTileHeaders(tilesetJson, parentTileHeader) {\n        // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n        // Get the basePath relative to the external tileset.\n        const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n        // If there is a parentTileHeader, add the root of the currently loading tileset\n        // to parentTileHeader's children, and update its depth.\n        if (parentTileHeader) {\n            parentTileHeader.children.push(rootTile);\n            rootTile.depth = parentTileHeader.depth + 1;\n        }\n        // 3DTiles knows the hierarchy beforehand\n        if (this.type === TILESET_TYPE.TILES3D) {\n            const stack = [];\n            stack.push(rootTile);\n            while (stack.length > 0) {\n                const tile = stack.pop();\n                this.stats.get(TILES_TOTAL).incrementCount();\n                const children = tile.header.children || [];\n                for (const childHeader of children) {\n                    const childTile = new Tile3D(this, childHeader, tile);\n                    // Special handling for Google\n                    // A session key must be used for all tile requests\n                    if (childTile.contentUrl?.includes('?session=')) {\n                        const url = new URL(childTile.contentUrl);\n                        const session = url.searchParams.get('session');\n                        // eslint-disable-next-line max-depth\n                        if (session) {\n                            this._queryParams.session = session;\n                        }\n                    }\n                    tile.children.push(childTile);\n                    childTile.depth = tile.depth + 1;\n                    stack.push(childTile);\n                }\n            }\n        }\n        return rootTile;\n    }\n    _initializeTraverser() {\n        let TraverserClass;\n        const type = this.type;\n        switch (type) {\n            case TILESET_TYPE.TILES3D:\n                TraverserClass = Tileset3DTraverser;\n                break;\n            case TILESET_TYPE.I3S:\n                TraverserClass = I3STilesetTraverser;\n                break;\n            default:\n                TraverserClass = TilesetTraverser;\n        }\n        return new TraverserClass({\n            basePath: this.basePath,\n            onTraversalEnd: this._onTraversalEnd.bind(this)\n        });\n    }\n    _destroyTileHeaders(parentTile) {\n        this._destroySubtree(parentTile);\n    }\n    async _loadTile(tile) {\n        let loaded;\n        try {\n            this._onStartTileLoading();\n            loaded = await tile.loadContent();\n        }\n        catch (error) {\n            this._onTileLoadError(tile, error instanceof Error ? error : new Error('load failed'));\n        }\n        finally {\n            this._onEndTileLoading();\n            this._onTileLoad(tile, loaded);\n        }\n    }\n    _onTileLoadError(tile, error) {\n        this.stats.get(TILES_LOAD_FAILED).incrementCount();\n        const message = error.message || error.toString();\n        const url = tile.url;\n        // TODO - Allow for probe log to be injected instead of console?\n        console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n        this.options.onTileError(tile, message, url);\n    }\n    _onTileLoad(tile, loaded) {\n        if (!loaded) {\n            return;\n        }\n        if (this.type === TILESET_TYPE.I3S) {\n            // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n            const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n            this.stats.get(TILES_TOTAL).reset();\n            this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n        }\n        // add coordinateOrigin and modelMatrix to tile\n        if (tile && tile.content) {\n            calculateTransformProps(tile, tile.content);\n        }\n        this.updateContentTypes(tile);\n        this._addTileToCache(tile);\n        this.options.onTileLoad(tile);\n    }\n    /**\n     * Update information about data types in nested tiles\n     * @param tile instance of a nested Tile3D\n     */\n    updateContentTypes(tile) {\n        if (this.type === TILESET_TYPE.I3S) {\n            if (tile.header.isDracoGeometry) {\n                this.contentFormats.draco = true;\n            }\n            switch (tile.header.textureFormat) {\n                case 'dds':\n                    this.contentFormats.dds = true;\n                    break;\n                case 'ktx2':\n                    this.contentFormats.ktx2 = true;\n                    break;\n                default:\n            }\n        }\n        else if (this.type === TILESET_TYPE.TILES3D) {\n            const { extensionsRemoved = [] } = tile.content?.gltf || {};\n            if (extensionsRemoved.includes('KHR_draco_mesh_compression')) {\n                this.contentFormats.draco = true;\n            }\n            if (extensionsRemoved.includes('EXT_meshopt_compression')) {\n                this.contentFormats.meshopt = true;\n            }\n            if (extensionsRemoved.includes('KHR_texture_basisu')) {\n                this.contentFormats.ktx2 = true;\n            }\n        }\n    }\n    _onStartTileLoading() {\n        this._pendingCount++;\n        this.stats.get(TILES_LOADING).incrementCount();\n    }\n    _onEndTileLoading() {\n        this._pendingCount--;\n        this.stats.get(TILES_LOADING).decrementCount();\n    }\n    _addTileToCache(tile) {\n        this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));\n    }\n    _updateCacheStats(tile) {\n        this.stats.get(TILES_LOADED).incrementCount();\n        this.stats.get(TILES_IN_MEMORY).incrementCount();\n        // TODO: Calculate GPU memory usage statistics for a tile.\n        this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;\n        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n        // Adjust SSE based on cache limits\n        if (this.options.memoryAdjustedScreenSpaceError) {\n            this.adjustScreenSpaceError();\n        }\n    }\n    _unloadTile(tile) {\n        this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;\n        this.stats.get(TILES_IN_MEMORY).decrementCount();\n        this.stats.get(TILES_UNLOADED).incrementCount();\n        this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n        this.options.onTileUnload(tile);\n        tile.unloadContent();\n    }\n    // Traverse the tree and destroy all tiles\n    _destroy() {\n        const stack = [];\n        if (this.root) {\n            stack.push(this.root);\n        }\n        while (stack.length > 0) {\n            const tile = stack.pop();\n            for (const child of tile.children) {\n                stack.push(child);\n            }\n            this._destroyTile(tile);\n        }\n        this.root = null;\n    }\n    // Traverse the tree and destroy all sub tiles\n    _destroySubtree(tile) {\n        const root = tile;\n        const stack = [];\n        stack.push(root);\n        while (stack.length > 0) {\n            tile = stack.pop();\n            for (const child of tile.children) {\n                stack.push(child);\n            }\n            if (tile !== root) {\n                this._destroyTile(tile);\n            }\n        }\n        root.children = [];\n    }\n    _destroyTile(tile) {\n        this._cache.unloadTile(this, tile);\n        this._unloadTile(tile);\n        tile.destroy();\n    }\n    _initializeTiles3DTileset(tilesetJson) {\n        if (tilesetJson.queryString) {\n            const searchParams = new URLSearchParams(tilesetJson.queryString);\n            const queryParams = Object.fromEntries(searchParams.entries());\n            this._queryParams = { ...this._queryParams, ...queryParams };\n        }\n        this.asset = tilesetJson.asset;\n        if (!this.asset) {\n            throw new Error('Tileset must have an asset property.');\n        }\n        if (this.asset.version !== '0.0' &&\n            this.asset.version !== '1.0' &&\n            this.asset.version !== '1.1') {\n            throw new Error('The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.');\n        }\n        // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n        // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n        if ('tilesetVersion' in this.asset) {\n            this._queryParams.v = this.asset.tilesetVersion;\n        }\n        // TODO - ion resources have a credits property we can use for additional attribution.\n        this.credits = {\n            attributions: this.options.attributions || []\n        };\n        this.description = this.options.description || '';\n        // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n        this.properties = tilesetJson.properties;\n        this.geometricError = tilesetJson.geometricError;\n        this._extensionsUsed = tilesetJson.extensionsUsed || [];\n        // Returns the extras property at the top of the tileset JSON (application specific metadata).\n        this.extras = tilesetJson.extras;\n    }\n    _initializeI3STileset() {\n        // @ts-expect-error\n        if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n            // @ts-ignore\n            this._queryParams.token = this.loadOptions.i3s.token;\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/**\n * Doubly linked list node\n * @private\n */\nexport class DoublyLinkedListNode {\n    item;\n    previous;\n    next;\n    constructor(item, previous, next) {\n        this.item = item;\n        this.previous = previous;\n        this.next = next;\n    }\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { DoublyLinkedListNode } from \"./doubly-linked-list-node.js\";\n/**\n * Doubly linked list\n * @private\n */\nexport class DoublyLinkedList {\n    head = null;\n    tail = null;\n    _length = 0;\n    get length() {\n        return this._length;\n    }\n    /**\n     * Adds the item to the end of the list\n     * @param {*} [item]\n     * @return {DoublyLinkedListNode}\n     */\n    add(item) {\n        const node = new DoublyLinkedListNode(item, this.tail, null);\n        if (this.tail) {\n            this.tail.next = node;\n            this.tail = node;\n        }\n        else {\n            this.head = node;\n            this.tail = node;\n        }\n        ++this._length;\n        return node;\n    }\n    /**\n     * Removes the given node from the list\n     * @param {DoublyLinkedListNode} node\n     */\n    remove(node) {\n        if (!node) {\n            return;\n        }\n        if (node.previous && node.next) {\n            node.previous.next = node.next;\n            node.next.previous = node.previous;\n        }\n        else if (node.previous) {\n            // Remove last node\n            node.previous.next = null;\n            this.tail = node.previous;\n        }\n        else if (node.next) {\n            // Remove first node\n            node.next.previous = null;\n            this.head = node.next;\n        }\n        else {\n            // Remove last node in the linked list\n            this.head = null;\n            this.tail = null;\n        }\n        node.next = null;\n        node.previous = null;\n        --this._length;\n    }\n    /**\n     * Moves nextNode after node\n     * @param {DoublyLinkedListNode} node\n     * @param {DoublyLinkedListNode} nextNode\n     */\n    splice(node, nextNode) {\n        if (node === nextNode) {\n            return;\n        }\n        // Remove nextNode, then insert after node\n        this.remove(nextNode);\n        this._insert(node, nextNode);\n    }\n    _insert(node, nextNode) {\n        const oldNodeNext = node.next;\n        node.next = nextNode;\n        // nextNode is the new tail\n        if (this.tail === node) {\n            this.tail = nextNode;\n        }\n        else {\n            oldNodeNext.previous = nextNode;\n        }\n        nextNode.next = oldNodeNext;\n        nextNode.previous = node;\n        ++this._length;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { DoublyLinkedList } from \"../utils/doubly-linked-list.js\";\n/**\n * Stores tiles with content loaded.\n * @private\n */\nexport class TilesetCache {\n    _list;\n    _sentinel;\n    _trimTiles;\n    constructor() {\n        // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache\n        // (sentinel, tail] -> tiles that were selected this frame\n        this._list = new DoublyLinkedList();\n        this._sentinel = this._list.add('sentinel');\n        this._trimTiles = false;\n    }\n    reset() {\n        // Move sentinel node to the tail so, at the start of the frame, all tiles\n        // may be potentially replaced.  Tiles are moved to the right of the sentinel\n        // when they are selected so they will not be replaced.\n        this._list.splice(this._list.tail, this._sentinel);\n    }\n    touch(tile) {\n        const node = tile._cacheNode;\n        if (node) {\n            this._list.splice(this._sentinel, node);\n        }\n    }\n    add(tileset, tile, addCallback) {\n        if (!tile._cacheNode) {\n            tile._cacheNode = this._list.add(tile);\n            if (addCallback) {\n                addCallback(tileset, tile);\n            }\n        }\n    }\n    unloadTile(tileset, tile, unloadCallback) {\n        const node = tile._cacheNode;\n        if (!node) {\n            return;\n        }\n        this._list.remove(node);\n        tile._cacheNode = null;\n        if (unloadCallback) {\n            unloadCallback(tileset, tile);\n        }\n    }\n    unloadTiles(tileset, unloadCallback) {\n        const trimTiles = this._trimTiles;\n        this._trimTiles = false;\n        const list = this._list;\n        const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n        // Traverse the list only to the sentinel since tiles/nodes to the\n        // right of the sentinel were used this frame.\n        // The sub-list to the left of the sentinel is ordered from LRU to MRU.\n        const sentinel = this._sentinel;\n        let node = list.head;\n        while (node !== sentinel &&\n            (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {\n            // @ts-expect-error\n            const tile = node.item;\n            // @ts-expect-error\n            node = node.next;\n            this.unloadTile(tileset, tile, unloadCallback);\n        }\n    }\n    trim() {\n        this._trimTiles = true;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nexport function calculateTransformProps(tileHeader, tile) {\n    assert(tileHeader);\n    assert(tile);\n    const { rtcCenter, gltfUpAxis } = tile;\n    const { computedTransform, boundingVolume: { center } } = tileHeader;\n    let modelMatrix = new Matrix4(computedTransform);\n    // Translate if appropriate\n    if (rtcCenter) {\n        modelMatrix.translate(rtcCenter);\n    }\n    // glTF models need to be rotated from Y to Z up\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n    switch (gltfUpAxis) {\n        case 'Z':\n            break;\n        case 'Y':\n            const rotationY = new Matrix4().rotateX(Math.PI / 2);\n            modelMatrix = modelMatrix.multiplyRight(rotationY);\n            break;\n        case 'X':\n            const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n            modelMatrix = modelMatrix.multiplyRight(rotationX);\n            break;\n        default:\n            break;\n    }\n    // Scale/offset positions if normalized integers\n    if (tile.isQuantized) {\n        modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n    }\n    // Option 1: Cartesian matrix and origin\n    const cartesianOrigin = new Vector3(center);\n    tile.cartesianModelMatrix = modelMatrix;\n    tile.cartesianOrigin = cartesianOrigin;\n    // Option 2: Cartographic matrix and origin\n    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n    tile.cartographicOrigin = cartographicOrigin;\n    // Deprecated, drop\n    if (!tile.coordinateSystem) {\n        tile.modelMatrix = tile.cartographicModelMatrix;\n    }\n}\n", "import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane()\n]);\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber) {\n    // Traverse and and request. Update _selectedTiles so that we know what to render.\n    // Traverse and and request. Update _selectedTiles so that we know what to render.\n    const { cameraDirection, cameraUp, height } = viewport;\n    const { metersPerUnit } = viewport.distanceScales;\n    // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n    // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n    const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n    // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n    const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n    const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n    commonSpacePlanesToWGS84(viewport);\n    const ViewportClass = viewport.constructor;\n    const { longitude, latitude, width, bearing, zoom } = viewport;\n    // @ts-ignore\n    const topDownViewport = new ViewportClass({\n        longitude,\n        latitude,\n        height,\n        width,\n        bearing,\n        zoom,\n        pitch: 0\n    });\n    // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n    return {\n        camera: {\n            position: cameraPositionCartesian,\n            direction: cameraDirectionCartesian,\n            up: cameraUpCartesian\n        },\n        viewport,\n        topDownViewport,\n        height,\n        cullingVolume,\n        frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n        sseDenominator: 1.15 // Assumes fovy = 60 degrees\n    };\n}\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {\n    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n        return [tiles, []];\n    }\n    // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n    const tuples = [];\n    const { longitude: viewportLongitude, latitude: viewportLatitude } = frameState.viewport;\n    for (const [index, tile] of tiles.entries()) {\n        const [longitude, latitude] = tile.header.mbs;\n        const deltaLon = Math.abs(viewportLongitude - longitude);\n        const deltaLat = Math.abs(viewportLatitude - latitude);\n        const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n        tuples.push([index, distance]);\n    }\n    const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n    const selectedTiles = [];\n    for (let i = 0; i < maximumTilesSelected; i++) {\n        selectedTiles.push(tiles[tuplesSorted[i][0]]);\n    }\n    const unselectedTiles = [];\n    for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n        unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n    }\n    return [selectedTiles, unselectedTiles];\n}\nfunction commonSpacePlanesToWGS84(viewport) {\n    // Extract frustum planes based on current view.\n    const frustumPlanes = viewport.getFrustumPlanes();\n    // Get the near/far plane centers\n    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n    let i = 0;\n    cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian));\n    for (const dir in frustumPlanes) {\n        if (dir === 'near') {\n            continue; // eslint-disable-line no-continue\n        }\n        const plane = frustumPlanes[dir];\n        const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n        const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n        cullingVolume.planes[i++].fromPointNormal(cartesianPos, \n        // Want the normal to point into the frustum since that's what culling expects\n        scratchVector.copy(nearCenterCartesian).subtract(cartesianPos));\n    }\n}\nfunction closestPointOnPlane(plane, refPoint, out = new Vector3()) {\n    const distanceToRef = plane.normal.dot(refPoint);\n    out\n        .copy(plane.normal)\n        .scale(plane.distance - distanceToRef)\n        .add(refPoint);\n    return out;\n}\nfunction worldToCartesian(viewport, point, out = new Vector3()) {\n    const cartographicPos = viewport.unprojectPosition(point);\n    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {\n    if (boundingVolume instanceof OrientedBoundingBox) {\n        // OrientedBoundingBox\n        const { halfAxes } = boundingVolume;\n        const obbSize = getObbSize(halfAxes);\n        // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n        // Add the tile elevation value for correct zooming to elevated tiles\n        return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n    }\n    else if (boundingVolume instanceof BoundingSphere) {\n        // BoundingSphere\n        const { radius } = boundingVolume;\n        // Add the tile elevation value for correct zooming to elevated tiles\n        return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n    }\n    else if (boundingVolume.width && boundingVolume.height) {\n        // BoundingRectangle\n        const { width, height } = boundingVolume;\n        const zoomX = Math.log2(WGS84_RADIUS_X / width);\n        const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n        return (zoomX + zoomY) / 2;\n    }\n    return 1;\n}\n/**\n * Calculate initial zoom for the tileset from 3D `fullExtent` defined in\n * the tileset metadata\n * @param fullExtent - 3D extent of the tileset\n * @param fullExtent.xmin - minimal longitude in decimal degrees\n * @param fullExtent.xmax - maximal longitude in decimal degrees\n * @param fullExtent.ymin - minimal latitude in decimal degrees\n * @param fullExtent.ymax - maximal latitude in decimal degrees\n * @param fullExtent.zmin - minimal elevation in meters\n * @param fullExtent.zmax - maximal elevation in meters\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {\n    Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector);\n    const extentSize = Math.sqrt(Math.pow(scratchVector[0] - cartesianCenter[0], 2) +\n        Math.pow(scratchVector[1] - cartesianCenter[1], 2) +\n        Math.pow(scratchVector[2] - cartesianCenter[2], 2));\n    return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\n/**\n * Calculate initial zoom for the tileset from 2D `extent` defined in\n * the tileset metadata\n * @param extent - 2D extent of the tileset. It is array of 4 elements [xmin, ymin, xmax, ymax]\n * @param extent[0] - minimal longitude in decimal degrees\n * @param extent[1] - minimal latitude in decimal degrees\n * @param extent[2] - maximal longitude in decimal degrees\n * @param extent[3] - maximal latitude in decimal degrees\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {\n    const [xmin, ymin, xmax, ymax] = extent;\n    return getZoomFromFullExtent({ xmin, xmax, ymin, ymax, zmin: 0, zmax: 0 }, cartorgraphicCenter, cartesianCenter);\n}\nfunction getObbSize(halfAxes) {\n    halfAxes.getColumn(0, scratchVector);\n    const axeY = halfAxes.getColumn(1);\n    const axeZ = halfAxes.getColumn(2);\n    const farthestVertex = scratchVector.add(axeY).add(axeZ);\n    const size = farthestVertex.len();\n    return size;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport { CullingVolume } from '@math.gl/culling';\nimport { load } from '@loaders.gl/core';\nimport { TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE } from \"../constants.js\";\nimport { createBoundingVolume, getCartographicBounds } from \"./helpers/bounding-volume.js\";\nimport { getTiles3DScreenSpaceError } from \"./helpers/tiles-3d-lod.js\";\nimport { getProjectedRadius } from \"./helpers/i3s-lod.js\";\nimport { get3dTilesOptions } from \"./helpers/3d-tiles-options.js\";\nimport { TilesetTraverser } from \"./tileset-traverser.js\";\nconst scratchVector = new Vector3();\nfunction defined(x) {\n    return x !== undefined && x !== null;\n}\n/**\n * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\n */\nexport class Tile3D {\n    tileset;\n    header;\n    id;\n    url;\n    parent;\n    /* Specifies the type of refine that is used when traversing this tile for rendering. */\n    refine;\n    type;\n    contentUrl;\n    /** Different refinement algorithms used by I3S and 3D tiles */\n    lodMetricType = 'geometricError';\n    /** The error, in meters, introduced if this tile is rendered and its children are not. */\n    lodMetricValue = 0;\n    /** @todo math.gl is not exporting BoundingVolume base type? */\n    boundingVolume = null;\n    /**\n     * The tile's content.  This represents the actual tile's payload,\n     * not the content's metadata in the tileset JSON file.\n     */\n    content = null;\n    contentState = TILE_CONTENT_STATE.UNLOADED;\n    gpuMemoryUsageInBytes = 0;\n    /** The tile's children - an array of Tile3D objects. */\n    children = [];\n    depth = 0;\n    viewportIds = [];\n    transform = new Matrix4();\n    extensions = null;\n    /** TODO Cesium 3d tiles specific */\n    implicitTiling = null;\n    /** Container to store application specific data */\n    userData = {};\n    computedTransform;\n    hasEmptyContent = false;\n    hasTilesetContent = false;\n    traverser = new TilesetTraverser({});\n    /** Used by TilesetCache */\n    _cacheNode = null;\n    _frameNumber = null;\n    // TODO Cesium 3d tiles specific\n    _expireDate = null;\n    _expiredContent = null;\n    _boundingBox = undefined;\n    /** updated every frame for tree traversal and rendering optimizations: */\n    _distanceToCamera = 0;\n    _screenSpaceError = 0;\n    _visibilityPlaneMask;\n    _visible = undefined;\n    _contentBoundingVolume;\n    _viewerRequestVolume;\n    _initialTransform = new Matrix4();\n    // Used by traverser, cannot be marked private\n    _priority = 0;\n    _selectedFrame = 0;\n    _requestedFrame = 0;\n    _selectionDepth = 0;\n    _touchedFrame = 0;\n    _centerZDepth = 0;\n    _shouldRefine = false;\n    _stackLength = 0;\n    _visitedFrame = 0;\n    _inRequestVolume = false;\n    _lodJudge = null; // TODO i3s specific, needs to remove\n    /**\n     * @constructs\n     * Create a Tile3D instance\n     * @param tileset - Tileset3D instance\n     * @param header - tile header - JSON loaded from a dataset\n     * @param parentHeader - parent Tile3D instance\n     * @param extendedId - optional ID to separate copies of a tile for different viewports.\n     *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n     */\n    // eslint-disable-next-line max-statements\n    constructor(tileset, header, parentHeader, extendedId = '') {\n        // PUBLIC MEMBERS\n        // original tile data\n        this.header = header;\n        // The tileset containing this tile.\n        this.tileset = tileset;\n        this.id = extendedId || header.id;\n        this.url = header.url;\n        // This tile's parent or `undefined` if this tile is the root.\n        // @ts-ignore\n        this.parent = parentHeader;\n        this.refine = this._getRefine(header.refine);\n        this.type = header.type;\n        this.contentUrl = header.contentUrl;\n        this._initializeLodMetric(header);\n        this._initializeTransforms(header);\n        this._initializeBoundingVolumes(header);\n        this._initializeContent(header);\n        this._initializeRenderingState(header);\n        Object.seal(this);\n    }\n    destroy() {\n        this.header = null;\n    }\n    isDestroyed() {\n        return this.header === null;\n    }\n    get selected() {\n        return this._selectedFrame === this.tileset._frameNumber;\n    }\n    get isVisible() {\n        return this._visible;\n    }\n    get isVisibleAndInRequestVolume() {\n        return this._visible && this._inRequestVolume;\n    }\n    /** Returns true if tile is not an empty tile and not an external tileset */\n    get hasRenderContent() {\n        return !this.hasEmptyContent && !this.hasTilesetContent;\n    }\n    /** Returns true if tile has children */\n    get hasChildren() {\n        return this.children.length > 0 || (this.header.children && this.header.children.length > 0);\n    }\n    /**\n     * Determines if the tile's content is ready. This is automatically `true` for\n     * tiles with empty content.\n     */\n    get contentReady() {\n        return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n    }\n    /**\n     * Determines if the tile has available content to render.  `true` if the tile's\n     * content is ready or if it has expired content this renders while new content loads; otherwise,\n     */\n    get contentAvailable() {\n        return Boolean((this.contentReady && this.hasRenderContent) || (this._expiredContent && !this.contentFailed));\n    }\n    /** Returns true if tile has renderable content but it's unloaded */\n    get hasUnloadedContent() {\n        return this.hasRenderContent && this.contentUnloaded;\n    }\n    /**\n     * Determines if the tile's content has not be requested. `true` if tile's\n     * content has not be requested; otherwise, `false`.\n     */\n    get contentUnloaded() {\n        return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n    }\n    /**\n     * Determines if the tile's content is expired. `true` if tile's\n     * content is expired; otherwise, `false`.\n     */\n    get contentExpired() {\n        return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n    }\n    // Determines if the tile's content failed to load.  `true` if the tile's\n    // content failed to load; otherwise, `false`.\n    get contentFailed() {\n        return this.contentState === TILE_CONTENT_STATE.FAILED;\n    }\n    /**\n     * Distance from the tile's bounding volume center to the camera\n     */\n    get distanceToCamera() {\n        return this._distanceToCamera;\n    }\n    /**\n     * Screen space error for LOD selection\n     */\n    get screenSpaceError() {\n        return this._screenSpaceError;\n    }\n    /**\n     * Get bounding box in cartographic coordinates\n     * @returns [min, max] each in [longitude, latitude, altitude]\n     */\n    get boundingBox() {\n        if (!this._boundingBox) {\n            this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);\n        }\n        return this._boundingBox;\n    }\n    /** Get the tile's screen space error. */\n    getScreenSpaceError(frameState, useParentLodMetric) {\n        switch (this.tileset.type) {\n            case TILESET_TYPE.I3S:\n                return getProjectedRadius(this, frameState);\n            case TILESET_TYPE.TILES3D:\n                return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n            default:\n                // eslint-disable-next-line\n                throw new Error('Unsupported tileset type');\n        }\n    }\n    /**\n     * Make tile unselected than means it won't be shown\n     * but it can be still loaded in memory\n     */\n    unselect() {\n        this._selectedFrame = 0;\n    }\n    /**\n     * Memory usage of tile on GPU\n     */\n    _getGpuMemoryUsageInBytes() {\n        return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;\n    }\n    /*\n     * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n     * Tiles are prioritized by screen space error.\n     */\n    // eslint-disable-next-line complexity\n    _getPriority() {\n        const traverser = this.tileset._traverser;\n        const { skipLevelOfDetail } = traverser.options;\n        /*\n         * Tiles that are outside of the camera's frustum could be skipped if we are in 'ADD' mode\n         * or if we are using 'Skip Traversal' in 'REPLACE' mode.\n         * Otherewise, all 'touched' child tiles have to be loaded and displayed,\n         * this may include tiles that are outide of the camera frustum (so that we can hide the parent tile).\n         */\n        const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n        // Check if any reason to abort\n        if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n            return -1;\n        }\n        // Condition used in `cancelOutOfViewRequests` function in CesiumJS/Cesium3DTileset.js\n        if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n            return -1;\n        }\n        if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n            return -1;\n        }\n        // Based on the priority function `getPriorityReverseScreenSpaceError` in CesiumJS. Scheduling priority is based on the parent's screen space error when possible.\n        const parent = this.parent;\n        const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n            ? parent._screenSpaceError\n            : this._screenSpaceError;\n        const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n        // Map higher SSE to lower values (e.g. root tile is highest priority)\n        return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n    }\n    /**\n     *  Requests the tile's content.\n     * The request may not be made if the Request Scheduler can't prioritize it.\n     */\n    // eslint-disable-next-line max-statements, complexity\n    async loadContent() {\n        if (this.hasEmptyContent) {\n            return false;\n        }\n        if (this.content) {\n            return true;\n        }\n        const expired = this.contentExpired;\n        if (expired) {\n            this._expireDate = null;\n        }\n        this.contentState = TILE_CONTENT_STATE.LOADING;\n        const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));\n        if (!requestToken) {\n            // cancelled\n            this.contentState = TILE_CONTENT_STATE.UNLOADED;\n            return false;\n        }\n        try {\n            const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n            // The content can be a binary tile ot a JSON tileset\n            const loader = this.tileset.loader;\n            const options = {\n                ...this.tileset.loadOptions,\n                [loader.id]: {\n                    // @ts-expect-error\n                    ...this.tileset.loadOptions[loader.id],\n                    isTileset: this.type === 'json',\n                    ...this._getLoaderSpecificOptions(loader.id)\n                }\n            };\n            this.content = await load(contentUrl, loader, options);\n            if (this.tileset.options.contentLoader) {\n                await this.tileset.options.contentLoader(this);\n            }\n            if (this._isTileset()) {\n                // Add tile headers for the nested tilset's subtree\n                // Async update of the tree should be fine since there would never be edits to the same node\n                // TODO - we need to capture the child tileset's URL\n                this.tileset._initializeTileHeaders(this.content, this);\n            }\n            this.contentState = TILE_CONTENT_STATE.READY;\n            this._onContentLoaded();\n            return true;\n        }\n        catch (error) {\n            // Tile is unloaded before the content finishes loading\n            this.contentState = TILE_CONTENT_STATE.FAILED;\n            throw error;\n        }\n        finally {\n            requestToken.done();\n        }\n    }\n    // Unloads the tile's content.\n    unloadContent() {\n        if (this.content && this.content.destroy) {\n            this.content.destroy();\n        }\n        this.content = null;\n        if (this.header.content && this.header.content.destroy) {\n            this.header.content.destroy();\n        }\n        this.header.content = null;\n        this.contentState = TILE_CONTENT_STATE.UNLOADED;\n        return true;\n    }\n    /**\n     * Update the tile's visibility\n     * @param {Object} frameState - frame state for tile culling\n     * @param {string[]} viewportIds - a list of viewport ids that show this tile\n     * @return {void}\n     */\n    updateVisibility(frameState, viewportIds) {\n        if (this._frameNumber === frameState.frameNumber) {\n            // Return early if visibility has already been checked during the traversal.\n            // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n            return;\n        }\n        const parent = this.parent;\n        const parentVisibilityPlaneMask = parent\n            ? parent._visibilityPlaneMask\n            : CullingVolume.MASK_INDETERMINATE;\n        if (this.tileset._traverser.options.updateTransforms) {\n            const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n            this._updateTransform(parentTransform);\n        }\n        this._distanceToCamera = this.distanceToTile(frameState);\n        this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n        this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n        this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n        this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n        this._frameNumber = frameState.frameNumber;\n        this.viewportIds = viewportIds;\n    }\n    // Determines whether the tile's bounding volume intersects the culling volume.\n    // @param {FrameState} frameState The frame state.\n    // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n    // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n    visibility(frameState, parentVisibilityPlaneMask) {\n        const { cullingVolume } = frameState;\n        const { boundingVolume } = this;\n        // TODO Cesium specific - restore clippingPlanes\n        // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n        // if (clippingPlanes && clippingPlanes.enabled) {\n        //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        //     boundingVolume,\n        //     clippingPlanesOriginMatrix\n        //   );\n        //   this._isClipped = intersection !== Intersect.INSIDE;\n        //   if (intersection === Intersect.OUTSIDE) {\n        //     return CullingVolume.MASK_OUTSIDE;\n        //   }\n        // }\n        // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n        return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    }\n    // Assuming the tile's bounding volume intersects the culling volume, determines\n    // whether the tile's content's bounding volume intersects the culling volume.\n    // @param {FrameState} frameState The frame state.\n    // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n    contentVisibility() {\n        return true;\n        // TODO restore\n        /*\n        // Assumes the tile's bounding volume intersects the culling volume already, so\n        // just return Intersect.INSIDE if there is no content bounding volume.\n        if (!defined(this.contentBoundingVolume)) {\n          return Intersect.INSIDE;\n        }\n    \n        if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n          // The tile's bounding volume is completely inside the culling volume so\n          // the content bounding volume must also be inside.\n          return Intersect.INSIDE;\n        }\n    \n        // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n        // tile's (not the content's) bounding volume intersects the culling volume?\n        const cullingVolume = frameState.cullingVolume;\n        const boundingVolume = tile.contentBoundingVolume;\n    \n        const tileset = this.tileset;\n        const clippingPlanes = tileset.clippingPlanes;\n        if (defined(clippingPlanes) && clippingPlanes.enabled) {\n          const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n            boundingVolume,\n            tileset.clippingPlanesOriginMatrix\n          );\n          this._isClipped = intersection !== Intersect.INSIDE;\n          if (intersection === Intersect.OUTSIDE) {\n            return Intersect.OUTSIDE;\n          }\n        }\n    \n        return cullingVolume.computeVisibility(boundingVolume);\n        */\n    }\n    /**\n     * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n     * @param frameState The frame state.\n     * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n     */\n    distanceToTile(frameState) {\n        const boundingVolume = this.boundingVolume;\n        return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n    }\n    /**\n     * Computes the tile's camera-space z-depth.\n     * @param frameState The frame state.\n     * @returns The distance, in meters.\n     */\n    cameraSpaceZDepth({ camera }) {\n        const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n        scratchVector.subVectors(boundingVolume.center, camera.position);\n        return camera.direction.dot(scratchVector);\n    }\n    /**\n     * Checks if the camera is inside the viewer request volume.\n     * @param {FrameState} frameState The frame state.\n     * @returns {Boolean} Whether the camera is inside the volume.\n     */\n    insideViewerRequestVolume(frameState) {\n        const viewerRequestVolume = this._viewerRequestVolume;\n        return (!viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0);\n    }\n    // TODO Cesium specific\n    // Update whether the tile has expired.\n    updateExpiration() {\n        if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n            const now = Date.now();\n            // @ts-ignore Date.lessThan - replace with ms compare?\n            if (Date.lessThan(this._expireDate, now)) {\n                this.contentState = TILE_CONTENT_STATE.EXPIRED;\n                this._expiredContent = this.content;\n            }\n        }\n    }\n    get extras() {\n        return this.header.extras;\n    }\n    // INTERNAL METHODS\n    _initializeLodMetric(header) {\n        if ('lodMetricType' in header) {\n            this.lodMetricType = header.lodMetricType;\n        }\n        else {\n            this.lodMetricType = (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType;\n            // eslint-disable-next-line\n            console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n        }\n        // This is used to compute screen space error, i.e., the error measured in pixels.\n        if ('lodMetricValue' in header) {\n            this.lodMetricValue = header.lodMetricValue;\n        }\n        else {\n            this.lodMetricValue =\n                (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue;\n            // eslint-disable-next-line\n            console.warn('3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue');\n        }\n    }\n    _initializeTransforms(tileHeader) {\n        // The local transform of this tile.\n        this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n        const parent = this.parent;\n        const tileset = this.tileset;\n        const parentTransform = parent && parent.computedTransform\n            ? parent.computedTransform.clone()\n            : tileset.modelMatrix.clone();\n        this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n        const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n        this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n    }\n    _initializeBoundingVolumes(tileHeader) {\n        this._contentBoundingVolume = null;\n        this._viewerRequestVolume = null;\n        this._updateBoundingVolume(tileHeader);\n    }\n    _initializeContent(tileHeader) {\n        // Empty tile by default\n        this.content = { _tileset: this.tileset, _tile: this };\n        this.hasEmptyContent = true;\n        this.contentState = TILE_CONTENT_STATE.UNLOADED;\n        // When `true`, the tile's content points to an external tileset.\n        // This is `false` until the tile's content is loaded.\n        this.hasTilesetContent = false;\n        if (tileHeader.contentUrl) {\n            this.content = null;\n            this.hasEmptyContent = false;\n        }\n    }\n    // TODO - remove anything not related to basic visibility detection\n    _initializeRenderingState(header) {\n        this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n        this._shouldRefine = false;\n        // Members this are updated every frame for tree traversal and rendering optimizations:\n        this._distanceToCamera = 0;\n        this._centerZDepth = 0;\n        this._screenSpaceError = 0;\n        this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n        this._visible = undefined;\n        this._inRequestVolume = false;\n        this._stackLength = 0;\n        this._selectionDepth = 0;\n        this._frameNumber = 0;\n        this._touchedFrame = 0;\n        this._visitedFrame = 0;\n        this._selectedFrame = 0;\n        this._requestedFrame = 0;\n        this._priority = 0.0;\n    }\n    _getRefine(refine) {\n        // Inherit from parent tile if omitted.\n        return refine || (this.parent && this.parent.refine) || TILE_REFINEMENT.REPLACE;\n    }\n    _isTileset() {\n        return this.contentUrl.indexOf('.json') !== -1;\n    }\n    _onContentLoaded() {\n        // Vector and Geometry tile rendering do not support the skip LOD optimization.\n        switch (this.content && this.content.type) {\n            case 'vctr':\n            case 'geom':\n                // @ts-ignore\n                this.tileset._traverser.disableSkipLevelOfDetail = true;\n                break;\n            default:\n        }\n        // The content may be tileset json\n        if (this._isTileset()) {\n            this.hasTilesetContent = true;\n        }\n        else {\n            this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();\n        }\n    }\n    _updateBoundingVolume(header) {\n        // Update the bounding volumes\n        this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);\n        const content = header.content;\n        if (!content) {\n            return;\n        }\n        // TODO Cesium specific\n        // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n        // around only the features in the tile. This box is useful for culling for rendering,\n        // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n        // since it only bounds features in the tile, not the entire tile, children may be\n        // outside of this box.\n        if (content.boundingVolume) {\n            this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);\n        }\n        if (header.viewerRequestVolume) {\n            this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);\n        }\n    }\n    // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n    _updateTransform(parentTransform = new Matrix4()) {\n        const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n        const didTransformChange = !computedTransform.equals(this.computedTransform);\n        if (!didTransformChange) {\n            return;\n        }\n        this.computedTransform = computedTransform;\n        this._updateBoundingVolume(this.header);\n    }\n    // Get options which are applicable only for the particular loader\n    _getLoaderSpecificOptions(loaderId) {\n        switch (loaderId) {\n            case 'i3s':\n                return {\n                    ...this.tileset.options.i3s,\n                    _tileOptions: {\n                        attributeUrls: this.header.attributeUrls,\n                        textureUrl: this.header.textureUrl,\n                        textureFormat: this.header.textureFormat,\n                        textureLoaderOptions: this.header.textureLoaderOptions,\n                        materialDefinition: this.header.materialDefinition,\n                        isDracoGeometry: this.header.isDracoGeometry,\n                        mbs: this.header.mbs\n                    },\n                    _tilesetOptions: {\n                        store: this.tileset.tileset.store,\n                        attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n                        fields: this.tileset.tileset.fields\n                    },\n                    isTileHeader: false\n                };\n            case '3d-tiles':\n            case 'cesium-ion':\n            default:\n                return get3dTilesOptions(this.tileset.tileset);\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const TILE_CONTENT_STATE = {\n    UNLOADED: 0, // Has never been requested\n    LOADING: 1, // Is waiting on a pending request\n    PROCESSING: 2, // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n    READY: 3, // Ready to render.\n    EXPIRED: 4, // Is expired and will be unloaded once new content is loaded.\n    FAILED: 5 // Request failed.\n};\nexport var TILE_REFINEMENT;\n(function (TILE_REFINEMENT) {\n    TILE_REFINEMENT[TILE_REFINEMENT[\"ADD\"] = 1] = \"ADD\";\n    TILE_REFINEMENT[TILE_REFINEMENT[\"REPLACE\"] = 2] = \"REPLACE\"; // Render tile or, if screen space error exceeded, refine to its descendants instead.\n})(TILE_REFINEMENT || (TILE_REFINEMENT = {}));\nexport var TILE_TYPE;\n(function (TILE_TYPE) {\n    TILE_TYPE[\"EMPTY\"] = \"empty\";\n    TILE_TYPE[\"SCENEGRAPH\"] = \"scenegraph\";\n    TILE_TYPE[\"POINTCLOUD\"] = \"pointcloud\";\n    TILE_TYPE[\"MESH\"] = \"mesh\";\n})(TILE_TYPE || (TILE_TYPE = {}));\nexport var TILESET_TYPE;\n(function (TILESET_TYPE) {\n    TILESET_TYPE[\"I3S\"] = \"I3S\";\n    TILESET_TYPE[\"TILES3D\"] = \"TILES3D\";\n})(TILESET_TYPE || (TILESET_TYPE = {}));\nexport var LOD_METRIC_TYPE;\n(function (LOD_METRIC_TYPE) {\n    LOD_METRIC_TYPE[\"GEOMETRIC_ERROR\"] = \"geometricError\";\n    LOD_METRIC_TYPE[\"MAX_SCREEN_THRESHOLD\"] = \"maxScreenThreshold\";\n})(LOD_METRIC_TYPE || (LOD_METRIC_TYPE = {}));\nexport const TILE3D_OPTIMIZATION_HINT = {\n    NOT_COMPUTED: -1,\n    USE_OPTIMIZATION: 1,\n    SKIP_OPTIMIZATION: 0\n};\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Quaternion, Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\n// const scratchProjectedBoundingSphere = new BoundingSphere();\nfunction defined(x) {\n    return x !== undefined && x !== null;\n}\n// const scratchMatrix = new Matrix3();\nconst scratchPoint = new Vector3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\nconst scratchCenter = new Vector3();\nconst scratchXAxis = new Vector3();\nconst scratchYAxis = new Vector3();\nconst scratchZAxis = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n    assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n    // boundingVolume schema:\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n    if (boundingVolumeHeader.box) {\n        return createBox(boundingVolumeHeader.box, transform, result);\n    }\n    if (boundingVolumeHeader.region) {\n        return createObbFromRegion(boundingVolumeHeader.region);\n    }\n    if (boundingVolumeHeader.sphere) {\n        return createSphere(boundingVolumeHeader.sphere, transform, result);\n    }\n    throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n/**\n * Calculate the cartographic bounding box the tile's bounding volume.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {BoundingVolume} boundingVolume The bounding volume.\n * @returns {CartographicBounds}\n */\nexport function getCartographicBounds(boundingVolumeHeader, boundingVolume) {\n    // boundingVolume schema:\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n    if (boundingVolumeHeader.box) {\n        return orientedBoundingBoxToCartographicBounds(boundingVolume);\n    }\n    if (boundingVolumeHeader.region) {\n        // [west, south, east, north, minimum height, maximum height]\n        // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n        // Heights are in meters above (or below) the WGS 84 ellipsoid.\n        const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n        return [\n            [degrees(west), degrees(south), minHeight],\n            [degrees(east), degrees(north), maxHeight]\n        ];\n    }\n    if (boundingVolumeHeader.sphere) {\n        return boundingSphereToCartographicBounds(boundingVolume);\n    }\n    throw new Error('Unkown boundingVolume type');\n}\nfunction createBox(box, transform, result) {\n    // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n    // 1. A half-axes based representation.\n    // box: An array of 12 numbers that define an oriented bounding box.\n    // The first three elements define the x, y, and z values for the center of the box.\n    // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n    // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n    // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n    // 2. A half-size-quaternion based representation.\n    // box: An array of 10 numbers that define an oriented bounding box.\n    // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n    // The next three elements (with indices 3, 4, and 5) define the halfSize.\n    // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n    const center = new Vector3(box[0], box[1], box[2]);\n    transform.transform(center, center);\n    let origin = [];\n    if (box.length === 10) {\n        const halfSize = box.slice(3, 6);\n        const quaternion = new Quaternion();\n        quaternion.fromArray(box, 6);\n        const x = new Vector3([1, 0, 0]);\n        const y = new Vector3([0, 1, 0]);\n        const z = new Vector3([0, 0, 1]);\n        x.transformByQuaternion(quaternion);\n        x.scale(halfSize[0]);\n        y.transformByQuaternion(quaternion);\n        y.scale(halfSize[1]);\n        z.transformByQuaternion(quaternion);\n        z.scale(halfSize[2]);\n        origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n    }\n    else {\n        origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n    }\n    const xAxis = transform.transformAsVector(origin.slice(0, 3));\n    const yAxis = transform.transformAsVector(origin.slice(3, 6));\n    const zAxis = transform.transformAsVector(origin.slice(6, 9));\n    const halfAxes = new Matrix3([\n        xAxis[0],\n        xAxis[1],\n        xAxis[2],\n        yAxis[0],\n        yAxis[1],\n        yAxis[2],\n        zAxis[0],\n        zAxis[1],\n        zAxis[2]\n    ]);\n    if (defined(result)) {\n        result.center = center;\n        result.halfAxes = halfAxes;\n        return result;\n    }\n    return new OrientedBoundingBox(center, halfAxes);\n}\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\nfunction createSphere(sphere, transform, result) {\n    // Find the transformed center\n    const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n    transform.transform(center, center);\n    const scale = transform.getScale(scratchScale);\n    const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n    const radius = sphere[3] * uniformScale;\n    if (defined(result)) {\n        result.center = center;\n        result.radius = radius;\n        return result;\n    }\n    return new BoundingSphere(center, radius);\n}\n/**\n * Create OrientedBoundingBox instance from region 3D tiles bounding volume\n * @param region - region 3D tiles bounding volume\n * @returns OrientedBoundingBox instance\n */\nfunction createObbFromRegion(region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = region;\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);\n    Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);\n    Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);\n    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);\n    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);\n    return createBox([\n        ...centerInCartesian,\n        ...scratchXAxis.subtract(centerInCartesian),\n        ...scratchYAxis.subtract(centerInCartesian),\n        ...scratchZAxis.subtract(centerInCartesian)\n    ], new Matrix4());\n}\n/**\n * Convert a bounding volume defined by OrientedBoundingBox to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction orientedBoundingBoxToCartographicBounds(boundingVolume) {\n    const result = emptyCartographicBounds();\n    const { halfAxes } = boundingVolume;\n    const xAxis = new Vector3(halfAxes.getColumn(0));\n    const yAxis = new Vector3(halfAxes.getColumn(1));\n    const zAxis = new Vector3(halfAxes.getColumn(2));\n    // Test all 8 corners of the box\n    for (let x = 0; x < 2; x++) {\n        for (let y = 0; y < 2; y++) {\n            for (let z = 0; z < 2; z++) {\n                scratchPoint.copy(boundingVolume.center);\n                scratchPoint.add(xAxis);\n                scratchPoint.add(yAxis);\n                scratchPoint.add(zAxis);\n                addToCartographicBounds(result, scratchPoint);\n                zAxis.negate();\n            }\n            yAxis.negate();\n        }\n        xAxis.negate();\n    }\n    return result;\n}\n/**\n * Convert a bounding volume defined by BoundingSphere to cartographic bounds\n * @returns {CartographicBounds}\n */\nfunction boundingSphereToCartographicBounds(boundingVolume) {\n    const result = emptyCartographicBounds();\n    const { center, radius } = boundingVolume;\n    const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);\n    let zAxis;\n    if (point) {\n        zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);\n    }\n    else {\n        zAxis = new Vector3(0, 0, 1);\n    }\n    let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);\n    if (xAxis.len() > 0) {\n        xAxis.normalize();\n    }\n    else {\n        xAxis = new Vector3(0, 1, 0);\n    }\n    const yAxis = xAxis.clone().cross(zAxis);\n    // Test 6 end points of the 3 axes\n    for (const axis of [xAxis, yAxis, zAxis]) {\n        scratchScale.copy(axis).scale(radius);\n        for (let dir = 0; dir < 2; dir++) {\n            scratchPoint.copy(center);\n            scratchPoint.add(scratchScale);\n            addToCartographicBounds(result, scratchPoint);\n            // Flip the axis\n            scratchScale.negate();\n        }\n    }\n    return result;\n}\n/**\n * Create a new cartographic bounds that contains no points\n * @returns {CartographicBounds}\n */\nfunction emptyCartographicBounds() {\n    return [\n        [Infinity, Infinity, Infinity],\n        [-Infinity, -Infinity, -Infinity]\n    ];\n}\n/**\n * Add a point to the target cartographic bounds\n * @param {CartographicBounds} target\n * @param {Vector3} cartesian coordinates of the point to add\n */\nfunction addToCartographicBounds(target, cartesian) {\n    Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);\n    target[0][0] = Math.min(target[0][0], scratchPoint[0]);\n    target[0][1] = Math.min(target[0][1], scratchPoint[1]);\n    target[0][2] = Math.min(target[0][2], scratchPoint[2]);\n    target[1][0] = Math.max(target[1][0], scratchPoint[0]);\n    target[1][1] = Math.max(target[1][1], scratchPoint[1]);\n    target[1][2] = Math.max(target[1][2], scratchPoint[2]);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n/* eslint-disable */\n// @ts-nocheck\nimport { Matrix4, Vector3, clamp } from '@math.gl/core';\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, { camera, mapProjection }, options = {}) {\n    const { dynamicScreenSpaceErrorHeightFalloff = 0.25, dynamicScreenSpaceErrorDensity = 0.00278 } = options;\n    let up;\n    let direction;\n    let height;\n    let minimumHeight;\n    let maximumHeight;\n    const tileBoundingVolume = root.contentBoundingVolume;\n    if (tileBoundingVolume instanceof TileBoundingRegion) {\n        up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n        direction = camera.directionWC;\n        height = camera.positionCartographic.height;\n        minimumHeight = tileBoundingVolume.minimumHeight;\n        maximumHeight = tileBoundingVolume.maximumHeight;\n    }\n    else {\n        // Transform camera position and direction into the local coordinate system of the tileset\n        const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n        const ellipsoid = mapProjection.ellipsoid;\n        const boundingVolume = tileBoundingVolume.boundingVolume;\n        const centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);\n        if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n            // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n            const centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);\n            up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n            direction = camera.directionWC;\n            height = camera.positionCartographic.height;\n            minimumHeight = 0.0;\n            maximumHeight = centerCartographic.height * 2.0;\n        }\n        else {\n            // The tileset is defined in local coordinates (z-up)\n            const positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);\n            up = Cartesian3.UNIT_Z;\n            direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);\n            direction = Cartesian3.normalize(direction, direction);\n            height = positionLocal.z;\n            if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n                // Assuming z-up, the last component stores the half-height of the box\n                const boxHeight = root._header.boundingVolume.box[11];\n                minimumHeight = centerLocal.z - boxHeight;\n                maximumHeight = centerLocal.z + boxHeight;\n            }\n            else if (tileBoundingVolume instanceof TileBoundingSphere) {\n                const radius = boundingVolume.radius;\n                minimumHeight = centerLocal.z - radius;\n                maximumHeight = centerLocal.z + radius;\n            }\n        }\n    }\n    // The range where the density starts to lessen. Start at the quarter height of the tileset.\n    const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n    const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n    const heightFar = maximumHeight;\n    const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n    // Increase density as the camera tilts towards the horizon\n    const dot = Math.abs(Cartesian3.dot(direction, up));\n    let horizonFactor = 1.0 - dot;\n    // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n    // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n    horizonFactor = horizonFactor * (1.0 - t);\n    return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\nexport function fog(distanceToCamera, density) {\n    const scalar = distanceToCamera * density;\n    return 1.0 - Math.exp(-(scalar * scalar));\n}\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {\n        const density = tileset.dynamicScreenSpaceErrorComputedDensity;\n        const factor = tileset.dynamicScreenSpaceErrorFactor;\n        // TODO: Refined screen space error that minimizes tiles in non-first-person\n        const dynamicError = fog(distanceToCamera, density) * factor;\n        return dynamicError;\n    }\n    return 0;\n}\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n    const tileset = tile.tileset;\n    const parentLodMetricValue = (tile.parent && tile.parent.lodMetricValue) || tile.lodMetricValue;\n    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n    // Leaf tiles do not have any error so save the computation\n    if (lodMetricValue === 0.0) {\n        return 0.0;\n    }\n    // TODO: Orthographic Frustum needs special treatment?\n    // this._getOrthograhicScreenSpaceError();\n    // Avoid divide by zero when viewer is inside the tile\n    const distance = Math.max(tile._distanceToCamera, 1e-7);\n    const { height, sseDenominator } = frameState;\n    const { viewDistanceScale } = tileset.options;\n    let error = (lodMetricValue * height * (viewDistanceScale || 1.0)) / (distance * sseDenominator);\n    error -= getDynamicScreenSpaceError(tileset, distance);\n    return error;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile\n * @param frameState\n * @returns\n */\nexport function getLodStatus(tile, frameState) {\n    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n        return 'DIG';\n    }\n    const screenSize = 2 * getProjectedRadius(tile, frameState);\n    if (screenSize < 2) {\n        return 'OUT';\n    }\n    if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n        return 'DRAW';\n    }\n    else if (tile.header.children) {\n        return 'DIG';\n    }\n    return 'OUT';\n}\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile, frameState) {\n    const { topDownViewport: viewport } = frameState;\n    const mbsLat = tile.header.mbs[1];\n    const mbsLon = tile.header.mbs[0];\n    const mbsZ = tile.header.mbs[2];\n    const mbsR = tile.header.mbs[3];\n    const mbsCenterCartesian = [...tile.boundingVolume.center];\n    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n    // ---------------------------\n    // Calculate mbs border vertex\n    // ---------------------------\n    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n    // Add extra vector to form plane\n    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n    // Mean Proportionals in Right Triangles - Altitude rule\n    // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n    const extraZ = (projection * projection) / cameraPositionEnu[2];\n    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n    // We need radius vector orthogonal to toEye vector\n    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n    // ---------------------------\n    // Project center vertex and border vertex and calculate projected radius of MBS\n    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n    const projectedRadius = projectedOriginVector\n        .copy(projectedOrigin)\n        .subtract(projectedMbsBorderVertex)\n        .magnitude();\n    return projectedRadius;\n}\n", "export function get3dTilesOptions(tileset) {\n    return {\n        assetGltfUpAxis: (tileset.asset && tileset.asset.gltfUpAxis) || 'Y'\n    };\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { assert } from '@loaders.gl/loader-utils';\n/**\n * A wrapper around arrays so that the internal length of the array can be manually managed.\n *\n * @alias ManagedArray\n * @constructor\n * @private\n *\n * @param {Number} [length=0] The initial length of the array.\n */\nexport class ManagedArray {\n    _map = new Map();\n    _array;\n    _length;\n    constructor(length = 0) {\n        this._array = new Array(length);\n        this._length = length;\n    }\n    /**\n     * Gets or sets the length of the array.\n     * If the set length is greater than the length of the internal array, the internal array is resized.\n     *\n     * @memberof ManagedArray.prototype\n     * @type Number\n     */\n    get length() {\n        return this._length;\n    }\n    set length(length) {\n        this._length = length;\n        if (length > this._array.length) {\n            this._array.length = length;\n        }\n    }\n    /**\n     * Gets the internal array.\n     *\n     * @memberof ManagedArray.prototype\n     * @type Array\n     * @readonly\n     */\n    get values() {\n        return this._array;\n    }\n    /**\n     * Gets the element at an index.\n     *\n     * @param {Number} index The index to get.\n     */\n    get(index) {\n        assert(index < this._array.length);\n        return this._array[index];\n    }\n    /**\n     * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n     *\n     * @param {Number} index The index to set.\n     * @param {*} element The element to set at index.\n     */\n    set(index, element) {\n        assert(index >= 0);\n        if (index >= this.length) {\n            this.length = index + 1;\n        }\n        if (this._map.has(this._array[index])) {\n            this._map.delete(this._array[index]);\n        }\n        this._array[index] = element;\n        this._map.set(element, index);\n    }\n    delete(element) {\n        const index = this._map.get(element);\n        if (index >= 0) {\n            this._array.splice(index, 1);\n            this._map.delete(element);\n            this.length--;\n        }\n    }\n    /**\n     * Returns the last element in the array without modifying the array.\n     *\n     * @returns {*} The last element in the array.\n     */\n    peek() {\n        return this._array[this._length - 1];\n    }\n    /**\n     * Push an element into the array.\n     *\n     * @param {*} element The element to push.\n     */\n    push(element) {\n        if (!this._map.has(element)) {\n            const index = this.length++;\n            this._array[index] = element;\n            this._map.set(element, index);\n        }\n    }\n    /**\n     * Pop an element from the array.\n     *\n     * @returns {*} The last element in the array.\n     */\n    pop() {\n        const element = this._array[--this.length];\n        this._map.delete(element);\n        return element;\n    }\n    /**\n     * Resize the internal array if length > _array.length.\n     *\n     * @param {Number} length The length.\n     */\n    reserve(length) {\n        assert(length >= 0);\n        if (length > this._array.length) {\n            this._array.length = length;\n        }\n    }\n    /**\n     * Resize the array.\n     *\n     * @param {Number} length The length.\n     */\n    resize(length) {\n        assert(length >= 0);\n        this.length = length;\n    }\n    /**\n     * Trim the internal array to the specified length. Defaults to the current length.\n     *\n     * @param {Number} [length] The length.\n     */\n    trim(length) {\n        if (length === null || length === undefined) {\n            length = this.length;\n        }\n        this._array.length = length;\n    }\n    reset() {\n        this._array = [];\n        this._map = new Map();\n        this._length = 0;\n    }\n    find(target) {\n        return this._map.has(target);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ManagedArray } from \"../utils/managed-array.js\";\nimport { TILE_REFINEMENT } from \"../constants.js\";\nexport const DEFAULT_PROPS = {\n    loadSiblings: false,\n    skipLevelOfDetail: false,\n    updateTransforms: true,\n    onTraversalEnd: () => { },\n    viewportTraversersMap: {},\n    basePath: ''\n};\nexport class TilesetTraverser {\n    options;\n    // fulfill in traverse call\n    root = null;\n    // tiles should be rendered\n    selectedTiles = {};\n    // tiles should be loaded from server\n    requestedTiles = {};\n    // tiles does not have render content\n    emptyTiles = {};\n    lastUpdate = new Date().getTime();\n    updateDebounceTime = 1000;\n    /** temporary storage to hold the traversed tiles during a traversal */\n    _traversalStack = new ManagedArray();\n    _emptyTraversalStack = new ManagedArray();\n    /** set in every traverse cycle */\n    _frameNumber = null;\n    // RESULT\n    traversalFinished(frameState) {\n        return true;\n    }\n    // TODO nested props\n    constructor(options) {\n        this.options = { ...DEFAULT_PROPS, ...options };\n    }\n    // tiles should be visible\n    traverse(root, frameState, options) {\n        this.root = root; // for root screen space error\n        this.options = { ...this.options, ...options };\n        // reset result\n        this.reset();\n        // update tile (visibility and expiration)\n        this.updateTile(root, frameState);\n        this._frameNumber = frameState.frameNumber;\n        this.executeTraversal(root, frameState);\n    }\n    reset() {\n        this.requestedTiles = {};\n        this.selectedTiles = {};\n        this.emptyTiles = {};\n        this._traversalStack.reset();\n        this._emptyTraversalStack.reset();\n    }\n    /**\n     * Execute traverse\n     * Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n     * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n     * This is the traditional replacement refinement approach and is called the base traversal.\n     * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n     * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n     * and rendering children and parent tiles simultaneously.\n     */\n    /* eslint-disable-next-line complexity, max-statements */\n    executeTraversal(root, frameState) {\n        // stack to store traversed tiles, only visible tiles should be added to stack\n        // visible: visible in the current view frustum\n        const stack = this._traversalStack;\n        root._selectionDepth = 1;\n        stack.push(root);\n        while (stack.length > 0) {\n            // 1. pop tile\n            const tile = stack.pop();\n            // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n            let shouldRefine = false;\n            if (this.canTraverse(tile, frameState)) {\n                this.updateChildTiles(tile, frameState);\n                shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n            }\n            // 3. decide if should render (select) this tile\n            //   - tile does not have render content\n            //   - tile has render content and tile is `add` type (pointcloud)\n            //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n            const parent = tile.parent;\n            const parentRefines = Boolean(!parent || parent._shouldRefine);\n            const stoppedRefining = !shouldRefine;\n            if (!tile.hasRenderContent) {\n                this.emptyTiles[tile.id] = tile;\n                this.loadTile(tile, frameState);\n                if (stoppedRefining) {\n                    this.selectTile(tile, frameState);\n                }\n                // additive tiles\n            }\n            else if (tile.refine === TILE_REFINEMENT.ADD) {\n                // Additive tiles are always loaded and selected\n                this.loadTile(tile, frameState);\n                this.selectTile(tile, frameState);\n                // replace tiles\n            }\n            else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n                // Always load tiles in the base traversal\n                // Select tiles that can't refine further\n                this.loadTile(tile, frameState);\n                if (stoppedRefining) {\n                    this.selectTile(tile, frameState);\n                }\n            }\n            // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n            this.touchTile(tile, frameState);\n            // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n            tile._shouldRefine = shouldRefine && parentRefines;\n        }\n        const newTime = new Date().getTime();\n        if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n            this.lastUpdate = newTime;\n            this.options.onTraversalEnd(frameState);\n        }\n    }\n    updateChildTiles(tile, frameState) {\n        const children = tile.children;\n        for (const child of children) {\n            this.updateTile(child, frameState);\n        }\n    }\n    /* eslint-disable complexity, max-statements */\n    updateAndPushChildren(tile, frameState, stack, depth) {\n        const { loadSiblings, skipLevelOfDetail } = this.options;\n        const children = tile.children;\n        // sort children tiles\n        children.sort(this.compareDistanceToCamera.bind(this));\n        // For traditional replacement refinement only refine if all children are loaded.\n        // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n        const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n        let hasVisibleChild = false;\n        let refines = true;\n        for (const child of children) {\n            child._selectionDepth = depth;\n            if (child.isVisibleAndInRequestVolume) {\n                if (stack.find(child)) {\n                    stack.delete(child);\n                }\n                stack.push(child);\n                hasVisibleChild = true;\n            }\n            else if (checkRefines || loadSiblings) {\n                // Keep non-visible children loaded since they are still needed before the parent can refine.\n                // Or loadSiblings is true so always load tiles regardless of visibility.\n                this.loadTile(child, frameState);\n                this.touchTile(child, frameState);\n            }\n            if (checkRefines) {\n                let childRefines;\n                if (!child._inRequestVolume) {\n                    childRefines = false;\n                }\n                else if (!child.hasRenderContent) {\n                    childRefines = this.executeEmptyTraversal(child, frameState);\n                }\n                else {\n                    childRefines = child.contentAvailable;\n                }\n                refines = refines && childRefines;\n                if (!refines) {\n                    return false;\n                }\n            }\n        }\n        if (!hasVisibleChild) {\n            refines = false;\n        }\n        return refines;\n    }\n    /* eslint-enable complexity, max-statements */\n    updateTile(tile, frameState) {\n        this.updateTileVisibility(tile, frameState);\n    }\n    // tile to render in the browser\n    selectTile(tile, frameState) {\n        if (this.shouldSelectTile(tile)) {\n            // The tile can be selected right away and does not require traverseAndSelect\n            tile._selectedFrame = frameState.frameNumber;\n            this.selectedTiles[tile.id] = tile;\n        }\n    }\n    // tile to load from server\n    loadTile(tile, frameState) {\n        if (this.shouldLoadTile(tile)) {\n            tile._requestedFrame = frameState.frameNumber;\n            tile._priority = tile._getPriority();\n            this.requestedTiles[tile.id] = tile;\n        }\n    }\n    // cache tile\n    touchTile(tile, frameState) {\n        tile.tileset._cache.touch(tile);\n        tile._touchedFrame = frameState.frameNumber;\n    }\n    // tile should be visible\n    // tile should have children\n    // tile LoD (level of detail) is not sufficient under current viewport\n    canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n        if (!tile.hasChildren) {\n            return false;\n        }\n        // cesium specific\n        if (tile.hasTilesetContent) {\n            // Traverse external this to visit its root tile\n            // Don't traverse if the subtree is expired because it will be destroyed\n            return !tile.contentExpired;\n        }\n        if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n            return false;\n        }\n        return this.shouldRefine(tile, frameState, useParentMetric);\n    }\n    shouldLoadTile(tile) {\n        // if request tile is in current frame\n        // and has unexpired render content\n        return tile.hasUnloadedContent || tile.contentExpired;\n    }\n    shouldSelectTile(tile) {\n        // if select tile is in current frame\n        // and content available\n        return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n    /** Decide if tile LoD (level of detail) is not sufficient under current viewport */\n    shouldRefine(tile, frameState, useParentMetric = false) {\n        let screenSpaceError = tile._screenSpaceError;\n        if (useParentMetric) {\n            screenSpaceError = tile.getScreenSpaceError(frameState, true);\n        }\n        return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;\n    }\n    updateTileVisibility(tile, frameState) {\n        const viewportIds = [];\n        if (this.options.viewportTraversersMap) {\n            for (const key in this.options.viewportTraversersMap) {\n                const value = this.options.viewportTraversersMap[key];\n                if (value === frameState.viewport.id) {\n                    viewportIds.push(key);\n                }\n            }\n        }\n        else {\n            viewportIds.push(frameState.viewport.id);\n        }\n        tile.updateVisibility(frameState, viewportIds);\n    }\n    // UTILITIES\n    compareDistanceToCamera(b, a) {\n        return b._distanceToCamera - a._distanceToCamera;\n    }\n    anyChildrenVisible(tile, frameState) {\n        let anyVisible = false;\n        for (const child of tile.children) {\n            // @ts-expect-error\n            child.updateVisibility(frameState);\n            // @ts-expect-error\n            anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n        return anyVisible;\n    }\n    // Depth-first traversal that checks if all nearest descendants with content are loaded.\n    // Ignores visibility.\n    executeEmptyTraversal(root, frameState) {\n        let allDescendantsLoaded = true;\n        const stack = this._emptyTraversalStack;\n        stack.push(root);\n        while (stack.length > 0) {\n            const tile = stack.pop();\n            const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, false);\n            const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;\n            // Traversal stops but the tile does not have content yet\n            // There will be holes if the parent tries to refine to its children, so don't refine\n            // One exception: a parent may refine even if one of its descendants is an empty leaf\n            if (!traverse && !tile.contentAvailable && !emptyLeaf) {\n                allDescendantsLoaded = false;\n            }\n            this.updateTile(tile, frameState);\n            if (!tile.isVisibleAndInRequestVolume) {\n                this.loadTile(tile, frameState);\n                this.touchTile(tile, frameState);\n            }\n            if (traverse) {\n                const children = tile.children;\n                for (const child of children) {\n                    stack.push(child);\n                }\n            }\n        }\n        return allDescendantsLoaded;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { TILE3D_OPTIMIZATION_HINT, TILE_REFINEMENT } from \"../../constants.js\";\nimport { TilesetTraverser } from \"../tileset-traverser.js\";\nexport class Tileset3DTraverser extends TilesetTraverser {\n    compareDistanceToCamera(a, b) {\n        // Sort by farthest child first since this is going on a stack\n        return b._distanceToCamera === 0 && a._distanceToCamera === 0\n            ? b._centerZDepth - a._centerZDepth\n            : b._distanceToCamera - a._distanceToCamera;\n    }\n    updateTileVisibility(tile, frameState) {\n        super.updateTileVisibility(tile, frameState);\n        //  Optimization - if none of the tile's children are visible then this tile isn't visible\n        if (!tile.isVisibleAndInRequestVolume) {\n            return;\n        }\n        const hasChildren = tile.children.length > 0;\n        if (tile.hasTilesetContent && hasChildren) {\n            // Use the root tile's visibility instead of this tile's visibility.\n            // The root tile may be culled by the children bounds optimization in which\n            // case this tile should also be culled.\n            const firstChild = tile.children[0];\n            this.updateTileVisibility(firstChild, frameState);\n            tile._visible = firstChild._visible;\n            return;\n        }\n        if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {\n            tile._visible = false;\n            return;\n        }\n        const replace = tile.refine === TILE_REFINEMENT.REPLACE;\n        const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;\n        if (replace && useOptimization && hasChildren) {\n            if (!this.anyChildrenVisible(tile, frameState)) {\n                tile._visible = false;\n                return;\n            }\n        }\n    }\n    meetsScreenSpaceErrorEarly(tile, frameState) {\n        const { parent } = tile;\n        if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {\n            return false;\n        }\n        // Use parent's geometric error with child's box to see if the tile already meet the SSE\n        return !this.shouldRefine(tile, frameState, true);\n    }\n}\n", "import { load } from '@loaders.gl/core';\nimport { TilesetTraverser } from \"../tileset-traverser.js\";\nimport { getLodStatus } from \"../helpers/i3s-lod.js\";\nimport { Tile3D } from \"../tile-3d.js\";\nimport { I3STileManager } from \"./i3s-tile-manager.js\";\nexport class I3STilesetTraverser extends TilesetTraverser {\n    _tileManager;\n    constructor(options) {\n        super(options);\n        this._tileManager = new I3STileManager();\n    }\n    /**\n     * Check if there are no penging tile header requests,\n     * that means the traversal is finished and we can call\n     * following-up callbacks.\n     */\n    traversalFinished(frameState) {\n        return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n    }\n    shouldRefine(tile, frameState) {\n        tile._lodJudge = getLodStatus(tile, frameState);\n        return tile._lodJudge === 'DIG';\n    }\n    updateChildTiles(tile, frameState) {\n        const children = tile.header.children || [];\n        // children which are already fetched and constructed as Tile3D instances\n        const childTiles = tile.children;\n        const tileset = tile.tileset;\n        for (const child of children) {\n            const extendedId = `${child.id}-${frameState.viewport.id}`;\n            // if child tile is not fetched\n            const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n            if (!childTile) {\n                let request = () => this._loadTile(child.id, tileset);\n                const cachedRequest = this._tileManager.find(extendedId);\n                if (!cachedRequest) {\n                    // eslint-disable-next-line max-depth\n                    if (tileset.tileset.nodePages) {\n                        request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n                    }\n                    this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);\n                }\n                else {\n                    // update frameNumber since it is still needed in current frame\n                    this._tileManager.update(extendedId, frameState);\n                }\n            }\n            else if (childTile) {\n                // if child tile is fetched and available\n                this.updateTile(childTile, frameState);\n            }\n        }\n        return false;\n    }\n    async _loadTile(nodeId, tileset) {\n        const { loader } = tileset;\n        const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n        // load metadata\n        const options = {\n            ...tileset.loadOptions,\n            i3s: {\n                ...tileset.loadOptions.i3s,\n                isTileHeader: true\n            }\n        };\n        return await load(nodeUrl, loader, options);\n    }\n    /**\n     * The callback to init Tile3D instance after loading the tile JSON\n     * @param {Object} header - the tile JSON from a dataset\n     * @param {Tile3D} tile - the parent Tile3D instance\n     * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n     *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n     * @return {void}\n     */\n    _onTileLoad(header, tile, extendedId) {\n        // after child tile is fetched\n        const childTile = new Tile3D(tile.tileset, header, tile, extendedId);\n        tile.children.push(childTile);\n        const frameState = this._tileManager.find(childTile.id).frameState;\n        this.updateTile(childTile, frameState);\n        // after tile fetched, resume traversal if still in current update/traversal frame\n        if (this._frameNumber === frameState.frameNumber &&\n            (this.traversalFinished(frameState) ||\n                new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {\n            this.executeTraversal(childTile, frameState);\n        }\n    }\n}\n", "/**\n * Counter to register pending tile headers for the particular frameNumber\n * Until all tiles are loaded we won't call `onTraversalEnd` callback\n */\nexport class I3SPendingTilesRegister {\n    frameNumberMap = new Map();\n    /**\n     * Register a new pending tile header for the particular frameNumber\n     * @param viewportId\n     * @param frameNumber\n     */\n    register(viewportId, frameNumber) {\n        const viewportMap = this.frameNumberMap.get(viewportId) || new Map();\n        const oldCount = viewportMap.get(frameNumber) || 0;\n        viewportMap.set(frameNumber, oldCount + 1);\n        this.frameNumberMap.set(viewportId, viewportMap);\n    }\n    /**\n     * Deregister a pending tile header for the particular frameNumber\n     * @param viewportId\n     * @param frameNumber\n     */\n    deregister(viewportId, frameNumber) {\n        const viewportMap = this.frameNumberMap.get(viewportId);\n        if (!viewportMap) {\n            return;\n        }\n        const oldCount = viewportMap.get(frameNumber) || 1;\n        viewportMap.set(frameNumber, oldCount - 1);\n    }\n    /**\n     * Check is there are no pending tile headers registered for the particular frameNumber\n     * @param viewportId\n     * @param frameNumber\n     * @returns\n     */\n    isZero(viewportId, frameNumber) {\n        const count = this.frameNumberMap.get(viewportId)?.get(frameNumber) || 0;\n        return count === 0;\n    }\n}\n", "import { I3SPendingTilesRegister } from \"./i3s-pending-tiles-register.js\";\nconst STATUS = {\n    REQUESTED: 'REQUESTED',\n    COMPLETED: 'COMPLETED',\n    ERROR: 'ERROR'\n};\n// A helper class to manage tile metadata fetching\nexport class I3STileManager {\n    _statusMap;\n    pendingTilesRegister = new I3SPendingTilesRegister();\n    constructor() {\n        this._statusMap = {};\n    }\n    /**\n     * Add request to map\n     * @param request - node metadata request\n     * @param key - unique key\n     * @param callback - callback after request completed\n     * @param frameState - frameState data\n     */\n    add(request, key, callback, frameState) {\n        if (!this._statusMap[key]) {\n            const { frameNumber, viewport: { id } } = frameState;\n            this._statusMap[key] = { request, callback, key, frameState, status: STATUS.REQUESTED };\n            // Register pending request for the frameNumber\n            this.pendingTilesRegister.register(id, frameNumber);\n            request()\n                .then((data) => {\n                this._statusMap[key].status = STATUS.COMPLETED;\n                const { frameNumber: actualFrameNumber, viewport: { id } } = this._statusMap[key].frameState;\n                // Deregister pending request for the frameNumber\n                this.pendingTilesRegister.deregister(id, actualFrameNumber);\n                this._statusMap[key].callback(data, frameState);\n            })\n                .catch((error) => {\n                this._statusMap[key].status = STATUS.ERROR;\n                const { frameNumber: actualFrameNumber, viewport: { id } } = this._statusMap[key].frameState;\n                // Deregister pending request for the frameNumber\n                this.pendingTilesRegister.deregister(id, actualFrameNumber);\n                callback(error);\n            });\n        }\n    }\n    /**\n     * Update request if it is still actual for the new frameState\n     * @param key - unique key\n     * @param frameState - frameState data\n     */\n    update(key, frameState) {\n        if (this._statusMap[key]) {\n            // Deregister pending request for the old frameNumber\n            const { frameNumber, viewport: { id } } = this._statusMap[key].frameState;\n            this.pendingTilesRegister.deregister(id, frameNumber);\n            // Register pending request for the new frameNumber\n            const { frameNumber: newFrameNumber, viewport: { id: newViewportId } } = frameState;\n            this.pendingTilesRegister.register(newViewportId, newFrameNumber);\n            this._statusMap[key].frameState = frameState;\n        }\n    }\n    /**\n     * Find request in the map\n     * @param key - unique key\n     * @returns\n     */\n    find(key) {\n        return this._statusMap[key];\n    }\n    /**\n     * Check it there are pending tile headers for the particular frameNumber\n     * @param viewportId\n     * @param frameNumber\n     * @returns\n     */\n    hasPendingTiles(viewportId, frameNumber) {\n        return !this.pendingTilesRegister.isZero(viewportId, frameNumber);\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_geospatial", "import_loader_utils", "import_core", "import_geospatial", "cameraPositionCartesian", "import_core", "import_culling", "import_geospatial", "scratchVector", "import_core", "import_culling", "TILE_REFINEMENT", "TILE_TYPE", "TILESET_TYPE", "LOD_METRIC_TYPE", "import_core", "import_culling", "import_geospatial", "import_loader_utils", "import_core", "scratchCenter", "scratchPosition", "import_core", "import_geospatial", "import_loader_utils", "scratchVector", "defined", "cullingVolume", "import_core", "id", "DEFAULT_PROPS"]
}
