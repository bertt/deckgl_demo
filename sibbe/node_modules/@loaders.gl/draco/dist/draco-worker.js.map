{
  "version": 3,
  "sources": ["../../worker-utils/src/lib/env-utils/version.ts", "../../worker-utils/src/lib/env-utils/assert.ts", "../../worker-utils/src/lib/env-utils/globals.ts", "../../worker-utils/src/lib/node/worker_threads-browser.ts", "../../worker-utils/src/lib/worker-utils/get-transfer-list.ts", "../../worker-utils/src/lib/worker-farm/worker-body.ts", "../../worker-utils/src/lib/library-utils/library-utils.ts", "../../loader-utils/src/lib/worker-loader-utils/create-loader-worker.ts", "../src/lib/utils/version.ts", "../src/draco-loader.ts", "../../schema/src/lib/table/simple-table/data-type.ts", "../../schema/src/lib/mesh/mesh-utils.ts", "../../schema/src/lib/mesh/deduce-mesh-schema.ts", "../src/lib/utils/get-draco-schema.ts", "../src/lib/draco-parser.ts", "../src/lib/draco-module-loader.ts", "../src/index.ts", "../src/workers/draco-worker.ts"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n\n/**\n * TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\n * 'beta' on beta branch, 'latest' on prod branch\n */\nexport const NPM_TAG = 'latest';\n\ndeclare let __VERSION__: string;\n\nfunction getVersion() {\n  if (!globalThis._loadersgl_?.version) {\n    globalThis._loadersgl_ = globalThis._loadersgl_ || {};\n    // __VERSION__ is injected by babel-plugin-version-inline\n    if (typeof __VERSION__ === 'undefined') {\n      // eslint-disable-next-line\n      console.warn(\n        'loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.'\n      );\n      globalThis._loadersgl_.version = NPM_TAG;\n    } else {\n      globalThis._loadersgl_.version = __VERSION__;\n    }\n  }\n\n  return globalThis._loadersgl_.version;\n}\n\nexport const VERSION = getVersion();\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\n\n/** Throws an `Error` with the optional `message` if `condition` is falsy */\nexport function assert(condition: any, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'loaders.gl assertion failed.');\n  }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_: {[key: string]: any} = globals.self || globals.window || globals.global || {};\nconst window_: {[key: string]: any} = globals.window || globals.self || globals.global || {};\nconst global_: {[key: string]: any} = globals.global || globals.self || globals.window || {};\nconst document_: {[key: string]: any} = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\n/** true if running in the browser, false if running in Node.js */\nexport const isBrowser: boolean =\n  // @ts-ignore process.browser\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\n/** true if running on a worker thread */\nexport const isWorker: boolean = typeof importScripts === 'function';\n\n/** true if running on a mobile device */\nexport const isMobile: boolean =\n  typeof window !== 'undefined' && typeof window.orientation !== 'undefined';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && /v([0-9]*)/.exec(process.version);\n\n/** Version of Node.js if running under Node, otherwise 0 */\nexport const nodeVersion: number = (matches && parseFloat(matches[1])) || 0;\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Browser polyfill for Node.js built-in `worker_threads` module.\n * These fills are non-functional, and just intended to ensure that\n * `import 'worker_threads` doesn't break browser builds.\n * The replacement is done in package.json browser field\n */\nexport class NodeWorker {\n  terminate() {}\n}\n\nexport type {NodeWorker as NodeWorkerType};\n\nexport const parentPort = null;\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object: unknown) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object: object | null): object {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n\n  Object.keys(clone).forEach((key) => {\n    // Typed Arrays and Arrays are passed with no change\n    if (\n      typeof object[key] === 'object' &&\n      !ArrayBuffer.isView(object[key]) &&\n      !(object[key] instanceof Array)\n    ) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n\n  return clone;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n// import type {TransferListItem} from '../node/worker_threads';\nimport {parentPort} from '../node/worker_threads';\n\ntype TransferListItem = any;\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nasync function getParentPort() {\n  // const isNode = globalThis.process;\n  // let parentPort;\n  // try {\n  //   // prettier-ignore\n  //   eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n  //   parentPort = globalThis.parentPort;\n  // } catch {\n  //   try {\n  //     // prettier-ignore\n  //     eval('globalThis.workerThreadsPromise = import(\\'worker_threads\\')'); // eslint-disable-line no-eval\n  //     const workerThreads = await globalThis.workerThreadsPromise;\n  //     parentPort = workerThreads.parentPort;\n  //   } catch (error) {\n  //     console.error((error as Error).message); // eslint-disable-line no-console\n  //   }\n  // }\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static async inWorkerThread(): Promise<boolean> {\n    return typeof self !== 'undefined' || Boolean(await getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    async function handleMessage(message) {\n      const parentPort = await getParentPort();\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    getParentPort().then((parentPort) => {\n      if (parentPort) {\n        parentPort.on('message', (message) => {\n          handleMessage(message);\n        });\n        // if (message == 'exit') { parentPort.unref(); }\n        // eslint-disable-next-line\n        parentPort.on('exit', () => console.debug('Node worker closing'));\n      } else {\n        // eslint-disable-next-line no-restricted-globals\n        globalThis.onmessage = handleMessage;\n      }\n    });\n  }\n\n  static async addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = async (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        const parentPort = await getParentPort();\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static async removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static async postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): Promise<void> {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n\n    // Cast to Node compatible transfer list\n    const transferList = getTransferList(payload) as TransferListItem[];\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-expect-error Outside of worker scopes this call has a third parameter\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global importScripts */\nimport {isBrowser, isWorker} from '../env-utils/globals';\nimport {assert} from '../env-utils/assert';\nimport {VERSION} from '../env-utils/version';\n\nconst loadLibraryPromises: Record<string, Promise<any>> = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {},\n  libraryName: string | null = null\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);\n  }\n  // Ensure libraries are only loaded once\n\n  loadLibraryPromises[libraryUrl] =\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(\n  library: string,\n  moduleName?: string,\n  options: any = {},\n  libraryName: string | null = null\n): string {\n  // Check if already a URL\n  if (!options.useLocalLibraries && library.startsWith('http')) {\n    return library;\n  }\n\n  libraryName = libraryName || library;\n\n  // Allow application to import and supply libraries through `options.modules`\n  // TODO - See js-module-utils in loader-utils\n  const modules = options.modules || {};\n  if (modules[libraryName]) {\n    return modules[libraryName];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${libraryName}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${libraryName}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${libraryName}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${libraryName}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl: string): Promise<any> {\n  if (libraryUrl.endsWith('wasm')) {\n    return await loadAsArrayBuffer(libraryUrl);\n  }\n\n  if (!isBrowser) {\n    // TODO - Node doesn't yet support dynamic import from https URLs\n    // try {\n    //   return await import(libraryUrl);\n    // } catch (error) {\n    //   console.error(error);\n    // }\n    try {\n      const {requireFromFile} = globalThis.loaders || {};\n      return await requireFromFile?.(libraryUrl);\n    } catch (error) {\n      console.error(error); // eslint-disable-line no-console\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const scriptSource = await loadAsText(libraryUrl);\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource: string, id: string): null | any {\n  if (!isBrowser) {\n    const {requireFromString} = globalThis.loaders || {};\n    return requireFromString?.(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(globalThis, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n\nasync function loadAsArrayBuffer(url: string): Promise<ArrayBuffer> {\n  const {readFileAsArrayBuffer} = globalThis.loaders || {};\n  if (isBrowser || !readFileAsArrayBuffer || url.startsWith('http')) {\n    const response = await fetch(url);\n    return await response.arrayBuffer();\n  }\n  return await readFileAsArrayBuffer(url);\n}\n\n/**\n * Load a file from local file system\n * @param filename\n * @returns\n */\nasync function loadAsText(url: string): Promise<string> {\n  const {readFileAsText} = globalThis.loaders || {};\n  if (isBrowser || !readFileAsText || url.startsWith('http')) {\n    const response = await fetch(url);\n    return await response.text();\n  }\n  return await readFileAsText(url);\n}\n", "/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser, LoaderOptions, LoaderContext} from '../../loader-types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport async function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}, context = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            // @ts-expect-error fetch missing\n            context: {\n              ...context,\n              _parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(\n  arrayBuffer: ArrayBuffer,\n  loader: any,\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({\n  loader,\n  arrayBuffer,\n  options,\n  context\n}: {\n  loader: LoaderWithParser;\n  arrayBuffer: ArrayBuffer;\n  options: LoaderOptions;\n  context: LoaderContext;\n}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoMesh} from './lib/draco-types';\nimport type {DracoParseOptions} from './lib/draco-parser';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    /** @deprecated WASM decoding is faster but JS is more backwards compatible */\n    decoderType?: 'wasm' | 'js';\n    /** @deprecated Specify where to load the Draco decoder library */\n    libraryPath?: string;\n    /** Override the URL to the worker bundle (by default loads from unpkg.com) */\n    workerUrl?: string;\n  };\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  dataType: null as unknown as DracoMesh,\n  batchType: null as never,\n  name: 'Draco',\n  id: 'draco',\n  module: 'draco',\n  // shapes: ['mesh'],\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: {\n    draco: {\n      decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n      libraryPath: 'libs/',\n      extraAttributes: {},\n      attributeNameEntry: undefined\n    }\n  }\n} as const satisfies Loader<DracoMesh, never, DracoLoaderOptions>;\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {DataType} from '../../../types/schema';\nimport {TypedArray, TypedArrayConstructor, ArrayType} from '../../../types/types';\n\n/** Deduce column types from values */\nexport function getDataTypeFromValue(\n  value: unknown,\n  defaultNumberType: 'float32' = 'float32'\n): DataType {\n  if (value instanceof Date) {\n    return 'date-millisecond';\n  }\n  if (value instanceof Number) {\n    return defaultNumberType;\n  }\n  if (typeof value === 'string') {\n    return 'utf8';\n  }\n  if (value === null || value === 'undefined') {\n    return 'null';\n  }\n  return 'null';\n}\n\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromArray(array: ArrayType): {type: DataType; nullable: boolean} {\n  let type = getDataTypeFromTypedArray(array as TypedArray);\n  if (type !== 'null') {\n    return {type, nullable: false};\n  }\n  if (array.length > 0) {\n    type = getDataTypeFromValue(array[0]);\n    return {type, nullable: true};\n  }\n\n  return {type: 'null', nullable: true};\n}\n\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return 'int8';\n    case Uint8Array:\n    case Uint8ClampedArray:\n      return 'uint8';\n    case Int16Array:\n      return 'int16';\n    case Uint16Array:\n      return 'uint16';\n    case Int32Array:\n      return 'int32';\n    case Uint32Array:\n      return 'uint32';\n    case Float32Array:\n      return 'float32';\n    case Float64Array:\n      return 'float64';\n    default:\n      return 'null';\n  }\n}\n\nexport function getArrayTypeFromDataType(\n  type: DataType,\n  nullable: boolean | undefined\n): TypedArrayConstructor | ArrayConstructor {\n  if (!nullable) {\n    switch (type) {\n      case 'int8':\n        return Int8Array;\n      case 'uint8':\n        return Uint8Array;\n      case 'int16':\n        return Int16Array;\n      case 'uint16':\n        return Uint16Array;\n      case 'int32':\n        return Int32Array;\n      case 'uint32':\n        return Uint32Array;\n      case 'float32':\n        return Float32Array;\n      case 'float64':\n        return Float64Array;\n      default:\n        break;\n    }\n  }\n\n  // if (typeof BigInt64Array !== 'undefined') {\n  //   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n  //   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n  // }\n\n  return Array;\n}\n", "// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types/types';\nimport {MeshAttributes} from '../../types/category-mesh';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MeshAttribute, MeshAttributes} from '../../types/category-mesh';\nimport {Schema, Field} from '../../types/schema';\nimport {getDataTypeFromTypedArray} from '../table/simple-table/data-type';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata: Record<string, string> = {}\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return {fields, metadata};\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  name: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Record<string, string>\n): Field {\n  const type = getDataTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  return {\n    name,\n    type: {type: 'fixed-size-list', listSize: attribute.size, children: [{name: 'value', type}]},\n    nullable: false,\n    metadata\n  };\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Record<string, string> {\n  const result: Record<string, string> = {};\n  if ('byteOffset' in attribute) {\n    result.byteOffset = attribute.byteOffset!.toString(10);\n  }\n  if ('byteStride' in attribute) {\n    result.byteStride = attribute.byteStride!.toString(10);\n  }\n  if ('normalized' in attribute) {\n    result.normalized = attribute.normalized!.toString();\n  }\n  return result;\n}\n", "import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadata = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return {fields, metadata};\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Record<string, string> {\n  Object.entries(metadata);\n  const serializedMetadata: Record<string, string> = {};\n  for (const key in metadata) {\n    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);\n  }\n  return serializedMetadata;\n}\n", "/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/** Options to control draco parsing */\nexport type DracoParseOptions = {\n  /** How triangle indices should be generated (mesh only) */\n  topology?: 'triangle-list' | 'triangle-strip';\n  /** Specify which attribute metadata entry stores the attribute name */\n  attributeNameEntry?: string;\n  /** Names and ids of extra attributes to include in the output */\n  extraAttributes?: {[uniqueId: string]: number};\n  /** Skip transforms specific quantized attributes */\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  /** Skip transforms specific octahedron encoded  attributes */\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  // 7: BigInt64Array,\n  // 8: BigUint64Array,\n  9: Float32Array\n  // 10: Float64Array\n  // 11: BOOL - What array type do we use for this?\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      if (values) {\n        const {value, size} = values;\n        attributes[attributeName] = {\n          value,\n          size,\n          byteOffset: loaderAttribute.byte_offset,\n          byteStride: loaderAttribute.byte_stride,\n          normalized: loaderAttribute.normalized\n        };\n      }\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} | null {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    if (!TypedArrayCtor) {\n      // eslint-disable-next-line no-console\n      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);\n      return null;\n    }\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_DECODER_VERSION = '1.5.6';\nconst DRACO_ENCODER_VERSION = '1.4.1';\n\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\n\nexport const DRACO_EXTERNAL_LIBRARIES = {\n  /** The primary Draco3D encoder, javascript wrapper part */\n  DECODER: 'draco_wasm_wrapper.js',\n  /** The primary draco decoder, compiled web assembly part */\n  DECODER_WASM: 'draco_decoder.wasm',\n  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */\n  FALLBACK_DECODER: 'draco_decoder.js',\n  /** Draco encoder */\n  ENCODER: 'draco_encoder.js'\n};\n\nexport const DRACO_EXTERNAL_LIBRARY_URLS = {\n  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,\n  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,\n  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,\n  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`\n};\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {\n      return {draco};\n    });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise ||= loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise ||= modules.draco3d.createEncoderModule({}).then((draco) => {\n      return {draco};\n    });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise ||= loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(\n        DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER],\n        'draco',\n        options,\n        DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER\n      );\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(\n          DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER],\n          'draco',\n          options,\n          DRACO_EXTERNAL_LIBRARIES.DECODER\n        ),\n        await loadLibrary(\n          DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM],\n          'draco',\n          options,\n          DRACO_EXTERNAL_LIBRARIES.DECODER_WASM\n        )\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(\n    DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.ENCODER],\n    'draco',\n    options,\n    DRACO_EXTERNAL_LIBRARIES.ENCODER\n  );\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMesh, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\n\n// Module constants\nexport {DRACO_EXTERNAL_LIBRARIES, DRACO_EXTERNAL_LIBRARY_URLS} from './lib/draco-module-loader';\n\n// Draco data types\n\nexport type {DracoMesh, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n  id: 'draco-writer',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n} as const satisfies LoaderWithParser<DracoMesh, never, DracoLoaderOptions>;\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: DracoLoaderOptions): Promise<DracoMesh> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n", "import {createLoaderWorker} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '../index';\n\ncreateLoaderWorker(DracoLoader);\n"],
  "mappings": "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",
  "names": ["parentPort", "payload", "VERSION", "VERSION", "DracoLoader", "DracoLoader"]
}
