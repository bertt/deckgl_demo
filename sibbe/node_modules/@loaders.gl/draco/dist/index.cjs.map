{
  "version": 3,
  "sources": ["index.js", "lib/utils/version.js", "draco-loader.js", "lib/draco-parser.js", "lib/utils/get-draco-schema.js", "lib/draco-module-loader.js", "lib/draco-builder.js", "draco-writer.js"],
  "sourcesContent": ["import { DracoLoader as DracoWorkerLoader } from \"./draco-loader.js\";\nimport DracoParser from \"./lib/draco-parser.js\";\nimport { loadDracoDecoderModule } from \"./lib/draco-module-loader.js\";\nimport { VERSION } from \"./lib/utils/version.js\";\n// Module constants\nexport { DRACO_EXTERNAL_LIBRARIES, DRACO_EXTERNAL_LIBRARY_URLS } from \"./lib/draco-module-loader.js\";\nexport { DracoWriter } from \"./draco-writer.js\";\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n    id: 'draco-writer',\n    name: 'Draco compressed geometry writer',\n    module: 'draco',\n    version: VERSION,\n    worker: true,\n    options: {\n        draco: {},\n        source: null\n    }\n};\nexport { DracoWorkerLoader };\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n    ...DracoWorkerLoader,\n    parse\n};\nasync function parse(arrayBuffer, options) {\n    const { draco } = await loadDracoDecoderModule(options);\n    const dracoParser = new DracoParser(draco);\n    try {\n        return dracoParser.parseSync(arrayBuffer, options?.draco);\n    }\n    finally {\n        dracoParser.destroy();\n    }\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Draco',\n    id: 'draco',\n    module: 'draco',\n    // shapes: ['mesh'],\n    version: VERSION,\n    worker: true,\n    extensions: ['drc'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['DRACO'],\n    options: {\n        draco: {\n            decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n            libraryPath: 'libs/',\n            extraAttributes: {},\n            attributeNameEntry: undefined\n        }\n    }\n};\n", "/* eslint-disable camelcase */\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getDracoSchema } from \"./utils/get-draco-schema.js\";\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n    TRIANGULAR_MESH: 0,\n    POINT_CLOUD: 1\n};\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n    POSITION: 'POSITION',\n    NORMAL: 'NORMAL',\n    COLOR: 'COLOR_0',\n    TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n    1: Int8Array,\n    2: Uint8Array,\n    3: Int16Array,\n    4: Uint16Array,\n    5: Int32Array,\n    6: Uint32Array,\n    // 7: BigInt64Array,\n    // 8: BigUint64Array,\n    9: Float32Array\n    // 10: Float64Array\n    // 11: BOOL - What array type do we use for this?\n};\nconst INDEX_ITEM_SIZE = 4;\nexport default class DracoParser {\n    draco;\n    decoder;\n    metadataQuerier;\n    // draco - the draco decoder, either import `draco3d` or load dynamically\n    constructor(draco) {\n        this.draco = draco;\n        this.decoder = new this.draco.Decoder();\n        this.metadataQuerier = new this.draco.MetadataQuerier();\n    }\n    /**\n     * Destroy draco resources\n     */\n    destroy() {\n        this.draco.destroy(this.decoder);\n        this.draco.destroy(this.metadataQuerier);\n    }\n    /**\n     * NOTE: caller must call `destroyGeometry` on the return value after using it\n     * @param arrayBuffer\n     * @param options\n     */\n    parseSync(arrayBuffer, options = {}) {\n        const buffer = new this.draco.DecoderBuffer();\n        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n        this._disableAttributeTransforms(options);\n        const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n        const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH\n            ? new this.draco.Mesh()\n            : new this.draco.PointCloud();\n        try {\n            let dracoStatus;\n            switch (geometry_type) {\n                case this.draco.TRIANGULAR_MESH:\n                    dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n                    break;\n                case this.draco.POINT_CLOUD:\n                    dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n                    break;\n                default:\n                    throw new Error('DRACO: Unknown geometry type.');\n            }\n            if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n                const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n                // console.error(message);\n                throw new Error(message);\n            }\n            const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n            const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n            const boundingBox = getMeshBoundingBox(geometry.attributes);\n            const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n            const data = {\n                loader: 'draco',\n                loaderData,\n                header: {\n                    vertexCount: dracoGeometry.num_points(),\n                    boundingBox\n                },\n                ...geometry,\n                schema\n            };\n            return data;\n        }\n        finally {\n            this.draco.destroy(buffer);\n            if (dracoGeometry) {\n                this.draco.destroy(dracoGeometry);\n            }\n        }\n    }\n    // Draco specific \"loader data\"\n    /**\n     * Extract\n     * @param dracoGeometry\n     * @param geometry_type\n     * @param options\n     * @returns\n     */\n    _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n        const metadata = this._getTopLevelMetadata(dracoGeometry);\n        const attributes = this._getDracoAttributes(dracoGeometry, options);\n        return {\n            geometry_type,\n            num_attributes: dracoGeometry.num_attributes(),\n            num_points: dracoGeometry.num_points(),\n            num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n            metadata,\n            attributes\n        };\n    }\n    /**\n     * Extract all draco provided information and metadata for each attribute\n     * @param dracoGeometry\n     * @param options\n     * @returns\n     */\n    _getDracoAttributes(dracoGeometry, options) {\n        const dracoAttributes = {};\n        for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n            // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n            // but it does seems to work this way\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n            const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n            dracoAttributes[dracoAttribute.unique_id()] = {\n                unique_id: dracoAttribute.unique_id(),\n                attribute_type: dracoAttribute.attribute_type(),\n                data_type: dracoAttribute.data_type(),\n                num_components: dracoAttribute.num_components(),\n                byte_offset: dracoAttribute.byte_offset(),\n                byte_stride: dracoAttribute.byte_stride(),\n                normalized: dracoAttribute.normalized(),\n                attribute_index: attributeId,\n                metadata\n            };\n            // Add transformation parameters for any attributes app wants untransformed\n            const quantization = this._getQuantizationTransform(dracoAttribute, options);\n            if (quantization) {\n                dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n            }\n            const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n            if (octahedron) {\n                dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n            }\n        }\n        return dracoAttributes;\n    }\n    /**\n     * Get standard loaders.gl mesh category data\n     * Extracts the geometry from draco\n     * @param dracoGeometry\n     * @param options\n     */\n    _getMeshData(dracoGeometry, loaderData, options) {\n        const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n        const positionAttribute = attributes.POSITION;\n        if (!positionAttribute) {\n            throw new Error('DRACO: No position attribute found.');\n        }\n        // For meshes, we need indices to define the faces.\n        if (dracoGeometry instanceof this.draco.Mesh) {\n            switch (options.topology) {\n                case 'triangle-strip':\n                    return {\n                        topology: 'triangle-strip',\n                        mode: 4, // GL.TRIANGLES\n                        attributes,\n                        indices: {\n                            value: this._getTriangleStripIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n                case 'triangle-list':\n                default:\n                    return {\n                        topology: 'triangle-list',\n                        mode: 5, // GL.TRIANGLE_STRIP\n                        attributes,\n                        indices: {\n                            value: this._getTriangleListIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n            }\n        }\n        // PointCloud - must come last as Mesh inherits from PointCloud\n        return {\n            topology: 'point-list',\n            mode: 0, // GL.POINTS\n            attributes\n        };\n    }\n    _getMeshAttributes(loaderData, dracoGeometry, options) {\n        const attributes = {};\n        for (const loaderAttribute of Object.values(loaderData.attributes)) {\n            const attributeName = this._deduceAttributeName(loaderAttribute, options);\n            loaderAttribute.name = attributeName;\n            const values = this._getAttributeValues(dracoGeometry, loaderAttribute);\n            if (values) {\n                const { value, size } = values;\n                attributes[attributeName] = {\n                    value,\n                    size,\n                    byteOffset: loaderAttribute.byte_offset,\n                    byteStride: loaderAttribute.byte_stride,\n                    normalized: loaderAttribute.normalized\n                };\n            }\n        }\n        return attributes;\n    }\n    // MESH INDICES EXTRACTION\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleListIndices(dracoGeometry) {\n        // Example on how to retrieve mesh and attributes.\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * INDEX_ITEM_SIZE;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n            return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n    }\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleStripIndices(dracoGeometry) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n            return getUint32Array(dracoArray);\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    /**\n     *\n     * @param dracoGeometry\n     * @param dracoAttribute\n     * @param attributeName\n     */\n    _getAttributeValues(dracoGeometry, attribute) {\n        const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n        if (!TypedArrayCtor) {\n            // eslint-disable-next-line no-console\n            console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);\n            return null;\n        }\n        const numComponents = attribute.num_components;\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n        let value;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n            this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n            value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n        return { value, size: numComponents };\n    }\n    // Attribute names\n    /**\n     * DRACO does not store attribute names - We need to deduce an attribute name\n     * for each attribute\n    _getAttributeNames(\n      dracoGeometry: Mesh | PointCloud,\n      options: DracoParseOptions\n    ): {[unique_id: number]: string} {\n      const attributeNames: {[unique_id: number]: string} = {};\n      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n        const attributeName = this._deduceAttributeName(dracoAttribute, options);\n        attributeNames[attributeName] = attributeName;\n      }\n      return attributeNames;\n    }\n     */\n    /**\n     * Deduce an attribute name.\n     * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n     * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n     * types\n     * @param attributeData\n     */\n    _deduceAttributeName(attribute, options) {\n        // Deduce name based on application provided map\n        const uniqueId = attribute.unique_id;\n        for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n            if (attributeUniqueId === uniqueId) {\n                return attributeName;\n            }\n        }\n        // Deduce name based on attribute type\n        const thisAttributeType = attribute.attribute_type;\n        for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n            const attributeType = this.draco[dracoAttributeConstant];\n            if (attributeType === thisAttributeType) {\n                // TODO - Return unique names if there multiple attributes per type\n                // (e.g. multiple TEX_COORDS or COLORS)\n                return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n            }\n        }\n        // Look up in metadata\n        // TODO - shouldn't this have priority?\n        const entryName = options.attributeNameEntry || 'name';\n        if (attribute.metadata[entryName]) {\n            return attribute.metadata[entryName].string;\n        }\n        // Attribute of \"GENERIC\" type, we need to assign some name\n        return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n    }\n    // METADATA EXTRACTION\n    /** Get top level metadata */\n    _getTopLevelMetadata(dracoGeometry) {\n        const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /** Get per attribute metadata */\n    _getAttributeMetadata(dracoGeometry, attributeId) {\n        const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /**\n     * Extract metadata field values\n     * @param dracoMetadata\n     * @returns\n     */\n    _getDracoMetadata(dracoMetadata) {\n        // The not so wonderful world of undocumented Draco APIs :(\n        if (!dracoMetadata || !dracoMetadata.ptr) {\n            return {};\n        }\n        const result = {};\n        const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n        for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n            const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n            result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n        }\n        return result;\n    }\n    /**\n     * Extracts possible values for one metadata entry by name\n     * @param dracoMetadata\n     * @param entryName\n     */\n    _getDracoMetadataField(dracoMetadata, entryName) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            // Draco metadata fields can hold int32 arrays\n            this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n            const intArray = getInt32Array(dracoArray);\n            return {\n                int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n                string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n                double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n                intArray\n            };\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n    /** Skip transforms for specific attribute types */\n    _disableAttributeTransforms(options) {\n        const { quantizedAttributes = [], octahedronAttributes = [] } = options;\n        const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n        for (const dracoAttributeName of skipAttributes) {\n            this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n        }\n    }\n    /**\n     * Extract (and apply?) Position Transform\n     * @todo not used\n     */\n    _getQuantizationTransform(dracoAttribute, options) {\n        const { quantizedAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n        if (skip) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits(),\n                        range: transform.range(),\n                        min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n    _getOctahedronTransform(dracoAttribute, options) {\n        const { octahedronAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const octahedron = octahedronAttributes\n            .map((type) => this.decoder[type])\n            .includes(attribute_type);\n        if (octahedron) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits()\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n}\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n        case Float32Array:\n            return draco.DT_FLOAT32;\n        case Int8Array:\n            return draco.DT_INT8;\n        case Int16Array:\n            return draco.DT_INT16;\n        case Int32Array:\n            return draco.DT_INT32;\n        case Uint8Array:\n            return draco.DT_UINT8;\n        case Uint16Array:\n            return draco.DT_UINT16;\n        case Uint32Array:\n            return draco.DT_UINT32;\n        default:\n            return draco.DT_INVALID;\n    }\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n", "import { deduceMeshField } from '@loaders.gl/schema';\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(attributes, loaderData, indices) {\n    const metadata = makeMetadata(loaderData.metadata);\n    const fields = [];\n    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n        fields.push(field);\n    }\n    if (indices) {\n        const indicesField = getArrowFieldFromAttribute('indices', indices);\n        fields.push(indicesField);\n    }\n    return { fields, metadata };\n}\nfunction transformAttributesLoaderData(loaderData) {\n    const result = {};\n    for (const key in loaderData) {\n        const dracoAttribute = loaderData[key];\n        result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n    }\n    return result;\n}\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n    const field = deduceMeshField(attributeName, attribute, metadataMap);\n    return field;\n}\nfunction makeMetadata(metadata) {\n    Object.entries(metadata);\n    const serializedMetadata = {};\n    for (const key in metadata) {\n        serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);\n    }\n    return serializedMetadata;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\nimport { loadLibrary } from '@loaders.gl/worker-utils';\nconst DRACO_DECODER_VERSION = '1.5.6';\nconst DRACO_ENCODER_VERSION = '1.4.1';\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\nexport const DRACO_EXTERNAL_LIBRARIES = {\n    /** The primary Draco3D encoder, javascript wrapper part */\n    DECODER: 'draco_wasm_wrapper.js',\n    /** The primary draco decoder, compiled web assembly part */\n    DECODER_WASM: 'draco_decoder.wasm',\n    /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */\n    FALLBACK_DECODER: 'draco_decoder.js',\n    /** Draco encoder */\n    ENCODER: 'draco_encoder.js'\n};\nexport const DRACO_EXTERNAL_LIBRARY_URLS = {\n    [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,\n    [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,\n    [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,\n    [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`\n};\nlet loadDecoderPromise;\nlet loadEncoderPromise;\nexport async function loadDracoDecoderModule(options) {\n    const modules = options.modules || {};\n    // Check if a bundled draco3d library has been supplied by application\n    if (modules.draco3d) {\n        loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {\n            return { draco };\n        });\n    }\n    else {\n        // If not, dynamically load the WASM script from our CDN\n        loadDecoderPromise ||= loadDracoDecoder(options);\n    }\n    return await loadDecoderPromise;\n}\nexport async function loadDracoEncoderModule(options) {\n    const modules = options.modules || {};\n    // Check if a bundled draco3d library has been supplied by application\n    if (modules.draco3d) {\n        loadEncoderPromise ||= modules.draco3d.createEncoderModule({}).then((draco) => {\n            return { draco };\n        });\n    }\n    else {\n        // If not, dynamically load the WASM script from our CDN\n        loadEncoderPromise ||= loadDracoEncoder(options);\n    }\n    return await loadEncoderPromise;\n}\n// DRACO DECODER LOADING\nasync function loadDracoDecoder(options) {\n    let DracoDecoderModule;\n    let wasmBinary;\n    switch (options.draco && options.draco.decoderType) {\n        case 'js':\n            DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);\n            break;\n        case 'wasm':\n        default:\n            [DracoDecoderModule, wasmBinary] = await Promise.all([\n                await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER),\n                await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)\n            ]);\n    }\n    // Depends on how import happened...\n    // @ts-ignore\n    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n    const options = {};\n    if (wasmBinary) {\n        options.wasmBinary = wasmBinary;\n    }\n    return new Promise((resolve) => {\n        DracoDecoderModule({\n            ...options,\n            onModuleLoaded: (draco) => resolve({ draco }) // Module is Promise-like. Wrap in object to avoid loop.\n        });\n    });\n}\n// ENCODER\nasync function loadDracoEncoder(options) {\n    let DracoEncoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.ENCODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.ENCODER);\n    // @ts-ignore\n    DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n    return new Promise((resolve) => {\n        DracoEncoderModule({\n            onModuleLoaded: (draco) => resolve({ draco }) // Module is Promise-like. Wrap in object to avoid loop.\n        });\n    });\n}\n", "// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n    POSITION: 'POSITION',\n    NORMAL: 'NORMAL',\n    COLOR_0: 'COLOR',\n    TEXCOORD_0: 'TEX_COORD'\n};\nconst noop = () => { };\nexport default class DracoBuilder {\n    draco;\n    dracoEncoder;\n    dracoMeshBuilder;\n    dracoMetadataBuilder;\n    log;\n    // draco - the draco decoder, either import `draco3d` or load dynamically\n    constructor(draco) {\n        this.draco = draco;\n        this.dracoEncoder = new this.draco.Encoder();\n        this.dracoMeshBuilder = new this.draco.MeshBuilder();\n        this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n    }\n    destroy() {\n        this.destroyEncodedObject(this.dracoMeshBuilder);\n        this.destroyEncodedObject(this.dracoEncoder);\n        this.destroyEncodedObject(this.dracoMetadataBuilder);\n        // @ts-ignore\n        this.dracoMeshBuilder = null;\n        // @ts-ignore\n        this.dracoEncoder = null;\n        // @ts-ignore\n        this.draco = null;\n    }\n    // TBD - when does this need to be called?\n    destroyEncodedObject(object) {\n        if (object) {\n            this.draco.destroy(object);\n        }\n    }\n    /**\n     * Encode mesh or point cloud\n     * @param mesh =({})\n     * @param options\n     */\n    encodeSync(mesh, options = {}) {\n        this.log = noop; // TODO\n        this._setOptions(options);\n        return options.pointcloud\n            ? this._encodePointCloud(mesh, options)\n            : this._encodeMesh(mesh, options);\n    }\n    // PRIVATE\n    _getAttributesFromMesh(mesh) {\n        // TODO - Change the encodePointCloud interface instead?\n        const attributes = { ...mesh, ...mesh.attributes };\n        // Fold indices into the attributes\n        if (mesh.indices) {\n            attributes.indices = mesh.indices;\n        }\n        return attributes;\n    }\n    _encodePointCloud(pointcloud, options) {\n        const dracoPointCloud = new this.draco.PointCloud();\n        if (options.metadata) {\n            this._addGeometryMetadata(dracoPointCloud, options.metadata);\n        }\n        const attributes = this._getAttributesFromMesh(pointcloud);\n        // Build a `DracoPointCloud` from the input data\n        this._createDracoPointCloud(dracoPointCloud, attributes, options);\n        const dracoData = new this.draco.DracoInt8Array();\n        try {\n            const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n            if (!(encodedLen > 0)) {\n                throw new Error('Draco encoding failed.');\n            }\n            this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n            return dracoInt8ArrayToArrayBuffer(dracoData);\n        }\n        finally {\n            this.destroyEncodedObject(dracoData);\n            this.destroyEncodedObject(dracoPointCloud);\n        }\n    }\n    _encodeMesh(mesh, options) {\n        const dracoMesh = new this.draco.Mesh();\n        if (options.metadata) {\n            this._addGeometryMetadata(dracoMesh, options.metadata);\n        }\n        const attributes = this._getAttributesFromMesh(mesh);\n        // Build a `DracoMesh` from the input data\n        this._createDracoMesh(dracoMesh, attributes, options);\n        const dracoData = new this.draco.DracoInt8Array();\n        try {\n            const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n            if (encodedLen <= 0) {\n                throw new Error('Draco encoding failed.');\n            }\n            this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n            return dracoInt8ArrayToArrayBuffer(dracoData);\n        }\n        finally {\n            this.destroyEncodedObject(dracoData);\n            this.destroyEncodedObject(dracoMesh);\n        }\n    }\n    /**\n     * Set encoding options.\n     * @param {{speed?: any; method?: any; quantization?: any;}} options\n     */\n    _setOptions(options) {\n        if ('speed' in options) {\n            // @ts-ignore\n            this.dracoEncoder.SetSpeedOptions(...options.speed);\n        }\n        if ('method' in options) {\n            const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n            // assert(dracoMethod)\n            this.dracoEncoder.SetEncodingMethod(dracoMethod);\n        }\n        if ('quantization' in options) {\n            for (const attribute in options.quantization) {\n                const bits = options.quantization[attribute];\n                const dracoPosition = this.draco[attribute];\n                this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n            }\n        }\n    }\n    /**\n     * @param {Mesh} dracoMesh\n     * @param {object} attributes\n     * @returns {Mesh}\n     */\n    _createDracoMesh(dracoMesh, attributes, options) {\n        const optionalMetadata = options.attributesMetadata || {};\n        try {\n            const positions = this._getPositionAttribute(attributes);\n            if (!positions) {\n                throw new Error('positions');\n            }\n            const vertexCount = positions.length / 3;\n            for (let attributeName in attributes) {\n                const attribute = attributes[attributeName];\n                attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n                const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n                if (uniqueId !== -1) {\n                    this._addAttributeMetadata(dracoMesh, uniqueId, {\n                        name: attributeName,\n                        ...(optionalMetadata[attributeName] || {})\n                    });\n                }\n            }\n        }\n        catch (error) {\n            this.destroyEncodedObject(dracoMesh);\n            throw error;\n        }\n        return dracoMesh;\n    }\n    /**\n     * @param {} dracoPointCloud\n     * @param {object} attributes\n     */\n    _createDracoPointCloud(dracoPointCloud, attributes, options) {\n        const optionalMetadata = options.attributesMetadata || {};\n        try {\n            const positions = this._getPositionAttribute(attributes);\n            if (!positions) {\n                throw new Error('positions');\n            }\n            const vertexCount = positions.length / 3;\n            for (let attributeName in attributes) {\n                const attribute = attributes[attributeName];\n                attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n                const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n                if (uniqueId !== -1) {\n                    this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n                        name: attributeName,\n                        ...(optionalMetadata[attributeName] || {})\n                    });\n                }\n            }\n        }\n        catch (error) {\n            this.destroyEncodedObject(dracoPointCloud);\n            throw error;\n        }\n        return dracoPointCloud;\n    }\n    /**\n     * @param mesh\n     * @param attributeName\n     * @param attribute\n     * @param vertexCount\n     */\n    _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n        if (!ArrayBuffer.isView(attribute)) {\n            return -1;\n        }\n        const type = this._getDracoAttributeType(attributeName);\n        // @ts-ignore TODO/fix types\n        const size = attribute.length / vertexCount;\n        if (type === 'indices') {\n            // @ts-ignore TODO/fix types\n            const numFaces = attribute.length / 3;\n            this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n            // @ts-ignore assumes mesh is a Mesh, not a point cloud\n            this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n            return -1;\n        }\n        this.log(`Adding attribute ${attributeName}, size ${size}`);\n        const builder = this.dracoMeshBuilder;\n        const { buffer } = attribute;\n        switch (attribute.constructor) {\n            case Int8Array:\n                return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n            case Int16Array:\n                return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n            case Int32Array:\n                return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n            case Uint8Array:\n            case Uint8ClampedArray:\n                return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n            case Uint16Array:\n                return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n            case Uint32Array:\n                return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n            case Float32Array:\n                return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n            // case Float64Array:\n            // Add attribute does not seem to be exposed\n            //   return builder.AddAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n            default:\n                // eslint-disable-next-line no-console\n                console.warn('Unsupported attribute type', attribute);\n                return -1;\n        }\n    }\n    /**\n     * DRACO can compress attributes of know type better\n     * TODO - expose an attribute type map?\n     * @param attributeName\n     */\n    _getDracoAttributeType(attributeName) {\n        switch (attributeName.toLowerCase()) {\n            case 'indices':\n                return 'indices';\n            case 'position':\n            case 'positions':\n            case 'vertices':\n                return this.draco.POSITION;\n            case 'normal':\n            case 'normals':\n                return this.draco.NORMAL;\n            case 'color':\n            case 'colors':\n                return this.draco.COLOR;\n            case 'texcoord':\n            case 'texcoords':\n                return this.draco.TEX_COORD;\n            default:\n                return this.draco.GENERIC;\n        }\n    }\n    _getPositionAttribute(attributes) {\n        for (const attributeName in attributes) {\n            const attribute = attributes[attributeName];\n            const dracoType = this._getDracoAttributeType(attributeName);\n            if (dracoType === this.draco.POSITION) {\n                return attribute;\n            }\n        }\n        return null;\n    }\n    /**\n     * Add metadata for the geometry.\n     * @param dracoGeometry - WASM Draco Object\n     * @param metadata\n     */\n    _addGeometryMetadata(dracoGeometry, metadata) {\n        const dracoMetadata = new this.draco.Metadata();\n        this._populateDracoMetadata(dracoMetadata, metadata);\n        this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n    }\n    /**\n     * Add metadata for an attribute to geometry.\n     * @param dracoGeometry - WASM Draco Object\n     * @param uniqueAttributeId\n     * @param metadata\n     */\n    _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n        // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n        // create such objects automatically from draco.Metadata object.\n        const dracoAttributeMetadata = new this.draco.Metadata();\n        this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n        // Draco3d doc note: Directly add attribute metadata to geometry.\n        // You can do this without explicitly adding |GeometryMetadata| to mesh.\n        this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n    }\n    /**\n     * Add contents of object or map to a WASM Draco Metadata Object\n     * @param dracoMetadata - WASM Draco Object\n     * @param metadata\n     */\n    _populateDracoMetadata(dracoMetadata, metadata) {\n        for (const [key, value] of getEntries(metadata)) {\n            switch (typeof value) {\n                case 'number':\n                    if (Math.trunc(value) === value) {\n                        this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n                    }\n                    else {\n                        this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n                    }\n                    break;\n                case 'object':\n                    if (value instanceof Int32Array) {\n                        this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n                    }\n                    break;\n                case 'string':\n                default:\n                    this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n            }\n        }\n    }\n}\n// HELPER FUNCTIONS\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n    const byteLength = dracoData.size();\n    const outputBuffer = new ArrayBuffer(byteLength);\n    const outputData = new Int8Array(outputBuffer);\n    for (let i = 0; i < byteLength; ++i) {\n        outputData[i] = dracoData.GetValue(i);\n    }\n    return outputBuffer;\n}\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n    const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n    return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n", "import DRACOBuilder from \"./lib/draco-builder.js\";\nimport { loadDracoEncoderModule } from \"./lib/draco-module-loader.js\";\nimport { VERSION } from \"./lib/utils/version.js\";\nconst DEFAULT_DRACO_WRITER_OPTIONS = {\n    pointcloud: false, // Set to true if pointcloud (mode: 0, no indices)\n    attributeNameEntry: 'name'\n    // Draco Compression Parameters\n    // method: 'MESH_EDGEBREAKER_ENCODING', // Use draco defaults\n    // speed: [5, 5], // Use draco defaults\n    // quantization: { // Use draco defaults\n    //   POSITION: 10\n    // }\n};\n/**\n * Exporter for Draco3D compressed geometries\n */\nexport const DracoWriter = {\n    name: 'DRACO',\n    id: 'draco',\n    module: 'draco',\n    version: VERSION,\n    extensions: ['drc'],\n    options: {\n        draco: DEFAULT_DRACO_WRITER_OPTIONS\n    },\n    encode\n};\nasync function encode(data, options = {}) {\n    // Dynamically load draco\n    const { draco } = await loadDracoEncoderModule(options);\n    const dracoBuilder = new DRACOBuilder(draco);\n    try {\n        return dracoBuilder.encodeSync(data, options.draco);\n    }\n    finally {\n        dracoBuilder.destroy();\n    }\n}\n"],
  "mappings": "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",
  "names": ["DracoLoader", "import_schema", "DracoLoader"]
}
