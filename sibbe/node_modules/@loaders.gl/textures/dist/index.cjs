"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  BASIS_EXTERNAL_LIBRARIES: () => BASIS_EXTERNAL_LIBRARIES,
  BasisLoader: () => BasisLoader,
  BasisWorkerLoader: () => BasisWorkerLoader,
  CRUNCH_EXTERNAL_LIBRARIES: () => CRUNCH_EXTERNAL_LIBRARIES,
  CompressedTextureLoader: () => CompressedTextureLoader,
  CompressedTextureWorkerLoader: () => CompressedTextureWorkerLoader,
  CompressedTextureWriter: () => CompressedTextureWriter,
  CrunchLoader: () => CrunchLoader,
  CrunchWorkerLoader: () => CrunchLoader,
  GL_EXTENSIONS_CONSTANTS: () => GL_EXTENSIONS_CONSTANTS,
  KTX2BasisWriter: () => KTX2BasisWriter,
  KTX2BasisWriterWorker: () => KTX2BasisWriterWorker,
  NPYLoader: () => NPYLoader,
  NPYWorkerLoader: () => NPYWorkerLoader,
  getSupportedGPUTextureFormats: () => getSupportedGPUTextureFormats,
  loadImageTexture: () => loadImageTexture,
  loadImageTextureArray: () => loadImageTextureArray,
  loadImageTextureCube: () => loadImageTextureCube,
  selectSupportedBasisFormat: () => selectSupportedBasisFormat
});
module.exports = __toCommonJS(dist_exports);

// dist/lib/utils/version.js
var VERSION = true ? "4.2.0-beta.2" : "latest";

// dist/lib/parsers/basis-module-loader.js
var import_loader_utils = require("@loaders.gl/loader-utils");
var import_worker_utils = require("@loaders.gl/worker-utils");
var BASIS_EXTERNAL_LIBRARIES = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
var loadBasisTranscoderPromise;
async function loadBasisTranscoderModule(options) {
  (0, import_loader_utils.registerJSModules)(options.modules);
  const basis = (0, import_loader_utils.getJSModuleOrNull)("basis");
  if (basis) {
    return basis;
  }
  loadBasisTranscoderPromise ||= loadBasisTranscoder(options);
  return await loadBasisTranscoderPromise;
}
async function loadBasisTranscoder(options) {
  let BASIS = null;
  let wasmBinary = null;
  [BASIS, wasmBinary] = await Promise.all([
    await (0, import_worker_utils.loadLibrary)(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
    await (0, import_worker_utils.loadLibrary)(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
  ]);
  BASIS = BASIS || globalThis.BASIS;
  return await initializeBasisTranscoderModule(BASIS, wasmBinary);
}
function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisModule(options).then((module2) => {
      const { BasisFile, initializeBasis } = module2;
      initializeBasis();
      resolve({ BasisFile });
    });
  });
}
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await (0, import_worker_utils.loadLibrary)(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
    await (0, import_worker_utils.loadLibrary)(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisEncoderModule(options).then((module2) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module2;
      initializeBasis();
      resolve({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// dist/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_es3
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_atc
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  // EXT_texture_compression_rgtc
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
};

// dist/lib/utils/texture-formats.js
var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
var WEBGL_EXTENSIONS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
var formats = null;
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || void 0;
    formats = /* @__PURE__ */ new Set();
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension(`${prefix}${extension}`)) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas = document.createElement("canvas");
    return canvas.getContext("webgl");
  } catch (error) {
    return null;
  }
}

// dist/lib/parsers/parse-ktx.js
var import_ktx_parse = require("ktx-parse");

// dist/lib/utils/extract-mipmap-images.js
function extractMipmapImages(data, options) {
  const images = new Array(options.mipMapLevels);
  let levelWidth = options.width;
  let levelHeight = options.height;
  let offset = 0;
  for (let i = 0; i < options.mipMapLevels; ++i) {
    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);
    const levelData = getLevelData(data, i, offset, levelSize);
    images[i] = {
      compressed: true,
      format: options.internalFormat,
      data: levelData,
      width: levelWidth,
      height: levelHeight,
      levelSize
    };
    levelWidth = Math.max(1, levelWidth >> 1);
    levelHeight = Math.max(1, levelHeight >> 1);
    offset += levelSize;
  }
  return images;
}
function getLevelData(data, index, offset, levelSize) {
  if (!Array.isArray(data)) {
    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);
  }
  return data[index].levelData;
}
function getLevelSize(options, levelWidth, levelHeight, data, index) {
  if (!Array.isArray(data)) {
    return options.sizeFunction(levelWidth, levelHeight);
  }
  return options.sizeFunction(data[index]);
}

// dist/lib/utils/ktx-format-helper.js
var VULKAN_TO_WEBGL_FORMAT_MAP = {
  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,
  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,
  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,
  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,
  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,
  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,
  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,
  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,
  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,
  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,
  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,
  // @ts-ignore
  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
  // @ts-ignore
  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
  // @ts-ignore
  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
  // @ts-ignore
  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
  // @ts-ignore
  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
  // @ts-ignore
  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
  // @ts-ignore
  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
  // @ts-ignore
  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
  // @ts-ignore
  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
  // @ts-ignore
  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
  // @ts-ignore
  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
  // @ts-ignore
  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
  // @ts-ignore
  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
  // @ts-ignore
  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,
  // @ts-ignore
  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
  1000054e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  // @ts-ignore
  1000066e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR
};
function mapVkFormatToWebGL(vkFormat) {
  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];
}

// dist/lib/parsers/parse-ktx.js
var KTX2_ID = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || // '´'
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // 'ª'
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11];
  return !notKTX;
}
function parseKTX(arrayBuffer) {
  const uint8Array = new Uint8Array(arrayBuffer);
  const ktx = (0, import_ktx_parse.read)(uint8Array);
  const mipMapLevels = Math.max(1, ktx.levels.length);
  const width = ktx.pixelWidth;
  const height = ktx.pixelHeight;
  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);
  return extractMipmapImages(ktx.levels, {
    mipMapLevels,
    width,
    height,
    sizeFunction: (level) => level.uncompressedByteLength,
    internalFormat
  });
}

// dist/lib/parsers/parse-basis.js
var OutputFormat = {
  etc1: {
    basisFormat: 0,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: true },
  bc1: {
    basisFormat: 2,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: true },
  bc5: { basisFormat: 5, compressed: true },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
  "bc7-m5": { basisFormat: 7, compressed: true },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: true },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
  rgba32: { basisFormat: 13, compressed: false },
  rgb565: { basisFormat: 14, compressed: false },
  bgr565: { basisFormat: 15, compressed: false },
  rgba4444: { basisFormat: 16, compressed: false }
};
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const { BasisFile } = await loadBasisTranscoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha(
    /* imageIndex, levelIndex */
  );
  const { compressed, format, basisFormat } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    format,
    // Additional fields
    // Add levelSize field.
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
      break;
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const { compressed, format, basisFormat } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(
    decodedData,
    levelIndex,
    0,
    0,
    basisFormat,
    0,
    -1,
    -1
    /* channel1 */
  )) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    // Additional fields
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format
  };
}
function getBasisOptions(options, hasAlpha) {
  let format = options && options.basis && options.basis.format;
  if (format === "auto") {
    format = selectSupportedBasisFormat();
  }
  if (typeof format === "object") {
    format = hasAlpha ? format.alpha : format.noAlpha;
  }
  format = format.toLowerCase();
  return OutputFormat[format];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}

// dist/basis-loader.js
var BasisWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: VERSION,
  worker: true,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: true,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
};
var BasisLoader = {
  ...BasisWorkerLoader,
  parse: parseBasis
};

// dist/lib/parsers/parse-dds.js
var import_loader_utils2 = require("@loaders.gl/loader-utils");
var DDS_CONSTANTS = {
  MAGIC_NUMBER: 542327876,
  HEADER_LENGTH: 31,
  MAGIC_NUMBER_INDEX: 0,
  HEADER_SIZE_INDEX: 1,
  HEADER_FLAGS_INDEX: 2,
  HEADER_HEIGHT_INDEX: 3,
  HEADER_WIDTH_INDEX: 4,
  MIPMAPCOUNT_INDEX: 7,
  HEADER_PF_FLAGS_INDEX: 20,
  HEADER_PF_FOURCC_INDEX: 21,
  DDSD_MIPMAPCOUNT: 131072,
  DDPF_FOURCC: 4
};
var DDS_PIXEL_FORMATS = {
  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  "ATC ": GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,
  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
};
var getATCLevelSize = getDxt1LevelSize;
var getATCALevelSize = getDxtXLevelSize;
var getATCILevelSize = getDxtXLevelSize;
var DDS_SIZE_FUNCTIONS = {
  DXT1: getDxt1LevelSize,
  DXT3: getDxtXLevelSize,
  DXT5: getDxtXLevelSize,
  "ATC ": getATCLevelSize,
  ATCA: getATCALevelSize,
  ATCI: getATCILevelSize
};
function isDDS(data) {
  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];
  return magic === DDS_CONSTANTS.MAGIC_NUMBER;
}
function parseDDS(data) {
  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];
  (0, import_loader_utils2.assert)(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), "DDS: Unsupported format, must contain a FourCC code");
  const fourCC = int32ToFourCC(pixelFormatNumber);
  const internalFormat = DDS_PIXEL_FORMATS[fourCC];
  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];
  (0, import_loader_utils2.assert)(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);
  let mipMapLevels = 1;
  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {
    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);
  }
  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];
  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];
  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function getDxt1LevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 8;
}
function getDxtXLevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 16;
}
function int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}

// dist/lib/parsers/parse-pvr.js
var PVR_CONSTANTS = {
  MAGIC_NUMBER: 55727696,
  MAGIC_NUMBER_EXTRA: 1347834371,
  HEADER_LENGTH: 13,
  HEADER_SIZE: 52,
  MAGIC_NUMBER_INDEX: 0,
  PIXEL_FORMAT_INDEX: 2,
  COLOUR_SPACE_INDEX: 4,
  HEIGHT_INDEX: 6,
  WIDTH_INDEX: 7,
  MIPMAPCOUNT_INDEX: 11,
  METADATA_SIZE_INDEX: 12
};
var PVR_PIXEL_FORMATS = {
  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],
  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],
  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],
  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],
  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],
  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],
  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],
  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],
  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],
  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],
  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],
  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],
  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],
  27: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR
  ],
  28: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR
  ],
  29: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR
  ],
  30: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR
  ],
  31: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR
  ],
  32: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR
  ],
  33: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR
  ],
  34: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR
  ],
  35: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR
  ],
  36: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR
  ],
  37: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR
  ],
  38: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR
  ],
  39: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR
  ],
  40: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR
  ]
};
var PVR_SIZE_FUNCTIONS = {
  0: pvrtc2bppSize,
  1: pvrtc2bppSize,
  2: pvrtc4bppSize,
  3: pvrtc4bppSize,
  6: dxtEtcSmallSize,
  7: dxtEtcSmallSize,
  9: dxtEtcAstcBigSize,
  11: dxtEtcAstcBigSize,
  22: dxtEtcSmallSize,
  23: dxtEtcAstcBigSize,
  24: dxtEtcSmallSize,
  25: dxtEtcSmallSize,
  26: dxtEtcAstcBigSize,
  27: dxtEtcAstcBigSize,
  28: atc5x4Size,
  29: atc5x5Size,
  30: atc6x5Size,
  31: atc6x6Size,
  32: atc8x5Size,
  33: atc8x6Size,
  34: atc8x8Size,
  35: atc10x5Size,
  36: atc10x6Size,
  37: atc10x8Size,
  38: atc10x10Size,
  39: atc12x10Size,
  40: atc12x12Size
};
function isPVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];
  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;
}
function parsePVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];
  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];
  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];
  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];
  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];
  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];
  const width = header[PVR_CONSTANTS.WIDTH_INDEX];
  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];
  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function pvrtc2bppSize(width, height) {
  width = Math.max(width, 16);
  height = Math.max(height, 8);
  return width * height / 4;
}
function pvrtc4bppSize(width, height) {
  width = Math.max(width, 8);
  height = Math.max(height, 8);
  return width * height / 2;
}
function dxtEtcSmallSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
}
function dxtEtcAstcBigSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
}
function atc5x4Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
}
function atc5x5Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
}
function atc6x5Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
}
function atc6x6Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
}
function atc8x5Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
}
function atc8x6Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
}
function atc8x8Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
}
function atc10x5Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
}
function atc10x6Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
}
function atc10x8Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
}
function atc10x10Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
}
function atc12x10Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
}
function atc12x12Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
}

// dist/lib/parsers/parse-compressed-texture.js
function parseCompressedTexture(data) {
  if (isKTX(data)) {
    return parseKTX(data);
  }
  if (isDDS(data)) {
    return parseDDS(data);
  }
  if (isPVR(data)) {
    return parsePVR(data);
  }
  throw new Error("Texture container format not recognized");
}

// dist/compressed-texture-loader.js
var CompressedTextureWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Texture Containers",
  id: "compressed-texture",
  module: "textures",
  version: VERSION,
  worker: true,
  extensions: [
    "ktx",
    "ktx2",
    "dds",
    // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc
    "pvr"
    // WEBGL_compressed_texture_pvrtc
  ],
  mimeTypes: [
    "image/ktx2",
    "image/ktx",
    "image/vnd-ms.dds",
    "image/x-dds",
    "application/octet-stream"
  ],
  binary: true,
  options: {
    "compressed-texture": {
      libraryPath: "libs/",
      useBasis: false
    }
  }
};
var CompressedTextureLoader = {
  ...CompressedTextureWorkerLoader,
  parse: async (arrayBuffer, options) => {
    var _a;
    if ((_a = options == null ? void 0 : options["compressed-texture"]) == null ? void 0 : _a.useBasis) {
      options.basis = {
        format: {
          alpha: "BC3",
          noAlpha: "BC1"
        },
        // @ts-expect-error TODO not allowed to modify inputs
        ...options.basis,
        containerFormat: "ktx2",
        module: "encoder"
      };
      const result = await parseBasis(arrayBuffer, options);
      return result[0];
    }
    return parseCompressedTexture(arrayBuffer);
  }
};

// dist/crunch-loader.js
var CrunchLoader = {
  dataType: null,
  batchType: null,
  id: "crunch",
  name: "Crunch",
  module: "textures",
  version: VERSION,
  worker: true,
  extensions: ["crn"],
  mimeTypes: ["image/crn", "image/x-crn", "application/octet-stream"],
  binary: true,
  options: {
    crunch: {
      libraryPath: "libs/"
    }
  }
};

// dist/lib/parsers/parse-npy.js
var a = new Uint32Array([305419896]);
var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
var isLittleEndian = !(b[0] === 18);
var LITTLE_ENDIAN_OS = isLittleEndian;
var DTYPES = {
  u1: Uint8Array,
  i1: Int8Array,
  u2: Uint16Array,
  i2: Int16Array,
  u4: Uint32Array,
  i4: Int32Array,
  f4: Float32Array,
  f8: Float64Array
};
function parseNPY(arrayBuffer, options) {
  var _a;
  const view = new DataView(arrayBuffer);
  const { header, headerEndOffset } = parseHeader(view);
  const numpyType = header.descr;
  const ArrayType = DTYPES[numpyType.slice(1, 3)];
  if (!ArrayType) {
    throw new Error(`Unimplemented type ${numpyType}`);
  }
  const nArrayElements = (_a = header.shape) == null ? void 0 : _a.reduce((a2, b2) => a2 * b2);
  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;
  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {
    throw new Error("Buffer overflow");
  }
  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));
  if (numpyType[0] === ">" && LITTLE_ENDIAN_OS || numpyType[0] === "<" && !LITTLE_ENDIAN_OS) {
    throw new Error("Incorrect endianness");
  }
  return {
    data,
    header
  };
}
function parseHeader(view) {
  const majorVersion = view.getUint8(6);
  let offset = 8;
  let headerLength;
  if (majorVersion >= 2) {
    headerLength = view.getUint32(offset, true);
    offset += 4;
  } else {
    headerLength = view.getUint16(offset, true);
    offset += 2;
  }
  const encoding = majorVersion <= 2 ? "latin1" : "utf-8";
  const decoder = new TextDecoder(encoding);
  const headerArray = new Uint8Array(view.buffer, offset, headerLength);
  const headerText = decoder.decode(headerArray);
  offset += headerLength;
  const header = JSON.parse(headerText.replace(/'/g, '"').replace("False", "false").replace("(", "[").replace(/,*\),*/g, "]"));
  return { header, headerEndOffset: offset };
}

// dist/npy-loader.js
var NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);
var NPYWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "NPY",
  id: "npy",
  module: "textures",
  version: VERSION,
  worker: true,
  extensions: ["npy"],
  mimeTypes: [],
  tests: [NPY_MAGIC_NUMBER.buffer],
  options: {
    npy: {}
  }
};
var NPYLoader = {
  ...NPYWorkerLoader,
  parseSync: parseNPY,
  parse: async (arrayBuffer, options) => parseNPY(arrayBuffer, options)
};

// dist/lib/parsers/crunch-module-loader.js
var import_loader_utils3 = require("@loaders.gl/loader-utils");
var import_worker_utils2 = require("@loaders.gl/worker-utils");
var CRUNCH_EXTERNAL_LIBRARIES = {
  /** Crunch decoder library. It is used as dynamically imported script */
  DECODER: "crunch.js"
};

// dist/lib/encoders/encode-texture.js
var import_worker_utils3 = require("@loaders.gl/worker-utils");
async function encodeImageURLToCompressedTextureURL(inputUrl, outputUrl, options) {
  const args = [
    // Note: our actual executable is `npx`, so `texture-compressor` is an argument
    "texture-compressor",
    "--type",
    "s3tc",
    "--compression",
    "DXT1",
    "--quality",
    "normal",
    "--input",
    inputUrl,
    "--output",
    outputUrl
  ];
  const childProcess = new import_worker_utils3.ChildProcessProxy();
  await childProcess.start({
    command: "npx",
    arguments: args,
    spawn: options
  });
  return outputUrl;
}

// dist/compressed-texture-writer.js
var CompressedTextureWriter = {
  name: "DDS Texture Container",
  id: "dds",
  module: "textures",
  version: VERSION,
  extensions: ["dds"],
  options: {
    texture: {
      format: "auto",
      compression: "auto",
      quality: "auto",
      mipmap: false,
      flipY: false,
      toolFlags: ""
    }
  },
  encodeURLtoURL: encodeImageURLToCompressedTextureURL,
  encode() {
    throw new Error("Not implemented");
  }
};

// dist/lib/encoders/encode-ktx2-basis-texture.js
async function encodeKTX2BasisTexture(image, options = {}) {
  const { useSRGB = false, qualityLevel = 10, encodeUASTC = false, mipmaps = false } = (options == null ? void 0 : options["ktx2-basis-writer"]) || {};
  const { BasisEncoder } = await loadBasisEncoderModule(options);
  const basisEncoder = new BasisEncoder();
  try {
    const basisFileData = new Uint8Array(image.width * image.height * 4);
    basisEncoder.setCreateKTX2File(true);
    basisEncoder.setKTX2UASTCSupercompression(true);
    basisEncoder.setKTX2SRGBTransferFunc(true);
    basisEncoder.setSliceSourceImage(0, image.data, image.width, image.height, false);
    basisEncoder.setPerceptual(useSRGB);
    basisEncoder.setMipSRGB(useSRGB);
    basisEncoder.setQualityLevel(qualityLevel);
    basisEncoder.setUASTC(encodeUASTC);
    basisEncoder.setMipGen(mipmaps);
    const numOutputBytes = basisEncoder.encode(basisFileData);
    const actualKTX2FileData = basisFileData.subarray(0, numOutputBytes).buffer;
    return actualKTX2FileData;
  } catch (error) {
    console.error("Basis Universal Supercompressed GPU Texture encoder Error: ", error);
    throw error;
  } finally {
    basisEncoder.delete();
  }
}

// dist/ktx2-basis-writer.js
var KTX2BasisWriter = {
  name: "Basis Universal Supercompressed GPU Texture",
  id: "ktx2-basis-writer",
  module: "textures",
  version: VERSION,
  extensions: ["ktx2"],
  options: {
    ["ktx2-basis-writer"]: {
      useSRGB: false,
      qualityLevel: 10,
      encodeUASTC: false,
      mipmaps: false
    }
  },
  encode: encodeKTX2BasisTexture
};

// dist/lib/texture-api/load-image.js
var import_loader_utils5 = require("@loaders.gl/loader-utils");
var import_images = require("@loaders.gl/images");

// dist/lib/texture-api/generate-url.js
var import_loader_utils4 = require("@loaders.gl/loader-utils");
function generateUrl(getUrl, options, urlOptions) {
  let url = typeof getUrl === "function" ? getUrl({ ...options, ...urlOptions }) : getUrl;
  const baseUrl = options.baseUrl;
  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === "/" ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
  }
  return (0, import_loader_utils4.resolvePath)(url);
}

// dist/lib/texture-api/async-deep-map.js
var isObject = (value) => value && typeof value === "object";
async function asyncDeepMap(tree, func, options = {}) {
  return await mapSubtree(tree, func, options);
}
async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }
  if (isObject(object)) {
    return await mapObject(object, func, options);
  }
  const url = object;
  return await func(url, options);
}
async function mapObject(object, func, options) {
  const promises = [];
  const values = {};
  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then((value) => {
      values[key] = value;
    });
    promises.push(promise);
  }
  await Promise.all(promises);
  return values;
}
async function mapArray(urlArray, func, options = {}) {
  const promises = urlArray.map((url) => mapSubtree(url, func, options));
  return await Promise.all(promises);
}

// dist/lib/texture-api/deep-load.js
async function deepLoad(urlTree, load, options) {
  return await asyncDeepMap(urlTree, (url) => shallowLoad(url, load, options));
}
async function shallowLoad(url, load, options) {
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}

// dist/lib/texture-api/load-image.js
async function loadImageTexture(getUrl, options = {}) {
  const imageUrls = await getImageUrls(getUrl, options);
  return await deepLoad(imageUrls, import_images.ImageLoader.parse, options);
}
async function getImageUrls(getUrl, options, urlOptions = {}) {
  const mipLevels = options && options.image && options.image.mipLevels || 0;
  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : generateUrl(getUrl, options, urlOptions);
}
async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];
  if (mipLevels === "auto") {
    const url = generateUrl(getUrl, options, { ...urlOptions, lod: 0 });
    const image = await shallowLoad(url, import_images.ImageLoader.parse, options);
    const { width, height } = (0, import_images.getImageSize)(image);
    mipLevels = getMipLevels({ width, height });
    urls.push(url);
  }
  (0, import_loader_utils5.assert)(mipLevels > 0);
  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = generateUrl(getUrl, options, { ...urlOptions, lod: mipLevel });
    urls.push(url);
  }
  return urls;
}
function getMipLevels(size) {
  return 1 + Math.floor(Math.log2(Math.max(size.width, size.height)));
}

// dist/lib/texture-api/load-image-array.js
var import_images2 = require("@loaders.gl/images");
async function loadImageTextureArray(count, getUrl, options = {}) {
  const imageUrls = await getImageArrayUrls(count, getUrl, options);
  return await deepLoad(imageUrls, import_images2.ImageLoader.parse, options);
}
async function getImageArrayUrls(count, getUrl, options = {}) {
  const promises = [];
  for (let index = 0; index < count; index++) {
    const promise = getImageUrls(getUrl, options, { index });
    promises.push(promise);
  }
  return await Promise.all(promises);
}

// dist/lib/texture-api/load-image-cube.js
var import_images3 = require("@loaders.gl/images");
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
var GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 34070;
var GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 34071;
var GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072;
var GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 34073;
var GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074;
var CUBE_FACES = [
  { face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: "right", axis: "x", sign: "positive" },
  { face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: "left", axis: "x", sign: "negative" },
  { face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: "top", axis: "y", sign: "positive" },
  { face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: "bottom", axis: "y", sign: "negative" },
  { face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: "front", axis: "z", sign: "positive" },
  { face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: "back", axis: "z", sign: "negative" }
];
async function getImageCubeUrls(getUrl, options) {
  const urls = {};
  const promises = [];
  let index = 0;
  for (let i = 0; i < CUBE_FACES.length; ++i) {
    const face = CUBE_FACES[index];
    const promise = getImageUrls(getUrl, options, { ...face, index: index++ }).then((url) => {
      urls[face.face] = url;
    });
    promises.push(promise);
  }
  await Promise.all(promises);
  return urls;
}
async function loadImageTextureCube(getUrl, options = {}) {
  const urls = await getImageCubeUrls(getUrl, options);
  return await deepLoad(urls, import_images3.ImageLoader.parse, options);
}

// dist/index.js
var KTX2BasisWriterWorker = {
  name: "Basis Universal Supercompressed GPU Texture",
  id: "ktx2-basis-writer",
  module: "textures",
  version: VERSION,
  extensions: ["ktx2"],
  worker: true,
  options: {
    useSRGB: false,
    qualityLevel: 10,
    encodeUASTC: false,
    mipmaps: false
  }
};
//# sourceMappingURL=index.cjs.map
