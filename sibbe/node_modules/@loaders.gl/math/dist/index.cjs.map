{
  "version": 3,
  "sources": ["index.js", "geometry/constants.js", "geometry/gl/gl-type.js", "geometry/is-geometry.js", "geometry/iterators/attribute-iterator.js", "geometry/primitives/modes.js", "geometry/iterators/primitive-iterator.js", "geometry/attributes/compute-vertex-normals.js", "geometry/utils/assert.js", "geometry/attributes/get-attribute-from-geometry.js", "geometry/colors/rgb565.js", "geometry/typed-arrays/typed-array-utils.js", "geometry/compression/attribute-compression.js", "geometry/utils/coordinates.js"],
  "sourcesContent": ["export { GL } from \"./geometry/constants.js\";\n// GL support\nexport { GL_TYPE } from \"./geometry/constants.js\";\nexport { default as GLType } from \"./geometry/gl/gl-type.js\";\n// Geometry\nexport { default as isGeometry } from \"./geometry/is-geometry.js\";\n// Iterators\nexport { makeAttributeIterator } from \"./geometry/iterators/attribute-iterator.js\";\nexport { makePrimitiveIterator } from \"./geometry/iterators/primitive-iterator.js\";\n// Helper methods\nexport { computeVertexNormals } from \"./geometry/attributes/compute-vertex-normals.js\";\nexport { encodeRGB565, decodeRGB565 } from \"./geometry/colors/rgb565.js\";\n// Typed array utils\nexport { concatTypedArrays } from \"./geometry/typed-arrays/typed-array-utils.js\";\n// Compression\nexport { octEncodeInRange, octEncode, octEncodeToVector4, octDecodeInRange, octDecode, octDecodeFromVector4, octPackFloat, octEncodeFloat, octDecodeFloat, octPack, octUnpack, compressTextureCoordinates, decompressTextureCoordinates, zigZagDeltaDecode } from \"./geometry/compression/attribute-compression.js\";\nexport { emod } from \"./geometry/utils/coordinates.js\";\n", "// Subset of WebGL constants\nexport const GL_PRIMITIVE = {\n    POINTS: 0x0000, // Points. single points.\n    LINES: 0x0001, // Lines. Each vertex connects to the one after it.\n    TRIANGLES: 0x0004 // Triangles. Each set of three vertices creates a separate triangle.\n};\n// Primitive modes\nexport const GL_PRIMITIVE_MODE = {\n    POINTS: 0x0000, // Points. single points.\n    LINES: 0x0001, // Lines. Each vertex connects to the one after it.\n    LINE_LOOP: 0x0002, // Lines. Each set of two vertices is treated as a separate line segment.\n    LINE_STRIP: 0x0003, // Lines/ a connected group of line segments from the first vertex to the last\n    TRIANGLES: 0x0004, // Triangles. Each set of three vertices creates a separate triangle.\n    TRIANGLE_STRIP: 0x0005, // Triangles. A connected group of triangles.\n    TRIANGLE_FAN: 0x0006 // Triangles. A connected group of triangles.\n    // Each vertex connects to the previous and the first vertex in the fan.\n};\nexport const GL_TYPE = {\n    BYTE: 5120,\n    UNSIGNED_BYTE: 5121,\n    SHORT: 5122,\n    UNSIGNED_SHORT: 5123,\n    INT: 5124,\n    UNSIGNED_INT: 5125,\n    FLOAT: 5126,\n    DOUBLE: 5130\n};\nexport const GL = {\n    ...GL_PRIMITIVE_MODE,\n    ...GL_TYPE\n};\n", "import { GL_TYPE as GL } from \"../constants.js\";\nconst GL_TYPE_TO_ARRAY_TYPE = {\n    [GL.DOUBLE]: Float64Array,\n    [GL.FLOAT]: Float32Array,\n    [GL.UNSIGNED_SHORT]: Uint16Array,\n    [GL.UNSIGNED_INT]: Uint32Array,\n    [GL.UNSIGNED_BYTE]: Uint8Array,\n    [GL.BYTE]: Int8Array,\n    [GL.SHORT]: Int16Array,\n    [GL.INT]: Int32Array\n};\nconst NAME_TO_GL_TYPE = {\n    DOUBLE: GL.DOUBLE,\n    FLOAT: GL.FLOAT,\n    UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n    UNSIGNED_INT: GL.UNSIGNED_INT,\n    UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n    BYTE: GL.BYTE,\n    SHORT: GL.SHORT,\n    INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport default class GLType {\n    // Signature: fromTypedArray(new Uint8Array())\n    // Signature: fromTypedArray(Uint8Array)\n    /**\n     * Returns the size, in bytes, of the corresponding datatype\n     * @param arrayOrType\n     * @returns glType a a string\n     */\n    static fromTypedArray(arrayOrType) {\n        // If typed array, look up constructor\n        arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n        for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n            const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n            if (ArrayType === arrayOrType) {\n                return glType;\n            }\n        }\n        throw new Error(ERR_TYPE_CONVERSION);\n    }\n    /**\n     * Extracts name for glType from array NAME_TO_GL_TYPE\n     * @param name\n     * @returns glType as a number\n     */\n    static fromName(name) {\n        const glType = NAME_TO_GL_TYPE[name];\n        if (!glType) {\n            throw new Error(ERR_TYPE_CONVERSION);\n        }\n        return glType;\n    }\n    // Converts GL constant to corresponding typed array type\n    // eslint-disable-next-line complexity\n    static getArrayType(glType) {\n        switch (glType) {\n            /*eslint-disable*/\n            // @ts-ignore\n            case GL.UNSIGNED_SHORT_5_6_5:\n            // @ts-ignore\n            case GL.UNSIGNED_SHORT_4_4_4_4:\n            // @ts-ignore\n            case GL.UNSIGNED_SHORT_5_5_5_1:\n                /* eslint-enable*/\n                return Uint16Array;\n            default:\n                const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n                if (!ArrayType) {\n                    throw new Error(ERR_TYPE_CONVERSION);\n                }\n                return ArrayType;\n        }\n    }\n    /**\n     * Returns the size in bytes of one element of the provided WebGL type\n     * @param glType\n     * @returns size of glType\n     */\n    static getByteSize(glType) {\n        const ArrayType = GLType.getArrayType(glType);\n        return ArrayType.BYTES_PER_ELEMENT;\n    }\n    /**\n     * Returns `true` if `glType` is a valid WebGL data type.\n     * @param glType\n     * @returns boolean\n     */\n    static validate(glType) {\n        return Boolean(GLType.getArrayType(glType));\n    }\n    /**\n     * Creates a typed view of an array of bytes\n     * @param glType The type of typed array (ArrayBuffer view) to create\n     * @param buffer The buffer storage to use for the view.\n     * @param byteOffset The offset, in bytes, to the first element in the view\n     * @param length The number of elements in the view. Defaults to buffer length\n     * @returns A typed array view of the buffer\n     */\n    static createTypedArray(glType, buffer, byteOffset = 0, length) {\n        if (length === undefined) {\n            length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n        }\n        const ArrayType = GLType.getArrayType(glType);\n        return new ArrayType(buffer, byteOffset, length);\n    }\n}\n", "/**\n * Checking if it is geometry\n * @param geometry\n */\nexport default function isGeometry(geometry) {\n    return (geometry &&\n        typeof geometry === 'object' &&\n        geometry.mode &&\n        geometry.attributes &&\n        typeof geometry.attributes === 'object');\n}\n", "/**\n * Iterates over a single attribute\n * NOTE: For performance, re-yields the same modified element\n * @param param0\n */\nexport function* makeAttributeIterator(values, size) {\n    const ArrayType = values.constructor;\n    const element = new ArrayType(size);\n    for (let i = 0; i < values.length; i += size) {\n        for (let j = 0; j < size; j++) {\n            element[j] = element[i + j];\n        }\n        yield element;\n    }\n}\n", "import { GL } from \"../constants.js\";\n/**\n * Different methods of working with geometries depending on glType\n /**\n\n/**\n * @param mode\n * @returns draw points | lines | triangles\n */\nexport function getPrimitiveModeType(mode) {\n    switch (mode) {\n        case GL.POINTS: // draw single points.\n            return GL.POINTS;\n        case GL.LINES: // draw lines. Each set of two vertices is treated as a separate line segment.\n        case GL.LINE_STRIP: // draw lines. Each vertex connects to the one after it.\n        case GL.LINE_LOOP: // draw a connected group of line segments from the first vertex to the last\n            return GL.LINES;\n        case GL.TRIANGLES:\n        case GL.TRIANGLE_STRIP:\n        case GL.TRIANGLE_FAN: // draw a connected group of triangles.\n            return GL.TRIANGLES;\n        default:\n            throw new Error('Unknown primitive mode');\n    }\n}\n/**\n * @param mode\n * @returns true | false\n */\nexport function isPrimitiveModeExpandable(mode) {\n    switch (mode) {\n        case GL.LINE_STRIP: // draw lines. Each vertex connects to the one after it.\n        case GL.LINE_LOOP: // draw a connected group of line segments from the first vertex to the last\n        case GL.TRIANGLE_STRIP: // draw a connected group of triangles.\n        case GL.TRIANGLE_FAN: // draw a connected group of triangles.\n            return true;\n        default:\n            return false;\n    }\n}\n/**\n * Returns new length depends on glType\n * @param mode\n * @param length\n * @returns new length\n */\nexport function getPrimitiveModeExpandedLength(mode, length) {\n    switch (mode) {\n        case GL.POINTS: // draw single points.\n            return length;\n        case GL.LINES: // draw lines. Each set of two vertices is treated as a separate line segment.\n            return length;\n        case GL.LINE_STRIP: // draw lines. Each vertex connects to the one after it.\n            return length;\n        case GL.LINE_LOOP: // draw a connected group of line segments from the first vertex to the last\n            return length + 1;\n        case GL.TRIANGLES: // draw triangles. Each set of three vertices creates a separate triangle.\n            return length;\n        case GL.TRIANGLE_STRIP: // draw a connected group of triangles.\n        case GL.TRIANGLE_FAN: // draw a connected group of triangles.\n            return (length - 2) * 3;\n        default:\n            throw new Error('Unknown length');\n    }\n}\n", "import { GL } from \"../constants.js\";\nimport { getPrimitiveModeType } from \"../primitives/modes.js\";\nimport { assert } from '@loaders.gl/loader-utils';\n/**\n * Will iterate over each primitive, expanding (dereferencing) indices\n * @param indices\n * @param attributes\n * @param mode\n * @param start\n * @param end\n */\n// eslint-disable-next-line complexity\nexport function* makePrimitiveIterator(indices, attributes = {}, mode, start = 0, end) {\n    // support indices being an object with a values array\n    if (indices) {\n        indices = indices.values || indices.value || indices;\n    }\n    // Autodeduce length from indices\n    if (end === undefined) {\n        end = indices ? indices.length : start;\n    }\n    // iteration info\n    const info = {\n        attributes,\n        type: getPrimitiveModeType(mode),\n        i1: 0,\n        i2: 0,\n        i3: 0\n    };\n    let i = start;\n    // @ts-ignore\n    while (i < end) {\n        switch (mode) {\n            case GL.POINTS: // draw single points.\n                info.i1 = i;\n                i += 1;\n                break;\n            case GL.LINES: // draw lines. Each set of two vertices is treated as a separate line segment.\n                info.i1 = i;\n                info.i2 = i + 1;\n                i += 2;\n                break;\n            case GL.LINE_STRIP: // draw lines. Each vertex connects to the one after it.\n                info.i1 = i;\n                info.i2 = i + 1;\n                i += 1;\n                break;\n            case GL.LINE_LOOP: // draw a connected group of line segments from the first vertex to the last\n                info.i1 = i;\n                info.i2 = i + 1;\n                i += 1;\n                break;\n            case GL.TRIANGLES: // draw triangles. Each set of three vertices creates a separate triangle.\n                info.i1 = i;\n                info.i2 = i + 1;\n                info.i3 = i + 2;\n                i += 3;\n                break;\n            case GL.TRIANGLE_STRIP: // draw a connected group of triangles.\n                info.i1 = i;\n                info.i2 = i + 1;\n                i += 1;\n                break;\n            case GL.TRIANGLE_FAN: // draw a connected group of triangles.\n                info.i1 = 1;\n                info.i2 = i;\n                info.i3 = i + 1;\n                i += 1;\n                break;\n            default:\n                assert(false);\n        }\n        // if indices are present, lookup actual vertices in indices\n        if (indices) {\n            if ('i1' in info) {\n                info.i1 = indices[info.i1];\n                info.i2 = indices[info.i2];\n                info.i3 = indices[info.i3];\n            }\n        }\n        // @ts-ignore\n        yield info;\n    }\n}\n", "import { Vector3 } from '@math.gl/core';\nimport { GL } from \"../constants.js\";\nimport { assert } from \"../utils/assert.js\";\nimport { makePrimitiveIterator } from \"../iterators/primitive-iterator.js\";\nimport { getPrimitiveModeType } from \"../primitives/modes.js\";\nimport { getPositions } from \"./get-attribute-from-geometry.js\";\n/**\n * Computes vertex normals for a geometry\n * @param param0\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function computeVertexNormals(geometry) {\n    // Only support GL.TRIANGLES, GL.TRIANGLE_STRIP, GL.TRIANGLE_FAN\n    assert(getPrimitiveModeType(geometry.mode) === GL.TRIANGLES, 'TRIANGLES required');\n    const { values: positions } = getPositions(geometry);\n    const normals = new Float32Array(positions.length);\n    const vectorA = new Vector3();\n    const vectorB = new Vector3();\n    const vectorC = new Vector3();\n    const vectorCB = new Vector3();\n    const vectorAB = new Vector3();\n    for (const primitive of makePrimitiveIterator(geometry)) {\n        vectorA.fromArray(positions, primitive.i1 * 3);\n        vectorB.fromArray(positions, primitive.i2 * 3 + 3);\n        vectorC.fromArray(positions, primitive.i3 * 3 + 6);\n        vectorCB.subVectors(vectorC, vectorB);\n        vectorAB.subVectors(vectorA, vectorB);\n        const normal = vectorCB.cross(vectorAB);\n        normal.normalize();\n        // @ts-ignore\n        const { primitiveIndex } = primitive;\n        normals[primitiveIndex * 9 + 0] = normal.x;\n        normals[primitiveIndex * 9 + 1] = normal.y;\n        normals[primitiveIndex * 9 + 2] = normal.z;\n        normals[primitiveIndex * 9 + 3] = normal.x;\n        normals[primitiveIndex * 9 + 4] = normal.y;\n        normals[primitiveIndex * 9 + 5] = normal.z;\n        normals[primitiveIndex * 9 + 6] = normal.x;\n        normals[primitiveIndex * 9 + 7] = normal.y;\n        normals[primitiveIndex * 9 + 8] = normal.z;\n    }\n    return normals;\n}\n", "/**\n * Throws error message\n * @param condition checks if an attribute equal to condition\n * @param message error message\n */\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(`math.gl assertion failed. ${message}`);\n    }\n}\n", "import isGeometry from \"../is-geometry.js\";\nimport { assert } from \"../utils/assert.js\";\n/**\n * analyze positions of geometry\n *\n * @param geometry\n * @returns Position| New geometry |assert\n */\nexport function getPositions(geometry) {\n    // If geometry, extract positions\n    if (isGeometry(geometry)) {\n        const { attributes } = geometry;\n        const position = attributes.POSITION || attributes.positions;\n        assert(position);\n        return position;\n    }\n    // If arraybuffer, assume 3 components\n    if (ArrayBuffer.isView(geometry)) {\n        return { values: geometry, size: 3 };\n    }\n    // Else assume accessor object\n    if (geometry) {\n        assert(geometry.values);\n        return geometry;\n    }\n    return assert(false);\n}\n", "/**\n * Decode color values\n * @param rgb565\n * @param target\n * @returns target\n */\nexport function decodeRGB565(rgb565, target = [0, 0, 0]) {\n    const r5 = (rgb565 >> 11) & 31;\n    const g6 = (rgb565 >> 5) & 63;\n    const b5 = rgb565 & 31;\n    target[0] = r5 << 3;\n    target[1] = g6 << 2;\n    target[2] = b5 << 3;\n    return target;\n}\n/**\n * Encode color values\n * @param rgb\n * @returns color\n */\nexport function encodeRGB565(rgb) {\n    const r5 = Math.floor(rgb[0] / 8) + 4;\n    const g6 = Math.floor(rgb[1] / 4) + 2;\n    const b5 = Math.floor(rgb[2] / 8) + 4;\n    return r5 + (g6 << 5) + (b5 << 11);\n}\n", "/**\n * Concats typed arrays\n * @param arrays\n * @returns new Uint8Array\n */\nexport function concatTypedArrays(arrays = []) {\n    let byteLength = 0;\n    for (let i = 0; i < arrays.length; ++i) {\n        byteLength += arrays[i].byteLength;\n    }\n    const buffer = new Uint8Array(byteLength);\n    let byteOffset = 0;\n    for (let i = 0; i < arrays.length; ++i) {\n        const data = new Uint8Array(arrays[i].buffer);\n        byteLength = data.length;\n        for (let j = 0; j < byteLength; ++j) {\n            buffer[byteOffset++] = data[j];\n        }\n    }\n    return buffer;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// Attribute compression and decompression functions.\nimport { Vector2, Vector3, clamp, _MathUtils } from '@math.gl/core';\nimport { assert } from \"../utils/assert.js\";\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\nconst scratchVector2 = new Vector2();\nconst scratchVector3 = new Vector3();\nconst scratchEncodeVector2 = new Vector2();\nconst octEncodeScratch = new Vector2();\nconst uint8ForceArray = new Uint8Array(1);\n/**\n * Force a value to Uint8\n *\n * @param value\n * @returns\n */\nfunction forceUint8(value) {\n    uint8ForceArray[0] = value;\n    return uint8ForceArray[0];\n}\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n *\n * @param value SNORM value in the range [0, rangeMaximum]\n * @param [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nfunction fromSNorm(value, rangeMaximum = 255) {\n    return (clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0;\n}\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum].\n *\n * @param value The scalar value in the range [-1.0, 1.0]\n * @param [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nfunction toSNorm(value, rangeMaximum = 255) {\n    return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to `Math.sign` except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n *\n * @param value The value to return the sign of.\n * @returns The sign of value.\n */\nfunction signNotZero(value) {\n    return value < 0.0 ? -1.0 : 1.0;\n}\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param result The 2 component oct-encoded unit length vector.\n * @param rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns The 2 component oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octDecodeInRange\n */\nexport function octEncodeInRange(vector, rangeMax, result) {\n    assert(vector);\n    assert(result);\n    const vector3 = scratchVector3.from(vector);\n    assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n    result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n    result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n    if (vector.z < 0) {\n        const x = result.x;\n        const y = result.y;\n        result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n        result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n    }\n    result.x = toSNorm(result.x, rangeMax);\n    result.y = toSNorm(result.y, rangeMax);\n    return result;\n}\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param result The 2 byte oct-encoded unit length vector.\n * @returns he 2 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecode\n */\nexport function octEncode(vector, result) {\n    return octEncodeInRange(vector, 255, result);\n}\n/**\n * Encodes a normalized vector into 4-byte vector\n * @param vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param result The 4 byte oct-encoded unit length vector.\n * @returns The 4 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecodeFromVector4\n */\nexport function octEncodeToVector4(vector, result) {\n    octEncodeInRange(vector, 65535, octEncodeScratch);\n    result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n    result.y = forceUint8(octEncodeScratch.x);\n    result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n    result.w = forceUint8(octEncodeScratch.y);\n    return result;\n}\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param x The x component of the oct-encoded unit length vector.\n * @param y The y component of the oct-encoded unit length vector.\n * @param rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param result The decoded and normalized vector\n * @returns The decoded and normalized vector.\n *\n * @exception x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see octEncodeInRange\n */\nexport function octDecodeInRange(x, y, rangeMax, result) {\n    assert(result);\n    if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n        throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);\n    }\n    result.x = fromSNorm(x, rangeMax);\n    result.y = fromSNorm(y, rangeMax);\n    result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n    if (result.z < 0.0) {\n        const oldVX = result.x;\n        result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n        result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n    }\n    return result.normalize();\n}\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param x The x component of the oct-encoded unit length vector.\n * @param y The y component of the oct-encoded unit length vector.\n * @param result The decoded and normalized vector.\n * @returns he decoded and normalized vector.\n *\n * @exception x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see octDecodeInRange\n */\nexport function octDecode(x, y, result) {\n    return octDecodeInRange(x, y, 255, result);\n}\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param encoded The oct-encoded unit length vector.\n * @param esult The decoded and normalized vector.\n * @returns The decoded and normalized vector.\n *\n * @exception x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see octDecodeInRange\n * @see octEncodeToVector4\n */\nexport function octDecodeFromVector4(encoded, result) {\n    assert(encoded);\n    assert(result);\n    const x = encoded.x;\n    const y = encoded.y;\n    const z = encoded.z;\n    const w = encoded.w;\n    if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n        throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n    }\n    const xOct16 = x * LEFT_SHIFT + y;\n    const yOct16 = z * LEFT_SHIFT + w;\n    return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param encoded The oct encoded vector.\n * @returns The oct encoded vector packed into a single float.\n *\n */\nexport function octPackFloat(encoded) {\n    const vector2 = scratchVector2.from(encoded);\n    return 256.0 * vector2.x + vector2.y;\n}\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns The 2 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n */\nexport function octEncodeFloat(vector) {\n    octEncode(vector, scratchEncodeVector2);\n    return octPackFloat(scratchEncodeVector2);\n}\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param value The oct-encoded unit length vector stored as a single floating-point number.\n * @param result The decoded and normalized vector\n * @returns The decoded and normalized vector.\n *\n */\nexport function octDecodeFloat(value, result) {\n    assert(Number.isFinite(value));\n    const temp = value / 256.0;\n    const x = Math.floor(temp);\n    const y = (temp - x) * 256.0;\n    return octDecode(x, y, result);\n}\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param v1 A normalized vector to be compressed.\n * @param v2 A normalized vector to be compressed.\n * @param v3 A normalized vector to be compressed.\n * @param result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nexport function octPack(v1, v2, v3, result) {\n    assert(v1);\n    assert(v2);\n    assert(v3);\n    assert(result);\n    const encoded1 = octEncodeFloat(v1);\n    const encoded2 = octEncodeFloat(v2);\n    const encoded3 = octEncode(v3, scratchEncodeVector2);\n    result.x = 65536.0 * encoded3.x + encoded1;\n    result.y = 65536.0 * encoded3.y + encoded2;\n    return result;\n}\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param v1 One decoded and normalized vector.\n * @param v2 One decoded and normalized vector.\n * @param v3 One decoded and normalized vector.\n */\nexport function octUnpack(packed, v1, v2, v3) {\n    let temp = packed.x / 65536.0;\n    const x = Math.floor(temp);\n    const encodedFloat1 = (temp - x) * 65536.0;\n    temp = packed.y / 65536.0;\n    const y = Math.floor(temp);\n    const encodedFloat2 = (temp - y) * 65536.0;\n    octDecodeFloat(encodedFloat1, v1);\n    octDecodeFloat(encodedFloat2, v2);\n    octDecode(x, y, v3);\n}\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns The packed texture coordinates.\n *\n */\nexport function compressTextureCoordinates(textureCoordinates) {\n    // Move x and y to the range 0-4095;\n    const x = (textureCoordinates.x * 4095.0) | 0;\n    const y = (textureCoordinates.y * 4095.0) | 0;\n    return 4096.0 * x + y;\n}\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param compressed The compressed texture coordinates.\n * @param result The decompressed texture coordinates.\n * @returns The modified result parameter.\n *\n */\nexport function decompressTextureCoordinates(compressed, result) {\n    const temp = compressed / 4096.0;\n    const xZeroTo4095 = Math.floor(temp);\n    result.x = xZeroTo4095 / 4095.0;\n    result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n    return result;\n}\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param uBuffer The buffer view of u values.\n * @param vBuffer The buffer view of v values.\n * @param [heightBuffer] The buffer view of height values.\n *\n * @link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format\n */\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n    assert(uBuffer);\n    assert(vBuffer);\n    assert(uBuffer.length === vBuffer.length);\n    if (heightBuffer) {\n        assert(uBuffer.length === heightBuffer.length);\n    }\n    function zigZagDecode(value) {\n        return (value >> 1) ^ -(value & 1);\n    }\n    let u = 0;\n    let v = 0;\n    let height = 0;\n    for (let i = 0; i < uBuffer.length; ++i) {\n        u += zigZagDecode(uBuffer[i]);\n        v += zigZagDecode(vBuffer[i]);\n        uBuffer[i] = u;\n        vBuffer[i] = v;\n        if (heightBuffer) {\n            height += zigZagDecode(heightBuffer[i]);\n            heightBuffer[i] = height;\n        }\n    }\n}\n", "/**\n * Handle UVs if they are out of range [0,1].\n * @param n\n */\nexport function emod(n) {\n    return ((n % 1) + 1) % 1;\n}\n"],
  "mappings": "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",
  "names": ["assert", "assert", "assert", "import_core", "assert"]
}
