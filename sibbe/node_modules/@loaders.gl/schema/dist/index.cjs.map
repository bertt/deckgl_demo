{
  "version": 3,
  "sources": ["index.js", "lib/table/batches/base-table-batch-aggregator.js", "lib/table/simple-table/row-utils.js", "lib/table/batches/row-table-batch-aggregator.js", "lib/table/batches/columnar-table-batch-aggregator.js", "lib/table/batches/table-batch-builder.js", "lib/table/simple-table/table-accessors.js", "lib/table/arrow-api/arrow-like-field.js", "lib/table/arrow-api/arrow-like-schema.js", "lib/table/simple-table/data-type.js", "lib/table/simple-table/table-schema.js", "lib/table/arrow-api/arrow-like-table.js", "lib/table/simple-table/make-table.js", "lib/table/simple-table/make-table-from-batches.js", "lib/table/simple-table/table-column.js", "lib/table/simple-table/convert-table.js", "lib/mesh/mesh-utils.js", "lib/mesh/deduce-mesh-schema.js", "lib/table/arrow-api/enum.js", "lib/table/arrow-api/arrow-like-type.js", "lib/table/arrow-api/get-type-info.js", "lib/utils/async-queue.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TABLE CATEGORY UTILS\nexport { TableBatchBuilder } from \"./lib/table/batches/table-batch-builder.js\";\nexport { RowTableBatchAggregator } from \"./lib/table/batches/row-table-batch-aggregator.js\";\nexport { ColumnarTableBatchAggregator } from \"./lib/table/batches/columnar-table-batch-aggregator.js\";\nexport { isTable, getTableLength, getTableNumCols, getTableCell, getTableRowShape, getTableColumnIndex, getTableColumnName, getTableRowAsObject, getTableRowAsArray, makeRowIterator, makeArrayRowIterator, makeObjectRowIterator } from \"./lib/table/simple-table/table-accessors.js\";\nexport { ArrowLikeTable } from \"./lib/table/arrow-api/arrow-like-table.js\";\nexport { makeTableFromData } from \"./lib/table/simple-table/make-table.js\";\nexport { makeTableFromBatches, makeBatchFromTable } from \"./lib/table/simple-table/make-table-from-batches.js\";\nexport { convertTable } from \"./lib/table/simple-table/convert-table.js\";\nexport { deduceTableSchema } from \"./lib/table/simple-table/table-schema.js\";\nexport { convertToObjectRow, convertToArrayRow } from \"./lib/table/simple-table/row-utils.js\";\nexport { getDataTypeFromArray } from \"./lib/table/simple-table/data-type.js\";\nexport { getMeshSize, getMeshBoundingBox } from \"./lib/mesh/mesh-utils.js\";\n// Commented out due to https://github.com/visgl/deck.gl/issues/6906 and https://github.com/visgl/loaders.gl/issues/2177\n// export {convertMesh} from './category/mesh/convert-mesh';\nexport { deduceMeshSchema, deduceMeshField, makeMeshAttributeMetadata } from \"./lib/mesh/deduce-mesh-schema.js\";\n// SCHEMA\nexport { Schema as ArrowLikeSchema, Field as ArrowLikeField, DataType as ArrowLikeDataType, Null, Binary, Bool, Int, Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float, Float16, Float32, Float64, Utf8, Date, DateDay, DateMillisecond, Time, TimeMillisecond, TimeSecond, Timestamp, TimestampSecond, TimestampMillisecond, TimestampMicrosecond, TimestampNanosecond, Interval, IntervalDayTime, IntervalYearMonth, FixedSizeList, Struct } from \"./lib/table/arrow-api/index.js\";\n// EXPERIMENTAL APIs\n// SCHEMA UTILS\nexport { getTypeInfo } from \"./lib/table/arrow-api/get-type-info.js\";\nexport { default as AsyncQueue } from \"./lib/utils/async-queue.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class BaseTableBatchAggregator {\n    schema;\n    options;\n    shape;\n    length = 0;\n    rows = null;\n    cursor = 0;\n    _headers = [];\n    constructor(schema, options) {\n        this.options = options;\n        this.schema = schema;\n        // schema is an array if there're no headers\n        // object if there are headers\n        if (!Array.isArray(schema)) {\n            this._headers = [];\n            for (const key in schema) {\n                this._headers[schema[key].index] = schema[key].name;\n            }\n        }\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        this.shape = 'array-row-table';\n        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n        this.rows[this.length] = row;\n        this.length++;\n    }\n    addObjectRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        this.shape = 'object-row-table';\n        this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n        this.rows[this.length] = row;\n        this.length++;\n    }\n    getBatch() {\n        let rows = this.rows;\n        if (!rows) {\n            return null;\n        }\n        rows = rows.slice(0, this.length);\n        this.rows = null;\n        const batch = {\n            shape: this.shape || 'array-row-table',\n            batchType: 'data',\n            data: rows,\n            length: this.length,\n            schema: this.schema,\n            cursor: this.cursor\n        };\n        return batch;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Convert an object row to an array row */\nexport function convertToObjectRow(arrayRow, headers) {\n    if (!arrayRow) {\n        throw new Error('null row');\n    }\n    const objectRow = {};\n    if (headers) {\n        for (let i = 0; i < headers.length; i++) {\n            objectRow[headers[i]] = arrayRow[i];\n        }\n    }\n    else {\n        for (let i = 0; i < arrayRow.length; i++) {\n            const columnName = `column-${i}`;\n            objectRow[columnName] = arrayRow[i];\n        }\n    }\n    return objectRow;\n}\n/** Convert an object row to an array row */\nexport function convertToArrayRow(objectRow, headers) {\n    if (!objectRow) {\n        throw new Error('null row');\n    }\n    if (headers) {\n        const arrayRow = new Array(headers.length);\n        for (let i = 0; i < headers.length; i++) {\n            arrayRow[i] = objectRow[headers[i]];\n        }\n        return arrayRow;\n    }\n    return Object.values(objectRow);\n}\n/** Get headers from a sample array row */\nexport function inferHeadersFromArrayRow(arrayRow) {\n    const headers = [];\n    for (let i = 0; i < arrayRow.length; i++) {\n        const columnName = `column-${i}`;\n        headers.push(columnName);\n    }\n    return headers;\n}\n/** Get headers from a smaple object row */\nexport function inferHeadersFromObjectRow(row) {\n    return Object.keys(row);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { convertToArrayRow, convertToObjectRow, inferHeadersFromArrayRow, inferHeadersFromObjectRow } from \"../simple-table/row-utils.js\";\nconst DEFAULT_ROW_COUNT = 100;\nexport class RowTableBatchAggregator {\n    schema;\n    options;\n    length = 0;\n    objectRows = null;\n    arrayRows = null;\n    cursor = 0;\n    _headers = null;\n    constructor(schema, options) {\n        this.options = options;\n        this.schema = schema;\n        // schema is an array if there're no headers\n        // object if there are headers\n        if (schema) {\n            this._headers = [];\n            for (const key in schema) {\n                this._headers[schema[key].index] = schema[key].name;\n            }\n        }\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        // TODO - infer schema at a higher level, instead of hacking headers here?\n        this._headers ||= inferHeadersFromArrayRow(row);\n        // eslint-disable-next-line default-case\n        switch (this.options.shape) {\n            case 'object-row-table':\n                const rowObject = convertToObjectRow(row, this._headers);\n                this.addObjectRow(rowObject, cursor);\n                break;\n            case 'array-row-table':\n                this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n                this.arrayRows[this.length] = row;\n                this.length++;\n                break;\n        }\n    }\n    addObjectRow(row, cursor) {\n        if (Number.isFinite(cursor)) {\n            this.cursor = cursor;\n        }\n        // TODO - infer schema at a higher level, instead of hacking headers here?\n        this._headers ||= inferHeadersFromObjectRow(row);\n        // eslint-disable-next-line default-case\n        switch (this.options.shape) {\n            case 'array-row-table':\n                const rowArray = convertToArrayRow(row, this._headers);\n                this.addArrayRow(rowArray, cursor);\n                break;\n            case 'object-row-table':\n                this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n                this.objectRows[this.length] = row;\n                this.length++;\n                break;\n        }\n    }\n    getBatch() {\n        let rows = this.arrayRows || this.objectRows;\n        if (!rows) {\n            return null;\n        }\n        rows = rows.slice(0, this.length);\n        this.arrayRows = null;\n        this.objectRows = null;\n        return {\n            shape: this.options.shape,\n            batchType: 'data',\n            data: rows,\n            length: this.length,\n            // @ts-expect-error we should infer a schema\n            schema: this.schema,\n            cursor: this.cursor\n        };\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_ROW_COUNT = 100;\nexport class ColumnarTableBatchAggregator {\n    schema;\n    length = 0;\n    allocated = 0;\n    columns = {};\n    constructor(schema, options) {\n        this.schema = schema;\n        this._reallocateColumns();\n    }\n    rowCount() {\n        return this.length;\n    }\n    addArrayRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        let i = 0;\n        // TODO what if no csv header, columns not populated?\n        for (const fieldName in this.columns) {\n            this.columns[fieldName][this.length] = row[i++];\n        }\n        this.length++;\n    }\n    addObjectRow(row) {\n        // If user keeps pushing rows beyond batch size, reallocate\n        this._reallocateColumns();\n        for (const fieldName in row) {\n            this.columns[fieldName][this.length] = row[fieldName];\n        }\n        this.length++;\n    }\n    getBatch() {\n        this._pruneColumns();\n        const columns = Array.isArray(this.schema) ? this.columns : {};\n        // schema is an array if there're no headers\n        // object if there are headers\n        // columns should match schema format\n        if (!Array.isArray(this.schema)) {\n            for (const fieldName in this.schema) {\n                const field = this.schema[fieldName];\n                columns[field.name] = this.columns[field.index];\n            }\n        }\n        this.columns = {};\n        const batch = {\n            shape: 'columnar-table',\n            batchType: 'data',\n            data: columns,\n            schema: this.schema,\n            length: this.length\n        };\n        return batch;\n    }\n    // HELPERS\n    _reallocateColumns() {\n        if (this.length < this.allocated) {\n            return;\n        }\n        // @ts-ignore TODO\n        this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n        this.columns = {};\n        for (const fieldName in this.schema) {\n            const field = this.schema[fieldName];\n            const ArrayType = field.type || Float32Array;\n            const oldColumn = this.columns[field.index];\n            if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n                // Copy the old data to the new array\n                const typedArray = new ArrayType(this.allocated);\n                typedArray.set(oldColumn);\n                this.columns[field.index] = typedArray;\n            }\n            else if (oldColumn) {\n                // Plain array\n                oldColumn.length = this.allocated;\n                this.columns[field.index] = oldColumn;\n            }\n            else {\n                // Create new\n                this.columns[field.index] = new ArrayType(this.allocated);\n            }\n        }\n    }\n    _pruneColumns() {\n        for (const [columnName, column] of Object.entries(this.columns)) {\n            this.columns[columnName] = column.slice(0, this.length);\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BaseTableBatchAggregator } from \"./base-table-batch-aggregator.js\";\nimport { RowTableBatchAggregator } from \"./row-table-batch-aggregator.js\";\nimport { ColumnarTableBatchAggregator } from \"./columnar-table-batch-aggregator.js\";\nconst DEFAULT_OPTIONS = {\n    shape: undefined,\n    batchSize: 'auto',\n    batchDebounceMs: 0,\n    limit: 0,\n    _limitMB: 0\n};\nconst ERR_MESSAGE = 'TableBatchBuilder';\n/** Incrementally builds batches from a stream of rows */\nexport class TableBatchBuilder {\n    schema;\n    options;\n    aggregator = null;\n    batchCount = 0;\n    bytesUsed = 0;\n    isChunkComplete = false;\n    lastBatchEmittedMs = Date.now();\n    totalLength = 0;\n    totalBytes = 0;\n    rowBytes = 0;\n    static ArrowBatch;\n    constructor(schema, options) {\n        this.schema = schema;\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n    }\n    limitReached() {\n        if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n            return true;\n        }\n        if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n            return true;\n        }\n        return false;\n    }\n    /** @deprecated Use addArrayRow or addObjectRow */\n    addRow(row) {\n        if (this.limitReached()) {\n            return;\n        }\n        this.totalLength++;\n        this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n        this.totalBytes += this.rowBytes;\n        if (Array.isArray(row)) {\n            this.addArrayRow(row);\n        }\n        else {\n            this.addObjectRow(row);\n        }\n    }\n    /** Add one row to the batch */\n    addArrayRow(row) {\n        if (!this.aggregator) {\n            const TableBatchType = this._getTableBatchType();\n            this.aggregator = new TableBatchType(this.schema, this.options);\n        }\n        this.aggregator.addArrayRow(row);\n    }\n    /** Add one row to the batch */\n    addObjectRow(row) {\n        if (!this.aggregator) {\n            const TableBatchType = this._getTableBatchType();\n            this.aggregator = new TableBatchType(this.schema, this.options);\n        }\n        this.aggregator.addObjectRow(row);\n    }\n    /** Mark an incoming raw memory chunk has completed */\n    chunkComplete(chunk) {\n        if (chunk instanceof ArrayBuffer) {\n            this.bytesUsed += chunk.byteLength;\n        }\n        if (typeof chunk === 'string') {\n            this.bytesUsed += chunk.length;\n        }\n        this.isChunkComplete = true;\n    }\n    getFullBatch(options) {\n        return this._isFull() ? this._getBatch(options) : null;\n    }\n    getFinalBatch(options) {\n        return this._getBatch(options);\n    }\n    // INTERNAL\n    _estimateRowMB(row) {\n        return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n    }\n    _isFull() {\n        // No batch, not ready\n        if (!this.aggregator || this.aggregator.rowCount() === 0) {\n            return false;\n        }\n        // if batchSize === 'auto' we wait for chunk to complete\n        // if batchSize === number, ensure we have enough rows\n        if (this.options.batchSize === 'auto') {\n            if (!this.isChunkComplete) {\n                return false;\n            }\n        }\n        else if (this.options.batchSize > this.aggregator.rowCount()) {\n            return false;\n        }\n        // Debounce batches\n        if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n            return false;\n        }\n        // Emit batch\n        this.isChunkComplete = false;\n        this.lastBatchEmittedMs = Date.now();\n        return true;\n    }\n    /**\n     * bytesUsed can be set via chunkComplete or via getBatch*\n     */\n    _getBatch(options) {\n        if (!this.aggregator) {\n            return null;\n        }\n        // TODO - this can overly increment bytes used?\n        if (options?.bytesUsed) {\n            this.bytesUsed = options.bytesUsed;\n        }\n        const normalizedBatch = this.aggregator.getBatch();\n        normalizedBatch.count = this.batchCount;\n        normalizedBatch.bytesUsed = this.bytesUsed;\n        Object.assign(normalizedBatch, options);\n        this.batchCount++;\n        this.aggregator = null;\n        return normalizedBatch;\n    }\n    _getTableBatchType() {\n        switch (this.options.shape) {\n            case 'array-row-table':\n            case 'object-row-table':\n                return RowTableBatchAggregator;\n            case 'columnar-table':\n                return ColumnarTableBatchAggregator;\n            case 'arrow-table':\n                if (!TableBatchBuilder.ArrowBatch) {\n                    throw new Error(ERR_MESSAGE);\n                }\n                return TableBatchBuilder.ArrowBatch;\n            default:\n                return BaseTableBatchAggregator;\n        }\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport function isTable(table) {\n    const shape = typeof table === 'object' && table?.shape;\n    switch (shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return Array.isArray(table.data);\n        case 'geojson-table':\n            return Array.isArray(table.features);\n        case 'columnar-table':\n            return table.data && typeof table.data === 'object';\n        case 'arrow-table':\n            return Boolean(table?.data?.numRows !== undefined);\n        default:\n            return false;\n    }\n}\n/**\n * Returns the length of the table (i.e. the number of rows)\n */\nexport function getTableLength(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.data.length;\n        case 'geojson-table':\n            return table.features.length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numRows;\n        case 'columnar-table':\n            for (const column of Object.values(table.data)) {\n                return column.length || 0;\n            }\n            return 0;\n        default:\n            throw new Error('table');\n    }\n}\n/**\n * Returns the number of columns in the table\n * @throws Fails to deduce number of columns if the table has no schema and is empty\n */\nexport function getTableNumCols(table) {\n    if (table.schema) {\n        return table.schema.fields.length;\n    }\n    if (getTableLength(table) === 0) {\n        throw new Error('empty table');\n    }\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[0].length;\n        case 'object-row-table':\n            return Object.keys(table.data[0]).length;\n        case 'geojson-table':\n            return Object.keys(table.features[0]).length;\n        case 'columnar-table':\n            return Object.keys(table.data).length;\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.numCols;\n        default:\n            throw new Error('table');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCell(table, rowIndex, columnName) {\n    switch (table.shape) {\n        case 'array-row-table':\n            const columnIndex = getTableColumnIndex(table, columnName);\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            return table.data[rowIndex][columnName];\n        case 'geojson-table':\n            return table.features[rowIndex][columnName];\n        case 'columnar-table':\n            const column = table.data[columnName];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrowColumnIndex = arrowTable.schema.fields.findIndex((field) => field.name === columnName);\n            return arrowTable.getChildAt(arrowColumnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Get a table cell value at row index and column name */\nexport function getTableCellAt(table, rowIndex, columnIndex) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return table.data[rowIndex][columnIndex];\n        case 'object-row-table':\n            const columnName1 = getTableColumnName(table, columnIndex);\n            return table.data[rowIndex][columnName1];\n        case 'geojson-table':\n            const columnName2 = getTableColumnName(table, columnIndex);\n            return table.features[rowIndex][columnName2];\n        case 'columnar-table':\n            const columnName3 = getTableColumnName(table, columnIndex);\n            const column = table.data[columnName3];\n            return column[rowIndex];\n        case 'arrow-table':\n            const arrowTable = table.data;\n            return arrowTable.getChildAt(columnIndex)?.get(rowIndex);\n        default:\n            throw new Error('todo');\n    }\n}\n/** Deduce the table row shape */\nexport function getTableRowShape(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return table.shape;\n        case 'geojson-table':\n            // TODO - this is not correct, geojson-table is not a row table\n            return 'object-row-table';\n        case 'columnar-table':\n        default:\n            throw new Error('Not a row table');\n    }\n}\n/** Get the index of a named table column. Requires the table to have a schema */\nexport function getTableColumnIndex(table, columnName) {\n    const columnIndex = table.schema?.fields.findIndex((field) => field.name === columnName);\n    if (columnIndex === undefined) {\n        throw new Error(columnName);\n    }\n    return columnIndex;\n}\n/** Get the name of a table column by index. Requires the table to have a schema */\nexport function getTableColumnName(table, columnIndex) {\n    const columnName = table.schema?.fields[columnIndex]?.name;\n    if (!columnName) {\n        throw new Error(`${columnIndex}`);\n    }\n    return columnName;\n}\n/**\n * Returns one row of the table in object format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsObject(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'object-row-table':\n            return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];\n        case 'array-row-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.data[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'geojson-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] = table.features[rowIndex][i];\n                }\n                return objectRow;\n            }\n            throw new Error('no schema');\n        case 'columnar-table':\n            if (table.schema) {\n                const objectRow = target || {};\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    objectRow[table.schema.fields[i].name] =\n                        table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return objectRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const objectRow = target || {};\n                for (const [name, column] of Object.entries(table.data)) {\n                    objectRow[name] = column[rowIndex];\n                }\n                return objectRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const objectRow = target || {};\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                objectRow[schema.fields[i].name] = row?.[schema.fields[i].name];\n            }\n            return objectRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/**\n * Returns one row of the table in array format.\n * @param target Optional parameter will be used if needed to store the row. Can be reused between calls to improve performance.\n * @returns an array representing the row. May be the original array in the row, a new object, or the target parameter\n */\n// eslint-disable-next-line complexity\nexport function getTableRowAsArray(table, rowIndex, target, copy) {\n    switch (table.shape) {\n        case 'array-row-table':\n            return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];\n        case 'object-row-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.data[rowIndex]);\n        case 'geojson-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                // TODO - should lift properties to top level\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.features[rowIndex][table.schema.fields[i].name];\n                }\n                return arrayRow;\n            }\n            // Warning: just slap on the values, this risks mismatches between rows\n            return Object.values(table.features[rowIndex]);\n        case 'columnar-table':\n            if (table.schema) {\n                const arrayRow = target || [];\n                for (let i = 0; i < table.schema.fields.length; i++) {\n                    arrayRow[i] = table.data[table.schema.fields[i].name][rowIndex];\n                }\n                return arrayRow;\n            }\n            else {\n                // eslint-disable-line no-else-return\n                const arrayRow = target || [];\n                let i = 0;\n                for (const column of Object.values(table.data)) {\n                    arrayRow[i] = column[rowIndex];\n                    i++;\n                }\n                return arrayRow;\n            }\n        case 'arrow-table':\n            const arrowTable = table.data;\n            const arrayRow = target || [];\n            const row = arrowTable.get(rowIndex);\n            const schema = arrowTable.schema;\n            for (let i = 0; i < schema.fields.length; i++) {\n                arrayRow[i] = row?.[schema.fields[i].name];\n            }\n            return arrayRow;\n        default:\n            throw new Error('shape');\n    }\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n    if (table.shape === 'array-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsArray(table, rowIndex);\n    }\n    return {\n        shape: 'array-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeColumnarTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n// Row Iterators\n/**\n * Iterate over table rows\n * @param table\n * @param shape\n */\nexport function* makeRowIterator(table, shape) {\n    switch (shape) {\n        case 'array-row-table':\n            yield* makeArrayRowIterator(table);\n            break;\n        case 'object-row-table':\n            yield* makeObjectRowIterator(table);\n            break;\n        default:\n            throw new Error(`Unknown row type ${shape}`);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding array rows\n * @param table\n * @param shape\n */\nexport function* makeArrayRowIterator(table, target = []) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsArray(table, rowIndex, target);\n    }\n}\n/**\n * Streaming processing: Iterate over table, yielding object rows\n * @param table\n * @param shape\n */\nexport function* makeObjectRowIterator(table, target = {}) {\n    const length = getTableLength(table);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        yield getTableRowAsObject(table, rowIndex, target);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport class ArrowLikeField {\n    name;\n    type;\n    nullable;\n    metadata;\n    constructor(name, type, nullable = false, metadata = new Map()) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata;\n    }\n    get typeId() {\n        return this.type && this.type.typeId;\n    }\n    clone() {\n        return new ArrowLikeField(this.name, this.type, this.nullable, this.metadata);\n    }\n    compareTo(other) {\n        return (this.name === other.name &&\n            this.type === other.type &&\n            this.nullable === other.nullable &&\n            this.metadata === other.metadata);\n    }\n    toString() {\n        return `${JSON.stringify(this.type)}${this.nullable ? ', nullable' : ''}${this.metadata ? `, metadata: ${JSON.stringify(this.metadata)}` : ''}`;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ArrowLikeField } from \"./arrow-like-field.js\";\nexport class ArrowLikeSchema {\n    fields;\n    metadata;\n    constructor(fields, metadata = new Map()) {\n        // checkNames(fields);\n        // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n        this.fields = fields.map((field) => new ArrowLikeField(field.name, field.type, field.nullable, field.metadata));\n        this.metadata =\n            metadata instanceof Map ? metadata : new Map(Object.entries(metadata));\n    }\n    // TODO - arrow only seems to compare fields, not metadata\n    compareTo(other) {\n        if (this.metadata !== other.metadata) {\n            return false;\n        }\n        if (this.fields.length !== other.fields.length) {\n            return false;\n        }\n        for (let i = 0; i < this.fields.length; ++i) {\n            if (!this.fields[i].compareTo(other.fields[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    select(...columnNames) {\n        // Ensure column names reference valid fields\n        const nameMap = Object.create(null);\n        for (const name of columnNames) {\n            nameMap[name] = true;\n        }\n        const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n        return new ArrowLikeSchema(selectedFields, this.metadata);\n    }\n    selectAt(...columnIndices) {\n        // Ensure column indices reference valid fields\n        const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n        return new ArrowLikeSchema(selectedFields, this.metadata);\n    }\n    assign(schemaOrFields) {\n        let fields;\n        let metadata = this.metadata;\n        if (schemaOrFields instanceof ArrowLikeSchema) {\n            const otherArrowLikeSchema = schemaOrFields;\n            fields = otherArrowLikeSchema.fields;\n            metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherArrowLikeSchema.metadata);\n        }\n        else {\n            fields = schemaOrFields;\n        }\n        // Create a merged list of fields, overwrite fields in place, new fields at end\n        const fieldMap = Object.create(null);\n        for (const field of this.fields) {\n            fieldMap[field.name] = field;\n        }\n        for (const field of fields) {\n            fieldMap[field.name] = field;\n        }\n        const mergedFields = Object.values(fieldMap);\n        return new ArrowLikeSchema(mergedFields, metadata);\n    }\n}\n// Warn if any duplicated field names\n// function checkNames(fields: Field[]): void {\n//   const usedNames: Record<string, boolean> = {};\n//   for (const field of fields) {\n//     if (usedNames[field.name]) {\n//       // eslint-disable-next-line\n//       console.warn('ArrowLikeSchema: duplicated field name', field.name, field);\n//     }\n//     usedNames[field.name] = true;\n//   }\n// }\nfunction mergeMaps(m1, m2) {\n    // @ts-ignore\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Deduce column types from values */\nexport function getDataTypeFromValue(value, defaultNumberType = 'float32') {\n    if (value instanceof Date) {\n        return 'date-millisecond';\n    }\n    if (value instanceof Number) {\n        return defaultNumberType;\n    }\n    if (typeof value === 'string') {\n        return 'utf8';\n    }\n    if (value === null || value === 'undefined') {\n        return 'null';\n    }\n    return 'null';\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromArray(array) {\n    let type = getDataTypeFromTypedArray(array);\n    if (type !== 'null') {\n        return { type, nullable: false };\n    }\n    if (array.length > 0) {\n        type = getDataTypeFromValue(array[0]);\n        return { type, nullable: true };\n    }\n    return { type: 'null', nullable: true };\n}\n/**\n * Deduces a simple data type \"descriptor from a typed array instance\n */\nexport function getDataTypeFromTypedArray(array) {\n    switch (array.constructor) {\n        case Int8Array:\n            return 'int8';\n        case Uint8Array:\n        case Uint8ClampedArray:\n            return 'uint8';\n        case Int16Array:\n            return 'int16';\n        case Uint16Array:\n            return 'uint16';\n        case Int32Array:\n            return 'int32';\n        case Uint32Array:\n            return 'uint32';\n        case Float32Array:\n            return 'float32';\n        case Float64Array:\n            return 'float64';\n        default:\n            return 'null';\n    }\n}\nexport function getArrayTypeFromDataType(type, nullable) {\n    if (!nullable) {\n        switch (type) {\n            case 'int8':\n                return Int8Array;\n            case 'uint8':\n                return Uint8Array;\n            case 'int16':\n                return Int16Array;\n            case 'uint16':\n                return Uint16Array;\n            case 'int32':\n                return Int32Array;\n            case 'uint32':\n                return Uint32Array;\n            case 'float32':\n                return Float32Array;\n            case 'float64':\n                return Float64Array;\n            default:\n                break;\n        }\n    }\n    // if (typeof BigInt64Array !== 'undefined') {\n    //   TYPED_ARRAY_TO_TYPE.BigInt64Array = new Int64();\n    //   TYPED_ARRAY_TO_TYPE.BigUint64Array = new Uint64();\n    // }\n    return Array;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromArray, getDataTypeFromValue } from \"./data-type.js\";\n/**\n * SCHEMA SUPPORT - AUTODEDUCTION\n * @param {*} table\n * @param {*} schema\n * @returns\n */\nexport function deduceTableSchema(table) {\n    switch (table.shape) {\n        case 'array-row-table':\n        case 'object-row-table':\n            return deduceSchemaFromRows(table.data);\n        case 'columnar-table':\n            return deduceSchemaFromColumns(table.data);\n        case 'arrow-table':\n        default:\n            throw new Error('Deduce schema');\n    }\n}\nexport function deduceSchema(data) {\n    return Array.isArray(data) ? deduceSchemaFromRows(data) : deduceSchemaFromColumns(data);\n}\n/** Given an object with columnar arrays, try to deduce a schema */\nfunction deduceSchemaFromColumns(columnarTable) {\n    const fields = [];\n    for (const [columnName, column] of Object.entries(columnarTable)) {\n        const field = deduceFieldFromColumn(column, columnName);\n        fields.push(field);\n    }\n    return { fields, metadata: {} };\n}\n/** Given an array of rows, try to deduce a schema */\nfunction deduceSchemaFromRows(rowTable) {\n    if (!rowTable.length) {\n        throw new Error('deduce from empty table');\n    }\n    const fields = [];\n    const row0 = rowTable[0];\n    // TODO - fields can be nullable, false detection...\n    // Could look at additional rows if nulls in first row\n    // TODO - if array, column names will be numbers\n    for (const [columnName, value] of Object.entries(row0)) {\n        fields.push(deduceFieldFromValue(value, columnName));\n    }\n    return { fields, metadata: {} };\n}\n/** Given a column (i.e. array), attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromColumn(column, name) {\n    if (ArrayBuffer.isView(column)) {\n        const type = getDataTypeFromArray(column);\n        return {\n            name,\n            type: type.type || 'null',\n            nullable: type.nullable\n            // metadata: {}\n        };\n    }\n    if (Array.isArray(column) && column.length > 0) {\n        const value = column[0];\n        const type = getDataTypeFromValue(value);\n        // TODO - support nested schemas?\n        return {\n            name,\n            type,\n            nullable: true\n            // metadata: {},\n        };\n    }\n    throw new Error('empty table');\n}\n/** Given a value, attempt to deduce an appropriate `Field` */\nfunction deduceFieldFromValue(value, name) {\n    const type = getDataTypeFromValue(value);\n    return {\n        name,\n        type,\n        nullable: true\n        // metadata: {}\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ArrowLikeSchema } from \"./arrow-like-schema.js\";\nimport { deduceTableSchema } from \"../simple-table/table-schema.js\";\nimport { getTableCell, getTableLength, getTableNumCols\n// getTableCell,\n// getTableRowShape,\n// getTableColumnIndex,\n// getTableColumnName,\n// getTableRowAsObject,\n// getTableRowAsArray\n } from \"../simple-table/table-accessors.js\";\nclass ArrowLikeVector {\n    table;\n    columnName;\n    constructor(table, columnName) {\n        this.table = table;\n        this.columnName = columnName;\n    }\n    get(rowIndex) {\n        return getTableCell(this.table, rowIndex, this.columnName);\n    }\n    toArray() {\n        switch (this.table.shape) {\n            case 'arrow-table':\n                const arrowTable = this.table.data;\n                return arrowTable.getChild(this.columnName)?.toArray();\n            case 'columnar-table':\n                return this.table.data[this.columnName];\n            default:\n                throw new Error(this.table.shape);\n        }\n    }\n}\n/**\n * Class that provides an API similar to Apache Arrow Table class\n * Forwards methods directly if the underlying table is Arrow, otherwise calls accessor functions\n */\nexport class ArrowLikeTable {\n    schema;\n    table;\n    constructor(table) {\n        const schema = table.schema || deduceTableSchema(table);\n        this.schema = new ArrowLikeSchema(schema.fields, schema.metadata);\n        this.table = { ...table, schema };\n    }\n    // get schema() {\n    //   return this.table.schema;\n    // }\n    get data() {\n        return this.table.shape === 'geojson-table' ? this.table.features : this.table.data;\n    }\n    get numCols() {\n        return getTableNumCols(this.table);\n    }\n    get length() {\n        return getTableLength(this.table);\n    }\n    getChild(columnName) {\n        return new ArrowLikeVector(this.table, columnName);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { deduceTableSchema } from \"./table-schema.js\";\nexport function makeTableFromData(data) {\n    let table;\n    switch (getTableShapeFromData(data)) {\n        case 'array-row-table':\n            table = { shape: 'array-row-table', data: data };\n            break;\n        case 'object-row-table':\n            table = { shape: 'object-row-table', data: data };\n            break;\n        case 'columnar-table':\n            table = { shape: 'columnar-table', data: data };\n            break;\n        default:\n            throw new Error('table');\n    }\n    const schema = deduceTableSchema(table);\n    return { ...table, schema };\n}\n/** Helper function to get shape of data */\nfunction getTableShapeFromData(data) {\n    if (Array.isArray(data)) {\n        if (data.length === 0) {\n            throw new Error('cannot deduce type of empty table');\n        }\n        // Deduce the table shape from the first row\n        const firstRow = data[0];\n        if (Array.isArray(firstRow)) {\n            return 'array-row-table';\n        }\n        if (firstRow && typeof firstRow === 'object') {\n            return 'object-row-table';\n        }\n    }\n    if (data && typeof data === 'object') {\n        return 'columnar-table';\n    }\n    throw new Error('invalid table');\n}\n/** Convert any table into object row format *\nexport function makeColumnarTable(table: Table): ColumnarTable {\n  if (table.shape === 'columnar-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array<{[key: string]: unknown}>(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'columnar-table',\n    schema: table.schema,\n    data\n  };\n}\n\n\n/** Convert any table into array row format *\nexport function makeArrayRowTable(table: TableLike): ArrayRowTable {\n  if (table.shape === 'array-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array<unknown[]>(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsArray(table, rowIndex);\n  }\n  return {\n    shape: 'array-row-table',\n    schema: table.schema,\n    data\n  };\n}\n\n/** Convert any table into object row format *\nexport function makeObjectRowTable(table: Table): ObjectRowTable {\n  if (table.shape === 'object-row-table') {\n    return table;\n  }\n  const length = getTableLength(table);\n  const data = new Array<{[key: string]: unknown}>(length);\n  for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n    data[rowIndex] = getTableRowAsObject(table, rowIndex);\n  }\n  return {\n    shape: 'object-row-table',\n    schema: table.schema,\n    data\n  };\n}\n*/\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableLength } from '@loaders.gl/schema';\n/**\n * Returns an iterator that yields a single table as a sequence of batches.\n * @note Currently only a single batch is yielded.\n * @note All batches will have the same shape and schema as the original table.\n * @returns\n */\nexport function* makeBatchesFromTable(table) {\n    yield makeBatchFromTable(table);\n}\n/**\n * Returns a table packaged as a single table batch\n * @note The batch will have the same shape and schema as the original table.\n * @returns `null` if no batches are yielded by the async iterator\n */\nexport function makeBatchFromTable(table) {\n    return { ...table, length: getTableLength(table), batchType: 'data' };\n}\n/**\n * Assembles all batches from an async iterator into a single table.\n * @note All batches must have the same shape and schema\n * @param batchIterator\n * @returns `null` if no batches are yielded by the async iterator\n */\n// eslint-disable-next-line complexity\nexport async function makeTableFromBatches(batchIterator) {\n    let arrayRows;\n    let objectRows;\n    let features;\n    let shape = null;\n    let schema;\n    for await (const batch of batchIterator) {\n        shape = shape || batch.shape;\n        schema = schema || batch.schema;\n        switch (batch.shape) {\n            case 'array-row-table':\n                arrayRows = arrayRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    arrayRows.push(row);\n                }\n                break;\n            case 'object-row-table':\n                objectRows = objectRows || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.data[rowIndex];\n                    objectRows.push(row);\n                }\n                break;\n            case 'geojson-table':\n                features = features || [];\n                for (let rowIndex = 0; rowIndex < getTableLength(batch); rowIndex++) {\n                    const row = batch.features[rowIndex];\n                    features.push(row);\n                }\n                break;\n            case 'columnar-table':\n            case 'arrow-table':\n            default:\n                throw new Error('shape');\n        }\n    }\n    if (!shape) {\n        return null;\n    }\n    switch (shape) {\n        case 'array-row-table':\n            return { shape: 'array-row-table', data: arrayRows, schema };\n        case 'object-row-table':\n            return { shape: 'object-row-table', data: objectRows, schema };\n        case 'geojson-table':\n            return { shape: 'geojson-table', type: 'FeatureCollection', features: features, schema };\n        default:\n            return null;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getArrayTypeFromDataType } from \"./data-type.js\";\nexport function makeColumnFromField(field, length) {\n    const ArrayType = getArrayTypeFromDataType(field.type, field.nullable);\n    return new ArrayType(length);\n}\n/*\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction deduceSchema(rows) {\n  const row = rows[0];\n\n  const schema = {};\n  let i = 0;\n  for (const columnName in row) {\n    const value = row[columnName];\n    switch (typeof value) {\n      case 'number':\n      case 'boolean':\n        // TODO - booleans could be handled differently...\n        schema[columnName] = {name: String(columnName), index: i, type: Float32Array};\n        break;\n\n      case 'object':\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n        break;\n\n      case 'string':\n      default:\n        schema[columnName] = {name: String(columnName), index: i, type: Array};\n      // We currently only handle numeric rows\n      // TODO we could offer a function to map strings to numbers?\n    }\n    i++;\n  }\n  return schema;\n}\n*/\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getTableCell, getTableLength, getTableRowAsArray, getTableRowAsObject } from \"./table-accessors.js\";\nimport { deduceTableSchema } from \"./table-schema.js\";\nimport { makeColumnFromField } from \"./table-column.js\";\n/**\n * Convert a table to a different shape\n * @param table\n * @param shape\n * @returns\n */\nexport function convertTable(table, shape) {\n    switch (shape) {\n        case 'object-row-table':\n            return makeObjectRowTable(table);\n        case 'array-row-table':\n            return makeArrayRowTable(table);\n        case 'columnar-table':\n            return makeColumnarTable(table);\n        case 'arrow-table':\n            return makeArrowTable(table);\n        default:\n            throw new Error(shape);\n    }\n}\n/**\n * Convert a table to apache arrow format\n * @note this depends on the `@loaders.gl/arrow module being imported\n */\nexport function makeArrowTable(table) {\n    const _makeArrowTable = globalThis.__loaders?._makeArrowTable;\n    if (!_makeArrowTable) {\n        throw new Error('');\n    }\n    return _makeArrowTable(table);\n}\n/** Convert any simple table into columnar format */\nexport function makeColumnarTable(table) {\n    // TODO - should schema really be optional?\n    const schema = table.schema || deduceTableSchema(table);\n    const fields = table.schema?.fields || [];\n    if (table.shape === 'columnar-table') {\n        return { ...table, schema };\n    }\n    const length = getTableLength(table);\n    const columns = {};\n    for (const field of fields) {\n        const column = makeColumnFromField(field, length);\n        columns[field.name] = column;\n        for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n            column[rowIndex] = getTableCell(table, rowIndex, field.name);\n        }\n    }\n    return {\n        shape: 'columnar-table',\n        schema,\n        data: columns\n    };\n}\n/** Convert any table into array row format */\nexport function makeArrayRowTable(table) {\n    if (table.shape === 'array-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsArray(table, rowIndex);\n    }\n    return {\n        shape: 'array-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/** Convert any table into object row format */\nexport function makeObjectRowTable(table) {\n    if (table.shape === 'object-row-table') {\n        return table;\n    }\n    const length = getTableLength(table);\n    const data = new Array(length);\n    for (let rowIndex = 0; rowIndex < length; rowIndex++) {\n        data[rowIndex] = getTableRowAsObject(table, rowIndex);\n    }\n    return {\n        shape: 'object-row-table',\n        schema: table.schema,\n        data\n    };\n}\n/**\n/**\n *\n * @note - should be part of schema module\nexport function convertColumnarToRowFormatTable(columnarTable: ColumnarTable): ObjectRowTable {\n  const tableKeys = ;\n  const tableRowsCount = columnarTable[tableKeys[0]].length;\n\n  const objectRows: ObjectRowTable['data'] = [];\n\n  for (let index = 0; index < tableRowsCount; index++) {\n    const objectRow = {};\n    for (const fieldName of Object.keys(columnarTable.data)) {\n      objectRow[fieldName] = columnarTable[fieldName][index];\n    }\n    objectRows.push(objectRow);\n  }\n\n  return {\n    shape: 'object-row-table',\n    data: objectRows\n  };\n}\n */\n", "/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes) {\n    let size = 0;\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        if (ArrayBuffer.isView(attribute)) {\n            // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n            size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n        }\n    }\n    return size;\n}\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let minZ = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    const positions = attributes.POSITION ? attributes.POSITION.value : [];\n    const len = positions && positions.length;\n    for (let i = 0; i < len; i += 3) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        const z = positions[i + 2];\n        minX = x < minX ? x : minX;\n        minY = y < minY ? y : minY;\n        minZ = z < minZ ? z : minZ;\n        maxX = x > maxX ? x : maxX;\n        maxY = y > maxY ? y : maxY;\n        maxZ = z > maxZ ? z : maxZ;\n    }\n    return [\n        [minX, minY, minZ],\n        [maxX, maxY, maxZ]\n    ];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getDataTypeFromTypedArray } from \"../table/simple-table/data-type.js\";\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(attributes, metadata = {}) {\n    const fields = deduceMeshFields(attributes);\n    return { fields, metadata };\n}\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(name, attribute, optionalMetadata) {\n    const type = getDataTypeFromTypedArray(attribute.value);\n    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n    return {\n        name,\n        type: { type: 'fixed-size-list', listSize: attribute.size, children: [{ name: 'value', type }] },\n        nullable: false,\n        metadata\n    };\n}\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes) {\n    const fields = [];\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        fields.push(deduceMeshField(attributeName, attribute));\n    }\n    return fields;\n}\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute) {\n    const result = {};\n    if ('byteOffset' in attribute) {\n        result.byteOffset = attribute.byteOffset.toString(10);\n    }\n    if ('byteStride' in attribute) {\n        result.byteStride = attribute.byteStride.toString(10);\n    }\n    if ('normalized' in attribute) {\n        result.normalized = attribute.normalized.toString();\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport var Type;\n(function (Type) {\n    /** The default placeholder type */\n    Type[Type[\"NONE\"] = 0] = \"NONE\";\n    /** A NULL type having no physical storage */\n    Type[Type[\"Null\"] = 1] = \"Null\";\n    /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n    Type[Type[\"Int\"] = 2] = \"Int\";\n    /** 2, 4, or 8-byte floating point value */\n    Type[Type[\"Float\"] = 3] = \"Float\";\n    /** Variable-length bytes (no guarantee of UTF8-ness) */\n    Type[Type[\"Binary\"] = 4] = \"Binary\";\n    /** UTF8 variable-length string as List<Char> */\n    Type[Type[\"Utf8\"] = 5] = \"Utf8\";\n    /** Boolean as 1 bit, LSB bit-packed ordering */\n    Type[Type[\"Bool\"] = 6] = \"Bool\";\n    /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n    Type[Type[\"Decimal\"] = 7] = \"Decimal\";\n    /** int32_t days or int64_t milliseconds since the UNIX epoch */\n    Type[Type[\"Date\"] = 8] = \"Date\";\n    /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n    Type[Type[\"Time\"] = 9] = \"Time\";\n    /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n    Type[Type[\"Timestamp\"] = 10] = \"Timestamp\";\n    /** YEAR_MONTH or DAY_TIME interval in SQL style */\n    Type[Type[\"Interval\"] = 11] = \"Interval\";\n    /** A list of some logical data type */\n    Type[Type[\"List\"] = 12] = \"List\";\n    /** Struct of logical types */\n    Type[Type[\"Struct\"] = 13] = \"Struct\";\n    /** Union of logical types */\n    Type[Type[\"Union\"] = 14] = \"Union\";\n    /** Fixed-size binary. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeBinary\"] = 15] = \"FixedSizeBinary\";\n    /** Fixed-size list. Each value occupies the same number of bytes */\n    Type[Type[\"FixedSizeList\"] = 16] = \"FixedSizeList\";\n    /** Map of named logical types */\n    Type[Type[\"Map\"] = 17] = \"Map\";\n    /** Dictionary aka Category type */\n    Type[Type[\"Dictionary\"] = -1] = \"Dictionary\";\n    Type[Type[\"Int8\"] = -2] = \"Int8\";\n    Type[Type[\"Int16\"] = -3] = \"Int16\";\n    Type[Type[\"Int32\"] = -4] = \"Int32\";\n    Type[Type[\"Int64\"] = -5] = \"Int64\";\n    Type[Type[\"Uint8\"] = -6] = \"Uint8\";\n    Type[Type[\"Uint16\"] = -7] = \"Uint16\";\n    Type[Type[\"Uint32\"] = -8] = \"Uint32\";\n    Type[Type[\"Uint64\"] = -9] = \"Uint64\";\n    Type[Type[\"Float16\"] = -10] = \"Float16\";\n    Type[Type[\"Float32\"] = -11] = \"Float32\";\n    Type[Type[\"Float64\"] = -12] = \"Float64\";\n    Type[Type[\"DateDay\"] = -13] = \"DateDay\";\n    Type[Type[\"DateMillisecond\"] = -14] = \"DateMillisecond\";\n    Type[Type[\"TimestampSecond\"] = -15] = \"TimestampSecond\";\n    Type[Type[\"TimestampMillisecond\"] = -16] = \"TimestampMillisecond\";\n    Type[Type[\"TimestampMicrosecond\"] = -17] = \"TimestampMicrosecond\";\n    Type[Type[\"TimestampNanosecond\"] = -18] = \"TimestampNanosecond\";\n    Type[Type[\"TimeSecond\"] = -19] = \"TimeSecond\";\n    Type[Type[\"TimeMillisecond\"] = -20] = \"TimeMillisecond\";\n    Type[Type[\"TimeMicrosecond\"] = -21] = \"TimeMicrosecond\";\n    Type[Type[\"TimeNanosecond\"] = -22] = \"TimeNanosecond\";\n    Type[Type[\"DenseUnion\"] = -23] = \"DenseUnion\";\n    Type[Type[\"SparseUnion\"] = -24] = \"SparseUnion\";\n    Type[Type[\"IntervalDayTime\"] = -25] = \"IntervalDayTime\";\n    Type[Type[\"IntervalYearMonth\"] = -26] = \"IntervalYearMonth\";\n})(Type || (Type = {}));\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\nimport { Type } from \"./enum.js\";\nexport { Type } from \"./enum.js\";\n/** ArrowLike DataType class */\nexport class DataType {\n    static isNull(x) {\n        return x && x.typeId === Type.Null;\n    }\n    static isInt(x) {\n        return x && x.typeId === Type.Int;\n    }\n    static isFloat(x) {\n        return x && x.typeId === Type.Float;\n    }\n    static isBinary(x) {\n        return x && x.typeId === Type.Binary;\n    }\n    static isUtf8(x) {\n        return x && x.typeId === Type.Utf8;\n    }\n    static isBool(x) {\n        return x && x.typeId === Type.Bool;\n    }\n    static isDecimal(x) {\n        return x && x.typeId === Type.Decimal;\n    }\n    static isDate(x) {\n        return x && x.typeId === Type.Date;\n    }\n    static isTime(x) {\n        return x && x.typeId === Type.Time;\n    }\n    static isTimestamp(x) {\n        return x && x.typeId === Type.Timestamp;\n    }\n    static isInterval(x) {\n        return x && x.typeId === Type.Interval;\n    }\n    static isList(x) {\n        return x && x.typeId === Type.List;\n    }\n    static isStruct(x) {\n        return x && x.typeId === Type.Struct;\n    }\n    static isUnion(x) {\n        return x && x.typeId === Type.Union;\n    }\n    static isFixedSizeBinary(x) {\n        return x && x.typeId === Type.FixedSizeBinary;\n    }\n    static isFixedSizeList(x) {\n        return x && x.typeId === Type.FixedSizeList;\n    }\n    static isMap(x) {\n        return x && x.typeId === Type.Map;\n    }\n    static isDictionary(x) {\n        return x && x.typeId === Type.Dictionary;\n    }\n    get typeId() {\n        return Type.NONE;\n    }\n    // get ArrayType(): AnyArrayType {\n    //   return Int8Array;\n    // }\n    // get ArrayType() { return Array; }\n    compareTo(other) {\n        // TODO\n        return this === other; // comparer.visit(this, other);\n    }\n}\n// NULL\nexport class Null extends DataType {\n    get typeId() {\n        return Type.Null;\n    }\n    get [Symbol.toStringTag]() {\n        return 'Null';\n    }\n    toString() {\n        return 'Null';\n    }\n}\n// BOOLEANS\nexport class Bool extends DataType {\n    get typeId() {\n        return Type.Bool;\n    }\n    // get ArrayType() {\n    //   return Uint8Array;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Bool';\n    }\n    toString() {\n        return 'Bool';\n    }\n}\n// INTS\nexport class Int extends DataType {\n    isSigned;\n    bitWidth;\n    constructor(isSigned, bitWidth) {\n        super();\n        this.isSigned = isSigned;\n        this.bitWidth = bitWidth;\n    }\n    get typeId() {\n        return Type.Int;\n    }\n    // get ArrayType() {\n    //   switch (this.bitWidth) {\n    //     case 8:\n    //       return this.isSigned ? Int8Array : Uint8Array;\n    //     case 16:\n    //       return this.isSigned ? Int16Array : Uint16Array;\n    //     case 32:\n    //       return this.isSigned ? Int32Array : Uint32Array;\n    //     case 64:\n    //       return this.isSigned ? Int32Array : Uint32Array;\n    //     default:\n    //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n    //   }\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Int';\n    }\n    toString() {\n        return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n    }\n}\nexport class Int8 extends Int {\n    constructor() {\n        super(true, 8);\n    }\n}\nexport class Int16 extends Int {\n    constructor() {\n        super(true, 16);\n    }\n}\nexport class Int32 extends Int {\n    constructor() {\n        super(true, 32);\n    }\n}\nexport class Int64 extends Int {\n    constructor() {\n        super(true, 64);\n    }\n}\nexport class Uint8 extends Int {\n    constructor() {\n        super(false, 8);\n    }\n}\nexport class Uint16 extends Int {\n    constructor() {\n        super(false, 16);\n    }\n}\nexport class Uint32 extends Int {\n    constructor() {\n        super(false, 32);\n    }\n}\nexport class Uint64 extends Int {\n    constructor() {\n        super(false, 64);\n    }\n}\n// FLOATS\nconst Precision = {\n    HALF: 16,\n    SINGLE: 32,\n    DOUBLE: 64\n};\nexport class Float extends DataType {\n    precision;\n    constructor(precision) {\n        super();\n        this.precision = precision;\n    }\n    get typeId() {\n        return Type.Float;\n    }\n    // get ArrayType() {\n    //   switch (this.precision) {\n    //     case Precision.HALF:\n    //       return Uint16Array;\n    //     case Precision.SINGLE:\n    //       return Float32Array;\n    //     case Precision.DOUBLE:\n    //       return Float64Array;\n    //     default:\n    //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n    //   }\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Float';\n    }\n    toString() {\n        return `Float${this.precision}`;\n    }\n}\nexport class Float16 extends Float {\n    constructor() {\n        super(Precision.HALF);\n    }\n}\nexport class Float32 extends Float {\n    constructor() {\n        super(Precision.SINGLE);\n    }\n}\nexport class Float64 extends Float {\n    constructor() {\n        super(Precision.DOUBLE);\n    }\n}\nexport class Binary extends DataType {\n    constructor() {\n        super();\n    }\n    get typeId() {\n        return Type.Binary;\n    }\n    toString() {\n        return 'Binary';\n    }\n    get [Symbol.toStringTag]() {\n        return 'Binary';\n    }\n}\n// STRINGS\nexport class Utf8 extends DataType {\n    get typeId() {\n        return Type.Utf8;\n    }\n    // get ArrayType() {\n    //   return Uint8Array;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Utf8';\n    }\n    toString() {\n        return 'Utf8';\n    }\n}\n// DATES, TIMES AND INTERVALS\nconst DateUnit = {\n    DAY: 0,\n    MILLISECOND: 1\n};\nexport class Date extends DataType {\n    unit;\n    constructor(unit) {\n        super();\n        this.unit = unit;\n    }\n    get typeId() {\n        return Type.Date;\n    }\n    // get ArrayType() {\n    //   return Int32Array;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Date';\n    }\n    toString() {\n        return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n    }\n}\nexport class DateDay extends Date {\n    constructor() {\n        super(DateUnit.DAY);\n    }\n}\nexport class DateMillisecond extends Date {\n    constructor() {\n        super(DateUnit.MILLISECOND);\n    }\n}\nconst TimeUnit = {\n    SECOND: 1,\n    MILLISECOND: 1e3,\n    MICROSECOND: 1e6,\n    NANOSECOND: 1e9\n};\nexport class Time extends DataType {\n    unit;\n    bitWidth;\n    constructor(unit, bitWidth) {\n        super();\n        this.unit = unit;\n        this.bitWidth = bitWidth;\n    }\n    get typeId() {\n        return Type.Time;\n    }\n    toString() {\n        return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n    }\n    get [Symbol.toStringTag]() {\n        return 'Time';\n    }\n}\nexport class TimeSecond extends Time {\n    constructor() {\n        super(TimeUnit.SECOND, 32);\n    }\n}\nexport class TimeMillisecond extends Time {\n    constructor() {\n        super(TimeUnit.MILLISECOND, 32);\n    }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\nexport class Timestamp extends DataType {\n    unit;\n    timezone;\n    constructor(unit, timezone = null) {\n        super();\n        this.unit = unit;\n        this.timezone = timezone;\n    }\n    get typeId() {\n        return Type.Timestamp;\n    }\n    // get ArrayType() {\n    //   return Int32Array;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Timestamp';\n    }\n    toString() {\n        return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n    }\n}\nexport class TimestampSecond extends Timestamp {\n    constructor(timezone = null) {\n        super(TimeUnit.SECOND, timezone);\n    }\n}\nexport class TimestampMillisecond extends Timestamp {\n    constructor(timezone = null) {\n        super(TimeUnit.MILLISECOND, timezone);\n    }\n}\nexport class TimestampMicrosecond extends Timestamp {\n    constructor(timezone = null) {\n        super(TimeUnit.MICROSECOND, timezone);\n    }\n}\nexport class TimestampNanosecond extends Timestamp {\n    constructor(timezone = null) {\n        super(TimeUnit.NANOSECOND, timezone);\n    }\n}\nconst IntervalUnit = {\n    DAY_TIME: 0,\n    YEAR_MONTH: 1\n};\nexport class Interval extends DataType {\n    unit;\n    constructor(unit) {\n        super();\n        this.unit = unit;\n    }\n    get typeId() {\n        return Type.Interval;\n    }\n    // get ArrayType() {\n    //   return Int32Array;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'Interval';\n    }\n    toString() {\n        return `Interval<${IntervalUnit[this.unit]}>`;\n    }\n}\nexport class IntervalDayTime extends Interval {\n    constructor() {\n        super(IntervalUnit.DAY_TIME);\n    }\n}\nexport class IntervalYearMonth extends Interval {\n    constructor() {\n        super(IntervalUnit.YEAR_MONTH);\n    }\n}\nexport class FixedSizeList extends DataType {\n    listSize;\n    children;\n    constructor(listSize, child) {\n        super();\n        this.listSize = listSize;\n        this.children = [child];\n    }\n    get typeId() {\n        return Type.FixedSizeList;\n    }\n    get valueType() {\n        return this.children[0].type;\n    }\n    get valueField() {\n        return this.children[0];\n    }\n    // get ArrayType() {\n    //   return this.valueType.ArrayType;\n    // }\n    get [Symbol.toStringTag]() {\n        return 'FixedSizeList';\n    }\n    toString() {\n        return `FixedSizeList[${this.listSize}]<${JSON.stringify(this.valueType)}>`;\n    }\n}\nexport class Struct extends DataType {\n    children;\n    constructor(children) {\n        super();\n        this.children = children;\n    }\n    get typeId() {\n        return Type.Struct;\n    }\n    toString() {\n        return `Struct<{${this.children\n            .map((f) => `${f.name}:${JSON.stringify(f.type)}`)\n            .join(', ')}}>`;\n    }\n    get [Symbol.toStringTag]() {\n        return 'Struct';\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Type } from \"./arrow-like-type.js\";\n/**\n * Gets type information from an Arrow type object or \"mock\" Arrow type object\n * @param arrowTypeLike Arrow Type or type object of similar shape\n */\nexport function getTypeInfo(arrowTypeLike) {\n    return {\n        typeId: arrowTypeLike.typeId,\n        ArrayType: arrowTypeLike.ArrayType,\n        typeName: arrowTypeLike.toString(),\n        typeEnumName: getTypeKey(arrowTypeLike.typeId),\n        precision: arrowTypeLike.precision\n    };\n}\nlet ReverseType = null;\nfunction getTypeKey(typeKey) {\n    if (!ReverseType) {\n        ReverseType = {};\n        for (const key in Type) {\n            ReverseType[Type[key]] = key;\n        }\n    }\n    return ReverseType[typeKey];\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\nclass ArrayQueue extends Array {\n    enqueue(value) {\n        // Add at the end\n        return this.push(value);\n    }\n    dequeue() {\n        // Remove first element\n        return this.shift();\n    }\n}\nexport default class AsyncQueue {\n    _values;\n    _settlers;\n    _closed;\n    constructor() {\n        // enqueues > dequeues\n        this._values = new ArrayQueue();\n        // dequeues > enqueues\n        this._settlers = new ArrayQueue();\n        this._closed = false;\n    }\n    close() {\n        while (this._settlers.length > 0) {\n            this._settlers.dequeue().resolve({ done: true });\n        }\n        this._closed = true;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    enqueue(value) {\n        if (this._closed) {\n            throw new Error('Closed');\n        }\n        if (this._settlers.length > 0) {\n            if (this._values.length > 0) {\n                throw new Error('Illegal internal state');\n            }\n            const settler = this._settlers.dequeue();\n            if (value instanceof Error) {\n                settler.reject(value);\n            }\n            else {\n                settler.resolve({ value });\n            }\n        }\n        else {\n            this._values.enqueue(value);\n        }\n    }\n    /**\n     * @returns a Promise for an IteratorResult\n     */\n    next() {\n        if (this._values.length > 0) {\n            const value = this._values.dequeue();\n            if (value instanceof Error) {\n                return Promise.reject(value);\n            }\n            return Promise.resolve({ value });\n        }\n        if (this._closed) {\n            if (this._settlers.length > 0) {\n                throw new Error('Illegal internal state');\n            }\n            return Promise.resolve({ done: true });\n        }\n        // Wait for new values to be enqueued\n        return new Promise((resolve, reject) => {\n            this._settlers.enqueue({ resolve, reject });\n        });\n    }\n}\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(asyncIterable, count = Infinity) {\n    const result = [];\n    const iterator = asyncIterable[Symbol.asyncIterator]();\n    while (result.length < count) {\n        const { value, done } = await iterator.next();\n        if (done) {\n            break;\n        }\n        result.push(value);\n    }\n    return result;\n}\n"],
  "mappings": "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",
  "names": ["Date", "DEFAULT_ROW_COUNT", "DEFAULT_ROW_COUNT", "objectRow", "arrayRow", "Type", "Date"]
}
