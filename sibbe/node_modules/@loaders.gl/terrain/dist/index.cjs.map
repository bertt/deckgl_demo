{
  "version": 3,
  "sources": ["index.js", "lib/parse-quantized-mesh.js", "lib/decode-quantized-mesh.js", "lib/helpers/skirt.js", "lib/parse-terrain.js", "lib/delatin/index.js", "lib/utils/version.js", "terrain-loader.js", "quantized-mesh-loader.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseFromContext } from '@loaders.gl/loader-utils';\nimport { parseQuantizedMesh } from \"./lib/parse-quantized-mesh.js\";\nimport { makeTerrainMeshFromImage } from \"./lib/parse-terrain.js\";\nimport { TerrainLoader as TerrainWorkerLoader } from \"./terrain-loader.js\";\nimport { QuantizedMeshLoader as QuantizedMeshWorkerLoader } from \"./quantized-mesh-loader.js\";\n// TerrainLoader\nexport { TerrainWorkerLoader };\nexport const TerrainLoader = {\n    ...TerrainWorkerLoader,\n    parse: parseTerrain\n};\nexport async function parseTerrain(arrayBuffer, options, context) {\n    const loadImageOptions = {\n        ...options,\n        mimeType: 'application/x.image',\n        image: { ...options?.image, type: 'data' }\n    };\n    const image = await parseFromContext(arrayBuffer, [], loadImageOptions, context);\n    // Extend function to support additional mesh generation options (square grid or delatin)\n    const terrainOptions = { ...TerrainLoader.options.terrain, ...options?.terrain };\n    // @ts-expect-error sort out image typing asap\n    return makeTerrainMeshFromImage(image, terrainOptions);\n}\n// QuantizedMeshLoader\nexport { QuantizedMeshWorkerLoader };\n/**\n * Loader for quantized meshes\n */\nexport const QuantizedMeshLoader = {\n    ...QuantizedMeshWorkerLoader,\n    parseSync: (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options?.['quantized-mesh']),\n    parse: async (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options?.['quantized-mesh'])\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport decode, { DECODING_STEPS } from \"./decode-quantized-mesh.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\nexport function parseQuantizedMesh(arrayBuffer, options = {}) {\n    const { bounds } = options;\n    // Don't parse edge indices or format extensions\n    const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode(arrayBuffer, DECODING_STEPS.triangleIndices);\n    let triangleIndices = originalTriangleIndices;\n    let attributes = getMeshAttributes(vertexData, header, bounds);\n    // Compute bounding box before adding skirt so that z values are not skewed\n    // TODO: Find bounding box from header, instead of doing extra pass over\n    // vertices.\n    const boundingBox = getMeshBoundingBox(attributes);\n    if (options?.skirtHeight) {\n        const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {\n            westIndices,\n            northIndices,\n            eastIndices,\n            southIndices\n        });\n        attributes = newAttributes;\n        triangleIndices = newTriangles;\n    }\n    return {\n        // Data return by this loader implementation\n        loaderData: {\n            header: {}\n        },\n        header: {\n            // @ts-ignore\n            vertexCount: triangleIndices.length,\n            boundingBox\n        },\n        // TODO\n        schema: undefined,\n        topology: 'triangle-list',\n        mode: 4, // TRIANGLES\n        indices: { value: triangleIndices, size: 1 },\n        attributes\n    };\n}\nfunction getMeshAttributes(vertexData, header, bounds) {\n    const { minHeight, maxHeight } = header;\n    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];\n    const xScale = maxX - minX;\n    const yScale = maxY - minY;\n    const zScale = maxHeight - minHeight;\n    const nCoords = vertexData.length / 3;\n    // vec3. x, y defined by bounds, z in meters\n    const positions = new Float32Array(nCoords * 3);\n    // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n    const texCoords = new Float32Array(nCoords * 2);\n    // Data is not interleaved; all u, then all v, then all heights\n    for (let i = 0; i < nCoords; i++) {\n        const x = vertexData[i] / 32767;\n        const y = vertexData[i + nCoords] / 32767;\n        const z = vertexData[i + nCoords * 2] / 32767;\n        positions[3 * i + 0] = x * xScale + minX;\n        positions[3 * i + 1] = y * yScale + minY;\n        positions[3 * i + 2] = z * zScale + minHeight;\n        texCoords[2 * i + 0] = x;\n        texCoords[2 * i + 1] = y;\n    }\n    return {\n        POSITION: { value: positions, size: 3 },\n        TEXCOORD_0: { value: texCoords, size: 2 }\n        // TODO: Parse normals if they exist in the file\n        // NORMAL: {}, - optional, but creates the high poly look with lighting\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nconst QUANTIZED_MESH_HEADER = new Map([\n    ['centerX', Float64Array.BYTES_PER_ELEMENT],\n    ['centerY', Float64Array.BYTES_PER_ELEMENT],\n    ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n    ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n    ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n    ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n    ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\nfunction decodeZigZag(value) {\n    return (value >> 1) ^ -(value & 1);\n}\nfunction decodeHeader(dataView) {\n    let position = 0;\n    const header = {};\n    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n        const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n        header[key] = getter.call(dataView, position, true);\n        position += bytesCount;\n    }\n    return { header, headerEndPosition: position };\n}\nfunction decodeVertexData(dataView, headerEndPosition) {\n    let position = headerEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = dataView.getUint32(position, true);\n    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n    const elementArrayLength = vertexCount * bytesPerArrayElement;\n    const uArrayStartPosition = position;\n    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n    let u = 0;\n    let v = 0;\n    let height = 0;\n    for (let i = 0; i < vertexCount; i++) {\n        u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n        v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n        height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n        vertexData[i] = u;\n        vertexData[i + vertexCount] = v;\n        vertexData[i + vertexCount * 2] = height;\n    }\n    position += elementArrayLength * 3;\n    return { vertexData, vertexDataEndPosition: position };\n}\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n    let indices;\n    if (bytesPerIndex === 2) {\n        indices = new Uint16Array(buffer, position, indicesCount);\n    }\n    else {\n        indices = new Uint32Array(buffer, position, indicesCount);\n    }\n    if (!encoded) {\n        return indices;\n    }\n    let highest = 0;\n    for (let i = 0; i < indices.length; ++i) {\n        const code = indices[i];\n        indices[i] = highest - code;\n        if (code === 0) {\n            ++highest;\n        }\n    }\n    return indices;\n}\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n    let position = vertexDataEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = vertexData.length / elementsPerVertex;\n    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n    if (position % bytesPerIndex !== 0) {\n        position += bytesPerIndex - (position % bytesPerIndex);\n    }\n    const triangleCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const triangleIndicesCount = triangleCount * 3;\n    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n    position += triangleIndicesCount * bytesPerIndex;\n    return {\n        triangleIndicesEndPosition: position,\n        triangleIndices\n    };\n}\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n    let position = triangleIndicesEndPosition;\n    const elementsPerVertex = 3;\n    const vertexCount = vertexData.length / elementsPerVertex;\n    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n    const westVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n    position += westVertexCount * bytesPerIndex;\n    const southVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n    position += southVertexCount * bytesPerIndex;\n    const eastVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n    position += eastVertexCount * bytesPerIndex;\n    const northVertexCount = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n    position += northVertexCount * bytesPerIndex;\n    return {\n        edgeIndicesEndPosition: position,\n        westIndices,\n        southIndices,\n        eastIndices,\n        northIndices\n    };\n}\nfunction decodeVertexNormalsExtension(extensionDataView) {\n    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\nfunction decodeWaterMaskExtension(extensionDataView) {\n    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\nfunction decodeExtensions(dataView, indicesEndPosition) {\n    const extensions = {};\n    if (dataView.byteLength <= indicesEndPosition) {\n        return { extensions, extensionsEndPosition: indicesEndPosition };\n    }\n    let position = indicesEndPosition;\n    while (position < dataView.byteLength) {\n        const extensionId = dataView.getUint8(position, true);\n        position += Uint8Array.BYTES_PER_ELEMENT;\n        const extensionLength = dataView.getUint32(position, true);\n        position += Uint32Array.BYTES_PER_ELEMENT;\n        const extensionView = new DataView(dataView.buffer, position, extensionLength);\n        switch (extensionId) {\n            case 1: {\n                extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n                break;\n            }\n            case 2: {\n                extensions.waterMask = decodeWaterMaskExtension(extensionView);\n                break;\n            }\n            default: {\n                // console.warn(`Unknown extension with id ${extensionId}`)\n            }\n        }\n        position += extensionLength;\n    }\n    return { extensions, extensionsEndPosition: position };\n}\nexport const DECODING_STEPS = {\n    header: 0,\n    vertices: 1,\n    triangleIndices: 2,\n    edgeIndices: 3,\n    extensions: 4\n};\nconst DEFAULT_OPTIONS = {\n    maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n    const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n    const view = new DataView(data);\n    const { header, headerEndPosition } = decodeHeader(view);\n    if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n        return { header };\n    }\n    const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n        return { header, vertexData };\n    }\n    const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n        return { header, vertexData, triangleIndices };\n    }\n    const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n    if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n        return {\n            header,\n            vertexData,\n            triangleIndices,\n            westIndices,\n            northIndices,\n            eastIndices,\n            southIndices\n        };\n    }\n    const { extensions } = decodeExtensions(view, edgeIndicesEndPosition);\n    return {\n        header,\n        vertexData,\n        triangleIndices,\n        westIndices,\n        northIndices,\n        eastIndices,\n        southIndices,\n        extensions\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateTypedArrays } from '@loaders.gl/loader-utils';\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param skirtHeight - height of the skirt geometry\n * @param outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {\n    const outsideEdges = outsideIndices\n        ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value)\n        : getOutsideEdgesFromTriangles(triangles);\n    // 2 new vertices for each outside edge\n    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n    // 2 new triangles for each outside edge\n    const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n    for (let i = 0; i < outsideEdges.length; i++) {\n        const edge = outsideEdges[i];\n        updateAttributesForNewEdge({\n            edge,\n            edgeIndex: i,\n            attributes,\n            skirtHeight,\n            newPosition,\n            newTexcoord0,\n            newTriangles\n        });\n    }\n    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n    const resultTriangles = triangles instanceof Array\n        ? triangles.concat(newTriangles)\n        : concatenateTypedArrays(triangles, newTriangles);\n    return {\n        attributes,\n        triangles: resultTriangles\n    };\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n    const edges = [];\n    for (let i = 0; i < triangles.length; i += 3) {\n        edges.push([triangles[i], triangles[i + 1]]);\n        edges.push([triangles[i + 1], triangles[i + 2]]);\n        edges.push([triangles[i + 2], triangles[i]]);\n    }\n    edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n    const outsideEdges = [];\n    let index = 0;\n    while (index < edges.length) {\n        if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {\n            index += 2;\n        }\n        else {\n            outsideEdges.push(edges[index]);\n            index++;\n        }\n    }\n    return outsideEdges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices, position) {\n    // Sort skirt indices to create adjacent triangles\n    indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n    // Reverse (b - a) to match triangle winding\n    indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n    indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n    // Reverse (b - a) to match triangle winding\n    indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n    const edges = [];\n    for (const index in indices) {\n        const indexGroup = indices[index];\n        for (let i = 0; i < indexGroup.length - 1; i++) {\n            edges.push([indexGroup[i], indexGroup[i + 1]]);\n        }\n    }\n    return edges;\n}\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {\n    const positionsLength = attributes.POSITION.value.length;\n    const vertex1Offset = edgeIndex * 2;\n    const vertex2Offset = edgeIndex * 2 + 1;\n    // Define POSITION for new 1st vertex\n    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);\n    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n    // Define POSITION for new 2nd vertex\n    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);\n    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n    // Use same TEXCOORDS for skirt vertices\n    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);\n    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);\n    // Define new triangles\n    const triangle1Offset = edgeIndex * 2 * 3;\n    newTriangles[triangle1Offset] = edge[0];\n    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;\n    newTriangles[triangle1Offset + 2] = edge[1];\n    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n    newTriangles[triangle1Offset + 4] = edge[0];\n    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from \"./delatin/index.js\";\nimport { addSkirt } from \"./helpers/skirt.js\";\n/**\n * Returns generated mesh object from image data\n *\n * @param terrainImage terrain image data\n * @param terrainOptions terrain options\n * @returns mesh object\n */\nexport function makeTerrainMeshFromImage(terrainImage, terrainOptions) {\n    const { meshMaxError, bounds, elevationDecoder } = terrainOptions;\n    const { data, width, height } = terrainImage;\n    let terrain;\n    let mesh;\n    switch (terrainOptions.tesselator) {\n        case 'martini':\n            terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n            mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n            break;\n        case 'delatin':\n            terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n            mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n            break;\n        // auto\n        default:\n            if (width === height && !(height & (width - 1))) {\n                terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n                mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n            }\n            else {\n                terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n                mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n            }\n            break;\n    }\n    const { vertices } = mesh;\n    let { triangles } = mesh;\n    let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n    // Compute bounding box before adding skirt so that z values are not skewed\n    const boundingBox = getMeshBoundingBox(attributes);\n    if (terrainOptions.skirtHeight) {\n        const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);\n        attributes = newAttributes;\n        triangles = newTriangles;\n    }\n    return {\n        // Data return by this loader implementation\n        loaderData: {\n            header: {}\n        },\n        header: {\n            vertexCount: triangles.length,\n            boundingBox\n        },\n        mode: 4, // TRIANGLES\n        indices: { value: Uint32Array.from(triangles), size: 1 },\n        attributes\n    };\n}\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n    const gridSize = width + 1;\n    const martini = new Martini(gridSize);\n    const tile = martini.createTile(terrain);\n    const { vertices, triangles } = tile.getMesh(meshMaxError);\n    return { vertices, triangles };\n}\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n    const tin = new Delatin(terrain, width + 1, height + 1);\n    tin.run(meshMaxError);\n    // @ts-expect-error\n    const { coords, triangles } = tin;\n    const vertices = coords;\n    return { vertices, triangles };\n}\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n    const { rScaler, bScaler, gScaler, offset } = elevationDecoder;\n    // From Martini demo\n    // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n    const terrain = new Float32Array((width + 1) * (height + 1));\n    // decode terrain values\n    for (let i = 0, y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++, i++) {\n            const k = i * 4;\n            const r = imageData[k + 0];\n            const g = imageData[k + 1];\n            const b = imageData[k + 2];\n            terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n        }\n    }\n    if (tesselator === 'martini') {\n        // backfill bottom border\n        for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n            terrain[i] = terrain[i - width - 1];\n        }\n        // backfill right border\n        for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n            terrain[i] = terrain[i - 1];\n        }\n    }\n    return terrain;\n}\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n    const gridSize = width + 1;\n    const numOfVerticies = vertices.length / 2;\n    // vec3. x, y in pixels, z in meters\n    const positions = new Float32Array(numOfVerticies * 3);\n    // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n    const texCoords = new Float32Array(numOfVerticies * 2);\n    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n    const xScale = (maxX - minX) / width;\n    const yScale = (maxY - minY) / height;\n    for (let i = 0; i < numOfVerticies; i++) {\n        const x = vertices[i * 2];\n        const y = vertices[i * 2 + 1];\n        const pixelIdx = y * gridSize + x;\n        positions[3 * i + 0] = x * xScale + minX;\n        positions[3 * i + 1] = -y * yScale + maxY;\n        positions[3 * i + 2] = terrain[pixelIdx];\n        texCoords[2 * i + 0] = x / width;\n        texCoords[2 * i + 1] = y / height;\n    }\n    return {\n        POSITION: { value: positions, size: 3 },\n        TEXCOORD_0: { value: texCoords, size: 2 }\n        // NORMAL: {}, - optional, but creates the high poly look with lighting\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// ISC License\n// Copyright(c) 2019, Michael Fogleman, Vladimir Agafonkin\n// @ts-nocheck\n/* eslint-disable complexity, max-params, max-statements, max-depth, no-constant-condition */\nexport default class Delatin {\n    constructor(data, width, height = width) {\n        this.data = data; // height data\n        this.width = width;\n        this.height = height;\n        this.coords = []; // vertex coordinates (x, y)\n        this.triangles = []; // mesh triangle indices\n        // additional triangle data\n        this._halfedges = [];\n        this._candidates = [];\n        this._queueIndices = [];\n        this._queue = []; // queue of added triangles\n        this._errors = [];\n        this._rms = [];\n        this._pending = []; // triangles pending addition to queue\n        this._pendingLen = 0;\n        this._rmsSum = 0;\n        const x1 = width - 1;\n        const y1 = height - 1;\n        const p0 = this._addPoint(0, 0);\n        const p1 = this._addPoint(x1, 0);\n        const p2 = this._addPoint(0, y1);\n        const p3 = this._addPoint(x1, y1);\n        // add initial two triangles\n        const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);\n        this._addTriangle(p0, p3, p1, t0, -1, -1);\n        this._flush();\n    }\n    // refine the mesh until its maximum error gets below the given one\n    run(maxError = 1) {\n        while (this.getMaxError() > maxError) {\n            this.refine();\n        }\n    }\n    // refine the mesh with a single point\n    refine() {\n        this._step();\n        this._flush();\n    }\n    // max error of the current mesh\n    getMaxError() {\n        return this._errors[0];\n    }\n    // root-mean-square deviation of the current mesh\n    getRMSD() {\n        return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;\n    }\n    // height value at a given position\n    heightAt(x, y) {\n        return this.data[this.width * y + x];\n    }\n    // rasterize and queue all triangles that got added or updated in _step\n    _flush() {\n        const coords = this.coords;\n        for (let i = 0; i < this._pendingLen; i++) {\n            const t = this._pending[i];\n            // rasterize triangle to find maximum pixel error\n            const a = 2 * this.triangles[t * 3 + 0];\n            const b = 2 * this.triangles[t * 3 + 1];\n            const c = 2 * this.triangles[t * 3 + 2];\n            this._findCandidate(coords[a], coords[a + 1], coords[b], coords[b + 1], coords[c], coords[c + 1], t);\n        }\n        this._pendingLen = 0;\n    }\n    // rasterize a triangle, find its max error, and queue it for processing\n    _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t) {\n        // triangle bounding box\n        const minX = Math.min(p0x, p1x, p2x);\n        const minY = Math.min(p0y, p1y, p2y);\n        const maxX = Math.max(p0x, p1x, p2x);\n        const maxY = Math.max(p0y, p1y, p2y);\n        // forward differencing variables\n        let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);\n        let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);\n        let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);\n        const a01 = p1y - p0y;\n        const b01 = p0x - p1x;\n        const a12 = p2y - p1y;\n        const b12 = p1x - p2x;\n        const a20 = p0y - p2y;\n        const b20 = p2x - p0x;\n        // pre-multiplied z values at vertices\n        const a = orient(p0x, p0y, p1x, p1y, p2x, p2y);\n        const z0 = this.heightAt(p0x, p0y) / a;\n        const z1 = this.heightAt(p1x, p1y) / a;\n        const z2 = this.heightAt(p2x, p2y) / a;\n        // iterate over pixels in bounding box\n        let maxError = 0;\n        let mx = 0;\n        let my = 0;\n        let rms = 0;\n        for (let y = minY; y <= maxY; y++) {\n            // compute starting offset\n            let dx = 0;\n            if (w00 < 0 && a12 !== 0) {\n                dx = Math.max(dx, Math.floor(-w00 / a12));\n            }\n            if (w01 < 0 && a20 !== 0) {\n                dx = Math.max(dx, Math.floor(-w01 / a20));\n            }\n            if (w02 < 0 && a01 !== 0) {\n                dx = Math.max(dx, Math.floor(-w02 / a01));\n            }\n            let w0 = w00 + a12 * dx;\n            let w1 = w01 + a20 * dx;\n            let w2 = w02 + a01 * dx;\n            let wasInside = false;\n            for (let x = minX + dx; x <= maxX; x++) {\n                // check if inside triangle\n                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\n                    wasInside = true;\n                    // compute z using barycentric coordinates\n                    const z = z0 * w0 + z1 * w1 + z2 * w2;\n                    const dz = Math.abs(z - this.heightAt(x, y));\n                    rms += dz * dz;\n                    if (dz > maxError) {\n                        maxError = dz;\n                        mx = x;\n                        my = y;\n                    }\n                }\n                else if (wasInside) {\n                    break;\n                }\n                w0 += a12;\n                w1 += a20;\n                w2 += a01;\n            }\n            w00 += b12;\n            w01 += b20;\n            w02 += b01;\n        }\n        if ((mx === p0x && my === p0y) || (mx === p1x && my === p1y) || (mx === p2x && my === p2y)) {\n            maxError = 0;\n        }\n        // update triangle metadata\n        this._candidates[2 * t] = mx;\n        this._candidates[2 * t + 1] = my;\n        this._rms[t] = rms;\n        // add triangle to priority queue\n        this._queuePush(t, maxError, rms);\n    }\n    // process the next triangle in the queue, splitting it with a new point\n    _step() {\n        // pop triangle with highest error from priority queue\n        const t = this._queuePop();\n        const e0 = t * 3 + 0;\n        const e1 = t * 3 + 1;\n        const e2 = t * 3 + 2;\n        const p0 = this.triangles[e0];\n        const p1 = this.triangles[e1];\n        const p2 = this.triangles[e2];\n        const ax = this.coords[2 * p0];\n        const ay = this.coords[2 * p0 + 1];\n        const bx = this.coords[2 * p1];\n        const by = this.coords[2 * p1 + 1];\n        const cx = this.coords[2 * p2];\n        const cy = this.coords[2 * p2 + 1];\n        const px = this._candidates[2 * t];\n        const py = this._candidates[2 * t + 1];\n        const pn = this._addPoint(px, py);\n        if (orient(ax, ay, bx, by, px, py) === 0) {\n            this._handleCollinear(pn, e0);\n        }\n        else if (orient(bx, by, cx, cy, px, py) === 0) {\n            this._handleCollinear(pn, e1);\n        }\n        else if (orient(cx, cy, ax, ay, px, py) === 0) {\n            this._handleCollinear(pn, e2);\n        }\n        else {\n            const h0 = this._halfedges[e0];\n            const h1 = this._halfedges[e1];\n            const h2 = this._halfedges[e2];\n            const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);\n            const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);\n            const t2 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);\n            this._legalize(t0);\n            this._legalize(t1);\n            this._legalize(t2);\n        }\n    }\n    // add coordinates for a new vertex\n    _addPoint(x, y) {\n        const i = this.coords.length >> 1;\n        this.coords.push(x, y);\n        return i;\n    }\n    // add or update a triangle in the mesh\n    _addTriangle(a, b, c, ab, bc, ca, e = this.triangles.length) {\n        const t = e / 3; // new triangle index\n        // add triangle vertices\n        this.triangles[e + 0] = a;\n        this.triangles[e + 1] = b;\n        this.triangles[e + 2] = c;\n        // add triangle halfedges\n        this._halfedges[e + 0] = ab;\n        this._halfedges[e + 1] = bc;\n        this._halfedges[e + 2] = ca;\n        // link neighboring halfedges\n        if (ab >= 0) {\n            this._halfedges[ab] = e + 0;\n        }\n        if (bc >= 0) {\n            this._halfedges[bc] = e + 1;\n        }\n        if (ca >= 0) {\n            this._halfedges[ca] = e + 2;\n        }\n        // init triangle metadata\n        this._candidates[2 * t + 0] = 0;\n        this._candidates[2 * t + 1] = 0;\n        this._queueIndices[t] = -1;\n        this._rms[t] = 0;\n        // add triangle to pending queue for later rasterization\n        this._pending[this._pendingLen++] = t;\n        // return first halfedge index\n        return e;\n    }\n    _legalize(a) {\n        // if the pair of triangles doesn't satisfy the Delaunay condition\n        // (p1 is inside the circumcircle of [p0, pl, pr]), flip them,\n        // then do the same check/flip recursively for the new pair of triangles\n        //\n        //           pl                    pl\n        //          /||\\                  /  \\\n        //       al/ || \\bl            al/    \\a\n        //        /  ||  \\              /      \\\n        //       /  a||b  \\    flip    /___ar___\\\n        //     p0\\   ||   /p1   =>   p0\\---bl---/p1\n        //        \\  ||  /              \\      /\n        //       ar\\ || /br             b\\    /br\n        //          \\||/                  \\  /\n        //           pr                    pr\n        const b = this._halfedges[a];\n        if (b < 0) {\n            return;\n        }\n        const a0 = a - (a % 3);\n        const b0 = b - (b % 3);\n        const al = a0 + ((a + 1) % 3);\n        const ar = a0 + ((a + 2) % 3);\n        const bl = b0 + ((b + 2) % 3);\n        const br = b0 + ((b + 1) % 3);\n        const p0 = this.triangles[ar];\n        const pr = this.triangles[a];\n        const pl = this.triangles[al];\n        const p1 = this.triangles[bl];\n        const coords = this.coords;\n        if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {\n            return;\n        }\n        const hal = this._halfedges[al];\n        const har = this._halfedges[ar];\n        const hbl = this._halfedges[bl];\n        const hbr = this._halfedges[br];\n        this._queueRemove(a0 / 3);\n        this._queueRemove(b0 / 3);\n        const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);\n        const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);\n        this._legalize(t0 + 1);\n        this._legalize(t1 + 2);\n    }\n    // handle a case where new vertex is on the edge of a triangle\n    _handleCollinear(pn, a) {\n        const a0 = a - (a % 3);\n        const al = a0 + ((a + 1) % 3);\n        const ar = a0 + ((a + 2) % 3);\n        const p0 = this.triangles[ar];\n        const pr = this.triangles[a];\n        const pl = this.triangles[al];\n        const hal = this._halfedges[al];\n        const har = this._halfedges[ar];\n        const b = this._halfedges[a];\n        if (b < 0) {\n            const t0 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);\n            const t1 = this._addTriangle(p0, pn, pl, t0, -1, hal);\n            this._legalize(t0 + 1);\n            this._legalize(t1 + 2);\n            return;\n        }\n        const b0 = b - (b % 3);\n        const bl = b0 + ((b + 2) % 3);\n        const br = b0 + ((b + 1) % 3);\n        const p1 = this.triangles[bl];\n        const hbl = this._halfedges[bl];\n        const hbr = this._halfedges[br];\n        this._queueRemove(b0 / 3);\n        const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);\n        const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);\n        const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);\n        const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);\n        this._legalize(t0);\n        this._legalize(t1);\n        this._legalize(t2);\n        this._legalize(t3);\n    }\n    // priority queue methods\n    _queuePush(t, error, rms) {\n        const i = this._queue.length;\n        this._queueIndices[t] = i;\n        this._queue.push(t);\n        this._errors.push(error);\n        this._rmsSum += rms;\n        this._queueUp(i);\n    }\n    _queuePop() {\n        const n = this._queue.length - 1;\n        this._queueSwap(0, n);\n        this._queueDown(0, n);\n        return this._queuePopBack();\n    }\n    _queuePopBack() {\n        const t = this._queue.pop();\n        this._errors.pop();\n        this._rmsSum -= this._rms[t];\n        this._queueIndices[t] = -1;\n        return t;\n    }\n    _queueRemove(t) {\n        const i = this._queueIndices[t];\n        if (i < 0) {\n            const it = this._pending.indexOf(t);\n            if (it !== -1) {\n                this._pending[it] = this._pending[--this._pendingLen];\n            }\n            else {\n                throw new Error('Broken triangulation (something went wrong).');\n            }\n            return;\n        }\n        const n = this._queue.length - 1;\n        if (n !== i) {\n            this._queueSwap(i, n);\n            if (!this._queueDown(i, n)) {\n                this._queueUp(i);\n            }\n        }\n        this._queuePopBack();\n    }\n    _queueLess(i, j) {\n        return this._errors[i] > this._errors[j];\n    }\n    _queueSwap(i, j) {\n        const pi = this._queue[i];\n        const pj = this._queue[j];\n        this._queue[i] = pj;\n        this._queue[j] = pi;\n        this._queueIndices[pi] = j;\n        this._queueIndices[pj] = i;\n        const e = this._errors[i];\n        this._errors[i] = this._errors[j];\n        this._errors[j] = e;\n    }\n    _queueUp(j0) {\n        let j = j0;\n        while (true) {\n            const i = (j - 1) >> 1;\n            if (i === j || !this._queueLess(j, i)) {\n                break;\n            }\n            this._queueSwap(i, j);\n            j = i;\n        }\n    }\n    _queueDown(i0, n) {\n        let i = i0;\n        while (true) {\n            const j1 = 2 * i + 1;\n            if (j1 >= n || j1 < 0) {\n                break;\n            }\n            const j2 = j1 + 1;\n            let j = j1;\n            if (j2 < n && this._queueLess(j2, j1)) {\n                j = j2;\n            }\n            if (!this._queueLess(j, i)) {\n                break;\n            }\n            this._queueSwap(i, j);\n            i = j;\n        }\n        return i > i0;\n    }\n}\nfunction orient(ax, ay, bx, by, cx, cy) {\n    return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);\n}\nfunction inCircle(ax, ay, bx, by, cx, cy, px, py) {\n    const dx = ax - px;\n    const dy = ay - py;\n    const ex = bx - px;\n    const ey = by - py;\n    const fx = cx - px;\n    const fy = cy - py;\n    const ap = dx * dx + dy * dy;\n    const bp = ex * ex + ey * ey;\n    const cp = fx * fx + fy * fy;\n    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\n/**\n * Worker loader for image encoded terrain\n */\nexport const TerrainLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Terrain',\n    id: 'terrain',\n    module: 'terrain',\n    version: VERSION,\n    worker: true,\n    extensions: ['png', 'pngraw', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'],\n    mimeTypes: ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/bmp'],\n    options: {\n        terrain: {\n            tesselator: 'auto',\n            bounds: undefined,\n            meshMaxError: 10,\n            elevationDecoder: {\n                rScaler: 1,\n                gScaler: 0,\n                bScaler: 0,\n                offset: 0\n            },\n            skirtHeight: undefined\n        }\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\n/**\n * Worker loader for quantized meshes\n */\nexport const QuantizedMeshLoader = {\n    dataType: null, // Mesh,\n    batchType: null,\n    name: 'Quantized Mesh',\n    id: 'quantized-mesh',\n    module: 'terrain',\n    version: VERSION,\n    worker: true,\n    extensions: ['terrain'],\n    mimeTypes: ['application/vnd.quantized-mesh'],\n    options: {\n        'quantized-mesh': {\n            bounds: [0, 0, 1, 1],\n            skirtHeight: null\n        }\n    }\n};\n"],
  "mappings": "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",
  "names": ["QuantizedMeshLoader", "TerrainLoader", "import_loader_utils", "import_schema", "t0", "t1", "getMeshAttributes", "Martini", "TerrainLoader", "QuantizedMeshLoader"]
}
