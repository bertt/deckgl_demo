"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  CesiumIonLoader: () => CesiumIonLoader,
  TILE3D_TYPE: () => TILE3D_TYPE,
  Tile3DBatchTable: () => Tile3DBatchTableParser,
  Tile3DFeatureTable: () => Tile3DFeatureTable,
  Tile3DSubtreeLoader: () => Tile3DSubtreeLoader,
  Tile3DWriter: () => Tile3DWriter,
  Tiles3DArchive: () => Tiles3DArchive,
  Tiles3DArchiveFileLoader: () => Tiles3DArchiveFileLoader,
  Tiles3DLoader: () => Tiles3DLoader,
  _getIonTilesetMetadata: () => getIonTilesetMetadata
});
module.exports = __toCommonJS(dist_exports);

// dist/tiles-3d-loader.js
var import_loader_utils8 = require("@loaders.gl/loader-utils");
var import_tiles2 = require("@loaders.gl/tiles");

// dist/lib/utils/version.js
var VERSION = true ? "4.2.0-beta.2" : "latest";

// dist/lib/constants.js
var TILE3D_TYPE = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
var TILE3D_TYPES = Object.keys(TILE3D_TYPE);
var MAGIC_ARRAY = {
  BATCHED_MODEL: [98, 51, 100, 109],
  INSTANCED_MODEL: [105, 51, 100, 109],
  POINT_CLOUD: [112, 110, 116, 115],
  COMPOSITE: [99, 109, 112, 116]
};

// dist/lib/parsers/helpers/parse-utils.js
var import_loader_utils = require("@loaders.gl/loader-utils");
function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  (0, import_loader_utils.assert)(arrayBuffer instanceof ArrayBuffer);
  const textDecoder = new TextDecoder("utf8");
  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
  const string = textDecoder.decode(typedArray);
  return string;
}
function getMagicString(arrayBuffer, byteOffset = 0) {
  const dataView = new DataView(arrayBuffer);
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}

// dist/lib/parsers/parse-3d-tile-point-cloud.js
var import_draco = require("@loaders.gl/draco");
var import_loader_utils4 = require("@loaders.gl/loader-utils");
var import_math6 = require("@loaders.gl/math");
var import_core3 = require("@math.gl/core");

// dist/lib/classes/tile-3d-feature-table.js
var import_math = require("@loaders.gl/math");
var Tile3DFeatureTable = class {
  json;
  buffer;
  featuresLength = 0;
  _cachedTypedArrays = {};
  constructor(featureTableJson, featureTableBinary) {
    this.json = featureTableJson;
    this.buffer = featureTableBinary;
  }
  getExtension(extensionName) {
    return this.json.extensions && this.json.extensions[extensionName];
  }
  hasProperty(propertyName) {
    return Boolean(this.json[propertyName]);
  }
  getGlobalProperty(propertyName, componentType = import_math.GL.UNSIGNED_INT, componentLength = 1) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
    }
    return jsonValue;
  }
  getPropertyArray(propertyName, componentType, componentLength) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      if ("componentType" in jsonValue) {
        componentType = import_math.GLType.fromName(jsonValue.componentType);
      }
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
    }
    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
  }
  getProperty(propertyName, componentType, componentLength, featureId, result) {
    const jsonValue = this.json[propertyName];
    if (!jsonValue) {
      return jsonValue;
    }
    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
    if (componentLength === 1) {
      return typedArray[featureId];
    }
    for (let i = 0; i < componentLength; ++i) {
      result[i] = typedArray[componentLength * featureId + i];
    }
    return result;
  }
  // HELPERS
  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = import_math.GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
  _getTypedArrayFromArray(propertyName, componentType, array) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = import_math.GLType.createTypedArray(componentType, array);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
};

// dist/lib/classes/tile-3d-batch-table.js
var import_loader_utils3 = require("@loaders.gl/loader-utils");

// dist/lib/classes/helpers/tile-3d-accessor-utils.js
var import_math2 = require("@loaders.gl/math");
var import_loader_utils2 = require("@loaders.gl/loader-utils");
var COMPONENTS_PER_ATTRIBUTE = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var UNPACKER = {
  SCALAR: (values, i) => values[i],
  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],
  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],
  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],
  // TODO: check column major
  MAT2: (values, i) => [
    values[4 * i + 0],
    values[4 * i + 1],
    values[4 * i + 2],
    values[4 * i + 3]
  ],
  MAT3: (values, i) => [
    values[9 * i + 0],
    values[9 * i + 1],
    values[9 * i + 2],
    values[9 * i + 3],
    values[9 * i + 4],
    values[9 * i + 5],
    values[9 * i + 6],
    values[9 * i + 7],
    values[9 * i + 8]
  ],
  MAT4: (values, i) => [
    values[16 * i + 0],
    values[16 * i + 1],
    values[16 * i + 2],
    values[16 * i + 3],
    values[16 * i + 4],
    values[16 * i + 5],
    values[16 * i + 6],
    values[16 * i + 7],
    values[16 * i + 8],
    values[16 * i + 9],
    values[16 * i + 10],
    values[16 * i + 11],
    values[16 * i + 12],
    values[16 * i + 13],
    values[16 * i + 14],
    values[16 * i + 15]
  ]
};
var PACKER = {
  SCALAR: (x, values, i) => {
    values[i] = x;
  },
  VEC2: (x, values, i) => {
    values[2 * i + 0] = x[0];
    values[2 * i + 1] = x[1];
  },
  VEC3: (x, values, i) => {
    values[3 * i + 0] = x[0];
    values[3 * i + 1] = x[1];
    values[3 * i + 2] = x[2];
  },
  VEC4: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  // TODO: check column major correctness
  MAT2: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  MAT3: (x, values, i) => {
    values[9 * i + 0] = x[0];
    values[9 * i + 1] = x[1];
    values[9 * i + 2] = x[2];
    values[9 * i + 3] = x[3];
    values[9 * i + 4] = x[4];
    values[9 * i + 5] = x[5];
    values[9 * i + 6] = x[6];
    values[9 * i + 7] = x[7];
    values[9 * i + 8] = x[8];
    values[9 * i + 9] = x[9];
  },
  MAT4: (x, values, i) => {
    values[16 * i + 0] = x[0];
    values[16 * i + 1] = x[1];
    values[16 * i + 2] = x[2];
    values[16 * i + 3] = x[3];
    values[16 * i + 4] = x[4];
    values[16 * i + 5] = x[5];
    values[16 * i + 6] = x[6];
    values[16 * i + 7] = x[7];
    values[16 * i + 8] = x[8];
    values[16 * i + 9] = x[9];
    values[16 * i + 10] = x[10];
    values[16 * i + 11] = x[11];
    values[16 * i + 12] = x[12];
    values[16 * i + 13] = x[13];
    values[16 * i + 14] = x[14];
    values[16 * i + 15] = x[15];
  }
};
function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {
  const { componentType } = tile3DAccessor;
  (0, import_loader_utils2.assert)(tile3DAccessor.componentType);
  const type = typeof componentType === "string" ? import_math2.GLType.fromName(componentType) : componentType;
  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
  const unpacker = UNPACKER[tile3DAccessor.type];
  const packer = PACKER[tile3DAccessor.type];
  byteOffset += tile3DAccessor.byteOffset;
  const values = import_math2.GLType.createTypedArray(type, buffer, byteOffset, size * length);
  return {
    values,
    type,
    size,
    unpacker,
    packer
  };
}

// dist/lib/classes/tile-3d-batch-table-hierarchy.js
var defined = (x) => x !== void 0;
function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
  if (!jsonHeader) {
    return null;
  }
  let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
  const legacyHierarchy = jsonHeader.HIERARCHY;
  if (legacyHierarchy) {
    console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
    jsonHeader.extensions = jsonHeader.extensions || {};
    jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
    hierarchy = legacyHierarchy;
  }
  if (!hierarchy) {
    return null;
  }
  return initializeHierarchyValues(hierarchy, binaryBody);
}
function initializeHierarchyValues(hierarchyJson, binaryBody) {
  let i;
  let classId;
  let binaryAccessor;
  const instancesLength = hierarchyJson.instancesLength;
  const classes = hierarchyJson.classes;
  let classIds = hierarchyJson.classIds;
  let parentCounts = hierarchyJson.parentCounts;
  let parentIds = hierarchyJson.parentIds;
  let parentIdsLength = instancesLength;
  if (defined(classIds.byteOffset)) {
    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
    classIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(classIds);
    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
  }
  let parentIndexes;
  if (defined(parentCounts)) {
    if (defined(parentCounts.byteOffset)) {
      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
      parentCounts.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentCounts);
      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
    }
    parentIndexes = new Uint16Array(instancesLength);
    parentIdsLength = 0;
    for (i = 0; i < instancesLength; ++i) {
      parentIndexes[i] = parentIdsLength;
      parentIdsLength += parentCounts[i];
    }
  }
  if (defined(parentIds) && defined(parentIds.byteOffset)) {
    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
    parentIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(parentIds);
    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
  }
  const classesLength = classes.length;
  for (i = 0; i < classesLength; ++i) {
    const classInstancesLength = classes[i].length;
    const properties = classes[i].instances;
    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
    classes[i].instances = combine(binaryProperties, properties);
  }
  const classCounts = new Array(classesLength).fill(0);
  const classIndexes = new Uint16Array(instancesLength);
  for (i = 0; i < instancesLength; ++i) {
    classId = classIds[i];
    classIndexes[i] = classCounts[classId];
    ++classCounts[classId];
  }
  const hierarchy = {
    classes,
    classIds,
    classIndexes,
    parentCounts,
    parentIndexes,
    parentIds
  };
  validateHierarchy(hierarchy);
  return hierarchy;
}
function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
  if (!hierarchy) {
    return;
  }
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  if (parentIds) {
    return endConditionCallback(hierarchy, instanceIndex);
  }
  if (parentCounts > 0) {
    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
  }
  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
}
function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
  const classIds = hierarchy.classIds;
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const instancesLength = classIds.length;
  const visited = scratchVisited;
  visited.length = Math.max(visited.length, instancesLength);
  const visitedMarker = ++marker;
  const stack2 = scratchStack;
  stack2.length = 0;
  stack2.push(instanceIndex);
  while (stack2.length > 0) {
    instanceIndex = stack2.pop();
    if (visited[instanceIndex] === visitedMarker) {
      continue;
    }
    visited[instanceIndex] = visitedMarker;
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined(result)) {
      return result;
    }
    const parentCount = parentCounts[instanceIndex];
    const parentIndex = parentIndexes[instanceIndex];
    for (let i = 0; i < parentCount; ++i) {
      const parentId = parentIds[parentIndex + i];
      if (parentId !== instanceIndex) {
        stack2.push(parentId);
      }
    }
  }
  return null;
}
function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
  let hasParent = true;
  while (hasParent) {
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined(result)) {
      return result;
    }
    const parentId = hierarchy.parentIds[instanceIndex];
    hasParent = parentId !== instanceIndex;
    instanceIndex = parentId;
  }
  throw new Error("traverseHierarchySingleParent");
}
function validateHierarchy(hierarchy) {
  const scratchValidateStack = [];
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  for (let i = 0; i < instancesLength; ++i) {
    validateInstance(hierarchy, i, stack);
  }
}
function validateInstance(hierarchy, instanceIndex, stack2) {
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  if (!defined(parentIds)) {
    return;
  }
  assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);
  assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
  stack2.push(instanceIndex);
  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;
  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
  for (let i = 0; i < parentCount; ++i) {
    const parentId = parentIds[parentIndex + i];
    if (parentId !== instanceIndex) {
      validateInstance(hierarchy, parentId, stack2);
    }
  }
  stack2.pop(instanceIndex);
}

// dist/lib/classes/tile-3d-batch-table.js
function defined2(x) {
  return x !== void 0 && x !== null;
}
var clone = (x, y) => x;
var IGNORED_PROPERTY_FIELDS = {
  HIERARCHY: true,
  // Deprecated HIERARCHY property
  extensions: true,
  extras: true
};
var Tile3DBatchTableParser = class {
  json;
  binary;
  featureCount;
  _extensions;
  // Copy all top-level property fields from the json object, ignoring special fields
  _properties;
  _binaryProperties;
  // TODO: hierarchy support is only partially implemented and not tested
  _hierarchy;
  constructor(json, binary, featureCount, options = {}) {
    var _a;
    (0, import_loader_utils3.assert)(featureCount >= 0);
    this.json = json || {};
    this.binary = binary;
    this.featureCount = featureCount;
    this._extensions = ((_a = this.json) == null ? void 0 : _a.extensions) || {};
    this._properties = {};
    for (const propertyName in this.json) {
      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
        this._properties[propertyName] = this.json[propertyName];
      }
    }
    this._binaryProperties = this._initializeBinaryProperties();
    if (options["3DTILES_batch_table_hierarchy"]) {
      this._hierarchy = initializeHierarchy(this, this.json, this.binary);
    }
  }
  getExtension(extensionName) {
    return this.json && this.json.extensions && this.json.extensions[extensionName];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(batchId, className) {
    this._checkBatchId(batchId);
    (0, import_loader_utils3.assert)(typeof className === "string", className);
    if (this._hierarchy) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        return instanceClass.name === className;
      });
      return defined2(result);
    }
    return false;
  }
  isExactClass(batchId, className) {
    (0, import_loader_utils3.assert)(typeof className === "string", className);
    return this.getExactClassName(batchId) === className;
  }
  getExactClassName(batchId) {
    this._checkBatchId(batchId);
    if (this._hierarchy) {
      const classId = this._hierarchy.classIds[batchId];
      const instanceClass = this._hierarchy.classes[classId];
      return instanceClass.name;
    }
    return void 0;
  }
  hasProperty(batchId, name) {
    this._checkBatchId(batchId);
    (0, import_loader_utils3.assert)(typeof name === "string", name);
    return defined2(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);
  }
  getPropertyNames(batchId, results) {
    this._checkBatchId(batchId);
    results = defined2(results) ? results : [];
    results.length = 0;
    const propertyNames = Object.keys(this._properties);
    results.push(...propertyNames);
    if (this._hierarchy) {
      this._getPropertyNamesInHierarchy(batchId, results);
    }
    return results;
  }
  getProperty(batchId, name) {
    this._checkBatchId(batchId);
    (0, import_loader_utils3.assert)(typeof name === "string", name);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name];
      if (defined2(binaryProperty)) {
        return this._getBinaryProperty(binaryProperty, batchId);
      }
    }
    const propertyValues = this._properties[name];
    if (defined2(propertyValues)) {
      return clone(propertyValues[batchId], true);
    }
    if (this._hierarchy) {
      const hierarchyProperty = this._getHierarchyProperty(batchId, name);
      if (defined2(hierarchyProperty)) {
        return hierarchyProperty;
      }
    }
    return void 0;
  }
  setProperty(batchId, name, value) {
    const featureCount = this.featureCount;
    this._checkBatchId(batchId);
    (0, import_loader_utils3.assert)(typeof name === "string", name);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name];
      if (binaryProperty) {
        this._setBinaryProperty(binaryProperty, batchId, value);
        return;
      }
    }
    if (this._hierarchy) {
      if (this._setHierarchyProperty(this, batchId, name, value)) {
        return;
      }
    }
    let propertyValues = this._properties[name];
    if (!defined2(propertyValues)) {
      this._properties[name] = new Array(featureCount);
      propertyValues = this._properties[name];
    }
    propertyValues[batchId] = clone(value, true);
  }
  // PRIVATE METHODS
  _checkBatchId(batchId) {
    const valid = batchId >= 0 && batchId < this.featureCount;
    if (!valid) {
      throw new Error("batchId not in range [0, featureCount - 1].");
    }
  }
  _getBinaryProperty(binaryProperty, index) {
    return binaryProperty.unpack(binaryProperty.typedArray, index);
  }
  _setBinaryProperty(binaryProperty, index, value) {
    binaryProperty.pack(value, binaryProperty.typedArray, index);
  }
  _initializeBinaryProperties() {
    let binaryProperties = null;
    for (const name in this._properties) {
      const property = this._properties[name];
      const binaryProperty = this._initializeBinaryProperty(name, property);
      if (binaryProperty) {
        binaryProperties = binaryProperties || {};
        binaryProperties[name] = binaryProperty;
      }
    }
    return binaryProperties;
  }
  _initializeBinaryProperty(name, property) {
    if ("byteOffset" in property) {
      const tile3DAccessor = property;
      (0, import_loader_utils3.assert)(this.binary, `Property ${name} requires a batch table binary.`);
      (0, import_loader_utils3.assert)(tile3DAccessor.type, `Property ${name} requires a type.`);
      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: accessor.values,
        componentCount: accessor.size,
        unpack: accessor.unpacker,
        pack: accessor.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(batchId, name) {
    if (!this._hierarchy) {
      return false;
    }
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      return defined2(instances[name]);
    });
    return defined2(result);
  }
  _getPropertyNamesInHierarchy(batchId, results) {
    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      for (const name in instances) {
        if (instances.hasOwnProperty(name)) {
          if (results.indexOf(name) === -1) {
            results.push(name);
          }
        }
      }
    });
  }
  _getHierarchyProperty(batchId, name) {
    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name];
      if (defined2(propertyValues)) {
        if (defined2(propertyValues.typedArray)) {
          return this._getBinaryProperty(propertyValues, indexInClass);
        }
        return clone(propertyValues[indexInClass], true);
      }
      return null;
    });
  }
  _setHierarchyProperty(batchTable, batchId, name, value) {
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name];
      if (defined2(propertyValues)) {
        (0, import_loader_utils3.assert)(instanceIndex === batchId, `Inherited property "${name}" is read-only.`);
        if (defined2(propertyValues.typedArray)) {
          this._setBinaryProperty(propertyValues, indexInClass, value);
        } else {
          propertyValues[indexInClass] = clone(value, true);
        }
        return true;
      }
      return false;
    });
    return defined2(result);
  }
};

// dist/lib/parsers/helpers/parse-3d-tile-header.js
var SIZEOF_UINT32 = 4;
function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {
  const view = new DataView(arrayBuffer);
  tile.magic = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.version = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.byteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  if (tile.version !== 1) {
    throw new Error(`3D Tile Version ${tile.version} not supported`);
  }
  return byteOffset;
}

// dist/lib/parsers/helpers/parse-3d-tile-tables.js
var SIZEOF_UINT322 = 4;
var DEPRECATION_WARNING = "b3dm tile in legacy format.";
function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
  const view = new DataView(arrayBuffer);
  let batchLength;
  tile.header = tile.header || {};
  let featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  if (batchTableJsonByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322 * 2;
    batchLength = featureTableJsonByteLength;
    batchTableJsonByteLength = featureTableBinaryByteLength;
    batchTableBinaryByteLength = 0;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  } else if (batchTableBinaryByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322;
    batchLength = batchTableJsonByteLength;
    batchTableJsonByteLength = featureTableJsonByteLength;
    batchTableBinaryByteLength = featureTableBinaryByteLength;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  }
  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
  tile.header.batchLength = batchLength;
  return byteOffset;
}
function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
  return byteOffset;
}
function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
  const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};
  tile.featureTableJson = {
    BATCH_LENGTH: batchLength || 0
  };
  if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {
    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);
    tile.featureTableJson = JSON.parse(featureTableString);
  }
  byteOffset += featureTableJsonByteLength || 0;
  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength || 0;
  return byteOffset;
}
function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
  const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};
  if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {
    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);
    tile.batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;
    if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {
      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }
  return byteOffset;
}

// dist/lib/parsers/helpers/normalize-3d-tile-colors.js
var import_math3 = require("@loaders.gl/math");
function normalize3DTileColorAttribute(tile, colors, batchTable) {
  if (!colors && (!tile || !tile.batchIds || !batchTable)) {
    return null;
  }
  const { batchIds, isRGB565, pointCount = 0 } = tile;
  if (batchIds && batchTable) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const batchId = batchIds[i];
      const dimensions = batchTable.getProperty(batchId, "dimensions");
      const color = dimensions.map((d) => d * 255);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: import_math3.GL.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && isRGB565) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const color = (0, import_math3.decodeRGB565)(colors[i]);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: import_math3.GL.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && colors.length === pointCount * 3) {
    return {
      type: import_math3.GL.UNSIGNED_BYTE,
      value: colors,
      size: 3,
      normalized: true
    };
  }
  return {
    type: import_math3.GL.UNSIGNED_BYTE,
    value: colors || new Uint8ClampedArray(),
    size: 4,
    normalized: true
  };
}

// dist/lib/parsers/helpers/normalize-3d-tile-normals.js
var import_core = require("@math.gl/core");
var import_math4 = require("@loaders.gl/math");
var scratchNormal = new import_core.Vector3();
function normalize3DTileNormalAttribute(tile, normals) {
  if (!normals) {
    return null;
  }
  if (tile.isOctEncoded16P) {
    const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);
    for (let i = 0; i < (tile.pointsLength || 0); i++) {
      (0, import_math4.octDecode)(normals[i * 2], normals[i * 2 + 1], scratchNormal);
      scratchNormal.toArray(decodedArray, i * 3);
    }
    return {
      type: import_math4.GL.FLOAT,
      size: 2,
      value: decodedArray
    };
  }
  return {
    type: import_math4.GL.FLOAT,
    size: 2,
    value: normals
  };
}

// dist/lib/parsers/helpers/normalize-3d-tile-positions.js
var import_core2 = require("@math.gl/core");
var import_math5 = require("@loaders.gl/math");
function normalize3DTilePositionAttribute(tile, positions, options) {
  if (!tile.isQuantized) {
    return positions;
  }
  if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
    tile.isQuantized = false;
    return decodeQuantizedPositions(tile, positions);
  }
  return {
    type: import_math5.GL.UNSIGNED_SHORT,
    value: positions,
    size: 3,
    normalized: true
  };
}
function decodeQuantizedPositions(tile, positions) {
  const scratchPosition = new import_core2.Vector3();
  const decodedArray = new Float32Array(tile.pointCount * 3);
  for (let i = 0; i < tile.pointCount; i++) {
    scratchPosition.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i * 3);
  }
  return decodedArray;
}

// dist/lib/parsers/parse-3d-tile-point-cloud.js
async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  initializeTile(tile);
  const { featureTable, batchTable } = parsePointCloudTables(tile);
  await parseDraco(tile, featureTable, batchTable, options, context);
  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, batchTable);
  parseNormals(tile, featureTable);
  return byteOffset;
}
function initializeTile(tile) {
  tile.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  tile.isQuantized = false;
  tile.isTranslucent = false;
  tile.isRGB565 = false;
  tile.isOctEncoded16P = false;
}
function parsePointCloudTables(tile) {
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(pointsLength)) {
    throw new Error("POINTS_LENGTH must be defined");
  }
  featureTable.featuresLength = pointsLength;
  tile.featuresLength = pointsLength;
  tile.pointsLength = pointsLength;
  tile.pointCount = pointsLength;
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", import_math6.GL.FLOAT, 3);
  const batchTable = parseBatchIds(tile, featureTable);
  return { featureTable, batchTable };
}
function parsePositions(tile, featureTable, options) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.positions) {
    if (featureTable.hasProperty("POSITION")) {
      tile.attributes.positions = featureTable.getPropertyArray("POSITION", import_math6.GL.FLOAT, 3);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", import_math6.GL.UNSIGNED_SHORT, 3);
      tile.isQuantized = true;
      tile.quantizedRange = (1 << 16) - 1;
      tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", import_math6.GL.FLOAT, 3);
      if (!tile.quantizedVolumeScale) {
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", import_math6.GL.FLOAT, 3);
      if (!tile.quantizedVolumeOffset) {
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
    }
  }
  if (!tile.attributes.positions) {
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
  }
}
function parseColors(tile, featureTable, batchTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.colors) {
    let colors = null;
    if (featureTable.hasProperty("RGBA")) {
      colors = featureTable.getPropertyArray("RGBA", import_math6.GL.UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty("RGB")) {
      colors = featureTable.getPropertyArray("RGB", import_math6.GL.UNSIGNED_BYTE, 3);
    } else if (featureTable.hasProperty("RGB565")) {
      colors = featureTable.getPropertyArray("RGB565", import_math6.GL.UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }
    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
  }
  if (featureTable.hasProperty("CONSTANT_RGBA")) {
    tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", import_math6.GL.UNSIGNED_BYTE, 4);
  }
}
function parseNormals(tile, featureTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.normals) {
    let normals = null;
    if (featureTable.hasProperty("NORMAL")) {
      normals = featureTable.getPropertyArray("NORMAL", import_math6.GL.FLOAT, 3);
    } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
      normals = featureTable.getPropertyArray("NORMAL_OCT16P", import_math6.GL.UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }
    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
  }
}
function parseBatchIds(tile, featureTable) {
  let batchTable = null;
  if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
    tile.batchIds = featureTable.getPropertyArray("BATCH_ID", import_math6.GL.UNSIGNED_SHORT, 1);
    if (tile.batchIds) {
      const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
      if (!batchFeatureLength) {
        throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
      }
      const { batchTableJson, batchTableBinary } = tile;
      batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
    }
  }
  return batchTable;
}
async function parseDraco(tile, featureTable, batchTable, options, context) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;
  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }
  const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    }
    dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
  }
  if (!dracoBuffer) {
    return true;
  }
  const dracoData = {
    buffer: dracoBuffer,
    properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },
    featureTableProperties: dracoFeatureTableProperties,
    batchTableProperties: dracoBatchTableProperties,
    dequantizeInShader: false
  };
  return await loadDraco(tile, dracoData, options, context);
}
async function loadDraco(tile, dracoData, options, context) {
  if (!context) {
    return;
  }
  const dracoOptions = {
    ...options,
    draco: {
      ...options == null ? void 0 : options.draco,
      extraAttributes: dracoData.batchTableProperties || {}
    }
  };
  delete dracoOptions["3d-tiles"];
  const data = await (0, import_loader_utils4.parseFromContext)(dracoData.buffer, import_draco.DracoLoader, dracoOptions, context);
  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
  if (isQuantizedDraco) {
    const quantization = data.POSITION.data.quantization;
    const range = quantization.range;
    tile.quantizedVolumeScale = new import_core3.Vector3(range, range, range);
    tile.quantizedVolumeOffset = new import_core3.Vector3(quantization.minValues);
    tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
    tile.isQuantizedDraco = true;
  }
  if (isOctEncodedDraco) {
    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
    tile.isOctEncodedDraco = true;
  }
  const batchTableAttributes = {};
  if (dracoData.batchTableProperties) {
    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
      if (data.attributes[attributeName] && data.attributes[attributeName].value) {
        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
      }
    }
  }
  tile.attributes = {
    // @ts-expect-error
    positions: decodedPositions,
    // @ts-expect-error
    colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
    // @ts-expect-error
    normals: decodedNormals,
    // @ts-expect-error
    batchIds: decodedBatchIds,
    ...batchTableAttributes
  };
}

// dist/lib/parsers/parse-3d-tile-batched-model.js
var import_math7 = require("@loaders.gl/math");

// dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js
var import_gltf = require("@loaders.gl/gltf");
var import_loader_utils5 = require("@loaders.gl/loader-utils");
var GLTF_FORMAT = {
  URI: 0,
  EMBEDDED: 1
};
function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {
  tile.rotateYtoZ = true;
  const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;
  if (gltfByteLength === 0) {
    throw new Error("glTF byte length must be greater than 0.");
  }
  tile.gltfUpAxis = (options == null ? void 0 : options["3d-tiles"]) && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
  tile.gltfArrayBuffer = (0, import_loader_utils5.sliceArrayBuffer)(arrayBuffer, byteOffset, gltfByteLength);
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  if (byteOffset % 4 === 0) {
  } else {
    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
  }
  return (tile.byteOffset || 0) + (tile.byteLength || 0);
}
async function extractGLTF(tile, gltfFormat, options, context) {
  const tile3DOptions = (options == null ? void 0 : options["3d-tiles"]) || {};
  extractGLTFBufferOrURL(tile, gltfFormat, options);
  if (tile3DOptions.loadGLTF) {
    if (!context) {
      return;
    }
    if (tile.gltfUrl) {
      const { fetch } = context;
      const response = await fetch(tile.gltfUrl, options);
      tile.gltfArrayBuffer = await response.arrayBuffer();
      tile.gltfByteOffset = 0;
    }
    if (tile.gltfArrayBuffer) {
      const gltfWithBuffers = await (0, import_loader_utils5.parseFromContext)(tile.gltfArrayBuffer, import_gltf.GLTFLoader, options, context);
      tile.gltf = (0, import_gltf.postProcessGLTF)(gltfWithBuffers);
      tile.gpuMemoryUsageInBytes = (0, import_gltf._getMemoryUsageGLTF)(tile.gltf);
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
    }
  }
}
function extractGLTFBufferOrURL(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      if (tile.gltfArrayBuffer) {
        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
        const textDecoder = new TextDecoder();
        const gltfUrl = textDecoder.decode(gltfUrlBytes);
        tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
      }
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
      break;
    case GLTF_FORMAT.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}

// dist/lib/parsers/parse-3d-tile-batched-model.js
async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
  const extensions = (_a = tile == null ? void 0 : tile.gltf) == null ? void 0 : _a.extensions;
  if (extensions && extensions.CESIUM_RTC) {
    tile.rtcCenter = extensions.CESIUM_RTC.center;
  }
  return byteOffset;
}
function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", import_math7.GL.FLOAT, 3);
  return byteOffset;
}

// dist/lib/parsers/parse-3d-tile-instanced-model.js
var import_core4 = require("@math.gl/core");
var import_geospatial = require("@math.gl/geospatial");
var import_math8 = require("@loaders.gl/math");
async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, tile.gltfFormat || 0, options, context);
  return byteOffset;
}
function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  if (tile.version !== 1) {
    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
  }
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.gltfFormat = view.getUint32(byteOffset, true);
  byteOffset += 4;
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  if (!((_a = tile == null ? void 0 : tile.header) == null ? void 0 : _a.featureTableJsonByteLength) || tile.header.featureTableJsonByteLength === 0) {
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  }
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
  featureTable.featuresLength = instancesLength;
  if (!Number.isFinite(instancesLength)) {
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  }
  tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", import_math8.GL.FLOAT, 3);
  const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
  return byteOffset;
}
function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
  const instances = new Array(instancesLength);
  const instancePosition = new import_core4.Vector3();
  const instanceNormalRight = new import_core4.Vector3();
  const instanceNormalUp = new import_core4.Vector3();
  const instanceNormalForward = new import_core4.Vector3();
  const instanceRotation = new import_core4.Matrix3();
  const instanceQuaternion = new import_core4.Quaternion();
  const instanceScale = new import_core4.Vector3();
  const instanceTranslationRotationScale = {};
  const instanceTransform = new import_core4.Matrix4();
  const scratch1 = [];
  const scratch2 = [];
  const scratch3 = [];
  const scratch4 = [];
  for (let i = 0; i < instancesLength; i++) {
    let position;
    if (featureTable.hasProperty("POSITION")) {
      position = featureTable.getProperty("POSITION", import_math8.GL.FLOAT, 3, i, instancePosition);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      position = featureTable.getProperty("POSITION_QUANTIZED", import_math8.GL.UNSIGNED_SHORT, 3, i, instancePosition);
      const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", import_math8.GL.FLOAT, 3);
      if (!quantizedVolumeOffset) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", import_math8.GL.FLOAT, 3);
      if (!quantizedVolumeScale) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      const MAX_UNSIGNED_SHORT = 65535;
      for (let j = 0; j < 3; j++) {
        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }
    if (!position) {
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    }
    instancePosition.copy(position);
    instanceTranslationRotationScale.translation = instancePosition;
    tile.normalUp = featureTable.getProperty("NORMAL_UP", import_math8.GL.FLOAT, 3, i, scratch1);
    tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", import_math8.GL.FLOAT, 3, i, scratch2);
    const hasCustomOrientation = false;
    if (tile.normalUp) {
      if (!tile.normalRight) {
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      }
      tile.hasCustomOrientation = true;
    } else {
      tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", import_math8.GL.UNSIGNED_SHORT, 2, i, scratch1);
      tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", import_math8.GL.UNSIGNED_SHORT, 2, i, scratch2);
      if (tile.octNormalUp) {
        if (!tile.octNormalRight) {
          throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
        }
        throw new Error("i3dm: oct-encoded orientation not implemented");
      } else if (tile.eastNorthUp) {
        import_geospatial.Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
        instanceTransform.getRotationMatrix3(instanceRotation);
      } else {
        instanceRotation.identity();
      }
    }
    if (hasCustomOrientation) {
      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
      instanceRotation.setColumn(0, instanceNormalRight);
      instanceRotation.setColumn(1, instanceNormalUp);
      instanceRotation.setColumn(2, instanceNormalForward);
    }
    instanceQuaternion.fromMatrix3(instanceRotation);
    instanceTranslationRotationScale.rotation = instanceQuaternion;
    instanceScale.set(1, 1, 1);
    const scale = featureTable.getProperty("SCALE", import_math8.GL.FLOAT, 1, i, scratch3);
    if (Number.isFinite(scale)) {
      instanceScale.multiplyByScalar(scale);
    }
    const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", import_math8.GL.FLOAT, 3, i, scratch1);
    if (nonUniformScale) {
      instanceScale.scale(nonUniformScale);
    }
    instanceTranslationRotationScale.scale = instanceScale;
    let batchId = featureTable.getProperty("BATCH_ID", import_math8.GL.UNSIGNED_SHORT, 1, i, scratch4);
    if (batchId === void 0) {
      batchId = i;
    }
    const rotationMatrix = new import_core4.Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
    instanceTransform.identity();
    instanceTransform.translate(instanceTranslationRotationScale.translation);
    instanceTransform.multiplyRight(rotationMatrix);
    instanceTransform.scale(instanceTranslationRotationScale.scale);
    const modelMatrix = instanceTransform.clone();
    instances[i] = {
      modelMatrix,
      batchId
    };
  }
  tile.instances = instances;
}

// dist/lib/parsers/parse-3d-tile-composite.js
async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile2) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {
    const subtile = { shape: "tile3d" };
    tile.tiles.push(subtile);
    byteOffset = await parse3DTile2(arrayBuffer, byteOffset, options, context, subtile);
  }
  return byteOffset;
}

// dist/lib/parsers/parse-3d-tile-gltf.js
var import_loader_utils6 = require("@loaders.gl/loader-utils");
var import_gltf2 = require("@loaders.gl/gltf");
async function parseGltf3DTile(tile, arrayBuffer, options, context) {
  var _a, _b;
  tile.rotateYtoZ = true;
  tile.gltfUpAxis = ((_a = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _a.assetGltfUpAxis) ? options["3d-tiles"].assetGltfUpAxis : "Y";
  if ((_b = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _b.loadGLTF) {
    if (!context) {
      return arrayBuffer.byteLength;
    }
    const gltfWithBuffers = await (0, import_loader_utils6.parseFromContext)(arrayBuffer, import_gltf2.GLTFLoader, options, context);
    tile.gltf = (0, import_gltf2.postProcessGLTF)(gltfWithBuffers);
    tile.gpuMemoryUsageInBytes = (0, import_gltf2._getMemoryUsageGLTF)(tile.gltf);
  } else {
    tile.gltfArrayBuffer = arrayBuffer;
  }
  return arrayBuffer.byteLength;
}

// dist/lib/parsers/parse-3d-tile.js
async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = { shape: "tile3d" }) {
  tile.byteOffset = byteOffset;
  tile.type = getMagicString(arrayBuffer, byteOffset);
  switch (tile.type) {
    case TILE3D_TYPE.COMPOSITE:
      return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);
    case TILE3D_TYPE.BATCHED_3D_MODEL:
      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.GLTF:
      return await parseGltf3DTile(tile, arrayBuffer, options, context);
    case TILE3D_TYPE.INSTANCED_3D_MODEL:
      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.POINT_CLOUD:
      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);
    default:
      throw new Error(`3DTileLoader: unknown type ${tile.type}`);
  }
}

// dist/lib/parsers/parse-3d-tile-header.js
var import_loader_utils7 = require("@loaders.gl/loader-utils");

// dist/lib/parsers/helpers/parse-3d-tile-subtree.js
var SUBTREE_FILE_MAGIC = 1952609651;
var SUBTREE_FILE_VERSION = 1;
async function parse3DTilesSubtree(data, options, context) {
  const magic = new Uint32Array(data.slice(0, 4));
  if (magic[0] !== SUBTREE_FILE_MAGIC) {
    throw new Error("Wrong subtree file magic number");
  }
  const version = new Uint32Array(data.slice(4, 8));
  if (version[0] !== SUBTREE_FILE_VERSION) {
    throw new Error("Wrong subtree file verson, must be 1");
  }
  const jsonByteLength = parseUint64Value(data.slice(8, 16));
  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
  const textDecoder = new TextDecoder("utf8");
  const string = textDecoder.decode(stringAttribute);
  const subtree = JSON.parse(string);
  const binaryByteLength = parseUint64Value(data.slice(16, 24));
  let internalBinaryBuffer = new ArrayBuffer(0);
  if (binaryByteLength) {
    internalBinaryBuffer = data.slice(24 + jsonByteLength);
  }
  await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);
  if (Array.isArray(subtree.contentAvailability)) {
    for (const contentAvailability of subtree.contentAvailability) {
      await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);
    }
  } else {
    await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);
  }
  await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);
  return subtree;
}
async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {
  const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;
  if (typeof bufferViewIndex !== "number") {
    return;
  }
  const bufferView = subtree.bufferViews[bufferViewIndex];
  const buffer = subtree.buffers[bufferView.buffer];
  if (!(context == null ? void 0 : context.baseUrl)) {
    throw new Error("Url is not provided");
  }
  if (!context.fetch) {
    throw new Error("fetch is not provided");
  }
  if (buffer.uri) {
    const bufferUri = `${(context == null ? void 0 : context.baseUrl) || ""}/${buffer.uri}`;
    const response = await context.fetch(bufferUri);
    const data = await response.arrayBuffer();
    availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
    return;
  }
  const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);
  availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);
}
function parseUint64Value(buffer) {
  const dataView = new DataView(buffer);
  const left = dataView.getUint32(0, true);
  const right = dataView.getUint32(4, true);
  return left + 2 ** 32 * right;
}

// dist/tile-3d-subtree-loader.js
var Tile3DSubtreeLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: VERSION,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: parse3DTilesSubtree,
  options: {}
};

// dist/lib/parsers/parse-3d-tile-header.js
var import_core8 = require("@loaders.gl/core");
var import_tiles = require("@loaders.gl/tiles");

// dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
var import_core7 = require("@loaders.gl/core");
var import_log = __toESM(require("@probe.gl/log"), 1);

// dist/lib/utils/s2/s2-token-functions.js
var import_long = __toESM(require("long"), 1);
var MAXIMUM_TOKEN_LENGTH = 16;
function getS2CellIdFromToken(token) {
  if (token === "X") {
    token = "";
  }
  const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
  return import_long.default.fromString(paddedToken, true, 16);
}
function getS2TokenFromCellId(cellId) {
  if (cellId.isZero()) {
    return "X";
  }
  let numZeroDigits = cellId.countTrailingZeros();
  const remainder = numZeroDigits % 4;
  numZeroDigits = (numZeroDigits - remainder) / 4;
  const trailingZeroHexChars = numZeroDigits;
  numZeroDigits *= 4;
  const x = cellId.shiftRightUnsigned(numZeroDigits);
  const hexString = x.toString(16).replace(/0+$/, "");
  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
  return zeroString + hexString;
}
function getS2ChildCellId(cellId, index) {
  const newLsb = lsb(cellId).shiftRightUnsigned(2);
  const childCellId = cellId.add(import_long.default.fromNumber(2 * index + 1 - 4).multiply(newLsb));
  return childCellId;
}
function lsb(cellId) {
  return cellId.and(cellId.not().add(1));
}

// dist/lib/utils/s2/s2geometry/s2-geometry.js
var import_long2 = __toESM(require("long"), 1);
var FACE_BITS = 3;
var MAX_LEVEL = 30;
var POS_BITS = 2 * MAX_LEVEL + 1;
var RADIAN_TO_DEGREE = 180 / Math.PI;
function getS2CellFromQuadKey(hilbertQuadkey) {
  if (hilbertQuadkey.length === 0) {
    throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);
  }
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  let level = 0;
  const point = [0, 0];
  for (let i = maxLevel - 1; i >= 0; i--) {
    level = maxLevel - i;
    const bit = position[i];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val, point, rx, ry);
    point[0] += val * rx;
    point[1] += val * ry;
  }
  if (face % 2 === 1) {
    const t = point[0];
    point[0] = point[1];
    point[1] = t;
  }
  return { face, ij: point, level };
}
function getS2QuadkeyFromCellId(cellId) {
  if (cellId.isZero()) {
    return "";
  }
  let bin = cellId.toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long2.default.fromString(faceB, true, 2).toString(10);
  let posS = "";
  if (levelN !== 0) {
    posS = import_long2.default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
  }
  return `${faceS}/${posS}`;
}
function IJToST(ij, level, offsets) {
  const maxSize = 1 << level;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x, y, z]) {
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lng = Math.atan2(y, x);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function rotateAndFlipQuadrant(n, point, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point[0] = n - 1 - point[0];
      point[1] = n - 1 - point[1];
    }
    const x = point[0];
    point[0] = point[1];
    point[1] = x;
  }
}
function getS2LngLatFromS2Cell(s2Cell) {
  const st = IJToST(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
  const uv = STToUV(st);
  const xyz = FaceUVToXYZ(s2Cell.face, uv);
  return XYZToLngLat(xyz);
}

// dist/lib/utils/s2/converters/s2-to-boundary.js
var MAX_RESOLUTION = 100;
function getS2BoundaryFlatFromS2Cell(s2cell) {
  const { face, ij, level } = s2cell;
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}

// dist/lib/utils/s2/s2geometry/s2-cell-utils.js
function getS2Cell(tokenOrKey) {
  const key = getS2QuadKey(tokenOrKey);
  const s2cell = getS2CellFromQuadKey(key);
  return s2cell;
}
function getS2QuadKey(tokenOrKey) {
  if (tokenOrKey.indexOf("/") > 0) {
    return tokenOrKey;
  }
  const id = getS2CellIdFromToken(tokenOrKey);
  return getS2QuadkeyFromCellId(id);
}

// dist/lib/utils/s2/s2-geometry-functions.js
function getS2LngLat(s2Token) {
  const s2cell = getS2Cell(s2Token);
  return getS2LngLatFromS2Cell(s2cell);
}

// dist/lib/utils/s2/converters/s2-to-region.js
function getS2Region(s2cell) {
  let region;
  if (s2cell.face === 2 || s2cell.face === 5) {
    let corners = null;
    let len = 0;
    for (let i = 0; i < 4; i++) {
      const key = `${s2cell.face}/${i}`;
      const cell = getS2Cell(key);
      const corns = getS2BoundaryFlatFromS2Cell(cell);
      if (typeof corners === "undefined" || corners === null)
        corners = new Float64Array(4 * corns.length);
      corners.set(corns, len);
      len += corns.length;
    }
    region = get2DRegionFromS2Corners(corners);
  } else {
    const corners = getS2BoundaryFlatFromS2Cell(s2cell);
    region = get2DRegionFromS2Corners(corners);
  }
  return region;
}
function get2DRegionFromS2Corners(corners) {
  if (corners.length % 2 !== 0) {
    throw new Error("Invalid corners");
  }
  const longitudes = [];
  const latitudes = [];
  for (let i = 0; i < corners.length; i += 2) {
    longitudes.push(corners[i]);
    latitudes.push(corners[i + 1]);
  }
  longitudes.sort((a, b) => a - b);
  latitudes.sort((a, b) => a - b);
  return {
    west: longitudes[0],
    east: longitudes[longitudes.length - 1],
    north: latitudes[latitudes.length - 1],
    south: latitudes[0]
  };
}

// dist/lib/utils/s2/converters/s2-to-obb-points.js
var import_core5 = require("@math.gl/core");
function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
  const min = (heightInfo == null ? void 0 : heightInfo.minimumHeight) || 0;
  const max = (heightInfo == null ? void 0 : heightInfo.maximumHeight) || 0;
  const s2cell = getS2Cell(tokenOrKey);
  const region = getS2Region(s2cell);
  const W = region.west;
  const S = region.south;
  const E = region.east;
  const N = region.north;
  const points = [];
  points.push(new import_core5.Vector3(W, N, min));
  points.push(new import_core5.Vector3(E, N, min));
  points.push(new import_core5.Vector3(E, S, min));
  points.push(new import_core5.Vector3(W, S, min));
  points.push(new import_core5.Vector3(W, N, max));
  points.push(new import_core5.Vector3(E, N, max));
  points.push(new import_core5.Vector3(E, S, max));
  points.push(new import_core5.Vector3(W, S, max));
  return points;
}

// dist/lib/utils/obb/s2-corners-to-obb.js
var import_core6 = require("@math.gl/core");
var import_culling = require("@math.gl/culling");
var import_geospatial2 = require("@math.gl/geospatial");
function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
  const token = s2VolumeInfo.token;
  const heightInfo = {
    minimumHeight: s2VolumeInfo.minimumHeight,
    maximumHeight: s2VolumeInfo.maximumHeight
  };
  const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
  const center = getS2LngLat(token);
  const centerLng = center[0];
  const centerLat = center[1];
  const point = import_geospatial2.Ellipsoid.WGS84.cartographicToCartesian([
    centerLng,
    centerLat,
    heightInfo.maximumHeight
  ]);
  const centerPointAdditional = new import_core6.Vector3(point[0], point[1], point[2]);
  corners.push(centerPointAdditional);
  const obb = (0, import_culling.makeOrientedBoundingBoxFromPoints)(corners);
  const box = [...obb.center, ...obb.halfAxes];
  return box;
}

// dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
var QUADTREE_DIVISION_COUNT = 4;
var OCTREE_DIVISION_COUNT = 8;
var SUBDIVISION_COUNT_MAP = {
  QUADTREE: QUADTREE_DIVISION_COUNT,
  OCTREE: OCTREE_DIVISION_COUNT
};
function getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {
  if (s2VolumeBox == null ? void 0 : s2VolumeBox.box) {
    const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
    const childCellId = getS2ChildCellId(cellId, index);
    const childToken = getS2TokenFromCellId(childCellId);
    const s2ChildVolumeInfo = { ...s2VolumeBox.s2VolumeInfo };
    s2ChildVolumeInfo.token = childToken;
    switch (subdivisionScheme) {
      case "OCTREE":
        const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
        const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
        const sizeZ = delta / 2;
        const midZ = s2VolumeInfo.minimumHeight + delta / 2;
        s2VolumeInfo.minimumHeight = midZ - sizeZ;
        s2VolumeInfo.maximumHeight = midZ + sizeZ;
        break;
      default:
        break;
    }
    const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
    const childS2VolumeBox = {
      box,
      s2VolumeInfo: s2ChildVolumeInfo
    };
    return childS2VolumeBox;
  }
  return void 0;
}
async function parseImplicitTiles(params) {
  const { implicitOptions, parentData = {
    mortonIndex: 0,
    x: 0,
    y: 0,
    z: 0
  }, childIndex = 0, s2VolumeBox, loaderOptions } = params;
  let { subtree, level = 0, globalData = {
    level: 0,
    mortonIndex: 0,
    x: 0,
    y: 0,
    z: 0
  } } = params;
  const { subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath } = implicitOptions;
  const tile = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!maximumLevel) {
    import_log.default.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);
    return tile;
  }
  const lev = level + globalData.level;
  if (lev > maximumLevel) {
    return tile;
  }
  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
  const bitsPerTile = Math.log2(childrenPerTile);
  const childX = childIndex & 1;
  const childY = childIndex >> 1 & 1;
  const childZ = childIndex >> 2 & 1;
  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);
  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
  let childTileX = concatBits(parentData.x, childX, 1);
  let childTileY = concatBits(parentData.y, childY, 1);
  let childTileZ = concatBits(parentData.z, childZ, 1);
  let isChildSubtreeAvailable = false;
  if (level >= subtreeLevels) {
    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
  }
  const x = concatBits(globalData.x, childTileX, level);
  const y = concatBits(globalData.y, childTileY, level);
  const z = concatBits(globalData.z, childTileZ, level);
  if (isChildSubtreeAvailable) {
    const subtreePath = `${basePath}/${subtreesUriTemplate}`;
    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);
    const childSubtree = await (0, import_core7.load)(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);
    subtree = childSubtree;
    globalData = {
      mortonIndex: childTileMortonIndex,
      x: childTileX,
      y: childTileY,
      z: childTileZ,
      level
    };
    childTileMortonIndex = 0;
    tileAvailabilityIndex = 0;
    childTileX = 0;
    childTileY = 0;
    childTileZ = 0;
    level = 0;
  }
  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
  if (!isTileAvailable) {
    return tile;
  }
  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
  if (isContentAvailable) {
    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);
  }
  const childTileLevel = level + 1;
  const pData = { mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ };
  for (let index = 0; index < childrenPerTile; index++) {
    const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);
    const childTileParsed = await parseImplicitTiles({
      subtree,
      implicitOptions,
      loaderOptions,
      parentData: pData,
      childIndex: index,
      level: childTileLevel,
      globalData: { ...globalData },
      s2VolumeBox: childS2VolumeBox
    });
    if (childTileParsed.contentUrl || childTileParsed.children.length) {
      const globalLevel = lev + 1;
      const childCoordinates = { childTileX, childTileY, childTileZ };
      const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, implicitOptions, s2VolumeBox);
      tile.children.push(formattedTile);
    }
  }
  return tile;
}
function getAvailabilityResult(availabilityData, index) {
  let availabilityObject;
  if (Array.isArray(availabilityData)) {
    availabilityObject = availabilityData[0];
    if (availabilityData.length > 1) {
      import_log.default.once('Not supported extension "3DTILES_multiple_contents" has been detected');
    }
  } else {
    availabilityObject = availabilityData;
  }
  if ("constant" in availabilityObject) {
    return Boolean(availabilityObject.constant);
  }
  if (availabilityObject.explicitBitstream) {
    return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);
  }
  return false;
}
function formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {
  const { basePath, refine, getRefine: getRefine2, lodMetricType, getTileType: getTileType2, rootLodMetricValue, rootBoundingVolume } = options;
  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, "");
  const lodMetricValue = rootLodMetricValue / 2 ** level;
  const boundingVolume = (s2VolumeBox == null ? void 0 : s2VolumeBox.box) ? { box: s2VolumeBox.box } : rootBoundingVolume;
  const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);
  return {
    children: tile.children,
    contentUrl: tile.contentUrl,
    content: { uri },
    id: tile.contentUrl,
    refine: getRefine2(refine),
    type: getTileType2(tile),
    lodMetricType,
    lodMetricValue,
    geometricError: lodMetricValue,
    transform: tile.transform,
    boundingVolume: boundingVolumeForChildTile
  };
}
function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
  if (rootBoundingVolume.region) {
    const { childTileX, childTileY, childTileZ } = childCoordinates;
    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
    const boundingVolumesCount = 2 ** level;
    const sizeX = (east - west) / boundingVolumesCount;
    const sizeY = (north - south) / boundingVolumesCount;
    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
    const [childMinimumHeight, childMaximumHeight] = [
      minimumHeight + sizeZ * childTileZ,
      minimumHeight + sizeZ * (childTileZ + 1)
    ];
    return {
      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
    };
  }
  if (rootBoundingVolume.box) {
    return rootBoundingVolume;
  }
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);
}
function concatBits(higher, lower, shift) {
  return (higher << shift) + lower;
}
function replaceContentUrlTemplate(templateUrl, level, x, y, z) {
  const mapUrl = generateMapUrl({ level, x, y, z });
  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
}
function generateMapUrl(items) {
  const mapUrl = {};
  for (const key in items) {
    mapUrl[`{${key}}`] = items[key];
  }
  return mapUrl;
}
function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
  const byteIndex = Math.floor(availabilityIndex / 8);
  const bitIndex = availabilityIndex % 8;
  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
  return bitValue === 1;
}

// dist/lib/parsers/parse-3d-tile-header.js
function getTileType(tile, tileContentUrl = "") {
  if (!tileContentUrl) {
    return import_tiles.TILE_TYPE.EMPTY;
  }
  const contentUrl = tileContentUrl.split("?")[0];
  const fileExtension = contentUrl.split(".").pop();
  switch (fileExtension) {
    case "pnts":
      return import_tiles.TILE_TYPE.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return import_tiles.TILE_TYPE.SCENEGRAPH;
    default:
      return fileExtension || import_tiles.TILE_TYPE.EMPTY;
  }
}
function getRefine(refine) {
  switch (refine) {
    case "REPLACE":
    case "replace":
      return import_tiles.TILE_REFINEMENT.REPLACE;
    case "ADD":
    case "add":
      return import_tiles.TILE_REFINEMENT.ADD;
    default:
      return refine;
  }
}
function resolveUri(uri, basePath) {
  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
  if (urlSchemeRegex.test(basePath)) {
    const url = new URL(uri, `${basePath}/`);
    return decodeURI(url.toString());
  } else if (uri.startsWith("/")) {
    return uri;
  }
  return import_loader_utils7.path.resolve(basePath, uri);
}
function normalizeTileData(tile, basePath) {
  var _a;
  if (!tile) {
    return null;
  }
  let tileContentUrl;
  if (tile.content) {
    const contentUri = tile.content.uri || ((_a = tile.content) == null ? void 0 : _a.url);
    if (typeof contentUri !== "undefined") {
      tileContentUrl = resolveUri(contentUri, basePath);
    }
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: import_tiles.LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine)
  };
  return tilePostprocessed;
}
async function normalizeTileHeaders(tileset, basePath, options) {
  let root = null;
  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);
  if (rootImplicitTilingExtension && tileset.root) {
    root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);
  } else {
    root = normalizeTileData(tileset.root, basePath);
  }
  const stack2 = [];
  stack2.push(root);
  while (stack2.length > 0) {
    const tile = stack2.pop() || {};
    const children = tile.children || [];
    const childrenPostprocessed = [];
    for (const childHeader of children) {
      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
      let childHeaderPostprocessed;
      if (childImplicitTilingExtension) {
        childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);
      } else {
        childHeaderPostprocessed = normalizeTileData(childHeader, basePath);
      }
      if (childHeaderPostprocessed) {
        childrenPostprocessed.push(childHeaderPostprocessed);
        stack2.push(childHeaderPostprocessed);
      }
    }
    tile.children = childrenPostprocessed;
  }
  return root;
}
async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {
  var _a, _b, _c;
  const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;
  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
  const subtree = await (0, import_core8.load)(subtreeUrl, Tile3DSubtreeLoader, options);
  const tileContentUri = (_a = tile.content) == null ? void 0 : _a.uri;
  const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : "";
  const refine = (_b = tileset == null ? void 0 : tileset.root) == null ? void 0 : _b.refine;
  const rootLodMetricValue = tile.geometricError;
  const s2VolumeInfo = (_c = tile.boundingVolume.extensions) == null ? void 0 : _c["3DTILES_bounding_volume_S2"];
  if (s2VolumeInfo) {
    const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
    const s2VolumeBox = { box, s2VolumeInfo };
    tile.boundingVolume = s2VolumeBox;
  }
  const rootBoundingVolume = tile.boundingVolume;
  const implicitOptions = {
    contentUrlTemplate,
    subtreesUriTemplate,
    subdivisionScheme,
    subtreeLevels,
    maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,
    refine,
    basePath,
    lodMetricType: import_tiles.LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    rootLodMetricValue,
    rootBoundingVolume,
    getTileType,
    getRefine
  };
  return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);
}
async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {
  if (!tile) {
    return null;
  }
  const { children, contentUrl } = await parseImplicitTiles({
    subtree: rootSubtree,
    implicitOptions,
    loaderOptions
  });
  let tileContentUrl;
  let tileContent = null;
  if (contentUrl) {
    tileContentUrl = contentUrl;
    tileContent = { uri: contentUrl.replace(`${basePath}/`, "") };
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: import_tiles.LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine),
    content: tileContent || tile.content,
    children
  };
  return tilePostprocessed;
}
function getImplicitTilingExtensionData(tile) {
  var _a;
  return ((_a = tile == null ? void 0 : tile.extensions) == null ? void 0 : _a["3DTILES_implicit_tiling"]) || (tile == null ? void 0 : tile.implicitTiling);
}

// dist/tiles-3d-loader.js
var Tiles3DLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: VERSION,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse,
  options: {
    "3d-tiles": {
      loadGLTF: true,
      decodeQuantizedPositions: false,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function parse(data, options = {}, context) {
  const loaderOptions = options["3d-tiles"] || {};
  let isTileset;
  if (loaderOptions.isTileset === "auto") {
    isTileset = (context == null ? void 0 : context.url) && context.url.indexOf(".json") !== -1;
  } else {
    isTileset = loaderOptions.isTileset;
  }
  return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);
}
async function parseTileset(data, options, context) {
  var _a;
  const tilesetJson = JSON.parse(new TextDecoder().decode(data));
  const tilesetUrl = (context == null ? void 0 : context.url) || "";
  const basePath = getBaseUri(tilesetUrl);
  const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});
  const tilesetJsonPostprocessed = {
    ...tilesetJson,
    shape: "tileset3d",
    loader: Tiles3DLoader,
    url: tilesetUrl,
    queryString: (context == null ? void 0 : context.queryString) || "",
    basePath,
    root: normalizedRoot || tilesetJson.root,
    type: import_tiles2.TILESET_TYPE.TILES3D,
    lodMetricType: import_tiles2.LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: ((_a = tilesetJson.root) == null ? void 0 : _a.geometricError) || 0
  };
  return tilesetJsonPostprocessed;
}
async function parseTile(arrayBuffer, options, context) {
  const tile = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  const byteOffset = 0;
  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);
  return tile.content;
}
function getBaseUri(tilesetUrl) {
  return import_loader_utils8.path.dirname(tilesetUrl);
}

// dist/lib/ion/ion.js
var import_core9 = require("@loaders.gl/core");
var import_loader_utils9 = require("@loaders.gl/loader-utils");
var CESIUM_ION_URL = "https://api.cesium.com/v1/assets";
async function getIonTilesetMetadata(accessToken, assetId) {
  if (!assetId) {
    const assets = await getIonAssets(accessToken);
    for (const item of assets.items) {
      if (item.type === "3DTILES") {
        assetId = item.id;
      }
    }
  }
  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);
  const { type, url } = ionAssetMetadata;
  (0, import_loader_utils9.assert)(type === "3DTILES" && url);
  ionAssetMetadata.headers = {
    Authorization: `Bearer ${ionAssetMetadata.accessToken}`
  };
  return ionAssetMetadata;
}
async function getIonAssets(accessToken) {
  (0, import_loader_utils9.assert)(accessToken);
  const url = CESIUM_ION_URL;
  const headers = { Authorization: `Bearer ${accessToken}` };
  const response = await (0, import_core9.fetchFile)(url, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  return await response.json();
}
async function getIonAssetMetadata(accessToken, assetId) {
  (0, import_loader_utils9.assert)(accessToken, assetId);
  const headers = { Authorization: `Bearer ${accessToken}` };
  const url = `${CESIUM_ION_URL}/${assetId}`;
  let response = await (0, import_core9.fetchFile)(`${url}`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let metadata = await response.json();
  response = await (0, import_core9.fetchFile)(`${url}/endpoint`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  const tilesetInfo = await response.json();
  metadata = {
    ...metadata,
    ...tilesetInfo
  };
  return metadata;
}

// dist/cesium-ion-loader.js
async function preload(url, options = {}) {
  options = options["cesium-ion"] || {};
  const { accessToken } = options;
  let assetId = options.assetId;
  if (!Number.isFinite(assetId)) {
    const matched = url.match(/\/([0-9]+)\/tileset.json/);
    assetId = matched && matched[1];
  }
  return getIonTilesetMetadata(accessToken, assetId);
}
var CesiumIonLoader = {
  ...Tiles3DLoader,
  id: "cesium-ion",
  name: "Cesium Ion",
  // @ts-ignore
  preload,
  parse: async (data, options, context) => {
    options = { ...options };
    options["3d-tiles"] = options["cesium-ion"];
    options.loader = CesiumIonLoader;
    return Tiles3DLoader.parse(data, options, context);
  },
  options: {
    "cesium-ion": {
      ...Tiles3DLoader.options["3d-tiles"],
      accessToken: null
    }
  }
};

// dist/3d-tiles-archive-loader.js
var import_loader_utils10 = require("@loaders.gl/loader-utils");

// dist/3d-tiles-archive/3d-tiles-archive-parser.js
var import_zip2 = require("@loaders.gl/zip");

// dist/3d-tiles-archive/3d-tiles-archive-archive.js
var import_crypto = require("@loaders.gl/crypto");
var import_compression = require("@loaders.gl/compression");
var import_zip = require("@loaders.gl/zip");
var COMPRESSION_METHODS = {
  /** No compression */
  0: (data) => new import_compression.NoCompression().decompress(data),
  /** Deflation */
  8: (data) => new import_compression.DeflateCompression({ raw: true }).decompress(data)
};
var Tiles3DArchive = class extends import_zip.IndexedArchive {
  /** hash info */
  hashTable;
  /**
   * creates Tiles3DArchive handler
   * @param fileProvider - FileProvider with the whole file
   * @param hashTable - hash info
   */
  constructor(fileProvider, hashTable, fileName) {
    super(fileProvider, hashTable, fileName);
    this.hashTable = hashTable;
  }
  /**
   * Returns file with the given path from 3tz archive
   * @param path - path inside the 3tz
   * @returns buffer with ready to use file
   */
  async getFile(path3) {
    let data = await this.getFileBytes(path3.toLocaleLowerCase());
    if (!data) {
      data = await this.getFileBytes(path3);
    }
    if (!data) {
      throw new Error(`No such file in the archive: ${path3}`);
    }
    return data;
  }
  /**
   * Trying to get raw file data by adress
   * @param path - path inside the archive
   * @returns buffer with the raw file data
   */
  async getFileBytes(path3) {
    let uncompressedFile;
    if (this.hashTable) {
      const arrayBuffer = new TextEncoder().encode(path3).buffer;
      const nameHash = await new import_crypto.MD5Hash().hash(arrayBuffer, "hex");
      const byteOffset = this.hashTable[nameHash];
      if (byteOffset === void 0) {
        return null;
      }
      const localFileHeader = await (0, import_zip.parseZipLocalFileHeader)(byteOffset, this.fileProvider);
      if (!localFileHeader) {
        return null;
      }
      const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);
      const compressionMethod = COMPRESSION_METHODS[localFileHeader.compressionMethod];
      if (!compressionMethod) {
        throw Error("Only Deflation compression is supported");
      }
      uncompressedFile = await compressionMethod(compressedFile);
    } else {
      uncompressedFile = await this.getFileWithoutHash(path3);
    }
    return uncompressedFile;
  }
};

// dist/3d-tiles-archive/3d-tiles-archive-parser.js
var parse3DTilesArchive = async (fileProvider, cb) => {
  const hashCDOffset = await (0, import_zip2.searchFromTheEnd)(fileProvider, import_zip2.CD_HEADER_SIGNATURE);
  const cdFileHeader = await (0, import_zip2.parseZipCDFileHeader)(hashCDOffset, fileProvider);
  let hashTable;
  if ((cdFileHeader == null ? void 0 : cdFileHeader.fileName) !== "@3dtilesIndex1@") {
    hashTable = await (0, import_zip2.makeHashTableFromZipHeaders)(fileProvider);
    cb == null ? void 0 : cb("3tz doesnt contain hash file, hash info has been composed according to zip archive headers");
  } else {
    const localFileHeader = await (0, import_zip2.parseZipLocalFileHeader)(cdFileHeader.localHeaderOffset, fileProvider);
    if (!localFileHeader) {
      throw new Error("corrupted 3tz zip archive");
    }
    const fileDataOffset = localFileHeader.fileDataOffset;
    const hashFile = await fileProvider.slice(fileDataOffset, fileDataOffset + localFileHeader.compressedSize);
    hashTable = (0, import_zip2.parseHashTable)(hashFile);
  }
  return new Tiles3DArchive(fileProvider, hashTable);
};

// dist/3d-tiles-archive-loader.js
var VERSION2 = true ? "4.2.0-beta.2" : "latest";
var Tiles3DArchiveFileLoader = {
  dataType: null,
  batchType: null,
  name: "3tz",
  id: "3tz",
  module: "3d-tiles",
  version: VERSION2,
  mimeTypes: ["application/octet-stream", "application/vnd.maxar.archive.3tz+zip"],
  parse: parse3DTilesArchive2,
  extensions: ["3tz"],
  options: {}
};
async function parse3DTilesArchive2(data, options = {}) {
  var _a;
  const archive = await parse3DTilesArchive(new import_loader_utils10.DataViewFile(new DataView(data)));
  return archive.getFile(((_a = options["3d-tiles-archive"]) == null ? void 0 : _a.path) ?? "");
}

// dist/lib/encoders/encode-3d-tile.js
var import_loader_utils15 = require("@loaders.gl/loader-utils");

// dist/lib/encoders/helpers/encode-3d-tile-header.js
var import_loader_utils11 = require("@loaders.gl/loader-utils");
function encode3DTileHeader(tile, dataView, byteOffset) {
  const HEADER_SIZE = 12;
  if (!dataView) {
    return byteOffset + HEADER_SIZE;
  }
  const { magic, version = 1, byteLength = 12 } = tile;
  (0, import_loader_utils11.assert)(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));
  dataView.setUint8(byteOffset + 0, magic[0]);
  dataView.setUint8(byteOffset + 1, magic[1]);
  dataView.setUint8(byteOffset + 2, magic[2]);
  dataView.setUint8(byteOffset + 3, magic[3]);
  dataView.setUint32(byteOffset + 4, version, true);
  dataView.setUint32(byteOffset + 8, byteLength, true);
  byteOffset += HEADER_SIZE;
  return byteOffset;
}
function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {
  if (!dataView) {
    return;
  }
  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true);
}

// dist/lib/encoders/encode-3d-tile-composite.js
function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile2) {
  tile = { magic: MAGIC_ARRAY.COMPOSITE, tiles: [], ...tile };
  const byteOffsetStart = byteOffset;
  byteOffset += encode3DTileHeader(tile, dataView, byteOffset);
  if (dataView) {
    dataView.setUint32(byteOffset, tile.tiles.length, true);
  }
  byteOffset += 4;
  for (let i = 0; i < tile.tiles.length; ++i) {
    byteOffset += encode3DTile2(tile.tiles[i], dataView, byteOffset, options);
  }
  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);
  return byteOffset;
}

// dist/lib/encoders/encode-3d-tile-batched-model.js
var import_loader_utils12 = require("@loaders.gl/loader-utils");
function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {
  const { featuresLength = 0, batchTable } = tile;
  const featureTableJson = {
    BATCH_LENGTH: featuresLength
  };
  const featureTableJsonString = JSON.stringify(featureTableJson);
  const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : "";
  const featureTableJsonByteLength = (0, import_loader_utils12.padToNBytes)(featureTableJsonString.length, 8);
  const batchTableJsonByteLength = batchTableJsonString ? (0, import_loader_utils12.padToNBytes)(batchTableJsonString.length, 8) : 0;
  tile = { magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile };
  const byteOffsetStart = byteOffset;
  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);
  if (dataView) {
    dataView.setUint32(12, featureTableJsonByteLength, true);
    dataView.setUint32(16, 0, true);
    dataView.setUint32(20, batchTableJsonByteLength, true);
    dataView.setUint32(24, 0, true);
  }
  byteOffset += 16;
  byteOffset = (0, import_loader_utils12.copyPaddedStringToDataView)(dataView, byteOffset, featureTableJsonString, 8);
  if (batchTable) {
    byteOffset = (0, import_loader_utils12.copyPaddedStringToDataView)(dataView, byteOffset, batchTableJsonString, 8);
  }
  const gltfEncoded = tile.gltfEncoded;
  if (gltfEncoded) {
    byteOffset = (0, import_loader_utils12.copyBinaryToDataView)(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);
  }
  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);
  return byteOffset;
}

// dist/lib/encoders/encode-3d-tile-instanced-model.js
var import_loader_utils13 = require("@loaders.gl/loader-utils");
function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {
  const { featuresLength = 1, gltfFormat = 1, gltfUri = "" } = tile;
  const gltfUriByteLength = gltfUri.length;
  const featureTableJson = {
    INSTANCES_LENGTH: featuresLength,
    POSITION: new Array(featuresLength * 3).fill(0)
  };
  const featureTableJsonString = JSON.stringify(featureTableJson);
  const featureTableJsonByteLength = featureTableJsonString.length;
  tile = { magic: MAGIC_ARRAY.INSTANCED_MODEL, ...tile };
  const byteOffsetStart = byteOffset;
  byteOffset = encode3DTileHeader(tile, dataView, 0);
  if (dataView) {
    dataView.setUint32(12, featureTableJsonByteLength, true);
    dataView.setUint32(16, 0, true);
    dataView.setUint32(20, 0, true);
    dataView.setUint32(24, 0, true);
    dataView.setUint32(28, gltfFormat, true);
  }
  byteOffset += 20;
  byteOffset += (0, import_loader_utils13.copyStringToDataView)(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);
  byteOffset += (0, import_loader_utils13.copyStringToDataView)(dataView, byteOffset, gltfUri, gltfUriByteLength);
  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);
  return byteOffset;
}

// dist/lib/encoders/encode-3d-tile-point-cloud.js
var import_loader_utils14 = require("@loaders.gl/loader-utils");
var DEFAULT_FEATURE_TABLE_JSON = {
  POINTS_LENGTH: 1,
  POSITIONS: {
    byteOffset: 0
  }
};
function encodePointCloud3DTile(tile, dataView, byteOffset, options) {
  const { featureTableJson = DEFAULT_FEATURE_TABLE_JSON } = tile;
  let featureTableJsonString = JSON.stringify(featureTableJson);
  featureTableJsonString = (0, import_loader_utils14.padStringToByteAlignment)(featureTableJsonString, 4);
  const { featureTableJsonByteLength = featureTableJsonString.length } = tile;
  const featureTableBinary = new ArrayBuffer(12);
  const featureTableBinaryByteLength = featureTableBinary.byteLength;
  tile = { magic: MAGIC_ARRAY.POINT_CLOUD, ...tile };
  const byteOffsetStart = byteOffset;
  byteOffset += encode3DTileHeader(tile, dataView, 0);
  if (dataView) {
    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true);
    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true);
    dataView.setUint32(byteOffset + 8, 0, true);
    dataView.setUint32(byteOffset + 12, 0, true);
  }
  byteOffset += 16;
  byteOffset += (0, import_loader_utils14.copyStringToDataView)(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);
  byteOffset += (0, import_loader_utils14.copyBinaryToDataView)(dataView, byteOffset, featureTableBinary, featureTableBinaryByteLength);
  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);
  return byteOffset;
}

// dist/lib/encoders/encode-3d-tile.js
function encode3DTile(tile, options) {
  const byteLength = encode3DTileToDataView(tile, null, 0, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  encode3DTileToDataView(tile, dataView, 0, options);
  return arrayBuffer;
}
function encode3DTileToDataView(tile, dataView, byteOffset, options) {
  (0, import_loader_utils15.assert)(typeof tile.type === "string");
  switch (tile.type) {
    case TILE3D_TYPE.COMPOSITE:
      return encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTileToDataView);
    case TILE3D_TYPE.POINT_CLOUD:
      return encodePointCloud3DTile(tile, dataView, byteOffset, options);
    case TILE3D_TYPE.BATCHED_3D_MODEL:
      return encodeBatchedModel3DTile(tile, dataView, byteOffset, options);
    case TILE3D_TYPE.INSTANCED_3D_MODEL:
      return encodeInstancedModel3DTile(tile, dataView, byteOffset, options);
    default:
      throw new Error("3D Tiles: unknown tile type");
  }
}

// dist/tile-3d-writer.js
var Tile3DWriter = {
  name: "3D Tile",
  id: "3d-tiles",
  module: "3d-tiles",
  version: VERSION,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  binary: true,
  options: {
    ["3d-tiles"]: {}
  },
  encode: async (tile, options) => encodeSync(tile, options),
  encodeSync
};
function encodeSync(tile, options) {
  return encode3DTile(tile, options);
}
//# sourceMappingURL=index.cjs.map
