{
  "version": 3,
  "sources": ["index.js", "tiles-3d-loader.js", "lib/utils/version.js", "lib/constants.js", "lib/parsers/helpers/parse-utils.js", "lib/parsers/parse-3d-tile-point-cloud.js", "lib/classes/tile-3d-feature-table.js", "lib/classes/tile-3d-batch-table.js", "lib/classes/helpers/tile-3d-accessor-utils.js", "lib/classes/tile-3d-batch-table-hierarchy.js", "lib/parsers/helpers/parse-3d-tile-header.js", "lib/parsers/helpers/parse-3d-tile-tables.js", "lib/parsers/helpers/normalize-3d-tile-colors.js", "lib/parsers/helpers/normalize-3d-tile-normals.js", "lib/parsers/helpers/normalize-3d-tile-positions.js", "lib/parsers/parse-3d-tile-batched-model.js", "lib/parsers/helpers/parse-3d-tile-gltf-view.js", "lib/parsers/parse-3d-tile-instanced-model.js", "lib/parsers/parse-3d-tile-composite.js", "lib/parsers/parse-3d-tile-gltf.js", "lib/parsers/parse-3d-tile.js", "lib/parsers/parse-3d-tile-header.js", "lib/parsers/helpers/parse-3d-tile-subtree.js", "tile-3d-subtree-loader.js", "lib/parsers/helpers/parse-3d-implicit-tiles.js", "lib/utils/s2/s2-token-functions.js", "lib/utils/s2/s2geometry/s2-geometry.js", "lib/utils/s2/converters/s2-to-boundary.js", "lib/utils/s2/s2geometry/s2-cell-utils.js", "lib/utils/s2/s2-geometry-functions.js", "lib/utils/s2/converters/s2-to-region.js", "lib/utils/s2/converters/s2-to-obb-points.js", "lib/utils/obb/s2-corners-to-obb.js", "lib/ion/ion.js", "cesium-ion-loader.js", "3d-tiles-archive-loader.js", "3d-tiles-archive/3d-tiles-archive-parser.js", "3d-tiles-archive/3d-tiles-archive-archive.js", "lib/encoders/encode-3d-tile.js", "lib/encoders/helpers/encode-3d-tile-header.js", "lib/encoders/encode-3d-tile-composite.js", "lib/encoders/encode-3d-tile-batched-model.js", "lib/encoders/encode-3d-tile-instanced-model.js", "lib/encoders/encode-3d-tile-point-cloud.js", "tile-3d-writer.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// LOADERS\nexport { Tiles3DLoader } from \"./tiles-3d-loader.js\";\nexport { CesiumIonLoader } from \"./cesium-ion-loader.js\";\nexport { Tile3DSubtreeLoader } from \"./tile-3d-subtree-loader.js\";\nexport { Tiles3DArchiveFileLoader } from \"./3d-tiles-archive-loader.js\";\n// WRITERS\nexport { Tile3DWriter } from \"./tile-3d-writer.js\";\n// CLASSES\nexport { default as Tile3DFeatureTable } from \"./lib/classes/tile-3d-feature-table.js\";\nexport { default as Tile3DBatchTable } from \"./lib/classes/tile-3d-batch-table.js\";\n// EXPERIMENTAL\nexport { TILE3D_TYPE } from \"./lib/constants.js\";\nexport { getIonTilesetMetadata as _getIonTilesetMetadata } from \"./lib/ion/ion.js\";\nexport { Tiles3DArchive } from \"./3d-tiles-archive/3d-tiles-archive-archive.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { path } from '@loaders.gl/loader-utils';\nimport { TILESET_TYPE, LOD_METRIC_TYPE } from '@loaders.gl/tiles';\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parse3DTile } from \"./lib/parsers/parse-3d-tile.js\";\nimport { normalizeTileHeaders } from \"./lib/parsers/parse-3d-tile-header.js\";\n/**\n * Loader for 3D Tiles\n */\nexport const Tiles3DLoader = {\n    dataType: null,\n    batchType: null,\n    id: '3d-tiles',\n    name: '3D Tiles',\n    module: '3d-tiles',\n    version: VERSION,\n    extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n    mimeTypes: ['application/octet-stream'],\n    tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n    parse,\n    options: {\n        '3d-tiles': {\n            loadGLTF: true,\n            decodeQuantizedPositions: false,\n            isTileset: 'auto',\n            assetGltfUpAxis: null\n        }\n    }\n};\n/** Parses a tileset or tile */\nasync function parse(data, options = {}, context) {\n    // auto detect file type\n    const loaderOptions = options['3d-tiles'] || {};\n    let isTileset;\n    if (loaderOptions.isTileset === 'auto') {\n        isTileset = context?.url && context.url.indexOf('.json') !== -1;\n    }\n    else {\n        isTileset = loaderOptions.isTileset;\n    }\n    return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);\n}\n/** Parse a tileset */\nasync function parseTileset(data, options, context) {\n    const tilesetJson = JSON.parse(new TextDecoder().decode(data));\n    const tilesetUrl = context?.url || '';\n    const basePath = getBaseUri(tilesetUrl);\n    const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});\n    const tilesetJsonPostprocessed = {\n        ...tilesetJson,\n        shape: 'tileset3d',\n        loader: Tiles3DLoader,\n        url: tilesetUrl,\n        queryString: context?.queryString || '',\n        basePath,\n        root: normalizedRoot || tilesetJson.root,\n        type: TILESET_TYPE.TILES3D,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        lodMetricValue: tilesetJson.root?.geometricError || 0\n    };\n    return tilesetJsonPostprocessed;\n}\n/** Parse a tile */\nasync function parseTile(arrayBuffer, options, context) {\n    const tile = {\n        content: {\n            shape: 'tile3d',\n            featureIds: null\n        }\n    };\n    const byteOffset = 0;\n    // @ts-expect-error\n    await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);\n    // @ts-expect-error\n    return tile.content;\n}\n/** Get base name */\nfunction getBaseUri(tilesetUrl) {\n    return path.dirname(tilesetUrl);\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// TILE TYPES\nexport const TILE3D_TYPE = {\n    COMPOSITE: 'cmpt',\n    POINT_CLOUD: 'pnts',\n    BATCHED_3D_MODEL: 'b3dm',\n    INSTANCED_3D_MODEL: 'i3dm',\n    GEOMETRY: 'geom',\n    VECTOR: 'vect',\n    GLTF: 'glTF'\n};\nexport const TILE3D_TYPES = Object.keys(TILE3D_TYPE);\nexport const MAGIC_ARRAY = {\n    BATCHED_MODEL: [98, 51, 100, 109],\n    INSTANCED_MODEL: [105, 51, 100, 109],\n    POINT_CLOUD: [112, 110, 116, 115],\n    COMPOSITE: [99, 109, 112, 116]\n};\n// TILE CONSTANTS\nexport const TILE3D_OPTIMIZATION_HINT = {\n    NOT_COMPUTED: -1,\n    USE_OPTIMIZATION: 1,\n    SKIP_OPTIMIZATION: 0\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { assert } from '@loaders.gl/loader-utils';\n// Decode the JSON binary array into clear text\nexport function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n    assert(arrayBuffer instanceof ArrayBuffer);\n    const textDecoder = new TextDecoder('utf8');\n    const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n    const string = textDecoder.decode(typedArray);\n    return string;\n}\n// Decode the JSON binary array into clear text\nexport function getStringFromTypedArray(typedArray) {\n    assert(ArrayBuffer.isView(typedArray));\n    const textDecoder = new TextDecoder('utf8');\n    const string = textDecoder.decode(typedArray);\n    return string;\n}\nexport function getMagicString(arrayBuffer, byteOffset = 0) {\n    const dataView = new DataView(arrayBuffer);\n    return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { parseFromContext } from '@loaders.gl/loader-utils';\nimport { GL } from '@loaders.gl/math';\nimport { Vector3 } from '@math.gl/core';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { normalize3DTileColorAttribute } from \"./helpers/normalize-3d-tile-colors.js\";\nimport { normalize3DTileNormalAttribute } from \"./helpers/normalize-3d-tile-normals.js\";\nimport { normalize3DTilePositionAttribute } from \"./helpers/normalize-3d-tile-positions.js\";\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n    initializeTile(tile);\n    const { featureTable, batchTable } = parsePointCloudTables(tile);\n    await parseDraco(tile, featureTable, batchTable, options, context);\n    parsePositions(tile, featureTable, options);\n    // @ts-expect-error TODO - do we need to assert on the batch table?\n    parseColors(tile, featureTable, batchTable);\n    parseNormals(tile, featureTable);\n    return byteOffset;\n}\nfunction initializeTile(tile) {\n    // Initialize point cloud tile defaults\n    tile.attributes = {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    tile.isQuantized = false;\n    tile.isTranslucent = false;\n    tile.isRGB565 = false;\n    tile.isOctEncoded16P = false;\n}\nfunction parsePointCloudTables(tile) {\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n    if (!Number.isFinite(pointsLength)) {\n        throw new Error('POINTS_LENGTH must be defined');\n    }\n    featureTable.featuresLength = pointsLength;\n    tile.featuresLength = pointsLength;\n    tile.pointsLength = pointsLength;\n    tile.pointCount = pointsLength;\n    tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n    const batchTable = parseBatchIds(tile, featureTable);\n    return { featureTable, batchTable };\n}\nfunction parsePositions(tile, featureTable, options) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.positions) {\n        if (featureTable.hasProperty('POSITION')) {\n            tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n        }\n        else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n            const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n            tile.isQuantized = true;\n            tile.quantizedRange = (1 << 16) - 1;\n            tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n            if (!tile.quantizedVolumeScale) {\n                throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n            }\n            tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n            if (!tile.quantizedVolumeOffset) {\n                throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n            }\n            tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n        }\n    }\n    if (!tile.attributes.positions) {\n        throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n    }\n}\nfunction parseColors(tile, featureTable, batchTable) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.colors) {\n        let colors = null;\n        if (featureTable.hasProperty('RGBA')) {\n            colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n            tile.isTranslucent = true;\n        }\n        else if (featureTable.hasProperty('RGB')) {\n            colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n        }\n        else if (featureTable.hasProperty('RGB565')) {\n            colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n            tile.isRGB565 = true;\n        }\n        tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n    }\n    if (featureTable.hasProperty('CONSTANT_RGBA')) {\n        tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n    }\n}\nfunction parseNormals(tile, featureTable) {\n    tile.attributes = tile.attributes || {\n        positions: null,\n        colors: null,\n        normals: null,\n        batchIds: null\n    };\n    if (!tile.attributes.normals) {\n        let normals = null;\n        if (featureTable.hasProperty('NORMAL')) {\n            normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n        }\n        else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n            normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n            tile.isOctEncoded16P = true;\n        }\n        tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n    }\n}\nfunction parseBatchIds(tile, featureTable) {\n    let batchTable = null;\n    if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n        tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n        if (tile.batchIds) {\n            const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n            if (!batchFeatureLength) {\n                throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n            }\n            const { batchTableJson, batchTableBinary } = tile;\n            batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n        }\n    }\n    return batchTable;\n}\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n    let dracoBuffer;\n    let dracoFeatureTableProperties;\n    let dracoBatchTableProperties;\n    const batchTableDraco = tile.batchTableJson &&\n        tile.batchTableJson.extensions &&\n        tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n    if (batchTableDraco) {\n        dracoBatchTableProperties = batchTableDraco.properties;\n    }\n    const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n    if (featureTableDraco) {\n        dracoFeatureTableProperties = featureTableDraco.properties;\n        const dracoByteOffset = featureTableDraco.byteOffset;\n        const dracoByteLength = featureTableDraco.byteLength;\n        if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n            throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n        }\n        dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n        tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n        tile.hasColors =\n            Number.isFinite(dracoFeatureTableProperties.RGB) ||\n                Number.isFinite(dracoFeatureTableProperties.RGBA);\n        tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n        tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n        tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n    }\n    if (!dracoBuffer) {\n        return true;\n    }\n    const dracoData = {\n        buffer: dracoBuffer,\n        properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },\n        featureTableProperties: dracoFeatureTableProperties,\n        batchTableProperties: dracoBatchTableProperties,\n        dequantizeInShader: false\n    };\n    return await loadDraco(tile, dracoData, options, context);\n}\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n    if (!context) {\n        return;\n    }\n    const dracoOptions = {\n        ...options,\n        draco: {\n            ...options?.draco,\n            extraAttributes: dracoData.batchTableProperties || {}\n        }\n    };\n    // The entire tileset might be included, too expensive to serialize\n    delete dracoOptions['3d-tiles'];\n    const data = await parseFromContext(dracoData.buffer, DracoLoader, dracoOptions, context);\n    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n    // @ts-expect-error\n    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n    // @ts-expect-error\n    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n    if (isQuantizedDraco) {\n        // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n        // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n        // @ts-expect-error This doesn't look right\n        const quantization = data.POSITION.data.quantization;\n        const range = quantization.range;\n        tile.quantizedVolumeScale = new Vector3(range, range, range);\n        tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n        tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n        tile.isQuantizedDraco = true;\n    }\n    if (isOctEncodedDraco) {\n        // @ts-expect-error This doesn't look right\n        tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n        tile.isOctEncodedDraco = true;\n    }\n    // Extra batch table attributes\n    const batchTableAttributes = {};\n    if (dracoData.batchTableProperties) {\n        for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n            if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n                batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n            }\n        }\n    }\n    tile.attributes = {\n        // @ts-expect-error\n        positions: decodedPositions,\n        // @ts-expect-error\n        colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n        // @ts-expect-error\n        normals: decodedNormals,\n        // @ts-expect-error\n        batchIds: decodedBatchIds,\n        ...batchTableAttributes\n    };\n}\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { GL, GLType } from '@loaders.gl/math';\n// Reference:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/1de96d087f0b17575eb1a3f736407b348c765d59/Source/Scene/Cesium3DTileFeatureTable.js\nexport default class Tile3DFeatureTable {\n    json;\n    buffer;\n    featuresLength = 0;\n    _cachedTypedArrays = {};\n    constructor(featureTableJson, featureTableBinary) {\n        this.json = featureTableJson;\n        this.buffer = featureTableBinary;\n    }\n    getExtension(extensionName) {\n        return this.json.extensions && this.json.extensions[extensionName];\n    }\n    hasProperty(propertyName) {\n        return Boolean(this.json[propertyName]);\n    }\n    getGlobalProperty(propertyName, componentType = GL.UNSIGNED_INT, componentLength = 1) {\n        const jsonValue = this.json[propertyName];\n        if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n            return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);\n        }\n        return jsonValue;\n    }\n    getPropertyArray(propertyName, componentType, componentLength) {\n        const jsonValue = this.json[propertyName];\n        if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n            if ('componentType' in jsonValue) {\n                componentType = GLType.fromName(jsonValue.componentType);\n            }\n            return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);\n        }\n        return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n    }\n    getProperty(propertyName, componentType, componentLength, featureId, result) {\n        const jsonValue = this.json[propertyName];\n        if (!jsonValue) {\n            return jsonValue;\n        }\n        const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n        if (componentLength === 1) {\n            return typedArray[featureId];\n        }\n        for (let i = 0; i < componentLength; ++i) {\n            result[i] = typedArray[componentLength * featureId + i];\n        }\n        return result;\n    }\n    // HELPERS\n    _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n        const cachedTypedArrays = this._cachedTypedArrays;\n        let typedArray = cachedTypedArrays[propertyName];\n        if (!typedArray) {\n            typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);\n            cachedTypedArrays[propertyName] = typedArray;\n        }\n        return typedArray;\n    }\n    _getTypedArrayFromArray(propertyName, componentType, array) {\n        const cachedTypedArrays = this._cachedTypedArrays;\n        let typedArray = cachedTypedArrays[propertyName];\n        if (!typedArray) {\n            typedArray = GLType.createTypedArray(componentType, array);\n            cachedTypedArrays[propertyName] = typedArray;\n        }\n        return typedArray;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { assert } from '@loaders.gl/loader-utils';\nimport { createTypedArrayFromAccessor } from \"./helpers/tile-3d-accessor-utils.js\";\nimport { initializeHierarchy, traverseHierarchy } from \"./tile-3d-batch-table-hierarchy.js\";\nfunction defined(x) {\n    return x !== undefined && x !== null;\n}\nconst clone = (x, y) => x;\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n    HIERARCHY: true, // Deprecated HIERARCHY property\n    extensions: true,\n    extras: true\n};\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n    json;\n    binary;\n    featureCount;\n    _extensions;\n    // Copy all top-level property fields from the json object, ignoring special fields\n    _properties;\n    _binaryProperties;\n    // TODO: hierarchy support is only partially implemented and not tested\n    _hierarchy;\n    constructor(json, binary, featureCount, options = {}) {\n        assert(featureCount >= 0);\n        this.json = json || {};\n        this.binary = binary;\n        this.featureCount = featureCount;\n        this._extensions = this.json?.extensions || {};\n        // Copy all top-level property fields from the json object, ignoring special fields\n        this._properties = {};\n        for (const propertyName in this.json) {\n            if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n                this._properties[propertyName] = this.json[propertyName];\n            }\n        }\n        this._binaryProperties = this._initializeBinaryProperties();\n        // TODO: hierarchy support is only partially implemented and not tested\n        if (options['3DTILES_batch_table_hierarchy']) {\n            this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n        }\n    }\n    getExtension(extensionName) {\n        return this.json && this.json.extensions && this.json.extensions[extensionName];\n    }\n    memorySizeInBytes() {\n        return 0;\n    }\n    isClass(batchId, className) {\n        this._checkBatchId(batchId);\n        assert(typeof className === 'string', className);\n        // extension: 3DTILES_batch_table_hierarchy\n        if (this._hierarchy) {\n            // PERFORMANCE_IDEA : cache results in the ancestor classes\n            //   to speed up this check if this area becomes a hotspot\n            // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n            const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n                const classId = hierarchy.classIds[instanceIndex];\n                const instanceClass = hierarchy.classes[classId];\n                return instanceClass.name === className;\n            });\n            return defined(result);\n        }\n        return false;\n    }\n    isExactClass(batchId, className) {\n        assert(typeof className === 'string', className);\n        return this.getExactClassName(batchId) === className;\n    }\n    getExactClassName(batchId) {\n        this._checkBatchId(batchId);\n        // extension: 3DTILES_batch_table_hierarchy\n        if (this._hierarchy) {\n            const classId = this._hierarchy.classIds[batchId];\n            const instanceClass = this._hierarchy.classes[classId];\n            return instanceClass.name;\n        }\n        return undefined;\n    }\n    hasProperty(batchId, name) {\n        this._checkBatchId(batchId);\n        assert(typeof name === 'string', name);\n        return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n    }\n    getPropertyNames(batchId, results) {\n        this._checkBatchId(batchId);\n        results = defined(results) ? results : [];\n        results.length = 0;\n        const propertyNames = Object.keys(this._properties);\n        results.push(...propertyNames);\n        if (this._hierarchy) {\n            this._getPropertyNamesInHierarchy(batchId, results);\n        }\n        return results;\n    }\n    getProperty(batchId, name) {\n        this._checkBatchId(batchId);\n        assert(typeof name === 'string', name);\n        if (this._binaryProperties) {\n            const binaryProperty = this._binaryProperties[name];\n            if (defined(binaryProperty)) {\n                return this._getBinaryProperty(binaryProperty, batchId);\n            }\n        }\n        const propertyValues = this._properties[name];\n        if (defined(propertyValues)) {\n            return clone(propertyValues[batchId], true);\n        }\n        // EXTENSION: 3DTILES_batch_table_hierarchy\n        if (this._hierarchy) {\n            const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n            if (defined(hierarchyProperty)) {\n                return hierarchyProperty;\n            }\n        }\n        return undefined;\n    }\n    setProperty(batchId, name, value) {\n        const featureCount = this.featureCount;\n        this._checkBatchId(batchId);\n        assert(typeof name === 'string', name);\n        if (this._binaryProperties) {\n            const binaryProperty = this._binaryProperties[name];\n            if (binaryProperty) {\n                this._setBinaryProperty(binaryProperty, batchId, value);\n                return;\n            }\n        }\n        // EXTENSION: 3DTILES_batch_table_hierarchy\n        if (this._hierarchy) {\n            if (this._setHierarchyProperty(this, batchId, name, value)) {\n                return;\n            }\n        }\n        let propertyValues = this._properties[name];\n        if (!defined(propertyValues)) {\n            // Property does not exist. Create it.\n            this._properties[name] = new Array(featureCount);\n            propertyValues = this._properties[name];\n        }\n        propertyValues[batchId] = clone(value, true);\n    }\n    // PRIVATE METHODS\n    _checkBatchId(batchId) {\n        const valid = batchId >= 0 && batchId < this.featureCount;\n        if (!valid) {\n            throw new Error('batchId not in range [0, featureCount - 1].');\n        }\n    }\n    _getBinaryProperty(binaryProperty, index) {\n        return binaryProperty.unpack(binaryProperty.typedArray, index);\n    }\n    _setBinaryProperty(binaryProperty, index, value) {\n        binaryProperty.pack(value, binaryProperty.typedArray, index);\n    }\n    _initializeBinaryProperties() {\n        let binaryProperties = null;\n        for (const name in this._properties) {\n            const property = this._properties[name];\n            const binaryProperty = this._initializeBinaryProperty(name, property);\n            // Store any information needed to access the binary data, including the typed array,\n            // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n            if (binaryProperty) {\n                binaryProperties = binaryProperties || {};\n                binaryProperties[name] = binaryProperty;\n            }\n        }\n        return binaryProperties;\n    }\n    _initializeBinaryProperty(name, property) {\n        if ('byteOffset' in property) {\n            // This is a binary property\n            const tile3DAccessor = property;\n            assert(this.binary, `Property ${name} requires a batch table binary.`);\n            assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n            const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n            // Store any information needed to access the binary data, including the typed array,\n            // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n            return {\n                typedArray: accessor.values,\n                componentCount: accessor.size,\n                unpack: accessor.unpacker,\n                pack: accessor.packer\n            };\n        }\n        return null;\n    }\n    //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n    _hasPropertyInHierarchy(batchId, name) {\n        if (!this._hierarchy) {\n            return false;\n        }\n        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n            const classId = hierarchy.classIds[instanceIndex];\n            const instances = hierarchy.classes[classId].instances;\n            return defined(instances[name]);\n        });\n        return defined(result);\n    }\n    _getPropertyNamesInHierarchy(batchId, results) {\n        traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n            const classId = hierarchy.classIds[instanceIndex];\n            const instances = hierarchy.classes[classId].instances;\n            for (const name in instances) {\n                if (instances.hasOwnProperty(name)) {\n                    if (results.indexOf(name) === -1) {\n                        results.push(name);\n                    }\n                }\n            }\n        });\n    }\n    _getHierarchyProperty(batchId, name) {\n        return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n            const classId = hierarchy.classIds[instanceIndex];\n            const instanceClass = hierarchy.classes[classId];\n            const indexInClass = hierarchy.classIndexes[instanceIndex];\n            const propertyValues = instanceClass.instances[name];\n            if (defined(propertyValues)) {\n                if (defined(propertyValues.typedArray)) {\n                    return this._getBinaryProperty(propertyValues, indexInClass);\n                }\n                return clone(propertyValues[indexInClass], true);\n            }\n            return null;\n        });\n    }\n    _setHierarchyProperty(batchTable, batchId, name, value) {\n        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n            const classId = hierarchy.classIds[instanceIndex];\n            const instanceClass = hierarchy.classes[classId];\n            const indexInClass = hierarchy.classIndexes[instanceIndex];\n            const propertyValues = instanceClass.instances[name];\n            if (defined(propertyValues)) {\n                assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n                if (defined(propertyValues.typedArray)) {\n                    this._setBinaryProperty(propertyValues, indexInClass, value);\n                }\n                else {\n                    propertyValues[indexInClass] = clone(value, true);\n                }\n                return true;\n            }\n            return false;\n        });\n        return defined(result);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { GLType } from '@loaders.gl/math'; // '@math.gl/geometry';\nimport { assert } from '@loaders.gl/loader-utils';\nconst COMPONENTS_PER_ATTRIBUTE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\n// TODO - could just return typed array views...\n// prettier-ignore\nconst UNPACKER = {\n    SCALAR: (values, i) => values[i],\n    VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],\n    VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],\n    VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],\n    // TODO: check column major\n    MAT2: (values, i) => [\n        values[4 * i + 0], values[4 * i + 1],\n        values[4 * i + 2], values[4 * i + 3]\n    ],\n    MAT3: (values, i) => [\n        values[9 * i + 0], values[9 * i + 1], values[9 * i + 2],\n        values[9 * i + 3], values[9 * i + 4], values[9 * i + 5],\n        values[9 * i + 6], values[9 * i + 7], values[9 * i + 8]\n    ],\n    MAT4: (values, i) => [\n        values[16 * i + 0], values[16 * i + 1], values[16 * i + 2], values[16 * i + 3],\n        values[16 * i + 4], values[16 * i + 5], values[16 * i + 6], values[16 * i + 7],\n        values[16 * i + 8], values[16 * i + 9], values[16 * i + 10], values[16 * i + 11],\n        values[16 * i + 12], values[16 * i + 13], values[16 * i + 14], values[16 * i + 15]\n    ]\n};\nconst PACKER = {\n    SCALAR: (x, values, i) => {\n        values[i] = x;\n    },\n    VEC2: (x, values, i) => {\n        values[2 * i + 0] = x[0];\n        values[2 * i + 1] = x[1];\n    },\n    VEC3: (x, values, i) => {\n        values[3 * i + 0] = x[0];\n        values[3 * i + 1] = x[1];\n        values[3 * i + 2] = x[2];\n    },\n    VEC4: (x, values, i) => {\n        values[4 * i + 0] = x[0];\n        values[4 * i + 1] = x[1];\n        values[4 * i + 2] = x[2];\n        values[4 * i + 3] = x[3];\n    },\n    // TODO: check column major correctness\n    MAT2: (x, values, i) => {\n        values[4 * i + 0] = x[0];\n        values[4 * i + 1] = x[1];\n        values[4 * i + 2] = x[2];\n        values[4 * i + 3] = x[3];\n    },\n    MAT3: (x, values, i) => {\n        values[9 * i + 0] = x[0];\n        values[9 * i + 1] = x[1];\n        values[9 * i + 2] = x[2];\n        values[9 * i + 3] = x[3];\n        values[9 * i + 4] = x[4];\n        values[9 * i + 5] = x[5];\n        values[9 * i + 6] = x[6];\n        values[9 * i + 7] = x[7];\n        values[9 * i + 8] = x[8];\n        values[9 * i + 9] = x[9];\n    },\n    MAT4: (x, values, i) => {\n        values[16 * i + 0] = x[0];\n        values[16 * i + 1] = x[1];\n        values[16 * i + 2] = x[2];\n        values[16 * i + 3] = x[3];\n        values[16 * i + 4] = x[4];\n        values[16 * i + 5] = x[5];\n        values[16 * i + 6] = x[6];\n        values[16 * i + 7] = x[7];\n        values[16 * i + 8] = x[8];\n        values[16 * i + 9] = x[9];\n        values[16 * i + 10] = x[10];\n        values[16 * i + 11] = x[11];\n        values[16 * i + 12] = x[12];\n        values[16 * i + 13] = x[13];\n        values[16 * i + 14] = x[14];\n        values[16 * i + 15] = x[15];\n    }\n};\nexport function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {\n    const { componentType } = tile3DAccessor;\n    assert(tile3DAccessor.componentType);\n    const type = typeof componentType === 'string' ? GLType.fromName(componentType) : componentType;\n    const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];\n    const unpacker = UNPACKER[tile3DAccessor.type];\n    const packer = PACKER[tile3DAccessor.type];\n    byteOffset += tile3DAccessor.byteOffset;\n    const values = GLType.createTypedArray(type, buffer, byteOffset, size * length);\n    return {\n        values,\n        type,\n        size,\n        unpacker,\n        packer\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = (x) => x !== undefined;\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n    if (!jsonHeader) {\n        return null;\n    }\n    let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n    const legacyHierarchy = jsonHeader.HIERARCHY;\n    if (legacyHierarchy) {\n        // eslint-disable-next-line\n        console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n        jsonHeader.extensions = jsonHeader.extensions || {};\n        jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n        hierarchy = legacyHierarchy;\n    }\n    if (!hierarchy) {\n        return null;\n    }\n    return initializeHierarchyValues(hierarchy, binaryBody);\n}\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n    let i;\n    let classId;\n    let binaryAccessor;\n    const instancesLength = hierarchyJson.instancesLength;\n    const classes = hierarchyJson.classes;\n    let classIds = hierarchyJson.classIds;\n    let parentCounts = hierarchyJson.parentCounts;\n    let parentIds = hierarchyJson.parentIds;\n    let parentIdsLength = instancesLength;\n    if (defined(classIds.byteOffset)) {\n        classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n        classIds.type = AttributeType.SCALAR;\n        binaryAccessor = getBinaryAccessor(classIds);\n        classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);\n    }\n    let parentIndexes;\n    if (defined(parentCounts)) {\n        if (defined(parentCounts.byteOffset)) {\n            parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n            parentCounts.type = AttributeType.SCALAR;\n            binaryAccessor = getBinaryAccessor(parentCounts);\n            parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);\n        }\n        parentIndexes = new Uint16Array(instancesLength);\n        parentIdsLength = 0;\n        for (i = 0; i < instancesLength; ++i) {\n            parentIndexes[i] = parentIdsLength;\n            parentIdsLength += parentCounts[i];\n        }\n    }\n    if (defined(parentIds) && defined(parentIds.byteOffset)) {\n        parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n        parentIds.type = AttributeType.SCALAR;\n        binaryAccessor = getBinaryAccessor(parentIds);\n        parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);\n    }\n    const classesLength = classes.length;\n    for (i = 0; i < classesLength; ++i) {\n        const classInstancesLength = classes[i].length;\n        const properties = classes[i].instances;\n        const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n        classes[i].instances = combine(binaryProperties, properties);\n    }\n    const classCounts = new Array(classesLength).fill(0);\n    const classIndexes = new Uint16Array(instancesLength);\n    for (i = 0; i < instancesLength; ++i) {\n        classId = classIds[i];\n        classIndexes[i] = classCounts[classId];\n        ++classCounts[classId];\n    }\n    const hierarchy = {\n        classes,\n        classIds,\n        classIndexes,\n        parentCounts,\n        parentIndexes,\n        parentIds\n    };\n    validateHierarchy(hierarchy);\n    return hierarchy;\n}\n// HELPER CODE\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n    if (!hierarchy) {\n        return;\n    }\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    if (parentIds) {\n        return endConditionCallback(hierarchy, instanceIndex);\n    }\n    if (parentCounts > 0) {\n        return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n    }\n    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n    const classIds = hierarchy.classIds;\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    const parentIndexes = hierarchy.parentIndexes;\n    const instancesLength = classIds.length;\n    // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n    // Use a marker value to indicate that an instance has been visited, which increments with each run.\n    // This is more efficient than clearing the visited array every time.\n    const visited = scratchVisited;\n    visited.length = Math.max(visited.length, instancesLength);\n    const visitedMarker = ++marker;\n    const stack = scratchStack;\n    stack.length = 0;\n    stack.push(instanceIndex);\n    while (stack.length > 0) {\n        instanceIndex = stack.pop();\n        if (visited[instanceIndex] === visitedMarker) {\n            // This instance has already been visited, stop traversal\n            continue;\n        }\n        visited[instanceIndex] = visitedMarker;\n        const result = endConditionCallback(hierarchy, instanceIndex);\n        if (defined(result)) {\n            // The end condition was met, stop the traversal and return the result\n            return result;\n        }\n        const parentCount = parentCounts[instanceIndex];\n        const parentIndex = parentIndexes[instanceIndex];\n        for (let i = 0; i < parentCount; ++i) {\n            const parentId = parentIds[parentIndex + i];\n            // Stop the traversal when the instance has no parent (its parentId equals itself)\n            // else add the parent to the stack to continue the traversal.\n            if (parentId !== instanceIndex) {\n                stack.push(parentId);\n            }\n        }\n    }\n    return null;\n}\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n    let hasParent = true;\n    while (hasParent) {\n        const result = endConditionCallback(hierarchy, instanceIndex);\n        if (defined(result)) {\n            // The end condition was met, stop the traversal and return the result\n            return result;\n        }\n        const parentId = hierarchy.parentIds[instanceIndex];\n        hasParent = parentId !== instanceIndex;\n        instanceIndex = parentId;\n    }\n    throw new Error('traverseHierarchySingleParent');\n}\n// DEBUG CODE\nfunction validateHierarchy(hierarchy) {\n    const scratchValidateStack = [];\n    const classIds = hierarchy.classIds;\n    const instancesLength = classIds.length;\n    for (let i = 0; i < instancesLength; ++i) {\n        validateInstance(hierarchy, i, stack);\n    }\n}\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n    const parentCounts = hierarchy.parentCounts;\n    const parentIds = hierarchy.parentIds;\n    const parentIndexes = hierarchy.parentIndexes;\n    const classIds = hierarchy.classIds;\n    const instancesLength = classIds.length;\n    if (!defined(parentIds)) {\n        // No need to validate if there are no parents\n        return;\n    }\n    assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);\n    assert(stack.indexOf(instanceIndex) === -1, 'Circular dependency detected in the batch table hierarchy.');\n    stack.push(instanceIndex);\n    const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n    const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n    for (let i = 0; i < parentCount; ++i) {\n        const parentId = parentIds[parentIndex + i];\n        // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n        if (parentId !== instanceIndex) {\n            validateInstance(hierarchy, parentId, stack);\n        }\n    }\n    stack.pop(instanceIndex);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\nconst SIZEOF_UINT32 = 4;\n/* PARSE FIXED HEADER:\nPopulates\n  magic, // identifies type of tile\n  type, // String version of magic\n  version,\n  byteLength\n */\nexport function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {\n    const view = new DataView(arrayBuffer);\n    tile.magic = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    tile.version = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    tile.byteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    // TODO - move version check into each tile parser?\n    if (tile.version !== 1) {\n        throw new Error(`3D Tile Version ${tile.version} not supported`);\n    }\n    return byteOffset; // Indicates where the parsing ended\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { getStringFromArrayBuffer } from \"./parse-utils.js\";\nconst SIZEOF_UINT32 = 4;\nconst DEPRECATION_WARNING = 'b3dm tile in legacy format.';\n// eslint-disable-next-line max-statements\nexport function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n    const view = new DataView(arrayBuffer);\n    let batchLength;\n    tile.header = tile.header || {};\n    let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n    byteOffset += SIZEOF_UINT32;\n    // First legacy header format - [batchLength] [batchTableByteLength] ('batchTableJsonByteLength': JSON starts with a quotation mark or the glTF magic)\n    // Second legacy format - [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength] (Second legacy format is similar as first but here we check 'batchTableBinaryByteLength' instead)\n    // Current header format - [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n    // First byte will be 0x22 or 0x67. The minimum uint32 expected is 0x22000000 = 570425344 = 570MB.\n    if (batchTableJsonByteLength >= 570425344) {\n        byteOffset -= SIZEOF_UINT32 * 2;\n        batchLength = featureTableJsonByteLength;\n        batchTableJsonByteLength = featureTableBinaryByteLength;\n        batchTableBinaryByteLength = 0;\n        featureTableJsonByteLength = 0;\n        featureTableBinaryByteLength = 0;\n        console.warn(DEPRECATION_WARNING); // eslint-disable-line\n    }\n    else if (batchTableBinaryByteLength >= 570425344) {\n        byteOffset -= SIZEOF_UINT32;\n        batchLength = batchTableJsonByteLength;\n        batchTableJsonByteLength = featureTableJsonByteLength;\n        batchTableBinaryByteLength = featureTableBinaryByteLength;\n        featureTableJsonByteLength = 0;\n        featureTableBinaryByteLength = 0;\n        console.warn(DEPRECATION_WARNING); // eslint-disable-line\n    }\n    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;\n    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;\n    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;\n    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;\n    tile.header.batchLength = batchLength;\n    return byteOffset;\n}\nexport function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);\n    byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);\n    return byteOffset;\n}\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n    const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};\n    tile.featureTableJson = {\n        BATCH_LENGTH: batchLength || 0\n    };\n    if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {\n        const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);\n        tile.featureTableJson = JSON.parse(featureTableString);\n    }\n    byteOffset += featureTableJsonByteLength || 0;\n    tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n    byteOffset += featureTableBinaryByteLength || 0;\n    /*\n    const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);\n  \n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    featureTable.featuresLength = batchLength;\n    */\n    return byteOffset;\n}\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n    const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};\n    if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {\n        const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);\n        tile.batchTableJson = JSON.parse(batchTableString);\n        byteOffset += batchTableJsonByteLength;\n        if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {\n            // Has a batch table binary\n            tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n            // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n            tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n            byteOffset += batchTableBinaryByteLength;\n        }\n    }\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { decodeRGB565, GL } from '@loaders.gl/math';\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n    // no colors defined\n    if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n        return null;\n    }\n    const { batchIds, isRGB565, pointCount = 0 } = tile;\n    // Batch table, look up colors in table\n    if (batchIds && batchTable) {\n        const colorArray = new Uint8ClampedArray(pointCount * 3);\n        for (let i = 0; i < pointCount; i++) {\n            const batchId = batchIds[i];\n            // TODO figure out what is `dimensions` used for\n            const dimensions = batchTable.getProperty(batchId, 'dimensions');\n            const color = dimensions.map((d) => d * 255);\n            colorArray[i * 3] = color[0];\n            colorArray[i * 3 + 1] = color[1];\n            colorArray[i * 3 + 2] = color[2];\n        }\n        return {\n            type: GL.UNSIGNED_BYTE,\n            value: colorArray,\n            size: 3,\n            normalized: true\n        };\n    }\n    // RGB565 case, convert to RGB\n    if (colors && isRGB565) {\n        const colorArray = new Uint8ClampedArray(pointCount * 3);\n        for (let i = 0; i < pointCount; i++) {\n            const color = decodeRGB565(colors[i]);\n            colorArray[i * 3] = color[0];\n            colorArray[i * 3 + 1] = color[1];\n            colorArray[i * 3 + 2] = color[2];\n        }\n        return {\n            type: GL.UNSIGNED_BYTE,\n            value: colorArray,\n            size: 3,\n            normalized: true\n        };\n    }\n    // RGB case (tile.isTranslucent)\n    if (colors && colors.length === pointCount * 3) {\n        return {\n            type: GL.UNSIGNED_BYTE,\n            value: colors,\n            size: 3,\n            normalized: true\n        };\n    }\n    // DEFAULT: RGBA case\n    return {\n        type: GL.UNSIGNED_BYTE,\n        value: colors || new Uint8ClampedArray(),\n        size: 4,\n        normalized: true\n    };\n}\n/* eslint-enable complexity*/\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { GL, octDecode } from '@loaders.gl/math';\nconst scratchNormal = new Vector3();\nexport function normalize3DTileNormalAttribute(tile, normals) {\n    if (!normals) {\n        return null;\n    }\n    if (tile.isOctEncoded16P) {\n        const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);\n        for (let i = 0; i < (tile.pointsLength || 0); i++) {\n            octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal);\n            // @ts-ignore\n            scratchNormal.toArray(decodedArray, i * 3);\n        }\n        return {\n            type: GL.FLOAT,\n            size: 2,\n            value: decodedArray\n        };\n    }\n    return {\n        type: GL.FLOAT,\n        size: 2,\n        value: normals\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { GL } from '@loaders.gl/math';\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n    if (!tile.isQuantized) {\n        return positions;\n    }\n    // For quantized posititions, either expand to Float32Array or return custom accessor\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n    // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n    if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n        tile.isQuantized = false;\n        return decodeQuantizedPositions(tile, positions);\n    }\n    // Default: Use normalized shorts directly, no copying/processing.\n    // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n    return {\n        type: GL.UNSIGNED_SHORT,\n        value: positions,\n        size: 3,\n        normalized: true\n    };\n}\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n    const scratchPosition = new Vector3();\n    const decodedArray = new Float32Array(tile.pointCount * 3);\n    for (let i = 0; i < tile.pointCount; i++) {\n        // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n        scratchPosition\n            .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n            .scale(1 / tile.quantizedRange)\n            .multiply(tile.quantizedVolumeScale)\n            .add(tile.quantizedVolumeOffset)\n            .toArray(decodedArray, i * 3);\n    }\n    return decodedArray;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { GL } from '@loaders.gl/math'; // math.gl/geometry;\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\n// import Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { parse3DTileGLTFViewSync, extractGLTF, GLTF_FORMAT } from \"./helpers/parse-3d-tile-gltf-view.js\";\nexport async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);\n    await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);\n    const extensions = tile?.gltf?.extensions;\n    if (extensions && extensions.CESIUM_RTC) {\n        tile.rtcCenter = extensions.CESIUM_RTC.center;\n    }\n    return byteOffset;\n}\nfunction parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\nimport { GLTFLoader, postProcessGLTF, _getMemoryUsageGLTF } from '@loaders.gl/gltf';\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nexport const GLTF_FORMAT = {\n    URI: 0,\n    EMBEDDED: 1\n};\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n    // Set flags\n    // glTF models need to be rotated from Y to Z up\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n    tile.rotateYtoZ = true;\n    // Assume glTF consumes rest of tile\n    const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;\n    if (gltfByteLength === 0) {\n        throw new Error('glTF byte length must be greater than 0.');\n    }\n    // Save gltf up axis\n    tile.gltfUpAxis =\n        options?.['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis\n            ? options['3d-tiles'].assetGltfUpAxis\n            : 'Y';\n    // TODO - We can avoid copy if already 4-byte aligned...\n    // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n    tile.gltfByteOffset = 0;\n    tile.gltfByteLength = gltfByteLength;\n    if (byteOffset % 4 === 0) {\n        // tile.gltfArrayBuffer = arrayBuffer;\n        // tile.gltfByteOffset = byteOffset;\n        // tile.gltfByteLength = gltfByteLength;\n    }\n    else {\n        // Create a copy of the glb so that it is 4-byte aligned\n        // eslint-disable-next-line\n        console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n    }\n    // Entire tile is consumed\n    return (tile.byteOffset || 0) + (tile.byteLength || 0);\n}\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n    const tile3DOptions = options?.['3d-tiles'] || {};\n    extractGLTFBufferOrURL(tile, gltfFormat, options);\n    if (tile3DOptions.loadGLTF) {\n        if (!context) {\n            return;\n        }\n        if (tile.gltfUrl) {\n            const { fetch } = context;\n            const response = await fetch(tile.gltfUrl, options);\n            tile.gltfArrayBuffer = await response.arrayBuffer();\n            tile.gltfByteOffset = 0;\n        }\n        if (tile.gltfArrayBuffer) {\n            // TODO - Should handle byteOffset... However, not used now...\n            const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);\n            tile.gltf = postProcessGLTF(gltfWithBuffers);\n            tile.gpuMemoryUsageInBytes = _getMemoryUsageGLTF(tile.gltf);\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n        }\n    }\n}\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n    switch (gltfFormat) {\n        case GLTF_FORMAT.URI:\n            // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n            // This removes all white space and null characters from the end of the string.\n            if (tile.gltfArrayBuffer) {\n                const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n                const textDecoder = new TextDecoder();\n                const gltfUrl = textDecoder.decode(gltfUrlBytes);\n                tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n            }\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n            break;\n        case GLTF_FORMAT.EMBEDDED:\n            break;\n        default:\n            throw new Error('b3dm: Illegal glTF format field');\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3, Matrix4, Quaternion } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { GL } from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from \"../classes/tile-3d-feature-table.js\";\nimport Tile3DBatchTable from \"../classes/tile-3d-batch-table.js\";\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from \"./helpers/parse-3d-tile-tables.js\";\nimport { parse3DTileGLTFViewSync, extractGLTF } from \"./helpers/parse-3d-tile-gltf-view.js\";\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n    await extractGLTF(tile, tile.gltfFormat || 0, options, context);\n    return byteOffset;\n}\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    if (tile.version !== 1) {\n        throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n    }\n    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n    const view = new DataView(arrayBuffer);\n    tile.gltfFormat = view.getUint32(byteOffset, true);\n    byteOffset += 4;\n    // PARSE FEATURE TABLE\n    byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n    // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n    if (!tile?.header?.featureTableJsonByteLength || tile.header.featureTableJsonByteLength === 0) {\n        throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n    }\n    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n    const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n    featureTable.featuresLength = instancesLength;\n    if (!Number.isFinite(instancesLength)) {\n        throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n    }\n    tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n    tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n    const batchTable = new Tile3DBatchTable(tile.batchTableJson, tile.batchTableBinary, instancesLength);\n    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n    return byteOffset;\n}\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n    const instances = new Array(instancesLength);\n    const instancePosition = new Vector3();\n    const instanceNormalRight = new Vector3();\n    const instanceNormalUp = new Vector3();\n    const instanceNormalForward = new Vector3();\n    const instanceRotation = new Matrix3();\n    const instanceQuaternion = new Quaternion();\n    const instanceScale = new Vector3();\n    const instanceTranslationRotationScale = {};\n    const instanceTransform = new Matrix4();\n    const scratch1 = [];\n    const scratch2 = [];\n    const scratch3 = [];\n    const scratch4 = [];\n    for (let i = 0; i < instancesLength; i++) {\n        let position;\n        // Get the instance position\n        if (featureTable.hasProperty('POSITION')) {\n            position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n        }\n        else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n            position = featureTable.getProperty('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3, i, instancePosition);\n            const quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n            if (!quantizedVolumeOffset) {\n                throw new Error('i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n            }\n            const quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n            if (!quantizedVolumeScale) {\n                throw new Error('i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n            }\n            const MAX_UNSIGNED_SHORT = 65535.0;\n            for (let j = 0; j < 3; j++) {\n                position[j] =\n                    (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n            }\n        }\n        if (!position) {\n            throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n        }\n        instancePosition.copy(position);\n        // @ts-expect-error\n        instanceTranslationRotationScale.translation = instancePosition;\n        // Get the instance rotation\n        tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n        tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n        const hasCustomOrientation = false;\n        if (tile.normalUp) {\n            if (!tile.normalRight) {\n                throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n            }\n            // Vector3.unpack(normalUp, 0, instanceNormalUp);\n            // Vector3.unpack(normalRight, 0, instanceNormalRight);\n            tile.hasCustomOrientation = true;\n        }\n        else {\n            tile.octNormalUp = featureTable.getProperty('NORMAL_UP_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch1);\n            tile.octNormalRight = featureTable.getProperty('NORMAL_RIGHT_OCT32P', GL.UNSIGNED_SHORT, 2, i, scratch2);\n            if (tile.octNormalUp) {\n                if (!tile.octNormalRight) {\n                    throw new Error('i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P');\n                }\n                throw new Error('i3dm: oct-encoded orientation not implemented');\n                /*\n                AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n                AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n                hasCustomOrientation = true;\n                */\n            }\n            else if (tile.eastNorthUp) {\n                Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n                instanceTransform.getRotationMatrix3(instanceRotation);\n            }\n            else {\n                instanceRotation.identity();\n            }\n        }\n        if (hasCustomOrientation) {\n            instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n            instanceRotation.setColumn(0, instanceNormalRight);\n            instanceRotation.setColumn(1, instanceNormalUp);\n            instanceRotation.setColumn(2, instanceNormalForward);\n        }\n        instanceQuaternion.fromMatrix3(instanceRotation);\n        // @ts-expect-error\n        instanceTranslationRotationScale.rotation = instanceQuaternion;\n        // Get the instance scale\n        instanceScale.set(1.0, 1.0, 1.0);\n        const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i, scratch3);\n        if (Number.isFinite(scale)) {\n            instanceScale.multiplyByScalar(scale);\n        }\n        const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n        if (nonUniformScale) {\n            instanceScale.scale(nonUniformScale);\n        }\n        // @ts-expect-error\n        instanceTranslationRotationScale.scale = instanceScale;\n        // Get the batchId\n        let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i, scratch4);\n        if (batchId === undefined) {\n            // If BATCH_ID semantic is undefined, batchId is just the instance number\n            batchId = i;\n        }\n        // @ts-expect-error\n        const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n        // Create the model matrix and the instance\n        instanceTransform.identity();\n        // @ts-expect-error\n        instanceTransform.translate(instanceTranslationRotationScale.translation);\n        instanceTransform.multiplyRight(rotationMatrix);\n        // @ts-expect-error\n        instanceTransform.scale(instanceTranslationRotationScale.scale);\n        const modelMatrix = instanceTransform.clone();\n        instances[i] = {\n            modelMatrix,\n            batchId\n        };\n    }\n    tile.instances = instances;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\nimport { parse3DTileHeaderSync } from \"./helpers/parse-3d-tile-header.js\";\n// eslint-disable-next-line max-params\nexport async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile) {\n    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n    const view = new DataView(arrayBuffer);\n    // Extract number of tiles\n    tile.tilesLength = view.getUint32(byteOffset, true);\n    byteOffset += 4;\n    // extract each tile from the byte stream\n    tile.tiles = [];\n    while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {\n        const subtile = { shape: 'tile3d' };\n        tile.tiles.push(subtile);\n        byteOffset = await parse3DTile(arrayBuffer, byteOffset, options, context, subtile);\n        // TODO - do we need to add any padding in between tiles?\n    }\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT license\n// Copyright (c) vis.gl contributors\nimport { parseFromContext } from '@loaders.gl/loader-utils';\nimport { _getMemoryUsageGLTF, GLTFLoader, postProcessGLTF } from '@loaders.gl/gltf';\nexport async function parseGltf3DTile(tile, arrayBuffer, options, context) {\n    // Set flags\n    // glTF models need to be rotated from Y to Z up\n    // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n    tile.rotateYtoZ = true;\n    // Save gltf up axis\n    tile.gltfUpAxis = options?.['3d-tiles']?.assetGltfUpAxis\n        ? options['3d-tiles'].assetGltfUpAxis\n        : 'Y';\n    if (options?.['3d-tiles']?.loadGLTF) {\n        if (!context) {\n            return arrayBuffer.byteLength;\n        }\n        const gltfWithBuffers = await parseFromContext(arrayBuffer, GLTFLoader, options, context);\n        tile.gltf = postProcessGLTF(gltfWithBuffers);\n        tile.gpuMemoryUsageInBytes = _getMemoryUsageGLTF(tile.gltf);\n    }\n    else {\n        tile.gltfArrayBuffer = arrayBuffer;\n    }\n    return arrayBuffer.byteLength;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { TILE3D_TYPE } from \"../constants.js\";\nimport { getMagicString } from \"./helpers/parse-utils.js\";\nimport { parsePointCloud3DTile } from \"./parse-3d-tile-point-cloud.js\";\nimport { parseBatchedModel3DTile } from \"./parse-3d-tile-batched-model.js\";\nimport { parseInstancedModel3DTile } from \"./parse-3d-tile-instanced-model.js\";\nimport { parseComposite3DTile } from \"./parse-3d-tile-composite.js\";\nimport { parseGltf3DTile } from \"./parse-3d-tile-gltf.js\";\n// Extracts\nexport async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = { shape: 'tile3d' }) {\n    tile.byteOffset = byteOffset;\n    tile.type = getMagicString(arrayBuffer, byteOffset);\n    switch (tile.type) {\n        case TILE3D_TYPE.COMPOSITE:\n            // Note: We pass this function as argument so that embedded tiles can be parsed recursively\n            return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);\n        case TILE3D_TYPE.BATCHED_3D_MODEL:\n            return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n        case TILE3D_TYPE.GLTF:\n            return await parseGltf3DTile(tile, arrayBuffer, options, context);\n        case TILE3D_TYPE.INSTANCED_3D_MODEL:\n            return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n        case TILE3D_TYPE.POINT_CLOUD:\n            return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);\n        default:\n            throw new Error(`3DTileLoader: unknown type ${tile.type}`); // eslint-disable-line\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { path } from '@loaders.gl/loader-utils';\nimport { Tile3DSubtreeLoader } from \"../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from \"./helpers/parse-3d-implicit-tiles.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../utils/obb/s2-corners-to-obb.js\";\nfunction getTileType(tile, tileContentUrl = '') {\n    if (!tileContentUrl) {\n        return TILE_TYPE.EMPTY;\n    }\n    const contentUrl = tileContentUrl.split('?')[0]; // Discard query string\n    const fileExtension = contentUrl.split('.').pop();\n    switch (fileExtension) {\n        case 'pnts':\n            return TILE_TYPE.POINTCLOUD;\n        case 'i3dm':\n        case 'b3dm':\n        case 'glb':\n        case 'gltf':\n            return TILE_TYPE.SCENEGRAPH;\n        default:\n            return fileExtension || TILE_TYPE.EMPTY;\n    }\n}\nfunction getRefine(refine) {\n    switch (refine) {\n        case 'REPLACE':\n        case 'replace':\n            return TILE_REFINEMENT.REPLACE;\n        case 'ADD':\n        case 'add':\n            return TILE_REFINEMENT.ADD;\n        default:\n            return refine;\n    }\n}\nfunction resolveUri(uri, basePath) {\n    // url scheme per RFC3986\n    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n    if (urlSchemeRegex.test(basePath)) {\n        const url = new URL(uri, `${basePath}/`);\n        return decodeURI(url.toString());\n    }\n    else if (uri.startsWith('/')) {\n        return uri;\n    }\n    return path.resolve(basePath, uri);\n}\nexport function normalizeTileData(tile, basePath) {\n    if (!tile) {\n        return null;\n    }\n    let tileContentUrl;\n    if (tile.content) {\n        const contentUri = tile.content.uri || tile.content?.url;\n        if (typeof contentUri !== 'undefined') {\n            // sparse implicit tilesets may not define content for all nodes\n            tileContentUrl = resolveUri(contentUri, basePath);\n        }\n    }\n    const tilePostprocessed = {\n        ...tile,\n        id: tileContentUrl,\n        contentUrl: tileContentUrl,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        lodMetricValue: tile.geometricError,\n        transformMatrix: tile.transform,\n        type: getTileType(tile, tileContentUrl),\n        refine: getRefine(tile.refine)\n    };\n    return tilePostprocessed;\n}\n// normalize tile headers\nexport async function normalizeTileHeaders(tileset, basePath, options) {\n    let root = null;\n    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);\n    if (rootImplicitTilingExtension && tileset.root) {\n        root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);\n    }\n    else {\n        root = normalizeTileData(tileset.root, basePath);\n    }\n    const stack = [];\n    stack.push(root);\n    while (stack.length > 0) {\n        const tile = stack.pop() || {};\n        const children = tile.children || [];\n        const childrenPostprocessed = [];\n        for (const childHeader of children) {\n            const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);\n            let childHeaderPostprocessed;\n            if (childImplicitTilingExtension) {\n                childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);\n            }\n            else {\n                childHeaderPostprocessed = normalizeTileData(childHeader, basePath);\n            }\n            if (childHeaderPostprocessed) {\n                childrenPostprocessed.push(childHeaderPostprocessed);\n                stack.push(childHeaderPostprocessed);\n            }\n        }\n        tile.children = childrenPostprocessed;\n    }\n    return root;\n}\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {\n    const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;\n    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);\n    const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);\n    const tileContentUri = tile.content?.uri;\n    const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : '';\n    const refine = tileset?.root?.refine;\n    // @ts-ignore\n    const rootLodMetricValue = tile.geometricError;\n    // Replace tile.boundingVolume with the the bounding volume specified by the extensions['3DTILES_bounding_volume_S2']\n    const s2VolumeInfo = tile.boundingVolume.extensions?.['3DTILES_bounding_volume_S2'];\n    if (s2VolumeInfo) {\n        const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);\n        const s2VolumeBox = { box, s2VolumeInfo };\n        tile.boundingVolume = s2VolumeBox;\n    }\n    const rootBoundingVolume = tile.boundingVolume;\n    const implicitOptions = {\n        contentUrlTemplate,\n        subtreesUriTemplate,\n        subdivisionScheme,\n        subtreeLevels,\n        maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,\n        refine,\n        basePath,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        rootLodMetricValue,\n        rootBoundingVolume,\n        getTileType,\n        getRefine\n    };\n    return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);\n}\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {\n    if (!tile) {\n        return null;\n    }\n    const { children, contentUrl } = await parseImplicitTiles({\n        subtree: rootSubtree,\n        implicitOptions,\n        loaderOptions\n    });\n    let tileContentUrl;\n    let tileContent = null;\n    if (contentUrl) {\n        tileContentUrl = contentUrl;\n        tileContent = { uri: contentUrl.replace(`${basePath}/`, '') };\n    }\n    const tilePostprocessed = {\n        ...tile,\n        id: tileContentUrl,\n        contentUrl: tileContentUrl,\n        lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n        lodMetricValue: tile.geometricError,\n        transformMatrix: tile.transform,\n        type: getTileType(tile, tileContentUrl),\n        refine: getRefine(tile.refine),\n        content: tileContent || tile.content,\n        children\n    };\n    return tilePostprocessed;\n}\n/**\n * Implicit Tiling data can be in 3DTILES_implicit_tiling for 3DTiles v.Next or directly in implicitTiling object for 3DTiles v1.1.\n * Spec 3DTiles v.Next - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * Spec 3DTiles v.1.1 - https://github.com/CesiumGS/3d-tiles/tree/draft-1.1/specification/ImplicitTiling\n * @param tile\n * @returns\n */\nfunction getImplicitTilingExtensionData(tile) {\n    return tile?.extensions?.['3DTILES_implicit_tiling'] || tile?.implicitTiling;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nconst SUBTREE_FILE_MAGIC = 0x74627573;\nconst SUBTREE_FILE_VERSION = 1;\n/**\n * Parse subtree file\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subtree-file-format\n * @param data\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport default async function parse3DTilesSubtree(data, options, context) {\n    const magic = new Uint32Array(data.slice(0, 4));\n    if (magic[0] !== SUBTREE_FILE_MAGIC) {\n        throw new Error('Wrong subtree file magic number');\n    }\n    const version = new Uint32Array(data.slice(4, 8));\n    if (version[0] !== SUBTREE_FILE_VERSION) {\n        throw new Error('Wrong subtree file verson, must be 1');\n    }\n    const jsonByteLength = parseUint64Value(data.slice(8, 16));\n    const stringAttribute = new Uint8Array(data, 24, jsonByteLength);\n    const textDecoder = new TextDecoder('utf8');\n    const string = textDecoder.decode(stringAttribute);\n    const subtree = JSON.parse(string);\n    const binaryByteLength = parseUint64Value(data.slice(16, 24));\n    let internalBinaryBuffer = new ArrayBuffer(0);\n    if (binaryByteLength) {\n        internalBinaryBuffer = data.slice(24 + jsonByteLength);\n    }\n    await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);\n    if (Array.isArray(subtree.contentAvailability)) {\n        for (const contentAvailability of subtree.contentAvailability) {\n            await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);\n        }\n    }\n    else {\n        await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);\n    }\n    await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);\n    return subtree;\n}\n/**\n * Load explicit bitstream for subtree availability data.\n * @param subtree - subtree data\n * @param availabilityObject - tileAvailability / contentAvailability / childSubtreeAvailability object\n * @param internalBinaryBuffer - subtree binary buffer\n * @param context - loaders.gl context\n */\nexport async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {\n    const bufferViewIndex = Number.isFinite(availabilityObject.bitstream)\n        ? availabilityObject.bitstream\n        : availabilityObject.bufferView;\n    if (typeof bufferViewIndex !== 'number') {\n        return;\n    }\n    const bufferView = subtree.bufferViews[bufferViewIndex];\n    const buffer = subtree.buffers[bufferView.buffer];\n    if (!context?.baseUrl) {\n        throw new Error('Url is not provided');\n    }\n    if (!context.fetch) {\n        throw new Error('fetch is not provided');\n    }\n    // External bitstream loading\n    if (buffer.uri) {\n        const bufferUri = `${context?.baseUrl || ''}/${buffer.uri}`;\n        const response = await context.fetch(bufferUri);\n        const data = await response.arrayBuffer();\n        availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);\n        return;\n    }\n    const bufferStart = subtree.buffers\n        .slice(0, bufferView.buffer)\n        .reduce((offset, buf) => offset + buf.byteLength, 0);\n    availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);\n}\n/**\n * Parse buffer to return uint64 value\n * @param buffer\n * @returns 64-bit value until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Value(buffer) {\n    const dataView = new DataView(buffer);\n    const left = dataView.getUint32(0, true);\n    const right = dataView.getUint32(4, true);\n    // combine the two 32-bit values\n    return left + 2 ** 32 * right;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport parse3DTilesSubtree from \"./lib/parsers/helpers/parse-3d-tile-subtree.js\";\nimport { VERSION } from \"./lib/utils/version.js\";\n/**\n * Loader for 3D Tiles Subtree\n */\nexport const Tile3DSubtreeLoader = {\n    dataType: null,\n    batchType: null,\n    id: '3d-tiles-subtree',\n    name: '3D Tiles Subtree',\n    module: '3d-tiles',\n    version: VERSION,\n    extensions: ['subtree'],\n    mimeTypes: ['application/octet-stream'],\n    tests: ['subtree'],\n    parse: parse3DTilesSubtree,\n    options: {}\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Tile3DSubtreeLoader } from \"../../../tile-3d-subtree-loader.js\";\nimport { load } from '@loaders.gl/core';\nimport { default as log } from '@probe.gl/log';\nimport { getS2CellIdFromToken, getS2ChildCellId, getS2TokenFromCellId } from \"../../utils/s2/index.js\";\nimport { convertS2BoundingVolumetoOBB } from \"../../utils/obb/s2-corners-to-obb.js\";\nconst QUADTREE_DIVISION_COUNT = 4;\nconst OCTREE_DIVISION_COUNT = 8;\nconst SUBDIVISION_COUNT_MAP = {\n    QUADTREE: QUADTREE_DIVISION_COUNT,\n    OCTREE: OCTREE_DIVISION_COUNT\n};\nfunction getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {\n    if (s2VolumeBox?.box) {\n        // Check if the BoundingVolume is of type \"box\"\n        const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);\n        const childCellId = getS2ChildCellId(cellId, index);\n        const childToken = getS2TokenFromCellId(childCellId);\n        // Clone object. Note, s2VolumeInfo is a plain object that doesn't contain any nested object.\n        // So, we can use the Spread Operator to make a shallow copy of the object.\n        const s2ChildVolumeInfo = { ...s2VolumeBox.s2VolumeInfo };\n        s2ChildVolumeInfo.token = childToken; // replace the token with the child's one\n        // In case of QUADTREE the sizeZ should NOT be changed!\n        // https://portal.ogc.org/files/102132\n        // A quadtree divides space only on the x and y dimensions.\n        // It divides each tile into 4 smaller tiles where the x and y dimensions are halved.\n        // The quadtree z minimum and maximum remain unchanged.\n        switch (subdivisionScheme) {\n            case 'OCTREE':\n                const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;\n                const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;\n                const sizeZ = delta / 2.0; // It's a next level (a child)\n                const midZ = s2VolumeInfo.minimumHeight + delta / 2.0;\n                s2VolumeInfo.minimumHeight = midZ - sizeZ;\n                s2VolumeInfo.maximumHeight = midZ + sizeZ;\n                break;\n            default:\n                break;\n        }\n        const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);\n        const childS2VolumeBox = {\n            box,\n            s2VolumeInfo: s2ChildVolumeInfo\n        };\n        return childS2VolumeBox;\n    }\n    return undefined;\n}\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(params) {\n    const { implicitOptions, parentData = {\n        mortonIndex: 0,\n        x: 0,\n        y: 0,\n        z: 0\n    }, childIndex = 0, s2VolumeBox, loaderOptions } = params;\n    let { subtree, level = 0, globalData = {\n        level: 0,\n        mortonIndex: 0,\n        x: 0,\n        y: 0,\n        z: 0\n    } } = params;\n    const { subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath } = implicitOptions;\n    const tile = { children: [], lodMetricValue: 0, contentUrl: '' };\n    if (!maximumLevel) {\n        // eslint-disable-next-line no-console\n        log.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);\n        return tile;\n    }\n    const lev = level + globalData.level;\n    if (lev > maximumLevel) {\n        return tile;\n    }\n    const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n    const bitsPerTile = Math.log2(childrenPerTile);\n    // childIndex is in range [0,4] for quadtrees and [0, 7] for octrees\n    const childX = childIndex & 0b01; // Get first bit for X\n    const childY = (childIndex >> 1) & 0b01; // Get second bit for Y\n    const childZ = (childIndex >> 2) & 0b01; // Get third bit for Z\n    const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n    let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);\n    let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n    // Local tile coordinates\n    let childTileX = concatBits(parentData.x, childX, 1);\n    let childTileY = concatBits(parentData.y, childY, 1);\n    let childTileZ = concatBits(parentData.z, childZ, 1);\n    let isChildSubtreeAvailable = false;\n    if (level >= subtreeLevels) {\n        isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n    }\n    const x = concatBits(globalData.x, childTileX, level);\n    const y = concatBits(globalData.y, childTileY, level);\n    const z = concatBits(globalData.z, childTileZ, level);\n    if (isChildSubtreeAvailable) {\n        const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n        const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n        const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);\n        subtree = childSubtree;\n        globalData = {\n            mortonIndex: childTileMortonIndex,\n            x: childTileX,\n            y: childTileY,\n            z: childTileZ,\n            level\n        };\n        childTileMortonIndex = 0;\n        tileAvailabilityIndex = 0;\n        childTileX = 0;\n        childTileY = 0;\n        childTileZ = 0;\n        level = 0;\n    }\n    const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n    if (!isTileAvailable) {\n        return tile;\n    }\n    const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n    if (isContentAvailable) {\n        tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n    }\n    const childTileLevel = level + 1;\n    const pData = { mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ };\n    for (let index = 0; index < childrenPerTile; index++) {\n        const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);\n        // Recursive calling...\n        const childTileParsed = await parseImplicitTiles({\n            subtree,\n            implicitOptions,\n            loaderOptions,\n            parentData: pData,\n            childIndex: index,\n            level: childTileLevel,\n            globalData: { ...globalData },\n            s2VolumeBox: childS2VolumeBox\n        });\n        if (childTileParsed.contentUrl || childTileParsed.children.length) {\n            const globalLevel = lev + 1;\n            const childCoordinates = { childTileX, childTileY, childTileZ };\n            const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, implicitOptions, s2VolumeBox);\n            // @ts-ignore\n            tile.children.push(formattedTile);\n        }\n    }\n    return tile;\n}\n/**\n * Check tile availability in the bitstream array\n * @param availabilityData - tileAvailability / contentAvailability / childSubtreeAvailability object\n * @param index - index in the bitstream array\n * @returns\n */\nfunction getAvailabilityResult(availabilityData, index) {\n    let availabilityObject;\n    if (Array.isArray(availabilityData)) {\n        /** TODO: we don't support `3DTILES_multiple_contents` extension at the moment.\n         * https://github.com/CesiumGS/3d-tiles/blob/main/extensions/3DTILES_implicit_tiling/README.md#multiple-contents\n         * Take first item in the array\n         */\n        availabilityObject = availabilityData[0];\n        if (availabilityData.length > 1) {\n            // eslint-disable-next-line no-console\n            log.once('Not supported extension \"3DTILES_multiple_contents\" has been detected');\n        }\n    }\n    else {\n        availabilityObject = availabilityData;\n    }\n    if ('constant' in availabilityObject) {\n        return Boolean(availabilityObject.constant);\n    }\n    if (availabilityObject.explicitBitstream) {\n        return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);\n    }\n    return false;\n}\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {\n    const { basePath, refine, getRefine, lodMetricType, getTileType, rootLodMetricValue, rootBoundingVolume } = options;\n    const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n    const lodMetricValue = rootLodMetricValue / 2 ** level;\n    const boundingVolume = s2VolumeBox?.box\n        ? { box: s2VolumeBox.box }\n        : rootBoundingVolume;\n    const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);\n    return {\n        children: tile.children,\n        contentUrl: tile.contentUrl,\n        content: { uri },\n        id: tile.contentUrl,\n        refine: getRefine(refine),\n        type: getTileType(tile),\n        lodMetricType,\n        lodMetricValue,\n        geometricError: lodMetricValue,\n        transform: tile.transform,\n        boundingVolume: boundingVolumeForChildTile\n    };\n}\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param level\n * @param rootBoundingVolume\n * @param childCoordinates\n */\nfunction calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {\n    if (rootBoundingVolume.region) {\n        const { childTileX, childTileY, childTileZ } = childCoordinates;\n        const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n        const boundingVolumesCount = 2 ** level;\n        const sizeX = (east - west) / boundingVolumesCount;\n        const sizeY = (north - south) / boundingVolumesCount;\n        // TODO : Why is the subdivisionScheme not being checked here?\n        // In case of QUADTREE the sizeZ should NOT be changed!\n        // https://portal.ogc.org/files/102132\n        // A quadtree divides space only on the x and y dimensions. It divides each tile into 4 smaller tiles where the x and y dimensions are halved. The quadtree z minimum and maximum remain unchanged.\n        const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n        const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n        const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n        const [childMinimumHeight, childMaximumHeight] = [\n            minimumHeight + sizeZ * childTileZ,\n            minimumHeight + sizeZ * (childTileZ + 1)\n        ];\n        return {\n            region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n        };\n    }\n    if (rootBoundingVolume.box) {\n        return rootBoundingVolume;\n    }\n    throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);\n}\n/**\n * Do binary concatenation\n * @param higher - number to put to higher part of result\n * @param lower - number to put to lower part of result\n * @param shift - number of bits to shift lower number\n */\nfunction concatBits(higher, lower, shift) {\n    return (higher << shift) + lower;\n}\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n    const mapUrl = generateMapUrl({ level, x, y, z });\n    return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items) {\n    const mapUrl = {};\n    for (const key in items) {\n        mapUrl[`{${key}}`] = items[key];\n    }\n    return mapUrl;\n}\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n    const byteIndex = Math.floor(availabilityIndex / 8);\n    const bitIndex = availabilityIndex % 8;\n    const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n    return bitValue === 1;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport Long from 'long';\nconst MAXIMUM_TOKEN_LENGTH = 16;\n/**\n * Convert the S2 token to the S2 cell ID\n * @param token {string} A string that is the cell's hex token. Zero cell ID is represented as 'X'.\n * @returns {Long} Cell id that is a 64-bit encoding of a face and a Hilbert curve parameter on that face.\n * See {@link https://github.com/google/s2-geometry-library-java/blob/c04b68bf3197a9c34082327eeb3aec7ab7c85da1/src/com/google/common/geometry/S2CellId.java#L439} for more information\n */\nexport function getS2CellIdFromToken(token) {\n    if (token === 'X') {\n        token = '';\n    }\n    // pad token with zeros to make the length 16 that is defined in MAXIMUM_TOKEN_LENGTH\n    const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, '0');\n    return Long.fromString(paddedToken, true, 16); // Hex base\n}\n/**\n * Convert the S2 cell ID to the S2 token\n * @param cellId {Long} A 64-bit encoding of a face and a Hilbert curve parameter on that face.\n * @returns {string} A string that is the cell's hex token. Zero cell ID is represented as 'X'.\n */\nexport function getS2TokenFromCellId(cellId) {\n    if (cellId.isZero()) {\n        return 'X';\n    }\n    let numZeroDigits = cellId.countTrailingZeros();\n    const remainder = numZeroDigits % 4;\n    numZeroDigits = (numZeroDigits - remainder) / 4;\n    const trailingZeroHexChars = numZeroDigits;\n    numZeroDigits *= 4;\n    const x = cellId.shiftRightUnsigned(numZeroDigits);\n    const hexString = x.toString(16).replace(/0+$/, '');\n    const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join('0');\n    return zeroString + hexString;\n}\n/**\n * Get one of four S2 cell's children.\n * @param cellId {Long} A 64-bit encoding of a face and a Hilbert curve parameter on that face.\n * The cell must NOT be a leaf one. So, the cell's level is in the range [0-29].\n * @param index {number} Child index defines one of four S2 cell's children. Must be in the range [0-3].\n * @returns The ID of the cell's child.\n */\nexport function getS2ChildCellId(cellId, index) {\n    // Shift sentinel bit 2 positions to the right.\n    const newLsb = lsb(cellId).shiftRightUnsigned(2);\n    // Insert child index before the sentinel bit.\n    const childCellId = cellId.add(Long.fromNumber(2 * index + 1 - 4).multiply(newLsb));\n    return childCellId;\n}\n/**\n * Return the lowest-numbered bit that is on for this cell id.\n * @private\n * @param cellId {Long} Cell id.\n * @returns {Long} The lowest-numbered bit that is on for this cell id.\n */\nfunction lsb(cellId) {\n    return cellId.and(cellId.not().add(1)); // eslint-disable-line\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND ISC\n// Copyright vis.gl contributors\n/*\nAdapted from s2-geometry under ISC License (ISC)\nCopyright (c) 2012-2016, Jon Atkins <github@jonatkins.com>\nCopyright (c) 2016, AJ ONeal <aj@daplie.com>\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\nimport Long from 'long';\n//\n// Functional Style\n//\nconst FACE_BITS = 3;\nconst MAX_LEVEL = 30;\nconst POS_BITS = 2 * MAX_LEVEL + 1; // 61 (60 bits of data, 1 bit lsb marker)\nconst RADIAN_TO_DEGREE = 180 / Math.PI;\n/**\n * Return the S2Cell\n * @param hilbertQuadkey {string} A string that is the Hilbert quad key (containing /)\n * @returns {@link S2Cell}\n */\n// eslint-disable-next-line max-statements\nexport function getS2CellFromQuadKey(hilbertQuadkey) {\n    if (hilbertQuadkey.length === 0) {\n        throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n    }\n    const parts = hilbertQuadkey.split('/');\n    const face = parseInt(parts[0], 10); // face is in the range [0..5]\n    const position = parts[1]; // position is in the range [0..4**30-1]\n    const maxLevel = position.length;\n    let level = 0;\n    const point = [0, 0];\n    for (let i = maxLevel - 1; i >= 0; i--) {\n        level = maxLevel - i;\n        const bit = position[i];\n        let rx = 0;\n        let ry = 0;\n        if (bit === '1') {\n            ry = 1;\n        }\n        else if (bit === '2') {\n            rx = 1;\n            ry = 1;\n        }\n        else if (bit === '3') {\n            rx = 1;\n        }\n        const val = Math.pow(2, level - 1);\n        rotateAndFlipQuadrant(val, point, rx, ry);\n        point[0] += val * rx;\n        point[1] += val * ry;\n    }\n    if (face % 2 === 1) {\n        const t = point[0];\n        point[0] = point[1];\n        point[1] = t;\n    }\n    return { face, ij: point, level };\n}\n/**\n * Convets S2 cell ID to the Hilbert quad key\n * @param cellId {Long} Cell id that is a 64-bit encoding of a face and a Hilbert curve parameter on that face\n * @returns {string} the Hilbert quad key (containing /) as a string in the format 'face/pos', where\n *  - face is a 10-base representation of the face number\n *  - pos is a 4-base representation of the position along the Hilbert curve. For example,\n *    pos == '13' means the following:\n *       The face is divided two times. After the first time the child cell with position 1 will be selected.\n *       Then, this cell will be divided the second time, and the child cell with position 3 will be selected.\n */\nexport function getS2QuadkeyFromCellId(cellId) {\n    if (cellId.isZero()) {\n        // Invalid token\n        return '';\n    }\n    let bin = cellId.toString(2);\n    while (bin.length < FACE_BITS + POS_BITS) {\n        // eslint-disable-next-line prefer-template\n        bin = '0' + bin;\n    }\n    // MUST come AFTER binstr has been left-padded with '0's\n    const lsbIndex = bin.lastIndexOf('1');\n    // substring(start, end) // includes start, does not include end\n    const faceB = bin.substring(0, 3);\n    // posB will always be a multiple of 2 (or it's invalid)\n    const posB = bin.substring(3, lsbIndex);\n    const levelN = posB.length / 2;\n    const faceS = Long.fromString(faceB, true, 2).toString(10);\n    /*\n      Here is a fix for the case when posB is an empty string that causes an exception in Long.fromString\n    */\n    let posS = '';\n    if (levelN !== 0) {\n        // posB is not an empty string, because levelN !== 0\n        posS = Long.fromString(posB, true, 2).toString(4);\n        while (posS.length < levelN) {\n            // eslint-disable-next-line prefer-template\n            posS = '0' + posS;\n        }\n    }\n    // Note, posS will be \"\" for the level==0, which corresponds to the full face.\n    // Example: Full face 0 (No subdivision, so level==0): Returns \"0/\"\n    // TODO: Is it ok?\n    return `${faceS}/${posS}`;\n}\n/**\n * Convets S2 the Hilbert quad key to cell ID.\n * @param quadkey {string} The Hilbert quad key (containing /) as a string in the format 'face/pos'\n * @returns {Long} Cell id that is a 64-bit encoding of a face and a Hilbert curve parameter on that face\n */\n/* eslint complexity: [\"error\", { \"max\": 14 }] */\nexport function getS2CellIdFromQuadkey(hilbertQuadkey) {\n    if (hilbertQuadkey.length === 0 || hilbertQuadkey.indexOf('/') !== 1) {\n        throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n    }\n    let idS = '';\n    const faceS = hilbertQuadkey[0];\n    switch (faceS) {\n        case '0':\n            idS += '000';\n            break;\n        case '1':\n            idS += '001';\n            break;\n        case '2':\n            idS += '010';\n            break;\n        case '3':\n            idS += '011';\n            break;\n        case '4':\n            idS += '100';\n            break;\n        case '5':\n            idS += '101';\n            break;\n        default:\n            throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n    }\n    const maxLevel = hilbertQuadkey.length;\n    // Don't convert position to Long, because it can contain leading zeros, which makes you handle it later.\n    for (let i = 2; i < maxLevel; i++) {\n        // The first char is a face, the second char is '/'\n        const p = hilbertQuadkey[i];\n        switch (p) {\n            case '0':\n                idS += '00';\n                break;\n            case '1':\n                idS += '01';\n                break;\n            case '2':\n                idS += '10';\n                break;\n            case '3':\n                idS += '11';\n                break;\n            default:\n                throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);\n        }\n    }\n    // Append the sentinel bit\n    idS += '1';\n    const paddedId = idS.padEnd(64, '0');\n    const id = Long.fromString(paddedId, true, 2);\n    return id;\n}\nexport function IJToST(ij, level, offsets) {\n    const maxSize = 1 << level;\n    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];\n}\nfunction singleSTtoUV(st) {\n    if (st >= 0.5) {\n        return (1 / 3.0) * (4 * st * st - 1);\n    }\n    return (1 / 3.0) * (1 - 4 * (1 - st) * (1 - st));\n}\nexport function STToUV(st) {\n    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];\n}\nexport function FaceUVToXYZ(face, [u, v]) {\n    switch (face) {\n        case 0:\n            return [1, u, v];\n        case 1:\n            return [-u, 1, v];\n        case 2:\n            return [-u, -v, 1];\n        case 3:\n            return [-1, -v, -u];\n        case 4:\n            return [v, -1, -u];\n        case 5:\n            return [v, u, -1];\n        default:\n            throw new Error('Invalid face');\n    }\n}\nexport function XYZToLngLat([x, y, z]) {\n    const lat = Math.atan2(z, Math.sqrt(x * x + y * y));\n    const lng = Math.atan2(y, x);\n    return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];\n}\nfunction rotateAndFlipQuadrant(n, point, rx, ry) {\n    if (ry === 0) {\n        if (rx === 1) {\n            point[0] = n - 1 - point[0];\n            point[1] = n - 1 - point[1];\n        }\n        const x = point[0];\n        point[0] = point[1];\n        point[1] = x;\n    }\n}\n/**\n * Retrieve S2 geometry center\n * @param s2cell {S2Cell} S2 cell\n * @returns {[number, number]} Longitude and Latitude coordinates of the S2 cell's center\n */\nexport function getS2LngLatFromS2Cell(s2Cell) {\n    const st = IJToST(s2Cell.ij, s2Cell.level, [0.5, 0.5]);\n    const uv = STToUV(st);\n    const xyz = FaceUVToXYZ(s2Cell.face, uv);\n    return XYZToLngLat(xyz);\n}\n/**\n * Return longitude and latitude of four corners of the cell.\n * @param s2Cell {S2Cell} S2 cell\n * @returns {Array<[number, number]>} Array of longitude and latitude pairs (in degrees) for four corners of the cell.\n */\nexport function getCornerLngLats(s2Cell) {\n    const result = [];\n    const offsets = [\n        [0.0, 0.0],\n        [0.0, 1.0],\n        [1.0, 1.0],\n        [1.0, 0.0]\n    ];\n    for (let i = 0; i < 4; i++) {\n        const st = IJToST(s2Cell.ij, s2Cell.level, offsets[i]);\n        const uv = STToUV(st);\n        const xyz = FaceUVToXYZ(s2Cell.face, uv);\n        result.push(XYZToLngLat(xyz));\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from \"../s2geometry/s2-geometry.js\";\nconst MAX_RESOLUTION = 100;\n/**\n * Get a polygon with corner coordinates for an S2 cell\n * @param s2cell {S2Cell} S2 cell\n * @return {Float64Array} - a simple polygon in flat array format: [lng0, lat0, lng1, lat1, ...]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\n// eslint-disable-next-line max-statements\nexport function getS2BoundaryFlatFromS2Cell(s2cell) {\n    const { face, ij, level } = s2cell;\n    const offsets = [\n        [0, 0],\n        [0, 1],\n        [1, 1],\n        [1, 0],\n        [0, 0]\n    ];\n    // The S2 cell edge is curved: http://s2geometry.io/\n    // This is more prominent at lower levels\n    // resolution is the number of segments to generate per edge.\n    // We exponentially reduce resolution as level increases so it doesn't affect perf\n    // when there are a large number of cells\n    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n    const result = new Float64Array(4 * resolution * 2 + 2);\n    let ptIndex = 0;\n    let prevLng = 0;\n    for (let i = 0; i < 4; i++) {\n        const offset = offsets[i].slice(0);\n        const nextOffset = offsets[i + 1];\n        const stepI = (nextOffset[0] - offset[0]) / resolution;\n        const stepJ = (nextOffset[1] - offset[1]) / resolution;\n        for (let j = 0; j < resolution; j++) {\n            offset[0] += stepI;\n            offset[1] += stepJ;\n            // Cell can be represented by coordinates IJ, ST, UV, XYZ\n            // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n            const st = IJToST(ij, level, offset);\n            const uv = STToUV(st);\n            const xyz = FaceUVToXYZ(face, uv);\n            const lngLat = XYZToLngLat(xyz);\n            // Adjust longitude for Web Mercator projection\n            if (Math.abs(lngLat[1]) > 89.999) {\n                lngLat[0] = prevLng;\n            }\n            const deltaLng = lngLat[0] - prevLng;\n            lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;\n            result[ptIndex++] = lngLat[0];\n            result[ptIndex++] = lngLat[1];\n            prevLng = lngLat[0];\n        }\n    }\n    // close the loop\n    result[ptIndex++] = result[0];\n    result[ptIndex++] = result[1];\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getS2CellFromQuadKey, getS2QuadkeyFromCellId } from \"./s2-geometry.js\";\nimport { getS2CellIdFromToken } from \"../s2-token-functions.js\";\n/**\n * Return the S2Cell from the cell's hex token or the Hilbert quad key\n * @param tokenOrKey {string} A string that is the cell's hex token or the Hilbert quad key (containing /)\n * @returns {@link S2Cell}\n */\nexport function getS2Cell(tokenOrKey) {\n    const key = getS2QuadKey(tokenOrKey);\n    const s2cell = getS2CellFromQuadKey(key);\n    return s2cell;\n}\n/**\n * Get the underlying Hilbert quad key\n * @param tokenOrKey {string} A string that is the cell's hex token or the Hilbert quad key (containing /)\n * @returns Hilbert quad key\n */\nexport function getS2QuadKey(tokenOrKey) {\n    if (tokenOrKey.indexOf('/') > 0) {\n        // is Hilbert quad key\n        return tokenOrKey;\n    }\n    // is S2 cell's hex token\n    const id = getS2CellIdFromToken(tokenOrKey);\n    return getS2QuadkeyFromCellId(id);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getS2BoundaryFlatFromS2Cell } from \"./converters/s2-to-boundary.js\";\nimport { getS2LngLatFromS2Cell } from \"./s2geometry/s2-geometry.js\";\nimport { getS2Cell } from \"./s2geometry/s2-cell-utils.js\";\n// GEOMETRY\n/**\n * Retrieve S2 geometry center\n * @param s2Token {string} A string that is the cell's hex token\n * @returns {[number, number]} Longitude and Latitude coordinates of the S2 cell's center\n */\nexport function getS2LngLat(s2Token) {\n    const s2cell = getS2Cell(s2Token);\n    return getS2LngLatFromS2Cell(s2cell);\n}\n/**\n * Get a polygon with corner coordinates for an s2 cell\n * @param tokenOrKey {string} A string that is the cell's hex token or the Hilbert quad key (containing /)\n * @return {Float64Array} - a simple polygon in flat array format: [lng0, lat0, lng1, lat1, ...]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\nexport function getS2BoundaryFlat(tokenOrKey) {\n    const s2cell = getS2Cell(tokenOrKey);\n    return getS2BoundaryFlatFromS2Cell(s2cell);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getS2BoundaryFlatFromS2Cell } from \"./s2-to-boundary.js\";\nimport { getS2Cell } from \"../s2geometry/s2-cell-utils.js\";\n/**\n * Converts S2 cell to the 2D region\n * @param s2cell {S2Cell} S2 cell to convert to 2D region\n * @returns 2D region as an object containing: west, north, east, south in degrees\n */\nexport function getS2Region(s2cell) {\n    let region;\n    if (s2cell.face === 2 || s2cell.face === 5) {\n        //    let corners: Float64Array;\n        let corners = null;\n        let len = 0;\n        for (let i = 0; i < 4; i++) {\n            const key = `${s2cell.face}/${i}`;\n            const cell = getS2Cell(key);\n            const corns = getS2BoundaryFlatFromS2Cell(cell);\n            if (typeof corners === 'undefined' || corners === null)\n                corners = new Float64Array(4 * corns.length);\n            corners.set(corns, len);\n            len += corns.length;\n        }\n        region = get2DRegionFromS2Corners(corners);\n    }\n    else {\n        const corners = getS2BoundaryFlatFromS2Cell(s2cell);\n        region = get2DRegionFromS2Corners(corners);\n    }\n    return region;\n}\n/**\n * Converts the S2 cell defined by its corners to the 2D region\n * @param corners {Float64Array} - a simple polygon in flat array format: [lng0, lat0, lng1, lat1, ...]\n * @returns 2D region as an object containing: west, north, east, south in degrees\n */\nfunction get2DRegionFromS2Corners(corners) {\n    if (corners.length % 2 !== 0) {\n        throw new Error('Invalid corners');\n    }\n    const longitudes = [];\n    const latitudes = [];\n    for (let i = 0; i < corners.length; i += 2) {\n        longitudes.push(corners[i]);\n        latitudes.push(corners[i + 1]);\n    }\n    longitudes.sort((a, b) => a - b);\n    latitudes.sort((a, b) => a - b);\n    // Return the region in degrees\n    return {\n        west: longitudes[0],\n        east: longitudes[longitudes.length - 1],\n        north: latitudes[latitudes.length - 1],\n        south: latitudes[0]\n    };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { getS2Cell } from \"../s2geometry/s2-cell-utils.js\";\nimport { getS2Region } from \"./s2-to-region.js\";\nimport { Vector3 } from '@math.gl/core';\n/**\n * Converts S2HeightInfo to corner points of an oriented bounding box\n * Can be used to constuct an OrientedBoundingBox instance\n * @param tokenOrKey {string} A string that is the cell's hex token or the Hilbert quad key (containing /)\n * @param heightInfo {S2HeightInfo} min and max height of the box\n * @returns corner points of the oriented bounding box\n */\nexport function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, // This can be an S2 key or token\nheightInfo) {\n    const min = heightInfo?.minimumHeight || 0;\n    const max = heightInfo?.maximumHeight || 0;\n    const s2cell = getS2Cell(tokenOrKey);\n    const region = getS2Region(s2cell);\n    // region lng/lat are in degrees\n    const W = region.west;\n    const S = region.south;\n    const E = region.east;\n    const N = region.north;\n    const points = [];\n    points.push(new Vector3(W, N, min));\n    points.push(new Vector3(E, N, min));\n    points.push(new Vector3(E, S, min));\n    points.push(new Vector3(W, S, min));\n    points.push(new Vector3(W, N, max));\n    points.push(new Vector3(E, N, max));\n    points.push(new Vector3(E, S, max));\n    points.push(new Vector3(W, S, max));\n    return points;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Vector3 } from '@math.gl/core';\nimport { makeOrientedBoundingBoxFromPoints } from '@math.gl/culling';\nimport { getS2OrientedBoundingBoxCornerPoints } from \"../../utils/s2/index.js\";\nimport { getS2LngLat } from \"../../utils/s2/index.js\";\nimport { Ellipsoid } from '@math.gl/geospatial';\n/**\n * Converts S2VolumeInfo to OrientedBoundingBox\n * @param {S2VolumeInfo} s2VolumeInfo - s2 volume to convert\n * @returns Oriented Bounding Box of type Box\n */\nexport function convertS2BoundingVolumetoOBB(s2VolumeInfo) {\n    const token = s2VolumeInfo.token;\n    const heightInfo = {\n        minimumHeight: s2VolumeInfo.minimumHeight,\n        maximumHeight: s2VolumeInfo.maximumHeight\n    };\n    const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);\n    // Add a point that doesn't allow the box dive under the Earth\n    const center = getS2LngLat(token);\n    const centerLng = center[0];\n    const centerLat = center[1];\n    const point = Ellipsoid.WGS84.cartographicToCartesian([\n        centerLng,\n        centerLat,\n        heightInfo.maximumHeight\n    ]);\n    const centerPointAdditional = new Vector3(point[0], point[1], point[2]);\n    corners.push(centerPointAdditional);\n    // corners should be an array of Vector3 (XYZ)\n    const obb = makeOrientedBoundingBoxFromPoints(corners);\n    const box = [...obb.center, ...obb.halfAxes];\n    return box;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// Minimal support to load tilsets from the Cesium ION services\nimport { fetchFile } from '@loaders.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nconst CESIUM_ION_URL = 'https://api.cesium.com/v1/assets';\n// Returns `{url, headers, type, attributions}` for an ion tileset\nexport async function getIonTilesetMetadata(accessToken, assetId) {\n    // Step 1, if no asset id, look for first 3DTILES asset associated with this token.\n    if (!assetId) {\n        const assets = await getIonAssets(accessToken);\n        for (const item of assets.items) {\n            if (item.type === '3DTILES') {\n                assetId = item.id;\n            }\n        }\n    }\n    // Step 2: Query metdatadata for this asset.\n    const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);\n    const { type, url } = ionAssetMetadata;\n    assert(type === '3DTILES' && url);\n    // Prepare a headers object for fetch\n    ionAssetMetadata.headers = {\n        Authorization: `Bearer ${ionAssetMetadata.accessToken}`\n    };\n    return ionAssetMetadata;\n}\n// Return a list of all assets associated with accessToken\nexport async function getIonAssets(accessToken) {\n    assert(accessToken);\n    const url = CESIUM_ION_URL;\n    const headers = { Authorization: `Bearer ${accessToken}` };\n    const response = await fetchFile(url, { headers });\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    return await response.json();\n}\n// Return metadata for a specific asset associated with token\nexport async function getIonAssetMetadata(accessToken, assetId) {\n    assert(accessToken, assetId);\n    const headers = { Authorization: `Bearer ${accessToken}` };\n    const url = `${CESIUM_ION_URL}/${assetId}`;\n    // https://cesium.com/docs/rest-api/#operation/getAsset\n    // Retrieves metadata information about a specific asset.\n    let response = await fetchFile(`${url}`, { headers });\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    let metadata = await response.json();\n    // https://cesium.com/docs/rest-api/#operation/getAssetEndpoint\n    // Retrieves information and credentials that allow you to access the tiled asset data for visualization and analysis.\n    response = await fetchFile(`${url}/endpoint`, { headers });\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    const tilesetInfo = await response.json();\n    // extract dataset description\n    metadata = {\n        ...metadata,\n        ...tilesetInfo\n    };\n    return metadata;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { Tiles3DLoader } from \"./tiles-3d-loader.js\";\nimport { getIonTilesetMetadata } from \"./lib/ion/ion.js\";\nasync function preload(url, options = {}) {\n    options = options['cesium-ion'] || {};\n    // @ts-ignore\n    const { accessToken } = options;\n    // @ts-ignore\n    let assetId = options.assetId;\n    if (!Number.isFinite(assetId)) {\n        const matched = url.match(/\\/([0-9]+)\\/tileset.json/);\n        assetId = matched && matched[1];\n    }\n    return getIonTilesetMetadata(accessToken, assetId);\n}\n/**\n * Loader for 3D tiles from Cesium ION\n */\nexport const CesiumIonLoader = {\n    ...Tiles3DLoader,\n    id: 'cesium-ion',\n    name: 'Cesium Ion',\n    // @ts-ignore\n    preload,\n    parse: async (data, options, context) => {\n        options = { ...options };\n        options['3d-tiles'] = options['cesium-ion'];\n        // @ts-ignore\n        options.loader = CesiumIonLoader;\n        return Tiles3DLoader.parse(data, options, context); // , loader);\n    },\n    options: {\n        'cesium-ion': {\n            ...Tiles3DLoader.options['3d-tiles'],\n            accessToken: null\n        }\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { DataViewFile } from '@loaders.gl/loader-utils';\nimport { parse3DTilesArchive as parse3DTilesArchiveFromProvider } from \"./3d-tiles-archive/3d-tiles-archive-parser.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n/**\n * Loader for 3tz packages\n */\nexport const Tiles3DArchiveFileLoader = {\n    dataType: null,\n    batchType: null,\n    name: '3tz',\n    id: '3tz',\n    module: '3d-tiles',\n    version: VERSION,\n    mimeTypes: ['application/octet-stream', 'application/vnd.maxar.archive.3tz+zip'],\n    parse: parse3DTilesArchive,\n    extensions: ['3tz'],\n    options: {}\n};\n/**\n * returns a single file from the 3tz archive\n * @param data 3tz archive data\n * @param options options\n * @returns requested file\n */\nasync function parse3DTilesArchive(data, options = {}) {\n    const archive = await parse3DTilesArchiveFromProvider(new DataViewFile(new DataView(data)));\n    return archive.getFile(options['3d-tiles-archive']?.path ?? '');\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { CD_HEADER_SIGNATURE, makeHashTableFromZipHeaders, parseHashTable, parseZipCDFileHeader, parseZipLocalFileHeader, searchFromTheEnd } from '@loaders.gl/zip';\nimport { Tiles3DArchive } from \"./3d-tiles-archive-archive.js\";\n/**\n * Creates 3tz file handler from raw file\n * @param fileProvider raw file data\n * @param cb is called with information message during parsing\n * @returns 3tz file handler\n */\nexport const parse3DTilesArchive = async (fileProvider, cb) => {\n    const hashCDOffset = await searchFromTheEnd(fileProvider, CD_HEADER_SIGNATURE);\n    const cdFileHeader = await parseZipCDFileHeader(hashCDOffset, fileProvider);\n    let hashTable;\n    if (cdFileHeader?.fileName !== '@3dtilesIndex1@') {\n        hashTable = await makeHashTableFromZipHeaders(fileProvider);\n        cb?.('3tz doesnt contain hash file, hash info has been composed according to zip archive headers');\n    }\n    else {\n        // cb?.('3tz contains hash file');\n        const localFileHeader = await parseZipLocalFileHeader(cdFileHeader.localHeaderOffset, fileProvider);\n        if (!localFileHeader) {\n            throw new Error('corrupted 3tz zip archive');\n        }\n        const fileDataOffset = localFileHeader.fileDataOffset;\n        const hashFile = await fileProvider.slice(fileDataOffset, fileDataOffset + localFileHeader.compressedSize);\n        hashTable = parseHashTable(hashFile);\n    }\n    return new Tiles3DArchive(fileProvider, hashTable);\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { MD5Hash } from '@loaders.gl/crypto';\nimport { DeflateCompression, NoCompression } from '@loaders.gl/compression';\nimport { IndexedArchive, parseZipLocalFileHeader } from '@loaders.gl/zip';\n/**\n * Handling different compression types in zip\n */\nconst COMPRESSION_METHODS = {\n    /** No compression */\n    0: (data) => new NoCompression().decompress(data),\n    /** Deflation */\n    8: (data) => new DeflateCompression({ raw: true }).decompress(data)\n};\n/**\n * Class for handling information about 3tz file\n */\nexport class Tiles3DArchive extends IndexedArchive {\n    /** hash info */\n    hashTable;\n    /**\n     * creates Tiles3DArchive handler\n     * @param fileProvider - FileProvider with the whole file\n     * @param hashTable - hash info\n     */\n    constructor(fileProvider, hashTable, fileName) {\n        super(fileProvider, hashTable, fileName);\n        this.hashTable = hashTable;\n    }\n    /**\n     * Returns file with the given path from 3tz archive\n     * @param path - path inside the 3tz\n     * @returns buffer with ready to use file\n     */\n    async getFile(path) {\n        // sometimes paths are not in lower case when hash file is created,\n        // so first we're looking for lower case file name and then for original one\n        let data = await this.getFileBytes(path.toLocaleLowerCase());\n        if (!data) {\n            data = await this.getFileBytes(path);\n        }\n        if (!data) {\n            throw new Error(`No such file in the archive: ${path}`);\n        }\n        return data;\n    }\n    /**\n     * Trying to get raw file data by adress\n     * @param path - path inside the archive\n     * @returns buffer with the raw file data\n     */\n    async getFileBytes(path) {\n        let uncompressedFile;\n        if (this.hashTable) {\n            const arrayBuffer = new TextEncoder().encode(path).buffer;\n            const nameHash = await new MD5Hash().hash(arrayBuffer, 'hex');\n            const byteOffset = this.hashTable[nameHash];\n            if (byteOffset === undefined) {\n                return null;\n            }\n            const localFileHeader = await parseZipLocalFileHeader(byteOffset, this.fileProvider);\n            if (!localFileHeader) {\n                return null;\n            }\n            const compressedFile = await this.fileProvider.slice(localFileHeader.fileDataOffset, localFileHeader.fileDataOffset + localFileHeader.compressedSize);\n            const compressionMethod = COMPRESSION_METHODS[localFileHeader.compressionMethod];\n            if (!compressionMethod) {\n                throw Error('Only Deflation compression is supported');\n            }\n            uncompressedFile = await compressionMethod(compressedFile);\n        }\n        else {\n            uncompressedFile = await this.getFileWithoutHash(path);\n        }\n        return uncompressedFile;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { TILE3D_TYPE } from \"../constants.js\";\nimport { assert } from '@loaders.gl/loader-utils';\nimport { encodeComposite3DTile } from \"./encode-3d-tile-composite.js\";\nimport { encodeBatchedModel3DTile } from \"./encode-3d-tile-batched-model.js\";\nimport { encodeInstancedModel3DTile } from \"./encode-3d-tile-instanced-model.js\";\nimport { encodePointCloud3DTile } from \"./encode-3d-tile-point-cloud.js\";\nexport default function encode3DTile(tile, options) {\n    const byteLength = encode3DTileToDataView(tile, null, 0, options);\n    const arrayBuffer = new ArrayBuffer(byteLength);\n    const dataView = new DataView(arrayBuffer);\n    encode3DTileToDataView(tile, dataView, 0, options);\n    return arrayBuffer;\n}\nfunction encode3DTileToDataView(tile, dataView, byteOffset, options) {\n    assert(typeof tile.type === 'string');\n    switch (tile.type) {\n        case TILE3D_TYPE.COMPOSITE:\n            return encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTileToDataView);\n        case TILE3D_TYPE.POINT_CLOUD:\n            return encodePointCloud3DTile(tile, dataView, byteOffset, options);\n        case TILE3D_TYPE.BATCHED_3D_MODEL:\n            return encodeBatchedModel3DTile(tile, dataView, byteOffset, options);\n        case TILE3D_TYPE.INSTANCED_3D_MODEL:\n            return encodeInstancedModel3DTile(tile, dataView, byteOffset, options);\n        default:\n            throw new Error('3D Tiles: unknown tile type');\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\n// HELPER ENCODERS\nimport { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n    const HEADER_SIZE = 12;\n    if (!dataView) {\n        return byteOffset + HEADER_SIZE;\n    }\n    const { magic, version = 1, byteLength = 12 } = tile;\n    assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n    dataView.setUint8(byteOffset + 0, magic[0]);\n    dataView.setUint8(byteOffset + 1, magic[1]);\n    dataView.setUint8(byteOffset + 2, magic[2]);\n    dataView.setUint8(byteOffset + 3, magic[3]);\n    dataView.setUint32(byteOffset + 4, version, true); // version\n    dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n    byteOffset += HEADER_SIZE;\n    return byteOffset;\n}\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n    if (!dataView) {\n        return;\n    }\n    dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.COMPOSITE, tiles: [], ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n    if (dataView) {\n        dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength\n    }\n    byteOffset += 4;\n    for (let i = 0; i < tile.tiles.length; ++i) {\n        byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n    }\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { padToNBytes, copyBinaryToDataView, copyPaddedStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n    const { featuresLength = 0, batchTable } = tile;\n    const featureTableJson = {\n        BATCH_LENGTH: featuresLength\n    };\n    const featureTableJsonString = JSON.stringify(featureTableJson);\n    const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n    const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n    const batchTableJsonByteLength = batchTableJsonString\n        ? padToNBytes(batchTableJsonString.length, 8)\n        : 0;\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n    if (dataView) {\n        dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n        dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n        dataView.setUint32(20, batchTableJsonByteLength, true); // batchTableJsonByteLength\n        dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n    }\n    byteOffset += 16;\n    // TODO feature table binary\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n    if (batchTable) {\n        byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n    }\n    // Add encoded GLTF to the end of data\n    const gltfEncoded = tile.gltfEncoded;\n    if (gltfEncoded) {\n        byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n    }\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { copyStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\n// Procedurally encode the tile array buffer for testing purposes\n// eslint-disable-next-line max-statements\nexport function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {\n    const { featuresLength = 1, gltfFormat = 1, gltfUri = '' } = tile;\n    const gltfUriByteLength = gltfUri.length;\n    const featureTableJson = {\n        INSTANCES_LENGTH: featuresLength,\n        POSITION: new Array(featuresLength * 3).fill(0)\n    };\n    const featureTableJsonString = JSON.stringify(featureTableJson);\n    const featureTableJsonByteLength = featureTableJsonString.length;\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.INSTANCED_MODEL, ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset = encode3DTileHeader(tile, dataView, 0);\n    if (dataView) {\n        dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n        dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n        dataView.setUint32(20, 0, true); // batchTableJsonByteLength\n        dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n        dataView.setUint32(28, gltfFormat, true); // gltfFormat\n    }\n    byteOffset += 20;\n    byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n    byteOffset += copyStringToDataView(dataView, byteOffset, gltfUri, gltfUriByteLength);\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND Apache-2.0\n// Copyright vis.gl contributors\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { MAGIC_ARRAY } from \"../constants.js\";\nimport { encode3DTileHeader, encode3DTileByteLength } from \"./helpers/encode-3d-tile-header.js\";\nimport { padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView } from '@loaders.gl/loader-utils';\nconst DEFAULT_FEATURE_TABLE_JSON = {\n    POINTS_LENGTH: 1,\n    POSITIONS: {\n        byteOffset: 0\n    }\n};\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n    const { featureTableJson = DEFAULT_FEATURE_TABLE_JSON } = tile;\n    let featureTableJsonString = JSON.stringify(featureTableJson);\n    featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n    const { featureTableJsonByteLength = featureTableJsonString.length } = tile;\n    const featureTableBinary = new ArrayBuffer(12); // Enough space to hold 3 floats\n    const featureTableBinaryByteLength = featureTableBinary.byteLength;\n    // Add default magic for this tile type\n    tile = { magic: MAGIC_ARRAY.POINT_CLOUD, ...tile };\n    const byteOffsetStart = byteOffset;\n    byteOffset += encode3DTileHeader(tile, dataView, 0);\n    if (dataView) {\n        dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true); // featureTableJsonByteLength\n        dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true); // featureTableBinaryByteLength\n        dataView.setUint32(byteOffset + 8, 0, true); // batchTableJsonByteLength\n        dataView.setUint32(byteOffset + 12, 0, true); // batchTableBinaryByteLength\n    }\n    byteOffset += 16;\n    byteOffset += copyStringToDataView(dataView, byteOffset, featureTableJsonString, featureTableJsonByteLength);\n    byteOffset += copyBinaryToDataView(dataView, byteOffset, featureTableBinary, featureTableBinaryByteLength);\n    // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n    encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n    return byteOffset;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport encode3DTile from \"./lib/encoders/encode-3d-tile.js\";\n/**\n * Exporter for 3D Tiles\n */\nexport const Tile3DWriter = {\n    name: '3D Tile',\n    id: '3d-tiles',\n    module: '3d-tiles',\n    version: VERSION,\n    extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    options: {\n        ['3d-tiles']: {}\n    },\n    encode: async (tile, options) => encodeSync(tile, options),\n    encodeSync\n};\nfunction encodeSync(tile, options) {\n    return encode3DTile(tile, options);\n}\n"],
  "mappings": "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",
  "names": ["import_loader_utils", "import_tiles", "import_loader_utils", "import_math", "import_core", "import_loader_utils", "import_math", "import_loader_utils", "stack", "defined", "SIZEOF_UINT32", "import_math", "import_math", "import_core", "import_math", "import_math", "import_loader_utils", "import_core", "import_math", "parse3DTile", "import_loader_utils", "import_gltf", "import_loader_utils", "import_core", "import_core", "Long", "import_long", "Long", "import_core", "import_core", "import_geospatial", "log", "getRefine", "getTileType", "stack", "import_core", "import_loader_utils", "import_loader_utils", "import_zip", "path", "VERSION", "parse3DTilesArchive", "import_loader_utils", "import_loader_utils", "encode3DTile", "import_loader_utils", "import_loader_utils", "import_loader_utils"]
}
