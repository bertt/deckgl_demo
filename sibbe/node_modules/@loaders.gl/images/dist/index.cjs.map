{
  "version": 3,
  "sources": ["index.js", "lib/utils/version.js", "lib/parsers/parse-image.js", "lib/category-api/image-type.js", "lib/category-api/parsed-image-api.js", "lib/parsers/svg-utils.js", "lib/parsers/parse-to-image.js", "lib/parsers/parse-to-image-bitmap.js", "lib/parsers/parse-to-node-image.js", "lib/category-api/parse-isobmff-binary.js", "lib/category-api/binary-image-api.js", "image-loader.js", "lib/encoders/encode-image.js", "image-writer.js", "lib/category-api/image-format.js"],
  "sourcesContent": ["// LOADERS AND WRITERS\nexport { ImageLoader } from \"./image-loader.js\";\nexport { ImageWriter } from \"./image-writer.js\";\n// IMAGE CATEGORY API\n// Binary Image API\nexport { getBinaryImageMetadata } from \"./lib/category-api/binary-image-api.js\";\n// Parsed Image API\nexport { isImageTypeSupported, getDefaultImageType } from \"./lib/category-api/image-type.js\";\nexport { isImage, getImageType, getImageSize, getImageData } from \"./lib/category-api/parsed-image-api.js\";\n// EXPERIMENTAL\nexport { getSupportedImageFormats } from \"./lib/category-api/image-format.js\";\nexport { isImageFormatSupported } from \"./lib/category-api/image-format.js\";\n// REMOVED\n/** @deprecated Temporary placeholder to prevent builds from breaking */\nexport function loadImage() {\n    throw new Error('loadImage has moved to @loaders.gl/textures');\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n", "import { assert } from '@loaders.gl/loader-utils';\nimport { isImageTypeSupported, getDefaultImageType } from \"../category-api/image-type.js\";\nimport { getImageData } from \"../category-api/parsed-image-api.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nimport { parseToImageBitmap } from \"./parse-to-image-bitmap.js\";\nimport { parseToNodeImage } from \"./parse-to-node-image.js\";\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport async function parseImage(arrayBuffer, options, context) {\n    options = options || {};\n    const imageOptions = options.image || {};\n    // The user can request a specific output format via `options.image.type`\n    const imageType = imageOptions.type || 'auto';\n    const { url } = context || {};\n    // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n    const loadType = getLoadableImageType(imageType);\n    let image;\n    switch (loadType) {\n        case 'imagebitmap':\n            image = await parseToImageBitmap(arrayBuffer, options, url);\n            break;\n        case 'image':\n            image = await parseToImage(arrayBuffer, options, url);\n            break;\n        case 'data':\n            // Node.js loads imagedata directly\n            image = await parseToNodeImage(arrayBuffer, options);\n            break;\n        default:\n            assert(false);\n    }\n    // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n    if (imageType === 'data') {\n        image = getImageData(image);\n    }\n    return image;\n}\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n    switch (type) {\n        case 'auto':\n        case 'data':\n            // Browser: For image data we need still need to load using an image format\n            // Node: the default image type is `data`.\n            return getDefaultImageType();\n        default:\n            // Throw an error if not supported\n            isImageTypeSupported(type);\n            return type;\n    }\n}\n", "import { isBrowser } from '@loaders.gl/loader-utils';\n// @ts-ignore TS2339: Property does not exist on type\nconst parseImageNode = globalThis.loaders?.parseImageNode;\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n/**\n * Checks if a loaders.gl image type is supported\n * @param type image type string\n */\nexport function isImageTypeSupported(type) {\n    switch (type) {\n        case 'auto':\n            // Should only ever be false in Node.js, if polyfills have not been installed...\n            return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n        case 'imagebitmap':\n            return IMAGE_BITMAP_SUPPORTED;\n        case 'image':\n            return IMAGE_SUPPORTED;\n        case 'data':\n            return DATA_SUPPORTED;\n        default:\n            throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n    }\n}\n/**\n * Returns the \"most performant\" supported image type on this platform\n * @returns image type string\n */\nexport function getDefaultImageType() {\n    if (IMAGE_BITMAP_SUPPORTED) {\n        return 'imagebitmap';\n    }\n    if (IMAGE_SUPPORTED) {\n        return 'image';\n    }\n    if (DATA_SUPPORTED) {\n        return 'data';\n    }\n    // This should only happen in Node.js\n    throw new Error('Install \\'@loaders.gl/polyfills\\' to parse images under Node.js');\n}\n", "export function isImage(image) {\n    return Boolean(getImageTypeOrNull(image));\n}\nexport function deleteImage(image) {\n    switch (getImageType(image)) {\n        case 'imagebitmap':\n            image.close();\n            break;\n        default:\n        // Nothing to do for images and image data objects\n    }\n}\nexport function getImageType(image) {\n    const format = getImageTypeOrNull(image);\n    if (!format) {\n        throw new Error('Not an image');\n    }\n    return format;\n}\nexport function getImageSize(image) {\n    return getImageData(image);\n}\nexport function getImageData(image) {\n    switch (getImageType(image)) {\n        case 'data':\n            return image;\n        case 'image':\n        case 'imagebitmap':\n            // Extract the image data from the image via a canvas\n            const canvas = document.createElement('canvas');\n            // TODO - reuse the canvas?\n            const context = canvas.getContext('2d');\n            if (!context) {\n                throw new Error('getImageData');\n            }\n            // @ts-ignore\n            canvas.width = image.width;\n            // @ts-ignore\n            canvas.height = image.height;\n            // @ts-ignore\n            context.drawImage(image, 0, 0);\n            // @ts-ignore\n            return context.getImageData(0, 0, image.width, image.height);\n        default:\n            throw new Error('getImageData');\n    }\n}\n// PRIVATE\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n    if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        return 'imagebitmap';\n    }\n    if (typeof Image !== 'undefined' && image instanceof Image) {\n        return 'image';\n    }\n    if (image && typeof image === 'object' && image.data && image.width && image.height) {\n        return 'data';\n    }\n    return null;\n}\n", "// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\nexport function isSVG(url) {\n    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // Prepare a properly tagged data URL, and load using normal mechanism\n        const textDecoder = new TextDecoder();\n        let xmlText = textDecoder.decode(arrayBuffer);\n        // TODO Escape in browser to support e.g. Chinese characters\n        try {\n            if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {\n                xmlText = unescape(encodeURIComponent(xmlText));\n            }\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n        // base64 encoding is safer. utf-8 fails in some browsers\n        const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n        return src;\n    }\n    return getBlob(arrayBuffer, url);\n}\nexport function getBlob(arrayBuffer, url) {\n    if (isSVG(url)) {\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n        // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n        throw new Error('SVG cannot be parsed directly to imagebitmap');\n    }\n    // TODO - how to determine mime type? Param? Sniff here?\n    return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n", "import { getBlobOrSVGDataUrl } from \"./svg-utils.js\";\n// Parses html image from array buffer\nexport async function parseToImage(arrayBuffer, options, url) {\n    // Note: image parsing requires conversion to Blob (for createObjectURL).\n    // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n    // But presumably not worth adding 'blob' flag to loader objects?\n    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n    const URL = self.URL || self.webkitURL;\n    const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n    try {\n        return await loadToImage(objectUrl || blobOrDataUrl, options);\n    }\n    finally {\n        if (objectUrl) {\n            URL.revokeObjectURL(objectUrl);\n        }\n    }\n}\nexport async function loadToImage(url, options) {\n    const image = new Image();\n    image.src = url;\n    // The `image.onload()` callback does not guarantee that the image has been decoded\n    // so a main thread \"freeze\" can be incurred when using the image for the first time.\n    // `Image.decode()` returns a promise that completes when image is decoded.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n    // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n    // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n    if (options.image && options.image.decode && image.decode) {\n        await image.decode();\n        return image;\n    }\n    // Create a promise that tracks onload/onerror callbacks\n    return await new Promise((resolve, reject) => {\n        try {\n            image.onload = () => resolve(image);\n            image.onerror = (error) => {\n                const message = error instanceof Error ? error.message : 'error';\n                reject(new Error(message));\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n", "import { isSVG, getBlob } from \"./svg-utils.js\";\nimport { parseToImage } from \"./parse-to-image.js\";\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport async function parseToImageBitmap(arrayBuffer, options, url) {\n    let blob;\n    // Cannot parse SVG directly to ImageBitmap, parse to Image first\n    if (isSVG(url)) {\n        // Note: this only works on main thread\n        const image = await parseToImage(arrayBuffer, options, url);\n        blob = image;\n    }\n    else {\n        // Create blob from the array buffer\n        blob = getBlob(arrayBuffer, url);\n    }\n    const imagebitmapOptions = options && options.imagebitmap;\n    return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n        imagebitmapOptions = null;\n    }\n    if (imagebitmapOptions) {\n        try {\n            // @ts-ignore Options\n            return await createImageBitmap(blob, imagebitmapOptions);\n        }\n        catch (error) {\n            console.warn(error); // eslint-disable-line\n            imagebitmapOptionsSupported = false;\n        }\n    }\n    return await createImageBitmap(blob);\n}\nfunction isEmptyObject(object) {\n    // @ts-ignore\n    for (const key in object || EMPTY_OBJECT) {\n        return false;\n    }\n    return true;\n}\n", "import { assert } from '@loaders.gl/loader-utils';\nimport { getBinaryImageMetadata } from \"../category-api/binary-image-api.js\";\n// Use polyfills if installed to parsed image using get-pixels\nexport async function parseToNodeImage(arrayBuffer, options) {\n    const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};\n    // @ts-ignore\n    const parseImageNode = globalThis.loaders?.parseImageNode;\n    assert(parseImageNode); // '@loaders.gl/polyfills not installed'\n    // @ts-expect-error TODO should we throw error in this case?\n    return await parseImageNode(arrayBuffer, mimeType);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// code adapted from https://github.com/sindresorhus/file-type under MIT license\n/**\n * Tests if a buffer is in ISO base media file format (ISOBMFF) @see https://en.wikipedia.org/wiki/ISO_base_media_file_format\n * (ISOBMFF is a media container standard based on the Apple QuickTime container format)\n */\nexport function getISOBMFFMediaType(buffer) {\n    // Almost all ISO base media files start with `ftyp` box. (It's not required to be first, but it's recommended to be.)\n    if (!checkString(buffer, 'ftyp', 4)) {\n        return null;\n    }\n    // Extra check: test for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n    if ((buffer[8] & 0x60) === 0x00) {\n        return null;\n    }\n    // `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n    return decodeMajorBrand(buffer);\n}\n/**\n * brands explained @see https://github.com/strukturag/libheif/issues/83\n * code adapted from @see https://github.com/sindresorhus/file-type/blob/main/core.js#L489-L492\n */\nexport function decodeMajorBrand(buffer) {\n    const brandMajor = getUTF8String(buffer, 8, 12).replace('\\0', ' ').trim();\n    switch (brandMajor) {\n        case 'avif':\n        case 'avis':\n            return { extension: 'avif', mimeType: 'image/avif' };\n        default:\n            return null;\n    }\n    // We don't need these now, but they are easy to add\n    // case 'mif1':\n    //   return {extension: 'heic', mimeType: 'image/heif'};\n    // case 'msf1':\n    //   return {extension: 'heic', mimeType: 'image/heif-sequence'};\n    // case 'heic':\n    // case 'heix':\n    //   return {extension: 'heic', mimeType: 'image/heic'};\n    // case 'hevc':\n    // case 'hevx':\n    //   return {extension: 'heic', mimeType: 'image/heic-sequence'};\n    // case 'qt':\n    //   return {ext: 'mov', mime: 'video/quicktime'};\n    // case 'M4V':\n    // case 'M4VH':\n    // case 'M4VP':\n    //   return {ext: 'm4v', mime: 'video/x-m4v'};\n    // case 'M4P':\n    //   return {ext: 'm4p', mime: 'video/mp4'};\n    // case 'M4B':\n    //   return {ext: 'm4b', mime: 'audio/mp4'};\n    // case 'M4A':\n    //   return {ext: 'm4a', mime: 'audio/x-m4a'};\n    // case 'F4V':\n    //   return {ext: 'f4v', mime: 'video/mp4'};\n    // case 'F4P':\n    //   return {ext: 'f4p', mime: 'video/mp4'};\n    // case 'F4A':\n    //   return {ext: 'f4a', mime: 'audio/mp4'};\n    // case 'F4B':\n    //   return {ext: 'f4b', mime: 'audio/mp4'};\n    // case 'crx':\n    //   return {ext: 'cr3', mime: 'image/x-canon-cr3'};\n    // default:\n    // if (brandMajor.startsWith('3g')) {\n    //   if (brandMajor.startsWith('3g2')) {\n    //     return {ext: '3g2', mime: 'video/3gpp2'};\n    //   }\n    //   return {ext: '3gp', mime: 'video/3gpp'};\n    // }\n    // return {ext: 'mp4', mime: 'video/mp4'};\n}\n/** Interpret a chunk of bytes as a UTF8 string */\nfunction getUTF8String(array, start, end) {\n    return String.fromCharCode(...array.slice(start, end));\n}\nfunction stringToBytes(string) {\n    return [...string].map((character) => character.charCodeAt(0));\n}\nfunction checkString(buffer, header, offset = 0) {\n    const headerBytes = stringToBytes(header);\n    for (let i = 0; i < headerBytes.length; ++i) {\n        if (headerBytes[i] !== buffer[i + offset]) {\n            return false;\n        }\n    }\n    return true;\n}\n", "// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\nimport { getISOBMFFMediaType } from \"./parse-isobmff-binary.js\";\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n/**\n * Extracts `{mimeType, width and height}` from a memory buffer containing a known image format\n * Currently supports `image/png`, `image/jpeg`, `image/bmp` and `image/gif`.\n * @param binaryData: DataView | ArrayBuffer image file memory to parse\n * @returns metadata or null if memory is not a valid image file format layout.\n */\nexport function getBinaryImageMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    return (getPngMetadata(dataView) ||\n        getJpegMetadata(dataView) ||\n        getGifMetadata(dataView) ||\n        getBmpMetadata(dataView) ||\n        getISOBMFFMetadata(dataView));\n}\n// ISOBMFF\nfunction getISOBMFFMetadata(binaryData) {\n    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);\n    const mediaType = getISOBMFFMediaType(buffer);\n    if (!mediaType) {\n        return null;\n    }\n    return {\n        mimeType: mediaType.mimeType,\n        // TODO - decode width and height\n        width: 0,\n        height: 0\n    };\n}\n// PNG\nfunction getPngMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the first 4 bytes of the PNG signature.\n    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n    if (!isPng) {\n        return null;\n    }\n    // Extract size from a binary PNG file\n    return {\n        mimeType: 'image/png',\n        width: dataView.getUint32(16, BIG_ENDIAN),\n        height: dataView.getUint32(20, BIG_ENDIAN)\n    };\n}\n// GIF\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check first 4 bytes of the GIF signature (\"GIF8\").\n    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n    if (!isGif) {\n        return null;\n    }\n    // GIF is little endian.\n    return {\n        mimeType: 'image/gif',\n        width: dataView.getUint16(6, LITTLE_ENDIAN),\n        height: dataView.getUint16(8, LITTLE_ENDIAN)\n    };\n}\n// BMP\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check magic number is valid (first 2 characters should be \"BM\").\n    // The mandatory bitmap file header is 14 bytes long.\n    const isBmp = dataView.byteLength >= 14 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n        dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n    if (!isBmp) {\n        return null;\n    }\n    // BMP is little endian.\n    return {\n        mimeType: 'image/bmp',\n        width: dataView.getUint32(18, LITTLE_ENDIAN),\n        height: dataView.getUint32(22, LITTLE_ENDIAN)\n    };\n}\n// JPEG\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n    const dataView = toDataView(binaryData);\n    // Check file contains the JPEG \"start of image\" (SOI) marker\n    // followed by another marker.\n    const isJpeg = dataView.byteLength >= 3 &&\n        dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n        dataView.getUint8(2) === 0xff;\n    if (!isJpeg) {\n        return null;\n    }\n    const { tableMarkers, sofMarkers } = getJpegMarkers();\n    // Exclude the two byte SOI marker.\n    let i = 2;\n    while (i + 9 < dataView.byteLength) {\n        const marker = dataView.getUint16(i, BIG_ENDIAN);\n        // The frame that contains the width and height of the JPEG image.\n        if (sofMarkers.has(marker)) {\n            return {\n                mimeType: 'image/jpeg',\n                height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n                width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n            };\n        }\n        // Miscellaneous tables/data preceding the frame header.\n        if (!tableMarkers.has(marker)) {\n            return null;\n        }\n        // Length includes size of length parameter but not the two byte header.\n        i += 2;\n        i += dataView.getUint16(i, BIG_ENDIAN);\n    }\n    return null;\n}\nfunction getJpegMarkers() {\n    // Tables/misc header markers.\n    // DQT, DHT, DAC, DRI, COM, APP_n\n    const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n    for (let i = 0xffe0; i < 0xfff0; ++i) {\n        tableMarkers.add(i);\n    }\n    // SOF markers and DHP marker.\n    // These markers are after tables/misc data.\n    const sofMarkers = new Set([\n        0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce,\n        0xffcf, 0xffde\n    ]);\n    return { tableMarkers, sofMarkers };\n}\n// TODO - move into image module?\nfunction toDataView(data) {\n    if (data instanceof DataView) {\n        return data;\n    }\n    if (ArrayBuffer.isView(data)) {\n        return new DataView(data.buffer);\n    }\n    // TODO: make these functions work for Node.js buffers?\n    // if (bufferToArrayBuffer) {\n    //   data = bufferToArrayBuffer(data);\n    // }\n    // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n    if (data instanceof ArrayBuffer) {\n        return new DataView(data);\n    }\n    throw new Error('toDataView');\n}\n", "// import type { ImageType } from '@loaders.gl/schema';\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseImage } from \"./lib/parsers/parse-image.js\";\nimport { getBinaryImageMetadata } from \"./lib/category-api/binary-image-api.js\";\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];\nconst MIME_TYPES = [\n    'image/png',\n    'image/jpeg',\n    'image/gif',\n    'image/webp',\n    'image/avif',\n    'image/bmp',\n    'image/vnd.microsoft.icon',\n    'image/svg+xml'\n];\nconst DEFAULT_IMAGE_LOADER_OPTIONS = {\n    image: {\n        type: 'auto',\n        decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n};\n/**\n * Loads a platform-specific image type\n * Note: This type can be used as input data to WebGL texture creation\n */\nexport const ImageLoader = {\n    dataType: null,\n    batchType: null,\n    id: 'image',\n    module: 'images',\n    name: 'Images',\n    version: VERSION,\n    mimeTypes: MIME_TYPES,\n    extensions: EXTENSIONS,\n    parse: parseImage,\n    // TODO: byteOffset, byteLength;\n    tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n    options: DEFAULT_IMAGE_LOADER_OPTIONS\n};\n", "import { getImageSize } from \"../category-api/parsed-image-api.js\";\n// @ts-ignore TS2339: Property does not exist on type\nconst encodeImageNode = globalThis.loaders?.encodeImageNode;\n/**\n * Returns data bytes representing a compressed image in PNG or JPG format,\n * This data can be saved using file system (f) methods or used in a request.\n * @param image - ImageBitmap Image or Canvas\n * @param options\n * param opt.type='png' - png, jpg or image/png, image/jpg are valid\n * param mimeType= - Whether to include a data URI header\n */\nexport async function encodeImage(image, options) {\n    options = options || {};\n    options.image = options.image || {};\n    return encodeImageNode\n        ? encodeImageNode(image, { type: options.image.mimeType })\n        : encodeImageInBrowser(image, options);\n}\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n    const { mimeType, jpegQuality } = options.image;\n    const { width, height } = getImageSize(image);\n    // create a canvas and resize it to the size of our image\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    drawImageToCanvas(image, canvas);\n    // The actual encoding is done asynchronously with `canvas.toBlob()`\n    const blob = await new Promise((resolve) => {\n        // get it back as a Blob\n        if (jpegQuality && qualityParamSupported) {\n            try {\n                canvas.toBlob(resolve, mimeType, jpegQuality);\n                return;\n            }\n            catch (error) {\n                qualityParamSupported = false;\n            }\n        }\n        canvas.toBlob(resolve, mimeType);\n    });\n    if (!blob) {\n        throw new Error('image encoding failed');\n    }\n    return await blob.arrayBuffer();\n}\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n    // Try optimized path for ImageBitmaps via bitmaprenderer context\n    if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        const context = canvas.getContext('bitmaprenderer');\n        if (context) {\n            // transfer the ImageBitmap to it\n            context.transferFromImageBitmap(image);\n            return canvas;\n        }\n    }\n    // Available on most platforms, except IE11 and Andriod WebViews...\n    const context = canvas.getContext('2d');\n    if (image.data) {\n        // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n        const clampedArray = new Uint8ClampedArray(image.data);\n        const imageData = new ImageData(clampedArray, image.width, image.height);\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n    }\n    // Fall back to generic image/image bitmap rendering path\n    context.drawImage(image, 0, 0);\n    return canvas;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { encodeImage } from \"./lib/encoders/encode-image.js\";\n/** Writer for image data */\nexport const ImageWriter = {\n    name: 'Images',\n    id: 'image',\n    module: 'images',\n    version: VERSION,\n    extensions: ['jpeg'],\n    options: {\n        image: {\n            mimeType: 'image/png',\n            jpegQuality: null\n        }\n    },\n    encode: encodeImage\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@loaders.gl/loader-utils';\nconst MIME_TYPES = [\n    'image/png',\n    'image/jpeg',\n    'image/gif',\n    'image/webp',\n    'image/avif',\n    'image/tiff',\n    // TODO - what is the correct type for SVG\n    'image/svg',\n    'image/svg+xml',\n    'image/bmp',\n    'image/vnd.microsoft.icon'\n];\n/** Only one round of tests is performed */\nconst mimeTypeSupportedPromise = null;\n/** Run-time browser detection of file formats requires async tests for most precise results */\nexport async function getSupportedImageFormats() {\n    if (mimeTypeSupportedPromise) {\n        return await mimeTypeSupportedPromise;\n    }\n    const supportedMimeTypes = new Set();\n    for (const mimeType of MIME_TYPES) {\n        const supported = isBrowser\n            ? await checkBrowserImageFormatSupportAsync(mimeType)\n            : checkNodeImageFormatSupport(mimeType);\n        if (supported) {\n            supportedMimeTypes.add(mimeType);\n        }\n    }\n    return supportedMimeTypes;\n}\n/** Cache sync values for speed */\nconst mimeTypeSupportedSync = {};\n/**\n * Check if image MIME type is supported. Result is cached to avoid repeated tests.\n */\nexport function isImageFormatSupported(mimeType) {\n    if (mimeTypeSupportedSync[mimeType] === undefined) {\n        const supported = isBrowser\n            ? checkBrowserImageFormatSupport(mimeType)\n            : checkNodeImageFormatSupport(mimeType);\n        mimeTypeSupportedSync[mimeType] = supported;\n    }\n    return mimeTypeSupportedSync[mimeType];\n}\n/**\n * Checks that polyfills are installed and that mimeType is supported by polyfills\n * @todo Ideally polyfills should declare what formats they support, instead of storing that data here.\n */\nfunction checkNodeImageFormatSupport(mimeType) {\n    const NODE_FORMAT_SUPPORT = ['image/png', 'image/jpeg', 'image/gif'];\n    const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;\n    const parseImageNode = globalThis.loaders?.parseImageNode;\n    return Boolean(parseImageNode) && imageFormatsNode.includes(mimeType);\n}\n/** Checks image format support synchronously.\n * @note Unreliable, fails on AVIF\n */\nfunction checkBrowserImageFormatSupport(mimeType) {\n    switch (mimeType) {\n        case 'image/avif': // Will fail\n        case 'image/webp':\n            return testBrowserImageFormatSupport(mimeType);\n        default:\n            return true;\n    }\n}\nconst TEST_IMAGE = {\n    'image/avif': 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',\n    // Lossy test image. Support for lossy images doesn't guarantee support for all WebP images.\n    'image/webp': 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n};\n/** Checks WebP and AVIF support asynchronously */\nasync function checkBrowserImageFormatSupportAsync(mimeType) {\n    const dataURL = TEST_IMAGE[mimeType];\n    return dataURL ? await testBrowserImageFormatSupportAsync(dataURL) : true;\n}\n/**\n * Checks browser synchronously\n * Checks if toDataURL supports the mimeType.\n * @note Imperfect testOn Chrome this is true for WebP but not for AVIF\n */\nfunction testBrowserImageFormatSupport(mimeType) {\n    try {\n        const element = document.createElement('canvas');\n        const dataURL = element.toDataURL(mimeType);\n        return dataURL.indexOf(`data:${mimeType}`) === 0;\n    }\n    catch {\n        // Probably Safari...\n        return false;\n    }\n}\n// Check WebPSupport asynchronously\nasync function testBrowserImageFormatSupportAsync(testImageDataURL) {\n    return new Promise((resolve) => {\n        const image = new Image();\n        image.src = testImageDataURL;\n        image.onload = () => resolve(image.height > 0);\n        image.onerror = () => resolve(false);\n    });\n}\n"],
  "mappings": "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",
  "names": ["import_loader_utils", "import_loader_utils", "_a", "parseImageNode", "_a", "context", "import_loader_utils", "MIME_TYPES", "_a", "parseImageNode"]
}
