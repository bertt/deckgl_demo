{
  "version": 3,
  "sources": ["../src/lib/async-queue/async-queue.ts", "../src/lib/worker-utils/get-transfer-list.ts", "../src/lib/node/worker_threads-browser.ts", "../src/lib/worker-farm/worker-body.ts", "../src/lib/worker-api/create-worker.ts", "../src/workers/null-worker.ts"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object: unknown) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object: object | null): object {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n\n  Object.keys(clone).forEach((key) => {\n    // Typed Arrays and Arrays are passed with no change\n    if (\n      typeof object[key] === 'object' &&\n      !ArrayBuffer.isView(object[key]) &&\n      !(object[key] instanceof Array)\n    ) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n\n  return clone;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Browser polyfill for Node.js built-in `worker_threads` module.\n * These fills are non-functional, and just intended to ensure that\n * `import 'worker_threads` doesn't break browser builds.\n * The replacement is done in package.json browser field\n */\nexport class NodeWorker {\n  terminate() {}\n}\n\nexport type {NodeWorker as NodeWorkerType};\n\nexport const parentPort = null;\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n// import type {TransferListItem} from '../node/worker_threads';\nimport {parentPort} from '../node/worker_threads';\n\ntype TransferListItem = any;\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nasync function getParentPort() {\n  // const isNode = globalThis.process;\n  // let parentPort;\n  // try {\n  //   // prettier-ignore\n  //   eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n  //   parentPort = globalThis.parentPort;\n  // } catch {\n  //   try {\n  //     // prettier-ignore\n  //     eval('globalThis.workerThreadsPromise = import(\\'worker_threads\\')'); // eslint-disable-line no-eval\n  //     const workerThreads = await globalThis.workerThreadsPromise;\n  //     parentPort = workerThreads.parentPort;\n  //   } catch (error) {\n  //     console.error((error as Error).message); // eslint-disable-line no-console\n  //   }\n  // }\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static async inWorkerThread(): Promise<boolean> {\n    return typeof self !== 'undefined' || Boolean(await getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    async function handleMessage(message) {\n      const parentPort = await getParentPort();\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    getParentPort().then((parentPort) => {\n      if (parentPort) {\n        parentPort.on('message', (message) => {\n          handleMessage(message);\n        });\n        // if (message == 'exit') { parentPort.unref(); }\n        // eslint-disable-next-line\n        parentPort.on('exit', () => console.debug('Node worker closing'));\n      } else {\n        // eslint-disable-next-line no-restricted-globals\n        globalThis.onmessage = handleMessage;\n      }\n    });\n  }\n\n  static async addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = async (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        const parentPort = await getParentPort();\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static async removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static async postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): Promise<void> {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n\n    // Cast to Node compatible transfer list\n    const transferList = getTransferList(payload) as TransferListItem[];\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-expect-error Outside of worker scopes this call has a third parameter\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches: AsyncQueue<any>;\nlet options: {[key: string]: any};\n\nexport type ProcessOnMainThread = (\n  data: any,\n  options?: {[key: string]: any},\n  context?: WorkerContext\n) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport async function createWorker(\n  process: Process,\n  processInBatches?: ProcessInBatches\n): Promise<void> {\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue<any>();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer: ArrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type: string, payload: WorkerMessagePayload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {createWorker} from '../lib/worker-api/create-worker';\n\ncreateWorker(async (data) => {\n  // @ts-ignore\n  return data;\n});\n"],
  "mappings": ";;;AAmBA,MAAqB,aAArB,MAAmC;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IAER,cAAc;AACZ,WAAK,UAAU,CAAC;AAChB,WAAK,YAAY,CAAC;AAClB,WAAK,UAAU;AAAA,IACjB;AAAA;AAAA,IAGA,CAAC,OAAO,aAAa,IAAsB;AACzC,aAAO;AAAA,IACT;AAAA;AAAA,IAGA,KAAK,OAAgB;AACnB,aAAO,KAAK,QAAQ,KAAK;AAAA,IAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,QAAQ,OAAwB;AAC9B,UAAI,KAAK,SAAS;AAChB,cAAM,IAAI,MAAM,QAAQ;AAAA,MAC1B;AAEA,UAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,YAAI,KAAK,QAAQ,SAAS,GAAG;AAC3B,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AACA,cAAM,UAAU,KAAK,UAAU,MAAM;AACrC,YAAI,iBAAiB,OAAO;AAC1B,kBAAQ,OAAO,KAAK;AAAA,QACtB,OAAO;AACL,kBAAQ,QAAQ,EAAC,MAAK,CAAC;AAAA,QACzB;AAAA,MACF,OAAO;AACL,aAAK,QAAQ,KAAK,KAAK;AAAA,MACzB;AAAA,IACF;AAAA;AAAA,IAGA,QAAc;AACZ,aAAO,KAAK,UAAU,SAAS,GAAG;AAChC,cAAM,UAAU,KAAK,UAAU,MAAM;AACrC,gBAAQ,QAAQ,EAAC,MAAM,KAAI,CAAC;AAAA,MAC9B;AACA,WAAK,UAAU;AAAA,IACjB;AAAA;AAAA;AAAA,IAKA,OAAwC;AAEtC,UAAI,KAAK,QAAQ,SAAS,GAAG;AAC3B,cAAM,QAAQ,KAAK,QAAQ,MAAM;AACjC,YAAI,iBAAiB,OAAO;AAC1B,iBAAO,QAAQ,OAAO,KAAK;AAAA,QAC7B;AACA,eAAO,QAAQ,QAAQ,EAAC,MAAM,OAAO,MAAK,CAAC;AAAA,MAC7C;AAGA,UAAI,KAAK,SAAS;AAChB,YAAI,KAAK,UAAU,SAAS,GAAG;AAC7B,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AACA,eAAO,QAAQ,QAAQ,EAAC,MAAM,MAAM,OAAO,OAAS,CAAC;AAAA,MACvD;AAGA,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,aAAK,UAAU,KAAK,EAAC,SAAS,OAAM,CAAC;AAAA,MACvC,CAAC;AAAA,IACH;AAAA,EACF;;;ACpFO,WAAS,gBACd,QACA,YAAqB,MACrB,WACgB;AAEhB,UAAM,eAAe,aAAa,oBAAI,IAAI;AAE1C,QAAI,CAAC,QAAQ;AAAA,IAEb,WAAW,eAAe,MAAM,GAAG;AACjC,mBAAa,IAAI,MAAM;AAAA,IACzB,WAAW,eAAe,OAAO,MAAM,GAAG;AAExC,mBAAa,IAAI,OAAO,MAAM;AAAA,IAChC,WAAW,YAAY,OAAO,MAAM,GAAG;AAAA,IAGvC,WAAW,aAAa,OAAO,WAAW,UAAU;AAClD,iBAAW,OAAO,QAAQ;AAExB,wBAAgB,OAAO,GAAG,GAAG,WAAW,YAAY;AAAA,MACtD;AAAA,IACF;AAIA,WAAO,cAAc,SAAY,MAAM,KAAK,YAAY,IAAI,CAAC;AAAA,EAC/D;AAGA,WAAS,eAAe,QAAiB;AACvC,QAAI,CAAC,QAAQ;AACX,aAAO;AAAA,IACT;AACA,QAAI,kBAAkB,aAAa;AACjC,aAAO;AAAA,IACT;AACA,QAAI,OAAO,gBAAgB,eAAe,kBAAkB,aAAa;AACvE,aAAO;AAAA,IACT;AACA,QAAI,OAAO,gBAAgB,eAAe,kBAAkB,aAAa;AACvE,aAAO;AAAA,IACT;AAEA,QAAI,OAAO,oBAAoB,eAAe,kBAAkB,iBAAiB;AAC/E,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;;;ACjDO,MAAM,aAAa;;;ACH1B,iBAAe,gBAAgB;AAiB7B,WAAO;AAAA,EACT;AAEA,MAAM,sBAAsB,oBAAI,IAAI;AAKpC,MAAqB,aAArB,MAAgC;AAAA;AAAA,IAE9B,aAAa,iBAAmC;AAC9C,aAAO,OAAO,SAAS,eAAe,QAAQ,MAAM,cAAc,CAAC;AAAA,IACrE;AAAA;AAAA;AAAA;AAAA,IAKA,WAAW,UAAU,WAA4E;AAC/F,qBAAe,cAAc,SAAS;AACpC,cAAMA,cAAa,MAAM,cAAc;AAEvC,cAAM,EAAC,MAAM,QAAO,IAAIA,cAAa,UAAU,QAAQ;AAIvD,kBAAU,MAAM,OAAO;AAAA,MACzB;AAEA,oBAAc,EAAE,KAAK,CAACA,gBAAe;AACnC,YAAIA,aAAY;AACd,UAAAA,YAAW,GAAG,WAAW,CAAC,YAAY;AACpC,0BAAc,OAAO;AAAA,UACvB,CAAC;AAGD,UAAAA,YAAW,GAAG,QAAQ,MAAM,QAAQ,MAAM,qBAAqB,CAAC;AAAA,QAClE,OAAO;AAEL,qBAAW,YAAY;AAAA,QACzB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IAEA,aAAa,iBACX,WACA;AACA,UAAI,mBAAmB,oBAAoB,IAAI,SAAS;AAExD,UAAI,CAAC,kBAAkB;AACrB,2BAAmB,OAAO,YAA+B;AACvD,cAAI,CAAC,eAAe,OAAO,GAAG;AAC5B;AAAA,UACF;AAEA,gBAAMA,cAAa,MAAM,cAAc;AAEvC,gBAAM,EAAC,MAAM,QAAO,IAAIA,cAAa,UAAU,QAAQ;AACvD,oBAAU,MAAM,OAAO;AAAA,QACzB;AAAA,MACF;AAEA,YAAMA,cAAa,MAAM,cAAc;AACvC,UAAIA,aAAY;AACd,gBAAQ,MAAM,iBAAiB;AAAA,MACjC,OAAO;AACL,mBAAW,iBAAiB,WAAW,gBAAgB;AAAA,MACzD;AAAA,IACF;AAAA,IAEA,aAAa,oBACX,WACA;AACA,YAAM,mBAAmB,oBAAoB,IAAI,SAAS;AAC1D,0BAAoB,OAAO,SAAS;AACpC,YAAMA,cAAa,MAAM,cAAc;AACvC,UAAIA,aAAY;AACd,gBAAQ,MAAM,iBAAiB;AAAA,MACjC,OAAO;AACL,mBAAW,oBAAoB,WAAW,gBAAgB;AAAA,MAC5D;AAAA,IACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,aAAa,YAAY,MAAyB,SAA8C;AAC9F,YAAM,OAA0B,EAAC,QAAQ,cAAc,MAAM,QAAO;AAIpE,YAAM,eAAe,gBAAgB,OAAO;AAE5C,YAAMA,cAAa,MAAM,cAAc;AACvC,UAAIA,aAAY;AACd,QAAAA,YAAW,YAAY,MAAM,YAAY;AAAA,MAE3C,OAAO;AAEL,mBAAW,YAAY,MAAM,YAAY;AAAA,MAC3C;AAAA,IACF;AAAA,EACF;AAGA,WAAS,eAAe,SAA4B;AAClD,UAAM,EAAC,MAAM,KAAI,IAAI;AACrB,WACE,SAAS,aACT,QACA,OAAO,KAAK,WAAW,YACvB,KAAK,OAAO,WAAW,YAAY;AAAA,EAEvC;;;AC/HA,MAAI,YAAY;AAChB,MAAI;AACJ,MAAI;AAWJ,iBAAsB,aACpB,SACA,kBACe;AACf,QAAI,CAAE,MAAM,WAAW,eAAe,GAAI;AACxC;AAAA,IACF;AAEA,UAAM,UAAyB;AAAA,MAC7B,SAAS;AAAA,IACX;AAGA,eAAW,YAAY,OAAO,MAAyB,YAAkC;AACvF,UAAI;AACF,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,gBAAI,CAAC,SAAS;AACZ,oBAAM,IAAI,MAAM,2CAA2C;AAAA,YAC7D;AACA,kBAAM,SAAS,MAAM,QAAQ,QAAQ,OAAO,QAAQ,WAAW,CAAC,GAAG,OAAO;AAC1E,uBAAW,YAAY,QAAQ,EAAC,OAAM,CAAC;AACvC;AAAA,UAEF,KAAK;AACH,gBAAI,CAAC,kBAAkB;AACrB,oBAAM,IAAI,MAAM,4CAA4C;AAAA,YAC9D;AACA,2BAAe,IAAI,WAAgB;AACnC,sBAAU,QAAQ,WAAW,CAAC;AAC9B,kBAAM,iBAAiB,iBAAiB,cAAc,SAAS,OAAO;AACtE,6BAAiB,SAAS,gBAAgB;AACxC,yBAAW,YAAY,gBAAgB,EAAC,QAAQ,MAAK,CAAC;AAAA,YACxD;AACA,uBAAW,YAAY,QAAQ,CAAC,CAAC;AACjC;AAAA,UAEF,KAAK;AACH,yBAAa,KAAK,QAAQ,KAAK;AAC/B;AAAA,UAEF,KAAK;AACH,yBAAa,MAAM;AACnB;AAAA,UAEF;AAAA,QACF;AAAA,MACF,SAAS,OAAP;AACA,cAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU;AACzD,mBAAW,YAAY,SAAS,EAAC,OAAO,QAAO,CAAC;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAEA,WAAS,oBAAoB,aAA0BC,WAAU,CAAC,GAAG;AACnE,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,KAAK;AAIX,YAAM,YAAY,CAAC,MAAcC,aAAkC;AACjE,YAAIA,SAAQ,OAAO,IAAI;AAErB;AAAA,QACF;AAEA,gBAAQ,MAAM;AAAA,UACZ,KAAK;AACH,uBAAW,oBAAoB,SAAS;AACxC,oBAAQA,SAAQ,MAAM;AACtB;AAAA,UAEF,KAAK;AACH,uBAAW,oBAAoB,SAAS;AACxC,mBAAOA,SAAQ,KAAK;AACpB;AAAA,UAEF;AAAA,QAEF;AAAA,MACF;AAEA,iBAAW,iBAAiB,SAAS;AAGrC,YAAM,UAAU,EAAC,IAAI,OAAO,aAAa,SAAAD,SAAO;AAChD,iBAAW,YAAY,WAAW,OAAO;AAAA,IAC3C,CAAC;AAAA,EACH;;;AC/GA,eAAa,OAAO,SAAS;AAE3B,WAAO;AAAA,EACT,CAAC;",
  "names": ["parentPort", "options", "payload"]
}
