{
  "version": 3,
  "sources": ["../src/lib/async-queue/async-queue.ts", "../src/lib/worker-utils/get-transfer-list.ts", "../src/lib/node/worker_threads.ts", "../src/lib/worker-farm/worker-body.ts", "../src/lib/worker-api/create-worker.ts", "../src/workers/null-worker.ts"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\n/**\n * Async Queue\n * - AsyncIterable: An async iterator can be\n * - Values can be pushed onto the queue\n * @example\n *   const asyncQueue = new AsyncQueue();\n *   setTimeout(() => asyncQueue.enqueue('tick'), 1000);\n *   setTimeout(() => asyncQueue.enqueue(new Error('done')), 10000);\n *   for await (const value of asyncQueue) {\n *     console.log(value); // tick\n *   }\n */\nexport default class AsyncQueue<T> {\n  private _values: any[];\n  private _settlers: any[];\n  private _closed: boolean;\n\n  constructor() {\n    this._values = []; // enqueues > dequeues\n    this._settlers = []; // dequeues > enqueues\n    this._closed = false;\n  }\n\n  /** Return an async iterator for this queue */\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  /** Push a new value - the async iterator will yield a promise resolved to this value */\n  push(value: T): void {\n    return this.enqueue(value);\n  }\n\n  /**\n   * Push a new value - the async iterator will yield a promise resolved to this value\n   * Add an error - the async iterator will yield a promise rejected with this value\n   */\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.shift();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.push(value);\n    }\n  }\n\n  /** Indicate that we not waiting for more values - The async iterator will be done */\n  close(): void {\n    while (this._settlers.length > 0) {\n      const settler = this._settlers.shift();\n      settler.resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  // ITERATOR IMPLEMENTATION\n\n  /** @returns a Promise for an IteratorResult */\n  next(): Promise<IteratorResult<T, any>> {\n    // If values in queue, yield the first value\n    if (this._values.length > 0) {\n      const value = this._values.shift();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({done: false, value});\n    }\n\n    // If queue is closed, the iterator is done\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true, value: undefined});\n    }\n\n    // Yield a promise that waits for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.push({resolve, reject});\n    });\n  }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(\n  object: any,\n  recursive: boolean = true,\n  transfers?: Set<any>\n): Transferable[] {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object: unknown) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  // @ts-ignore\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object: object | null): object {\n  if (object === null) {\n    return {};\n  }\n  const clone = Object.assign({}, object);\n\n  Object.keys(clone).forEach((key) => {\n    // Typed Arrays and Arrays are passed with no change\n    if (\n      typeof object[key] === 'object' &&\n      !ArrayBuffer.isView(object[key]) &&\n      !(object[key] instanceof Array)\n    ) {\n      clone[key] = getTransferListForWriter(object[key]);\n    } else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n      clone[key] = {};\n    } else {\n      clone[key] = object[key];\n    }\n  });\n\n  return clone;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport * as WorkerThreads from 'worker_threads';\nexport * from 'worker_threads';\nexport const parentPort = WorkerThreads?.parentPort;\nexport const NodeWorker = WorkerThreads.Worker;\nexport type NodeWorkerType = WorkerThreads.Worker;\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {WorkerMessageData, WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {getTransferList} from '../worker-utils/get-transfer-list';\n// import type {TransferListItem} from '../node/worker_threads';\nimport {parentPort} from '../node/worker_threads';\n\ntype TransferListItem = any;\n\n/** Vile hack to defeat over-zealous bundlers from stripping out the require */\nasync function getParentPort() {\n  // const isNode = globalThis.process;\n  // let parentPort;\n  // try {\n  //   // prettier-ignore\n  //   eval('globalThis.parentPort = require(\\'worker_threads\\').parentPort'); // eslint-disable-line no-eval\n  //   parentPort = globalThis.parentPort;\n  // } catch {\n  //   try {\n  //     // prettier-ignore\n  //     eval('globalThis.workerThreadsPromise = import(\\'worker_threads\\')'); // eslint-disable-line no-eval\n  //     const workerThreads = await globalThis.workerThreadsPromise;\n  //     parentPort = workerThreads.parentPort;\n  //   } catch (error) {\n  //     console.error((error as Error).message); // eslint-disable-line no-console\n  //   }\n  // }\n  return parentPort;\n}\n\nconst onMessageWrapperMap = new Map();\n\n/**\n * Type safe wrapper for worker code\n */\nexport default class WorkerBody {\n  /** Check that we are actually in a worker thread */\n  static async inWorkerThread(): Promise<boolean> {\n    return typeof self !== 'undefined' || Boolean(await getParentPort());\n  }\n\n  /*\n   * (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n   */\n  static set onmessage(onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any) {\n    async function handleMessage(message) {\n      const parentPort = await getParentPort();\n      // Confusingly the message itself also has a 'type' field which is always set to 'message'\n      const {type, payload} = parentPort ? message : message.data;\n      // if (!isKnownMessage(message)) {\n      //   return;\n      // }\n      onMessage(type, payload);\n    }\n\n    getParentPort().then((parentPort) => {\n      if (parentPort) {\n        parentPort.on('message', (message) => {\n          handleMessage(message);\n        });\n        // if (message == 'exit') { parentPort.unref(); }\n        // eslint-disable-next-line\n        parentPort.on('exit', () => console.debug('Node worker closing'));\n      } else {\n        // eslint-disable-next-line no-restricted-globals\n        globalThis.onmessage = handleMessage;\n      }\n    });\n  }\n\n  static async addEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    let onMessageWrapper = onMessageWrapperMap.get(onMessage);\n\n    if (!onMessageWrapper) {\n      onMessageWrapper = async (message: MessageEvent<any>) => {\n        if (!isKnownMessage(message)) {\n          return;\n        }\n\n        const parentPort = await getParentPort();\n        // Confusingly in the browser, the message itself also has a 'type' field which is always set to 'message'\n        const {type, payload} = parentPort ? message : message.data;\n        onMessage(type, payload);\n      };\n    }\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.addEventListener('message', onMessageWrapper);\n    }\n  }\n\n  static async removeEventListener(\n    onMessage: (type: WorkerMessageType, payload: WorkerMessagePayload) => any\n  ) {\n    const onMessageWrapper = onMessageWrapperMap.get(onMessage);\n    onMessageWrapperMap.delete(onMessage);\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      console.error('not implemented'); // eslint-disable-line\n    } else {\n      globalThis.removeEventListener('message', onMessageWrapper);\n    }\n  }\n\n  /**\n   * Send a message from a worker to creating thread (main thread)\n   * @param type\n   * @param payload\n   */\n  static async postMessage(type: WorkerMessageType, payload: WorkerMessagePayload): Promise<void> {\n    const data: WorkerMessageData = {source: 'loaders.gl', type, payload};\n    // console.log('posting message', data);\n\n    // Cast to Node compatible transfer list\n    const transferList = getTransferList(payload) as TransferListItem[];\n\n    const parentPort = await getParentPort();\n    if (parentPort) {\n      parentPort.postMessage(data, transferList);\n      // console.log('posted message', data);\n    } else {\n      // @ts-expect-error Outside of worker scopes this call has a third parameter\n      globalThis.postMessage(data, transferList);\n    }\n  }\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(message: MessageEvent<any>) {\n  const {type, data} = message;\n  return (\n    type === 'message' &&\n    data &&\n    typeof data.source === 'string' &&\n    data.source.startsWith('loaders.gl')\n  );\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches: AsyncQueue<any>;\nlet options: {[key: string]: any};\n\nexport type ProcessOnMainThread = (\n  data: any,\n  options?: {[key: string]: any},\n  context?: WorkerContext\n) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport async function createWorker(\n  process: Process,\n  processInBatches?: ProcessInBatches\n): Promise<void> {\n  if (!(await WorkerBody.inWorkerThread())) {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue<any>();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer: ArrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type: string, payload: WorkerMessagePayload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {createWorker} from '../lib/worker-api/create-worker';\n\ncreateWorker(async (data) => {\n  // @ts-ignore\n  return data;\n});\n"],
  "mappings": "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",
  "names": ["parentPort", "options", "payload"]
}
