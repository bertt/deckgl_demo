{
  "version": 3,
  "sources": ["index.js", "lib/fetch/fetch-file.js", "javascript-utils/is-type.js", "lib/fetch/fetch-error.js", "lib/utils/mime-type-utils.js", "lib/utils/url-utils.js", "lib/utils/resource-utils.js", "lib/utils/response-utils.js", "lib/fetch/read-array-buffer.js", "lib/loader-utils/option-utils.js", "lib/loader-utils/loggers.js", "lib/loader-utils/option-defaults.js", "lib/loader-utils/normalize-loader.js", "lib/api/register-loaders.js", "lib/api/select-loader.js", "lib/utils/log.js", "lib/api/parse.js", "lib/loader-utils/get-data.js", "iterators/make-iterator/make-string-iterator.js", "iterators/make-iterator/make-array-buffer-iterator.js", "iterators/make-iterator/make-blob-iterator.js", "iterators/make-iterator/make-stream-iterator.js", "iterators/make-iterator/make-iterator.js", "lib/loader-utils/get-fetch-function.js", "lib/loader-utils/loader-context.js", "lib/api/parse-sync.js", "lib/api/parse-in-batches.js", "lib/api/load.js", "lib/api/load-in-batches.js", "lib/api/encode-table.js", "lib/api/encode.js", "iterators/make-stream/make-stream.js", "null-loader.js", "lib/progress/fetch-progress.js", "lib/filesystems/browser-filesystem.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// FILE READING AND WRITING\nexport { fetchFile } from \"./lib/fetch/fetch-file.js\";\nexport { FetchError } from \"./lib/fetch/fetch-error.js\";\nexport { readArrayBuffer } from \"./lib/fetch/read-array-buffer.js\";\n// export {readFileSync} from './lib/fetch/read-file';\n// export {writeFile, writeFileSync} from './lib/fetch/write-file';\n// CONFIGURATION\nexport { setLoaderOptions, getLoaderOptions } from \"./lib/api/loader-options.js\";\nexport { registerLoaders } from \"./lib/api/register-loaders.js\";\nexport { selectLoader, selectLoaderSync } from \"./lib/api/select-loader.js\";\n// LOADING (READING + PARSING)\nexport { parse } from \"./lib/api/parse.js\";\nexport { parseSync } from \"./lib/api/parse-sync.js\";\nexport { parseInBatches } from \"./lib/api/parse-in-batches.js\";\nexport { load } from \"./lib/api/load.js\";\nexport { loadInBatches } from \"./lib/api/load-in-batches.js\";\n// ENCODING (ENCODING AND WRITING)\nexport { encodeTable, encodeTableAsText, encodeTableInBatches } from \"./lib/api/encode-table.js\";\nexport { encode, encodeSync, encodeInBatches, encodeURLtoURL } from \"./lib/api/encode.js\";\nexport { encodeText, encodeTextSync } from \"./lib/api/encode.js\";\n// CORE UTILS SHARED WITH LOADERS (RE-EXPORTED FROM LOADER-UTILS)\nexport { setPathPrefix, getPathPrefix, resolvePath } from '@loaders.gl/loader-utils';\nexport { RequestScheduler } from '@loaders.gl/loader-utils';\n// ITERATOR UTILS\nexport { makeIterator } from \"./iterators/make-iterator/make-iterator.js\";\nexport { makeStream } from \"./iterators/make-stream/make-stream.js\";\n// CORE LOADERS\nexport { NullWorkerLoader, NullLoader } from \"./null-loader.js\";\nexport { JSONLoader } from '@loaders.gl/loader-utils';\n// EXPERIMENTAL\nexport { fetchProgress as _fetchProgress } from \"./lib/progress/fetch-progress.js\";\nexport { BrowserFileSystem as _BrowserFileSystem } from \"./lib/filesystems/browser-filesystem.js\";\n// FOR TESTING\nexport { _unregisterLoaders } from \"./lib/api/register-loaders.js\";\n//\n// TODO - MOVE TO LOADER-UTILS AND DEPRECATE IN CORE?\n//\nexport { isBrowser, isWorker, self, window, global, document } from '@loaders.gl/loader-utils';\nexport { assert } from '@loaders.gl/loader-utils';\nexport { forEach, concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nexport { makeTextDecoderIterator, makeTextEncoderIterator, makeLineIterator, makeNumberedLineIterator } from '@loaders.gl/loader-utils';\n// \"JAVASCRIPT\" UTILS - move to loader-utils?\nexport { isPureObject, isPromise, isIterable, isAsyncIterable, isIterator, isResponse, isReadableStream, isWritableStream } from \"./javascript-utils/is-type.js\";\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { resolvePath } from '@loaders.gl/loader-utils';\nimport { makeResponse } from \"../utils/response-utils.js\";\n// import {FetchError} from './fetch-error';\nexport function isNodePath(url) {\n    return !isRequestURL(url) && !isDataURL(url);\n}\nexport function isRequestURL(url) {\n    return url.startsWith('http:') || url.startsWith('https:');\n}\nexport function isDataURL(url) {\n    return url.startsWith('data:');\n}\n/**\n * fetch API compatible function\n * - Supports fetching from Node.js local file system paths\n * - Respects pathPrefix and file aliases\n */\nexport async function fetchFile(urlOrData, fetchOptions) {\n    if (typeof urlOrData === 'string') {\n        const url = resolvePath(urlOrData);\n        // Support fetching from local file system\n        if (isNodePath(url)) {\n            if (globalThis.loaders?.fetchNode) {\n                return globalThis.loaders?.fetchNode(url, fetchOptions);\n            }\n            // throw new Error(\n            //   'fetchFile: globalThis.loaders.fetchNode not defined. Install @loaders.gl/polyfills'\n            // );\n        }\n        // Call global fetch\n        return await fetch(url, fetchOptions);\n    }\n    // TODO - should we still call fetch on non-URL inputs?\n    return await makeResponse(urlOrData);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst isBoolean = (x) => typeof x === 'boolean';\nconst isFunction = (x) => typeof x === 'function';\nexport const isObject = (x) => x !== null && typeof x === 'object';\nexport const isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;\nexport const isPromise = (x) => isObject(x) && isFunction(x.then);\nexport const isIterable = (x) => Boolean(x) && typeof x[Symbol.iterator] === 'function';\nexport const isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === 'function';\nexport const isIterator = (x) => x && isFunction(x.next);\nexport const isResponse = (x) => (typeof Response !== 'undefined' && x instanceof Response) ||\n    (x && x.arrayBuffer && x.text && x.json);\nexport const isFile = (x) => typeof File !== 'undefined' && x instanceof File;\nexport const isBlob = (x) => typeof Blob !== 'undefined' && x instanceof Blob;\n/** Check for Node.js `Buffer` without triggering bundler to include buffer polyfill */\nexport const isBuffer = (x) => x && typeof x === 'object' && x.isBuffer;\nexport const isWritableDOMStream = (x) => isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);\nexport const isReadableDOMStream = (x) => (typeof ReadableStream !== 'undefined' && x instanceof ReadableStream) ||\n    (isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader));\n// Not implemented in Firefox: && isFunction(x.pipeTo)\nexport const isWritableNodeStream = (x) => isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);\nexport const isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);\nexport const isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);\nexport const isWritableStream = (x) => isWritableDOMStream(x) || isWritableNodeStream(x);\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport class FetchError extends Error {\n    constructor(message, info) {\n        super(message);\n        this.reason = info.reason;\n        this.url = info.url;\n        this.response = info.response;\n    }\n    /** A best effort reason for why the fetch failed */\n    reason;\n    /** The URL that failed to load. Empty string if not available. */\n    url;\n    /** The Response object, if any. */\n    response;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TODO - build/integrate proper MIME type parsing\n// https://mimesniff.spec.whatwg.org/\nconst DATA_URL_PATTERN = /^data:([-\\w.]+\\/[-\\w.+]+)(;|,)/;\nconst MIME_TYPE_PATTERN = /^([-\\w.]+\\/[-\\w.+]+)/;\n/**\n * Compare two MIME types, case insensitively etc.\n * @param mimeType1\n * @param mimeType2\n * @returns true if the MIME types are equivalent\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#structure_of_a_mime_type\n */\nexport function compareMIMETypes(mimeType1, mimeType2) {\n    if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {\n        return true;\n    }\n    return false;\n}\n/**\n * Remove extra data like `charset` from MIME types\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMEType(mimeString) {\n    // If resource is a data url, extract any embedded mime type\n    const matches = MIME_TYPE_PATTERN.exec(mimeString);\n    if (matches) {\n        return matches[1];\n    }\n    return mimeString;\n}\n/**\n * Extract MIME type from data URL\n *\n * @param mimeString\n * @returns A clean MIME type, or an empty string\n *\n * @todo - handle more advanced MIMETYpes, multiple types\n * @todo - extract charset etc\n */\nexport function parseMIMETypeFromURL(url) {\n    // If resource is a data URL, extract any embedded mime type\n    const matches = DATA_URL_PATTERN.exec(url);\n    if (matches) {\n        return matches[1];\n    }\n    return '';\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst QUERY_STRING_PATTERN = /\\?.*/;\nexport function extractQueryString(url) {\n    const matches = url.match(QUERY_STRING_PATTERN);\n    return matches && matches[0];\n}\nexport function stripQueryString(url) {\n    return url.replace(QUERY_STRING_PATTERN, '');\n}\nexport function shortenUrlForDisplay(url) {\n    if (url.length < 50) {\n        return url;\n    }\n    const urlEnd = url.slice(url.length - 15);\n    const urlStart = url.substr(0, 32);\n    return `${urlStart}...${urlEnd}`;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse, isBlob } from \"../../javascript-utils/is-type.js\";\nimport { parseMIMEType, parseMIMETypeFromURL } from \"./mime-type-utils.js\";\nimport { stripQueryString } from \"./url-utils.js\";\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceUrl(resource) {\n    // If resource is a `Response`, it contains the information directly as a field\n    if (isResponse(resource)) {\n        const response = resource;\n        return response.url;\n    }\n    // If the resource is a Blob or a File (subclass of Blob)\n    if (isBlob(resource)) {\n        const blob = resource;\n        // File objects have a \"name\" property. Blob objects don't have any\n        // url (name) information\n        return blob.name || '';\n    }\n    if (typeof resource === 'string') {\n        return resource;\n    }\n    // Unknown\n    return '';\n}\n/**\n * Returns the URL associated with this resource.\n * The returned value may include a query string and need further processing.\n * If it cannot determine url, the corresponding value will be an empty string\n *\n * @todo string parameters are assumed to be URLs\n */\nexport function getResourceMIMEType(resource) {\n    // If resource is a response, it contains the information directly\n    if (isResponse(resource)) {\n        const response = resource;\n        const contentTypeHeader = response.headers.get('content-type') || '';\n        const noQueryUrl = stripQueryString(response.url);\n        return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);\n    }\n    // If the resource is a Blob or a File (subclass of Blob)\n    if (isBlob(resource)) {\n        const blob = resource;\n        return blob.type || '';\n    }\n    if (typeof resource === 'string') {\n        return parseMIMETypeFromURL(resource);\n    }\n    // Unknown\n    return '';\n}\n/**\n  * Returns (approximate) content length for a resource if it can be determined.\n  * Returns -1 if content length cannot be determined.\n  * @param resource\n\n  * @note string parameters are NOT assumed to be URLs\n  */\nexport function getResourceContentLength(resource) {\n    if (isResponse(resource)) {\n        const response = resource;\n        return response.headers['content-length'] || -1;\n    }\n    if (isBlob(resource)) {\n        const blob = resource;\n        return blob.size;\n    }\n    if (typeof resource === 'string') {\n        // TODO - handle data URL?\n        return resource.length;\n    }\n    if (resource instanceof ArrayBuffer) {\n        return resource.byteLength;\n    }\n    if (ArrayBuffer.isView(resource)) {\n        return resource.byteLength;\n    }\n    return -1;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { FetchError } from \"../fetch/fetch-error.js\";\nimport { getResourceContentLength, getResourceUrl, getResourceMIMEType } from \"./resource-utils.js\";\nimport { shortenUrlForDisplay } from \"./url-utils.js\";\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource) {\n    if (isResponse(resource)) {\n        return resource;\n    }\n    // Add content-length header if possible\n    const headers = {};\n    const contentLength = getResourceContentLength(resource);\n    if (contentLength >= 0) {\n        headers['content-length'] = String(contentLength);\n    }\n    // `new Response(File)` does not preserve content-type and URL\n    // so we add them here\n    const url = getResourceUrl(resource);\n    const type = getResourceMIMEType(resource);\n    if (type) {\n        headers['content-type'] = type;\n    }\n    // Add a custom header with initial bytes if available\n    const initialDataUrl = await getInitialDataUrl(resource);\n    if (initialDataUrl) {\n        headers['x-first-bytes'] = initialDataUrl;\n    }\n    // TODO - is this the best way of handling strings?\n    // Maybe package as data URL instead?\n    if (typeof resource === 'string') {\n        // Convert to ArrayBuffer to avoid Response treating it as a URL\n        resource = new TextEncoder().encode(resource);\n    }\n    // Attempt to create a Response from the resource, adding headers and setting url\n    const response = new Response(resource, { headers });\n    // We can't control `Response.url` via constructor, use a property override to record URL.\n    Object.defineProperty(response, 'url', { value: url });\n    return response;\n}\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response) {\n    if (!response.ok) {\n        const error = await getResponseError(response);\n        throw error;\n    }\n}\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response) {\n    if (!response.ok) {\n        let message = `${response.status} ${response.statusText}`;\n        message = message.length > 60 ? `${message.slice(0, 60)}...` : message;\n        throw new Error(message);\n    }\n}\n// HELPERS\nasync function getResponseError(response) {\n    const shortUrl = shortenUrlForDisplay(response.url);\n    let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;\n    message = message.length > 100 ? `${message.slice(0, 100)}...` : message;\n    const info = {\n        reason: response.statusText,\n        url: response.url,\n        response\n    };\n    try {\n        const contentType = response.headers.get('Content-Type');\n        info.reason = contentType?.includes('application/json')\n            ? await response.json()\n            : response.text();\n    }\n    catch (error) {\n        // eslint forbids return in a finally statement, so we just catch here\n    }\n    return new FetchError(message, info);\n}\nasync function getInitialDataUrl(resource) {\n    const INITIAL_DATA_LENGTH = 5;\n    if (typeof resource === 'string') {\n        return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n    }\n    if (resource instanceof Blob) {\n        const blobSlice = resource.slice(0, 5);\n        return await new Promise((resolve) => {\n            const reader = new FileReader();\n            reader.onload = (event) => resolve(event?.target?.result);\n            reader.readAsDataURL(blobSlice);\n        });\n    }\n    if (resource instanceof ArrayBuffer) {\n        const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n        const base64 = arrayBufferToBase64(slice);\n        return `data:base64,${base64}`;\n    }\n    return null;\n}\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(file, start, length) {\n    // TODO - we can do better for ArrayBuffer and string\n    if (!(file instanceof Blob)) {\n        file = new Blob([file]);\n    }\n    const slice = file.slice(start, start + length);\n    return await readBlob(slice);\n}\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob) {\n    return await new Promise((resolve, reject) => {\n        const fileReader = new FileReader();\n        fileReader.onload = (event) => resolve(event?.target?.result);\n        // TODO - reject with a proper Error\n        fileReader.onerror = (error) => reject(error);\n        fileReader.readAsArrayBuffer(blob);\n    });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { registerJSModules } from '@loaders.gl/loader-utils';\nimport { isPureObject, isObject } from \"../../javascript-utils/is-type.js\";\nimport { probeLog, NullLog } from \"./loggers.js\";\nimport { DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS } from \"./option-defaults.js\";\n/**\n * Helper for safely accessing global loaders.gl variables\n * Wraps initialization of global variable in function to defeat overly aggressive tree-shakers\n */\nexport function getGlobalLoaderState() {\n    // @ts-ignore\n    globalThis.loaders = globalThis.loaders || {};\n    // @ts-ignore\n    const { loaders } = globalThis;\n    // Add _state object to keep separate from modules added to globalThis.loaders\n    if (!loaders._state) {\n        loaders._state = {};\n    }\n    return loaders._state;\n}\n/**\n * Store global loader options on the global object to increase chances of cross loaders-version interoperability\n * NOTE: This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks\n * @returns global loader options merged with default loader options\n */\nexport function getGlobalLoaderOptions() {\n    const state = getGlobalLoaderState();\n    // Ensure all default loader options from this library are mentioned\n    state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };\n    return state.globalOptions;\n}\n/**\n * Set global loader options\n * @param options\n */\nexport function setGlobalOptions(options) {\n    const state = getGlobalLoaderState();\n    const globalOptions = getGlobalLoaderOptions();\n    // @ts-expect-error First param looks incorrect\n    state.globalOptions = normalizeOptionsInternal(globalOptions, options);\n    // Make sure any new modules are registered\n    registerJSModules(options.modules);\n}\n/**\n * Merges options with global opts and loader defaults, also injects baseUri\n * @param options\n * @param loader\n * @param loaders\n * @param url\n */\nexport function normalizeOptions(options, loader, loaders, url) {\n    loaders = loaders || [];\n    loaders = Array.isArray(loaders) ? loaders : [loaders];\n    validateOptions(options, loaders);\n    return normalizeOptionsInternal(loader, options, url);\n}\n// VALIDATE OPTIONS\n/**\n * Warn for unsupported options\n * @param options\n * @param loaders\n */\nfunction validateOptions(options, loaders) {\n    // Check top level options\n    validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);\n    for (const loader of loaders) {\n        // Get the scoped, loader specific options from the user supplied options\n        const idOptions = ((options && options[loader.id]) || {});\n        // Get scoped, loader specific default and deprecated options from the selected loader\n        const loaderOptions = (loader.options && loader.options[loader.id]) || {};\n        const deprecatedOptions = (loader.deprecatedOptions && loader.deprecatedOptions[loader.id]) || {};\n        // Validate loader specific options\n        // @ts-ignore\n        validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);\n    }\n}\n// eslint-disable-next-line max-params, complexity\nfunction validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {\n    const loaderName = id || 'Top level';\n    const prefix = id ? `${id}.` : '';\n    for (const key in options) {\n        // If top level option value is an object it could options for a loader, so ignore\n        const isSubOptions = !id && isObject(options[key]);\n        const isBaseUriOption = key === 'baseUri' && !id;\n        const isWorkerUrlOption = key === 'workerUrl' && id;\n        // <loader>.workerUrl requires special handling as it is now auto-generated and no longer specified as a default option.\n        if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {\n            // Issue deprecation warnings\n            if (key in deprecatedOptions) {\n                probeLog.warn(`${loaderName} loader option \\'${prefix}${key}\\' no longer supported, use \\'${deprecatedOptions[key]}\\'`)();\n            }\n            else if (!isSubOptions) {\n                const suggestion = findSimilarOption(key, loaders);\n                probeLog.warn(`${loaderName} loader option \\'${prefix}${key}\\' not recognized. ${suggestion}`)();\n            }\n        }\n    }\n}\nfunction findSimilarOption(optionKey, loaders) {\n    const lowerCaseOptionKey = optionKey.toLowerCase();\n    let bestSuggestion = '';\n    for (const loader of loaders) {\n        for (const key in loader.options) {\n            if (optionKey === key) {\n                return `Did you mean \\'${loader.id}.${key}\\'?`;\n            }\n            const lowerCaseKey = key.toLowerCase();\n            const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);\n            if (isPartialMatch) {\n                bestSuggestion = bestSuggestion || `Did you mean \\'${loader.id}.${key}\\'?`;\n            }\n        }\n    }\n    return bestSuggestion;\n}\nfunction normalizeOptionsInternal(loader, options, url) {\n    const loaderDefaultOptions = loader.options || {};\n    const mergedOptions = { ...loaderDefaultOptions };\n    addUrlOptions(mergedOptions, url);\n    // LOGGING: options.log can be set to `null` to defeat logging\n    if (mergedOptions.log === null) {\n        mergedOptions.log = new NullLog();\n    }\n    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());\n    mergeNestedFields(mergedOptions, options);\n    return mergedOptions;\n}\n// Merge nested options objects\nfunction mergeNestedFields(mergedOptions, options) {\n    for (const key in options) {\n        // Check for nested options\n        // object in options => either no key in defaultOptions or object in defaultOptions\n        if (key in options) {\n            const value = options[key];\n            if (isPureObject(value) && isPureObject(mergedOptions[key])) {\n                mergedOptions[key] = {\n                    ...mergedOptions[key],\n                    ...options[key]\n                };\n            }\n            else {\n                mergedOptions[key] = options[key];\n            }\n        }\n        // else: No need to merge nested opts, and the initial merge already copied over the nested options\n    }\n}\n/**\n * Harvest information from the url\n * @deprecated This is mainly there to support a hack in the GLTFLoader\n * TODO - baseUri should be a directory, i.e. remove file component from baseUri\n * TODO - extract extension?\n * TODO - extract query parameters?\n * TODO - should these be injected on context instead of options?\n */\nfunction addUrlOptions(options, url) {\n    if (url && !('baseUri' in options)) {\n        options.baseUri = url;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// probe.gl Log compatible loggers\nimport { Log } from '@probe.gl/log';\nexport const probeLog = new Log({ id: 'loaders.gl' });\n// Logs nothing\nexport class NullLog {\n    log() {\n        return () => { };\n    }\n    info() {\n        return () => { };\n    }\n    warn() {\n        return () => { };\n    }\n    error() {\n        return () => { };\n    }\n}\n// Logs to console\nexport class ConsoleLog {\n    console;\n    constructor() {\n        this.console = console; // eslint-disable-line\n    }\n    log(...args) {\n        return this.console.log.bind(this.console, ...args);\n    }\n    info(...args) {\n        return this.console.info.bind(this.console, ...args);\n    }\n    warn(...args) {\n        return this.console.warn.bind(this.console, ...args);\n    }\n    error(...args) {\n        return this.console.error.bind(this.console, ...args);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser } from '@loaders.gl/loader-utils';\nimport { ConsoleLog } from \"./loggers.js\";\nexport const DEFAULT_LOADER_OPTIONS = {\n    // baseUri\n    fetch: null,\n    mimeType: undefined,\n    nothrow: false,\n    log: new ConsoleLog(), // A probe.gl compatible (`log.log()()` syntax) that just logs to console\n    useLocalLibraries: false,\n    CDN: 'https://unpkg.com/@loaders.gl',\n    worker: true, // By default, use worker if provided by loader.\n    maxConcurrency: 3, // How many worker instances should be created for each loader.\n    maxMobileConcurrency: 1, // How many worker instances should be created for each loader on mobile devices.\n    reuseWorkers: isBrowser, // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)\n    _nodeWorkers: false, // By default do not support node workers\n    _workerType: '', // 'test' to use locally generated workers\n    limit: 0,\n    _limitMB: 0,\n    batchSize: 'auto',\n    batchDebounceMs: 0,\n    metadata: false, // TODO - currently only implemented for parseInBatches, adds initial metadata batch,\n    transforms: []\n};\nexport const REMOVED_LOADER_OPTIONS = {\n    throws: 'nothrow',\n    dataType: '(no longer used)',\n    uri: 'baseUri',\n    // Warn if fetch options are used on top-level\n    method: 'fetch.method',\n    headers: 'fetch.headers',\n    body: 'fetch.body',\n    mode: 'fetch.mode',\n    credentials: 'fetch.credentials',\n    cache: 'fetch.cache',\n    redirect: 'fetch.redirect',\n    referrer: 'fetch.referrer',\n    referrerPolicy: 'fetch.referrerPolicy',\n    integrity: 'fetch.integrity',\n    keepalive: 'fetch.keepalive',\n    signal: 'fetch.signal'\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nexport function isLoaderObject(loader) {\n    if (!loader) {\n        return false;\n    }\n    if (Array.isArray(loader)) {\n        loader = loader[0];\n    }\n    const hasExtensions = Array.isArray(loader?.extensions);\n    /* Now handled by types and worker loaders do not have these\n    let hasParser =\n      loader.parseTextSync ||\n      loader.parseSync ||\n      loader.parse ||\n      loader.parseStream || // TODO Remove, Replace with parseInBatches\n      loader.parseInBatches;\n    */\n    return hasExtensions;\n}\nexport function normalizeLoader(loader) {\n    // This error is fairly easy to trigger by mixing up import statements etc\n    // So we make an exception and add a developer error message for this case\n    // To help new users from getting stuck here\n    assert(loader, 'null loader');\n    assert(isLoaderObject(loader), 'invalid loader');\n    // NORMALIZE [LOADER, OPTIONS] => LOADER\n    // If [loader, options], create a new loaders object with options merged in\n    let options;\n    if (Array.isArray(loader)) {\n        options = loader[1];\n        loader = loader[0];\n        loader = {\n            ...loader,\n            options: { ...loader.options, ...options }\n        };\n    }\n    // NORMALIZE text and binary flags\n    // Ensure at least one of text/binary flags are properly set\n    // @ts-expect-error\n    if (loader?.parseTextSync || loader?.parseText) {\n        loader.text = true;\n    }\n    if (!loader.text) {\n        loader.binary = true;\n    }\n    return loader;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { normalizeLoader } from \"../loader-utils/normalize-loader.js\";\nimport { getGlobalLoaderState } from \"../loader-utils/option-utils.js\";\n/**\n * Store global registered loaders on the global object to increase chances of cross loaders-version interoperability\n * This use case is not reliable but can help when testing new versions of loaders.gl with existing frameworks\n */\nconst getGlobalLoaderRegistry = () => {\n    const state = getGlobalLoaderState();\n    state.loaderRegistry = state.loaderRegistry || [];\n    return state.loaderRegistry;\n};\n/** Register a list of global loaders */\nexport function registerLoaders(loaders) {\n    const loaderRegistry = getGlobalLoaderRegistry();\n    loaders = Array.isArray(loaders) ? loaders : [loaders];\n    for (const loader of loaders) {\n        const normalizedLoader = normalizeLoader(loader);\n        if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {\n            // add to the beginning of the loaderRegistry, so the last registeredLoader get picked\n            loaderRegistry.unshift(normalizedLoader);\n        }\n    }\n}\nexport function getRegisteredLoaders() {\n    return getGlobalLoaderRegistry();\n}\n/** @deprecated For testing only  */\nexport function _unregisterLoaders() {\n    const state = getGlobalLoaderState();\n    state.loaderRegistry = [];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { compareArrayBuffers, path } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from \"../loader-utils/normalize-loader.js\";\nimport { log } from \"../utils/log.js\";\nimport { getResourceUrl, getResourceMIMEType } from \"../utils/resource-utils.js\";\nimport { compareMIMETypes } from \"../utils/mime-type-utils.js\";\nimport { getRegisteredLoaders } from \"./register-loaders.js\";\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { stripQueryString } from \"../utils/url-utils.js\";\nconst EXT_PATTERN = /\\.([^.]+)$/;\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(data, loaders = [], options, context) {\n    if (!validHTTPResponse(data)) {\n        return null;\n    }\n    // First make a sync attempt, disabling exceptions\n    let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);\n    if (loader) {\n        return loader;\n    }\n    // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n    // to see if we can detect by initial content\n    if (isBlob(data)) {\n        data = await data.slice(0, 10).arrayBuffer();\n        loader = selectLoaderSync(data, loaders, options, context);\n    }\n    // no loader available\n    if (!loader && !options?.nothrow) {\n        throw new Error(getNoValidLoaderMessage(data));\n    }\n    return loader;\n}\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(data, loaders = [], options, context) {\n    if (!validHTTPResponse(data)) {\n        return null;\n    }\n    // eslint-disable-next-line complexity\n    // if only a single loader was provided (not as array), force its use\n    // TODO - Should this behavior be kept and documented?\n    if (loaders && !Array.isArray(loaders)) {\n        // TODO - remove support for legacy loaders\n        return normalizeLoader(loaders);\n    }\n    // Build list of candidate loaders that will be searched in order for a match\n    let candidateLoaders = [];\n    // First search supplied loaders\n    if (loaders) {\n        candidateLoaders = candidateLoaders.concat(loaders);\n    }\n    // Then fall back to registered loaders\n    if (!options?.ignoreRegisteredLoaders) {\n        candidateLoaders.push(...getRegisteredLoaders());\n    }\n    // TODO - remove support for legacy loaders\n    normalizeLoaders(candidateLoaders);\n    const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n    // no loader available\n    if (!loader && !options?.nothrow) {\n        throw new Error(getNoValidLoaderMessage(data));\n    }\n    return loader;\n}\n/** Implements loaders selection logic */\n// eslint-disable-next-line complexity\nfunction selectLoaderInternal(data, loaders, options, context) {\n    const url = getResourceUrl(data);\n    const type = getResourceMIMEType(data);\n    const testUrl = stripQueryString(url) || context?.url;\n    let loader = null;\n    let reason = '';\n    // if options.mimeType is supplied, it takes precedence\n    if (options?.mimeType) {\n        loader = findLoaderByMIMEType(loaders, options?.mimeType);\n        reason = `match forced by supplied MIME type ${options?.mimeType}`;\n    }\n    // Look up loader by url\n    loader = loader || findLoaderByUrl(loaders, testUrl);\n    reason = reason || (loader ? `matched url ${testUrl}` : '');\n    // Look up loader by mime type\n    loader = loader || findLoaderByMIMEType(loaders, type);\n    reason = reason || (loader ? `matched MIME type ${type}` : '');\n    // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n    // @ts-ignore Blob | Response\n    loader = loader || findLoaderByInitialBytes(loaders, data);\n    // @ts-ignore Blob | Response\n    reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n    // Look up loader by fallback mime type\n    if (options?.fallbackMimeType) {\n        loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n        reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n    }\n    if (reason) {\n        log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n    }\n    return loader;\n}\n/** Check HTTP Response */\nfunction validHTTPResponse(data) {\n    // HANDLE HTTP status\n    if (data instanceof Response) {\n        // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n        if (data.status === 204) {\n            return false;\n        }\n    }\n    return true;\n}\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data) {\n    const url = getResourceUrl(data);\n    const type = getResourceMIMEType(data);\n    let message = 'No valid loader found (';\n    message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n    message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n    // First characters are only accessible when called on data (string or arrayBuffer).\n    // @ts-ignore Blob | Response\n    const firstCharacters = data ? getFirstCharacters(data) : '';\n    message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n    message += ')';\n    return message;\n}\nfunction normalizeLoaders(loaders) {\n    for (const loader of loaders) {\n        normalizeLoader(loader);\n    }\n}\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n    // Get extension\n    const match = url && EXT_PATTERN.exec(url);\n    const extension = match && match[1];\n    return extension ? findLoaderByExtension(loaders, extension) : null;\n}\nfunction findLoaderByExtension(loaders, extension) {\n    extension = extension.toLowerCase();\n    for (const loader of loaders) {\n        for (const loaderExtension of loader.extensions) {\n            if (loaderExtension.toLowerCase() === extension) {\n                return loader;\n            }\n        }\n    }\n    return null;\n}\nfunction findLoaderByMIMEType(loaders, mimeType) {\n    for (const loader of loaders) {\n        if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {\n            return loader;\n        }\n        // Support referring to loaders using the \"unregistered tree\"\n        // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n        if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {\n            return loader;\n        }\n    }\n    return null;\n}\nfunction findLoaderByInitialBytes(loaders, data) {\n    if (!data) {\n        return null;\n    }\n    for (const loader of loaders) {\n        if (typeof data === 'string') {\n            if (testDataAgainstText(data, loader)) {\n                return loader;\n            }\n        }\n        else if (ArrayBuffer.isView(data)) {\n            // Typed Arrays can have offsets into underlying buffer\n            if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n                return loader;\n            }\n        }\n        else if (data instanceof ArrayBuffer) {\n            const byteOffset = 0;\n            if (testDataAgainstBinary(data, byteOffset, loader)) {\n                return loader;\n            }\n        }\n        // TODO Handle streaming case (requires creating a new AsyncIterator)\n    }\n    return null;\n}\nfunction testDataAgainstText(data, loader) {\n    if (loader.testText) {\n        return loader.testText(data);\n    }\n    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n    return tests.some((test) => data.startsWith(test));\n}\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n    return tests.some((test) => testBinary(data, byteOffset, loader, test));\n}\nfunction testBinary(data, byteOffset, loader, test) {\n    if (test instanceof ArrayBuffer) {\n        return compareArrayBuffers(test, data, test.byteLength);\n    }\n    switch (typeof test) {\n        case 'function':\n            return test(data);\n        case 'string':\n            // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n            const magic = getMagicString(data, byteOffset, test.length);\n            return test === magic;\n        default:\n            return false;\n    }\n}\nfunction getFirstCharacters(data, length = 5) {\n    if (typeof data === 'string') {\n        return data.slice(0, length);\n    }\n    else if (ArrayBuffer.isView(data)) {\n        // Typed Arrays can have offsets into underlying buffer\n        return getMagicString(data.buffer, data.byteOffset, length);\n    }\n    else if (data instanceof ArrayBuffer) {\n        const byteOffset = 0;\n        return getMagicString(data, byteOffset, length);\n    }\n    return '';\n}\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n    if (arrayBuffer.byteLength < byteOffset + length) {\n        return '';\n    }\n    const dataView = new DataView(arrayBuffer);\n    let magic = '';\n    for (let i = 0; i < length; i++) {\n        magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n    }\n    return magic;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Log } from '@probe.gl/log';\nexport const log = new Log({ id: 'loaders.gl' });\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseWithWorker, canParseWithWorker } from '@loaders.gl/loader-utils';\nimport { assert, validateWorkerVersion } from '@loaders.gl/worker-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { isResponse } from \"../../javascript-utils/is-type.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { mergeLoaderOptions } from '@loaders.gl/loader-utils';\nimport { getArrayBufferOrStringFromData } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\n// implementation signature\nexport async function parse(data, loaders, options, context) {\n    // Signature: parse(data, options, context | url)\n    // Uses registered loaders\n    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    data = await data; // Resolve any promise\n    options = options || {}; // Could be invalid...\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    // Chooses a loader (and normalizes it)\n    // Also use any loaders in the context, new loaders take priority\n    const typedLoaders = loaders;\n    const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n    // todo hacky type cast\n    const loader = await selectLoader(data, candidateLoaders, options);\n    // Note: if no loader was found, if so just return null\n    if (!loader) {\n        return null;\n    }\n    // Normalize options\n    // @ts-expect-error\n    options = normalizeOptions(options, loader, candidateLoaders, url); // Could be invalid...\n    // Get a context (if already present, will be unchanged)\n    context = getLoaderContext(\n    // @ts-expect-error\n    { url, _parse: parse, loaders: candidateLoaders }, options, context || null);\n    return await parseWithLoader(loader, data, options, context);\n}\n// TODO: support progress and abort\n// TODO - should accept loader.parseAsyncIterator and concatenate.\nasync function parseWithLoader(loader, data, options, context) {\n    validateWorkerVersion(loader);\n    options = mergeLoaderOptions(loader.options, options);\n    if (isResponse(data)) {\n        // Serialize to support passing the response to web worker\n        const response = data;\n        const { ok, redirected, status, statusText, type, url } = response;\n        const headers = Object.fromEntries(response.headers.entries());\n        // @ts-expect-error TODO - fix this\n        context.response = { headers, ok, redirected, status, statusText, type, url };\n    }\n    data = await getArrayBufferOrStringFromData(data, loader, options);\n    const loaderWithParser = loader;\n    // First check for synchronous text parser, wrap results in promises\n    if (loaderWithParser.parseTextSync && typeof data === 'string') {\n        return loaderWithParser.parseTextSync(data, options, context);\n    }\n    // If we have a workerUrl and the loader can parse the given options efficiently in a worker\n    if (canParseWithWorker(loader, options)) {\n        return await parseWithWorker(loader, data, options, context, parse);\n    }\n    // Check for asynchronous parser\n    if (loaderWithParser.parseText && typeof data === 'string') {\n        return await loaderWithParser.parseText(data, options, context);\n    }\n    if (loaderWithParser.parse) {\n        return await loaderWithParser.parse(data, options, context);\n    }\n    // This should not happen, all sync loaders should also offer `parse` function\n    assert(!loaderWithParser.parseSync);\n    // TBD - If asynchronous parser not available, return null\n    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isResponse, isReadableStream, isAsyncIterable, isIterable, isIterator, isBlob, isBuffer } from \"../../javascript-utils/is-type.js\";\nimport { makeIterator } from \"../../iterators/make-iterator/make-iterator.js\";\nimport { checkResponse, makeResponse } from \"../utils/response-utils.js\";\nconst ERR_DATA = 'Cannot convert supplied data type';\n// eslint-disable-next-line complexity\nexport function getArrayBufferOrStringFromDataSync(data, loader, options) {\n    if (loader.text && typeof data === 'string') {\n        return data;\n    }\n    if (isBuffer(data)) {\n        // @ts-ignore\n        data = data.buffer;\n    }\n    if (data instanceof ArrayBuffer) {\n        const arrayBuffer = data;\n        if (loader.text && !loader.binary) {\n            const textDecoder = new TextDecoder('utf8');\n            return textDecoder.decode(arrayBuffer);\n        }\n        return arrayBuffer;\n    }\n    // We may need to handle offsets\n    if (ArrayBuffer.isView(data)) {\n        // TextDecoder is invoked on typed arrays and will handle offsets\n        if (loader.text && !loader.binary) {\n            const textDecoder = new TextDecoder('utf8');\n            return textDecoder.decode(data);\n        }\n        let arrayBuffer = data.buffer;\n        // Since we are returning the underlying arrayBuffer, we must create a new copy\n        // if this typed array / Buffer is a partial view into the ArryayBuffer\n        // TODO - this is a potentially unnecessary copy\n        const byteLength = data.byteLength || data.length;\n        if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {\n            // console.warn(`loaders.gl copying arraybuffer of length ${byteLength}`);\n            arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);\n        }\n        return arrayBuffer;\n    }\n    throw new Error(ERR_DATA);\n}\n// Convert async iterator to a promise\nexport async function getArrayBufferOrStringFromData(data, loader, options) {\n    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);\n    if (typeof data === 'string' || isArrayBuffer) {\n        return getArrayBufferOrStringFromDataSync(data, loader, options);\n    }\n    // Blobs and files are FileReader compatible\n    if (isBlob(data)) {\n        data = await makeResponse(data);\n    }\n    if (isResponse(data)) {\n        const response = data;\n        await checkResponse(response);\n        return loader.binary ? await response.arrayBuffer() : await response.text();\n    }\n    if (isReadableStream(data)) {\n        // @ts-expect-error TS2559 options type\n        data = makeIterator(data, options);\n    }\n    if (isIterable(data) || isAsyncIterable(data)) {\n        // Assume arrayBuffer iterator - attempt to concatenate\n        return concatenateArrayBuffersAsync(data);\n    }\n    throw new Error(ERR_DATA);\n}\nexport async function getAsyncIterableFromData(data, options) {\n    if (isIterator(data)) {\n        return data;\n    }\n    if (isResponse(data)) {\n        const response = data;\n        // Note Since this function is not async, we currently can't load error message, just status\n        await checkResponse(response);\n        // TODO - bug in polyfill, body can be a Promise under Node.js\n        // eslint-disable-next-line @typescript-eslint/await-thenable\n        const body = await response.body;\n        // TODO - body can be null?\n        return makeIterator(body, options);\n    }\n    if (isBlob(data) || isReadableStream(data)) {\n        return makeIterator(data, options);\n    }\n    if (isAsyncIterable(data)) {\n        return data;\n    }\n    return getIterableFromData(data);\n}\nexport async function getReadableStream(data) {\n    if (isReadableStream(data)) {\n        return data;\n    }\n    if (isResponse(data)) {\n        // @ts-ignore\n        return data.body;\n    }\n    const response = await makeResponse(data);\n    // @ts-ignore\n    return response.body;\n}\n// HELPERS\nfunction getIterableFromData(data) {\n    // generate an iterator that emits a single chunk\n    if (ArrayBuffer.isView(data)) {\n        return (function* oneChunk() {\n            yield data.buffer;\n        })();\n    }\n    if (data instanceof ArrayBuffer) {\n        return (function* oneChunk() {\n            yield data;\n        })();\n    }\n    if (isIterator(data)) {\n        return data;\n    }\n    if (isIterable(data)) {\n        return data[Symbol.iterator]();\n    }\n    throw new Error(ERR_DATA);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n/**\n * Returns an iterator that breaks a big string into chunks and yields them one-by-one as ArrayBuffers\n * @param blob string to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeStringIterator(string, options) {\n    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n    let offset = 0;\n    const textEncoder = new TextEncoder();\n    while (offset < string.length) {\n        // Create a chunk of the right size\n        const chunkLength = Math.min(string.length - offset, chunkSize);\n        const chunk = string.slice(offset, offset + chunkLength);\n        offset += chunkLength;\n        // yield an ArrayBuffer chunk\n        yield textEncoder.encode(chunk);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_CHUNK_SIZE = 256 * 1024;\n/**\n * Returns an iterator that breaks a big ArrayBuffer into chunks and yields them one-by-one\n * @param blob ArrayBuffer to iterate over\n * @param options\n * @param options.chunkSize\n */\nexport function* makeArrayBufferIterator(arrayBuffer, options = {}) {\n    const { chunkSize = DEFAULT_CHUNK_SIZE } = options;\n    let byteOffset = 0;\n    while (byteOffset < arrayBuffer.byteLength) {\n        // Create a chunk of the right size\n        const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n        const chunk = new ArrayBuffer(chunkByteLength);\n        // Copy data from the big chunk\n        const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n        const chunkArray = new Uint8Array(chunk);\n        chunkArray.set(sourceArray);\n        // yield the chunk\n        byteOffset += chunkByteLength;\n        yield chunk;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB \u2014 biggest value that keeps UI responsive\n/**\n * Returns an iterator that breaks a big Blob into chunks and yields them one-by-one\n * @param blob Blob or File object\n * @param options\n * @param options.chunkSize\n */\nexport async function* makeBlobIterator(blob, options) {\n    const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;\n    let offset = 0;\n    while (offset < blob.size) {\n        const end = offset + chunkSize;\n        const chunk = await blob.slice(offset, end).arrayBuffer();\n        offset = end;\n        yield chunk;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBrowser, toArrayBuffer } from '@loaders.gl/loader-utils';\n/**\n * Returns an async iterable that reads from a stream (works in both Node.js and browsers)\n * @param stream stream to iterator over\n */\nexport function makeStreamIterator(stream, options) {\n    return isBrowser\n        ? makeBrowserStreamIterator(stream, options)\n        : makeNodeStreamIterator(stream, options);\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @see https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n */\nasync function* makeBrowserStreamIterator(stream, options) {\n    // WhatWG: stream is supposed to have a `getIterator` method\n    // if (typeof stream.getIterator === 'function') {\n    //   return stream.getIterator();\n    // }\n    // if (typeof stream[Symbol.asyncIterator] === 'function') {\n    //   return makeToArrayBufferIterator(stream);\n    // }\n    // In the browser, we first need to get a lock on the stream\n    const reader = stream.getReader();\n    let nextBatchPromise;\n    try {\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const currentBatchPromise = nextBatchPromise || reader.read();\n            // Issue a read for an additional batch, while we await the next batch\n            // Idea is to make fetching happen in parallel with processing / parsing\n            if (options?._streamReadAhead) {\n                nextBatchPromise = reader.read();\n            }\n            // Read from the stream\n            // value is a Uint8Array\n            const { done, value } = await currentBatchPromise;\n            // Exit if we're done\n            if (done) {\n                return;\n            }\n            // Else yield the chunk\n            yield toArrayBuffer(value);\n        }\n    }\n    catch (error) {\n        // TODO - examples makes it look like this should always be called,\n        // but that generates exceptions so only call it if we do not reach the end\n        reader.releaseLock();\n    }\n}\n/**\n * Returns an async iterable that reads from a DOM (browser) stream\n * @param stream stream to iterate from\n * @note Requires Node.js >= 10\n */\nasync function* makeNodeStreamIterator(stream, options) {\n    // Hacky test for node version to ensure we don't call bad polyfills\n    // NODE 10+: stream is an asyncIterator\n    for await (const chunk of stream) {\n        yield toArrayBuffer(chunk); // Coerce each chunk to ArrayBuffer\n    }\n}\n/* TODO - remove NODE < 10\n * @see https://github.com/bustle/streaming-iterables, MIT license\n *\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return;\n  }\n\n  // TODO - check if is this ever used in Node 10+?\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield toArrayBuffer(data);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState?.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n\nasync function onceReadable(stream: Readable): Promise<any> {\n  return new Promise((resolve) => {\n    stream.once('readable', resolve);\n  });\n}\n  */\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { makeStringIterator } from \"./make-string-iterator.js\";\nimport { makeArrayBufferIterator } from \"./make-array-buffer-iterator.js\";\nimport { makeBlobIterator } from \"./make-blob-iterator.js\";\nimport { makeStreamIterator } from \"./make-stream-iterator.js\";\nimport { isBlob, isReadableStream, isResponse } from \"../../javascript-utils/is-type.js\";\n/**\n * Returns an iterator that breaks its input into chunks and yields them one-by-one.\n * @param data\n * @param options\n * @returns\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function makeIterator(data, options) {\n    if (typeof data === 'string') {\n        // Note: Converts string chunks to binary\n        return makeStringIterator(data, options);\n    }\n    if (data instanceof ArrayBuffer) {\n        return makeArrayBufferIterator(data, options);\n    }\n    if (isBlob(data)) {\n        return makeBlobIterator(data, options);\n    }\n    if (isReadableStream(data)) {\n        return makeStreamIterator(data, options);\n    }\n    if (isResponse(data)) {\n        const response = data;\n        return makeStreamIterator(response.body, options);\n    }\n    throw new Error('makeIterator');\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isObject } from \"../../javascript-utils/is-type.js\";\nimport { fetchFile } from \"../fetch/fetch-file.js\";\nimport { getGlobalLoaderOptions } from \"./option-utils.js\";\n/**\n * Gets the current fetch function from options and context\n * @param options\n * @param context\n */\nexport function getFetchFunction(options, context) {\n    const globalOptions = getGlobalLoaderOptions();\n    const loaderOptions = options || globalOptions;\n    // options.fetch can be a function\n    if (typeof loaderOptions.fetch === 'function') {\n        return loaderOptions.fetch;\n    }\n    // options.fetch can be an options object\n    if (isObject(loaderOptions.fetch)) {\n        return (url) => fetchFile(url, loaderOptions.fetch);\n    }\n    // else refer to context (from parent loader) if available\n    if (context?.fetch) {\n        return context?.fetch;\n    }\n    // else return the default fetch function\n    return fetchFile;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getFetchFunction } from \"./get-fetch-function.js\";\nimport { extractQueryString, stripQueryString } from \"../utils/url-utils.js\";\nimport { path } from '@loaders.gl/loader-utils';\n/**\n * \"sub\" loaders invoked by other loaders get a \"context\" injected on `this`\n * The context will inject core methods like `parse` and contain information\n * about loaders and options passed in to the top-level `parse` call.\n *\n * @param context\n * @param options\n * @param previousContext\n */\nexport function getLoaderContext(context, options, parentContext) {\n    // For recursive calls, we already have a context\n    // TODO - add any additional loaders to context?\n    if (parentContext) {\n        return parentContext;\n    }\n    const newContext = {\n        fetch: getFetchFunction(options, context),\n        ...context\n    };\n    // Parse URLs so that subloaders can easily generate correct strings\n    if (newContext.url) {\n        const baseUrl = stripQueryString(newContext.url);\n        newContext.baseUrl = baseUrl;\n        newContext.queryString = extractQueryString(newContext.url);\n        newContext.filename = path.filename(baseUrl);\n        newContext.baseUrl = path.dirname(baseUrl);\n    }\n    // Recursive loading does not use single loader\n    if (!Array.isArray(newContext.loaders)) {\n        newContext.loaders = null;\n    }\n    return newContext;\n}\n// eslint-disable-next-line complexity\nexport function getLoadersFromContext(loaders, context) {\n    // A single loader (non-array) indicates no selection desired. Force select.\n    if (loaders && !Array.isArray(loaders)) {\n        return loaders;\n    }\n    // Create a merged list\n    let candidateLoaders;\n    if (loaders) {\n        candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];\n    }\n    if (context && context.loaders) {\n        const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];\n        candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;\n    }\n    // If no loaders, return null to look in globally registered loaders\n    return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { selectLoaderSync } from \"./select-loader.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getArrayBufferOrStringFromDataSync } from \"../loader-utils/get-data.js\";\nimport { getLoaderContext, getLoadersFromContext } from \"../loader-utils/loader-context.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\n/**\n * Parses `data` synchronously using a specified loader\n */\nexport function parseSync(data, loaders, options, context) {\n    // Signature: parseSync(data, options)\n    // Uses registered loaders\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    options = options || {};\n    // Chooses a loader (and normalizes it)\n    // Also use any loaders in the context, new loaders take priority\n    const typedLoaders = loaders;\n    const candidateLoaders = getLoadersFromContext(typedLoaders, context);\n    const loader = selectLoaderSync(data, candidateLoaders, options);\n    // Note: if nothrow option was set, it is possible that no loader was found, if so just return null\n    if (!loader) {\n        return null;\n    }\n    // Normalize options\n    options = normalizeOptions(options, loader, candidateLoaders);\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    const parse = () => {\n        throw new Error('parseSync called parse (which is async');\n    };\n    context = getLoaderContext({ url, _parseSync: parse, _parse: parse, loaders: loaders }, options, context || null);\n    return parseWithLoaderSync(loader, data, options, context);\n}\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nfunction parseWithLoaderSync(loader, data, options, context) {\n    data = getArrayBufferOrStringFromDataSync(data, loader, options);\n    if (loader.parseTextSync && typeof data === 'string') {\n        return loader.parseTextSync(data, options); // , context, loader);\n    }\n    if (loader.parseSync && data instanceof ArrayBuffer) {\n        return loader.parseSync(data, options, context); // , loader);\n    }\n    // TBD - If synchronous parser not available, return null\n    throw new Error(`${loader.name} loader: 'parseSync' not supported by this loader, use 'parse' instead. ${context.url || ''}`);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isTable, makeBatchFromTable } from '@loaders.gl/schema';\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { normalizeOptions } from \"../loader-utils/option-utils.js\";\nimport { getLoaderContext } from \"../loader-utils/loader-context.js\";\nimport { getAsyncIterableFromData } from \"../loader-utils/get-data.js\";\nimport { getResourceUrl } from \"../utils/resource-utils.js\";\nimport { selectLoader } from \"./select-loader.js\";\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport { parse } from \"./parse.js\";\n/**\n * Parses `data` using a specified loader\n * @param data\n * @param loaders\n * @param options\n * @param context\n */\nexport async function parseInBatches(data, loaders, options, context) {\n    const loaderArray = Array.isArray(loaders) ? loaders : undefined;\n    // Signature: parseInBatches(data, options, url) - Uses registered loaders\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loaders = undefined;\n    }\n    data = await data; // Resolve any promise\n    options = options || {};\n    // Extract a url for auto detection\n    const url = getResourceUrl(data);\n    // Chooses a loader and normalizes it\n    // Note - only uses URL and contentType for streams and iterator inputs\n    const loader = await selectLoader(data, loaders, options);\n    // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n    if (!loader) {\n        return [];\n    }\n    // Normalize options\n    options = normalizeOptions(options, loader, loaderArray, url);\n    context = getLoaderContext({ url, _parseInBatches: parseInBatches, _parse: parse, loaders: loaderArray }, options, context || null);\n    return await parseWithLoaderInBatches(loader, data, options, context);\n}\n/**\n * Loader has been selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n    const outputIterator = await parseToOutputIterator(loader, data, options, context);\n    // Generate metadata batch if requested\n    if (!options.metadata) {\n        return outputIterator;\n    }\n    const metadataBatch = {\n        shape: 'metadata',\n        batchType: 'metadata',\n        metadata: {\n            _loader: loader,\n            _context: context\n        },\n        // Populate with some default fields to avoid crashing\n        data: [],\n        bytesUsed: 0\n    };\n    async function* makeMetadataBatchIterator(iterator) {\n        yield metadataBatch;\n        yield* iterator;\n    }\n    return makeMetadataBatchIterator(outputIterator);\n}\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n    // Get an iterator from the input\n    const inputIterator = await getAsyncIterableFromData(data, options);\n    // Apply any iterator transforms (options.transforms)\n    const transformedIterator = await applyInputTransforms(inputIterator, options?.transforms || []);\n    // If loader supports parseInBatches, we are done\n    if (loader.parseInBatches) {\n        return loader.parseInBatches(transformedIterator, options, context);\n    }\n    return parseChunkInBatches(transformedIterator, loader, options, context);\n}\n// Fallback: load atomically using `parse` concatenating input iterator into single chunk\nasync function* parseChunkInBatches(transformedIterator, loader, options, context) {\n    const arrayBuffer = await concatenateArrayBuffersAsync(transformedIterator);\n    // Call `parse` instead of `loader.parse` to ensure we can call workers etc.\n    const parsedData = await parse(arrayBuffer, loader, \n    // TODO - Hack: supply loaders MIME type to ensure we match it\n    { ...options, mimeType: loader.mimeTypes[0] }, context);\n    // yield a single batch, the output from loader.parse() repackaged as a batch\n    const batch = convertDataToBatch(parsedData, loader);\n    yield batch;\n}\n/**\n * Convert parsed data into a single batch\n * @todo run through batch builder to apply options etc...\n */\nfunction convertDataToBatch(parsedData, loader) {\n    // prettier-ignore\n    const batch = isTable(parsedData)\n        ? makeBatchFromTable(parsedData)\n        : {\n            shape: 'unknown',\n            batchType: 'data',\n            data: parsedData,\n            length: Array.isArray(parsedData) ? parsedData.length : 1\n        };\n    batch.mimeType = loader.mimeTypes[0];\n    return batch;\n}\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nasync function applyInputTransforms(inputIterator, transforms = []) {\n    let iteratorChain = inputIterator;\n    for await (const transformBatches of transforms) {\n        iteratorChain = transformBatches(iteratorChain);\n    }\n    return iteratorChain;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isBlob } from \"../../javascript-utils/is-type.js\";\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parse } from \"./parse.js\";\n// implementation signature\nexport async function load(url, loaders, options, context) {\n    let resolvedLoaders;\n    let resolvedOptions;\n    // Signature: load(url, options)\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        resolvedLoaders = [];\n        resolvedOptions = loaders;\n        context = undefined; // context not supported in short signature\n    }\n    else {\n        resolvedLoaders = loaders;\n        resolvedOptions = options;\n    }\n    // Select fetch function\n    const fetch = getFetchFunction(resolvedOptions);\n    // at this point, `url` could be already loaded binary data\n    let data = url;\n    // url is a string, fetch the url\n    if (typeof url === 'string') {\n        data = await fetch(url);\n        // URL is Blob or File, fetchFile handles it (alt: we could generate ObjectURL here)\n    }\n    if (isBlob(url)) {\n        // The fetch response object will contain blob.name\n        // @ts-expect-error TODO - This may not work for overridden fetch functions\n        data = await fetch(url);\n    }\n    // Data is loaded (at least we have a `Response` object) so time to hand over to `parse`\n    // return await parse(data, loaders as Loader[], options);\n    return Array.isArray(resolvedLoaders)\n        ? await parse(data, resolvedLoaders, resolvedOptions) // loader array overload\n        : await parse(data, resolvedLoaders, resolvedOptions); // single loader overload\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isLoaderObject } from \"../loader-utils/normalize-loader.js\";\nimport { getFetchFunction } from \"../loader-utils/get-fetch-function.js\";\nimport { parseInBatches } from \"./parse-in-batches.js\";\nexport function loadInBatches(files, loaders, options, context) {\n    let loadersArray;\n    // Signature: load(url, options)\n    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n        context = undefined; // context not supported in short signature\n        options = loaders;\n        loadersArray = undefined;\n    }\n    else {\n        loadersArray = loaders;\n    }\n    // Select fetch function\n    const fetch = getFetchFunction(options || {});\n    // Single url/file\n    if (!Array.isArray(files)) {\n        return loadOneFileInBatches(files, loadersArray, options || {}, fetch);\n    }\n    // Multiple URLs / files\n    const promises = files.map((file) => loadOneFileInBatches(file, loadersArray, options || {}, fetch));\n    // No point in waiting here for all responses before starting to stream individual streams?\n    return promises;\n}\nasync function loadOneFileInBatches(file, loaders, options, fetch) {\n    if (typeof file === 'string') {\n        const url = file;\n        const response = await fetch(url);\n        // pick right overload\n        return Array.isArray(loaders)\n            ? await parseInBatches(response, loaders, options)\n            : await parseInBatches(response, loaders, options);\n    }\n    // pick right overload\n    return Array.isArray(loaders)\n        ? await parseInBatches(file, loaders, options)\n        : await parseInBatches(file, loaders, options);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc\n/* global TextEncoder, TextDecoder */\nimport { concatenateArrayBuffers } from '@loaders.gl/loader-utils';\nexport async function encodeTable(data, writer, options) {\n    if (writer.encode) {\n        return await writer.encode(data, options);\n    }\n    if (writer.encodeText) {\n        const text = await writer.encodeText(data, options);\n        return new TextEncoder().encode(text);\n    }\n    if (writer.encodeInBatches) {\n        // Create an iterator representing the data\n        // TODO - Assumes this is a table\n        const batches = encodeTableInBatches(data, writer, options);\n        // Concatenate the output\n        const chunks = [];\n        for await (const batch of batches) {\n            chunks.push(batch);\n        }\n        return concatenateArrayBuffers(...chunks);\n    }\n    throw new Error('Writer could not encode data');\n}\nexport async function encodeTableAsText(data, writer, options) {\n    if (writer.text && writer.encodeText) {\n        return await writer.encodeText(data, options);\n    }\n    if (writer.text) {\n        const arrayBuffer = await encodeTable(data, writer, options);\n        return new TextDecoder().decode(arrayBuffer);\n    }\n    throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\nexport function encodeTableInBatches(data, writer, options) {\n    if (writer.encodeInBatches) {\n        const dataIterator = getIterator(data);\n        // @ts-expect-error\n        return writer.encodeInBatches(dataIterator, options);\n    }\n    // TODO -fall back to atomic encode?\n    throw new Error('Writer could not encode data in batches');\n}\nfunction getIterator(data) {\n    const dataIterator = [{ ...data, start: 0, end: data.length }];\n    return dataIterator;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { canEncodeWithWorker, NodeFile, resolvePath } from '@loaders.gl/loader-utils';\nimport { processOnWorker } from '@loaders.gl/worker-utils';\nimport { isBrowser } from '@loaders.gl/loader-utils';\nimport { fetchFile } from \"../fetch/fetch-file.js\";\nimport { getLoaderOptions } from \"./loader-options.js\";\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(data, writer, options) {\n    const globalOptions = getLoaderOptions();\n    // const globalOptions: WriterOptions = {}; // getWriterOptions();\n    options = { ...globalOptions, ...options };\n    // Handle the special case where we are invoking external command-line tools\n    if (writer.encodeURLtoURL) {\n        return encodeWithCommandLineTool(writer, data, options);\n    }\n    // Worker support\n    if (canEncodeWithWorker(writer, options)) {\n        return await processOnWorker(writer, data, options);\n    }\n    // TODO Merge default writer options with options argument like it is done in load module.\n    return await writer.encode(data, options);\n}\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data, writer, options) {\n    if (writer.encodeSync) {\n        return writer.encodeSync(data, options);\n    }\n    if (writer.encodeTextSync) {\n        return new TextEncoder().encode(writer.encodeTextSync(data, options));\n    }\n    throw new Error(`Writer ${writer.name} could not synchronously encode data`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(data, writer, options) {\n    if (writer.encodeText) {\n        return await writer.encodeText(data, options);\n    }\n    if (writer.encodeTextSync) {\n        return writer.encodeTextSync(data, options);\n    }\n    if (writer.text) {\n        const arrayBuffer = await writer.encode(data, options);\n        return new TextDecoder().decode(arrayBuffer);\n    }\n    throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport function encodeTextSync(data, writer, options) {\n    if (writer.encodeTextSync) {\n        return writer.encodeTextSync(data, options);\n    }\n    if (writer.text && writer.encodeSync) {\n        const arrayBuffer = encodeSync(data, writer, options);\n        return new TextDecoder().decode(arrayBuffer);\n    }\n    throw new Error(`Writer ${writer.name} could not encode data as text`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(data, writer, options) {\n    if (writer.encodeInBatches) {\n        const dataIterator = getIterator(data);\n        // @ts-expect-error\n        return writer.encodeInBatches(dataIterator, options);\n    }\n    // TODO -fall back to atomic encode?\n    throw new Error(`Writer ${writer.name} could not encode in batches`);\n}\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeTextInBatches(data, writer, options) {\n    if (writer.encodeTextInBatches) {\n        const dataIterator = getIterator(data);\n        // @ts-expect-error\n        return writer.encodeTextInBatches(dataIterator, options);\n    }\n    // TODO -fall back to atomic encode?\n    throw new Error(`Writer ${writer.name} could not encode text in batches`);\n}\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n    inputUrl = resolvePath(inputUrl);\n    outputUrl = resolvePath(outputUrl);\n    if (isBrowser || !writer.encodeURLtoURL) {\n        throw new Error();\n    }\n    const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n    return outputFilename;\n}\n/** Helper function to encode via external tool (typically command line execution in Node.js) */\nasync function encodeWithCommandLineTool(writer, data, options) {\n    if (isBrowser) {\n        throw new Error(`Writer ${writer.name} not supported in browser`);\n    }\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    const file = new NodeFile(tmpInputFilename, 'w');\n    await file.write(data);\n    const tmpOutputFilename = getTemporaryFilename('output');\n    const outputFilename = await encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n}\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n    const dataIterator = [{ ...data, start: 0, end: data.length }];\n    return dataIterator;\n}\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename) {\n    return `/tmp/${filename}`;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Builds a DOM stream from an iterator\n * This stream is currently used in browsers only,\n * but note that Web stream support is present in Node from Node 16\n * https://nodejs.org/api/webstreams.html#webstreams_web_streams_api\n */\nexport function makeStream(source, options) {\n    if (globalThis.loaders.makeNodeStream) {\n        return globalThis.loaders.makeNodeStream(source, options);\n    }\n    // TODO - add AsyncGenerator to parameter types?\n    const iterator = source[Symbol.asyncIterator]\n        ? source[Symbol.asyncIterator]()\n        : source[Symbol.iterator]();\n    return new ReadableStream({\n        // Create a byte stream (enables `Response(stream).arrayBuffer()`)\n        // Only supported on Chrome\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/ReadableByteStreamController\n        // @ts-ignore\n        type: 'bytes',\n        async pull(controller) {\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    controller.close();\n                }\n                else {\n                    // TODO - ignores controller.desiredSize\n                    // @ts-expect-error Unclear why value is not correctly typed\n                    controller.enqueue(new Uint8Array(value));\n                }\n            }\n            catch (error) {\n                controller.error(error);\n            }\n        },\n        async cancel() {\n            await iterator?.return?.();\n        }\n    }, \n    // options: QueingStrategy<Uint8Array>\n    {\n        // This is bytes, not chunks\n        highWaterMark: 2 ** 24,\n        ...options\n    });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.2.0-beta.2\" !== 'undefined' ? \"4.2.0-beta.2\" : 'latest';\n/**\n * Loads any data and returns null (or optionally passes through data unparsed)\n */\nexport const NullWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Null loader',\n    id: 'null',\n    module: 'core',\n    version: VERSION,\n    worker: true,\n    mimeTypes: ['application/x.empty'],\n    extensions: ['null'],\n    tests: [() => false],\n    options: {\n        null: {}\n    }\n};\n/**\n * Loads any data and returns null (or optionally passes through data unparsed)\n */\nexport const NullLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Null loader',\n    id: 'null',\n    module: 'core',\n    version: VERSION,\n    mimeTypes: ['application/x.empty'],\n    extensions: ['null'],\n    parse: async (arrayBuffer, options, context) => parseSync(arrayBuffer, options || {}, context),\n    parseSync,\n    parseInBatches: async function* generator(asyncIterator, options, context) {\n        for await (const batch of asyncIterator) {\n            yield parseSync(batch, options, context);\n        }\n    },\n    tests: [() => false],\n    options: {\n        null: {}\n    }\n};\n/**\n * Returns arguments passed to the parse API in a format that can be transferred to a\n * web worker. The `context` parameter is stripped using JSON.stringify & parse.\n */\nfunction parseSync(arrayBuffer, options, context) {\n    return null;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport async function fetchProgress(response, onProgress, // TODO better callback types\nonDone = () => { }, onError = () => { }) {\n    response = await response;\n    if (!response.ok) {\n        // ERROR checking needs to be done separately\n        return response;\n    }\n    const body = response.body;\n    if (!body) {\n        // 'ReadableStream not yet supported in this browser.\n        return response;\n    }\n    const contentLength = response.headers.get('content-length') || 0;\n    const totalBytes = contentLength ? parseInt(contentLength) : 0;\n    if (!(totalBytes > 0)) {\n        return response;\n    }\n    // Currently override only implemented in browser\n    if (typeof ReadableStream === 'undefined' || !body.getReader) {\n        return response;\n    }\n    // Create a new stream that invisbly wraps original stream\n    const progressStream = new ReadableStream({\n        async start(controller) {\n            const reader = body.getReader();\n            await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n        }\n    });\n    return new Response(progressStream);\n}\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    try {\n        const { done, value } = await reader.read();\n        if (done) {\n            onDone();\n            controller.close();\n            return;\n        }\n        loadedBytes += value.byteLength;\n        const percent = Math.round((loadedBytes / totalBytes) * 100);\n        onProgress(percent, { loadedBytes, totalBytes });\n        controller.enqueue(value);\n        await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n    }\n    catch (error) {\n        controller.error(error);\n        onError(error);\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BlobFile } from '@loaders.gl/loader-utils';\n/**\n * FileSystem adapter for a browser FileList.\n * Holds a list of browser 'File' objects.\n */\nexport class BrowserFileSystem {\n    _fetch;\n    files = {};\n    lowerCaseFiles = {};\n    usedFiles = {};\n    /**\n     * A FileSystem API wrapper around a list of browser 'File' objects\n     * @param files\n     * @param options\n     */\n    constructor(files, options) {\n        this._fetch = options?.fetch || fetch;\n        for (let i = 0; i < files.length; ++i) {\n            const file = files[i];\n            this.files[file.name] = file;\n            this.lowerCaseFiles[file.name.toLowerCase()] = file;\n            this.usedFiles[file.name] = false;\n        }\n        this.fetch = this.fetch.bind(this);\n    }\n    // implements IFileSystem\n    /**\n     * Implementation of fetch against this file system\n     * Delegates to global fetch for http{s}:// or data://\n     */\n    async fetch(path, options) {\n        // Fallback to handle https:/http:/data: etc fetches\n        if (path.includes('://')) {\n            return this._fetch(path, options);\n        }\n        // Local fetches are served from the list of files\n        const file = this.files[path];\n        if (!file) {\n            return new Response(path, { status: 400, statusText: 'NOT FOUND' });\n        }\n        const headers = new Headers(options?.headers);\n        const range = headers.get('Range');\n        const bytes = range && /bytes=($1)-($2)/.exec(range);\n        if (bytes) {\n            const start = parseInt(bytes[1]);\n            const end = parseInt(bytes[2]);\n            // The trick when reading File objects is to read successive \"slices\" of the File\n            // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n            // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n            const data = await file.slice(start, end).arrayBuffer();\n            const response = new Response(data);\n            Object.defineProperty(response, 'url', { value: path });\n            return response;\n        }\n        // return makeResponse()\n        const response = new Response(file);\n        Object.defineProperty(response, 'url', { value: path });\n        return response;\n    }\n    /**\n     * List filenames in this filesystem\n     * @param dirname\n     * @returns\n     */\n    async readdir(dirname) {\n        const files = [];\n        for (const path in this.files) {\n            files.push(path);\n        }\n        // TODO filter by dirname\n        return files;\n    }\n    /**\n     * Return information (size) about files in this file system\n     */\n    async stat(path, options) {\n        const file = this.files[path];\n        if (!file) {\n            throw new Error(path);\n        }\n        return { size: file.size };\n    }\n    /**\n     * Just removes the file from the list\n     */\n    async unlink(path) {\n        delete this.files[path];\n        delete this.lowerCaseFiles[path];\n        this.usedFiles[path] = true;\n    }\n    // implements IRandomAccessFileSystem\n    // RANDOM ACCESS\n    async openReadableFile(pathname, flags) {\n        return new BlobFile(this.files[pathname]);\n    }\n    // PRIVATE\n    // Supports case independent paths, and file usage tracking\n    _getFile(path, used) {\n        // Prefer case match, but fall back to case independent.\n        const file = this.files[path] || this.lowerCaseFiles[path];\n        if (file && used) {\n            this.usedFiles[path] = true;\n        }\n        return file;\n    }\n}\n/*\n   * Read a range into a buffer\n   * @todo - handle position memory\n   * @param buffer is the buffer that the data (read from the fd) will be written to.\n   * @param offset is the offset in the buffer to start writing at.\n   * @param length is an integer specifying the number of bytes to read.\n   * @param position is an argument specifying where to begin reading from in the file. If position is null, data will be read from the current file position, and the file position will be updated. If position is an integer, the file position will remain unchanged.\n   *\n  async read(\n    fd: any,\n    buffer: ArrayBuffer,\n    offset: number = 0,\n    length: number = buffer.byteLength,\n    position: number | null = null\n  ): Promise<{bytesRead: number; buffer: ArrayBuffer}> {\n    const file = fd as File;\n    const startPosition = 0; // position\n    const arrayBuffer = await file.slice(startPosition, startPosition + length).arrayBuffer();\n    // copy into target buffer\n    return {bytesRead: length, buffer: arrayBuffer};\n  }\n\n  async close(fd: number): Promise<void> {\n    // NO OP\n  }\n\n  // fstat(fd: number): Promise<object>; // Stat\n  */\n"],
  "mappings": "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",
  "names": ["import_loader_utils", "import_loader_utils", "import_loader_utils", "import_loader_utils", "import_log", "import_loader_utils", "import_loader_utils", "import_loader_utils", "DEFAULT_CHUNK_SIZE", "DEFAULT_CHUNK_SIZE", "import_loader_utils", "import_loader_utils", "parse", "import_loader_utils", "fetch", "fetch", "import_loader_utils", "import_loader_utils", "import_worker_utils", "getIterator", "getIterator", "import_loader_utils", "parseSync", "import_loader_utils", "import_loader_utils", "path", "response", "import_loader_utils"]
}
