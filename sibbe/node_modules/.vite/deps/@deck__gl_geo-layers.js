import {
  COORDINATE_SYSTEM,
  CompositeLayer,
  CubeGeometry,
  Geometry,
  GlobeViewport,
  GroupNode,
  ImageLoader,
  ImageSource,
  Layer,
  LayerExtension,
  LayersPass,
  Matrix3,
  Matrix4,
  Model,
  ModelNode,
  OrthographicViewport,
  PickLayersPass,
  Quaternion,
  RequestScheduler,
  ScenegraphNode,
  Stats,
  Tesselator,
  Texture,
  UNIT,
  Vector2,
  Vector3,
  WebMercatorViewport,
  assert as assert2,
  assert2 as assert3,
  assert3 as assert4,
  clamp,
  concatenateTypedArrays,
  config,
  copyToArray,
  createIterable,
  deduceMeshField,
  deepEqual,
  degrees,
  dist_default,
  equals,
  fetchFile,
  flatten,
  fp64,
  fp64LowPart,
  getBinaryImageMetadata,
  getImageData,
  getJSModuleOrNull,
  getMeshBoundingBox,
  gouraudLighting,
  isImageFormatSupported,
  lerp,
  lngLatToWorld,
  load,
  loadLibrary,
  log,
  log_default,
  mat4_exports,
  math_utils_exports,
  memoize,
  mergeLoaderOptions,
  mergeShaders,
  padToNBytes,
  parseFromContext,
  parseJSON,
  path_exports,
  pbr,
  phongLighting,
  picking_default,
  project32_default,
  project_default,
  registerJSModules,
  sliceArrayBuffer,
  toDegrees,
  toRadians,
  vec3_exports,
  worldToLngLat
} from "./chunk-KLZ6SAXF.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-USJHI7ER.js";

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i3 = dim; i3 < outerLen; i3 += dim) {
          x2 = data[i3];
          y2 = data[i3 + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList2(data, start, end, dim, clockwise) {
      var i3, last;
      if (clockwise === signedArea2(data, start, end, dim) > 0) {
        for (i3 = start; i3 < end; i3 += dim)
          last = insertNode2(i3, data[i3], data[i3 + 1], last);
      } else {
        for (i3 = end - dim; i3 >= start; i3 -= dim)
          last = insertNode2(i3, data[i3], data[i3 + 1], last);
      }
      if (last && equals4(last, last.next)) {
        removeNode2(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints2(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p2 = start, again;
      do {
        again = false;
        if (!p2.steiner && (equals4(p2, p2.next) || area2(p2.prev, p2, p2.next) === 0)) {
          removeNode2(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next)
            break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve2(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode2(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
            earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut2(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar2(ear) {
      var a3 = ear.prev, b2 = ear, c2 = ear.next;
      if (area2(a3, b2, c2) >= 0)
        return false;
      var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c2.next;
      while (p2 !== a3) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed2(ear, minX, minY, invSize) {
      var a3 = ear.prev, b2 = ear, c2 = ear.next;
      if (area2(a3, b2, c2) >= 0)
        return false;
      var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area2(p2.prev, p2, p2.next) >= 0)
          return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area2(n2.prev, n2, n2.next) >= 0)
          return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections2(start, triangles, dim) {
      var p2 = start;
      do {
        var a3 = p2.prev, b2 = p2.next.next;
        if (!equals4(a3, b2) && intersects2(a3, p2, p2.next, b2) && locallyInside2(a3, b2) && locallyInside2(b2, a3)) {
          triangles.push(a3.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode2(p2);
          removeNode2(p2.next);
          p2 = start = b2;
        }
        p2 = p2.next;
      } while (p2 !== start);
      return filterPoints2(p2);
    }
    function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
      var a3 = start;
      do {
        var b2 = a3.next.next;
        while (b2 !== a3.prev) {
          if (a3.i !== b2.i && isValidDiagonal2(a3, b2)) {
            var c2 = splitPolygon2(a3, b2);
            a3 = filterPoints2(a3, a3.next);
            c2 = filterPoints2(c2, c2.next);
            earcutLinked2(a3, triangles, dim, minX, minY, invSize, 0);
            earcutLinked2(c2, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a3 = a3.next;
      } while (a3 !== start);
    }
    function eliminateHoles2(data, holeIndices, outerNode, dim) {
      var queue = [], i3, len, start, end, list;
      for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
        start = holeIndices[i3] * dim;
        end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList2(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost2(list));
      }
      queue.sort(compareX2);
      for (i3 = 0; i3 < queue.length; i3++) {
        outerNode = eliminateHole2(queue[i3], outerNode);
      }
      return outerNode;
    }
    function compareX2(a3, b2) {
      return a3.x - b2.x;
    }
    function eliminateHole2(hole, outerNode) {
      var bridge = findHoleBridge2(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon2(bridge, hole);
      filterPoints2(bridgeReverse, bridgeReverse.next);
      return filterPoints2(bridge, bridge.next);
    }
    function findHoleBridge2(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x2 <= hx && x2 > qx) {
            qx = x2;
            m = p2.x < p2.next.x ? p2 : p2.next;
            if (x2 === hx)
              return m;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p2 = m;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside2(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector2(m, p2)))) {
            m = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m;
    }
    function sectorContainsSector2(m, p2) {
      return area2(m.prev, m, p2.prev) < 0 && area2(p2.next, m, m.next) < 0;
    }
    function indexCurve2(start, minX, minY, invSize) {
      var p2 = start;
      do {
        if (p2.z === 0)
          p2.z = zOrder2(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked2(p2);
    }
    function sortLinked2(list) {
      var i3, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q = p2;
          pSize = 0;
          for (i3 = 0; i3 < inSize; i3++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
              e2 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e2 = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e2;
            else
              list = e2;
            e2.prevZ = tail;
            tail = e2;
          }
          p2 = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder2(x2, y2, minX, minY, invSize) {
      x2 = (x2 - minX) * invSize | 0;
      y2 = (y2 - minY) * invSize | 0;
      x2 = (x2 | x2 << 8) & 16711935;
      x2 = (x2 | x2 << 4) & 252645135;
      x2 = (x2 | x2 << 2) & 858993459;
      x2 = (x2 | x2 << 1) & 1431655765;
      y2 = (y2 | y2 << 8) & 16711935;
      y2 = (y2 | y2 << 4) & 252645135;
      y2 = (y2 | y2 << 2) & 858993459;
      y2 = (y2 | y2 << 1) & 1431655765;
      return x2 | y2 << 1;
    }
    function getLeftmost2(start) {
      var p2 = start, leftmost = start;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
          leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start);
      return leftmost;
    }
    function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal2(a3, b2) {
      return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon2(a3, b2) && // dones't intersect other edges
      (locallyInside2(a3, b2) && locallyInside2(b2, a3) && middleInside2(a3, b2) && // locally visible
      (area2(a3.prev, a3, b2.prev) || area2(a3, b2.prev, b2)) || // does not create opposite-facing sectors
      equals4(a3, b2) && area2(a3.prev, a3, a3.next) > 0 && area2(b2.prev, b2, b2.next) > 0);
    }
    function area2(p2, q, r2) {
      return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
    }
    function equals4(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects2(p1, q1, p2, q2) {
      var o1 = sign2(area2(p1, q1, p2));
      var o2 = sign2(area2(p1, q1, q2));
      var o3 = sign2(area2(p2, q2, p1));
      var o4 = sign2(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment2(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment2(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment2(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment2(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment2(p2, q, r2) {
      return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
    }
    function sign2(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon2(a3, b2) {
      var p2 = a3;
      do {
        if (p2.i !== a3.i && p2.next.i !== a3.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects2(p2, p2.next, a3, b2))
          return true;
        p2 = p2.next;
      } while (p2 !== a3);
      return false;
    }
    function locallyInside2(a3, b2) {
      return area2(a3.prev, a3, a3.next) < 0 ? area2(a3, b2, a3.next) >= 0 && area2(a3, a3.prev, b2) >= 0 : area2(a3, b2, a3.prev) < 0 || area2(a3, a3.next, b2) < 0;
    }
    function middleInside2(a3, b2) {
      var p2 = a3, inside = false, px = (a3.x + b2.x) / 2, py = (a3.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a3);
      return inside;
    }
    function splitPolygon2(a3, b2) {
      var a22 = new Node(a3.i, a3.x, a3.y), b22 = new Node(b2.i, b2.x, b2.y), an = a3.next, bp = b2.prev;
      a3.next = b2;
      b2.prev = a3;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode2(i3, x2, y2, last) {
      var p2 = new Node(i3, x2, y2);
      if (!last) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
      }
      return p2;
    }
    function removeNode2(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ)
        p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ)
        p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i3, x2, y2) {
      this.i = i3;
      this.x = x2;
      this.y = y2;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i3 = 0, len = holeIndices.length; i3 < len; i3++) {
          var start = holeIndices[i3] * dim;
          var end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea2(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i3 = 0; i3 < triangles.length; i3 += 3) {
        var a3 = triangles[i3] * dim;
        var b2 = triangles[i3 + 1] * dim;
        var c2 = triangles[i3 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a3] - data[c2]) * (data[b2 + 1] - data[a3 + 1]) - (data[a3] - data[b2]) * (data[c2 + 1] - data[a3 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea2(data, start, end, dim) {
      var sum = 0;
      for (var i3 = start, j = end - dim; i3 < end; i3 += dim) {
        sum += (data[j] - data[i3]) * (data[i3 + 1] + data[j + 1]);
        j = i3;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i3 = 0; i3 < data.length; i3++) {
        for (var j = 0; j < data[i3].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i3][j][d]);
        }
        if (i3 > 0) {
          holeIndex += data[i3 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a3, arrayMode) {
      if (a3) {
        const keys = Object.keys(a3);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          if (arrayMode === "strict") {
            target[keys[i3]] = [a3[keys[i3]]];
          } else {
            target[keys[i3]] = a3[keys[i3]];
          }
        }
      }
    };
    exports.getValue = function(v) {
      if (exports.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions2 = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions2, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<" && xmlData[i3 + 1] === "?") {
          i3 += 2;
          i3 = readPI(xmlData, i3);
          if (i3.err)
            return i3;
        } else if (xmlData[i3] === "<") {
          let tagStartPos = i3;
          i3++;
          if (xmlData[i3] === "!") {
            i3 = readCommentAndCDATA(xmlData, i3);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i3] === "/") {
              closingTag = true;
              i3++;
            }
            let tagName = "";
            for (; i3 < xmlData.length && xmlData[i3] !== ">" && xmlData[i3] !== " " && xmlData[i3] !== "	" && xmlData[i3] !== "\n" && xmlData[i3] !== "\r"; i3++) {
              tagName += xmlData[i3];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i3--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i3));
            }
            const result = readAttributeStr(xmlData, i3);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i3));
            }
            let attrStr = result.value;
            i3 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i3 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i3));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i3 - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i3));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i3++; i3 < xmlData.length; i3++) {
              if (xmlData[i3] === "<") {
                if (xmlData[i3 + 1] === "!") {
                  i3++;
                  i3 = readCommentAndCDATA(xmlData, i3);
                  continue;
                } else if (xmlData[i3 + 1] === "?") {
                  i3 = readPI(xmlData, ++i3);
                  if (i3.err)
                    return i3;
                } else {
                  break;
                }
              } else if (xmlData[i3] === "&") {
                const afterAmp = validateAmpersand(xmlData, i3);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i3));
                i3 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i3])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i3));
                }
              }
            }
            if (xmlData[i3] === "<") {
              i3--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i3])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i3] + "' is not expected.", getLineNumberForPosition(xmlData, i3));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i3) {
      const start = i3;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] == "?" || xmlData[i3] == " ") {
          const tagname = xmlData.substr(start, i3 - start);
          if (i3 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i3));
          } else if (xmlData[i3] == "?" && xmlData[i3 + 1] == ">") {
            i3++;
            break;
          } else {
            continue;
          }
        }
      }
      return i3;
    }
    function readCommentAndCDATA(xmlData, i3) {
      if (xmlData.length > i3 + 5 && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === "-") {
        for (i3 += 3; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "-" && xmlData[i3 + 1] === "-" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      } else if (xmlData.length > i3 + 8 && xmlData[i3 + 1] === "D" && xmlData[i3 + 2] === "O" && xmlData[i3 + 3] === "C" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "Y" && xmlData[i3 + 6] === "P" && xmlData[i3 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i3] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i3 + 9 && xmlData[i3 + 1] === "[" && xmlData[i3 + 2] === "C" && xmlData[i3 + 3] === "D" && xmlData[i3 + 4] === "A" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "A" && xmlData[i3 + 7] === "[") {
        for (i3 += 8; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "]" && xmlData[i3 + 1] === "]" && xmlData[i3 + 2] === ">") {
            i3 += 2;
            break;
          }
        }
      }
      return i3;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i3) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === doubleQuote || xmlData[i3] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i3];
          } else if (startChar !== xmlData[i3]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i3] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i3];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i3,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i3 = 0; i3 < matches.length; i3++) {
        if (matches[i3][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' has no space in starting.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] !== void 0 && matches[i3][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i3][2] + "' is without value.", getPositionFromMatch(matches[i3]));
        } else if (matches[i3][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i3][2] + "' is not allowed.", getPositionFromMatch(matches[i3]));
        }
        const attrName = matches[i3][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i3]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i3]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i3) {
      let re = /\d/;
      if (xmlData[i3] === "x") {
        i3++;
        re = /[\da-fA-F]/;
      }
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === ";")
          return i3;
        if (!xmlData[i3].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i3) {
      i3++;
      if (xmlData[i3] === ";")
        return -1;
      if (xmlData[i3] === "#") {
        i3++;
        return validateNumberAmpersand(xmlData, i3);
      }
      let count = 0;
      for (; i3 < xmlData.length; i3++, count++) {
        if (xmlData[i3].match(/\w/) && count < 20)
          continue;
        if (xmlData[i3] === ";")
          break;
        return -1;
      }
      return i3;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions2 = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions2, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions2;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    var util = require_util();
    function readDocType(xmlData, i3) {
      const entities = {};
      if (xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "C" && xmlData[i3 + 5] === "T" && xmlData[i3 + 6] === "Y" && xmlData[i3 + 7] === "P" && xmlData[i3 + 8] === "E") {
        i3 = i3 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i3 < xmlData.length; i3++) {
          if (xmlData[i3] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i3)) {
              i3 += 7;
              [entityName, val, i3] = readEntityExp(xmlData, i3 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i3))
              i3 += 8;
            else if (hasBody && isAttlist(xmlData, i3))
              i3 += 8;
            else if (hasBody && isNotation(xmlData, i3))
              i3 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i3] === ">") {
            if (comment) {
              if (xmlData[i3 - 1] === "-" && xmlData[i3 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i3] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i3];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i3 };
    }
    function readEntityExp(xmlData, i3) {
      let entityName2 = "";
      for (; i3 < xmlData.length && (xmlData[i3] !== "'" && xmlData[i3] !== '"'); i3++) {
        entityName2 += xmlData[i3];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i3++];
      let val2 = "";
      for (; i3 < xmlData.length && xmlData[i3] !== startChar; i3++) {
        val2 += xmlData[i3];
      }
      return [entityName2, val2, i3];
    }
    function isComment(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "-" && xmlData[i3 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "N" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "I" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "E" && xmlData[i3 + 3] === "L" && xmlData[i3 + 4] === "E" && xmlData[i3 + 5] === "M" && xmlData[i3 + 6] === "E" && xmlData[i3 + 7] === "N" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "A" && xmlData[i3 + 3] === "T" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "L" && xmlData[i3 + 6] === "I" && xmlData[i3 + 7] === "S" && xmlData[i3 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i3) {
      if (xmlData[i3 + 1] === "!" && xmlData[i3 + 2] === "N" && xmlData[i3 + 3] === "O" && xmlData[i3 + 4] === "T" && xmlData[i3 + 5] === "A" && xmlData[i3 + 6] === "T" && xmlData[i3 + 7] === "I" && xmlData[i3 + 8] === "O" && xmlData[i3 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name12) {
      if (util.isName(name12))
        return name12;
      else
        throw new Error(`Invalid entity name ${name12}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber2(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign2 = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign2 && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign2 + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign2 + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber2;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber2 = require_strnum();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "¢" },
          "pound": { regex: /&(pound|#163);/g, val: "£" },
          "yen": { regex: /&(yen|#165);/g, val: "¥" },
          "euro": { regex: /&(euro|#8364);/g, val: "€" },
          "copyright": { regex: /&(copy|#169);/g, val: "©" },
          "reg": { regex: /&(reg|#174);/g, val: "®" },
          "inr": { regex: /&(inr|#8377);/g, val: "₹" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_2, str) => String.fromCharCode(Number.parseInt(str, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i3 = 0; i3 < entKeys.length; i3++) {
        const ent = entKeys[i3];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i3 = 0; i3 < len; i3++) {
          const attrName = this.resolveNameSpace(matches[i3][1]);
          let oldVal = matches[i3][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i3 = 0; i3 < xmlData.length; i3++) {
        const ch = xmlData[i3];
        if (ch === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            let tagData = readTagExp(xmlData, i3, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i3 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i3 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i3 = endIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i3);
            this.docTypeEntities = result.entities;
            i3 = result.i;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i3 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val2 == void 0)
              val2 = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val2);
            }
            i3 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i3, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i3 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i3 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${rawTagName}`);
                i3 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i3 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i3];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i3, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i3; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary)
            attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str, i3, errMsg) {
      const closingIndex = xmlData.indexOf(str, i3);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i3, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i3 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i3) {
      const startIndex = i3;
      let openTagCount = 1;
      for (; i3 < xmlData.length; i3++) {
        if (xmlData[i3] === "<") {
          if (xmlData[i3 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i3, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i3 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i3),
                  i: closeIndex
                };
              }
            }
            i3 = closeIndex;
          } else if (xmlData[i3 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i3 + 1, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i3 + 3, "StopNode is not closed.");
            i3 = closeIndex;
          } else if (xmlData.substr(i3 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i3, "StopNode is not closed.") - 2;
            i3 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i3, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i3 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber2(val2, options);
      } else {
        if (util.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress2(node, options);
    }
    function compress2(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress2(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i3 = 0; i3 < len; i3++) {
          const atrrName = keys[i3];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i3 = 0; i3 < arr.length; i3++) {
        const tagObj = arr[i3];
        const tagName = propName(tagObj);
        if (tagName === void 0)
          continue;
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i3 = 0; i3 < keys.length; i3++) {
        const key = keys[i3];
        if (!obj.hasOwnProperty(key))
          continue;
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr))
            continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i3 = 0; i3 < options.entities.length; i3++) {
          const entity = options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions2 = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a3) {
        return a3;
      },
      attributeValueProcessor: function(attrName, a3) {
        return a3;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions2, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key))
          continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val2 += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val2 += "";
          } else if (key[0] === "?") {
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i3 = 0; i3 < this.options.entities.length; i3++) {
          const entity = this.options.entities[i3];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name12) {
      if (name12.startsWith(this.options.attributeNamePrefix) && name12 !== this.options.textNodeName) {
        return name12.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var XMLParser = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/@deck.gl/geo-layers/node_modules/long/dist/long.js
var require_long = __commonJS({
  "node_modules/@deck.gl/geo-layers/node_modules/long/dist/long.js"(exports, module) {
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
    })(exports, function() {
      "use strict";
      function Long4(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long4.prototype.__isLong__;
      Object.defineProperty(Long4.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      function isLong2(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long4.isLong = isLong2;
      var INT_CACHE2 = {};
      var UINT_CACHE2 = {};
      function fromInt2(value, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value >>>= 0;
          if (cache2 = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE2[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache2)
            UINT_CACHE2[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache2 = -128 <= value && value < 128) {
            cachedObj = INT_CACHE2[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits2(value, value < 0 ? -1 : 0, false);
          if (cache2)
            INT_CACHE2[value] = obj;
          return obj;
        }
      }
      Long4.fromInt = fromInt2;
      function fromNumber2(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
          return unsigned ? UZERO2 : ZERO2;
        if (unsigned) {
          if (value < 0)
            return UZERO2;
          if (value >= TWO_PWR_64_DBL2)
            return MAX_UNSIGNED_VALUE2;
        } else {
          if (value <= -TWO_PWR_63_DBL2)
            return MIN_VALUE2;
          if (value + 1 >= TWO_PWR_63_DBL2)
            return MAX_VALUE2;
        }
        if (value < 0)
          return fromNumber2(-value, unsigned).neg();
        return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
      }
      Long4.fromNumber = fromNumber2;
      function fromBits2(lowBits, highBits, unsigned) {
        return new Long4(lowBits, highBits, unsigned);
      }
      Long4.fromBits = fromBits2;
      var pow_dbl2 = Math.pow;
      function fromString2(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO2;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p2;
        if ((p2 = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p2 === 0) {
          return fromString2(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber2(pow_dbl2(radix, 8));
        var result = ZERO2;
        for (var i3 = 0; i3 < str.length; i3 += 8) {
          var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
          if (size < 8) {
            var power = fromNumber2(pow_dbl2(radix, size));
            result = result.mul(power).add(fromNumber2(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber2(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long4.fromString = fromString2;
      function fromValue2(val2) {
        if (val2 instanceof Long4)
          return val2;
        if (typeof val2 === "number")
          return fromNumber2(val2);
        if (typeof val2 === "string")
          return fromString2(val2);
        return fromBits2(val2.low, val2.high, val2.unsigned);
      }
      Long4.fromValue = fromValue2;
      var TWO_PWR_16_DBL2 = 1 << 16;
      var TWO_PWR_24_DBL2 = 1 << 24;
      var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
      var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
      var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
      var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
      var ZERO2 = fromInt2(0);
      Long4.ZERO = ZERO2;
      var UZERO2 = fromInt2(0, true);
      Long4.UZERO = UZERO2;
      var ONE2 = fromInt2(1);
      Long4.ONE = ONE2;
      var UONE2 = fromInt2(1, true);
      Long4.UONE = UONE2;
      var NEG_ONE2 = fromInt2(-1);
      Long4.NEG_ONE = NEG_ONE2;
      var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
      Long4.MAX_VALUE = MAX_VALUE2;
      var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
      Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
      var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
      Long4.MIN_VALUE = MIN_VALUE2;
      var LongPrototype2 = Long4.prototype;
      LongPrototype2.toInt = function toInt2() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype2.toNumber = function toNumber2() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
      };
      LongPrototype2.toString = function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE2)) {
            var radixLong = fromNumber2(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype2.getHighBits = function getHighBits2() {
        return this.high;
      };
      LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
        return this.high >>> 0;
      };
      LongPrototype2.getLowBits = function getLowBits2() {
        return this.low;
      };
      LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
        return this.low >>> 0;
      };
      LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
        if (this.isNegative())
          return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
        var val2 = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val2 & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype2.isZero = function isZero2() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype2.isNegative = function isNegative2() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype2.isPositive = function isPositive2() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype2.isOdd = function isOdd2() {
        return (this.low & 1) === 1;
      };
      LongPrototype2.isEven = function isEven2() {
        return (this.low & 1) === 0;
      };
      LongPrototype2.equals = function equals4(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype2.eq = LongPrototype2.equals;
      LongPrototype2.notEquals = function notEquals2(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype2.neq = LongPrototype2.notEquals;
      LongPrototype2.lessThan = function lessThan2(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype2.lt = LongPrototype2.lessThan;
      LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
      LongPrototype2.greaterThan = function greaterThan2(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype2.gt = LongPrototype2.greaterThan;
      LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
      LongPrototype2.compare = function compare2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype2.comp = LongPrototype2.compare;
      LongPrototype2.negate = function negate2() {
        if (!this.unsigned && this.eq(MIN_VALUE2))
          return MIN_VALUE2;
        return this.not().add(ONE2);
      };
      LongPrototype2.neg = LongPrototype2.negate;
      LongPrototype2.add = function add2(addend) {
        if (!isLong2(addend))
          addend = fromValue2(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype2.subtract = function subtract2(subtrahend) {
        if (!isLong2(subtrahend))
          subtrahend = fromValue2(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype2.sub = LongPrototype2.subtract;
      LongPrototype2.multiply = function multiply2(multiplier) {
        if (this.isZero())
          return ZERO2;
        if (!isLong2(multiplier))
          multiplier = fromValue2(multiplier);
        if (multiplier.isZero())
          return ZERO2;
        if (this.eq(MIN_VALUE2))
          return multiplier.isOdd() ? MIN_VALUE2 : ZERO2;
        if (multiplier.eq(MIN_VALUE2))
          return this.isOdd() ? MIN_VALUE2 : ZERO2;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
          return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype2.mul = LongPrototype2.multiply;
      LongPrototype2.divide = function divide2(divisor) {
        if (!isLong2(divisor))
          divisor = fromValue2(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? UZERO2 : ZERO2;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE2)) {
            if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
              return MIN_VALUE2;
            else if (divisor.eq(MIN_VALUE2))
              return ONE2;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO2)) {
                return divisor.isNegative() ? ONE2 : NEG_ONE2;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE2))
            return this.unsigned ? UZERO2 : ZERO2;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO2;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO2;
          if (divisor.gt(this.shru(1)))
            return UONE2;
          res = UZERO2;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl2(2, log2 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber2(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE2;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype2.div = LongPrototype2.divide;
      LongPrototype2.modulo = function modulo2(divisor) {
        if (!isLong2(divisor))
          divisor = fromValue2(divisor);
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype2.mod = LongPrototype2.modulo;
      LongPrototype2.not = function not2() {
        return fromBits2(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype2.and = function and2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype2.or = function or2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype2.xor = function xor2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits2(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype2.shl = LongPrototype2.shiftLeft;
      LongPrototype2.shiftRight = function shiftRight2(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype2.shr = LongPrototype2.shiftRight;
      LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits2(high, 0, this.unsigned);
          else
            return fromBits2(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
      LongPrototype2.toSigned = function toSigned2() {
        if (!this.unsigned)
          return this;
        return fromBits2(this.low, this.high, false);
      };
      LongPrototype2.toUnsigned = function toUnsigned2() {
        if (this.unsigned)
          return this;
        return fromBits2(this.low, this.high, true);
      };
      LongPrototype2.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype2.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24 & 255,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24 & 255
        ];
      };
      LongPrototype2.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24 & 255,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24 & 255,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      return Long4;
    });
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e2) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e2();
      else if ("function" == typeof define && define.amd)
        define([], e2);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e2();
      }
    }(function() {
      return function s2(a3, o2, h) {
        function u(r2, e3) {
          if (!o2[r2]) {
            if (!a3[r2]) {
              var t2 = "function" == typeof __require && __require;
              if (!e3 && t2)
                return t2(r2, true);
              if (l2)
                return l2(r2, true);
              var n2 = new Error("Cannot find module '" + r2 + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i3 = o2[r2] = { exports: {} };
            a3[r2][0].call(i3.exports, function(e4) {
              var t3 = a3[r2][1][e4];
              return u(t3 || e4);
            }, i3, i3.exports, s2, a3, o2, h);
          }
          return o2[r2].exports;
        }
        for (var l2 = "function" == typeof __require && __require, e2 = 0; e2 < h.length; e2++)
          u(h[e2]);
        return u;
      }({ 1: [function(e2, t2, r2) {
        "use strict";
        var d = e2("./utils"), c2 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e3) {
          for (var t3, r3, n2, i3, s2, a3, o2, h = [], u = 0, l2 = e3.length, f2 = l2, c3 = "string" !== d.getTypeOf(e3); u < e3.length; )
            f2 = l2 - u, n2 = c3 ? (t3 = e3[u++], r3 = u < l2 ? e3[u++] : 0, u < l2 ? e3[u++] : 0) : (t3 = e3.charCodeAt(u++), r3 = u < l2 ? e3.charCodeAt(u++) : 0, u < l2 ? e3.charCodeAt(u++) : 0), i3 = t3 >> 2, s2 = (3 & t3) << 4 | r3 >> 4, a3 = 1 < f2 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f2 ? 63 & n2 : 64, h.push(p2.charAt(i3) + p2.charAt(s2) + p2.charAt(a3) + p2.charAt(o2));
          return h.join("");
        }, r2.decode = function(e3) {
          var t3, r3, n2, i3, s2, a3, o2 = 0, h = 0, u = "data:";
          if (e3.substr(0, u.length) === u)
            throw new Error("Invalid base64 input, it looks like a data url.");
          var l2, f2 = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e3.charAt(e3.length - 1) === p2.charAt(64) && f2--, e3.charAt(e3.length - 2) === p2.charAt(64) && f2--, f2 % 1 != 0)
            throw new Error("Invalid base64 input, bad content length.");
          for (l2 = c2.uint8array ? new Uint8Array(0 | f2) : new Array(0 | f2); o2 < e3.length; )
            t3 = p2.indexOf(e3.charAt(o2++)) << 2 | (i3 = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i3) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a3 = p2.indexOf(e3.charAt(o2++))), l2[h++] = t3, 64 !== s2 && (l2[h++] = r3), 64 !== a3 && (l2[h++] = n2);
          return l2;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./external"), i3 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a3 = e2("./stream/DataLengthProbe");
        function o2(e3, t3, r3, n3, i4) {
          this.compressedSize = e3, this.uncompressedSize = t3, this.crc32 = r3, this.compression = n3, this.compressedContent = i4;
        }
        o2.prototype = { getContentWorker: function() {
          var e3 = new i3(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a3("data_length")), t3 = this;
          return e3.on("end", function() {
            if (this.streamInfo.data_length !== t3.uncompressedSize)
              throw new Error("Bug : uncompressed data size mismatch");
          }), e3;
        }, getCompressedWorker: function() {
          return new i3(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o2.createWorkerFrom = function(e3, t3, r3) {
          return e3.pipe(new s2()).pipe(new a3("uncompressedSize")).pipe(t3.compressWorker(r3)).pipe(new a3("compressedSize")).withStreamInfo("compression", t3);
        }, t2.exports = o2;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r2.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./utils");
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n3 = 0; n3 < 8; n3++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3) {
          return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? function(e4, t4, r3, n3) {
            var i3 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a3 = n3; a3 < s2; a3++)
              e4 = e4 >>> 8 ^ i3[255 & (e4 ^ t4[a3])];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : function(e4, t4, r3, n3) {
            var i3 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a3 = n3; a3 < s2; a3++)
              e4 = e4 >>> 8 ^ i3[255 & (e4 ^ t4.charCodeAt(a3))];
            return -1 ^ e4;
          }(0 | t3, e3, e3.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t2, r2) {
        "use strict";
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e2, t2, r2) {
        "use strict";
        var n2 = null;
        n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t2.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i3 = e2("pako"), s2 = e2("./utils"), a3 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
        function h(e3, t3) {
          a3.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t3, this.meta = {};
        }
        r2.magic = "\b\0", s2.inherits(h, a3), h.prototype.processChunk = function(e3) {
          this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
        }, h.prototype.flush = function() {
          a3.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a3.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i3[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t3 = this;
          this._pako.onData = function(e3) {
            t3.push({ data: e3, meta: t3.meta });
          };
        }, r2.compressWorker = function(e3) {
          return new h("Deflate", e3);
        }, r2.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t2, r2) {
        "use strict";
        function A(e3, t3) {
          var r3, n3 = "";
          for (r3 = 0; r3 < t3; r3++)
            n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
          return n3;
        }
        function n2(e3, t3, r3, n3, i4, s3) {
          var a3, o2, h = e3.file, u = e3.compression, l2 = s3 !== O.utf8encode, f2 = I.transformTo("string", s3(h.name)), c2 = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p2 = I.transformTo("string", s3(d)), m = I.transformTo("string", O.utf8encode(d)), _2 = c2.length !== h.name.length, g = m.length !== d.length, b2 = "", v = "", y2 = "", w = h.dir, k = h.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t3 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
          var S = 0;
          t3 && (S |= 8), l2 || !_2 && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i4 ? (C = 798, z |= function(e4, t4) {
            var r4 = e4;
            return e4 || (r4 = t4 ? 16893 : 33204), (65535 & r4) << 16;
          }(h.unixPermissions, w)) : (C = 20, z |= function(e4) {
            return 63 & (e4 || 0);
          }(h.dosPermissions)), a3 = k.getUTCHours(), a3 <<= 6, a3 |= k.getUTCMinutes(), a3 <<= 5, a3 |= k.getUTCSeconds() / 2, o2 = k.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k.getUTCMonth() + 1, o2 <<= 5, o2 |= k.getUTCDate(), _2 && (v = A(1, 1) + A(B(f2), 4) + c2, b2 += "up" + A(v.length, 2) + v), g && (y2 = A(1, 1) + A(B(p2), 4) + m, b2 += "uc" + A(y2.length, 2) + y2);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a3, 2), E += A(o2, 2), E += A(x2.crc32, 4), E += A(x2.compressedSize, 4), E += A(x2.uncompressedSize, 4), E += A(f2.length, 2), E += A(b2.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f2 + b2, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p2.length, 2) + "\0\0\0\0" + A(z, 4) + A(n3, 4) + f2 + b2 + p2 };
        }
        var I = e2("../utils"), i3 = e2("../stream/GenericWorker"), O = e2("../utf8"), B = e2("../crc32"), R = e2("../signature");
        function s2(e3, t3, r3, n3) {
          i3.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t3, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s2, i3), s2.prototype.push = function(e3) {
          var t3 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i3.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t3 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
        }, s2.prototype.openedSource = function(e3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
          var t3 = this.streamFiles && !e3.file.dir;
          if (t3) {
            var r3 = n2(e3, t3, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r3.fileRecord, meta: { percent: 0 } });
          } else
            this.accumulate = true;
        }, s2.prototype.closedSource = function(e3) {
          this.accumulate = false;
          var t3 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t3, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r3.dirRecord), t3)
            this.push({ data: function(e4) {
              return R.DATA_DESCRIPTOR + A(e4.crc32, 4) + A(e4.compressedSize, 4) + A(e4.uncompressedSize, 4);
            }(e3), meta: { percent: 100 } });
          else
            for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
              this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s2.prototype.flush = function() {
          for (var e3 = this.bytesWritten, t3 = 0; t3 < this.dirRecords.length; t3++)
            this.push({ data: this.dirRecords[t3], meta: { percent: 100 } });
          var r3 = this.bytesWritten - e3, n3 = function(e4, t4, r4, n4, i4) {
            var s3 = I.transformTo("string", i4(n4));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e4, 2) + A(e4, 2) + A(t4, 4) + A(r4, 4) + A(s3.length, 2) + s3;
          }(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s2.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s2.prototype.registerPrevious = function(e3) {
          this._sources.push(e3);
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.closedSource(t3.previous.streamInfo), t3._sources.length ? t3.prepareNextSource() : t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, s2.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s2.prototype.error = function(e3) {
          var t3 = this._sources;
          if (!i3.prototype.error.call(this, e3))
            return false;
          for (var r3 = 0; r3 < t3.length; r3++)
            try {
              t3[r3].error(e3);
            } catch (e4) {
            }
          return true;
        }, s2.prototype.lock = function() {
          i3.prototype.lock.call(this);
          for (var e3 = this._sources, t3 = 0; t3 < e3.length; t3++)
            e3[t3].lock();
        }, t2.exports = s2;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t2, r2) {
        "use strict";
        var u = e2("../compressions"), n2 = e2("./ZipFileWorker");
        r2.generateWorker = function(e3, a3, t3) {
          var o2 = new n2(a3.streamFiles, t3, a3.platform, a3.encodeFileName), h = 0;
          try {
            e3.forEach(function(e4, t4) {
              h++;
              var r3 = function(e5, t5) {
                var r4 = e5 || t5, n4 = u[r4];
                if (!n4)
                  throw new Error(r4 + " is not a valid compression method !");
                return n4;
              }(t4.options.compression, a3.compression), n3 = t4.options.compressionOptions || a3.compressionOptions || {}, i3 = t4.dir, s2 = t4.date;
              t4._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i3, date: s2, comment: t4.comment || "", unixPermissions: t4.unixPermissions, dosPermissions: t4.dosPermissions }).pipe(o2);
            }), o2.entriesCount = h;
          } catch (e4) {
            o2.error(e4);
          }
          return o2;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t2, r2) {
        "use strict";
        function n2() {
          if (!(this instanceof n2))
            return new n2();
          if (arguments.length)
            throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e3 = new n2();
            for (var t3 in this)
              "function" != typeof this[t3] && (e3[t3] = this[t3]);
            return e3;
          };
        }
        (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t3) {
          return new n2().loadAsync(e3, t3);
        }, n2.external = e2("./external"), t2.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t2, r2) {
        "use strict";
        var u = e2("./utils"), i3 = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a3 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
        function f2(n3) {
          return new i3.Promise(function(e3, t3) {
            var r3 = n3.decompressed.getContentWorker().pipe(new a3());
            r3.on("error", function(e4) {
              t3(e4);
            }).on("end", function() {
              r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t3(new Error("Corrupted zip : CRC32 mismatch")) : e3();
            }).resume();
          });
        }
        t2.exports = function(e3, o2) {
          var h = this;
          return o2 = u.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l2.isNode && l2.isStream(e3) ? i3.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
            var t3 = new s2(o2);
            return t3.load(e4), t3;
          }).then(function(e4) {
            var t3 = [i3.Promise.resolve(e4)], r3 = e4.files;
            if (o2.checkCRC32)
              for (var n3 = 0; n3 < r3.length; n3++)
                t3.push(f2(r3[n3]));
            return i3.Promise.all(t3);
          }).then(function(e4) {
            for (var t3 = e4.shift(), r3 = t3.files, n3 = 0; n3 < r3.length; n3++) {
              var i4 = r3[n3], s3 = i4.fileNameStr, a4 = u.resolve(i4.fileNameStr);
              h.file(a4, i4.decompressed, { binary: true, optimizedBinaryString: true, date: i4.date, dir: i4.dir, comment: i4.fileCommentStr.length ? i4.fileCommentStr : null, unixPermissions: i4.unixPermissions, dosPermissions: i4.dosPermissions, createFolders: o2.createFolders }), i4.dir || (h.file(a4).unsafeOriginalName = s3);
            }
            return t3.zipComment.length && (h.comment = t3.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i3 = e2("../stream/GenericWorker");
        function s2(e3, t3) {
          i3.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t3);
        }
        n2.inherits(s2, i3), s2.prototype._bindStream = function(e3) {
          var t3 = this;
          (this._stream = e3).pause(), e3.on("data", function(e4) {
            t3.push({ data: e4, meta: { percent: 0 } });
          }).on("error", function(e4) {
            t3.isPaused ? this.generatedError = e4 : t3.error(e4);
          }).on("end", function() {
            t3.isPaused ? t3._upstreamEnded = true : t3.end();
          });
        }, s2.prototype.pause = function() {
          return !!i3.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s2.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t2.exports = s2;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t2, r2) {
        "use strict";
        var i3 = e2("readable-stream").Readable;
        function n2(e3, t3, r3) {
          i3.call(this, t3), this._helper = e3;
          var n3 = this;
          e3.on("data", function(e4, t4) {
            n3.push(e4) || n3._helper.pause(), r3 && r3(t4);
          }).on("error", function(e4) {
            n3.emit("error", e4);
          }).on("end", function() {
            n3.push(null);
          });
        }
        e2("../utils").inherits(n2, i3), n2.prototype._read = function() {
          this._helper.resume();
        }, t2.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t3) {
          if (Buffer.from && Buffer.from !== Uint8Array.from)
            return Buffer.from(e3, t3);
          if ("number" == typeof e3)
            throw new Error('The "data" argument must not be a number');
          return new Buffer(e3, t3);
        }, allocBuffer: function(e3) {
          if (Buffer.alloc)
            return Buffer.alloc(e3);
          var t3 = new Buffer(e3);
          return t3.fill(0), t3;
        }, isBuffer: function(e3) {
          return Buffer.isBuffer(e3);
        }, isStream: function(e3) {
          return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
        } };
      }, {}], 15: [function(e2, t2, r2) {
        "use strict";
        function s2(e3, t3, r3) {
          var n3, i4 = u.getTypeOf(t3), s3 = u.extend(r3 || {}, f2);
          s3.date = s3.date || /* @__PURE__ */ new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g(e3)), s3.createFolders && (n3 = _2(e3)) && b2.call(this, n3, true);
          var a4 = "string" === i4 && false === s3.binary && false === s3.base64;
          r3 && void 0 !== r3.binary || (s3.binary = !a4), (t3 instanceof c2 && 0 === t3.uncompressedSize || s3.dir || !t3 || 0 === t3.length) && (s3.base64 = false, s3.binary = true, t3 = "", s3.compression = "STORE", i4 = "string");
          var o3 = null;
          o3 = t3 instanceof c2 || t3 instanceof l2 ? t3 : p2.isNode && p2.isStream(t3) ? new m(e3, t3) : u.prepareContent(e3, t3, s3.binary, s3.optimizedBinaryString, s3.base64);
          var h2 = new d(e3, o3, s3);
          this.files[e3] = h2;
        }
        var i3 = e2("./utf8"), u = e2("./utils"), l2 = e2("./stream/GenericWorker"), a3 = e2("./stream/StreamHelper"), f2 = e2("./defaults"), c2 = e2("./compressedObject"), d = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m = e2("./nodejs/NodejsStreamInputAdapter"), _2 = function(e3) {
          "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
          var t3 = e3.lastIndexOf("/");
          return 0 < t3 ? e3.substring(0, t3) : "";
        }, g = function(e3) {
          return "/" !== e3.slice(-1) && (e3 += "/"), e3;
        }, b2 = function(e3, t3) {
          return t3 = void 0 !== t3 ? t3 : f2.createFolders, e3 = g(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t3 }), this.files[e3];
        };
        function h(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e3) {
          var t3, r3, n3;
          for (t3 in this.files)
            n3 = this.files[t3], (r3 = t3.slice(this.root.length, t3.length)) && t3.slice(0, this.root.length) === this.root && e3(r3, n3);
        }, filter: function(r3) {
          var n3 = [];
          return this.forEach(function(e3, t3) {
            r3(e3, t3) && n3.push(t3);
          }), n3;
        }, file: function(e3, t3, r3) {
          if (1 !== arguments.length)
            return e3 = this.root + e3, s2.call(this, e3, t3, r3), this;
          if (h(e3)) {
            var n3 = e3;
            return this.filter(function(e4, t4) {
              return !t4.dir && n3.test(e4);
            });
          }
          var i4 = this.files[this.root + e3];
          return i4 && !i4.dir ? i4 : null;
        }, folder: function(r3) {
          if (!r3)
            return this;
          if (h(r3))
            return this.filter(function(e4, t4) {
              return t4.dir && r3.test(e4);
            });
          var e3 = this.root + r3, t3 = b2.call(this, e3), n3 = this.clone();
          return n3.root = t3.name, n3;
        }, remove: function(r3) {
          r3 = this.root + r3;
          var e3 = this.files[r3];
          if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir)
            delete this.files[r3];
          else
            for (var t3 = this.filter(function(e4, t4) {
              return t4.name.slice(0, r3.length) === r3;
            }), n3 = 0; n3 < t3.length; n3++)
              delete this.files[t3[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e3) {
          var t3, r3 = {};
          try {
            if ((r3 = u.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i3.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type)
              throw new Error("No output type specified.");
            u.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
            var n3 = r3.comment || this.comment || "";
            t3 = o2.generateWorker(this, r3, n3);
          } catch (e4) {
            (t3 = new l2("error")).error(e4);
          }
          return new a3(t3, r3.type || "string", r3.mimeType);
        }, generateAsync: function(e3, t3) {
          return this.generateInternalStream(e3).accumulate(t3);
        }, generateNodeStream: function(e3, t3) {
          return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t3);
        } };
        t2.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t2, r2) {
        "use strict";
        t2.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i3(e3) {
          n2.call(this, e3);
          for (var t3 = 0; t3 < this.data.length; t3++)
            e3[t3] = 255 & e3[t3];
        }
        e2("../utils").inherits(i3, n2), i3.prototype.byteAt = function(e3) {
          return this.data[this.zero + e3];
        }, i3.prototype.lastIndexOfSignature = function(e3) {
          for (var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i4 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2)
            if (this.data[s2] === t3 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i4)
              return s2 - this.zero;
          return -1;
        }, i3.prototype.readAndCheckSignature = function(e3) {
          var t3 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i4 = e3.charCodeAt(3), s2 = this.readData(4);
          return t3 === s2[0] && r3 === s2[1] && n3 === s2[2] && i4 === s2[3];
        }, i3.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return [];
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils");
        function i3(e3) {
          this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
        }
        i3.prototype = { checkOffset: function(e3) {
          this.checkIndex(this.index + e3);
        }, checkIndex: function(e3) {
          if (this.length < this.zero + e3 || e3 < 0)
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
        }, setIndex: function(e3) {
          this.checkIndex(e3), this.index = e3;
        }, skip: function(e3) {
          this.setIndex(this.index + e3);
        }, byteAt: function() {
        }, readInt: function(e3) {
          var t3, r3 = 0;
          for (this.checkOffset(e3), t3 = this.index + e3 - 1; t3 >= this.index; t3--)
            r3 = (r3 << 8) + this.byteAt(t3);
          return this.index += e3, r3;
        }, readString: function(e3) {
          return n2.transformTo("string", this.readData(e3));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e3 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
        } }, t2.exports = i3;
      }, { "../utils": 32 }], 19: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./Uint8ArrayReader");
        function i3(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i3, n2), i3.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./DataReader");
        function i3(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i3, n2), i3.prototype.byteAt = function(e3) {
          return this.data.charCodeAt(this.zero + e3);
        }, i3.prototype.lastIndexOfSignature = function(e3) {
          return this.data.lastIndexOf(e3) - this.zero;
        }, i3.prototype.readAndCheckSignature = function(e3) {
          return e3 === this.readData(4);
        }, i3.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t3 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./ArrayReader");
        function i3(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i3, n2), i3.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3)
            return new Uint8Array(0);
          var t3 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t3;
        }, t2.exports = i3;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i3 = e2("../support"), s2 = e2("./ArrayReader"), a3 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h = e2("./Uint8ArrayReader");
        t2.exports = function(e3) {
          var t3 = n2.getTypeOf(e3);
          return n2.checkSupport(t3), "string" !== t3 || i3.uint8array ? "nodebuffer" === t3 ? new o2(e3) : i3.uint8array ? new h(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a3(e3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t2, r2) {
        "use strict";
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i3 = e2("../utils");
        function s2(e3) {
          n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
        }
        i3.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.push({ data: i3.transformTo(this.destType, e3.data), meta: e3.meta });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./GenericWorker"), i3 = e2("../crc32");
        function s2() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.streamInfo.crc32 = i3(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
        }, t2.exports = s2;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i3 = e2("./GenericWorker");
        function s2(e3) {
          i3.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
        }
        n2.inherits(s2, i3), s2.prototype.processChunk = function(e3) {
          if (e3) {
            var t3 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t3 + e3.data.length;
          }
          i3.prototype.processChunk.call(this, e3);
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("../utils"), i3 = e2("./GenericWorker");
        function s2(e3) {
          i3.call(this, "DataWorker");
          var t3 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
            t3.dataIsReady = true, t3.data = e4, t3.max = e4 && e4.length || 0, t3.type = n2.getTypeOf(e4), t3.isPaused || t3._tickAndRepeat();
          }, function(e4) {
            t3.error(e4);
          });
        }
        n2.inherits(s2, i3), s2.prototype.cleanUp = function() {
          i3.prototype.cleanUp.call(this), this.data = null;
        }, s2.prototype.resume = function() {
          return !!i3.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s2.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s2.prototype._tick = function() {
          if (this.isPaused || this.isFinished)
            return false;
          var e3 = null, t3 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max)
            return this.end();
          switch (this.type) {
            case "string":
              e3 = this.data.substring(this.index, t3);
              break;
            case "uint8array":
              e3 = this.data.subarray(this.index, t3);
              break;
            case "array":
            case "nodebuffer":
              e3 = this.data.slice(this.index, t3);
          }
          return this.index = t3, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t2.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t2, r2) {
        "use strict";
        function n2(e3) {
          this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n2.prototype = { push: function(e3) {
          this.emit("data", e3);
        }, end: function() {
          if (this.isFinished)
            return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e3) {
            this.emit("error", e3);
          }
          return true;
        }, error: function(e3) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
        }, on: function(e3, t3) {
          return this._listeners[e3].push(t3), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e3, t3) {
          if (this._listeners[e3])
            for (var r3 = 0; r3 < this._listeners[e3].length; r3++)
              this._listeners[e3][r3].call(this, t3);
        }, pipe: function(e3) {
          return e3.registerPrevious(this);
        }, registerPrevious: function(e3) {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
          var t3 = this;
          return e3.on("data", function(e4) {
            t3.processChunk(e4);
          }), e3.on("end", function() {
            t3.end();
          }), e3.on("error", function(e4) {
            t3.error(e4);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished)
            return false;
          var e3 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
        }, flush: function() {
        }, processChunk: function(e3) {
          this.push(e3);
        }, withStreamInfo: function(e3, t3) {
          return this.extraStreamInfo[e3] = t3, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e3 in this.extraStreamInfo)
            Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
        }, lock: function() {
          if (this.isLocked)
            throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e3 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e3 : e3;
        } }, t2.exports = n2;
      }, {}], 29: [function(e2, t2, r2) {
        "use strict";
        var h = e2("../utils"), i3 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u = e2("../base64"), n2 = e2("../support"), a3 = e2("../external"), o2 = null;
        if (n2.nodestream)
          try {
            o2 = e2("../nodejs/NodejsStreamOutputAdapter");
          } catch (e3) {
          }
        function l2(e3, o3) {
          return new a3.Promise(function(t3, r3) {
            var n3 = [], i4 = e3._internalType, s3 = e3._outputType, a4 = e3._mimeType;
            e3.on("data", function(e4, t4) {
              n3.push(e4), o3 && o3(t4);
            }).on("error", function(e4) {
              n3 = [], r3(e4);
            }).on("end", function() {
              try {
                var e4 = function(e5, t4, r4) {
                  switch (e5) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t4), r4);
                    case "base64":
                      return u.encode(t4);
                    default:
                      return h.transformTo(e5, t4);
                  }
                }(s3, function(e5, t4) {
                  var r4, n4 = 0, i5 = null, s4 = 0;
                  for (r4 = 0; r4 < t4.length; r4++)
                    s4 += t4[r4].length;
                  switch (e5) {
                    case "string":
                      return t4.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t4);
                    case "uint8array":
                      for (i5 = new Uint8Array(s4), r4 = 0; r4 < t4.length; r4++)
                        i5.set(t4[r4], n4), n4 += t4[r4].length;
                      return i5;
                    case "nodebuffer":
                      return Buffer.concat(t4);
                    default:
                      throw new Error("concat : unsupported type '" + e5 + "'");
                  }
                }(i4, n3), a4);
                t3(e4);
              } catch (e5) {
                r3(e5);
              }
              n3 = [];
            }).resume();
          });
        }
        function f2(e3, t3, r3) {
          var n3 = t3;
          switch (t3) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t3, this._mimeType = r3, h.checkSupport(n3), this._worker = e3.pipe(new i3(n3)), e3.lock();
          } catch (e4) {
            this._worker = new s2("error"), this._worker.error(e4);
          }
        }
        f2.prototype = { accumulate: function(e3) {
          return l2(this, e3);
        }, on: function(e3, t3) {
          var r3 = this;
          return "data" === e3 ? this._worker.on(e3, function(e4) {
            t3.call(r3, e4.data, e4.meta);
          }) : this._worker.on(e3, function() {
            h.delay(t3, arguments, r3);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e3) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
            throw new Error(this._outputType + " is not supported by this method");
          return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
        } }, t2.exports = f2;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t2, r2) {
        "use strict";
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
          r2.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
          } catch (e3) {
            try {
              var i3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i3.append(n2), r2.blob = 0 === i3.getBlob("application/zip").size;
            } catch (e4) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e2("readable-stream").Readable;
        } catch (e3) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t2, s2) {
        "use strict";
        for (var o2 = e2("./utils"), h = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u = new Array(256), i3 = 0; i3 < 256; i3++)
          u[i3] = 252 <= i3 ? 6 : 248 <= i3 ? 5 : 240 <= i3 ? 4 : 224 <= i3 ? 3 : 192 <= i3 ? 2 : 1;
        u[254] = u[254] = 1;
        function a3() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l2() {
          n2.call(this, "utf-8 encode");
        }
        s2.utf8encode = function(e3) {
          return h.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : function(e4) {
            var t3, r3, n3, i4, s3, a4 = e4.length, o3 = 0;
            for (i4 = 0; i4 < a4; i4++)
              55296 == (64512 & (r3 = e4.charCodeAt(i4))) && i4 + 1 < a4 && 56320 == (64512 & (n3 = e4.charCodeAt(i4 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i4++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
            for (t3 = h.uint8array ? new Uint8Array(o3) : new Array(o3), i4 = s3 = 0; s3 < o3; i4++)
              55296 == (64512 & (r3 = e4.charCodeAt(i4))) && i4 + 1 < a4 && 56320 == (64512 & (n3 = e4.charCodeAt(i4 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i4++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
            return t3;
          }(e3);
        }, s2.utf8decode = function(e3) {
          return h.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
            var t3, r3, n3, i4, s3 = e4.length, a4 = new Array(2 * s3);
            for (t3 = r3 = 0; t3 < s3; )
              if ((n3 = e4[t3++]) < 128)
                a4[r3++] = n3;
              else if (4 < (i4 = u[n3]))
                a4[r3++] = 65533, t3 += i4 - 1;
              else {
                for (n3 &= 2 === i4 ? 31 : 3 === i4 ? 15 : 7; 1 < i4 && t3 < s3; )
                  n3 = n3 << 6 | 63 & e4[t3++], i4--;
                1 < i4 ? a4[r3++] = 65533 : n3 < 65536 ? a4[r3++] = n3 : (n3 -= 65536, a4[r3++] = 55296 | n3 >> 10 & 1023, a4[r3++] = 56320 | 1023 & n3);
              }
            return a4.length !== r3 && (a4.subarray ? a4 = a4.subarray(0, r3) : a4.length = r3), o2.applyFromCharCode(a4);
          }(e3 = o2.transformTo(h.uint8array ? "uint8array" : "array", e3));
        }, o2.inherits(a3, n2), a3.prototype.processChunk = function(e3) {
          var t3 = o2.transformTo(h.uint8array ? "uint8array" : "array", e3.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r3 = t3;
              (t3 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t3.set(r3, this.leftOver.length);
            } else
              t3 = this.leftOver.concat(t3);
            this.leftOver = null;
          }
          var n3 = function(e4, t4) {
            var r4;
            for ((t4 = t4 || e4.length) > e4.length && (t4 = e4.length), r4 = t4 - 1; 0 <= r4 && 128 == (192 & e4[r4]); )
              r4--;
            return r4 < 0 ? t4 : 0 === r4 ? t4 : r4 + u[e4[r4]] > t4 ? r4 : t4;
          }(t3), i4 = t3;
          n3 !== t3.length && (h.uint8array ? (i4 = t3.subarray(0, n3), this.leftOver = t3.subarray(n3, t3.length)) : (i4 = t3.slice(0, n3), this.leftOver = t3.slice(n3, t3.length))), this.push({ data: s2.utf8decode(i4), meta: e3.meta });
        }, a3.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s2.Utf8DecodeWorker = a3, o2.inherits(l2, n2), l2.prototype.processChunk = function(e3) {
          this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
        }, s2.Utf8EncodeWorker = l2;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t2, a3) {
        "use strict";
        var o2 = e2("./support"), h = e2("./base64"), r2 = e2("./nodejsUtils"), u = e2("./external");
        function n2(e3) {
          return e3;
        }
        function l2(e3, t3) {
          for (var r3 = 0; r3 < e3.length; ++r3)
            t3[r3] = 255 & e3.charCodeAt(r3);
          return t3;
        }
        e2("setimmediate"), a3.newBlob = function(t3, r3) {
          a3.checkSupport("blob");
          try {
            return new Blob([t3], { type: r3 });
          } catch (e3) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t3), n3.getBlob(r3);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i3 = { stringifyByChunk: function(e3, t3, r3) {
          var n3 = [], i4 = 0, s3 = e3.length;
          if (s3 <= r3)
            return String.fromCharCode.apply(null, e3);
          for (; i4 < s3; )
            "array" === t3 || "nodebuffer" === t3 ? n3.push(String.fromCharCode.apply(null, e3.slice(i4, Math.min(i4 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i4, Math.min(i4 + r3, s3)))), i4 += r3;
          return n3.join("");
        }, stringifyByChar: function(e3) {
          for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
            t3 += String.fromCharCode(e3[r3]);
          return t3;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e3) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e3) {
            return false;
          }
        }() } };
        function s2(e3) {
          var t3 = 65536, r3 = a3.getTypeOf(e3), n3 = true;
          if ("uint8array" === r3 ? n3 = i3.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i3.applyCanBeUsed.nodebuffer), n3)
            for (; 1 < t3; )
              try {
                return i3.stringifyByChunk(e3, r3, t3);
              } catch (e4) {
                t3 = Math.floor(t3 / 2);
              }
          return i3.stringifyByChar(e3);
        }
        function f2(e3, t3) {
          for (var r3 = 0; r3 < e3.length; r3++)
            t3[r3] = e3[r3];
          return t3;
        }
        a3.applyFromCharCode = s2;
        var c2 = {};
        c2.string = { string: n2, array: function(e3) {
          return l2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.string.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return l2(e3, new Uint8Array(e3.length));
        }, nodebuffer: function(e3) {
          return l2(e3, r2.allocBuffer(e3.length));
        } }, c2.array = { string: s2, array: n2, arraybuffer: function(e3) {
          return new Uint8Array(e3).buffer;
        }, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.arraybuffer = { string: function(e3) {
          return s2(new Uint8Array(e3));
        }, array: function(e3) {
          return f2(new Uint8Array(e3), new Array(e3.byteLength));
        }, arraybuffer: n2, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(new Uint8Array(e3));
        } }, c2.uint8array = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return e3.buffer;
        }, uint8array: n2, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.nodebuffer = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.nodebuffer.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return f2(e3, new Uint8Array(e3.length));
        }, nodebuffer: n2 }, a3.transformTo = function(e3, t3) {
          if (t3 = t3 || "", !e3)
            return t3;
          a3.checkSupport(e3);
          var r3 = a3.getTypeOf(t3);
          return c2[r3][e3](t3);
        }, a3.resolve = function(e3) {
          for (var t3 = e3.split("/"), r3 = [], n3 = 0; n3 < t3.length; n3++) {
            var i4 = t3[n3];
            "." === i4 || "" === i4 && 0 !== n3 && n3 !== t3.length - 1 || (".." === i4 ? r3.pop() : r3.push(i4));
          }
          return r3.join("/");
        }, a3.getTypeOf = function(e3) {
          return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a3.checkSupport = function(e3) {
          if (!o2[e3.toLowerCase()])
            throw new Error(e3 + " is not supported by this platform");
        }, a3.MAX_VALUE_16BITS = 65535, a3.MAX_VALUE_32BITS = -1, a3.pretty = function(e3) {
          var t3, r3, n3 = "";
          for (r3 = 0; r3 < (e3 || "").length; r3++)
            n3 += "\\x" + ((t3 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t3.toString(16).toUpperCase();
          return n3;
        }, a3.delay = function(e3, t3, r3) {
          setImmediate(function() {
            e3.apply(r3 || null, t3 || []);
          });
        }, a3.inherits = function(e3, t3) {
          function r3() {
          }
          r3.prototype = t3.prototype, e3.prototype = new r3();
        }, a3.extend = function() {
          var e3, t3, r3 = {};
          for (e3 = 0; e3 < arguments.length; e3++)
            for (t3 in arguments[e3])
              Object.prototype.hasOwnProperty.call(arguments[e3], t3) && void 0 === r3[t3] && (r3[t3] = arguments[e3][t3]);
          return r3;
        }, a3.prepareContent = function(r3, e3, n3, i4, s3) {
          return u.Promise.resolve(e3).then(function(n4) {
            return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u.Promise(function(t3, r4) {
              var e4 = new FileReader();
              e4.onload = function(e5) {
                t3(e5.target.result);
              }, e4.onerror = function(e5) {
                r4(e5.target.error);
              }, e4.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e4) {
            var t3 = a3.getTypeOf(e4);
            return t3 ? ("arraybuffer" === t3 ? e4 = a3.transformTo("uint8array", e4) : "string" === t3 && (s3 ? e4 = h.decode(e4) : n3 && true !== i4 && (e4 = function(e5) {
              return l2(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
            }(e4))), e4) : u.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), i3 = e2("./utils"), s2 = e2("./signature"), a3 = e2("./zipEntry"), o2 = e2("./support");
        function h(e3) {
          this.files = [], this.loadOptions = e3;
        }
        h.prototype = { checkSignature: function(e3) {
          if (!this.reader.readAndCheckSignature(e3)) {
            this.reader.index -= 4;
            var t3 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i3.pretty(t3) + ", expected " + i3.pretty(e3) + ")");
          }
        }, isSignature: function(e3, t3) {
          var r3 = this.reader.index;
          this.reader.setIndex(e3);
          var n3 = this.reader.readString(4) === t3;
          return this.reader.setIndex(r3), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e3 = this.reader.readData(this.zipCommentLength), t3 = o2.uint8array ? "uint8array" : "array", r3 = i3.transformTo(t3, e3);
          this.zipComment = this.loadOptions.decodeFileName(r3);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e3, t3, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; )
            e3 = this.reader.readInt(2), t3 = this.reader.readInt(4), r3 = this.reader.readData(t3), this.zip64ExtensibleData[e3] = { id: e3, length: t3, value: r3 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
            throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e3, t3;
          for (e3 = 0; e3 < this.files.length; e3++)
            t3 = this.files[e3], this.reader.setIndex(t3.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t3.readLocalPart(this.reader), t3.handleUTF8(), t3.processAttributes();
        }, readCentralDir: function() {
          var e3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); )
            (e3 = new a3({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
          if (e3 < 0)
            throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e3);
          var t3 = e3;
          if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i3.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i3.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i3.MAX_VALUE_16BITS || this.centralDirRecords === i3.MAX_VALUE_16BITS || this.centralDirSize === i3.MAX_VALUE_32BITS || this.centralDirOffset === i3.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r3 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
          var n3 = t3 - r3;
          if (0 < n3)
            this.isSignature(t3, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0)
            throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e3) {
          this.reader = n2(e3);
        }, load: function(e3) {
          this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t2.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t2, r2) {
        "use strict";
        var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i3 = e2("./compressedObject"), a3 = e2("./crc32"), o2 = e2("./utf8"), h = e2("./compressions"), u = e2("./support");
        function l2(e3, t3) {
          this.options = e3, this.loadOptions = t3;
        }
        l2.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e3) {
          var t3, r3;
          if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize)
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t3 = function(e4) {
            for (var t4 in h)
              if (Object.prototype.hasOwnProperty.call(h, t4) && h[t4].magic === e4)
                return h[t4];
            return null;
          }(this.compressionMethod)))
            throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
          this.decompressed = new i3(this.compressedSize, this.uncompressedSize, this.crc32, t3, e3.readData(this.compressedSize));
        }, readCentralPart: function(e3) {
          this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
          var t3 = e3.readInt(2);
          if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted())
            throw new Error("Encrypted zip are not supported");
          e3.skip(t3), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e3 = n2(this.extraFields[1].value);
            this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
          }
        }, readExtraFields: function(e3) {
          var t3, r3, n3, i4 = e3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i4; )
            t3 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t3] = { id: t3, length: r3, value: n3 };
          e3.setIndex(i4);
        }, handleUTF8: function() {
          var e3 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8())
            this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
          else {
            var t3 = this.findExtraFieldUnicodePath();
            if (null !== t3)
              this.fileNameStr = t3;
            else {
              var r3 = s2.transformTo(e3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r3);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (null !== n3)
              this.fileCommentStr = n3;
            else {
              var i4 = s2.transformTo(e3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i4);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e3 = this.extraFields[28789];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a3(this.fileName) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e3 = this.extraFields[25461];
          if (e3) {
            var t3 = n2(e3.value);
            return 1 !== t3.readInt(1) ? null : a3(this.fileComment) !== t3.readInt(4) ? null : o2.utf8decode(t3.readData(e3.length - 5));
          }
          return null;
        } }, t2.exports = l2;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t2, r2) {
        "use strict";
        function n2(e3, t3, r3) {
          this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t3, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
        }
        var s2 = e2("./stream/StreamHelper"), i3 = e2("./stream/DataWorker"), a3 = e2("./utf8"), o2 = e2("./compressedObject"), h = e2("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e3) {
          var t3 = null, r3 = "string";
          try {
            if (!e3)
              throw new Error("No output type specified.");
            var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
            "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t3 = this._decompressWorker();
            var i4 = !this._dataBinary;
            i4 && !n3 && (t3 = t3.pipe(new a3.Utf8EncodeWorker())), !i4 && n3 && (t3 = t3.pipe(new a3.Utf8DecodeWorker()));
          } catch (e4) {
            (t3 = new h("error")).error(e4);
          }
          return new s2(t3, r3, "");
        }, async: function(e3, t3) {
          return this.internalStream(e3).accumulate(t3);
        }, nodeStream: function(e3, t3) {
          return this.internalStream(e3 || "nodebuffer").toNodejsStream(t3);
        }, _compressWorker: function(e3, t3) {
          if (this._data instanceof o2 && this._data.compression.magic === e3.magic)
            return this._data.getCompressedWorker();
          var r3 = this._decompressWorker();
          return this._dataBinary || (r3 = r3.pipe(new a3.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t3);
        }, _decompressWorker: function() {
          return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i3(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f2 = 0; f2 < u.length; f2++)
          n2.prototype[u[f2]] = l2;
        t2.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l2, t2) {
        (function(t3) {
          "use strict";
          var r2, n2, e3 = t3.MutationObserver || t3.WebKitMutationObserver;
          if (e3) {
            var i3 = 0, s2 = new e3(u), a3 = t3.document.createTextNode("");
            s2.observe(a3, { characterData: true }), r2 = function() {
              a3.data = i3 = ++i3 % 2;
            };
          } else if (t3.setImmediate || void 0 === t3.MessageChannel)
            r2 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e4 = t3.document.createElement("script");
              e4.onreadystatechange = function() {
                u(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
              }, t3.document.documentElement.appendChild(e4);
            } : function() {
              setTimeout(u, 0);
            };
          else {
            var o2 = new t3.MessageChannel();
            o2.port1.onmessage = u, r2 = function() {
              o2.port2.postMessage(0);
            };
          }
          var h = [];
          function u() {
            var e4, t4;
            n2 = true;
            for (var r3 = h.length; r3; ) {
              for (t4 = h, h = [], e4 = -1; ++e4 < r3; )
                t4[e4]();
              r3 = h.length;
            }
            n2 = false;
          }
          l2.exports = function(e4) {
            1 !== h.push(e4) || n2 || r2();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t2, r2) {
        "use strict";
        var i3 = e2("immediate");
        function u() {
        }
        var l2 = {}, s2 = ["REJECTED"], a3 = ["FULFILLED"], n2 = ["PENDING"];
        function o2(e3) {
          if ("function" != typeof e3)
            throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u && d(this, e3);
        }
        function h(e3, t3, r3) {
          this.promise = e3, "function" == typeof t3 && (this.onFulfilled = t3, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
        }
        function f2(t3, r3, n3) {
          i3(function() {
            var e3;
            try {
              e3 = r3(n3);
            } catch (e4) {
              return l2.reject(t3, e4);
            }
            e3 === t3 ? l2.reject(t3, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t3, e3);
          });
        }
        function c2(e3) {
          var t3 = e3 && e3.then;
          if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t3)
            return function() {
              t3.apply(e3, arguments);
            };
        }
        function d(t3, e3) {
          var r3 = false;
          function n3(e4) {
            r3 || (r3 = true, l2.reject(t3, e4));
          }
          function i4(e4) {
            r3 || (r3 = true, l2.resolve(t3, e4));
          }
          var s3 = p2(function() {
            e3(i4, n3);
          });
          "error" === s3.status && n3(s3.value);
        }
        function p2(e3, t3) {
          var r3 = {};
          try {
            r3.value = e3(t3), r3.status = "success";
          } catch (e4) {
            r3.status = "error", r3.value = e4;
          }
          return r3;
        }
        (t2.exports = o2).prototype.finally = function(t3) {
          if ("function" != typeof t3)
            return this;
          var r3 = this.constructor;
          return this.then(function(e3) {
            return r3.resolve(t3()).then(function() {
              return e3;
            });
          }, function(e3) {
            return r3.resolve(t3()).then(function() {
              throw e3;
            });
          });
        }, o2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, o2.prototype.then = function(e3, t3) {
          if ("function" != typeof e3 && this.state === a3 || "function" != typeof t3 && this.state === s2)
            return this;
          var r3 = new this.constructor(u);
          this.state !== n2 ? f2(r3, this.state === a3 ? e3 : t3, this.outcome) : this.queue.push(new h(r3, e3, t3));
          return r3;
        }, h.prototype.callFulfilled = function(e3) {
          l2.resolve(this.promise, e3);
        }, h.prototype.otherCallFulfilled = function(e3) {
          f2(this.promise, this.onFulfilled, e3);
        }, h.prototype.callRejected = function(e3) {
          l2.reject(this.promise, e3);
        }, h.prototype.otherCallRejected = function(e3) {
          f2(this.promise, this.onRejected, e3);
        }, l2.resolve = function(e3, t3) {
          var r3 = p2(c2, t3);
          if ("error" === r3.status)
            return l2.reject(e3, r3.value);
          var n3 = r3.value;
          if (n3)
            d(e3, n3);
          else {
            e3.state = a3, e3.outcome = t3;
            for (var i4 = -1, s3 = e3.queue.length; ++i4 < s3; )
              e3.queue[i4].callFulfilled(t3);
          }
          return e3;
        }, l2.reject = function(e3, t3) {
          e3.state = s2, e3.outcome = t3;
          for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; )
            e3.queue[r3].callRejected(t3);
          return e3;
        }, o2.resolve = function(e3) {
          if (e3 instanceof this)
            return e3;
          return l2.resolve(new this(u), e3);
        }, o2.reject = function(e3) {
          var t3 = new this(u);
          return l2.reject(t3, e3);
        }, o2.all = function(e3) {
          var r3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var n3 = e3.length, i4 = false;
          if (!n3)
            return this.resolve([]);
          var s3 = new Array(n3), a4 = 0, t3 = -1, o3 = new this(u);
          for (; ++t3 < n3; )
            h2(e3[t3], t3);
          return o3;
          function h2(e4, t4) {
            r3.resolve(e4).then(function(e5) {
              s3[t4] = e5, ++a4 !== n3 || i4 || (i4 = true, l2.resolve(o3, s3));
            }, function(e5) {
              i4 || (i4 = true, l2.reject(o3, e5));
            });
          }
        }, o2.race = function(e3) {
          var t3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3))
            return this.reject(new TypeError("must be an array"));
          var r3 = e3.length, n3 = false;
          if (!r3)
            return this.resolve([]);
          var i4 = -1, s3 = new this(u);
          for (; ++i4 < r3; )
            a4 = e3[i4], t3.resolve(a4).then(function(e4) {
              n3 || (n3 = true, l2.resolve(s3, e4));
            }, function(e4) {
              n3 || (n3 = true, l2.reject(s3, e4));
            });
          var a4;
          return s3;
        };
      }, { immediate: 36 }], 38: [function(e2, t2, r2) {
        "use strict";
        var n2 = {};
        (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t2.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t2, r2) {
        "use strict";
        var a3 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h = e2("./utils/strings"), i3 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u = Object.prototype.toString, l2 = 0, f2 = -1, c2 = 0, d = 8;
        function p2(e3) {
          if (!(this instanceof p2))
            return new p2(e3);
          this.options = o2.assign({ level: f2, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 < t3.windowBits ? t3.windowBits = -t3.windowBits : t3.gzip && 0 < t3.windowBits && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
          var r3 = a3.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
          if (r3 !== l2)
            throw new Error(i3[r3]);
          if (t3.header && a3.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
            var n3;
            if (n3 = "string" == typeof t3.dictionary ? h.string2buf(t3.dictionary) : "[object ArrayBuffer]" === u.call(t3.dictionary) ? new Uint8Array(t3.dictionary) : t3.dictionary, (r3 = a3.deflateSetDictionary(this.strm, n3)) !== l2)
              throw new Error(i3[r3]);
            this._dict_set = true;
          }
        }
        function n2(e3, t3) {
          var r3 = new p2(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || i3[r3.err];
          return r3.result;
        }
        p2.prototype.push = function(e3, t3) {
          var r3, n3, i4 = this.strm, s3 = this.options.chunkSize;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? 4 : 0, "string" == typeof e3 ? i4.input = h.string2buf(e3) : "[object ArrayBuffer]" === u.call(e3) ? i4.input = new Uint8Array(e3) : i4.input = e3, i4.next_in = 0, i4.avail_in = i4.input.length;
          do {
            if (0 === i4.avail_out && (i4.output = new o2.Buf8(s3), i4.next_out = 0, i4.avail_out = s3), 1 !== (r3 = a3.deflate(i4, n3)) && r3 !== l2)
              return this.onEnd(r3), !(this.ended = true);
            0 !== i4.avail_out && (0 !== i4.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h.buf2binstring(o2.shrinkBuf(i4.output, i4.next_out))) : this.onData(o2.shrinkBuf(i4.output, i4.next_out)));
          } while ((0 < i4.avail_in || 0 === i4.avail_out) && 1 !== r3);
          return 4 === n3 ? (r3 = a3.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l2) : 2 !== n3 || (this.onEnd(l2), !(i4.avail_out = 0));
        }, p2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, p2.prototype.onEnd = function(e3) {
          e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, n2(e3, t3);
        }, r2.gzip = function(e3, t3) {
          return (t3 = t3 || {}).gzip = true, n2(e3, t3);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t2, r2) {
        "use strict";
        var c2 = e2("./zlib/inflate"), d = e2("./utils/common"), p2 = e2("./utils/strings"), m = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i3 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a3(e3) {
          if (!(this instanceof a3))
            return new a3(e3);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t3 = this.options;
          t3.raw && 0 <= t3.windowBits && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, 0 === t3.windowBits && (t3.windowBits = -15)), !(0 <= t3.windowBits && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), 15 < t3.windowBits && t3.windowBits < 48 && 0 == (15 & t3.windowBits) && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i3(), this.strm.avail_out = 0;
          var r3 = c2.inflateInit2(this.strm, t3.windowBits);
          if (r3 !== m.Z_OK)
            throw new Error(n2[r3]);
          this.header = new s2(), c2.inflateGetHeader(this.strm, this.header);
        }
        function o2(e3, t3) {
          var r3 = new a3(t3);
          if (r3.push(e3, true), r3.err)
            throw r3.msg || n2[r3.err];
          return r3.result;
        }
        a3.prototype.push = function(e3, t3) {
          var r3, n3, i4, s3, a4, o3, h = this.strm, u = this.options.chunkSize, l2 = this.options.dictionary, f2 = false;
          if (this.ended)
            return false;
          n3 = t3 === ~~t3 ? t3 : true === t3 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e3 ? h.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _2.call(e3) ? h.input = new Uint8Array(e3) : h.input = e3, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r3 = c2.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l2 && (o3 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _2.call(l2) ? new Uint8Array(l2) : l2, r3 = c2.inflateSetDictionary(this.strm, o3)), r3 === m.Z_BUF_ERROR && true === f2 && (r3 = m.Z_OK, f2 = false), r3 !== m.Z_STREAM_END && r3 !== m.Z_OK)
              return this.onEnd(r3), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r3 !== m.Z_STREAM_END && (0 !== h.avail_in || n3 !== m.Z_FINISH && n3 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i4 = p2.utf8border(h.output, h.next_out), s3 = h.next_out - i4, a4 = p2.buf2string(h.output, i4), h.next_out = s3, h.avail_out = u - s3, s3 && d.arraySet(h.output, h.output, i4, s3, 0), this.onData(a4)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f2 = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r3 !== m.Z_STREAM_END);
          return r3 === m.Z_STREAM_END && (n3 = m.Z_FINISH), n3 === m.Z_FINISH ? (r3 = c2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m.Z_OK) : n3 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a3.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, a3.prototype.onEnd = function(e3) {
          e3 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Inflate = a3, r2.inflate = o2, r2.inflateRaw = function(e3, t3) {
          return (t3 = t3 || {}).raw = true, o2(e3, t3);
        }, r2.ungzip = o2;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t2, r2) {
        "use strict";
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e3) {
          for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
            var r3 = t3.shift();
            if (r3) {
              if ("object" != typeof r3)
                throw new TypeError(r3 + "must be non-object");
              for (var n3 in r3)
                r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
            }
          }
          return e3;
        }, r2.shrinkBuf = function(e3, t3) {
          return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
        };
        var i3 = { arraySet: function(e3, t3, r3, n3, i4) {
          if (t3.subarray && e3.subarray)
            e3.set(t3.subarray(r3, r3 + n3), i4);
          else
            for (var s3 = 0; s3 < n3; s3++)
              e3[i4 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          var t3, r3, n3, i4, s3, a3;
          for (t3 = n3 = 0, r3 = e3.length; t3 < r3; t3++)
            n3 += e3[t3].length;
          for (a3 = new Uint8Array(n3), t3 = i4 = 0, r3 = e3.length; t3 < r3; t3++)
            s3 = e3[t3], a3.set(s3, i4), i4 += s3.length;
          return a3;
        } }, s2 = { arraySet: function(e3, t3, r3, n3, i4) {
          for (var s3 = 0; s3 < n3; s3++)
            e3[i4 + s3] = t3[r3 + s3];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        r2.setTyped = function(e3) {
          e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i3)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
        }, r2.setTyped(n2);
      }, {}], 42: [function(e2, t2, r2) {
        "use strict";
        var h = e2("./common"), i3 = true, s2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          i3 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          s2 = false;
        }
        for (var u = new h.Buf8(256), n2 = 0; n2 < 256; n2++)
          u[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l2(e3, t3) {
          if (t3 < 65537 && (e3.subarray && s2 || !e3.subarray && i3))
            return String.fromCharCode.apply(null, h.shrinkBuf(e3, t3));
          for (var r3 = "", n3 = 0; n3 < t3; n3++)
            r3 += String.fromCharCode(e3[n3]);
          return r3;
        }
        u[254] = u[254] = 1, r2.string2buf = function(e3) {
          var t3, r3, n3, i4, s3, a3 = e3.length, o2 = 0;
          for (i4 = 0; i4 < a3; i4++)
            55296 == (64512 & (r3 = e3.charCodeAt(i4))) && i4 + 1 < a3 && 56320 == (64512 & (n3 = e3.charCodeAt(i4 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i4++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t3 = new h.Buf8(o2), i4 = s3 = 0; s3 < o2; i4++)
            55296 == (64512 & (r3 = e3.charCodeAt(i4))) && i4 + 1 < a3 && 56320 == (64512 & (n3 = e3.charCodeAt(i4 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i4++), r3 < 128 ? t3[s3++] = r3 : (r3 < 2048 ? t3[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t3[s3++] = 224 | r3 >>> 12 : (t3[s3++] = 240 | r3 >>> 18, t3[s3++] = 128 | r3 >>> 12 & 63), t3[s3++] = 128 | r3 >>> 6 & 63), t3[s3++] = 128 | 63 & r3);
          return t3;
        }, r2.buf2binstring = function(e3) {
          return l2(e3, e3.length);
        }, r2.binstring2buf = function(e3) {
          for (var t3 = new h.Buf8(e3.length), r3 = 0, n3 = t3.length; r3 < n3; r3++)
            t3[r3] = e3.charCodeAt(r3);
          return t3;
        }, r2.buf2string = function(e3, t3) {
          var r3, n3, i4, s3, a3 = t3 || e3.length, o2 = new Array(2 * a3);
          for (r3 = n3 = 0; r3 < a3; )
            if ((i4 = e3[r3++]) < 128)
              o2[n3++] = i4;
            else if (4 < (s3 = u[i4]))
              o2[n3++] = 65533, r3 += s3 - 1;
            else {
              for (i4 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a3; )
                i4 = i4 << 6 | 63 & e3[r3++], s3--;
              1 < s3 ? o2[n3++] = 65533 : i4 < 65536 ? o2[n3++] = i4 : (i4 -= 65536, o2[n3++] = 55296 | i4 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i4);
            }
          return l2(o2, n3);
        }, r2.utf8border = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
        };
      }, { "./common": 41 }], 43: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3, r3, n2) {
          for (var i3 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a3 = 0; 0 !== r3; ) {
            for (r3 -= a3 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i3 = i3 + t3[n2++] | 0) | 0, --a3; )
              ;
            i3 %= 65521, s2 %= 65521;
          }
          return i3 | s2 << 16 | 0;
        };
      }, {}], 44: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t2, r2) {
        "use strict";
        var o2 = function() {
          for (var e3, t3 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n2 = 0; n2 < 8; n2++)
              e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t3[r3] = e3;
          }
          return t3;
        }();
        t2.exports = function(e3, t3, r3, n2) {
          var i3 = o2, s2 = n2 + r3;
          e3 ^= -1;
          for (var a3 = n2; a3 < s2; a3++)
            e3 = e3 >>> 8 ^ i3[255 & (e3 ^ t3[a3])];
          return -1 ^ e3;
        };
      }, {}], 46: [function(e2, t2, r2) {
        "use strict";
        var h, c2 = e2("../utils/common"), u = e2("./trees"), d = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l2 = 0, f2 = 4, m = 0, _2 = -2, g = -1, b2 = 4, i3 = 2, v = 8, y2 = 9, s2 = 286, a3 = 30, o2 = 19, w = 2 * s2 + 1, k = 15, x2 = 3, S = 258, z = S + x2 + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e3, t3) {
          return e3.msg = n2[t3], t3;
        }
        function T(e3) {
          return (e3 << 1) - (4 < e3 ? 9 : 0);
        }
        function D(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        function F(e3) {
          var t3 = e3.state, r3 = t3.pending;
          r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c2.arraySet(e3.output, t3.pending_buf, t3.pending_out, r3, e3.next_out), e3.next_out += r3, t3.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t3.pending -= r3, 0 === t3.pending && (t3.pending_out = 0));
        }
        function N(e3, t3) {
          u._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, F(e3.strm);
        }
        function U2(e3, t3) {
          e3.pending_buf[e3.pending++] = t3;
        }
        function P(e3, t3) {
          e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
        }
        function L(e3, t3) {
          var r3, n3, i4 = e3.max_chain_length, s3 = e3.strstart, a4 = e3.prev_length, o3 = e3.nice_match, h2 = e3.strstart > e3.w_size - z ? e3.strstart - (e3.w_size - z) : 0, u2 = e3.window, l3 = e3.w_mask, f3 = e3.prev, c3 = e3.strstart + S, d2 = u2[s3 + a4 - 1], p3 = u2[s3 + a4];
          e3.prev_length >= e3.good_match && (i4 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
          do {
            if (u2[(r3 = t3) + a4] === p3 && u2[r3 + a4 - 1] === d2 && u2[r3] === u2[s3] && u2[++r3] === u2[s3 + 1]) {
              s3 += 2, r3++;
              do {
              } while (u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && u2[++s3] === u2[++r3] && s3 < c3);
              if (n3 = S - (c3 - s3), s3 = c3 - S, a4 < n3) {
                if (e3.match_start = t3, o3 <= (a4 = n3))
                  break;
                d2 = u2[s3 + a4 - 1], p3 = u2[s3 + a4];
              }
            }
          } while ((t3 = f3[t3 & l3]) > h2 && 0 != --i4);
          return a4 <= e3.lookahead ? a4 : e3.lookahead;
        }
        function j(e3) {
          var t3, r3, n3, i4, s3, a4, o3, h2, u2, l3, f3 = e3.w_size;
          do {
            if (i4 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f3 + (f3 - z)) {
              for (c2.arraySet(e3.window, e3.window, f3, f3, 0), e3.match_start -= f3, e3.strstart -= f3, e3.block_start -= f3, t3 = r3 = e3.hash_size; n3 = e3.head[--t3], e3.head[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
                ;
              for (t3 = r3 = f3; n3 = e3.prev[--t3], e3.prev[t3] = f3 <= n3 ? n3 - f3 : 0, --r3; )
                ;
              i4 += f3;
            }
            if (0 === e3.strm.avail_in)
              break;
            if (a4 = e3.strm, o3 = e3.window, h2 = e3.strstart + e3.lookahead, u2 = i4, l3 = void 0, l3 = a4.avail_in, u2 < l3 && (l3 = u2), r3 = 0 === l3 ? 0 : (a4.avail_in -= l3, c2.arraySet(o3, a4.input, a4.next_in, l3, h2), 1 === a4.state.wrap ? a4.adler = d(a4.adler, o3, l3, h2) : 2 === a4.state.wrap && (a4.adler = p2(a4.adler, o3, l3, h2)), a4.next_in += l3, a4.total_in += l3, l3), e3.lookahead += r3, e3.lookahead + e3.insert >= x2)
              for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); )
                ;
          } while (e3.lookahead < z && 0 !== e3.strm.avail_in);
        }
        function Z(e3, t3) {
          for (var r3, n3; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t3 === l2)
                return A;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z && (e3.match_length = L(e3, r3)), e3.match_length >= x2)
              if (n3 = u._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
                for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; )
                  ;
                e3.strstart++;
              } else
                e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else
              n3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (n3 && (N(e3, false), 0 === e3.strm.avail_out))
              return A;
          }
          return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
        }
        function W(e3, t3) {
          for (var r3, n3, i4; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t3 === l2)
                return A;
              if (0 === e3.lookahead)
                break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z && (e3.match_length = L(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
              for (i4 = e3.strstart + e3.lookahead - x2, n3 = u._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i4 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; )
                ;
              if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            } else if (e3.match_available) {
              if ((n3 = u._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out)
                return A;
            } else
              e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (n3 = u._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t3 === f2 ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
        }
        function M(e3, t3, r3, n3, i4) {
          this.good_length = e3, this.max_lazy = t3, this.nice_length = r3, this.max_chain = n3, this.func = i4;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w), this.dyn_dtree = new c2.Buf16(2 * (2 * a3 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o2 + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k + 1), this.heap = new c2.Buf16(2 * s2 + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s2 + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e3) {
          var t3;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i3, (t3 = e3.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? C : E, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = l2, u._tr_init(t3), m) : R(e3, _2);
        }
        function K(e3) {
          var t3 = G(e3);
          return t3 === m && function(e4) {
            e4.window_size = 2 * e4.w_size, D(e4.head), e4.max_lazy_match = h[e4.level].max_lazy, e4.good_match = h[e4.level].good_length, e4.nice_match = h[e4.level].nice_length, e4.max_chain_length = h[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
          }(e3.state), t3;
        }
        function Y(e3, t3, r3, n3, i4, s3) {
          if (!e3)
            return _2;
          var a4 = 1;
          if (t3 === g && (t3 = 6), n3 < 0 ? (a4 = 0, n3 = -n3) : 15 < n3 && (a4 = 2, n3 -= 16), i4 < 1 || y2 < i4 || r3 !== v || n3 < 8 || 15 < n3 || t3 < 0 || 9 < t3 || s3 < 0 || b2 < s3)
            return R(e3, _2);
          8 === n3 && (n3 = 9);
          var o3 = new H();
          return (e3.state = o3).strm = e3, o3.wrap = a4, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i4 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c2.Buf8(2 * o3.w_size), o3.head = new c2.Buf16(o3.hash_size), o3.prev = new c2.Buf16(o3.w_size), o3.lit_bufsize = 1 << i4 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = s3, o3.method = r3, K(e3);
        }
        h = [new M(0, 0, 0, 0, function(e3, t3) {
          var r3 = 65535;
          for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (j(e3), 0 === e3.lookahead && t3 === l2)
                return A;
              if (0 === e3.lookahead)
                break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var n3 = e3.block_start + r3;
            if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N(e3, false), 0 === e3.strm.avail_out))
              return A;
            if (e3.strstart - e3.block_start >= e3.w_size - z && (N(e3, false), 0 === e3.strm.avail_out))
              return A;
          }
          return e3.insert = 0, t3 === f2 ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : (e3.strstart > e3.block_start && (N(e3, false), e3.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r2.deflateInit = function(e3, t3) {
          return Y(e3, t3, v, 15, 8, 0);
        }, r2.deflateInit2 = Y, r2.deflateReset = K, r2.deflateResetKeep = G, r2.deflateSetHeader = function(e3, t3) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? _2 : (e3.state.gzhead = t3, m) : _2;
        }, r2.deflate = function(e3, t3) {
          var r3, n3, i4, s3;
          if (!e3 || !e3.state || 5 < t3 || t3 < 0)
            return e3 ? R(e3, _2) : _2;
          if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t3 !== f2)
            return R(e3, 0 === e3.avail_out ? -5 : _2);
          if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t3, n3.status === C)
            if (2 === n3.wrap)
              e3.adler = 0, U2(n3, 31), U2(n3, 139), U2(n3, 8), n3.gzhead ? (U2(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U2(n3, 255 & n3.gzhead.time), U2(n3, n3.gzhead.time >> 8 & 255), U2(n3, n3.gzhead.time >> 16 & 255), U2(n3, n3.gzhead.time >> 24 & 255), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 3), n3.status = E);
            else {
              var a4 = v + (n3.w_bits - 8 << 4) << 8;
              a4 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a4 |= 32), a4 += 31 - a4 % 31, n3.status = E, P(n3, a4), 0 !== n3.strstart && (P(n3, e3.adler >>> 16), P(n3, 65535 & e3.adler)), e3.adler = 1;
            }
          if (69 === n3.status)
            if (n3.gzhead.extra) {
              for (i4 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), F(e3), i4 = n3.pending, n3.pending !== n3.pending_buf_size)); )
                U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
              n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
            } else
              n3.status = 73;
          if (73 === n3.status)
            if (n3.gzhead.name) {
              i4 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), F(e3), i4 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
            } else
              n3.status = 91;
          if (91 === n3.status)
            if (n3.gzhead.comment) {
              i4 = n3.pending;
              do {
                if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), F(e3), i4 = n3.pending, n3.pending === n3.pending_buf_size)) {
                  s3 = 1;
                  break;
                }
                s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
              } while (0 !== s3);
              n3.gzhead.hcrc && n3.pending > i4 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i4, i4)), 0 === s3 && (n3.status = 103);
            } else
              n3.status = 103;
          if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F(e3), n3.pending + 2 <= n3.pending_buf_size && (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E)) : n3.status = E), 0 !== n3.pending) {
            if (F(e3), 0 === e3.avail_out)
              return n3.last_flush = -1, m;
          } else if (0 === e3.avail_in && T(t3) <= T(r3) && t3 !== f2)
            return R(e3, -5);
          if (666 === n3.status && 0 !== e3.avail_in)
            return R(e3, -5);
          if (0 !== e3.avail_in || 0 !== n3.lookahead || t3 !== l2 && 666 !== n3.status) {
            var o3 = 2 === n3.strategy ? function(e4, t4) {
              for (var r4; ; ) {
                if (0 === e4.lookahead && (j(e4), 0 === e4.lookahead)) {
                  if (t4 === l2)
                    return A;
                  break;
                }
                if (e4.match_length = 0, r4 = u._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N(e4, false), 0 === e4.strm.avail_out))
                  return A;
              }
              return e4.insert = 0, t4 === f2 ? (N(e4, true), 0 === e4.strm.avail_out ? O : B) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A : I;
            }(n3, t3) : 3 === n3.strategy ? function(e4, t4) {
              for (var r4, n4, i5, s4, a5 = e4.window; ; ) {
                if (e4.lookahead <= S) {
                  if (j(e4), e4.lookahead <= S && t4 === l2)
                    return A;
                  if (0 === e4.lookahead)
                    break;
                }
                if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a5[i5 = e4.strstart - 1]) === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5]) {
                  s4 = e4.strstart + S;
                  do {
                  } while (n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && n4 === a5[++i5] && i5 < s4);
                  e4.match_length = S - (s4 - i5), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= x2 ? (r4 = u._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N(e4, false), 0 === e4.strm.avail_out))
                  return A;
              }
              return e4.insert = 0, t4 === f2 ? (N(e4, true), 0 === e4.strm.avail_out ? O : B) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A : I;
            }(n3, t3) : h[n3.level].func(n3, t3);
            if (o3 !== O && o3 !== B || (n3.status = 666), o3 === A || o3 === O)
              return 0 === e3.avail_out && (n3.last_flush = -1), m;
            if (o3 === I && (1 === t3 ? u._tr_align(n3) : 5 !== t3 && (u._tr_stored_block(n3, 0, 0, false), 3 === t3 && (D(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F(e3), 0 === e3.avail_out))
              return n3.last_flush = -1, m;
          }
          return t3 !== f2 ? m : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), U2(n3, e3.adler >> 16 & 255), U2(n3, e3.adler >> 24 & 255), U2(n3, 255 & e3.total_in), U2(n3, e3.total_in >> 8 & 255), U2(n3, e3.total_in >> 16 & 255), U2(n3, e3.total_in >> 24 & 255)) : (P(n3, e3.adler >>> 16), P(n3, 65535 & e3.adler)), F(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m : 1);
        }, r2.deflateEnd = function(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state.status) !== C && 69 !== t3 && 73 !== t3 && 91 !== t3 && 103 !== t3 && t3 !== E && 666 !== t3 ? R(e3, _2) : (e3.state = null, t3 === E ? R(e3, -3) : m) : _2;
        }, r2.deflateSetDictionary = function(e3, t3) {
          var r3, n3, i4, s3, a4, o3, h2, u2, l3 = t3.length;
          if (!e3 || !e3.state)
            return _2;
          if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C || r3.lookahead)
            return _2;
          for (1 === s3 && (e3.adler = d(e3.adler, t3, l3, 0)), r3.wrap = 0, l3 >= r3.w_size && (0 === s3 && (D(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u2 = new c2.Buf8(r3.w_size), c2.arraySet(u2, t3, l3 - r3.w_size, r3.w_size, 0), t3 = u2, l3 = r3.w_size), a4 = e3.avail_in, o3 = e3.next_in, h2 = e3.input, e3.avail_in = l3, e3.next_in = 0, e3.input = t3, j(r3); r3.lookahead >= x2; ) {
            for (n3 = r3.strstart, i4 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i4; )
              ;
            r3.strstart = n3, r3.lookahead = x2 - 1, j(r3);
          }
          return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h2, e3.avail_in = a4, r3.wrap = s3, m;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function(e3, t3) {
          var r3, n2, i3, s2, a3, o2, h, u, l2, f2, c2, d, p2, m, _2, g, b2, v, y2, w, k, x2, S, z, C;
          r3 = e3.state, n2 = e3.next_in, z = e3.input, i3 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C = e3.output, a3 = s2 - (t3 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h = r3.dmax, u = r3.wsize, l2 = r3.whave, f2 = r3.wnext, c2 = r3.window, d = r3.hold, p2 = r3.bits, m = r3.lencode, _2 = r3.distcode, g = (1 << r3.lenbits) - 1, b2 = (1 << r3.distbits) - 1;
          e:
            do {
              p2 < 15 && (d += z[n2++] << p2, p2 += 8, d += z[n2++] << p2, p2 += 8), v = m[d & g];
              t:
                for (; ; ) {
                  if (d >>>= y2 = v >>> 24, p2 -= y2, 0 === (y2 = v >>> 16 & 255))
                    C[s2++] = 65535 & v;
                  else {
                    if (!(16 & y2)) {
                      if (0 == (64 & y2)) {
                        v = m[(65535 & v) + (d & (1 << y2) - 1)];
                        continue t;
                      }
                      if (32 & y2) {
                        r3.mode = 12;
                        break e;
                      }
                      e3.msg = "invalid literal/length code", r3.mode = 30;
                      break e;
                    }
                    w = 65535 & v, (y2 &= 15) && (p2 < y2 && (d += z[n2++] << p2, p2 += 8), w += d & (1 << y2) - 1, d >>>= y2, p2 -= y2), p2 < 15 && (d += z[n2++] << p2, p2 += 8, d += z[n2++] << p2, p2 += 8), v = _2[d & b2];
                    r:
                      for (; ; ) {
                        if (d >>>= y2 = v >>> 24, p2 -= y2, !(16 & (y2 = v >>> 16 & 255))) {
                          if (0 == (64 & y2)) {
                            v = _2[(65535 & v) + (d & (1 << y2) - 1)];
                            continue r;
                          }
                          e3.msg = "invalid distance code", r3.mode = 30;
                          break e;
                        }
                        if (k = 65535 & v, p2 < (y2 &= 15) && (d += z[n2++] << p2, (p2 += 8) < y2 && (d += z[n2++] << p2, p2 += 8)), h < (k += d & (1 << y2) - 1)) {
                          e3.msg = "invalid distance too far back", r3.mode = 30;
                          break e;
                        }
                        if (d >>>= y2, p2 -= y2, (y2 = s2 - a3) < k) {
                          if (l2 < (y2 = k - y2) && r3.sane) {
                            e3.msg = "invalid distance too far back", r3.mode = 30;
                            break e;
                          }
                          if (S = c2, (x2 = 0) === f2) {
                            if (x2 += u - y2, y2 < w) {
                              for (w -= y2; C[s2++] = c2[x2++], --y2; )
                                ;
                              x2 = s2 - k, S = C;
                            }
                          } else if (f2 < y2) {
                            if (x2 += u + f2 - y2, (y2 -= f2) < w) {
                              for (w -= y2; C[s2++] = c2[x2++], --y2; )
                                ;
                              if (x2 = 0, f2 < w) {
                                for (w -= y2 = f2; C[s2++] = c2[x2++], --y2; )
                                  ;
                                x2 = s2 - k, S = C;
                              }
                            }
                          } else if (x2 += f2 - y2, y2 < w) {
                            for (w -= y2; C[s2++] = c2[x2++], --y2; )
                              ;
                            x2 = s2 - k, S = C;
                          }
                          for (; 2 < w; )
                            C[s2++] = S[x2++], C[s2++] = S[x2++], C[s2++] = S[x2++], w -= 3;
                          w && (C[s2++] = S[x2++], 1 < w && (C[s2++] = S[x2++]));
                        } else {
                          for (x2 = s2 - k; C[s2++] = C[x2++], C[s2++] = C[x2++], C[s2++] = C[x2++], 2 < (w -= 3); )
                            ;
                          w && (C[s2++] = C[x2++], 1 < w && (C[s2++] = C[x2++]));
                        }
                        break;
                      }
                  }
                  break;
                }
            } while (n2 < i3 && s2 < o2);
          n2 -= w = p2 >> 3, d &= (1 << (p2 -= w << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i3 ? i3 - n2 + 5 : 5 - (n2 - i3), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d, r3.bits = p2;
        };
      }, {}], 49: [function(e2, t2, r2) {
        "use strict";
        var I = e2("../utils/common"), O = e2("./adler32"), B = e2("./crc32"), R = e2("./inffast"), T = e2("./inftrees"), D = 1, F = 2, N = 0, U2 = -2, P = 1, n2 = 852, i3 = 592;
        function L(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        function s2() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a3(e3) {
          var t3;
          return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = P, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new I.Buf32(n2), t3.distcode = t3.distdyn = new I.Buf32(i3), t3.sane = 1, t3.back = -1, N) : U2;
        }
        function o2(e3) {
          var t3;
          return e3 && e3.state ? ((t3 = e3.state).wsize = 0, t3.whave = 0, t3.wnext = 0, a3(e3)) : U2;
        }
        function h(e3, t3) {
          var r3, n3;
          return e3 && e3.state ? (n3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || 15 < t3) ? U2 : (null !== n3.window && n3.wbits !== t3 && (n3.window = null), n3.wrap = r3, n3.wbits = t3, o2(e3))) : U2;
        }
        function u(e3, t3) {
          var r3, n3;
          return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h(e3, t3)) !== N && (e3.state = null), r3) : U2;
        }
        var l2, f2, c2 = true;
        function j(e3) {
          if (c2) {
            var t3;
            for (l2 = new I.Buf32(512), f2 = new I.Buf32(32), t3 = 0; t3 < 144; )
              e3.lens[t3++] = 8;
            for (; t3 < 256; )
              e3.lens[t3++] = 9;
            for (; t3 < 280; )
              e3.lens[t3++] = 7;
            for (; t3 < 288; )
              e3.lens[t3++] = 8;
            for (T(D, e3.lens, 0, 288, l2, 0, e3.work, { bits: 9 }), t3 = 0; t3 < 32; )
              e3.lens[t3++] = 5;
            T(F, e3.lens, 0, 32, f2, 0, e3.work, { bits: 5 }), c2 = false;
          }
          e3.lencode = l2, e3.lenbits = 9, e3.distcode = f2, e3.distbits = 5;
        }
        function Z(e3, t3, r3, n3) {
          var i4, s3 = e3.state;
          return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I.Buf8(s3.wsize)), n3 >= s3.wsize ? (I.arraySet(s3.window, t3, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i4 = s3.wsize - s3.wnext) && (i4 = n3), I.arraySet(s3.window, t3, r3 - n3, i4, s3.wnext), (n3 -= i4) ? (I.arraySet(s3.window, t3, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i4, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i4))), 0;
        }
        r2.inflateReset = o2, r2.inflateReset2 = h, r2.inflateResetKeep = a3, r2.inflateInit = function(e3) {
          return u(e3, 15);
        }, r2.inflateInit2 = u, r2.inflate = function(e3, t3) {
          var r3, n3, i4, s3, a4, o3, h2, u2, l3, f3, c3, d, p2, m, _2, g, b2, v, y2, w, k, x2, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in)
            return U2;
          12 === (r3 = e3.state).mode && (r3.mode = 13), a4 = e3.next_out, i4 = e3.output, h2 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u2 = r3.hold, l3 = r3.bits, f3 = o3, c3 = h2, x2 = N;
          e:
            for (; ; )
              switch (r3.mode) {
                case P:
                  if (0 === r3.wrap) {
                    r3.mode = 13;
                    break;
                  }
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if (2 & r3.wrap && 35615 === u2) {
                    E[r3.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0), l3 = u2 = 0, r3.mode = 2;
                    break;
                  }
                  if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                    e3.msg = "incorrect header check", r3.mode = 30;
                    break;
                  }
                  if (8 != (15 & u2)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (l3 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r3.wbits)
                    r3.wbits = k;
                  else if (k > r3.wbits) {
                    e3.msg = "invalid window size", r3.mode = 30;
                    break;
                  }
                  r3.dmax = 1 << k, e3.adler = r3.check = 1, r3.mode = 512 & u2 ? 10 : 12, l3 = u2 = 0;
                  break;
                case 2:
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if (r3.flags = u2, 8 != (255 & r3.flags)) {
                    e3.msg = "unknown compression method", r3.mode = 30;
                    break;
                  }
                  if (57344 & r3.flags) {
                    e3.msg = "unknown header flags set", r3.mode = 30;
                    break;
                  }
                  r3.head && (r3.head.text = u2 >> 8 & 1), 512 & r3.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u2 = 0, r3.mode = 3;
                case 3:
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.head && (r3.head.time = u2), 512 & r3.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r3.check = B(r3.check, E, 4, 0)), l3 = u2 = 0, r3.mode = 4;
                case 4:
                  for (; l3 < 16; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  r3.head && (r3.head.xflags = 255 & u2, r3.head.os = u2 >> 8), 512 & r3.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u2 = 0, r3.mode = 5;
                case 5:
                  if (1024 & r3.flags) {
                    for (; l3 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.length = u2, r3.head && (r3.head.extra_len = u2), 512 & r3.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r3.check = B(r3.check, E, 2, 0)), l3 = u2 = 0;
                  } else
                    r3.head && (r3.head.extra = null);
                  r3.mode = 6;
                case 6:
                  if (1024 & r3.flags && (o3 < (d = r3.length) && (d = o3), d && (r3.head && (k = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I.arraySet(r3.head.extra, n3, s3, d, k)), 512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, r3.length -= d), r3.length))
                    break e;
                  r3.length = 0, r3.mode = 7;
                case 7:
                  if (2048 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d = 0; k = n3[s3 + d++], r3.head && k && r3.length < 65536 && (r3.head.name += String.fromCharCode(k)), k && d < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, k)
                      break e;
                  } else
                    r3.head && (r3.head.name = null);
                  r3.length = 0, r3.mode = 8;
                case 8:
                  if (4096 & r3.flags) {
                    if (0 === o3)
                      break e;
                    for (d = 0; k = n3[s3 + d++], r3.head && k && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k)), k && d < o3; )
                      ;
                    if (512 & r3.flags && (r3.check = B(r3.check, n3, d, s3)), o3 -= d, s3 += d, k)
                      break e;
                  } else
                    r3.head && (r3.head.comment = null);
                  r3.mode = 9;
                case 9:
                  if (512 & r3.flags) {
                    for (; l3 < 16; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    if (u2 !== (65535 & r3.check)) {
                      e3.msg = "header crc mismatch", r3.mode = 30;
                      break;
                    }
                    l3 = u2 = 0;
                  }
                  r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
                  break;
                case 10:
                  for (; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  e3.adler = r3.check = L(u2), l3 = u2 = 0, r3.mode = 11;
                case 11:
                  if (0 === r3.havedict)
                    return e3.next_out = a4, e3.avail_out = h2, e3.next_in = s3, e3.avail_in = o3, r3.hold = u2, r3.bits = l3, 2;
                  e3.adler = r3.check = 1, r3.mode = 12;
                case 12:
                  if (5 === t3 || 6 === t3)
                    break e;
                case 13:
                  if (r3.last) {
                    u2 >>>= 7 & l3, l3 -= 7 & l3, r3.mode = 27;
                    break;
                  }
                  for (; l3 < 3; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  switch (r3.last = 1 & u2, l3 -= 1, 3 & (u2 >>>= 1)) {
                    case 0:
                      r3.mode = 14;
                      break;
                    case 1:
                      if (j(r3), r3.mode = 20, 6 !== t3)
                        break;
                      u2 >>>= 2, l3 -= 2;
                      break e;
                    case 2:
                      r3.mode = 17;
                      break;
                    case 3:
                      e3.msg = "invalid block type", r3.mode = 30;
                  }
                  u2 >>>= 2, l3 -= 2;
                  break;
                case 14:
                  for (u2 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                    e3.msg = "invalid stored block lengths", r3.mode = 30;
                    break;
                  }
                  if (r3.length = 65535 & u2, l3 = u2 = 0, r3.mode = 15, 6 === t3)
                    break e;
                case 15:
                  r3.mode = 16;
                case 16:
                  if (d = r3.length) {
                    if (o3 < d && (d = o3), h2 < d && (d = h2), 0 === d)
                      break e;
                    I.arraySet(i4, n3, s3, d, a4), o3 -= d, s3 += d, h2 -= d, a4 += d, r3.length -= d;
                    break;
                  }
                  r3.mode = 12;
                  break;
                case 17:
                  for (; l3 < 14; ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if (r3.nlen = 257 + (31 & u2), u2 >>>= 5, l3 -= 5, r3.ndist = 1 + (31 & u2), u2 >>>= 5, l3 -= 5, r3.ncode = 4 + (15 & u2), u2 >>>= 4, l3 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                    e3.msg = "too many length or distance symbols", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 18;
                case 18:
                  for (; r3.have < r3.ncode; ) {
                    for (; l3 < 3; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.lens[A[r3.have++]] = 7 & u2, u2 >>>= 3, l3 -= 3;
                  }
                  for (; r3.have < 19; )
                    r3.lens[A[r3.have++]] = 0;
                  if (r3.lencode = r3.lendyn, r3.lenbits = 7, S = { bits: r3.lenbits }, x2 = T(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S), r3.lenbits = S.bits, x2) {
                    e3.msg = "invalid code lengths set", r3.mode = 30;
                    break;
                  }
                  r3.have = 0, r3.mode = 19;
                case 19:
                  for (; r3.have < r3.nlen + r3.ndist; ) {
                    for (; g = (C = r3.lencode[u2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    if (b2 < 16)
                      u2 >>>= _2, l3 -= _2, r3.lens[r3.have++] = b2;
                    else {
                      if (16 === b2) {
                        for (z = _2 + 2; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u2 += n3[s3++] << l3, l3 += 8;
                        }
                        if (u2 >>>= _2, l3 -= _2, 0 === r3.have) {
                          e3.msg = "invalid bit length repeat", r3.mode = 30;
                          break;
                        }
                        k = r3.lens[r3.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l3 -= 2;
                      } else if (17 === b2) {
                        for (z = _2 + 3; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u2 += n3[s3++] << l3, l3 += 8;
                        }
                        l3 -= _2, k = 0, d = 3 + (7 & (u2 >>>= _2)), u2 >>>= 3, l3 -= 3;
                      } else {
                        for (z = _2 + 7; l3 < z; ) {
                          if (0 === o3)
                            break e;
                          o3--, u2 += n3[s3++] << l3, l3 += 8;
                        }
                        l3 -= _2, k = 0, d = 11 + (127 & (u2 >>>= _2)), u2 >>>= 7, l3 -= 7;
                      }
                      if (r3.have + d > r3.nlen + r3.ndist) {
                        e3.msg = "invalid bit length repeat", r3.mode = 30;
                        break;
                      }
                      for (; d--; )
                        r3.lens[r3.have++] = k;
                    }
                  }
                  if (30 === r3.mode)
                    break;
                  if (0 === r3.lens[256]) {
                    e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                    break;
                  }
                  if (r3.lenbits = 9, S = { bits: r3.lenbits }, x2 = T(D, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S), r3.lenbits = S.bits, x2) {
                    e3.msg = "invalid literal/lengths set", r3.mode = 30;
                    break;
                  }
                  if (r3.distbits = 6, r3.distcode = r3.distdyn, S = { bits: r3.distbits }, x2 = T(F, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S), r3.distbits = S.bits, x2) {
                    e3.msg = "invalid distances set", r3.mode = 30;
                    break;
                  }
                  if (r3.mode = 20, 6 === t3)
                    break e;
                case 20:
                  r3.mode = 21;
                case 21:
                  if (6 <= o3 && 258 <= h2) {
                    e3.next_out = a4, e3.avail_out = h2, e3.next_in = s3, e3.avail_in = o3, r3.hold = u2, r3.bits = l3, R(e3, c3), a4 = e3.next_out, i4 = e3.output, h2 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u2 = r3.hold, l3 = r3.bits, 12 === r3.mode && (r3.back = -1);
                    break;
                  }
                  for (r3.back = 0; g = (C = r3.lencode[u2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if (g && 0 == (240 & g)) {
                    for (v = _2, y2 = g, w = b2; g = (C = r3.lencode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b2 = 65535 & C, !(v + (_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    u2 >>>= v, l3 -= v, r3.back += v;
                  }
                  if (u2 >>>= _2, l3 -= _2, r3.back += _2, r3.length = b2, 0 === g) {
                    r3.mode = 26;
                    break;
                  }
                  if (32 & g) {
                    r3.back = -1, r3.mode = 12;
                    break;
                  }
                  if (64 & g) {
                    e3.msg = "invalid literal/length code", r3.mode = 30;
                    break;
                  }
                  r3.extra = 15 & g, r3.mode = 22;
                case 22:
                  if (r3.extra) {
                    for (z = r3.extra; l3 < z; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.length += u2 & (1 << r3.extra) - 1, u2 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                  }
                  r3.was = r3.length, r3.mode = 23;
                case 23:
                  for (; g = (C = r3.distcode[u2 & (1 << r3.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                    if (0 === o3)
                      break e;
                    o3--, u2 += n3[s3++] << l3, l3 += 8;
                  }
                  if (0 == (240 & g)) {
                    for (v = _2, y2 = g, w = b2; g = (C = r3.distcode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b2 = 65535 & C, !(v + (_2 = C >>> 24) <= l3); ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    u2 >>>= v, l3 -= v, r3.back += v;
                  }
                  if (u2 >>>= _2, l3 -= _2, r3.back += _2, 64 & g) {
                    e3.msg = "invalid distance code", r3.mode = 30;
                    break;
                  }
                  r3.offset = b2, r3.extra = 15 & g, r3.mode = 24;
                case 24:
                  if (r3.extra) {
                    for (z = r3.extra; l3 < z; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    r3.offset += u2 & (1 << r3.extra) - 1, u2 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
                  }
                  if (r3.offset > r3.dmax) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break;
                  }
                  r3.mode = 25;
                case 25:
                  if (0 === h2)
                    break e;
                  if (d = c3 - h2, r3.offset > d) {
                    if ((d = r3.offset - d) > r3.whave && r3.sane) {
                      e3.msg = "invalid distance too far back", r3.mode = 30;
                      break;
                    }
                    p2 = d > r3.wnext ? (d -= r3.wnext, r3.wsize - d) : r3.wnext - d, d > r3.length && (d = r3.length), m = r3.window;
                  } else
                    m = i4, p2 = a4 - r3.offset, d = r3.length;
                  for (h2 < d && (d = h2), h2 -= d, r3.length -= d; i4[a4++] = m[p2++], --d; )
                    ;
                  0 === r3.length && (r3.mode = 21);
                  break;
                case 26:
                  if (0 === h2)
                    break e;
                  i4[a4++] = r3.length, h2--, r3.mode = 21;
                  break;
                case 27:
                  if (r3.wrap) {
                    for (; l3 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 |= n3[s3++] << l3, l3 += 8;
                    }
                    if (c3 -= h2, e3.total_out += c3, r3.total += c3, c3 && (e3.adler = r3.check = r3.flags ? B(r3.check, i4, c3, a4 - c3) : O(r3.check, i4, c3, a4 - c3)), c3 = h2, (r3.flags ? u2 : L(u2)) !== r3.check) {
                      e3.msg = "incorrect data check", r3.mode = 30;
                      break;
                    }
                    l3 = u2 = 0;
                  }
                  r3.mode = 28;
                case 28:
                  if (r3.wrap && r3.flags) {
                    for (; l3 < 32; ) {
                      if (0 === o3)
                        break e;
                      o3--, u2 += n3[s3++] << l3, l3 += 8;
                    }
                    if (u2 !== (4294967295 & r3.total)) {
                      e3.msg = "incorrect length check", r3.mode = 30;
                      break;
                    }
                    l3 = u2 = 0;
                  }
                  r3.mode = 29;
                case 29:
                  x2 = 1;
                  break e;
                case 30:
                  x2 = -3;
                  break e;
                case 31:
                  return -4;
                case 32:
                default:
                  return U2;
              }
          return e3.next_out = a4, e3.avail_out = h2, e3.next_in = s3, e3.avail_in = o3, r3.hold = u2, r3.bits = l3, (r3.wsize || c3 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t3)) && Z(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r3.mode = 31, -4) : (f3 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f3, e3.total_out += c3, r3.total += c3, r3.wrap && c3 && (e3.adler = r3.check = r3.flags ? B(r3.check, i4, c3, e3.next_out - c3) : O(r3.check, i4, c3, e3.next_out - c3)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f3 && 0 === c3 || 4 === t3) && x2 === N && (x2 = -5), x2);
        }, r2.inflateEnd = function(e3) {
          if (!e3 || !e3.state)
            return U2;
          var t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, N;
        }, r2.inflateGetHeader = function(e3, t3) {
          var r3;
          return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U2 : ((r3.head = t3).done = false, N) : U2;
        }, r2.inflateSetDictionary = function(e3, t3) {
          var r3, n3 = t3.length;
          return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U2 : 11 === r3.mode && O(1, t3, n3, 0) !== r3.check ? -3 : Z(e3, t3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N) : U2;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t2, r2) {
        "use strict";
        var D = e2("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t2.exports = function(e3, t3, r3, n2, i3, s2, a3, o2) {
          var h, u, l2, f2, c2, d, p2, m, _2, g = o2.bits, b2 = 0, v = 0, y2 = 0, w = 0, k = 0, x2 = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b2 = 0; b2 <= 15; b2++)
            O[b2] = 0;
          for (v = 0; v < n2; v++)
            O[t3[r3 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
            ;
          if (w < k && (k = w), 0 === w)
            return i3[s2++] = 20971520, i3[s2++] = 20971520, o2.bits = 1, 0;
          for (y2 = 1; y2 < w && 0 === O[y2]; y2++)
            ;
          for (k < y2 && (k = y2), b2 = z = 1; b2 <= 15; b2++)
            if (z <<= 1, (z -= O[b2]) < 0)
              return -1;
          if (0 < z && (0 === e3 || 1 !== w))
            return -1;
          for (B[1] = 0, b2 = 1; b2 < 15; b2++)
            B[b2 + 1] = B[b2] + O[b2];
          for (v = 0; v < n2; v++)
            0 !== t3[r3 + v] && (a3[B[t3[r3 + v]]++] = v);
          if (d = 0 === e3 ? (A = R = a3, 19) : 1 === e3 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U2, R = P, -1), b2 = y2, c2 = s2, S = v = E = 0, l2 = -1, f2 = (C = 1 << (x2 = k)) - 1, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
            return 1;
          for (; ; ) {
            for (p2 = b2 - S, _2 = a3[v] < d ? (m = 0, a3[v]) : a3[v] > d ? (m = R[T + a3[v]], A[I + a3[v]]) : (m = 96, 0), h = 1 << b2 - S, y2 = u = 1 << x2; i3[c2 + (E >> S) + (u -= h)] = p2 << 24 | m << 16 | _2 | 0, 0 !== u; )
              ;
            for (h = 1 << b2 - 1; E & h; )
              h >>= 1;
            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b2]) {
              if (b2 === w)
                break;
              b2 = t3[r3 + a3[v]];
            }
            if (k < b2 && (E & f2) !== l2) {
              for (0 === S && (S = k), c2 += y2, z = 1 << (x2 = b2 - S); x2 + S < w && !((z -= O[x2 + S]) <= 0); )
                x2++, z <<= 1;
              if (C += 1 << x2, 1 === e3 && 852 < C || 2 === e3 && 592 < C)
                return 1;
              i3[l2 = E & f2] = k << 24 | x2 << 16 | c2 - s2 | 0;
            }
          }
          return 0 !== E && (i3[c2 + E] = b2 - S << 24 | 64 << 16 | 0), o2.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t2, r2) {
        "use strict";
        t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t2, r2) {
        "use strict";
        var i3 = e2("../utils/common"), o2 = 0, h = 1;
        function n2(e3) {
          for (var t3 = e3.length; 0 <= --t3; )
            e3[t3] = 0;
        }
        var s2 = 0, a3 = 29, u = 256, l2 = u + 1 + a3, f2 = 30, c2 = 19, _2 = 2 * l2 + 1, g = 15, d = 16, p2 = 7, m = 256, b2 = 16, v = 17, y2 = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l2 + 2));
        n2(z);
        var C = new Array(2 * f2);
        n2(C);
        var E = new Array(512);
        n2(E);
        var A = new Array(256);
        n2(A);
        var I = new Array(a3);
        n2(I);
        var O, B, R, T = new Array(f2);
        function D(e3, t3, r3, n3, i4) {
          this.static_tree = e3, this.extra_bits = t3, this.extra_base = r3, this.elems = n3, this.max_length = i4, this.has_stree = e3 && e3.length;
        }
        function F(e3, t3) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
        }
        function N(e3) {
          return e3 < 256 ? E[e3] : E[256 + (e3 >>> 7)];
        }
        function U2(e3, t3) {
          e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
        }
        function P(e3, t3, r3) {
          e3.bi_valid > d - r3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, U2(e3, e3.bi_buf), e3.bi_buf = t3 >> d - e3.bi_valid, e3.bi_valid += r3 - d) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += r3);
        }
        function L(e3, t3, r3) {
          P(e3, r3[2 * t3], r3[2 * t3 + 1]);
        }
        function j(e3, t3) {
          for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t3; )
            ;
          return r3 >>> 1;
        }
        function Z(e3, t3, r3) {
          var n3, i4, s3 = new Array(g + 1), a4 = 0;
          for (n3 = 1; n3 <= g; n3++)
            s3[n3] = a4 = a4 + r3[n3 - 1] << 1;
          for (i4 = 0; i4 <= t3; i4++) {
            var o3 = e3[2 * i4 + 1];
            0 !== o3 && (e3[2 * i4] = j(s3[o3]++, o3));
          }
        }
        function W(e3) {
          var t3;
          for (t3 = 0; t3 < l2; t3++)
            e3.dyn_ltree[2 * t3] = 0;
          for (t3 = 0; t3 < f2; t3++)
            e3.dyn_dtree[2 * t3] = 0;
          for (t3 = 0; t3 < c2; t3++)
            e3.bl_tree[2 * t3] = 0;
          e3.dyn_ltree[2 * m] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        function M(e3) {
          8 < e3.bi_valid ? U2(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        function H(e3, t3, r3, n3) {
          var i4 = 2 * t3, s3 = 2 * r3;
          return e3[i4] < e3[s3] || e3[i4] === e3[s3] && n3[t3] <= n3[r3];
        }
        function G(e3, t3, r3) {
          for (var n3 = e3.heap[r3], i4 = r3 << 1; i4 <= e3.heap_len && (i4 < e3.heap_len && H(t3, e3.heap[i4 + 1], e3.heap[i4], e3.depth) && i4++, !H(t3, n3, e3.heap[i4], e3.depth)); )
            e3.heap[r3] = e3.heap[i4], r3 = i4, i4 <<= 1;
          e3.heap[r3] = n3;
        }
        function K(e3, t3, r3) {
          var n3, i4, s3, a4, o3 = 0;
          if (0 !== e3.last_lit)
            for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i4 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L(e3, i4, t3) : (L(e3, (s3 = A[i4]) + u + 1, t3), 0 !== (a4 = w[s3]) && P(e3, i4 -= I[s3], a4), L(e3, s3 = N(--n3), r3), 0 !== (a4 = k[s3]) && P(e3, n3 -= T[s3], a4)), o3 < e3.last_lit; )
              ;
          L(e3, m, t3);
        }
        function Y(e3, t3) {
          var r3, n3, i4, s3 = t3.dyn_tree, a4 = t3.stat_desc.static_tree, o3 = t3.stat_desc.has_stree, h2 = t3.stat_desc.elems, u2 = -1;
          for (e3.heap_len = 0, e3.heap_max = _2, r3 = 0; r3 < h2; r3++)
            0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u2 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
          for (; e3.heap_len < 2; )
            s3[2 * (i4 = e3.heap[++e3.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e3.depth[i4] = 0, e3.opt_len--, o3 && (e3.static_len -= a4[2 * i4 + 1]);
          for (t3.max_code = u2, r3 = e3.heap_len >> 1; 1 <= r3; r3--)
            G(e3, s3, r3);
          for (i4 = h2; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i4] = s3[2 * r3] + s3[2 * n3], e3.depth[i4] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i4, e3.heap[1] = i4++, G(e3, s3, 1), 2 <= e3.heap_len; )
            ;
          e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t4) {
            var r4, n4, i5, s4, a5, o4, h3 = t4.dyn_tree, u3 = t4.max_code, l3 = t4.stat_desc.static_tree, f3 = t4.stat_desc.has_stree, c3 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m2 = 0;
            for (s4 = 0; s4 <= g; s4++)
              e4.bl_count[s4] = 0;
            for (h3[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _2; r4++)
              p3 < (s4 = h3[2 * h3[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m2++), h3[2 * n4 + 1] = s4, u3 < n4 || (e4.bl_count[s4]++, a5 = 0, d2 <= n4 && (a5 = c3[n4 - d2]), o4 = h3[2 * n4], e4.opt_len += o4 * (s4 + a5), f3 && (e4.static_len += o4 * (l3[2 * n4 + 1] + a5)));
            if (0 !== m2) {
              do {
                for (s4 = p3 - 1; 0 === e4.bl_count[s4]; )
                  s4--;
                e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m2 -= 2;
              } while (0 < m2);
              for (s4 = p3; 0 !== s4; s4--)
                for (n4 = e4.bl_count[s4]; 0 !== n4; )
                  u3 < (i5 = e4.heap[--r4]) || (h3[2 * i5 + 1] !== s4 && (e4.opt_len += (s4 - h3[2 * i5 + 1]) * h3[2 * i5], h3[2 * i5 + 1] = s4), n4--);
            }
          }(e3, t3), Z(s3, u2, e3.bl_count);
        }
        function X(e3, t3, r3) {
          var n3, i4, s3 = -1, a4 = t3[1], o3 = 0, h2 = 7, u2 = 4;
          for (0 === a4 && (h2 = 138, u2 = 3), t3[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++)
            i4 = a4, a4 = t3[2 * (n3 + 1) + 1], ++o3 < h2 && i4 === a4 || (o3 < u2 ? e3.bl_tree[2 * i4] += o3 : 0 !== i4 ? (i4 !== s3 && e3.bl_tree[2 * i4]++, e3.bl_tree[2 * b2]++) : o3 <= 10 ? e3.bl_tree[2 * v]++ : e3.bl_tree[2 * y2]++, s3 = i4, u2 = (o3 = 0) === a4 ? (h2 = 138, 3) : i4 === a4 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V(e3, t3, r3) {
          var n3, i4, s3 = -1, a4 = t3[1], o3 = 0, h2 = 7, u2 = 4;
          for (0 === a4 && (h2 = 138, u2 = 3), n3 = 0; n3 <= r3; n3++)
            if (i4 = a4, a4 = t3[2 * (n3 + 1) + 1], !(++o3 < h2 && i4 === a4)) {
              if (o3 < u2)
                for (; L(e3, i4, e3.bl_tree), 0 != --o3; )
                  ;
              else
                0 !== i4 ? (i4 !== s3 && (L(e3, i4, e3.bl_tree), o3--), L(e3, b2, e3.bl_tree), P(e3, o3 - 3, 2)) : o3 <= 10 ? (L(e3, v, e3.bl_tree), P(e3, o3 - 3, 3)) : (L(e3, y2, e3.bl_tree), P(e3, o3 - 11, 7));
              s3 = i4, u2 = (o3 = 0) === a4 ? (h2 = 138, 3) : i4 === a4 ? (h2 = 6, 3) : (h2 = 7, 4);
            }
        }
        n2(T);
        var q = false;
        function J(e3, t3, r3, n3) {
          P(e3, (s2 << 1) + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            M(e4), n4 && (U2(e4, r4), U2(e4, ~r4)), i3.arraySet(e4.pending_buf, e4.window, t4, r4, e4.pending), e4.pending += r4;
          }(e3, t3, r3, true);
        }
        r2._tr_init = function(e3) {
          q || (function() {
            var e4, t3, r3, n3, i4, s3 = new Array(g + 1);
            for (n3 = r3 = 0; n3 < a3 - 1; n3++)
              for (I[n3] = r3, e4 = 0; e4 < 1 << w[n3]; e4++)
                A[r3++] = n3;
            for (A[r3 - 1] = n3, n3 = i4 = 0; n3 < 16; n3++)
              for (T[n3] = i4, e4 = 0; e4 < 1 << k[n3]; e4++)
                E[i4++] = n3;
            for (i4 >>= 7; n3 < f2; n3++)
              for (T[n3] = i4 << 7, e4 = 0; e4 < 1 << k[n3] - 7; e4++)
                E[256 + i4++] = n3;
            for (t3 = 0; t3 <= g; t3++)
              s3[t3] = 0;
            for (e4 = 0; e4 <= 143; )
              z[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (; e4 <= 255; )
              z[2 * e4 + 1] = 9, e4++, s3[9]++;
            for (; e4 <= 279; )
              z[2 * e4 + 1] = 7, e4++, s3[7]++;
            for (; e4 <= 287; )
              z[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (Z(z, l2 + 1, s3), e4 = 0; e4 < f2; e4++)
              C[2 * e4 + 1] = 5, C[2 * e4] = j(e4, 5);
            O = new D(z, w, u + 1, l2, g), B = new D(C, k, 0, f2, g), R = new D(new Array(0), x2, 0, c2, p2);
          }(), q = true), e3.l_desc = new F(e3.dyn_ltree, O), e3.d_desc = new F(e3.dyn_dtree, B), e3.bl_desc = new F(e3.bl_tree, R), e3.bi_buf = 0, e3.bi_valid = 0, W(e3);
        }, r2._tr_stored_block = J, r2._tr_flush_block = function(e3, t3, r3, n3) {
          var i4, s3, a4 = 0;
          0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
            var t4, r4 = 4093624447;
            for (t4 = 0; t4 <= 31; t4++, r4 >>>= 1)
              if (1 & r4 && 0 !== e4.dyn_ltree[2 * t4])
                return o2;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26])
              return h;
            for (t4 = 32; t4 < u; t4++)
              if (0 !== e4.dyn_ltree[2 * t4])
                return h;
            return o2;
          }(e3)), Y(e3, e3.l_desc), Y(e3, e3.d_desc), a4 = function(e4) {
            var t4;
            for (X(e4, e4.dyn_ltree, e4.l_desc.max_code), X(e4, e4.dyn_dtree, e4.d_desc.max_code), Y(e4, e4.bl_desc), t4 = c2 - 1; 3 <= t4 && 0 === e4.bl_tree[2 * S[t4] + 1]; t4--)
              ;
            return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
          }(e3), i4 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i4 && (i4 = s3)) : i4 = s3 = r3 + 5, r3 + 4 <= i4 && -1 !== t3 ? J(e3, t3, r3, n3) : 4 === e3.strategy || s3 === i4 ? (P(e3, 2 + (n3 ? 1 : 0), 3), K(e3, z, C)) : (P(e3, 4 + (n3 ? 1 : 0), 3), function(e4, t4, r4, n4) {
            var i5;
            for (P(e4, t4 - 257, 5), P(e4, r4 - 1, 5), P(e4, n4 - 4, 4), i5 = 0; i5 < n4; i5++)
              P(e4, e4.bl_tree[2 * S[i5] + 1], 3);
            V(e4, e4.dyn_ltree, t4 - 1), V(e4, e4.dyn_dtree, r4 - 1);
          }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a4 + 1), K(e3, e3.dyn_ltree, e3.dyn_dtree)), W(e3), n3 && M(e3);
        }, r2._tr_tally = function(e3, t3, r3) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t3 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (A[r3] + u + 1)]++, e3.dyn_dtree[2 * N(t3)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, r2._tr_align = function(e3) {
          P(e3, 2, 3), L(e3, m, z), function(e4) {
            16 === e4.bi_valid ? (U2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          }(e3);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t2, r2) {
        "use strict";
        t2.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t2, r2) {
        (function(e3) {
          !function(r3, n2) {
            "use strict";
            if (!r3.setImmediate) {
              var i3, s2, t3, a3, o2 = 1, h = {}, u = false, l2 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
              e4 = e4 && e4.setTimeout ? e4 : r3, i3 = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
                process.nextTick(function() {
                  c2(e5);
                });
              } : function() {
                if (r3.postMessage && !r3.importScripts) {
                  var e5 = true, t4 = r3.onmessage;
                  return r3.onmessage = function() {
                    e5 = false;
                  }, r3.postMessage("", "*"), r3.onmessage = t4, e5;
                }
              }() ? (a3 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d, false) : r3.attachEvent("onmessage", d), function(e5) {
                r3.postMessage(a3 + e5, "*");
              }) : r3.MessageChannel ? ((t3 = new MessageChannel()).port1.onmessage = function(e5) {
                c2(e5.data);
              }, function(e5) {
                t3.port2.postMessage(e5);
              }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s2 = l2.documentElement, function(e5) {
                var t4 = l2.createElement("script");
                t4.onreadystatechange = function() {
                  c2(e5), t4.onreadystatechange = null, s2.removeChild(t4), t4 = null;
                }, s2.appendChild(t4);
              }) : function(e5) {
                setTimeout(c2, 0, e5);
              }, e4.setImmediate = function(e5) {
                "function" != typeof e5 && (e5 = new Function("" + e5));
                for (var t4 = new Array(arguments.length - 1), r4 = 0; r4 < t4.length; r4++)
                  t4[r4] = arguments[r4 + 1];
                var n3 = { callback: e5, args: t4 };
                return h[o2] = n3, i3(o2), o2++;
              }, e4.clearImmediate = f2;
            }
            function f2(e5) {
              delete h[e5];
            }
            function c2(e5) {
              if (u)
                setTimeout(c2, 0, e5);
              else {
                var t4 = h[e5];
                if (t4) {
                  u = true;
                  try {
                    !function(e6) {
                      var t5 = e6.callback, r4 = e6.args;
                      switch (r4.length) {
                        case 0:
                          t5();
                          break;
                        case 1:
                          t5(r4[0]);
                          break;
                        case 2:
                          t5(r4[0], r4[1]);
                          break;
                        case 3:
                          t5(r4[0], r4[1], r4[2]);
                          break;
                        default:
                          t5.apply(n2, r4);
                      }
                    }(t4);
                  } finally {
                    f2(e5), u = false;
                  }
                }
              }
            }
            function d(e5) {
              e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a3) && c2(+e5.data.slice(a3.length));
            }
          }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i3, l2, len, pos, chunk, result;
        len = 0;
        for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
          len += chunks[i3].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i3 = 0, l2 = chunks.length; i3 < l2; i3++) {
          chunk = chunks[i3];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i3 = 0; i3 < len; i3++) {
          dest[dest_offs + i3] = src[src_offs + i3];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits(s2, value, length2) {
      if (s2.bi_valid > Buf_size - length2) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length2 - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length2;
      }
    }
    function send_code(s2, c2, tree) {
      send_bits(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s2) {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n2, m;
      var bits;
      var xbits;
      var f2;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h = s2.heap_max + 1; h < HEAP_SIZE; h++) {
        n2 = s2.heap[h];
        bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n2 * 2 + 1] = bits;
        if (n2 > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n2 >= base) {
          xbits = extra[n2 - base];
        }
        f2 = tree[n2 * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n2 = s2.bl_count[bits];
        while (n2 !== 0) {
          m = s2.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n2--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n2;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        var len = tree[n2 * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n2 * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n2;
      var bits;
      var length2;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length2 = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length2;
        for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
          _length_code[length2++] = code;
        }
      }
      _length_code[length2 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n2 = 0;
      while (n2 <= 143) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      while (n2 <= 255) {
        static_ltree[n2 * 2 + 1] = 9;
        n2++;
        bl_count[9]++;
      }
      while (n2 <= 279) {
        static_ltree[n2 * 2 + 1] = 7;
        n2++;
        bl_count[7]++;
      }
      while (n2 <= 287) {
        static_ltree[n2 * 2 + 1] = 8;
        n2++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n2 = 0; n2 < D_CODES; n2++) {
        static_dtree[n2 * 2 + 1] = 5;
        static_dtree[n2 * 2] = bi_reverse(n2, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s2) {
      var n2;
      for (n2 = 0; n2 < L_CODES; n2++) {
        s2.dyn_ltree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < D_CODES; n2++) {
        s2.dyn_dtree[n2 * 2] = 0;
      }
      for (n2 = 0; n2 < BL_CODES; n2++) {
        s2.bl_tree[n2 * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup(s2) {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block(s2, buf, len, header) {
      bi_windup(s2);
      if (header) {
        put_short(s2, len);
        put_short(s2, ~len);
      }
      utils.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller(tree, n2, m, depth) {
      var _n2 = n2 * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
    }
    function pqdownheap(s2, tree, k) {
      var v = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller(tree, v, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v;
    }
    function compress_block(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code(s2, END_BLOCK, ltree);
    }
    function build_tree(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n2, m;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n2 = 0; n2 < elems; n2++) {
        if (tree[n2 * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n2;
          s2.depth[n2] = 0;
        } else {
          tree[n2 * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
        pqdownheap(s2, tree, n2);
      }
      node = elems;
      do {
        n2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n2;
        s2.heap[--s2.heap_max] = m;
        tree[node * 2] = tree[n2 * 2] + tree[m * 2];
        s2.depth[node] = (s2.depth[n2] >= s2.depth[m] ? s2.depth[n2] : s2.depth[m]) + 1;
        tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    }
    function scan_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s2, tree, max_code) {
      var n2;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n2 = 0; n2 <= max_code; n2++) {
        curlen = nextlen;
        nextlen = tree[(n2 + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s2) {
      var max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s2, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s2) {
      var black_mask = 4093624447;
      var n2;
      for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n2 = 32; n2 < LITERALS; n2++) {
        if (s2.dyn_ltree[n2 * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s2) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    }
    function _tr_stored_block(s2, buf, stored_len, last) {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s2, buf, stored_len, true);
    }
    function _tr_align(s2) {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    }
    function _tr_flush_block(s2, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    }
    function _tr_tally(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
      while (len !== 0) {
        n2 = len > 2e3 ? 2e3 : len;
        len -= n2;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n2);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c2, table = [];
      for (var n2 = 0; n2 < 256; n2++) {
        c2 = n2;
        for (var k = 0; k < 8; k++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n2] = c2;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t2 = crcTable, end = pos + len;
      crc ^= -1;
      for (var i3 = pos; i3 < end; i3++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i3]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f2) {
      return (f2 << 1) - (f2 > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only(s2, last) {
      trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    }
    function put_byte(s2, b2) {
      s2.pending_buf[s2.pending++] = b2;
    }
    function putShortMSB(s2, b2) {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window(s2) {
      var _w_size = s2.w_size;
      var p2, n2, m, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n2 = s2.hash_size;
          p2 = n2;
          do {
            m = s2.head[--p2];
            s2.head[p2] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          n2 = _w_size;
          p2 = n2;
          do {
            m = s2.prev[--p2];
            s2.prev[p2] = m >= _w_size ? m - _w_size : 0;
          } while (--n2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n2;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    }
    function deflate_stored(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.last_lit) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s2) {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH;
      trees._tr_init(s2);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap2 = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap2 = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap2;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new utils.Buf8(s2.w_size * 2);
      s2.head = new utils.Buf16(s2.hash_size);
      s2.prev = new utils.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s2;
      var beg, val2;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte(s2, 31);
          put_byte(s2, 139);
          put_byte(s2, 8);
          if (!s2.gzhead) {
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, 0);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, OS_CODE);
            s2.status = BUSY_STATE;
          } else {
            put_byte(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte(s2, s2.gzhead.time & 255);
            put_byte(s2, s2.gzhead.time >> 8 & 255);
            put_byte(s2, s2.gzhead.time >> 16 & 255);
            put_byte(s2, s2.gzhead.time >> 24 & 255);
            put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
            put_byte(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte(s2, s2.gzhead.extra.length & 255);
              put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE;
          putShortMSB(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE;
          }
        } else {
          s2.status = NAME_STATE;
        }
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val2 = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val2 = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val2 = 0;
            }
            put_byte(s2, val2);
          } while (val2 !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val2 === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE;
          }
        } else {
          s2.status = COMMENT_STATE;
        }
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val2 = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val2 = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val2 = 0;
            }
            put_byte(s2, val2);
          } while (val2 !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val2 === 0) {
            s2.status = HCRC_STATE;
          }
        } else {
          s2.status = HCRC_STATE;
        }
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE;
          }
        } else {
          s2.status = BUSY_STATE;
        }
      }
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n2;
      var wrap2;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s2 = strm.state;
      wrap2 = s2.wrap;
      if (wrap2 === 2 || wrap2 === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap2 === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap2 === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils.Buf8(s2.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        str = s2.strstart;
        n2 = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n2);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap2;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf, c2, c22, m_pos, i3, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i3++] = c2;
        } else if (c2 < 2048) {
          buf[i3++] = 192 | c2 >>> 6;
          buf[i3++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i3++] = 224 | c2 >>> 12;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        } else {
          buf[i3++] = 240 | c2 >>> 18;
          buf[i3++] = 128 | c2 >>> 12 & 63;
          buf[i3++] = 128 | c2 >>> 6 & 63;
          buf[i3++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i3 = 0; i3 < len; i3++) {
        result += String.fromCharCode(buf[i3]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i3 = 0, len = buf.length; i3 < len; i3++) {
        buf[i3] = str.charCodeAt(i3);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i3, out, c2, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i3 = 0; i3 < len; ) {
        c2 = buf[i3++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i3 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i3 < len) {
          c2 = c2 << 6 | buf[i3++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap2;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else {
        wrap2 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap2;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy2) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy2 >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy2) {
          dist = copy2;
        }
        utils.arraySet(state.window, src, end - copy2, dist, state.wnext);
        copy2 -= dist;
        if (copy2) {
          utils.arraySet(state.window, src, end - copy2, copy2, 0);
          state.wnext = copy2;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy2;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n2;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy2 = state.length;
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy2,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  state.length -= copy2;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy2, next);
                }
                have -= copy2;
                next += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy2 = state.length;
              if (copy2) {
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2 > left) {
                  copy2 = left;
                }
                if (copy2 === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy2, put);
                have -= copy2;
                next += copy2;
                left -= copy2;
                put += copy2;
                state.length -= copy2;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy2 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy2 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy2 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy2 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy2--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy2 = _out - left;
              if (state.offset > copy2) {
                copy2 = state.offset - copy2;
                if (copy2 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy2 > state.wnext) {
                  copy2 -= state.wnext;
                  from = state.wsize - copy2;
                } else {
                  from = state.wnext - copy2;
                }
                if (copy2 > state.length) {
                  copy2 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy2 = state.length;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              left -= copy2;
              state.length -= copy2;
              do {
                output[put++] = from_source[from++];
              } while (--copy2);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c2 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c2.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c2.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
        if (status === c2.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c2.Z_BUF_ERROR && allowBufError === true) {
          status = c2.Z_OK;
          allowBufError = false;
        }
        if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
      if (status === c2.Z_STREAM_END) {
        _mode = c2.Z_FINISH;
      }
      if (_mode === c2.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c2.Z_OK;
      }
      if (_mode === c2.Z_SYNC_FLUSH) {
        this.onEnd(c2.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c2.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako2 = {};
    assign(pako2, deflate, inflate, constants);
    module.exports = pako2;
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/snappyjs/snappy_decompressor.js
var require_snappy_decompressor = __commonJS({
  "node_modules/snappyjs/snappy_decompressor.js"(exports) {
    "use strict";
    var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
    function copyBytes(fromArray, fromPos, toArray, toPos, length2) {
      var i3;
      for (i3 = 0; i3 < length2; i3++) {
        toArray[toPos + i3] = fromArray[fromPos + i3];
      }
    }
    function selfCopyBytes(array, pos, offset, length2) {
      var i3;
      for (i3 = 0; i3 < length2; i3++) {
        array[pos + i3] = array[pos - offset + i3];
      }
    }
    function SnappyDecompressor(compressed) {
      this.array = compressed;
      this.pos = 0;
    }
    SnappyDecompressor.prototype.readUncompressedLength = function() {
      var result = 0;
      var shift = 0;
      var c2, val2;
      while (shift < 32 && this.pos < this.array.length) {
        c2 = this.array[this.pos];
        this.pos += 1;
        val2 = c2 & 127;
        if (val2 << shift >>> shift !== val2) {
          return -1;
        }
        result |= val2 << shift;
        if (c2 < 128) {
          return result;
        }
        shift += 7;
      }
      return -1;
    };
    SnappyDecompressor.prototype.uncompressToBuffer = function(outBuffer) {
      var array = this.array;
      var arrayLength = array.length;
      var pos = this.pos;
      var outPos = 0;
      var c2, len, smallLen;
      var offset;
      while (pos < array.length) {
        c2 = array[pos];
        pos += 1;
        if ((c2 & 3) === 0) {
          len = (c2 >>> 2) + 1;
          if (len > 60) {
            if (pos + 3 >= arrayLength) {
              return false;
            }
            smallLen = len - 60;
            len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
            len = (len & WORD_MASK[smallLen]) + 1;
            pos += smallLen;
          }
          if (pos + len > arrayLength) {
            return false;
          }
          copyBytes(array, pos, outBuffer, outPos, len);
          pos += len;
          outPos += len;
        } else {
          switch (c2 & 3) {
            case 1:
              len = (c2 >>> 2 & 7) + 4;
              offset = array[pos] + (c2 >>> 5 << 8);
              pos += 1;
              break;
            case 2:
              if (pos + 1 >= arrayLength) {
                return false;
              }
              len = (c2 >>> 2) + 1;
              offset = array[pos] + (array[pos + 1] << 8);
              pos += 2;
              break;
            case 3:
              if (pos + 3 >= arrayLength) {
                return false;
              }
              len = (c2 >>> 2) + 1;
              offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
              pos += 4;
              break;
            default:
              break;
          }
          if (offset === 0 || offset > outPos) {
            return false;
          }
          selfCopyBytes(outBuffer, outPos, offset, len);
          outPos += len;
        }
      }
      return true;
    };
    exports.SnappyDecompressor = SnappyDecompressor;
  }
});

// node_modules/snappyjs/snappy_compressor.js
var require_snappy_compressor = __commonJS({
  "node_modules/snappyjs/snappy_compressor.js"(exports) {
    "use strict";
    var BLOCK_LOG = 16;
    var BLOCK_SIZE = 1 << BLOCK_LOG;
    var MAX_HASH_TABLE_BITS = 14;
    var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
    function hashFunc(key, hashFuncShift) {
      return key * 506832829 >>> hashFuncShift;
    }
    function load32(array, pos) {
      return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
    }
    function equals32(array, pos1, pos2) {
      return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
    }
    function copyBytes(fromArray, fromPos, toArray, toPos, length2) {
      var i3;
      for (i3 = 0; i3 < length2; i3++) {
        toArray[toPos + i3] = fromArray[fromPos + i3];
      }
    }
    function emitLiteral(input, ip, len, output, op) {
      if (len <= 60) {
        output[op] = len - 1 << 2;
        op += 1;
      } else if (len < 256) {
        output[op] = 60 << 2;
        output[op + 1] = len - 1;
        op += 2;
      } else {
        output[op] = 61 << 2;
        output[op + 1] = len - 1 & 255;
        output[op + 2] = len - 1 >>> 8;
        op += 3;
      }
      copyBytes(input, ip, output, op, len);
      return op + len;
    }
    function emitCopyLessThan64(output, op, offset, len) {
      if (len < 12 && offset < 2048) {
        output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
        output[op + 1] = offset & 255;
        return op + 2;
      } else {
        output[op] = 2 + (len - 1 << 2);
        output[op + 1] = offset & 255;
        output[op + 2] = offset >>> 8;
        return op + 3;
      }
    }
    function emitCopy(output, op, offset, len) {
      while (len >= 68) {
        op = emitCopyLessThan64(output, op, offset, 64);
        len -= 64;
      }
      if (len > 64) {
        op = emitCopyLessThan64(output, op, offset, 60);
        len -= 60;
      }
      return emitCopyLessThan64(output, op, offset, len);
    }
    function compressFragment(input, ip, inputSize, output, op) {
      var hashTableBits = 1;
      while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
        hashTableBits += 1;
      }
      hashTableBits -= 1;
      var hashFuncShift = 32 - hashTableBits;
      if (typeof globalHashTables[hashTableBits] === "undefined") {
        globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
      }
      var hashTable = globalHashTables[hashTableBits];
      var i3;
      for (i3 = 0; i3 < hashTable.length; i3++) {
        hashTable[i3] = 0;
      }
      var ipEnd = ip + inputSize;
      var ipLimit;
      var baseIp = ip;
      var nextEmit = ip;
      var hash, nextHash;
      var nextIp, candidate, skip;
      var bytesBetweenHashLookups;
      var base, matched, offset;
      var prevHash, curHash;
      var flag = true;
      var INPUT_MARGIN = 15;
      if (inputSize >= INPUT_MARGIN) {
        ipLimit = ipEnd - INPUT_MARGIN;
        ip += 1;
        nextHash = hashFunc(load32(input, ip), hashFuncShift);
        while (flag) {
          skip = 32;
          nextIp = ip;
          do {
            ip = nextIp;
            hash = nextHash;
            bytesBetweenHashLookups = skip >>> 5;
            skip += 1;
            nextIp = ip + bytesBetweenHashLookups;
            if (ip > ipLimit) {
              flag = false;
              break;
            }
            nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
            candidate = baseIp + hashTable[hash];
            hashTable[hash] = ip - baseIp;
          } while (!equals32(input, ip, candidate));
          if (!flag) {
            break;
          }
          op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);
          do {
            base = ip;
            matched = 4;
            while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
              matched += 1;
            }
            ip += matched;
            offset = base - candidate;
            op = emitCopy(output, op, offset, matched);
            nextEmit = ip;
            if (ip >= ipLimit) {
              flag = false;
              break;
            }
            prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
            hashTable[prevHash] = ip - 1 - baseIp;
            curHash = hashFunc(load32(input, ip), hashFuncShift);
            candidate = baseIp + hashTable[curHash];
            hashTable[curHash] = ip - baseIp;
          } while (equals32(input, ip, candidate));
          if (!flag) {
            break;
          }
          ip += 1;
          nextHash = hashFunc(load32(input, ip), hashFuncShift);
        }
      }
      if (nextEmit < ipEnd) {
        op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
      }
      return op;
    }
    function putVarint(value, output, op) {
      do {
        output[op] = value & 127;
        value = value >>> 7;
        if (value > 0) {
          output[op] += 128;
        }
        op += 1;
      } while (value > 0);
      return op;
    }
    function SnappyCompressor(uncompressed) {
      this.array = uncompressed;
    }
    SnappyCompressor.prototype.maxCompressedLength = function() {
      var sourceLen = this.array.length;
      return 32 + sourceLen + Math.floor(sourceLen / 6);
    };
    SnappyCompressor.prototype.compressToBuffer = function(outBuffer) {
      var array = this.array;
      var length2 = array.length;
      var pos = 0;
      var outPos = 0;
      var fragmentSize;
      outPos = putVarint(length2, outBuffer, outPos);
      while (pos < length2) {
        fragmentSize = Math.min(length2 - pos, BLOCK_SIZE);
        outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
        pos += fragmentSize;
      }
      return outPos;
    };
    exports.SnappyCompressor = SnappyCompressor;
  }
});

// node_modules/snappyjs/index.js
var require_snappyjs = __commonJS({
  "node_modules/snappyjs/index.js"(exports) {
    "use strict";
    function isNode() {
      if (typeof process === "object") {
        if (typeof process.versions === "object") {
          if (typeof process.versions.node !== "undefined") {
            return true;
          }
        }
      }
      return false;
    }
    function isUint8Array(object) {
      return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
    }
    function isArrayBuffer(object) {
      return object instanceof ArrayBuffer;
    }
    function isBuffer(object) {
      if (!isNode()) {
        return false;
      }
      return Buffer.isBuffer(object);
    }
    var SnappyDecompressor = require_snappy_decompressor().SnappyDecompressor;
    var SnappyCompressor = require_snappy_compressor().SnappyCompressor;
    var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
    function uncompress2(compressed) {
      if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer(compressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
      }
      var uint8Mode = false;
      var arrayBufferMode = false;
      if (isUint8Array(compressed)) {
        uint8Mode = true;
      } else if (isArrayBuffer(compressed)) {
        arrayBufferMode = true;
        compressed = new Uint8Array(compressed);
      }
      var decompressor = new SnappyDecompressor(compressed);
      var length2 = decompressor.readUncompressedLength();
      if (length2 === -1) {
        throw new Error("Invalid Snappy bitstream");
      }
      var uncompressed, uncompressedView;
      if (uint8Mode) {
        uncompressed = new Uint8Array(length2);
        if (!decompressor.uncompressToBuffer(uncompressed)) {
          throw new Error("Invalid Snappy bitstream");
        }
      } else if (arrayBufferMode) {
        uncompressed = new ArrayBuffer(length2);
        uncompressedView = new Uint8Array(uncompressed);
        if (!decompressor.uncompressToBuffer(uncompressedView)) {
          throw new Error("Invalid Snappy bitstream");
        }
      } else {
        uncompressed = Buffer.alloc(length2);
        if (!decompressor.uncompressToBuffer(uncompressed)) {
          throw new Error("Invalid Snappy bitstream");
        }
      }
      return uncompressed;
    }
    function compress2(uncompressed) {
      if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer(uncompressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
      }
      var uint8Mode = false;
      var arrayBufferMode = false;
      if (isUint8Array(uncompressed)) {
        uint8Mode = true;
      } else if (isArrayBuffer(uncompressed)) {
        arrayBufferMode = true;
        uncompressed = new Uint8Array(uncompressed);
      }
      var compressor = new SnappyCompressor(uncompressed);
      var maxLength = compressor.maxCompressedLength();
      var compressed, compressedView;
      var length2;
      if (uint8Mode) {
        compressed = new Uint8Array(maxLength);
        length2 = compressor.compressToBuffer(compressed);
      } else if (arrayBufferMode) {
        compressed = new ArrayBuffer(maxLength);
        compressedView = new Uint8Array(compressed);
        length2 = compressor.compressToBuffer(compressedView);
      } else {
        compressed = Buffer.alloc(maxLength);
        length2 = compressor.compressToBuffer(compressed);
      }
      if (!compressed.slice) {
        var compressedArray = new Uint8Array(Array.prototype.slice.call(compressed, 0, length2));
        if (uint8Mode) {
          return compressedArray;
        } else if (arrayBufferMode) {
          return compressedArray.buffer;
        } else {
          throw new Error("Not implemented");
        }
      }
      return compressed.slice(0, length2);
    }
    exports.uncompress = uncompress2;
    exports.compress = compress2;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i3 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s2 = buffer[offset + i3];
      i3 += d;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i3], i3 += d, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i3 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i3] = m & 255, i3 += d, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i3] = e2 & 255, i3 += d, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i3 - d] |= s2 * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
          this.type = val2 & 7;
          readField(tag, result, this);
          if (this.pos === startPos)
            this.skip(val2);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val2 = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      readSFixed32: function() {
        var val2 = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val2;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readSFixed64: function() {
        var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val2;
      },
      readFloat: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val2;
      },
      readDouble: function() {
        var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val2;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val2, b2;
        b2 = buf[this.pos++];
        val2 = b2 & 127;
        if (b2 < 128)
          return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 7;
        if (b2 < 128)
          return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 14;
        if (b2 < 128)
          return val2;
        b2 = buf[this.pos++];
        val2 |= (b2 & 127) << 21;
        if (b2 < 128)
          return val2;
        b2 = buf[this.pos];
        val2 |= (b2 & 15) << 28;
        return readVarintRemainder(val2, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes)
          return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end)
          arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val2) {
        var type = val2 & 7;
        if (type === Pbf.Varint)
          while (this.buf[this.pos++] > 127) {
          }
        else if (type === Pbf.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32)
          this.pos += 4;
        else if (type === Pbf.Fixed64)
          this.pos += 8;
        else
          throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min) {
        var length2 = this.length || 16;
        while (length2 < this.pos + min)
          length2 *= 2;
        if (length2 !== this.length) {
          var buf = new Uint8Array(length2);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length2;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val2) {
        this.realloc(4);
        writeInt32(this.buf, val2, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val2) {
        this.realloc(8);
        writeInt32(this.buf, val2 & -1, this.pos);
        writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val2) {
        val2 = +val2 || 0;
        if (val2 > 268435455 || val2 < 0) {
          writeBigVarint(val2, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
        if (val2 <= 127)
          return;
        this.buf[this.pos++] = val2 >>> 7 & 127;
      },
      writeSVarint: function(val2) {
        this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
      },
      writeBoolean: function(val2) {
        this.writeVarint(Boolean(val2));
      },
      writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeFloat: function(val2) {
        this.realloc(4);
        ieee754.write(this.buf, val2, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val2) {
        this.realloc(8);
        ieee754.write(this.buf, val2, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i3 = 0; i3 < len; i3++)
          this.buf[this.pos++] = buffer[i3];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;
        if (len >= 128)
          makeRoomForExtraLength(startPos, len, this);
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length)
          this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val2);
      },
      writeSFixed32Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val2);
      },
      writeFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val2);
      },
      writeSFixed64Field: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val2);
      },
      writeVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val2);
      },
      writeSVarintField: function(tag, val2) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val2);
      },
      writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
      },
      writeFloatField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val2);
      },
      writeDoubleField: function(tag, val2) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val2);
      },
      writeBooleanField: function(tag, val2) {
        this.writeVarintField(tag, Boolean(val2));
      }
    };
    function readVarintRemainder(l2, s2, p2) {
      var buf = p2.buf, h, b2;
      b2 = buf[p2.pos++];
      h = (b2 & 112) >> 4;
      if (b2 < 128)
        return toNum(l2, h, s2);
      b2 = buf[p2.pos++];
      h |= (b2 & 127) << 3;
      if (b2 < 128)
        return toNum(l2, h, s2);
      b2 = buf[p2.pos++];
      h |= (b2 & 127) << 10;
      if (b2 < 128)
        return toNum(l2, h, s2);
      b2 = buf[p2.pos++];
      h |= (b2 & 127) << 17;
      if (b2 < 128)
        return toNum(l2, h, s2);
      b2 = buf[p2.pos++];
      h |= (b2 & 127) << 24;
      if (b2 < 128)
        return toNum(l2, h, s2);
      b2 = buf[p2.pos++];
      h |= (b2 & 1) << 31;
      if (b2 < 128)
        return toNum(l2, h, s2);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val2, pbf) {
      var low, high;
      if (val2 >= 0) {
        low = val2 % 4294967296 | 0;
        high = val2 / 4294967296 | 0;
      } else {
        low = ~(-val2 % 4294967296);
        high = ~(-val2 / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb2 = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb2 | ((high >>>= 3) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high)
        return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i3 = pbf.pos - 1; i3 >= startPos; i3--)
        pbf.buf[i3 + extraLen] = pbf.buf[i3];
    }
    function writePackedVarint(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeVarint(arr[i3]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSVarint(arr[i3]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFloat(arr[i3]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeDouble(arr[i3]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeBoolean(arr[i3]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFixed32(arr[i3]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSFixed32(arr[i3]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeFixed64(arr[i3]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i3 = 0; i3 < arr.length; i3++)
        pbf.writeSFixed64(arr[i3]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val2, pos) {
      buf[pos] = val2;
      buf[pos + 1] = val2 >>> 8;
      buf[pos + 2] = val2 >>> 16;
      buf[pos + 3] = val2 >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i3 = pos;
      while (i3 < end) {
        var b0 = buf[i3];
        var c2 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i3 + bytesPerSequence > end)
          break;
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c2 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i3 + 1];
          if ((b1 & 192) === 128) {
            c2 = (b0 & 31) << 6 | b1 & 63;
            if (c2 <= 127) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i3 + 1];
          b2 = buf[i3 + 2];
          if ((b1 & 192) === 128 && (b2 & 192) === 128) {
            c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
            if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i3 + 1];
          b2 = buf[i3 + 2];
          b3 = buf[i3 + 3];
          if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
            c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
            if (c2 <= 65535 || c2 >= 1114112) {
              c2 = null;
            }
          }
        }
        if (c2 === null) {
          c2 = 65533;
          bytesPerSequence = 1;
        } else if (c2 > 65535) {
          c2 -= 65536;
          str += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
          c2 = 56320 | c2 & 1023;
        }
        str += String.fromCharCode(c2);
        i3 += bytesPerSequence;
      }
      return str;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str, pos) {
      for (var i3 = 0, c2, lead; i3 < str.length; i3++) {
        c2 = str.charCodeAt(i3);
        if (c2 > 55295 && c2 < 57344) {
          if (lead) {
            if (c2 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c2;
              continue;
            } else {
              c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c2 > 56319 || i3 + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c2;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c2 < 128) {
          buf[pos++] = c2;
        } else {
          if (c2 < 2048) {
            buf[pos++] = c2 >> 6 | 192;
          } else {
            if (c2 < 65536) {
              buf[pos++] = c2 >> 12 | 224;
            } else {
              buf[pos++] = c2 >> 18 | 240;
              buf[pos++] = c2 >> 12 & 63 | 128;
            }
            buf[pos++] = c2 >> 6 & 63 | 128;
          }
          buf[pos++] = c2 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec3 positions;
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
uniform bool greatCircle;
uniform bool useShortestPath;
uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = positions.x;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, positions.y);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (useShortestPath) {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/arc-layer/arc-layer.js
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
  getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
  getWidth: { type: "accessor", value: 1 },
  getHeight: { type: "accessor", value: 1 },
  getTilt: { type: "accessor", value: 0 },
  greatCircle: false,
  numSegments: { type: "number", value: 50, min: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var _ArcLayer = class _ArcLayer extends Layer {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceSourceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getSourceColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getTargetColor",
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: "getHeight",
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: "getTilt",
        defaultValue: 0
      }
    });
  }
  updateState(opts) {
    var _a;
    super.updateState(opts);
    const { props, oldProps, changeFlags } = opts;
    if (changeFlags.extensionsChanged || props.numSegments !== oldProps.numSegments) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      greatCircle,
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const { numSegments } = this.props;
    let positions = [];
    for (let i3 = 0; i3 < numSegments; i3++) {
      positions = positions.concat([i3, 1, 0, i3, -1, 0]);
    }
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
    model.setUniforms({ numSegments });
    return model;
  }
};
_ArcLayer.layerName = "ArcLayer";
_ArcLayer.defaultProps = defaultProps;
var ArcLayer = _ArcLayer;

// node_modules/@deck.gl/layers/dist/bitmap-layer/create-mesh.js
var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  const maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  const maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  const uCount = Math.ceil(maxXSpan / resolution) + 1;
  const vCount = Math.ceil(maxYSpan / resolution) + 1;
  const vertexCount = (uCount - 1) * (vCount - 1) * 6;
  const indices = new Uint32Array(vertexCount);
  const texCoords = new Float32Array(uCount * vCount * 2);
  const positions = new Float64Array(uCount * vCount * 3);
  let vertex = 0;
  let index = 0;
  for (let u = 0; u < uCount; u++) {
    const ut = u / (uCount - 1);
    for (let v = 0; v < vCount; v++) {
      const vt = v / (vCount - 1);
      const p2 = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p2[0];
      positions[vertex * 3 + 1] = p2[1];
      positions[vertex * 3 + 2] = p2[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  const positions = new Float64Array(12);
  for (let i3 = 0; i3 < bounds.length; i3++) {
    positions[i3 * 3 + 0] = bounds[i3][0];
    positions[i3 * 3 + 1] = bounds[i3][1];
    positions[i3 * 3 + 2] = bounds[i3][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
}

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer-fragment.js
var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

// node_modules/@deck.gl/layers/dist/bitmap-layer/bitmap-layer.js
var defaultProps2 = {
  image: { type: "image", value: null, async: true },
  bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
  desaturate: { type: "number", min: 0, max: 1, value: 0 },
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: { type: "color", value: [0, 0, 0, 0] },
  tintColor: { type: "color", value: [255, 255, 255] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var _BitmapLayer = class _BitmapLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default] });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.remove(["instancePickingColors"]);
    const noAlloc = true;
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        update: (attribute) => attribute.value = this.state.mesh.indices,
        noAlloc
      },
      positions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        update: (attribute) => attribute.value = this.state.mesh.positions,
        noAlloc
      },
      texCoords: {
        size: 2,
        update: (attribute) => attribute.value = this.state.mesh.texCoords,
        noAlloc
      }
    });
  }
  updateState({ props, oldProps, changeFlags }) {
    var _a;
    const attributeManager = this.getAttributeManager();
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
    if (props.bounds !== oldProps.bounds) {
      const oldMesh = this.state.mesh;
      const mesh = this._createMesh();
      this.state.model.setVertexCount(mesh.vertexCount);
      for (const key in mesh) {
        if (oldMesh && oldMesh[key] !== mesh[key]) {
          attributeManager.invalidate(key);
        }
      }
      this.setState({ mesh, ...this._getCoordinateUniforms() });
    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
      this.setState(this._getCoordinateUniforms());
    }
  }
  getPickingInfo(params) {
    const { image } = this.props;
    const info = params.info;
    if (!info.color || !image) {
      info.bitmap = null;
      return info;
    }
    const { width, height } = image;
    info.index = 0;
    const uv = unpackUVsFromRGB(info.color);
    info.bitmap = {
      size: { width, height },
      uv,
      pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
    };
    return info;
  }
  // Override base Layer multi-depth picking logic
  disablePickingIndex() {
    this.setState({ disablePicking: true });
  }
  restorePickingColors() {
    this.setState({ disablePicking: false });
  }
  _updateAutoHighlight(info) {
    super._updateAutoHighlight({
      ...info,
      color: this.encodePickingColor(0)
    });
  }
  _createMesh() {
    const { bounds } = this.props;
    let normalizedBounds = bounds;
    if (isRectangularBounds(bounds)) {
      normalizedBounds = [
        [bounds[0], bounds[1]],
        [bounds[0], bounds[3]],
        [bounds[2], bounds[3]],
        [bounds[2], bounds[1]]
      ];
    }
    return createMesh(normalizedBounds, this.context.viewport.resolution);
  }
  _getModel() {
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      topology: "triangle-list",
      isInstanced: false
    });
  }
  draw(opts) {
    const { uniforms, moduleParameters } = opts;
    const { model, coordinateConversion, bounds, disablePicking } = this.state;
    const { image, desaturate, transparentColor, tintColor } = this.props;
    if (moduleParameters.picking.isActive && disablePicking) {
      return;
    }
    if (image && model) {
      model.setUniforms(uniforms);
      model.setBindings({ bitmapTexture: image });
      model.setUniforms({
        desaturate,
        transparentColor: transparentColor.map((x2) => x2 / 255),
        tintColor: tintColor.slice(0, 3).map((x2) => x2 / 255),
        coordinateConversion,
        bounds
      });
      model.draw(this.context.renderPass);
    }
  }
  _getCoordinateUniforms() {
    const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
    let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
    if (imageCoordinateSystem !== DEFAULT) {
      const { bounds } = this.props;
      if (!isRectangularBounds(bounds)) {
        throw new Error("_imageCoordinateSystem only supports rectangular bounds");
      }
      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
        return { coordinateConversion: -1, bounds };
      }
      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
        const topRight = lngLatToWorld([bounds[2], bounds[3]]);
        return {
          coordinateConversion: 1,
          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
        };
      }
    }
    return {
      coordinateConversion: 0,
      bounds: [0, 0, 0, 0]
    };
  }
};
_BitmapLayer.layerName = "BitmapLayer";
_BitmapLayer.defaultProps = defaultProps2;
var BitmapLayer = _BitmapLayer;
function unpackUVsFromRGB(color) {
  const [u, v, fracUV] = color;
  const vFrac = (fracUV & 240) / 256;
  const uFrac = (fracUV & 15) / 16;
  return [(u + uFrac) / 256, (v + vFrac) / 256];
}
function isRectangularBounds(bounds) {
  return Number.isFinite(bounds[0]);
}

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * opacity * vColor.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/icon-layer/icon-manager.js
var DEFAULT_CANVAS_WIDTH = 1024;
var DEFAULT_BUFFER = 4;
var noop = () => {
};
var DEFAULT_SAMPLER_PARAMETERS = {
  minFilter: "linear",
  mipmapFilter: "linear",
  // LINEAR is the default value but explicitly set it here
  magFilter: "linear",
  // minimize texture boundary artifacts
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
};
var MISSING_ICON = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, maxWidth, maxHeight) {
  const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
  const width = Math.floor(imageData.width * resizeRatio);
  const height = Math.floor(imageData.height * resizeRatio);
  if (resizeRatio === 1) {
    return { data: imageData, width, height };
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return { data: ctx.canvas, width, height };
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(texture, width, height, sampler) {
  const { width: oldWidth, height: oldHeight, device } = texture;
  const newTexture = device.createTexture({ format: "rgba8unorm", width, height, sampler });
  const commandEncoder = device.createCommandEncoder();
  commandEncoder.copyTextureToTexture({
    source: texture,
    destination: newTexture,
    width: oldWidth,
    height: oldHeight
  });
  commandEncoder.finish();
  texture.destroy();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (let i3 = 0; i3 < columns.length; i3++) {
    const { icon, xOffset } = columns[i3];
    const id = getIconId(icon);
    mapping[id] = {
      ...icon,
      x: xOffset,
      y: yOffset
    };
  }
}
function buildMapping({ icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, rowHeight = 0, canvasWidth }) {
  let columns = [];
  for (let i3 = 0; i3 < icons.length; i3++) {
    const icon = icons[i3];
    const id = getIconId(icon);
    if (!mapping[id]) {
      const { height, width } = icon;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  const icons = {};
  const { iterable, objectInfo } = createIterable(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);
    if (!icon) {
      throw new Error("Icon is missing.");
    }
    if (!icon.url) {
      throw new Error("Icon url is missing.");
    }
    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
    }
  }
  return icons;
}
var IconManager = class {
  constructor(device, { onUpdate = noop, onError = noop }) {
    this._loadOptions = null;
    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};
    this._textureParameters = null;
    this._pendingCount = 0;
    this._autoPacking = false;
    this._xOffset = 0;
    this._yOffset = 0;
    this._rowHeight = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
    this.device = device;
    this.onUpdate = onUpdate;
    this.onError = onError;
  }
  finalize() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.delete();
  }
  getTexture() {
    return this._texture || this._externalTexture;
  }
  getIconMapping(icon) {
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || MISSING_ICON;
  }
  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, textureParameters }) {
    var _a;
    if (loadOptions) {
      this._loadOptions = loadOptions;
    }
    if (autoPacking !== void 0) {
      this._autoPacking = autoPacking;
    }
    if (iconMapping) {
      this._mapping = iconMapping;
    }
    if (iconAtlas) {
      (_a = this._texture) == null ? void 0 : _a.delete();
      this._texture = null;
      this._externalTexture = iconAtlas;
    }
    if (textureParameters) {
      this._textureParameters = textureParameters;
    }
  }
  get isLoaded() {
    return this._pendingCount === 0;
  }
  packIcons(data, getIcon) {
    if (!this._autoPacking || typeof document === "undefined") {
      return;
    }
    const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
    if (icons.length > 0) {
      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        rowHeight: this._rowHeight,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });
      this._rowHeight = rowHeight;
      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;
      if (!this._texture) {
        this._texture = this.device.createTexture({
          format: "rgba8unorm",
          width: this._canvasWidth,
          height: this._canvasHeight,
          sampler: this._textureParameters || DEFAULT_SAMPLER_PARAMETERS
        });
      }
      if (this._texture.height !== this._canvasHeight) {
        this._texture = resizeTexture(this._texture, this._canvasWidth, this._canvasHeight, this._textureParameters || DEFAULT_SAMPLER_PARAMETERS);
      }
      this.onUpdate();
      this._canvas = this._canvas || document.createElement("canvas");
      this._loadIcons(icons);
    }
  }
  _loadIcons(icons) {
    const ctx = this._canvas.getContext("2d", {
      willReadFrequently: true
    });
    for (const icon of icons) {
      this._pendingCount++;
      load(icon.url, this._loadOptions).then((imageData) => {
        const id = getIconId(icon);
        const iconDef = this._mapping[id];
        const { x: x2, y: y2, width: maxWidth, height: maxHeight } = iconDef;
        const { data, width, height } = resizeImage(ctx, imageData, maxWidth, maxHeight);
        this._texture.setSubImageData({
          data,
          x: x2 + (maxWidth - width) / 2,
          y: y2 + (maxHeight - height) / 2,
          width,
          height
        });
        iconDef.width = width;
        iconDef.height = height;
        this._texture.generateMipmap();
        this.onUpdate();
      }).catch((error) => {
        this.onError({
          url: icon.url,
          source: icon.source,
          sourceIndex: icon.sourceIndex,
          loadOptions: this._loadOptions,
          error
        });
      }).finally(() => {
        this._pendingCount--;
      });
    }
  }
};

// node_modules/@deck.gl/layers/dist/icon-layer/icon-layer.js
var DEFAULT_COLOR2 = [0, 0, 0, 255];
var defaultProps3 = {
  iconAtlas: { type: "image", value: null, async: true },
  iconMapping: { type: "object", value: {}, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  billboard: true,
  sizeUnits: "pixels",
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getIcon: { type: "accessor", value: (x2) => x2.icon },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  onIconError: { type: "function", value: null, optional: true },
  textureParameters: { type: "object", ignore: true, value: null }
};
var _IconLayer = class _IconLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  initializeState() {
    this.state = {
      iconManager: new IconManager(this.context.device, {
        onUpdate: this._onUpdate.bind(this),
        onError: this._onError.bind(this)
      })
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceOffsets: {
        size: 2,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceOffset
      },
      instanceIconFrames: {
        size: 4,
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceIconFrame
      },
      instanceColorModes: {
        size: 1,
        type: "uint8",
        accessor: "getIcon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        transform: this.getInstanceColorMode
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR2
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      }
    });
  }
  /* eslint-disable max-statements, complexity */
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
    const { iconManager } = this.state;
    if (typeof iconAtlas === "string") {
      return;
    }
    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
    iconManager.setProps({
      loadOptions: props.loadOptions,
      autoPacking: !prePacked,
      iconAtlas,
      iconMapping: prePacked ? iconMapping : null,
      textureParameters
    });
    if (prePacked) {
      if (oldProps.iconMapping !== props.iconMapping) {
        attributeManager.invalidate("getIcon");
      }
    } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
      iconManager.packIcons(data, getIcon);
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */
  get isLoaded() {
    return super.isLoaded && this.state.iconManager.isLoaded;
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.iconManager.finalize();
  }
  draw({ uniforms }) {
    const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
    const { iconManager } = this.state;
    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      const model = this.state.model;
      model.setBindings({ iconsTexture });
      model.setUniforms(uniforms);
      model.setUniforms({
        iconsTextureDim: [iconsTexture.width, iconsTexture.height],
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels,
        billboard,
        alphaCutoff
      });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          // The size must be explicitly passed here otherwise luma.gl
          // will default to assuming that positions are 3D (x,y,z)
          positions: {
            size: 2,
            value: new Float32Array(positions)
          }
        }
      }),
      isInstanced: true
    });
  }
  _onUpdate() {
    this.setNeedsRedraw();
  }
  _onError(evt) {
    var _a;
    const onIconError = (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onIconError;
    if (onIconError) {
      onIconError(evt);
    } else {
      log_default.error(evt.error.message)();
    }
  }
  getInstanceOffset(icon) {
    const { width, height, anchorX = width / 2, anchorY = height / 2 } = this.state.iconManager.getIconMapping(icon);
    return [width / 2 - anchorX, height / 2 - anchorY];
  }
  getInstanceColorMode(icon) {
    const mapping = this.state.iconManager.getIconMapping(icon);
    return mapping.mask ? 1 : 0;
  }
  getInstanceIconFrame(icon) {
    const { x: x2, y: y2, width, height } = this.state.iconManager.getIconMapping(icon);
    return [x2, y2, width, height];
  }
};
_IconLayer.defaultProps = defaultProps3;
_IconLayer.layerName = "IconLayer";
var IconLayer = _IconLayer;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float useShortestPath;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (useShortestPath > 0.5 || useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * useShortestPath > 180.) {
source_world.x += 360. * useShortestPath;
source_world = splitLine(source_world, target_world, 180. * useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * useShortestPath < -180.) {
target_world.x += 360. * useShortestPath;
target_world = splitLine(source_world, target_world, 180. * useShortestPath);
target_world_64low = vec3(0.0);
} else if (useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/line-layer/line-layer.js
var DEFAULT_COLOR3 = [0, 0, 0, 255];
var defaultProps4 = {
  getSourcePosition: { type: "accessor", value: (x2) => x2.sourcePosition },
  getTargetPosition: { type: "accessor", value: (x2) => x2.targetPosition },
  getColor: { type: "accessor", value: DEFAULT_COLOR3 },
  getWidth: { type: "accessor", value: 1 },
  widthUnits: "pixels",
  widthScale: { type: "number", value: 1, min: 0 },
  widthMinPixels: { type: "number", value: 0, min: 0 },
  widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
};
var _LineLayer = class _LineLayer extends Layer {
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds([
      "instanceSourcePositions",
      "instanceTargetPositions"
    ]);
  }
  getShaders() {
    return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  // This layer has its own wrapLongitude logic
  get wrapLongitude() {
    return false;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getSourcePosition"
      },
      instanceTargetPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getTargetPosition"
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: "getWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      widthUnits: UNIT[widthUnits],
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      useShortestPath: wrapLongitude ? 1 : 0
    });
    model.draw(this.context.renderPass);
    if (wrapLongitude) {
      model.setUniforms({
        useShortestPath: -1
      });
      model.draw(this.context.renderPass);
    }
  }
  _getModel() {
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
_LineLayer.layerName = "LineLayer";
_LineLayer.defaultProps = defaultProps4;
var LineLayer = _LineLayer;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/point-cloud-layer/point-cloud-layer.js
var DEFAULT_COLOR4 = [0, 0, 0, 255];
var DEFAULT_NORMAL = [0, 0, 1];
var defaultProps5 = {
  sizeUnits: "pixels",
  pointSize: { type: "number", min: 0, value: 10 },
  //  point radius in pixels
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getNormal: { type: "accessor", value: DEFAULT_NORMAL },
  getColor: { type: "accessor", value: DEFAULT_COLOR4 },
  material: true,
  // Depreated
  radiusPixels: { deprecatedFor: "pointSize" }
};
function normalizeData(data) {
  const { header, attributes } = data;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    const { size, value } = attributes.COLOR_0;
    attributes.instanceColors = { size, type: "unorm8", value };
  }
}
var _PointCloudLayer = class _PointCloudLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: point_cloud_layer_vertex_glsl_default, fs: point_cloud_layer_fragment_glsl_default, modules: [project32_default, gouraudLighting, picking_default] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: "getNormal",
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR4
      }
    });
  }
  updateState(params) {
    var _a;
    const { changeFlags, props } = params;
    super.updateState(params);
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
    if (changeFlags.dataChanged) {
      normalizeData(props.data);
    }
  }
  draw({ uniforms }) {
    const { pointSize, sizeUnits } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      sizeUnits: UNIT[sizeUnits],
      radiusPixels: pointSize
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [];
    for (let i3 = 0; i3 < 3; i3++) {
      const angle = i3 / 3 * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(positions)
        }
      }),
      isInstanced: true
    });
  }
};
_PointCloudLayer.layerName = "PointCloudLayer";
_PointCloudLayer.defaultProps = defaultProps5;
var PointCloudLayer = _PointCloudLayer;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
radiusMinPixels, radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
lineWidthMinPixels, lineWidthMaxPixels
);
outerRadiusPixels += stroked * lineWidthPixels / 2.0;
float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
if (billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
uniform bool filled;
uniform float stroked;
uniform bool antialiasing;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (stroked > 0.5) {
float isLine = antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (filled) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (!filled) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5 = [0, 0, 0, 255];
var defaultProps6 = {
  radiusUnits: "meters",
  radiusScale: { type: "number", min: 0, value: 1 },
  radiusMinPixels: { type: "number", min: 0, value: 0 },
  //  min point radius in pixels
  radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  // max point radius in pixels
  lineWidthUnits: "meters",
  lineWidthScale: { type: "number", min: 0, value: 1 },
  lineWidthMinPixels: { type: "number", min: 0, value: 0 },
  lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  stroked: false,
  filled: true,
  billboard: false,
  antialiasing: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getRadius: { type: "accessor", value: 1 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
  getLineWidth: { type: "accessor", value: 1 },
  // deprecated
  strokeWidth: { deprecatedFor: "getLineWidth" },
  outline: { deprecatedFor: "stroked" },
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var _ScatterplotLayer = class _ScatterplotLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: scatterplot_layer_vertex_glsl_default, fs: scatterplot_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: "getRadius",
        defaultValue: 1
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    if (params.changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      stroked: stroked ? 1 : 0,
      filled,
      billboard,
      antialiasing,
      radiusUnits: UNIT[radiusUnits],
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      lineWidthUnits: UNIT[lineWidthUnits],
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-strip",
        attributes: {
          positions: { size: 3, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
_ScatterplotLayer.defaultProps = defaultProps6;
_ScatterplotLayer.layerName = "ScatterplotLayer";
var ScatterplotLayer = _ScatterplotLayer;

// node_modules/@math.gl/polygon/dist/polygon-utils.js
var WINDING = {
  CLOCKWISE: 1,
  COUNTER_CLOCKWISE: -1
};
function modifyPolygonWindingDirection(points, direction, options = {}) {
  const windingDirection = getPolygonWindingDirection(points, options);
  if (windingDirection !== direction) {
    reversePolygon(points, options);
    return true;
  }
  return false;
}
function getPolygonWindingDirection(points, options = {}) {
  return Math.sign(getPolygonSignedArea(points, options));
}
var DimIndex = {
  x: 0,
  y: 1,
  z: 2
};
function getPolygonSignedArea(points, options = {}) {
  const { start = 0, end = points.length, plane = "xy" } = options;
  const dim = options.size || 2;
  let area2 = 0;
  const i0 = DimIndex[plane[0]];
  const i1 = DimIndex[plane[1]];
  for (let i3 = start, j = end - dim; i3 < end; i3 += dim) {
    area2 += (points[i3 + i0] - points[j + i0]) * (points[i3 + i1] + points[j + i1]);
    j = i3;
  }
  return area2 / 2;
}
function reversePolygon(points, options) {
  const { start = 0, end = points.length, size = 2 } = options;
  const numPoints = (end - start) / size;
  const numSwaps = Math.floor(numPoints / 2);
  for (let i3 = 0; i3 < numSwaps; ++i3) {
    const b1 = start + i3 * size;
    const b2 = start + (numPoints - 1 - i3) * size;
    for (let j = 0; j < size; ++j) {
      const tmp = points[b1 + j];
      points[b1 + j] = points[b2 + j];
      points[b2 + j] = tmp;
    }
  }
}

// node_modules/@math.gl/polygon/dist/earcut.js
function earcut(positions, holeIndices, dim = 2, areas, plane = "xy") {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  let invSize;
  let maxX;
  let maxY;
  let minX;
  let minY;
  let x2;
  let y2;
  if (hasHoles)
    outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
  if (positions.length > 80 * dim) {
    minX = maxX = positions[0];
    minY = maxY = positions[1];
    for (let i3 = dim; i3 < outerLen; i3 += dim) {
      x2 = positions[i3];
      y2 = positions[i3 + 1];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise, area2, plane) {
  let i3;
  let last;
  if (area2 === void 0) {
    area2 = getPolygonSignedArea(data, { start, end, size: dim, plane });
  }
  let i0 = DimIndex[plane[0]];
  let i1 = DimIndex[plane[1]];
  if (clockwise === area2 < 0) {
    for (i3 = start; i3 < end; i3 += dim)
      last = insertNode(i3, data[i3 + i0], data[i3 + i1], last);
  } else {
    for (i3 = end - dim; i3 >= start; i3 -= dim)
      last = insertNode(i3, data[i3 + i0], data[i3 + i1], last);
  }
  if (last && equals2(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start;
  let again;
  do {
    again = false;
    if (!p2.steiner && (equals2(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  let prev;
  let next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a3 = ear.prev;
  const b2 = ear;
  const c2 = ear.next;
  if (area(a3, b2, c2) >= 0)
    return false;
  const ax = a3.x;
  const bx = b2.x;
  const cx = c2.x;
  const ay = a3.y;
  const by = b2.y;
  const cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p2 = c2.next;
  while (p2 !== a3) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a3 = ear.prev;
  const b2 = ear;
  const c2 = ear.next;
  if (area(a3, b2, c2) >= 0)
    return false;
  const ax = a3.x;
  const bx = b2.x;
  const cx = c2.x;
  const ay = a3.y;
  const by = b2.y;
  const cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
  const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
  const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
  const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize);
  const maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p2 = ear.prevZ;
  let n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a3 = p2.prev;
    const b2 = p2.next.next;
    if (!equals2(a3, b2) && intersects(a3, p2, p2.next, b2) && locallyInside(a3, b2) && locallyInside(b2, a3)) {
      triangles.push(a3.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a3 = start;
  do {
    let b2 = a3.next.next;
    while (b2 !== a3.prev) {
      if (a3.i !== b2.i && isValidDiagonal(a3, b2)) {
        let c2 = splitPolygon(a3, b2);
        a3 = filterPoints(a3, a3.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a3, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a3 = a3.next;
  } while (a3 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
  const queue = [];
  let i3;
  let len;
  let start;
  let end;
  let list;
  for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
    start = holeIndices[i3] * dim;
    end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false, areas && areas[i3 + 1], plane);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i3 = 0; i3 < queue.length; i3++) {
    outerNode = eliminateHole(queue[i3], outerNode);
  }
  return outerNode;
}
function compareX(a3, b2) {
  return a3.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx)
          return m;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m)
    return null;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  let tan;
  p2 = m;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
        m = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m;
}
function sectorContainsSector(m, p2) {
  return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let e2;
  let i3;
  let inSize = 1;
  let numMerges;
  let p2;
  let pSize;
  let q;
  let qSize;
  let tail;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q = p2;
      pSize = 0;
      for (i3 = 0; i3 < inSize; i3++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start;
  let leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a3, b2) {
  return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon(a3, b2) && // dones't intersect other edges
  (locallyInside(a3, b2) && locallyInside(b2, a3) && middleInside(a3, b2) && // locally visible
  (area(a3.prev, a3, b2.prev) || area(a3, b2.prev, b2)) || // does not create opposite-facing sectors
  equals2(a3, b2) && area(a3.prev, a3, a3.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals2(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a3, b2) {
  let p2 = a3;
  do {
    if (p2.i !== a3.i && p2.next.i !== a3.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a3, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a3);
  return false;
}
function locallyInside(a3, b2) {
  return area(a3.prev, a3, a3.next) < 0 ? area(a3, b2, a3.next) >= 0 && area(a3, a3.prev, b2) >= 0 : area(a3, b2, a3.prev) < 0 || area(a3, a3.next, b2) < 0;
}
function middleInside(a3, b2) {
  let p2 = a3;
  let inside = false;
  const px = (a3.x + b2.x) / 2;
  const py = (a3.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a3);
  return inside;
}
function splitPolygon(a3, b2) {
  const a22 = new Vertex(a3.i, a3.x, a3.y);
  const b22 = new Vertex(b2.i, b2.x, b2.y);
  const an = a3.next;
  const bp = b2.prev;
  a3.next = b2;
  b2.prev = a3;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i3, x2, y2, last) {
  const p2 = new Vertex(i3, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
var Vertex = class {
  constructor(i3, x2, y2) {
    this.prev = null;
    this.next = null;
    this.z = 0;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
    this.i = i3;
    this.x = x2;
    this.y = y2;
  }
};

// node_modules/@math.gl/polygon/dist/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i3 = 0; i3 < size; i3++) {
      if (target[startIndex - size + i3] !== source[i3]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i3 = 0; i3 < size; i3++) {
    target[startIndex + i3] = source[i3];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i3 = 0; i3 < size; i3++) {
    target[i3] = source[i3];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i3 = 0; i3 < size; i3++) {
    out[i3] = positions[startI + i3];
  }
  return out;
}

// node_modules/@math.gl/polygon/dist/lineclip.js
function intersect(a3, b2, edge, bbox, out = []) {
  let t2;
  let snap;
  if (edge & 8) {
    t2 = (bbox[3] - a3[1]) / (b2[1] - a3[1]);
    snap = 3;
  } else if (edge & 4) {
    t2 = (bbox[1] - a3[1]) / (b2[1] - a3[1]);
    snap = 1;
  } else if (edge & 2) {
    t2 = (bbox[2] - a3[0]) / (b2[0] - a3[0]);
    snap = 2;
  } else if (edge & 1) {
    t2 = (bbox[0] - a3[0]) / (b2[0] - a3[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i3 = 0; i3 < a3.length; i3++) {
    out[i3] = (snap & 1) === i3 ? bbox[snap] : t2 * (b2[i3] - a3[i3]) + a3[i3];
  }
  return out;
}
function bitCode(p2, bbox) {
  let code = 0;
  if (p2[0] < bbox[0])
    code |= 1;
  else if (p2[0] > bbox[2])
    code |= 2;
  if (p2[1] < bbox[1])
    code |= 4;
  else if (p2[1] > bbox[3])
    code |= 8;
  return code;
}

// node_modules/@math.gl/polygon/dist/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a3 = getPointAtIndex(positions, 0, size, startIndex);
  let b2;
  let codeB;
  const cell = getGridCell(a3, gridResolution, gridOffset, []);
  const scratchPoint2 = [];
  push(part, a3);
  for (let i3 = 1; i3 < numPoints; i3++) {
    b2 = getPointAtIndex(positions, i3, size, startIndex, b2);
    codeB = bitCode(b2, cell);
    while (codeB) {
      intersect(a3, b2, codeB, cell, scratchPoint2);
      const codeAlt = bitCode(scratchPoint2, cell);
      if (codeAlt) {
        intersect(a3, scratchPoint2, codeAlt, cell, scratchPoint2);
        codeB = codeAlt;
      }
      push(part, scratchPoint2);
      copy(a3, scratchPoint2);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a3);
      }
      codeB = bitCode(b2, cell);
    }
    push(part, b2);
    copy(a3, b2);
  }
  return broken ? result : result[0];
}
var TYPE_INSIDE = 0;
var TYPE_BORDER = 1;
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
  const result = [];
  const queue = [
    {
      pos: positions,
      types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
      holes: holeIndices || []
    }
  ];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const { pos, types, holes } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
      const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
      queue.push(polygonLow, polygonHigh);
      for (let i3 = 0; i3 < holes.length; i3++) {
        parts = bisectPolygon(pos, types, size, holes[i3], holes[i3 + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = { positions: pos };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint2 = [];
  let p2;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i3 = 0; i3 < numPoints; i3++) {
    p2 = getPointAtIndex(positions, i3, size, startIndex, p2);
    side = Math.sign(edge & 8 ? p2[1] - bbox[3] : p2[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i3];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p2, edge, bbox, scratchPoint2);
      push(resultLow, scratchPoint2) && typesLow.push(prevType);
      push(resultHigh, scratchPoint2) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p2) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p2) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p2);
    prevSide = side;
    prevType = type;
  }
  return [
    lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
    highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
  ];
}
function getGridCell(p2, gridResolution, gridOffset, out) {
  const left = Math.floor((p2[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p2[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i3 = 0; i3 < endIndex; i3 += size) {
    const x2 = positions[i3];
    const y2 = positions[i3 + 1];
    minX = x2 < minX ? x2 : minX;
    maxX = x2 > maxX ? x2 : maxX;
    minY = y2 < minY ? y2 : minY;
    maxY = y2 > maxY ? y2 : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
function concatInPlace(arr1, arr2) {
  for (let i3 = 0; i3 < arr2.length; i3++) {
    arr1.push(arr2[i3]);
  }
  return arr1;
}

// node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
var DEFAULT_MAX_LATITUDE = 85.051129;
function cutPolylineByMercatorBounds(positions, options) {
  const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize2 = true } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const { size = 2, normalize: normalize2 = true, edgeTypes = false } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i3 = splitIndex; i3 < srcEndIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    for (let i3 = srcStartIndex; i3 < splitIndex; i3++) {
      newPositions[targetIndex++] = positions[i3];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options == null ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i3 = startIndex + 1; i3 < endIndex; i3 += size) {
    const lat = Math.abs(positions[i3]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i3 - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p2 = getPointAtIndex(positions, 0, size, startIndex);
    p2[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p2);
    p2[1] = Math.sign(p2[1]) * maxLatitude;
    push(positions, p2);
    p2[0] = firstLng;
    push(positions, p2);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i3 = startIndex; i3 < endIndex; i3 += size) {
    lng = positions[i3];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i3] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i3 = 0; i3 < pointCount; i3++) {
    refLng = positions[i3 * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i3 = 0; i3 < pointCount; i3++) {
    positions[i3 * size] += delta;
  }
}

// node_modules/@deck.gl/layers/dist/column-layer/column-geometry.js
var ColumnGeometry = class extends Geometry {
  constructor(props) {
    const { indices, attributes } = tesselateColumn(props);
    super({
      ...props,
      indices,
      // @ts-expect-error
      attributes
    });
  }
};
function tesselateColumn(props) {
  const { radius, height = 1, nradial = 10 } = props;
  let { vertices } = props;
  if (vertices) {
    log_default.assert(vertices.length >= nradial);
    vertices = vertices.flatMap((v) => [v[0], v[1]]);
    modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
  }
  const isExtruded = height > 0;
  const vertsAroundEdge = nradial + 1;
  const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
  const stepAngle = Math.PI * 2 / nradial;
  const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  let i3 = 0;
  if (isExtruded) {
    for (let j = 0; j < vertsAroundEdge; j++) {
      const a3 = j * stepAngle;
      const vertexIndex = j % nradial;
      const sin = Math.sin(a3);
      const cos = Math.cos(a3);
      for (let k = 0; k < 2; k++) {
        positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
        positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
        positions[i3 + 2] = (1 / 2 - k) * height;
        normals[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos;
        normals[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin;
        i3 += 3;
      }
    }
    positions[i3 + 0] = positions[i3 - 3];
    positions[i3 + 1] = positions[i3 - 2];
    positions[i3 + 2] = positions[i3 - 1];
    i3 += 3;
  }
  for (let j = isExtruded ? 0 : 1; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign(0.5 - j % 2);
    const a3 = v * stepAngle;
    const vertexIndex = (v + nradial) % nradial;
    const sin = Math.sin(a3);
    const cos = Math.cos(a3);
    positions[i3 + 0] = vertices ? vertices[vertexIndex * 2] : cos * radius;
    positions[i3 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin * radius;
    positions[i3 + 2] = height / 2;
    normals[i3 + 2] = 1;
    i3 += 3;
  }
  if (isExtruded) {
    let index = 0;
    for (let j = 0; j < nradial; j++) {
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 2;
      indices[index++] = j * 2 + 0;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 1;
      indices[index++] = j * 2 + 3;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: { size: 3, value: positions },
      NORMAL: { size: 3, value: normals }
    }
  };
}

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int radiusUnits;
uniform int widthUnits;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
} else if (stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
if (isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = radius * coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;
if (radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded && !isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
uniform vec3 project_uCameraPosition;
uniform bool extruded;
uniform bool isStroke;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
#ifdef FLAT_SHADING
if (extruded && !isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/column-layer/column-layer.js
var DEFAULT_COLOR6 = [0, 0, 0, 255];
var defaultProps7 = {
  diskResolution: { type: "number", min: 4, value: 20 },
  vertices: null,
  radius: { type: "number", min: 0, value: 1e3 },
  angle: { type: "number", value: 0 },
  offset: { type: "array", value: [0, 0] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  elevationScale: { type: "number", min: 0, value: 1 },
  radiusUnits: "meters",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  extruded: true,
  wireframe: false,
  filled: true,
  stroked: false,
  flatShading: false,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
  getLineWidth: { type: "accessor", value: 1 },
  getElevation: { type: "accessor", value: 1e3 },
  material: true,
  getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
};
var _ColumnLayer = class _ColumnLayer extends Layer {
  getShaders() {
    const defines = {};
    const { flatShading } = this.props;
    if (flatShading) {
      defines.FLAT_SHADING = 1;
    }
    return super.getShaders({
      vs: column_layer_vertex_glsl_default,
      fs: column_layer_fragment_glsl_default,
      defines,
      modules: [project32_default, flatShading ? phongLighting : gouraudLighting, picking_default]
    });
  }
  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR6
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getLineWidth",
        transition: true
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      this.getAttributeManager().invalidateAll();
    }
    const instanceCount = this.getNumInstances();
    this.state.fillModel.setInstanceCount(instanceCount);
    this.state.wireframeModel.setInstanceCount(instanceCount);
    if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
      this._updateGeometry(props);
    }
  }
  getGeometry(diskResolution, vertices, hasThinkness) {
    const geometry = new ColumnGeometry({
      radius: 1,
      height: hasThinkness ? 2 : 0,
      vertices,
      nradial: diskResolution
    });
    let meanVertexDistance = 0;
    if (vertices) {
      for (let i3 = 0; i3 < diskResolution; i3++) {
        const p2 = vertices[i3];
        const d = Math.sqrt(p2[0] * p2[0] + p2[1] * p2[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });
    return geometry;
  }
  _getModels() {
    const shaders = this.getShaders();
    const bufferLayout = this.getAttributeManager().getBufferLayouts();
    const fillModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-fill`,
      bufferLayout,
      isInstanced: true
    });
    const wireframeModel = new Model(this.context.device, {
      ...shaders,
      id: `${this.props.id}-wireframe`,
      bufferLayout,
      isInstanced: true
    });
    return {
      fillModel,
      wireframeModel,
      models: [wireframeModel, fillModel]
    };
  }
  _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
    const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3
    });
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    fillModel.setGeometry(geometry);
    fillModel.setTopology("triangle-strip");
    fillModel.setIndexBuffer(null);
    wireframeModel.setGeometry(geometry);
    wireframeModel.setTopology("line-list");
  }
  draw({ uniforms }) {
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle } = this.props;
    const fillModel = this.state.fillModel;
    const wireframeModel = this.state.wireframeModel;
    const { fillVertexCount, edgeDistance } = this.state;
    const renderUniforms = {
      ...uniforms,
      radius,
      angle: angle / 180 * Math.PI,
      offset,
      extruded,
      stroked,
      coverage,
      elevationScale,
      edgeDistance,
      radiusUnits: UNIT[radiusUnits],
      widthUnits: UNIT[lineWidthUnits],
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels
    };
    if (extruded && wireframe) {
      wireframeModel.setUniforms(renderUniforms);
      wireframeModel.setUniforms({ isStroke: true });
      wireframeModel.draw(this.context.renderPass);
    }
    fillModel.setUniforms(renderUniforms);
    if (filled) {
      fillModel.setVertexCount(fillVertexCount);
      fillModel.setUniforms({ isStroke: false });
      fillModel.draw(this.context.renderPass);
    }
    if (!extruded && stroked) {
      fillModel.setVertexCount(fillVertexCount * 2 / 3);
      fillModel.setUniforms({ isStroke: true });
      fillModel.draw(this.context.renderPass);
    }
  }
};
_ColumnLayer.layerName = "ColumnLayer";
_ColumnLayer.defaultProps = defaultProps7;
var ColumnLayer = _ColumnLayer;

// node_modules/@deck.gl/layers/dist/column-layer/grid-cell-layer.js
var defaultProps8 = {
  cellSize: { type: "number", min: 0, value: 1e3 },
  offset: { type: "array", value: [1, 1] }
};
var _GridCellLayer = class _GridCellLayer extends ColumnLayer {
  _updateGeometry() {
    const geometry = new CubeGeometry();
    this.state.fillModel.setGeometry(geometry);
  }
  draw({ uniforms }) {
    const { elevationScale, extruded, offset, coverage, cellSize, angle, radiusUnits } = this.props;
    const fillModel = this.state.fillModel;
    fillModel.setUniforms(uniforms);
    fillModel.setUniforms({
      radius: cellSize / 2,
      radiusUnits: UNIT[radiusUnits],
      angle,
      offset,
      extruded,
      coverage,
      elevationScale,
      edgeDistance: 1,
      isStroke: false
    });
    fillModel.draw(this.context.renderPass);
  }
};
_GridCellLayer.layerName = "GridCellLayer";
_GridCellLayer.defaultProps = defaultProps8;
var GridCellLayer = _GridCellLayer;

// node_modules/@deck.gl/layers/dist/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  let flatPath;
  if (Array.isArray(path[0])) {
    const length2 = path.length * size;
    flatPath = new Array(length2);
    for (let i3 = 0; i3 < path.length; i3++) {
      for (let j = 0; j < size; j++) {
        flatPath[i3 * size + j] = path[i3][j] || 0;
      }
    }
  } else {
    flatPath = path;
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, { size, gridResolution });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, { size });
  }
  return flatPath;
}

// node_modules/@deck.gl/layers/dist/path-layer/path-tesselator.js
var START_CAP = 1;
var END_CAP = 2;
var INVALID = 4;
var PathTesselator = class extends Tesselator {
  constructor(opts) {
    super({
      ...opts,
      attributes: {
        // Padding covers shaderAttributes for last segment in largest case fp64
        // additional vertex + hi & low parts, 3 * 6
        positions: {
          size: 3,
          padding: 18,
          initialize: true,
          type: opts.fp64 ? Float64Array : Float32Array
        },
        segmentTypes: { size: 1, type: Uint8ClampedArray }
      }
    });
  }
  /** Get packed attribute by name */
  get(attributeName) {
    return this.attributes[attributeName];
  }
  /* Implement base Tesselator interface */
  getGeometryFromBuffer(buffer) {
    if (this.normalize) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /* Implement base Tesselator interface */
  normalizeGeometry(path) {
    if (this.normalize) {
      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
    }
    return path;
  }
  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    if (isCut(path)) {
      let size = 0;
      for (const subPath of path) {
        size += this.getGeometrySize(subPath);
      }
      return size;
    }
    const numPoints = this.getPathLength(path);
    if (numPoints < 2) {
      return 0;
    }
    if (this.isClosed(path)) {
      return numPoints < 3 ? 0 : numPoints + 2;
    }
    return numPoints;
  }
  /* Implement base Tesselator interface */
  updateGeometryAttributes(path, context) {
    if (context.geometrySize === 0) {
      return;
    }
    if (path && isCut(path)) {
      for (const subPath of path) {
        const geometrySize = this.getGeometrySize(subPath);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPath, context);
        context.vertexStart += geometrySize;
      }
    } else {
      this._updateSegmentTypes(path, context);
      this._updatePositions(path, context);
    }
  }
  _updateSegmentTypes(path, context) {
    const segmentTypes = this.attributes.segmentTypes;
    const isPathClosed = path ? this.isClosed(path) : false;
    const { vertexStart, geometrySize } = context;
    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
    if (isPathClosed) {
      segmentTypes[vertexStart] = INVALID;
      segmentTypes[vertexStart + geometrySize - 2] = INVALID;
    } else {
      segmentTypes[vertexStart] += START_CAP;
      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
    }
    segmentTypes[vertexStart + geometrySize - 1] = INVALID;
  }
  _updatePositions(path, context) {
    const { positions } = this.attributes;
    if (!positions || !path) {
      return;
    }
    const { vertexStart, geometrySize } = context;
    const p2 = new Array(3);
    for (let i3 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i3++, ptIndex++) {
      this.getPointOnPath(path, ptIndex, p2);
      positions[i3 * 3] = p2[0];
      positions[i3 * 3 + 1] = p2[1];
      positions[i3 * 3 + 2] = p2[2];
    }
  }
  // Utilities
  /** Returns the number of points in the path */
  getPathLength(path) {
    return path.length / this.positionSize;
  }
  /** Returns a point on the path at the specified index */
  getPointOnPath(path, index, target = []) {
    const { positionSize } = this;
    if (index * positionSize >= path.length) {
      index += 1 - path.length / positionSize;
    }
    const i3 = index * positionSize;
    target[0] = path[i3];
    target[1] = path[i3 + 1];
    target[2] = positionSize === 3 && path[i3 + 2] || 0;
    return target;
  }
  // Returns true if the first and last points are identical
  isClosed(path) {
    if (!this.normalize) {
      return Boolean(this.opts.loop);
    }
    const { positionSize } = this;
    const lastPointIndex = path.length - positionSize;
    return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
  }
};
function isCut(path) {
  return Array.isArray(path[0]);
}

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = capType;
} else {
vJointType = jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0);
vec3 width;
if (billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
uniform float miterLimit;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/path-layer/path-layer.js
var DEFAULT_COLOR7 = [0, 0, 0, 255];
var defaultProps9 = {
  widthUnits: "meters",
  widthScale: { type: "number", min: 0, value: 1 },
  widthMinPixels: { type: "number", min: 0, value: 0 },
  widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  jointRounded: false,
  capRounded: false,
  miterLimit: { type: "number", min: 0, value: 4 },
  billboard: false,
  _pathType: null,
  getPath: { type: "accessor", value: (object) => object.path },
  getColor: { type: "accessor", value: DEFAULT_COLOR7 },
  getWidth: { type: "accessor", value: 1 },
  // deprecated props
  rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
};
var ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var _PathLayer = class _PathLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      vertexPositions: {
        size: 3,
        // Start filling buffer from 1 vertex in
        vertexOffset: 1,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION,
        accessor: "getPath",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instanceLeftPositions: {
            vertexOffset: 0
          },
          instanceStartPositions: {
            vertexOffset: 1
          },
          instanceEndPositions: {
            vertexOffset: 2
          },
          instanceRightPositions: {
            vertexOffset: 3
          }
        }
      },
      instanceTypes: {
        size: 1,
        type: "uint8",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateSegmentTypes,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: "getWidth",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        accessor: "getColor",
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR7
      },
      instancePickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value)
      }
    });
    this.setState({
      pathTesselator: new PathTesselator({
        fp64: this.use64bitPositions()
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
    if (geometryChanged) {
      const { pathTesselator } = this.state;
      const buffers = props.data.attributes || {};
      pathTesselator.updateGeometry({
        data: props.data,
        geometryBuffer: buffers.getPath,
        buffers,
        normalize: !props._pathType,
        loop: props._pathType === "loop",
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        dataChanged: changeFlags.dataChanged
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        startIndices: pathTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        attributeManager.invalidateAll();
      }
    }
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      attributeManager.invalidateAll();
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index);
    }
    return info;
  }
  /** Override base Layer method */
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i3 = 0; i3 < data.length; i3++) {
        if (data[i3].__source.index === objectIndex) {
          this._disablePickingIndex(i3);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { jointRounded, capRounded, billboard, miterLimit, widthUnits, widthScale, widthMinPixels, widthMaxPixels } = this.props;
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      jointType: Number(jointRounded),
      capType: Number(capRounded),
      billboard,
      widthUnits: UNIT[widthUnits],
      widthScale,
      miterLimit,
      widthMinPixels,
      widthMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const SEGMENT_INDICES = [
      // start corner
      0,
      1,
      2,
      // body
      1,
      4,
      2,
      1,
      3,
      4,
      // end corner
      3,
      5,
      4
    ];
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      // start inner corner
      0,
      -1,
      // start outer corner
      0,
      1,
      // end inner corner
      1,
      -1,
      // end outer corner
      1,
      1,
      // bevel end corner
      1,
      0
    ];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-list",
        attributes: {
          indices: new Uint16Array(SEGMENT_INDICES),
          positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
        }
      }),
      isInstanced: true
    });
  }
  calculatePositions(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("positions");
  }
  calculateSegmentTypes(attribute) {
    const { pathTesselator } = this.state;
    attribute.startIndices = pathTesselator.vertexStarts;
    attribute.value = pathTesselator.get("segmentTypes");
  }
};
_PathLayer.defaultProps = defaultProps9;
_PathLayer.layerName = "PathLayer";
var PathLayer = _PathLayer;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon.js
var import_earcut2 = __toESM(require_earcut(), 1);
var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
var windingOptions = {
  isClosed: true
};
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function getPositions(polygon) {
  return "positions" in polygon ? polygon.positions : polygon;
}
function getHoleIndices(polygon) {
  return "holeIndices" in polygon ? polygon.holeIndices : null;
}
function isNested(polygon) {
  return Array.isArray(polygon[0]);
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i3 = 0; i3 < size; i3++) {
    if (positions[startIndex + i3] !== positions[endIndex - size + i3]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i3 = 0; i3 < len; i3++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i3][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;
  for (let i3 = 0; i3 < srcLength; i3++) {
    target[targetIndex++] = positions[srcStartIndex + i3];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i3 = 0; i3 < size; i3++) {
      target[targetIndex++] = positions[srcStartIndex + i3];
    }
  }
  windingOptions.start = targetStartIndex;
  windingOptions.end = targetIndex;
  windingOptions.size = size;
  modifyPolygonWindingDirection(target, windingDirection, windingOptions);
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  const positions = [];
  const holeIndices = [];
  if ("positions" in polygon) {
    const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
    if (srcHoleIndices) {
      let targetIndex = 0;
      for (let i3 = 0; i3 <= srcHoleIndices.length; i3++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i3 - 1], srcHoleIndices[i3], i3 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    polygon = srcPositions;
  }
  if (!isNested(polygon)) {
    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
    return positions;
  }
  if (!isSimple(polygon)) {
    let targetIndex = 0;
    for (const [polygonIndex, simplePolygon] of polygon.entries()) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);
      holeIndices.push(targetIndex);
    }
    holeIndices.pop();
    return { positions, holeIndices };
  }
  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
  return positions;
}
function getPlaneArea(positions, xIndex, yIndex) {
  const numVerts = positions.length / 3;
  let area2 = 0;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const j = (i3 + 1) % numVerts;
    area2 += positions[i3 * 3 + xIndex] * positions[j * 3 + yIndex];
    area2 -= positions[j * 3 + xIndex] * positions[i3 * 3 + yIndex];
  }
  return Math.abs(area2 / 2);
}
function permutePositions(positions, xIndex, yIndex, zIndex) {
  const numVerts = positions.length / 3;
  for (let i3 = 0; i3 < numVerts; i3++) {
    const o2 = i3 * 3;
    const x2 = positions[o2 + 0];
    const y2 = positions[o2 + 1];
    const z = positions[o2 + 2];
    positions[o2 + xIndex] = x2;
    positions[o2 + yIndex] = y2;
    positions[o2 + zIndex] = z;
  }
}
function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
  let holeIndices = getHoleIndices(polygon);
  if (holeIndices) {
    holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
  }
  let positions = getPositions(polygon);
  const is3d = full3d && positionSize === 3;
  if (preproject) {
    const n2 = positions.length;
    positions = positions.slice();
    const p2 = [];
    for (let i3 = 0; i3 < n2; i3 += positionSize) {
      p2[0] = positions[i3];
      p2[1] = positions[i3 + 1];
      if (is3d) {
        p2[2] = positions[i3 + 2];
      }
      const xy = preproject(p2);
      positions[i3] = xy[0];
      positions[i3 + 1] = xy[1];
      if (is3d) {
        positions[i3 + 2] = xy[2];
      }
    }
  }
  if (is3d) {
    const xyArea = getPlaneArea(positions, 0, 1);
    const xzArea = getPlaneArea(positions, 0, 2);
    const yzArea = getPlaneArea(positions, 1, 2);
    if (!xyArea && !xzArea && !yzArea) {
      return [];
    }
    if (xyArea > xzArea && xyArea > yzArea) {
    } else if (xzArea > yzArea) {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 0, 2, 1);
    } else {
      if (!preproject) {
        positions = positions.slice();
      }
      permutePositions(positions, 2, 0, 1);
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/polygon-tesselator.js
var PolygonTesselator = class extends Tesselator {
  constructor(opts) {
    const { fp64: fp642, IndexType = Uint32Array } = opts;
    super({
      ...opts,
      attributes: {
        positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
        vertexValid: { type: Uint16Array, size: 1 },
        indices: { type: IndexType, size: 1 }
      }
    });
  }
  /** Get attribute by name */
  get(attributeName) {
    const { attributes } = this;
    if (attributeName === "indices") {
      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
    }
    return attributes[attributeName];
  }
  /** Override base Tesselator method */
  updateGeometry(opts) {
    super.updateGeometry(opts);
    const externalIndices = this.buffers.indices;
    if (externalIndices) {
      this.vertexCount = (externalIndices.value || externalIndices).length;
    } else if (this.data && !this.getGeometry) {
      throw new Error("missing indices buffer");
    }
  }
  /** Implement base Tesselator interface */
  normalizeGeometry(polygon) {
    if (this.normalize) {
      const normalizedPolygon = normalize(polygon, this.positionSize);
      if (this.opts.resolution) {
        return cutPolygonByGrid(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          gridResolution: this.opts.resolution,
          edgeTypes: true
        });
      }
      if (this.opts.wrapLongitude) {
        return cutPolygonByMercatorBounds(getPositions(normalizedPolygon), getHoleIndices(normalizedPolygon), {
          size: this.positionSize,
          maxLatitude: 86,
          edgeTypes: true
        });
      }
      return normalizedPolygon;
    }
    return polygon;
  }
  /** Implement base Tesselator interface */
  getGeometrySize(polygon) {
    if (isCut2(polygon)) {
      let size = 0;
      for (const subPolygon of polygon) {
        size += this.getGeometrySize(subPolygon);
      }
      return size;
    }
    return getPositions(polygon).length / this.positionSize;
  }
  /** Override base Tesselator method */
  getGeometryFromBuffer(buffer) {
    if (this.normalize || !this.buffers.indices) {
      return super.getGeometryFromBuffer(buffer);
    }
    return null;
  }
  /** Implement base Tesselator interface */
  updateGeometryAttributes(polygon, context) {
    if (polygon && isCut2(polygon)) {
      for (const subPolygon of polygon) {
        const geometrySize = this.getGeometrySize(subPolygon);
        context.geometrySize = geometrySize;
        this.updateGeometryAttributes(subPolygon, context);
        context.vertexStart += geometrySize;
        context.indexStart = this.indexStarts[context.geometryIndex + 1];
      }
    } else {
      const normalizedPolygon = polygon;
      this._updateIndices(normalizedPolygon, context);
      this._updatePositions(normalizedPolygon, context);
      this._updateVertexValid(normalizedPolygon, context);
    }
  }
  // Flatten the indices array
  _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
    const { attributes, indexStarts, typedArrayManager } = this;
    let target = attributes.indices;
    if (!target || !polygon) {
      return;
    }
    let i3 = indexStart;
    const indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject, this.opts.full3d);
    target = typedArrayManager.allocate(target, indexStart + indices.length, {
      copy: true
    });
    for (let j = 0; j < indices.length; j++) {
      target[i3++] = indices[j] + offset;
    }
    indexStarts[geometryIndex + 1] = indexStart + indices.length;
    attributes.indices = target;
  }
  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, { vertexStart, geometrySize }) {
    const { attributes: { positions }, positionSize } = this;
    if (!positions || !polygon) {
      return;
    }
    const polygonPositions = getPositions(polygon);
    for (let i3 = vertexStart, j = 0; j < geometrySize; i3++, j++) {
      const x2 = polygonPositions[j * positionSize];
      const y2 = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
      positions[i3 * 3] = x2;
      positions[i3 * 3 + 1] = y2;
      positions[i3 * 3 + 2] = z;
    }
  }
  _updateVertexValid(polygon, { vertexStart, geometrySize }) {
    const { positionSize } = this;
    const vertexValid = this.attributes.vertexValid;
    const holeIndices = polygon && getHoleIndices(polygon);
    if (polygon && polygon.edgeTypes) {
      vertexValid.set(polygon.edgeTypes, vertexStart);
    } else {
      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
    }
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
};
function isCut2(polygon) {
  return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
}

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default = `uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;
out vec4 vColor;
struct PolygonProps {
vec4 fillColors;
vec4 lineColors;
vec3 positions;
vec3 positions64Low;
vec3 pickingColors;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project_uCommonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = isWireframe ? props.lineColors : props.fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = props.pickingColors;
if (extruded) {
pos.z += props.elevations * elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * opacity);
} else {
vColor = vec4(colors.rgb, colors.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.fillColors = fillColors;
props.lineColors = lineColors;
props.pickingColors = pickingColors;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 instancePositions;
in vec3 instanceNextPositions;
in vec3 instancePositions64Low;
in vec3 instanceNextPositions64Low;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
in float instanceVertexValid;
${solid_polygon_layer_vertex_main_glsl_default}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = instancePositions;
pos64Low = instancePositions64Low;
nextPos = instanceNextPositions;
nextPos64Low = instanceNextPositions64Low;
#else
pos = instanceNextPositions;
pos64Low = instanceNextPositions64Low;
nextPos = instancePositions;
nextPos64Low = instancePositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = instanceElevations * positions.y;
props.fillColors = instanceFillColors;
props.lineColors = instanceLineColors;
props.pickingColors = instancePickingColors;
calculatePosition(props);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8 = [0, 0, 0, 255];
var defaultProps10 = {
  filled: true,
  extruded: false,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  _full3d: false,
  elevationScale: { type: "number", min: 0, value: 1 },
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  getElevation: { type: "accessor", value: 1e3 },
  getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
  getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
  material: true
};
var ATTRIBUTE_TRANSITION2 = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};
var _SolidPolygonLayer = class _SolidPolygonLayer extends Layer {
  getShaders(type) {
    return super.getShaders({
      vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
      fs: solid_polygon_layer_fragment_glsl_default,
      defines: {
        RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
      },
      modules: [project32_default, gouraudLighting, picking_default]
    });
  }
  get wrapLongitude() {
    return false;
  }
  getBounds() {
    var _a;
    return (_a = this.getAttributeManager()) == null ? void 0 : _a.getBounds(["vertexPositions"]);
  }
  initializeState() {
    const { viewport } = this.context;
    let { coordinateSystem } = this.props;
    const { _full3d } = this.props;
    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
    }
    let preproject;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
      if (_full3d) {
        preproject = viewport.projectPosition.bind(viewport);
      } else {
        preproject = viewport.projectFlat.bind(viewport);
      }
    }
    this.setState({
      numInstances: 0,
      polygonTesselator: new PolygonTesselator({
        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results
        // Provide a preproject function if the coordinates are in lnglat
        preproject,
        fp64: this.use64bitPositions(),
        IndexType: Uint32Array
      })
    });
    const attributeManager = this.getAttributeManager();
    const noAlloc = true;
    attributeManager.remove(["instancePickingColors"]);
    attributeManager.add({
      indices: {
        size: 1,
        isIndexed: true,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateIndices,
        noAlloc
      },
      vertexPositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getPolygon",
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          instancePositions: {
            vertexOffset: 0,
            divisor: 1
          },
          instanceNextPositions: {
            vertexOffset: 1,
            divisor: 1
          }
        }
      },
      instanceVertexValid: {
        size: 1,
        type: "uint16",
        divisor: 1,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getElevation",
        shaderAttributes: {
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getFillColor",
        defaultValue: DEFAULT_COLOR8,
        shaderAttributes: {
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: ATTRIBUTE_TRANSITION2,
        accessor: "getLineColor",
        defaultValue: DEFAULT_COLOR8,
        shaderAttributes: {
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 4,
        type: "uint8",
        accessor: (object, { index, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index, value),
        shaderAttributes: {
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index } = info;
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      info.object = data.find((d) => d.__source.index === index);
    }
    return info;
  }
  disablePickingIndex(objectIndex) {
    const data = this.props.data;
    if (data[0] && data[0].__source) {
      for (let i3 = 0; i3 < data.length; i3++) {
        if (data[i3].__source.index === objectIndex) {
          this._disablePickingIndex(i3);
        }
      }
    } else {
      super.disablePickingIndex(objectIndex);
    }
  }
  draw({ uniforms }) {
    const { extruded, filled, wireframe, elevationScale } = this.props;
    const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
    const renderUniforms = {
      ...uniforms,
      extruded: Boolean(extruded),
      elevationScale
    };
    if (wireframeModel && wireframe) {
      wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      wireframeModel.setUniforms(renderUniforms);
      wireframeModel.draw(this.context.renderPass);
    }
    if (sideModel && filled) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      sideModel.draw(this.context.renderPass);
    }
    if (topModel && filled) {
      topModel.setVertexCount(polygonTesselator.vertexCount);
      topModel.setUniforms(renderUniforms);
      topModel.draw(this.context.renderPass);
    }
  }
  updateState(updateParams) {
    var _a;
    super.updateState(updateParams);
    this.updateGeometry(updateParams);
    const { props, oldProps, changeFlags } = updateParams;
    const attributeManager = this.getAttributeManager();
    const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
    if (regenerateModels) {
      (_a = this.state.models) == null ? void 0 : _a.forEach((model) => model.destroy());
      this.setState(this._getModels());
      attributeManager.invalidateAll();
    }
  }
  updateGeometry({ props, oldProps, changeFlags }) {
    const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryConfigChanged) {
      const { polygonTesselator } = this.state;
      const buffers = props.data.attributes || {};
      polygonTesselator.updateGeometry({
        data: props.data,
        normalize: props._normalize,
        geometryBuffer: buffers.getPolygon,
        buffers,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        wrapLongitude: props.wrapLongitude,
        // TODO - move the flag out of the viewport
        resolution: this.context.viewport.resolution,
        fp64: this.use64bitPositions(),
        dataChanged: changeFlags.dataChanged,
        full3d: props._full3d
      });
      this.setState({
        numInstances: polygonTesselator.instanceCount,
        startIndices: polygonTesselator.vertexStarts
      });
      if (!changeFlags.dataChanged) {
        this.getAttributeManager().invalidateAll();
      }
    }
  }
  _getModels() {
    const { id, filled, extruded } = this.props;
    let topModel;
    let sideModel;
    let wireframeModel;
    const bufferLayout = this.getAttributeManager().getBufferLayouts();
    if (filled) {
      const shaders = this.getShaders("top");
      shaders.defines.NON_INSTANCED_MODEL = 1;
      topModel = new Model(this.context.device, {
        ...shaders,
        id: `${id}-top`,
        topology: "triangle-list",
        uniforms: {
          isWireframe: false
        },
        bufferLayout,
        isIndexed: true,
        userData: {
          excludeAttributes: { instanceVertexValid: true }
        }
      });
    }
    if (extruded) {
      sideModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-side`,
        bufferLayout,
        uniforms: {
          isWireframe: false
        },
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            // top right - top left - bottom right - bottom left
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
            }
          }
        }),
        isInstanced: 1,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
      wireframeModel = new Model(this.context.device, {
        ...this.getShaders("side"),
        id: `${id}-wireframe`,
        bufferLayout,
        uniforms: {
          isWireframe: true
        },
        geometry: new Geometry({
          topology: "line-strip",
          attributes: {
            // top right - top left - bottom left - bottom right
            positions: {
              size: 2,
              value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
            }
          }
        }),
        isInstanced: 1,
        userData: {
          excludeAttributes: { indices: true }
        }
      });
    }
    return {
      models: [sideModel, wireframeModel, topModel].filter(Boolean),
      topModel,
      sideModel,
      wireframeModel
    };
  }
  calculateIndices(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.indexStarts;
    attribute.value = polygonTesselator.get("indices");
  }
  calculatePositions(attribute) {
    const { polygonTesselator } = this.state;
    attribute.startIndices = polygonTesselator.vertexStarts;
    attribute.value = polygonTesselator.get("positions");
  }
  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get("vertexValid");
  }
};
_SolidPolygonLayer.defaultProps = defaultProps10;
_SolidPolygonLayer.layerName = "SolidPolygonLayer";
var SolidPolygonLayer = _SolidPolygonLayer;

// node_modules/@deck.gl/layers/dist/utils.js
function replaceInRange({ data, getIndex, dataRange, replace }) {
  const { startRow = 0, endRow = Infinity } = dataRange;
  const count = data.length;
  let replaceStart = count;
  let replaceEnd = count;
  for (let i3 = 0; i3 < count; i3++) {
    const row = getIndex(data[i3]);
    if (replaceStart > i3 && row >= startRow) {
      replaceStart = i3;
    }
    if (row >= endRow) {
      replaceEnd = i3;
      break;
    }
  }
  let index = replaceStart;
  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
  for (let i3 = 0; i3 < replace.length; i3++) {
    data[index++] = replace[i3];
  }
  if (endChunk) {
    for (let i3 = 0; i3 < endChunk.length; i3++) {
      data[index++] = endChunk[i3];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}

// node_modules/@deck.gl/layers/dist/polygon-layer/polygon-layer.js
var defaultLineColor = [0, 0, 0, 255];
var defaultFillColor = [0, 0, 0, 255];
var defaultProps11 = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,
  _normalize: true,
  _windingOrder: "CW",
  lineWidthUnits: "meters",
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  getPolygon: { type: "accessor", value: (f2) => f2.polygon },
  // Polygon fill color
  getFillColor: { type: "accessor", value: defaultFillColor },
  // Point, line and polygon outline color
  getLineColor: { type: "accessor", value: defaultLineColor },
  // Line and polygon outline accessors
  getLineWidth: { type: "accessor", value: 1 },
  // Polygon extrusion accessor
  getElevation: { type: "accessor", value: 1e3 },
  // Optional material for 'lighting' shader module
  material: true
};
var _PolygonLayer = class _PolygonLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      paths: [],
      pathsDiff: null
    };
    if (this.props.getLineDashArray) {
      log_default.removed("getLineDashArray", "PathStyleExtension")();
    }
  }
  updateState({ changeFlags }) {
    const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
      const paths = this.state.paths.slice();
      const pathsDiff = changeFlags.dataChanged.map((dataRange) => replaceInRange({
        data: paths,
        getIndex: (p2) => p2.__source.index,
        dataRange,
        replace: this._getPaths(dataRange)
      }));
      this.setState({ paths, pathsDiff });
    } else if (geometryChanged) {
      this.setState({
        paths: this._getPaths(),
        pathsDiff: null
      });
    }
  }
  _getPaths(dataRange = {}) {
    const { data, getPolygon, positionFormat, _normalize } = this.props;
    const paths = [];
    const positionSize = positionFormat === "XY" ? 2 : 3;
    const { startRow, endRow } = dataRange;
    const { iterable, objectInfo } = createIterable(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      let polygon = getPolygon(object, objectInfo);
      if (_normalize) {
        polygon = normalize(polygon, positionSize);
      }
      const { holeIndices } = polygon;
      const positions = polygon.positions || polygon;
      if (holeIndices) {
        for (let i3 = 0; i3 <= holeIndices.length; i3++) {
          const path = positions.slice(holeIndices[i3 - 1] || 0, holeIndices[i3] || positions.length);
          paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
        }
      } else {
        paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
      }
    }
    return paths;
  }
  /* eslint-disable complexity */
  renderLayers() {
    const { data, _dataDiff, stroked, filled, extruded, wireframe, _normalize, _windingOrder, elevationScale, transitions, positionFormat } = this.props;
    const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified } = this.props;
    const { getFillColor, getLineColor, getLineWidth, getLineDashArray, getElevation, getPolygon, updateTriggers, material } = this.props;
    const { paths, pathsDiff } = this.state;
    const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
    const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
    const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
      _dataDiff,
      extruded,
      elevationScale,
      filled,
      wireframe,
      _normalize,
      _windingOrder,
      getElevation,
      getFillColor,
      getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
      material,
      transitions
    }, this.getSubLayerProps({
      id: "fill",
      updateTriggers: updateTriggers && {
        getPolygon: updateTriggers.getPolygon,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        // using a legacy API to invalid lineColor attributes
        // if (extruded && wireframe) has changed
        lineColors: extruded && wireframe,
        getLineColor: updateTriggers.getLineColor
      }
    }), {
      data,
      positionFormat,
      getPolygon
    });
    const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
      _dataDiff: pathsDiff && (() => pathsDiff),
      widthUnits: lineWidthUnits,
      widthScale: lineWidthScale,
      widthMinPixels: lineWidthMinPixels,
      widthMaxPixels: lineWidthMaxPixels,
      jointRounded: lineJointRounded,
      miterLimit: lineMiterLimit,
      dashJustified: lineDashJustified,
      // Already normalized
      _pathType: "loop",
      transitions: transitions && {
        getWidth: transitions.getLineWidth,
        getColor: transitions.getLineColor,
        getPath: transitions.getPolygon
      },
      getColor: this.getSubLayerAccessor(getLineColor),
      getWidth: this.getSubLayerAccessor(getLineWidth),
      getDashArray: this.getSubLayerAccessor(getLineDashArray)
    }, this.getSubLayerProps({
      id: "stroke",
      updateTriggers: updateTriggers && {
        getWidth: updateTriggers.getLineWidth,
        getColor: updateTriggers.getLineColor,
        getDashArray: updateTriggers.getLineDashArray
      }
    }), {
      data: paths,
      positionFormat,
      getPath: (x2) => x2.path
    });
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
};
_PolygonLayer.layerName = "PolygonLayer";
_PolygonLayer.defaultProps = defaultProps11;
var PolygonLayer = _PolygonLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-binary.js
function binaryToFeatureForAccesor(data, index) {
  if (!data) {
    return null;
  }
  const featureIndex = "startIndices" in data ? data.startIndices[index] : index;
  const geometryIndex = data.featureIds.value[featureIndex];
  if (featureIndex !== -1) {
    return getPropertiesForIndex(data, geometryIndex, featureIndex);
  }
  return null;
}
function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
  const feature2 = {
    properties: { ...data.properties[propertiesIndex] }
  };
  for (const prop in data.numericProps) {
    feature2.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
  }
  return feature2;
}
function calculatePickingColors(geojsonBinary, encodePickingColor) {
  const pickingColors = {
    points: null,
    lines: null,
    polygons: null
  };
  for (const key in pickingColors) {
    const featureIds = geojsonBinary[key].globalFeatureIds.value;
    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
    const pickingColor = [];
    for (let i3 = 0; i3 < featureIds.length; i3++) {
      encodePickingColor(featureIds[i3], pickingColor);
      pickingColors[key][i3 * 3 + 0] = pickingColor[0];
      pickingColors[key][i3 * 3 + 1] = pickingColor[1];
      pickingColors[key][i3 * 3 + 2] = pickingColor[2];
    }
  }
  return pickingColors;
}

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf) {
float distance = alpha;
alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);
if (outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
color = mix(outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_BUFFER2 = 192 / 256;
var EMPTY_ARRAY = [];
var defaultProps12 = {
  getIconOffsets: { type: "accessor", value: (x2) => x2.offsets },
  alphaCutoff: 1e-3,
  smoothing: 0.1,
  outlineWidth: 0,
  outlineColor: { type: "color", value: [0, 0, 0, 255] }
};
var _MultiIconLayer = class _MultiIconLayer extends IconLayer {
  getShaders() {
    return { ...super.getShaders(), fs: multi_icon_layer_fragment_glsl_default };
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceOffsets: {
        size: 2,
        accessor: "getIconOffsets"
      },
      instancePickingColors: {
        type: "uint8",
        size: 3,
        accessor: (object, { index, target: value }) => this.encodePickingColor(index, value)
      }
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    let { outlineColor } = props;
    if (outlineColor !== oldProps.outlineColor) {
      outlineColor = outlineColor.map((x2) => x2 / 255);
      outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
      this.setState({
        outlineColor
      });
    }
    if (!props.sdf && props.outlineWidth) {
      log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
    }
  }
  draw(params) {
    const { sdf, smoothing, outlineWidth } = this.props;
    const { outlineColor } = this.state;
    const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
    params.uniforms = {
      ...params.uniforms,
      // Refer the following doc about gamma and buffer
      // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817
      sdfBuffer: DEFAULT_BUFFER2,
      outlineBuffer,
      gamma: smoothing,
      sdf: Boolean(sdf),
      outlineColor
    };
    super.draw(params);
    if (sdf && outlineWidth) {
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      const model = this.state.model;
      if (iconsTexture) {
        model.setUniforms({ outlineBuffer: DEFAULT_BUFFER2 });
        model.draw(this.context.renderPass);
      }
    }
  }
  getInstanceOffset(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY;
  }
  getInstanceColorMode(icons) {
    return 1;
  }
  getInstanceIconFrame(icons) {
    return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;
  }
};
_MultiIconLayer.defaultProps = defaultProps12;
_MultiIconLayer.layerName = "MultiIconLayer";
var MultiIconLayer = _MultiIconLayer;

// node_modules/@mapbox/tiny-sdf/index.js
var INF = 1e20;
var TinySDF = class {
  constructor({
    fontSize = 24,
    buffer = 3,
    radius = 8,
    cutoff = 0.25,
    fontFamily = "sans-serif",
    fontWeight = "normal",
    fontStyle = "normal"
  } = {}) {
    this.buffer = buffer;
    this.cutoff = cutoff;
    this.radius = radius;
    const size = this.size = fontSize + buffer * 4;
    const canvas = this._createCanvas(size);
    const ctx = this.ctx = canvas.getContext("2d", { willReadFrequently: true });
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = "left";
    ctx.fillStyle = "black";
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Uint16Array(size);
  }
  _createCanvas(size) {
    const canvas = document.createElement("canvas");
    canvas.width = canvas.height = size;
    return canvas;
  }
  draw(char) {
    const {
      width: glyphAdvance,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      actualBoundingBoxLeft,
      actualBoundingBoxRight
    } = this.ctx.measureText(char);
    const glyphTop = Math.ceil(actualBoundingBoxAscent);
    const glyphLeft = 0;
    const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
    const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
    const width = glyphWidth + 2 * this.buffer;
    const height = glyphHeight + 2 * this.buffer;
    const len = Math.max(width * height, 0);
    const data = new Uint8ClampedArray(len);
    const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
    if (glyphWidth === 0 || glyphHeight === 0)
      return glyph;
    const { ctx, buffer, gridInner, gridOuter } = this;
    ctx.clearRect(buffer, buffer, glyphWidth, glyphHeight);
    ctx.fillText(char, buffer, buffer + glyphTop);
    const imgData = ctx.getImageData(buffer, buffer, glyphWidth, glyphHeight);
    gridOuter.fill(INF, 0, len);
    gridInner.fill(0, 0, len);
    for (let y2 = 0; y2 < glyphHeight; y2++) {
      for (let x2 = 0; x2 < glyphWidth; x2++) {
        const a3 = imgData.data[4 * (y2 * glyphWidth + x2) + 3] / 255;
        if (a3 === 0)
          continue;
        const j = (y2 + buffer) * width + x2 + buffer;
        if (a3 === 1) {
          gridOuter[j] = 0;
          gridInner[j] = INF;
        } else {
          const d = 0.5 - a3;
          gridOuter[j] = d > 0 ? d * d : 0;
          gridInner[j] = d < 0 ? d * d : 0;
        }
      }
    }
    edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
    edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
    for (let i3 = 0; i3 < len; i3++) {
      const d = Math.sqrt(gridOuter[i3]) - Math.sqrt(gridInner[i3]);
      data[i3] = Math.round(255 - 255 * (d / this.radius + this.cutoff));
    }
    return glyph;
  }
};
function edt(data, x0, y0, width, height, gridSize, f2, v, z) {
  for (let x2 = x0; x2 < x0 + width; x2++)
    edt1d(data, y0 * gridSize + x2, gridSize, height, f2, v, z);
  for (let y2 = y0; y2 < y0 + height; y2++)
    edt1d(data, y2 * gridSize + x0, 1, width, f2, v, z);
}
function edt1d(grid, offset, stride, length2, f2, v, z) {
  v[0] = 0;
  z[0] = -INF;
  z[1] = INF;
  f2[0] = grid[offset];
  for (let q = 1, k = 0, s2 = 0; q < length2; q++) {
    f2[q] = grid[offset + q * stride];
    const q2 = q * q;
    do {
      const r2 = v[k];
      s2 = (f2[q] - f2[r2] + q2 - r2 * r2) / (q - r2) / 2;
    } while (s2 <= z[k] && --k > -1);
    k++;
    v[k] = q;
    z[k] = s2;
    z[k + 1] = INF;
  }
  for (let q = 0, k = 0; q < length2; q++) {
    while (z[k + 1] < q)
      k++;
    const r2 = v[k];
    const qr = q - r2;
    grid[offset + q * stride] = f2[r2] + qr * qr;
  }
}

// node_modules/@deck.gl/layers/dist/text-layer/utils.js
var MISSING_CHAR_WIDTH = 32;
var SINGLE_LINE = [];
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2({ characterSet, getFontWidth, fontHeight, buffer, maxCanvasWidth, mapping = {}, xOffset = 0, yOffset = 0 }) {
  let row = 0;
  let x2 = xOffset;
  const rowHeight = fontHeight + buffer * 2;
  for (const char of characterSet) {
    if (!mapping[char]) {
      const width = getFontWidth(char);
      if (x2 + width + buffer * 2 > maxCanvasWidth) {
        x2 = 0;
        row++;
      }
      mapping[char] = {
        x: x2 + buffer,
        y: yOffset + row * rowHeight + buffer,
        width,
        height: rowHeight,
        layoutWidth: width,
        layoutHeight: fontHeight
      };
      x2 += width + buffer * 2;
    }
  }
  return {
    mapping,
    xOffset: x2,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, startIndex, endIndex, mapping) {
  var _a;
  let width = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const character = text[i3];
    width += ((_a = mapping[character]) == null ? void 0 : _a.layoutWidth) || 0;
  }
  return width;
}
function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const textWidth = getTextWidth(text, i3, i3 + 1, iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i3) {
        target.push(i3);
      }
      rowStartCharIndex = i3;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  return rowOffsetLeft;
}
function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
  let rowStartCharIndex = startIndex;
  let groupStartCharIndex = startIndex;
  let groupEndCharIndex = startIndex;
  let rowOffsetLeft = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    if (text[i3] === " ") {
      groupEndCharIndex = i3 + 1;
    } else if (text[i3 + 1] === " " || i3 + 1 === endIndex) {
      groupEndCharIndex = i3 + 1;
    }
    if (groupEndCharIndex > groupStartCharIndex) {
      let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        if (rowStartCharIndex < groupStartCharIndex) {
          target.push(groupStartCharIndex);
          rowStartCharIndex = groupStartCharIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          groupWidth = breakAll(text, groupStartCharIndex, groupEndCharIndex, maxWidth, iconMapping, target);
          rowStartCharIndex = target[target.length - 1];
        }
      }
      groupStartCharIndex = groupEndCharIndex;
      rowOffsetLeft += groupWidth;
    }
  }
  return rowOffsetLeft;
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
  if (endIndex === void 0) {
    endIndex = text.length;
  }
  const result = [];
  if (wordBreak === "break-all") {
    breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
  } else {
    breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
  }
  return result;
}
function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
  let x2 = 0;
  let rowHeight = 0;
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    const character = line[i3];
    const frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.layoutHeight;
      }
      leftOffsets[i3] = x2 + frame.layoutWidth / 2;
      x2 += frame.layoutWidth;
    } else {
      log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
      leftOffsets[i3] = x2;
      x2 += MISSING_CHAR_WIDTH;
    }
  }
  rowSize[0] = x2;
  rowSize[1] = rowHeight;
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  var _a;
  const characters = Array.from(paragraph);
  const numCharacters = characters.length;
  const x2 = new Array(numCharacters);
  const y2 = new Array(numCharacters);
  const rowWidth = new Array(numCharacters);
  const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  const size = [0, 0];
  const rowSize = [0, 0];
  let rowOffsetTop = 0;
  let lineStartIndex = 0;
  let lineEndIndex = 0;
  for (let i3 = 0; i3 <= numCharacters; i3++) {
    const char = characters[i3];
    if (char === "\n" || i3 === numCharacters) {
      lineEndIndex = i3;
    }
    if (lineEndIndex > lineStartIndex) {
      const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
      for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
        const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
        const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
        transformRow(characters, rowStart, rowEnd, iconMapping, x2, rowSize);
        for (let j = rowStart; j < rowEnd; j++) {
          const char2 = characters[j];
          const layoutOffsetY = ((_a = iconMapping[char2]) == null ? void 0 : _a.layoutOffsetY) || 0;
          y2[j] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
          rowWidth[j] = rowSize[0];
        }
        rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
        size[0] = Math.max(size[0], rowSize[0]);
      }
      lineStartIndex = lineEndIndex;
    }
    if (char === "\n") {
      x2[lineStartIndex] = 0;
      y2[lineStartIndex] = 0;
      rowWidth[lineStartIndex] = 0;
      lineStartIndex++;
    }
  }
  size[1] = rowOffsetTop;
  return { x: x2, y: y2, rowWidth, size };
}
function getTextFromBuffer({ value, length: length2, stride, offset, startIndices, characterSet }) {
  const bytesPerElement = value.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : 1;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const characterCount = startIndices[length2] || Math.ceil((value.length - elementOffset) / elementStride);
  const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
  const texts = new Array(length2);
  let codes = value;
  if (elementStride > 1 || elementOffset > 0) {
    const ArrayType = value.constructor;
    codes = new ArrayType(characterCount);
    for (let i3 = 0; i3 < characterCount; i3++) {
      codes[i3] = value[i3 * elementStride + elementOffset];
    }
  }
  for (let index = 0; index < length2; index++) {
    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || characterCount;
    const codesAtIndex = codes.subarray(startIndex, endIndex);
    texts[index] = String.fromCodePoint.apply(null, codesAtIndex);
    if (autoCharacterSet) {
      codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
    }
  }
  if (autoCharacterSet) {
    for (const charCode of autoCharacterSet) {
      characterSet.add(String.fromCodePoint(charCode));
    }
  }
  return { texts, characterCount };
}

// node_modules/@deck.gl/layers/dist/text-layer/lru-cache.js
var LRUCache = class {
  constructor(limit = 5) {
    this._cache = {};
    this._order = [];
    this.limit = limit;
  }
  get(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }
  set(key, value) {
    if (!this._cache[key]) {
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }
      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      this.delete(key);
      this._cache[key] = value;
      this._appendOrder(key);
    }
  }
  delete(key) {
    const value = this._cache[key];
    if (value) {
      delete this._cache[key];
      this._deleteOrder(key);
    }
  }
  _deleteOrder(key) {
    const index = this._order.indexOf(key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }
  _appendOrder(key) {
    this._order.push(key);
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  const charSet = [];
  for (let i3 = 32; i3 < 128; i3++) {
    charSet.push(String.fromCharCode(i3));
  }
  return charSet;
}
var DEFAULT_FONT_SETTINGS = {
  fontFamily: "Monaco, monospace",
  fontWeight: "normal",
  characterSet: getDefaultCharacterSet(),
  fontSize: 64,
  buffer: 4,
  sdf: false,
  cutoff: 0.25,
  radius: 12,
  smoothing: 0.1
};
var MAX_CANVAS_WIDTH = 1024;
var BASELINE_SCALE = 0.9;
var HEIGHT_SCALE = 1.2;
var CACHE_LIMIT = 3;
var cache = new LRUCache(CACHE_LIMIT);
function getNewChars(cacheKey, characterSet) {
  let newCharSet;
  if (typeof characterSet === "string") {
    newCharSet = new Set(Array.from(characterSet));
  } else {
    newCharSet = new Set(characterSet);
  }
  const cachedFontAtlas = cache.get(cacheKey);
  if (!cachedFontAtlas) {
    return newCharSet;
  }
  for (const char in cachedFontAtlas.mapping) {
    if (newCharSet.has(char)) {
      newCharSet.delete(char);
    }
  }
  return newCharSet;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (let i3 = 0; i3 < alphaChannel.length; i3++) {
    imageData.data[4 * i3 + 3] = alphaChannel[i3];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.textAlign = "left";
}
function setFontAtlasCacheLimit(limit) {
  log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
  cache = new LRUCache(limit);
}
var FontAtlasManager = class {
  constructor() {
    this.props = { ...DEFAULT_FONT_SETTINGS };
  }
  get atlas() {
    return this._atlas;
  }
  // TODO - cut during v9 porting as types reveal this is not correct
  // get texture(): Texture | undefined {
  //   return this._atlas;
  // }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  get scale() {
    const { fontSize, buffer } = this.props;
    return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    this._key = this._getKey();
    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);
    if (cachedFontAtlas && charSet.size === 0) {
      if (this._atlas !== cachedFontAtlas) {
        this._atlas = cachedFontAtlas;
      }
      return;
    }
    const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
    this._atlas = fontAtlas;
    cache.set(this._key, fontAtlas);
  }
  // eslint-disable-next-line max-statements
  _generateFontAtlas(characterSet, cachedFontAtlas) {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
      getFontWidth: (char) => ctx.measureText(char).width,
      fontHeight: fontSize * HEIGHT_SCALE,
      buffer,
      characterSet,
      maxCanvasWidth: MAX_CANVAS_WIDTH,
      ...cachedFontAtlas && {
        mapping: cachedFontAtlas.mapping,
        xOffset: cachedFontAtlas.xOffset,
        yOffset: cachedFontAtlas.yOffset
      }
    });
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);
    if (sdf) {
      const tinySDF = new TinySDF({
        fontSize,
        buffer,
        radius,
        cutoff,
        fontFamily,
        fontWeight: `${fontWeight}`
      });
      for (const char of characterSet) {
        const { data, width, height, glyphTop } = tinySDF.draw(char);
        mapping[char].width = width;
        mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
        const imageData = ctx.createImageData(width, height);
        populateAlphaChannel(data, imageData);
        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
      }
    }
    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }
  _getKey() {
    const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
    if (sdf) {
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
};

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-vertex.glsl.js
var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer-fragment.glsl.js
var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
uniform bool stroked;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec2 pixelPosition = uv * dimensions;
if (stroked) {
float distToEdge = min(
min(pixelPosition.x, dimensions.x - pixelPosition.x),
min(pixelPosition.y, dimensions.y - pixelPosition.y)
);
float isBorder = smoothedge(distToEdge, vLineWidth);
fragColor = mix(vFillColor, vLineColor, isBorder);
} else {
fragColor = vFillColor;
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/layers/dist/text-layer/text-background-layer/text-background-layer.js
var defaultProps13 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  padding: { type: "array", value: [0, 0, 0, 0] },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getSize: { type: "accessor", value: 1 },
  getAngle: { type: "accessor", value: 0 },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
  getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
  getLineWidth: { type: "accessor", value: 1 }
};
var _TextBackgroundLayer = class _TextBackgroundLayer extends Layer {
  getShaders() {
    return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: true,
        accessor: "getPosition"
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: "getSize",
        defaultValue: 1
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: "getAngle"
      },
      instanceRects: {
        size: 4,
        accessor: "getBoundingRect"
      },
      instancePixelOffsets: {
        size: 2,
        transition: true,
        accessor: "getPixelOffset"
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: "unorm8",
        accessor: "getLineColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: "getLineWidth",
        defaultValue: 1
      }
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { changeFlags } = params;
    if (changeFlags.extensionsChanged) {
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      this.state.model = this._getModel();
      this.getAttributeManager().invalidateAll();
    }
  }
  draw({ uniforms }) {
    const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
    let { padding } = this.props;
    if (padding.length < 4) {
      padding = [padding[0], padding[1], padding[0], padding[1]];
    }
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setUniforms({
      billboard,
      stroked: Boolean(getLineWidth),
      padding,
      sizeUnits: UNIT[sizeUnits],
      sizeScale,
      sizeMinPixels,
      sizeMaxPixels
    });
    model.draw(this.context.renderPass);
  }
  _getModel() {
    const positions = [0, 0, 1, 0, 1, 1, 0, 1];
    return new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Geometry({
        topology: "triangle-fan-webgl",
        vertexCount: 4,
        attributes: {
          positions: { size: 2, value: new Float32Array(positions) }
        }
      }),
      isInstanced: true
    });
  }
};
_TextBackgroundLayer.defaultProps = defaultProps13;
_TextBackgroundLayer.layerName = "TextBackgroundLayer";
var TextBackgroundLayer = _TextBackgroundLayer;

// node_modules/@deck.gl/layers/dist/text-layer/text-layer.js
var TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};
var ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};
var DEFAULT_COLOR9 = [0, 0, 0, 255];
var DEFAULT_LINE_HEIGHT = 1;
var defaultProps14 = {
  billboard: true,
  sizeScale: 1,
  sizeUnits: "pixels",
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,
  background: false,
  getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
  getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getBorderWidth: { type: "accessor", value: 0 },
  backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
  characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
  fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
  fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
  lineHeight: DEFAULT_LINE_HEIGHT,
  outlineWidth: { type: "number", value: 0, min: 0 },
  outlineColor: { type: "color", value: DEFAULT_COLOR9 },
  fontSettings: { type: "object", value: {}, compare: 1 },
  // auto wrapping options
  wordBreak: "break-word",
  maxWidth: { type: "number", value: -1 },
  getText: { type: "accessor", value: (x2) => x2.text },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR9 },
  getSize: { type: "accessor", value: 32 },
  getAngle: { type: "accessor", value: 0 },
  getTextAnchor: { type: "accessor", value: "middle" },
  getAlignmentBaseline: { type: "accessor", value: "center" },
  getPixelOffset: { type: "accessor", value: [0, 0] },
  // deprecated
  backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
};
var _TextLayer = class _TextLayer extends CompositeLayer {
  constructor() {
    super(...arguments);
    this.getBoundingRect = (object, objectInfo) => {
      let { size: [width, height] } = this.transformParagraph(object, objectInfo);
      const { fontSize } = this.state.fontAtlasManager.props;
      width /= fontSize;
      height /= fontSize;
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
    };
    this.getIconOffsets = (object, objectInfo) => {
      const { getTextAnchor, getAlignmentBaseline } = this.props;
      const { x: x2, y: y2, rowWidth, size: [width, height] } = this.transformParagraph(object, objectInfo);
      const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
      const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
      const numCharacters = x2.length;
      const offsets = new Array(numCharacters * 2);
      let index = 0;
      for (let i3 = 0; i3 < numCharacters; i3++) {
        const rowOffset = (1 - anchorX) * (width - rowWidth[i3]) / 2;
        offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x2[i3];
        offsets[index++] = (anchorY - 1) * height / 2 + y2[i3];
      }
      return offsets;
    };
  }
  initializeState() {
    this.state = {
      styleVersion: 0,
      fontAtlasManager: new FontAtlasManager()
    };
    if (this.props.maxWidth > 0) {
      log_default.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
    }
  }
  // eslint-disable-next-line complexity
  updateState(params) {
    const { props, oldProps, changeFlags } = params;
    const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
    if (textChanged) {
      this._updateText();
    }
    const fontChanged = this._updateFontAtlas();
    const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
    if (styleChanged) {
      this.setState({
        styleVersion: this.state.styleVersion + 1
      });
    }
  }
  getPickingInfo({ info }) {
    info.object = info.index >= 0 ? this.props.data[info.index] : null;
    return info;
  }
  /** Returns true if font has changed */
  _updateFontAtlas() {
    const { fontSettings, fontFamily, fontWeight } = this.props;
    const { fontAtlasManager, characterSet } = this.state;
    const fontProps = {
      ...fontSettings,
      characterSet,
      fontFamily,
      fontWeight
    };
    if (!fontAtlasManager.mapping) {
      fontAtlasManager.setProps(fontProps);
      return true;
    }
    for (const key in fontProps) {
      if (fontProps[key] !== fontAtlasManager.props[key]) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
    }
    return false;
  }
  // Text strings are variable width objects
  // Count characters and start offsets
  _updateText() {
    var _a;
    const { data, characterSet } = this.props;
    const textBuffer = (_a = data.attributes) == null ? void 0 : _a.getText;
    let { getText } = this.props;
    let startIndices = data.startIndices;
    let numInstances;
    const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
    if (textBuffer && startIndices) {
      const { texts, characterCount } = getTextFromBuffer({
        ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
        // @ts-ignore if data.attribute is defined then length is expected
        length: data.length,
        startIndices,
        characterSet: autoCharacterSet
      });
      numInstances = characterCount;
      getText = (_2, { index }) => texts[index];
    } else {
      const { iterable, objectInfo } = createIterable(data);
      startIndices = [0];
      numInstances = 0;
      for (const object of iterable) {
        objectInfo.index++;
        const text = Array.from(getText(object, objectInfo) || "");
        if (autoCharacterSet) {
          text.forEach(autoCharacterSet.add, autoCharacterSet);
        }
        numInstances += text.length;
        startIndices.push(numInstances);
      }
    }
    this.setState({
      getText,
      startIndices,
      numInstances,
      characterSet: autoCharacterSet || characterSet
    });
  }
  /** There are two size systems in this layer:
  
      + Pixel size: user-specified text size, via getSize, sizeScale, sizeUnits etc.
        The layer roughly matches the output of the layer to CSS pixels, e.g. getSize: 12, sizeScale: 2
        in layer props is roughly equivalent to font-size: 24px in CSS.
      + Texture size: internally, character positions in a text blob are calculated using the sizes of iconMapping,
        which depends on how large each character is drawn into the font atlas. This is controlled by
        fontSettings.fontSize (default 64) and most users do not set it manually.
        These numbers are intended to be used in the vertex shader and never to be exposed to the end user.
  
      All surfaces exposed to the user should either use the pixel size or a multiplier relative to the pixel size. */
  /** Calculate the size and position of each character in a text string.
   * Values are in texture size */
  transformParagraph(object, objectInfo) {
    const { fontAtlasManager } = this.state;
    const iconMapping = fontAtlasManager.mapping;
    const getText = this.state.getText;
    const { wordBreak, lineHeight, maxWidth } = this.props;
    const paragraph = getText(object, objectInfo) || "";
    return transformParagraph(paragraph, lineHeight, wordBreak, maxWidth * fontAtlasManager.props.fontSize, iconMapping);
  }
  renderLayers() {
    const { startIndices, numInstances, getText, fontAtlasManager: { scale, atlas, mapping }, styleVersion } = this.state;
    const { data, _dataDiff, getPosition, getColor, getSize, getAngle, getPixelOffset, getBackgroundColor, getBorderColor, getBorderWidth, backgroundPadding, background, billboard, fontSettings, outlineWidth, outlineColor, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, transitions, updateTriggers } = this.props;
    const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
    const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
    return [
      background && new BackgroundLayerClass({
        // background props
        getFillColor: getBackgroundColor,
        getLineColor: getBorderColor,
        getLineWidth: getBorderWidth,
        padding: backgroundPadding,
        // props shared with characters layer
        getPosition,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getSize: transitions.getSize,
          getFillColor: transitions.getBackgroundColor,
          getLineColor: transitions.getBorderColor,
          getLineWidth: transitions.getBorderWidth,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "background",
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getSize: updateTriggers.getSize,
          getFillColor: updateTriggers.getBackgroundColor,
          getLineColor: updateTriggers.getBorderColor,
          getLineWidth: updateTriggers.getBorderWidth,
          getPixelOffset: updateTriggers.getPixelOffset,
          getBoundingRect: {
            getText: updateTriggers.getText,
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data: (
          // @ts-ignore (2339) attribute is not defined on all data types
          data.attributes && data.attributes.background ? (
            // @ts-ignore (2339) attribute is not defined on all data types
            { length: data.length, attributes: data.attributes.background }
          ) : data
        ),
        _dataDiff,
        // Maintain the same background behavior as <=8.3. Remove in v9?
        autoHighlight: false,
        getBoundingRect: this.getBoundingRect
      }),
      new CharactersLayerClass({
        sdf: fontSettings.sdf,
        smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
        outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
        outlineColor,
        iconAtlas: atlas,
        iconMapping: mapping,
        getPosition,
        getColor,
        getSize,
        getAngle,
        getPixelOffset,
        billboard,
        sizeScale: sizeScale * scale,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale,
        sizeMaxPixels: sizeMaxPixels * scale,
        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: transitions.getPixelOffset
        }
      }, this.getSubLayerProps({
        id: "characters",
        updateTriggers: {
          all: updateTriggers.getText,
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getIconOffsets: {
            getTextAnchor: updateTriggers.getTextAnchor,
            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
            styleVersion
          }
        }
      }), {
        data,
        _dataDiff,
        startIndices,
        numInstances,
        getIconOffsets: this.getIconOffsets,
        getIcon: getText
      })
    ];
  }
  static set fontAtlasCacheLimit(limit) {
    setFontAtlasCacheLimit(limit);
  }
};
_TextLayer.defaultProps = defaultProps14;
_TextLayer.layerName = "TextLayer";
var TextLayer = _TextLayer;

// node_modules/@deck.gl/layers/dist/geojson-layer/sub-layer-map.js
var POINT_LAYER = {
  circle: {
    type: ScatterplotLayer,
    props: {
      filled: "filled",
      stroked: "stroked",
      lineWidthMaxPixels: "lineWidthMaxPixels",
      lineWidthMinPixels: "lineWidthMinPixels",
      lineWidthScale: "lineWidthScale",
      lineWidthUnits: "lineWidthUnits",
      pointRadiusMaxPixels: "radiusMaxPixels",
      pointRadiusMinPixels: "radiusMinPixels",
      pointRadiusScale: "radiusScale",
      pointRadiusUnits: "radiusUnits",
      pointAntialiasing: "antialiasing",
      pointBillboard: "billboard",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor",
      getLineWidth: "getLineWidth",
      getPointRadius: "getRadius"
    }
  },
  icon: {
    type: IconLayer,
    props: {
      iconAtlas: "iconAtlas",
      iconMapping: "iconMapping",
      iconSizeMaxPixels: "sizeMaxPixels",
      iconSizeMinPixels: "sizeMinPixels",
      iconSizeScale: "sizeScale",
      iconSizeUnits: "sizeUnits",
      iconAlphaCutoff: "alphaCutoff",
      iconBillboard: "billboard",
      getIcon: "getIcon",
      getIconAngle: "getAngle",
      getIconColor: "getColor",
      getIconPixelOffset: "getPixelOffset",
      getIconSize: "getSize"
    }
  },
  text: {
    type: TextLayer,
    props: {
      textSizeMaxPixels: "sizeMaxPixels",
      textSizeMinPixels: "sizeMinPixels",
      textSizeScale: "sizeScale",
      textSizeUnits: "sizeUnits",
      textBackground: "background",
      textBackgroundPadding: "backgroundPadding",
      textFontFamily: "fontFamily",
      textFontWeight: "fontWeight",
      textLineHeight: "lineHeight",
      textMaxWidth: "maxWidth",
      textOutlineColor: "outlineColor",
      textOutlineWidth: "outlineWidth",
      textWordBreak: "wordBreak",
      textCharacterSet: "characterSet",
      textBillboard: "billboard",
      textFontSettings: "fontSettings",
      getText: "getText",
      getTextAngle: "getAngle",
      getTextColor: "getColor",
      getTextPixelOffset: "getPixelOffset",
      getTextSize: "getSize",
      getTextAnchor: "getTextAnchor",
      getTextAlignmentBaseline: "getAlignmentBaseline",
      getTextBackgroundColor: "getBackgroundColor",
      getTextBorderColor: "getBorderColor",
      getTextBorderWidth: "getBorderWidth"
    }
  }
};
var LINE_LAYER = {
  type: PathLayer,
  props: {
    lineWidthUnits: "widthUnits",
    lineWidthScale: "widthScale",
    lineWidthMinPixels: "widthMinPixels",
    lineWidthMaxPixels: "widthMaxPixels",
    lineJointRounded: "jointRounded",
    lineCapRounded: "capRounded",
    lineMiterLimit: "miterLimit",
    lineBillboard: "billboard",
    getLineColor: "getColor",
    getLineWidth: "getWidth"
  }
};
var POLYGON_LAYER = {
  type: SolidPolygonLayer,
  props: {
    extruded: "extruded",
    filled: "filled",
    wireframe: "wireframe",
    elevationScale: "elevationScale",
    material: "material",
    _full3d: "_full3d",
    getElevation: "getElevation",
    getFillColor: "getFillColor",
    getLineColor: "getLineColor"
  }
};
function getDefaultProps({ type, props }) {
  const result = {};
  for (const key in props) {
    result[key] = type.defaultProps[props[key]];
  }
  return result;
}
function forwardProps(layer, mapping) {
  const { transitions, updateTriggers } = layer.props;
  const result = {
    updateTriggers: {},
    transitions: transitions && {
      getPosition: transitions.geometry
    }
  };
  for (const sourceKey in mapping) {
    const targetKey = mapping[sourceKey];
    let value = layer.props[sourceKey];
    if (sourceKey.startsWith("get")) {
      value = layer.getSubLayerAccessor(value);
      result.updateTriggers[targetKey] = updateTriggers[sourceKey];
      if (transitions) {
        result.transitions[targetKey] = transitions[sourceKey];
      }
    }
    result[targetKey] = value;
  }
  return result;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{ geometry: geojson }];
  }
}
function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  const { startRow = 0, endRow = features.length } = dataRange;
  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    const feature2 = features[featureIndex];
    const { geometry } = feature2;
    if (!geometry) {
      continue;
    }
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      const { geometries } = geometry;
      for (let i3 = 0; i3 < geometries.length; i3++) {
        const subGeometry = geometries[i3];
        separateGeometry(subGeometry, separated, wrapFeature, feature2, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature2, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  const { type, coordinates } = geometry;
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn(`${type} coordinates are malformed`)();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach((point2) => {
        pointFeatures.push(wrapFeature({
          geometry: { type: "Point", coordinates: point2 }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach((path) => {
        lineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach((path) => {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: { type: "LineString", coordinates: path }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach((polygon) => {
        polygonFeatures.push(wrapFeature({
          geometry: { type: "Polygon", coordinates: polygon }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach((path) => {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: { type: "LineString", coordinates: path }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
var COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};
function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer-props.js
function createEmptyLayerProps() {
  return {
    points: {},
    lines: {},
    polygons: {},
    polygonsOutline: {}
  };
}
function getCoordinates(f2) {
  return f2.geometry.coordinates;
}
function createLayerPropsFromFeatures(features, featuresDiff) {
  const layerProps = createEmptyLayerProps();
  const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
  layerProps.points.data = pointFeatures;
  layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
  layerProps.points.getPosition = getCoordinates;
  layerProps.lines.data = lineFeatures;
  layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
  layerProps.lines.getPath = getCoordinates;
  layerProps.polygons.data = polygonFeatures;
  layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
  layerProps.polygons.getPolygon = getCoordinates;
  layerProps.polygonsOutline.data = polygonOutlineFeatures;
  layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
  layerProps.polygonsOutline.getPath = getCoordinates;
  return layerProps;
}
function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
  const layerProps = createEmptyLayerProps();
  const { points, lines, polygons } = geojsonBinary;
  const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
  layerProps.points.data = {
    length: points.positions.value.length / points.positions.size,
    attributes: {
      ...points.attributes,
      getPosition: points.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.points
      }
    },
    properties: points.properties,
    numericProps: points.numericProps,
    featureIds: points.featureIds
  };
  layerProps.lines.data = {
    length: lines.pathIndices.value.length - 1,
    startIndices: lines.pathIndices.value,
    attributes: {
      ...lines.attributes,
      getPath: lines.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.lines
      }
    },
    properties: lines.properties,
    numericProps: lines.numericProps,
    featureIds: lines.featureIds
  };
  layerProps.lines._pathType = "open";
  layerProps.polygons.data = {
    length: polygons.polygonIndices.value.length - 1,
    startIndices: polygons.polygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPolygon: polygons.positions,
      pickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygons._normalize = false;
  if (polygons.triangles) {
    layerProps.polygons.data.attributes.indices = polygons.triangles.value;
  }
  layerProps.polygonsOutline.data = {
    length: polygons.primitivePolygonIndices.value.length - 1,
    startIndices: polygons.primitivePolygonIndices.value,
    attributes: {
      ...polygons.attributes,
      getPath: polygons.positions,
      instancePickingColors: {
        size: 3,
        value: customPickingColors.polygons
      }
    },
    properties: polygons.properties,
    numericProps: polygons.numericProps,
    featureIds: polygons.featureIds
  };
  layerProps.polygonsOutline._pathType = "open";
  return layerProps;
}

// node_modules/@deck.gl/layers/dist/geojson-layer/geojson-layer.js
var FEATURE_TYPES = ["points", "linestrings", "polygons"];
var defaultProps15 = {
  ...getDefaultProps(POINT_LAYER.circle),
  ...getDefaultProps(POINT_LAYER.icon),
  ...getDefaultProps(POINT_LAYER.text),
  ...getDefaultProps(LINE_LAYER),
  ...getDefaultProps(POLYGON_LAYER),
  // Overwrite sub layer defaults
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,
  _full3d: false,
  iconAtlas: { type: "object", value: null },
  iconMapping: { type: "object", value: {} },
  getIcon: { type: "accessor", value: (f2) => f2.properties.icon },
  getText: { type: "accessor", value: (f2) => f2.properties.text },
  // Self props
  pointType: "circle",
  // TODO: deprecated, remove in v9
  getRadius: { deprecatedFor: "getPointRadius" }
};
var _GeoJsonLayer = class _GeoJsonLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      layerProps: {},
      features: {},
      featuresDiff: {}
    };
  }
  updateState({ props, changeFlags }) {
    if (!changeFlags.dataChanged) {
      return;
    }
    const { data } = this.props;
    const binary = data && "points" in data && "polygons" in data && "lines" in data;
    this.setState({ binary });
    if (binary) {
      this._updateStateBinary({ props, changeFlags });
    } else {
      this._updateStateJSON({ props, changeFlags });
    }
  }
  _updateStateBinary({ props, changeFlags }) {
    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
    this.setState({ layerProps });
  }
  _updateStateJSON({ props, changeFlags }) {
    const features = getGeojsonFeatures(props.data);
    const wrapFeature = this.getSubLayerRow.bind(this);
    let newFeatures = {};
    const featuresDiff = {};
    if (Array.isArray(changeFlags.dataChanged)) {
      const oldFeatures = this.state.features;
      for (const key in oldFeatures) {
        newFeatures[key] = oldFeatures[key].slice();
        featuresDiff[key] = [];
      }
      for (const dataRange of changeFlags.dataChanged) {
        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
        for (const key in oldFeatures) {
          featuresDiff[key].push(replaceInRange({
            data: newFeatures[key],
            getIndex: (f2) => f2.__source.index,
            dataRange,
            replace: partialFeatures[key]
          }));
        }
      }
    } else {
      newFeatures = separateGeojsonFeatures(features, wrapFeature);
    }
    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
    this.setState({
      features: newFeatures,
      featuresDiff,
      layerProps
    });
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const { index, sourceLayer } = info;
    info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
      info.index = this.props.data.points.globalFeatureIds.value[index];
    }
    return info;
  }
  _updateAutoHighlight(info) {
    const pointLayerIdPrefix = `${this.id}-points-`;
    const sourceIsPoints = info.featureType === "points";
    for (const layer of this.getSubLayers()) {
      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  _renderPolygonLayer() {
    var _a;
    const { extruded, wireframe } = this.props;
    const { layerProps } = this.state;
    const id = "polygons-fill";
    const PolygonFillLayer = this.shouldRenderSubLayer(id, (_a = layerProps.polygons) == null ? void 0 : _a.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
    if (PolygonFillLayer) {
      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
      const useLineColor = extruded && wireframe;
      if (!useLineColor) {
        delete forwardedProps.getLineColor;
      }
      forwardedProps.updateTriggers.lineColors = useLineColor;
      return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({
        id,
        updateTriggers: forwardedProps.updateTriggers
      }), layerProps.polygons);
    }
    return null;
  }
  _renderLineLayers() {
    var _a, _b;
    const { extruded, stroked } = this.props;
    const { layerProps } = this.state;
    const polygonStrokeLayerId = "polygons-stroke";
    const lineStringsLayerId = "linestrings";
    const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, (_a = layerProps.polygonsOutline) == null ? void 0 : _a.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
    const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, (_b = layerProps.lines) == null ? void 0 : _b.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
    if (PolygonStrokeLayer || LineStringsLayer) {
      const forwardedProps = forwardProps(this, LINE_LAYER.props);
      return [
        PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({
          id: polygonStrokeLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.polygonsOutline),
        LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({
          id: lineStringsLayerId,
          updateTriggers: forwardedProps.updateTriggers
        }), layerProps.lines)
      ];
    }
    return null;
  }
  _renderPointLayers() {
    var _a;
    const { pointType } = this.props;
    const { layerProps, binary } = this.state;
    let { highlightedObjectIndex } = this.props;
    if (!binary && Number.isFinite(highlightedObjectIndex)) {
      highlightedObjectIndex = layerProps.points.data.findIndex((d) => d.__source.index === highlightedObjectIndex);
    }
    const types = new Set(pointType.split("+"));
    const pointLayers = [];
    for (const type of types) {
      const id = `points-${type}`;
      const PointLayerMapping = POINT_LAYER[type];
      const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, (_a = layerProps.points) == null ? void 0 : _a.data) && this.getSubLayerClass(id, PointLayerMapping.type);
      if (PointsLayer) {
        const forwardedProps = forwardProps(this, PointLayerMapping.props);
        let pointsLayerProps = layerProps.points;
        if (type === "text" && binary) {
          const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
          pointsLayerProps = {
            ...pointsLayerProps,
            // @ts-expect-error TODO - type binary data
            data: { ...pointsLayerProps.data, attributes: rest }
          };
        }
        pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({
          id,
          updateTriggers: forwardedProps.updateTriggers,
          highlightedObjectIndex
        }), pointsLayerProps));
      }
    }
    return pointLayers;
  }
  renderLayers() {
    const { extruded } = this.props;
    const polygonFillLayer = this._renderPolygonLayer();
    const lineLayers = this._renderLineLayers();
    const pointLayers = this._renderPointLayers();
    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      lineLayers,
      pointLayers,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  getSubLayerAccessor(accessor) {
    const { binary } = this.state;
    if (!binary || typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const feature2 = binaryToFeatureForAccesor(data, index);
      return accessor(feature2, info);
    };
  }
};
_GeoJsonLayer.layerName = "GeoJsonLayer";
_GeoJsonLayer.defaultProps = defaultProps15;
var GeoJsonLayer = _GeoJsonLayer;

// node_modules/@loaders.gl/xml/dist/sax-ts/sax.js
var DEFAULT_SAX_EVENTS = {
  ontext: () => {
  },
  onprocessinginstruction: () => {
  },
  onsgmldeclaration: () => {
  },
  ondoctype: () => {
  },
  oncomment: () => {
  },
  onopentagstart: () => {
  },
  onattribute: () => {
  },
  onopentag: () => {
  },
  onclosetag: () => {
  },
  onopencdata: () => {
  },
  oncdata: () => {
  },
  onclosecdata: () => {
  },
  onerror: () => {
  },
  onend: () => {
  },
  onready: () => {
  },
  onscript: () => {
  },
  onopennamespace: () => {
  },
  onclosenamespace: () => {
  }
};
var DEFAULT_SAX_PARSER_OPTIONS = {
  ...DEFAULT_SAX_EVENTS,
  strict: false,
  MAX_BUFFER_LENGTH: 64 * 1024,
  lowercase: false,
  lowercasetags: false,
  noscript: false,
  strictEntities: false,
  xmlns: void 0,
  position: void 0,
  trim: void 0,
  normalize: void 0
};
var ENTITIES = {
  amp: "&",
  gt: ">",
  lt: "<",
  quot: '"',
  apos: "'",
  AElig: 198,
  Aacute: 193,
  Acirc: 194,
  Agrave: 192,
  Aring: 197,
  Atilde: 195,
  Auml: 196,
  Ccedil: 199,
  ETH: 208,
  Eacute: 201,
  Ecirc: 202,
  Egrave: 200,
  Euml: 203,
  Iacute: 205,
  Icirc: 206,
  Igrave: 204,
  Iuml: 207,
  Ntilde: 209,
  Oacute: 211,
  Ocirc: 212,
  Ograve: 210,
  Oslash: 216,
  Otilde: 213,
  Ouml: 214,
  THORN: 222,
  Uacute: 218,
  Ucirc: 219,
  Ugrave: 217,
  Uuml: 220,
  Yacute: 221,
  aacute: 225,
  acirc: 226,
  aelig: 230,
  agrave: 224,
  aring: 229,
  atilde: 227,
  auml: 228,
  ccedil: 231,
  eacute: 233,
  ecirc: 234,
  egrave: 232,
  eth: 240,
  euml: 235,
  iacute: 237,
  icirc: 238,
  igrave: 236,
  iuml: 239,
  ntilde: 241,
  oacute: 243,
  ocirc: 244,
  ograve: 242,
  oslash: 248,
  otilde: 245,
  ouml: 246,
  szlig: 223,
  thorn: 254,
  uacute: 250,
  ucirc: 251,
  ugrave: 249,
  uuml: 252,
  yacute: 253,
  yuml: 255,
  copy: 169,
  reg: 174,
  nbsp: 160,
  iexcl: 161,
  cent: 162,
  pound: 163,
  curren: 164,
  yen: 165,
  brvbar: 166,
  sect: 167,
  uml: 168,
  ordf: 170,
  laquo: 171,
  not: 172,
  shy: 173,
  macr: 175,
  deg: 176,
  plusmn: 177,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  acute: 180,
  micro: 181,
  para: 182,
  middot: 183,
  cedil: 184,
  ordm: 186,
  raquo: 187,
  frac14: 188,
  frac12: 189,
  frac34: 190,
  iquest: 191,
  times: 215,
  divide: 247,
  OElig: 338,
  oelig: 339,
  Scaron: 352,
  scaron: 353,
  Yuml: 376,
  fnof: 402,
  circ: 710,
  tilde: 732,
  Alpha: 913,
  Beta: 914,
  Gamma: 915,
  Delta: 916,
  Epsilon: 917,
  Zeta: 918,
  Eta: 919,
  Theta: 920,
  Iota: 921,
  Kappa: 922,
  Lambda: 923,
  Mu: 924,
  Nu: 925,
  Xi: 926,
  Omicron: 927,
  Pi: 928,
  Rho: 929,
  Sigma: 931,
  Tau: 932,
  Upsilon: 933,
  Phi: 934,
  Chi: 935,
  Psi: 936,
  Omega: 937,
  alpha: 945,
  beta: 946,
  gamma: 947,
  delta: 948,
  epsilon: 949,
  zeta: 950,
  eta: 951,
  theta: 952,
  iota: 953,
  kappa: 954,
  lambda: 955,
  mu: 956,
  nu: 957,
  xi: 958,
  omicron: 959,
  pi: 960,
  rho: 961,
  sigmaf: 962,
  sigma: 963,
  tau: 964,
  upsilon: 965,
  phi: 966,
  chi: 967,
  psi: 968,
  omega: 969,
  thetasym: 977,
  upsih: 978,
  piv: 982,
  ensp: 8194,
  emsp: 8195,
  thinsp: 8201,
  zwnj: 8204,
  zwj: 8205,
  lrm: 8206,
  rlm: 8207,
  ndash: 8211,
  mdash: 8212,
  lsquo: 8216,
  rsquo: 8217,
  sbquo: 8218,
  ldquo: 8220,
  rdquo: 8221,
  bdquo: 8222,
  dagger: 8224,
  Dagger: 8225,
  bull: 8226,
  hellip: 8230,
  permil: 8240,
  prime: 8242,
  Prime: 8243,
  lsaquo: 8249,
  rsaquo: 8250,
  oline: 8254,
  frasl: 8260,
  euro: 8364,
  image: 8465,
  weierp: 8472,
  real: 8476,
  trade: 8482,
  alefsym: 8501,
  larr: 8592,
  uarr: 8593,
  rarr: 8594,
  darr: 8595,
  harr: 8596,
  crarr: 8629,
  lArr: 8656,
  uArr: 8657,
  rArr: 8658,
  dArr: 8659,
  hArr: 8660,
  forall: 8704,
  part: 8706,
  exist: 8707,
  empty: 8709,
  nabla: 8711,
  isin: 8712,
  notin: 8713,
  ni: 8715,
  prod: 8719,
  sum: 8721,
  minus: 8722,
  lowast: 8727,
  radic: 8730,
  prop: 8733,
  infin: 8734,
  ang: 8736,
  and: 8743,
  or: 8744,
  cap: 8745,
  cup: 8746,
  int: 8747,
  there4: 8756,
  sim: 8764,
  cong: 8773,
  asymp: 8776,
  ne: 8800,
  equiv: 8801,
  le: 8804,
  ge: 8805,
  sub: 8834,
  sup: 8835,
  nsub: 8836,
  sube: 8838,
  supe: 8839,
  oplus: 8853,
  otimes: 8855,
  perp: 8869,
  sdot: 8901,
  lceil: 8968,
  rceil: 8969,
  lfloor: 8970,
  rfloor: 8971,
  lang: 9001,
  rang: 9002,
  loz: 9674,
  spades: 9824,
  clubs: 9827,
  hearts: 9829,
  diams: 9830
};
Object.keys(ENTITIES).forEach((key) => {
  const e2 = ENTITIES[key];
  ENTITIES[key] = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
});

// node_modules/@loaders.gl/xml/dist/lib/xml-utils/uncapitalize.js
function uncapitalize(str) {
  return typeof str === "string" ? str.charAt(0).toLowerCase() + str.slice(1) : str;
}
function uncapitalizeKeys(object) {
  if (Array.isArray(object)) {
    return object.map((element) => uncapitalizeKeys(element));
  }
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize(key)] = uncapitalizeKeys(value);
    }
    return newObject;
  }
  return object;
}

// node_modules/@loaders.gl/xml/dist/lib/parsers/parse-xml.js
var import_fast_xml_parser = __toESM(require_fxp(), 1);
function parseXMLSync(text, options) {
  if ((options == null ? void 0 : options._parser) && options._parser !== "fast-xml-parser") {
    throw new Error(options == null ? void 0 : options._parser);
  }
  const fastXMLOptions = {
    // Default FastXML options
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#allowbooleanattributes
    allowBooleanAttributes: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#ignoredeclaration
    ignoreDeclaration: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#removensprefix
    removeNSPrefix: options == null ? void 0 : options.removeNSPrefix,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#textnodename
    textNodeName: options == null ? void 0 : options.textNodeName,
    // Let's application specify keys that are always arrays
    isArray: (name12, jpath, isLeafNode, isAttribute) => {
      var _a;
      const array = Boolean((_a = options == null ? void 0 : options.arrayPaths) == null ? void 0 : _a.some((path) => jpath === path));
      return array;
    },
    // Application overrides
    ...options == null ? void 0 : options._fastXML
  };
  const xml = fastParseXML(text, fastXMLOptions);
  return (options == null ? void 0 : options.uncapitalizeKeys) ? uncapitalizeKeys(xml) : xml;
}
function fastParseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}

// node_modules/@loaders.gl/xml/dist/xml-loader.js
var VERSION = true ? "4.2.0-beta.2" : "latest";
var XMLLoader = {
  dataType: null,
  batchType: null,
  name: "XML",
  id: "xml",
  module: "xml",
  version: VERSION,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/xml", "text/xml"],
  testText: testXMLFile,
  options: {
    xml: {
      _parser: "fast-xml-parser",
      uncapitalizeKeys: false,
      removeNSPrefix: false,
      textNodeName: "value",
      arrayPaths: []
    }
  },
  parse: async (arrayBuffer, options) => parseXMLSync(new TextDecoder().decode(arrayBuffer), {
    ...XMLLoader.options.xml,
    ...options == null ? void 0 : options.xml
  }),
  parseTextSync: (text, options) => parseXMLSync(text, { ...XMLLoader.options.xml, ...options == null ? void 0 : options.xml })
};
function testXMLFile(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/xml/dist/html-loader.js
var HTMLLoader = {
  ...XMLLoader,
  name: "HTML",
  id: "html",
  extensions: ["html", "htm"],
  mimeTypes: ["text/html"],
  testText: testHTMLFile,
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync(text, options)
};
function testHTMLFile(text) {
  return text.startsWith("<html");
}
function parseTextSync(text, options) {
  var _a, _b;
  options = mergeLoaderOptions(options, {
    xml: {
      _parser: "fast-xml-parser",
      _fastXML: {
        htmlEntities: true
      }
    }
  });
  return (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-error.js
function parseWMSError(text, options) {
  var _a, _b, _c, _d;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const serviceExceptionXML = ((_c = parsedXML == null ? void 0 : parsedXML.ServiceExceptionReport) == null ? void 0 : _c.ServiceException) || ((_d = parsedXML == null ? void 0 : parsedXML["ogc:ServiceExceptionReport"]) == null ? void 0 : _d["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
  return message;
}

// node_modules/@loaders.gl/wms/dist/wms-error-loader.js
var VERSION2 = true ? "4.2.0-beta.2" : "latest";
var WMSErrorLoader = {
  dataType: null,
  batchType: null,
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: VERSION2,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: testXMLFile2,
  options: {
    wms: {
      throwOnError: false
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseSync: (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync2(text, options)
};
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}
function parseTextSync2(text, options) {
  const wmsOptions = { ...WMSErrorLoader.options.wms, ...options == null ? void 0 : options.wms };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/xml/parse-xml-helpers.js
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function getXMLStringArray(xmlValue) {
  const xmlArray = getXMLArray(xmlValue);
  if (xmlArray.length > 0 && xmlArray.every((_2) => typeof _2 === "string")) {
    return xmlArray;
  }
  return [];
}
function getXMLFloat(xmlValue, defaultValue2 = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseFloat(xmlValue);
    default:
      return void 0;
  }
}
function getXMLInteger(xmlValue, defaultValue2 = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseInt(xmlValue, 10);
    default:
      return void 0;
  }
}
function getXMLBoolean(xmlValue) {
  switch (xmlValue) {
    case "true":
      return true;
    case "false":
      return false;
    case "1":
      return true;
    case "0":
      return false;
    default:
      return false;
  }
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js
function parseWMSCapabilities(xmlText, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options == null ? void 0 : options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options == null ? void 0 : options.includeRawJSON) {
    capabilities.json = xmlCapabilities;
  }
  if (options == null ? void 0 : options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const capabilities = {
    version: String(xml.version || ""),
    name: String(((_a = xml.Service) == null ? void 0 : _a.Name) || "unnamed"),
    title: ((_b = xml.Service) == null ? void 0 : _b.Title) ? String((_c = xml.Service) == null ? void 0 : _c.Title) : void 0,
    abstract: ((_d = xml.Service) == null ? void 0 : _d.Abstract) ? String((_e = xml.Service) == null ? void 0 : _e.Abstract) : void 0,
    keywords: getXMLStringArray((_g = (_f = xml.Service) == null ? void 0 : _f.KeywordList) == null ? void 0 : _g.Keyword),
    fees: ((_h = xml.Service) == null ? void 0 : _h.Fees) ? JSON.stringify((_i = xml.Service) == null ? void 0 : _i.Fees) : void 0,
    accessConstraints: ((_j = xml.Service) == null ? void 0 : _j.AccessConstraints) ? JSON.stringify((_k = xml.Service) == null ? void 0 : _k.AccessConstraints) : void 0,
    layerLimit: getXMLInteger((_l = xml.Service) == null ? void 0 : _l.LayerLimit),
    maxWidth: getXMLInteger((_m = xml.Service) == null ? void 0 : _m.maxWidth),
    maxHeight: getXMLInteger((_n = xml.Service) == null ? void 0 : _n.maxHeight),
    layers: [],
    requests: extractRequests((_o = xml.Capability) == null ? void 0 : _o.Request),
    exceptions: extractExceptions(xml.Exception)
    // contact field is a mess of largely irrelevant information, put it last
    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
  };
  const xmlLayers = getXMLArray((_p = xml.Capability) == null ? void 0 : _p.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === void 0) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name12, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest == null ? void 0 : xmlRequest.Format);
    requests[name12] = { mimeTypes };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException == null ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return void 0;
}
function extractLayer(xmlLayer) {
  var _a;
  const layer = {
    // All layers must have a title
    title: String((xmlLayer == null ? void 0 : xmlLayer.Title) || ""),
    // Name is required only if renderable
    name: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_a = xmlLayer.KeywordList) == null ? void 0 : _a.Keyword)
  };
  const crs = (xmlLayer == null ? void 0 : xmlLayer.CRS) || (xmlLayer == null ? void 0 : xmlLayer.SRS);
  if (crs && Array.isArray(crs) && crs.every((_2) => typeof _2 === "string")) {
    layer.crs = crs;
  }
  let geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer == null ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer == null ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer == null ? void 0 : xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === void 0) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const { westBoundLongitude: w, northBoundLatitude: n2, eastBoundLongitude: e2, southBoundLatitude: s2 } = xmlBoundingBox;
  return [
    [w, s2],
    [e2, n2]
  ];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const { minx, miny, maxx, maxy } = xmlBoundingBox;
  return [
    [minx, miny],
    [maxx, maxy]
  ];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const { CRS, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
  const boundingBox = {
    // CRS in 1.3.0, SRS in 1.1.1
    crs: CRS || SRS,
    boundingBox: [
      [getXMLFloat(minx), getXMLFloat(miny)],
      [getXMLFloat(maxx), getXMLFloat(maxy)]
    ]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const { name: name12, units, value: extent } = xmlDimension;
  const dimension = { name: name12, units, extent };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if ((parent == null ? void 0 : parent.geographicBoundingBox) && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if ((parent == null ? void 0 : parent.crs) && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if ((parent == null ? void 0 : parent.boundingBoxes) && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if ((parent == null ? void 0 : parent.dimensions) && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}

// node_modules/@loaders.gl/wms/dist/wms-capabilities-loader.js
var VERSION3 = true ? "4.2.0-beta.2" : "latest";
var WMSCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: VERSION3,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: testXMLFile3,
  options: {
    wms: {}
  },
  parse: async (arrayBuffer, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options == null ? void 0 : options.wms)
  ),
  parseTextSync: (text, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(text, options == null ? void 0 : options.wms)
  )
};
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-features.js
function parseWMSFeatureInfo(text, options) {
  var _a, _b, _c;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const xmlFeatureInfo = ((_c = parsedXML.FeatureInfoResponse) == null ? void 0 : _c.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}

// node_modules/@loaders.gl/wms/dist/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-layer-description.js
function parseWMSLayerDescription(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  return parsedXML;
}

// node_modules/@loaders.gl/wms/dist/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/gml/deep-strict-equal.js
var pSlice = Array.prototype.slice;

// node_modules/@turf/helpers/main.es.js
var earthRadius = 63710088e-1;
var factors = {
  meters: earthRadius,
  metres: earthRadius,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  miles: earthRadius / 1609.344,
  nauticalmiles: earthRadius / 1852,
  inches: earthRadius * 39.37,
  yards: earthRadius / 1.0936,
  feet: earthRadius * 3.28084,
  radians: 1,
  degrees: earthRadius / 111325
};
var unitsFactors = {
  meters: 1,
  metres: 1,
  millimeters: 1e3,
  millimetres: 1e3,
  centimeters: 100,
  centimetres: 100,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  miles: 1 / 1609.344,
  nauticalmiles: 1 / 1852,
  inches: 39.37,
  yards: 1 / 1.0936,
  feet: 3.28084,
  radians: 1 / earthRadius,
  degrees: 1 / 111325
};

// node_modules/@loaders.gl/wms/dist/lib/services/create-image-service.js
function createImageService(props, services) {
  const { type = "auto" } = props;
  const service = type === "auto" ? guessServiceType(props.url, services) : getServiceOfType(type, services);
  if (!service) {
    throw new Error("Not a valid image source type");
  }
  return service.create(props);
}
function getServiceOfType(type, services) {
  for (const service of services) {
    if (service.type === type) {
      return service;
    }
  }
  return null;
}
function guessServiceType(url, services) {
  for (const service of services) {
    if (service.testURL && service.testURL(url)) {
      return service;
    }
  }
  return null;
}

// node_modules/@loaders.gl/wms/dist/services/ogc/wms-service.js
var WMSService = {
  type: "wms",
  testURL: (url) => url.toLowerCase().includes("wms"),
  create: (props) => new WMSSource(props)
};
var WMSSource = class extends ImageSource {
  /** Create a WMSSource */
  constructor(props) {
    super(props);
    /** Base URL to the service */
    __publicField(this, "url");
    __publicField(this, "data");
    /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
    __publicField(this, "substituteCRS84");
    /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
    __publicField(this, "flipCRS");
    /** Default static WMS parameters */
    __publicField(this, "wmsParameters");
    /** Default static vendor parameters */
    __publicField(this, "vendorParameters");
    __publicField(this, "capabilities", null);
    this.url = props.url;
    this.data = props.url;
    this.substituteCRS84 = props.substituteCRS84 ?? false;
    this.flipCRS = ["EPSG:4326"];
    this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...props.wmsParameters
    };
    this.vendorParameters = props.vendorParameters || {};
  }
  // ImageService implementation
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  async getImage(parameters2) {
    const { boundingBox, bbox, ...rest } = parameters2;
    const wmsParameters = {
      bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
      ...rest
    };
    return await this.getMap(wmsParameters);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  // WMS Service API Stubs
  /** Get Capabilities */
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
    this.capabilities = capabilities;
    return capabilities;
  }
  /** Get a map image */
  async getMap(wmsParameters, vendorParameters) {
    const url = this.getMapURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfo(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfoText(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return new TextDecoder().decode(arrayBuffer);
  }
  /** Get more information about a layer */
  async describeLayer(wmsParameters, vendorParameters) {
    const url = this.describeLayerURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get an image with a semantic legend */
  async getLegendGraphic(wmsParameters, vendorParameters) {
    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetCapabilities", options, vendorParameters);
  }
  /** Generate a URL for the GetMap request */
  getMapURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const options = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      ...wmsParameters
    };
    return this._getWMSUrl("GetMap", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  getFeatureInfoURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const { boundingBox, bbox } = wmsParameters;
    wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;
    const options = {
      version: this.wmsParameters.version,
      // query_layers: [],
      // format: this.wmsParameters.format,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      // x: undefined!,
      // y: undefined!,
      ...wmsParameters
    };
    return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  describeLayerURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("DescribeLayer", options, vendorParameters);
  }
  getLegendGraphicURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      // format?
      ...wmsParameters
    };
    return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
  }
  // INTERNAL METHODS
  _parseWMSUrl(url) {
    const [baseUrl, search] = url.split("?");
    const searchParams = search.split("&");
    const parameters2 = {};
    for (const parameter of searchParams) {
      const [key, value] = parameter.split("=");
      parameters2[key] = value;
    }
    return { url: baseUrl, parameters: parameters2 };
  }
  /**
   * Generate a URL with parameters
   * @note case _getWMSUrl may need to be overridden to handle certain backends?
   * @note at the moment, only URLs with parameters are supported (no XML payloads)
   * */
  _getWMSUrl(request, wmsParameters, vendorParameters) {
    let url = this.url;
    let first = true;
    const allParameters = {
      service: "WMS",
      version: wmsParameters.version,
      request,
      ...wmsParameters,
      ...this.vendorParameters,
      ...vendorParameters
    };
    const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
    for (const [key, value] of Object.entries(allParameters)) {
      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
        url += first ? "?" : "&";
        first = false;
        url += this._getURLParameter(key, value, wmsParameters);
      }
    }
    return encodeURI(url);
  }
  _getWMS130Parameters(wmsParameters) {
    const newParameters = { ...wmsParameters };
    if (newParameters.srs) {
      newParameters.crs = newParameters.crs || newParameters.srs;
      delete newParameters.srs;
    }
    return newParameters;
  }
  // eslint-disable-next-line complexity
  _getURLParameter(key, value, wmsParameters) {
    switch (key) {
      case "crs":
        if (wmsParameters.version !== "1.3.0") {
          key = "srs";
        } else if (this.substituteCRS84 && value === "EPSG:4326") {
          value = "CRS:84";
        }
        break;
      case "srs":
        if (wmsParameters.version === "1.3.0") {
          key = "crs";
        }
        break;
      case "bbox":
        const bbox = this._flipBoundingBox(value, wmsParameters);
        if (bbox) {
          value = bbox;
        }
        break;
      case "x":
        if (wmsParameters.version === "1.3.0") {
          key = "i";
        }
        break;
      case "y":
        if (wmsParameters.version === "1.3.0") {
          key = "j";
        }
        break;
      default:
    }
    key = key.toUpperCase();
    return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
  }
  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
  _flipBoundingBox(bboxValue, wmsParameters) {
    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
      return null;
    }
    const flipCoordinates = (
      // Only affects WMS 1.3.0
      wmsParameters.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
      this.flipCRS.includes(wmsParameters.crs || "") && // Don't flip if we are subsituting EPSG:4326 with CRS:84
      !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326")
    );
    const bbox = bboxValue;
    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  }
  /** Fetches an array buffer and checks the response (boilerplate reduction) */
  async _fetchArrayBuffer(url) {
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return arrayBuffer;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  _checkResponse(response, arrayBuffer) {
    var _a, _b;
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const loadOptions = mergeLoaderOptions(this.loadOptions, {
        wms: { throwOnError: true }
      });
      const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, loadOptions);
      throw new Error(error);
    }
  }
  /** Error situation detected */
  _parseError(arrayBuffer) {
    var _a, _b;
    const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.loadOptions);
    return new Error(error);
  }
};

// node_modules/@loaders.gl/wms/dist/lib/services/image-service.js
var ImageService = class extends ImageSource {
  constructor(props) {
    super(props);
  }
  // IMAGE SOURCE API
  async getMetadata() {
    throw new Error("ImageSource.getMetadata not implemented");
  }
  async getImage(parameters2) {
    const granularParameters = this.getGranularParameters(parameters2);
    const url = this.getURLFromTemplate(granularParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    return await ImageLoader.parse(arrayBuffer);
  }
  // HELPERS
  /** Break up bounding box in east, north, south, west */
  getGranularParameters(parameters2) {
    const [[east, north], [west, south]] = parameters2.boundingBox;
    return { ...parameters2, east, north, south, west };
  }
  /** Supports both ${} and {} notations */
  getURLFromTemplate(parameters2) {
    let url = this.props.url;
    for (const [key, value] of Object.entries(parameters2)) {
      url = url.replace(`\${${key}}`, String(value));
      url = url.replace(`{${key}}`, String(value));
    }
    return url;
  }
};
__publicField(ImageService, "type", "template");
__publicField(ImageService, "testURL", (url) => url.toLowerCase().includes("{"));

// node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-service.js
var ArcGISImageSource = class extends ImageService {
  constructor(props) {
    super(props);
    __publicField(this, "data");
    this.data = props.url;
  }
  // ImageSource (normalized endpoints)
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(parameters2) {
    throw new Error("not implemented");
  }
  // ImageServer endpoints
  async metadata() {
    throw new Error("not implemented");
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
   */
  exportImage(options) {
    throw new Error("not implemented");
  }
  // URL creators
  metadataURL(options) {
    return `${this.props.url}?f=pjson`;
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
   //   f=image
   */
  exportImageURL(options) {
    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
    const size = `size=${options.width},${options.height}`;
    const arcgisOptions = { ...options, bbox, size };
    delete arcgisOptions.width;
    delete arcgisOptions.height;
    return this.getUrl("exportImage", arcgisOptions);
  }
  // INTERNAL METHODS
  /**
   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
   * @note if override is common, maybe add a callback prop?
   * */
  getUrl(path, options, extra) {
    let url = `${this.props.url}/${path}`;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += `${key.toUpperCase()}=${value.join(",")}`;
      } else {
        url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
      }
    }
    return url;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  async checkResponse(response) {
    if (!response.ok) {
      throw new Error("error");
    }
  }
};
var ArcGISImageService = {
  type: "arcgis-image-server",
  testURL: (url) => url.toLowerCase().includes("ImageServer"),
  create: (props) => new ArcGISImageSource(props)
};

// node_modules/@loaders.gl/wms/dist/services/create-image-source.js
var SERVICES = [WMSService, ArcGISImageService];
function createImageSource(props) {
  return createImageService(props, SERVICES);
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/utils.js
var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/wms-layer.js
var defaultProps16 = {
  id: "imagery-layer",
  data: "",
  serviceType: "auto",
  srs: "auto",
  layers: { type: "array", compare: true, value: [] },
  onMetadataLoad: { type: "function", value: () => {
  } },
  // eslint-disable-next-line
  onMetadataLoadError: { type: "function", value: console.error },
  onImageLoadStart: { type: "function", value: () => {
  } },
  onImageLoad: { type: "function", value: () => {
  } },
  onImageLoadError: {
    type: "function",
    compare: false,
    // eslint-disable-next-line
    value: (requestId, error) => console.error(error, requestId)
  }
};
var _WMSLayer = class _WMSLayer extends CompositeLayer {
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    var _a;
    return ((_a = this.state) == null ? void 0 : _a.loadCounter) === 0 && super.isLoaded;
  }
  /** Lets deck.gl know that we want viewport change events */
  shouldUpdateState() {
    return true;
  }
  initializeState() {
    this.state._nextRequestId = 0;
    this.state.lastRequestId = -1;
    this.state.loadCounter = 0;
  }
  updateState({ changeFlags, props, oldProps }) {
    const { viewport } = this.context;
    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
      this.state.imageSource = this._createImageSource(props);
      this._loadMetadata();
      this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
      this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
    } else if (changeFlags.viewportChanged) {
      this.debounce(() => this.loadImage(viewport, "viewport changed"));
    }
  }
  finalizeState() {
  }
  renderLayers() {
    const { bounds, image, lastRequestParameters } = this.state;
    return image && new BitmapLayer({
      ...this.getSubLayerProps({ id: "bitmap" }),
      _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
      bounds,
      image
    });
  }
  async getFeatureInfoText(x2, y2) {
    var _a, _b;
    const { lastRequestParameters } = this.state;
    if (lastRequestParameters) {
      const featureInfo = await ((_b = (_a = this.state.imageSource).getFeatureInfoText) == null ? void 0 : _b.call(_a, {
        ...lastRequestParameters,
        query_layers: lastRequestParameters.layers,
        x: x2,
        y: y2,
        info_format: "application/vnd.ogc.gml"
      }));
      return featureInfo;
    }
    return "";
  }
  _createImageSource(props) {
    if (props.data instanceof ImageSource) {
      return props.data;
    }
    if (typeof props.data === "string") {
      return createImageSource({
        url: props.data,
        loadOptions: props.loadOptions,
        type: props.serviceType
      });
    }
    throw new Error("invalid image source in props.data");
  }
  /** Run a getMetadata on the image service */
  async _loadMetadata() {
    var _a, _b;
    const { imageSource } = this.state;
    try {
      this.state.loadCounter++;
      const metadata = await imageSource.getMetadata();
      if (this.state.imageSource === imageSource) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onMetadataLoad(metadata);
      }
    } catch (error) {
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onMetadataLoadError(error);
    } finally {
      this.state.loadCounter--;
    }
  }
  /** Load an image */
  async loadImage(viewport, reason) {
    var _a, _b;
    const { layers, serviceType } = this.props;
    if (serviceType === "wms" && layers.length === 0) {
      return;
    }
    const bounds = viewport.getBounds();
    const { width, height } = viewport;
    const requestId = this.getRequestId();
    let { srs } = this.props;
    if (srs === "auto") {
      srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
    }
    const requestParams = {
      width,
      height,
      boundingBox: [
        [bounds[0], bounds[1]],
        [bounds[2], bounds[3]]
      ],
      layers,
      crs: srs
    };
    if (srs === "EPSG:3857") {
      const min = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
      const max = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
      requestParams.boundingBox = [min, max];
    }
    try {
      this.state.loadCounter++;
      this.props.onImageLoadStart(requestId);
      const image = await this.state.imageSource.getImage(requestParams);
      if (this.state.lastRequestId < requestId) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onImageLoad(requestId);
        this.setState({
          image,
          bounds,
          lastRequestParameters: requestParams,
          lastRequestId: requestId
        });
      }
    } catch (error) {
      this.raiseError(error, "Load image");
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onImageLoadError(requestId, error);
    } finally {
      this.state.loadCounter--;
    }
  }
  // HELPERS
  /** Global counter for issuing unique request ids */
  getRequestId() {
    return this.state._nextRequestId++;
  }
  /** Runs an action in the future, cancels it if the new action is issued before it executes */
  debounce(fn, ms = 500) {
    clearTimeout(this.state._timeoutId);
    this.state._timeoutId = setTimeout(() => fn(), ms);
  }
};
_WMSLayer.layerName = "WMSLayer";
_WMSLayer.defaultProps = defaultProps16;
var WMSLayer = _WMSLayer;

// node_modules/@deck.gl/geo-layers/dist/great-circle-layer/great-circle-layer.js
var defaultProps17 = {
  getHeight: { type: "accessor", value: 0 },
  greatCircle: true
};
var _GreatCircleLayer = class _GreatCircleLayer extends ArcLayer {
};
_GreatCircleLayer.layerName = "GreatCircleLayer";
_GreatCircleLayer.defaultProps = defaultProps17;
var GreatCircleLayer = _GreatCircleLayer;

// node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js
var defaultProps18 = {
  ...PolygonLayer.defaultProps
};
var _GeoCellLayer = class _GeoCellLayer extends CompositeLayer {
  /** Implement to generate props to create geometry. */
  indexToBounds() {
    return null;
  }
  renderLayers() {
    const { elevationScale, extruded, wireframe, filled, stroked, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified, getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    const { updateTriggers, material, transitions } = this.props;
    const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
    const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
    return new CellLayer({
      filled,
      wireframe,
      extruded,
      elevationScale,
      stroked,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      material,
      transitions,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    }, this.getSubLayerProps({
      id: "cell",
      updateTriggers: updateTriggers && {
        ...boundsUpdateTriggers,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    }), boundsProps);
  }
};
_GeoCellLayer.layerName = "GeoCellLayer";
_GeoCellLayer.defaultProps = defaultProps18;
var GeoCellLayer = _GeoCellLayer;

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-geometry.js
var import_long = __toESM(require_long(), 1);
var FACE_BITS = 3;
var MAX_LEVEL = 30;
var POS_BITS = 2 * MAX_LEVEL + 1;
var RADIAN_TO_DEGREE = 180 / Math.PI;
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x2, y2, z]) {
  const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
  const lng = Math.atan2(y2, x2);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return `${faceS}/${posS}`;
}
function rotateAndFlipQuadrant(n2, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n2 - 1 - point2[0];
      point2[1] = n2 - 1 - point2[1];
    }
    const x2 = point2[0];
    point2[0] = point2[1];
    point2[1] = x2;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point2 = [0, 0];
  let level;
  for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
    level = maxLevel - i3;
    const bit = position[i3];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val2 = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val2, point2, rx, ry);
    point2[0] += val2 * rx;
    point2[1] += val2 * ry;
  }
  if (face % 2 === 1) {
    const t2 = point2[0];
    point2[0] = point2[1];
    point2[1] = t2;
  }
  return { face, ij: point2, level };
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-utils.js
var import_long2 = __toESM(require_long(), 1);
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
var MAX_RESOLUTION = 100;
function getGeoBounds({ face, ij, level }) {
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i3 = 0; i3 < 4; i3++) {
    const offset = offsets[i3].slice(0);
    const nextOffset = offsets[i3 + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-layer.js
var defaultProps19 = {
  getS2Token: { type: "accessor", value: (d) => d.token }
};
var _S2Layer = class _S2Layer extends GeoCellLayer {
  indexToBounds() {
    const { data, getS2Token } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getS2Polygon(getS2Token(x2, objectInfo))
    };
  }
};
_S2Layer.layerName = "S2Layer";
_S2Layer.defaultProps = defaultProps19;
var S2Layer = _S2Layer;

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-utils.js
var TILE_SIZE = 512;
function quadkeyToWorldBounds(quadkey, coverage) {
  let x2 = 0;
  let y2 = 0;
  let mask = 1 << quadkey.length;
  const scale = mask / TILE_SIZE;
  for (let i3 = 0; i3 < quadkey.length; i3++) {
    mask >>= 1;
    const q = parseInt(quadkey[i3]);
    if (q % 2)
      x2 |= mask;
    if (q > 1)
      y2 |= mask;
  }
  return [
    [x2 / scale, TILE_SIZE - y2 / scale],
    [(x2 + coverage) / scale, TILE_SIZE - (y2 + coverage) / scale]
  ];
}
function getQuadkeyPolygon(quadkey, coverage = 1) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
  const [w, n2] = worldToLngLat(topLeft);
  const [e2, s2] = worldToLngLat(bottomRight);
  return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
}

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-layer.js
var defaultProps20 = {
  getQuadkey: { type: "accessor", value: (d) => d.quadkey }
};
var _QuadkeyLayer = class _QuadkeyLayer extends GeoCellLayer {
  indexToBounds() {
    const { data, extruded, getQuadkey } = this.props;
    const coverage = extruded ? 0.99 : 1;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getQuadkeyPolygon(getQuadkey(x2, objectInfo), coverage),
      updateTriggers: { getPolygon: coverage }
    };
  }
};
_QuadkeyLayer.layerName = "QuadkeyLayer";
_QuadkeyLayer.defaultProps = defaultProps20;
var QuadkeyLayer = _QuadkeyLayer;

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js
var Tile2DHeader = class {
  constructor(index) {
    this.index = index;
    this.isVisible = false;
    this.isSelected = false;
    this.parent = null;
    this.children = [];
    this.content = null;
    this._loader = void 0;
    this._abortController = null;
    this._loaderId = 0;
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
  }
  /** @deprecated use `boundingBox` instead */
  get bbox() {
    return this._bbox;
  }
  // TODO - remove in v9
  set bbox(value) {
    if (this._bbox)
      return;
    this._bbox = value;
    if ("west" in value) {
      this.boundingBox = [
        [value.west, value.south],
        [value.east, value.north]
      ];
    } else {
      this.boundingBox = [
        [value.left, value.top],
        [value.right, value.bottom]
      ];
    }
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return Boolean(this._loader) && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const result = this.content ? this.content.byteLength : 0;
    if (!Number.isFinite(result)) {
      console.error("byteLength not defined in tile data");
    }
    return result;
  }
  /* eslint-disable max-statements */
  async _loadData({ getData, requestScheduler, onLoad, onError }) {
    const { index, id, bbox, userData, zoom } = this;
    const loaderId = this._loaderId;
    this._abortController = new AbortController();
    const { signal } = this._abortController;
    const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
      return tile.isSelected ? 1 : -1;
    });
    if (!requestToken) {
      this._isCancelled = true;
      return;
    }
    if (this._isCancelled) {
      requestToken.done();
      return;
    }
    let tileData = null;
    let error;
    try {
      tileData = await getData({ index, id, bbox, userData, zoom, signal });
    } catch (err) {
      error = err || true;
    } finally {
      requestToken.done();
    }
    if (loaderId !== this._loaderId) {
      return;
    }
    this._loader = void 0;
    this.content = tileData;
    if (this._isCancelled && !tileData) {
      this._isLoaded = false;
      return;
    }
    this._isLoaded = true;
    this._isCancelled = false;
    if (error) {
      onError(error, this);
    } else {
      onLoad(this);
    }
  }
  loadData(opts) {
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
    this._loaderId++;
    this._loader = this._loadData(opts);
    return this._loader;
  }
  setNeedsReload() {
    if (this.isLoading) {
      this.abort();
      this._loader = void 0;
    }
    this._needsReload = true;
  }
  abort() {
    var _a;
    if (this.isLoaded) {
      return;
    }
    this._isCancelled = true;
    (_a = this._abortController) == null ? void 0 : _a.abort();
  }
};

// node_modules/@math.gl/culling/dist/constants.js
var INTERSECTION = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
var scratchVector = new Vector3();
var scratchNormal = new Vector3();
var AxisAlignedBoundingBox = class _AxisAlignedBoundingBox {
  /**
   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
   * @param center The center of the box; automatically computed if not supplied.
   */
  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.center = new Vector3(center);
    this.halfDiagonal = new Vector3(maximum).subtract(this.center);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
  }
  /**
   * Duplicates a AxisAlignedBoundingBox instance.
   *
   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
   */
  clone() {
    return new _AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
  }
  /**
   * Compares the provided AxisAlignedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(right) {
    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transform2) {
    this.center.transformAsPoint(transform2);
    this.halfDiagonal.transform(transform2);
    this.minimum.transform(transform2);
    this.maximum.transform(transform2);
    return this;
  }
  /**
   * Determines which side of a plane a box is located.
   */
  intersectPlane(plane) {
    const { halfDiagonal } = this;
    const normal = scratchNormal.from(plane.normal);
    const e2 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
    const s2 = this.center.dot(normal) + plane.distance;
    if (s2 - e2 > 0) {
      return INTERSECTION.INSIDE;
    }
    if (s2 + e2 < 0) {
      return INTERSECTION.OUTSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point2) {
    return Math.sqrt(this.distanceSquaredTo(point2));
  }
  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */
  distanceSquaredTo(point2) {
    const offset = scratchVector.from(point2).subtract(this.center);
    const { halfDiagonal } = this;
    let distanceSquared = 0;
    let d;
    d = Math.abs(offset.x) - halfDiagonal.x;
    if (d > 0) {
      distanceSquared += d * d;
    }
    d = Math.abs(offset.y) - halfDiagonal.y;
    if (d > 0) {
      distanceSquared += d * d;
    }
    d = Math.abs(offset.z) - halfDiagonal.z;
    if (d > 0) {
      distanceSquared += d * d;
    }
    return distanceSquared;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
var scratchVector2 = new Vector3();
var scratchVector22 = new Vector3();
var BoundingSphere = class _BoundingSphere {
  /** Creates a bounding sphere */
  constructor(center = [0, 0, 0], radius = 0) {
    this.radius = -0;
    this.center = new Vector3();
    this.fromCenterRadius(center, radius);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(center, radius) {
    this.center.from(center);
    this.radius = radius;
    return this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(corner, oppositeCorner) {
    oppositeCorner = scratchVector2.from(oppositeCorner);
    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
    this.radius = this.center.distance(oppositeCorner);
    return this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new _BoundingSphere(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(boundingSphere) {
    const leftCenter = this.center;
    const leftRadius = this.radius;
    const rightCenter = boundingSphere.center;
    const rightRadius = boundingSphere.radius;
    const toRightCenter = scratchVector2.copy(rightCenter).subtract(leftCenter);
    const centerSeparation = toRightCenter.magnitude();
    if (leftRadius >= centerSeparation + rightRadius) {
      return this.clone();
    }
    if (rightRadius >= centerSeparation + leftRadius) {
      return boundingSphere.clone();
    }
    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
    scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
    this.center.copy(scratchVector22);
    this.radius = halfDistanceBetweenTangentPoints;
    return this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(point2) {
    const scratchPoint2 = scratchVector2.from(point2);
    const radius = scratchPoint2.subtract(this.center).magnitude();
    if (radius > this.radius) {
      this.radius = radius;
    }
    return this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(transform2) {
    this.center.transform(transform2);
    const scale = mat4_exports.getScaling(scratchVector2, transform2);
    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;
    return this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(point2) {
    const d = this.distanceTo(point2);
    return d * d;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(point2) {
    const scratchPoint2 = scratchVector2.from(point2);
    const delta = scratchPoint2.subtract(this.center);
    return Math.max(0, delta.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(plane) {
    const center = this.center;
    const radius = this.radius;
    const normal = plane.normal;
    const distanceToPlane = normal.dot(center) + plane.distance;
    if (distanceToPlane < -radius) {
      return INTERSECTION.OUTSIDE;
    }
    if (distanceToPlane < radius) {
      return INTERSECTION.INTERSECTING;
    }
    return INTERSECTION.INSIDE;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
var scratchVector3 = new Vector3();
var scratchOffset = new Vector3();
var scratchVectorU = new Vector3();
var scratchVectorV = new Vector3();
var scratchVectorW = new Vector3();
var scratchCorner = new Vector3();
var scratchToCenter = new Vector3();
var MATRIX3 = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
var OrientedBoundingBox = class _OrientedBoundingBox {
  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new Vector3().from(center);
    this.halfAxes = new Matrix3(halfAxes);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    const normXAxis = new Vector3(xAxis).normalize();
    const normYAxis = new Vector3(yAxis).normalize();
    const normZAxis = new Vector3(zAxis).normalize();
    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
    const quaternionObject = new Quaternion(quaternion2);
    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
    this.center = new Vector3().from(center);
    this.halfAxes = directionsMatrix;
    return this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new _OrientedBoundingBox(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(result = new BoundingSphere()) {
    const halfAxes = this.halfAxes;
    const u = halfAxes.getColumn(0, scratchVectorU);
    const v = halfAxes.getColumn(1, scratchVectorV);
    const w = halfAxes.getColumn(2, scratchVectorW);
    const cornerVector = scratchVector3.copy(u).add(v).add(w);
    result.center.copy(this.center);
    result.radius = cornerVector.magnitude();
    return result;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(plane) {
    const center = this.center;
    const normal = plane.normal;
    const halfAxes = this.halfAxes;
    const normalX = normal.x;
    const normalY = normal.y;
    const normalZ = normal.z;
    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
    const distanceToPlane = normal.dot(center) + plane.distance;
    if (distanceToPlane <= -radEffective) {
      return INTERSECTION.OUTSIDE;
    } else if (distanceToPlane >= radEffective) {
      return INTERSECTION.INSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point2) {
    return Math.sqrt(this.distanceSquaredTo(point2));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(point2) {
    const offset = scratchOffset.from(point2).subtract(this.center);
    const halfAxes = this.halfAxes;
    const u = halfAxes.getColumn(0, scratchVectorU);
    const v = halfAxes.getColumn(1, scratchVectorV);
    const w = halfAxes.getColumn(2, scratchVectorW);
    const uHalf = u.magnitude();
    const vHalf = v.magnitude();
    const wHalf = w.magnitude();
    u.normalize();
    v.normalize();
    w.normalize();
    let distanceSquared = 0;
    let d;
    d = Math.abs(offset.dot(u)) - uHalf;
    if (d > 0) {
      distanceSquared += d * d;
    }
    d = Math.abs(offset.dot(v)) - vHalf;
    if (d > 0) {
      distanceSquared += d * d;
    }
    d = Math.abs(offset.dot(w)) - wHalf;
    if (d > 0) {
      distanceSquared += d * d;
    }
    return distanceSquared;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(position, direction, result = [-0, -0]) {
    let minDist = Number.POSITIVE_INFINITY;
    let maxDist = Number.NEGATIVE_INFINITY;
    const center = this.center;
    const halfAxes = this.halfAxes;
    const u = halfAxes.getColumn(0, scratchVectorU);
    const v = halfAxes.getColumn(1, scratchVectorV);
    const w = halfAxes.getColumn(2, scratchVectorW);
    const corner = scratchCorner.copy(u).add(v).add(w).add(center);
    const toCenter = scratchToCenter.copy(corner).subtract(position);
    let mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u).add(v).subtract(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u).subtract(v).add(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center).add(u).subtract(v).subtract(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u).add(v).add(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u).add(v).subtract(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u).subtract(v).add(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center.copy(corner).subtract(u).subtract(v).subtract(w);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    result[0] = minDist;
    result[1] = maxDist;
    return result;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transformation) {
    this.center.transformAsPoint(transformation);
    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
    xAxis.transformAsPoint(transformation);
    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
    yAxis.transformAsPoint(transformation);
    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
    zAxis.transformAsPoint(transformation);
    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
    return this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
};

// node_modules/@math.gl/culling/dist/lib/plane.js
var scratchPosition = new Vector3();
var scratchNormal2 = new Vector3();
var Plane = class _Plane {
  constructor(normal = [0, 0, 1], distance = 0) {
    this.normal = new Vector3();
    this.distance = -0;
    this.fromNormalDistance(normal, distance);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(normal, distance) {
    assert4(Number.isFinite(distance));
    this.normal.from(normal).normalize();
    this.distance = distance;
    return this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(point2, normal) {
    point2 = scratchPosition.from(point2);
    this.normal.from(normal).normalize();
    const distance = -this.normal.dot(point2);
    this.distance = distance;
    return this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(a3, b2, c2, d) {
    this.normal.set(a3, b2, c2);
    assert4(equals(this.normal.len(), 1));
    this.distance = d;
    return this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new _Plane(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(right) {
    return equals(this.distance, right.distance) && equals(this.normal, right.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(point2) {
    return this.normal.dot(point2) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(matrix4) {
    const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
    const point2 = this.normal.scale(-this.distance).transform(matrix4);
    return this.fromPointNormal(point2, normal);
  }
  projectPointOntoPlane(point2, result = [0, 0, 0]) {
    const scratchPoint2 = scratchPosition.from(point2);
    const pointDistance = this.getPointDistance(scratchPoint2);
    const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
    return scratchPoint2.subtract(scaledNormal).to(result);
  }
};

// node_modules/@math.gl/culling/dist/lib/culling-volume.js
var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
var scratchPlaneCenter = new Vector3();
var scratchPlaneNormal = new Vector3();
var CullingVolume = class _CullingVolume {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(planes = []) {
    this.planes = planes;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(boundingSphere) {
    this.planes.length = 2 * faces.length;
    const center = boundingSphere.center;
    const radius = boundingSphere.radius;
    let planeIndex = 0;
    for (const faceNormal of faces) {
      let plane0 = this.planes[planeIndex];
      let plane1 = this.planes[planeIndex + 1];
      if (!plane0) {
        plane0 = this.planes[planeIndex] = new Plane();
      }
      if (!plane1) {
        plane1 = this.planes[planeIndex + 1] = new Plane();
      }
      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
      plane0.fromPointNormal(plane0Center, faceNormal);
      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
      plane1.fromPointNormal(plane1Center, negatedFaceNormal);
      planeIndex += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(boundingVolume) {
    let intersect3 = INTERSECTION.INSIDE;
    for (const plane of this.planes) {
      const result = boundingVolume.intersectPlane(plane);
      switch (result) {
        case INTERSECTION.OUTSIDE:
          return INTERSECTION.OUTSIDE;
        case INTERSECTION.INTERSECTING:
          intersect3 = INTERSECTION.INTERSECTING;
          break;
        default:
      }
    }
    return intersect3;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
    assert4(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
    if (parentPlaneMask === _CullingVolume.MASK_OUTSIDE || parentPlaneMask === _CullingVolume.MASK_INSIDE) {
      return parentPlaneMask;
    }
    let mask = _CullingVolume.MASK_INSIDE;
    const planes = this.planes;
    for (let k = 0; k < this.planes.length; ++k) {
      const flag = k < 31 ? 1 << k : 0;
      if (k < 31 && (parentPlaneMask & flag) === 0) {
        continue;
      }
      const plane = planes[k];
      const result = boundingVolume.intersectPlane(plane);
      if (result === INTERSECTION.OUTSIDE) {
        return _CullingVolume.MASK_OUTSIDE;
      } else if (result === INTERSECTION.INTERSECTING) {
        mask |= flag;
      }
    }
    return mask;
  }
};
CullingVolume.MASK_OUTSIDE = 4294967295;
CullingVolume.MASK_INSIDE = 0;
CullingVolume.MASK_INDETERMINATE = 2147483647;

// node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
var scratchPlaneUpVector = new Vector3();
var scratchPlaneRightVector = new Vector3();
var scratchPlaneNearCenter = new Vector3();
var scratchPlaneFarCenter = new Vector3();
var scratchPlaneNormal2 = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
var fromPointsXMin = new Vector3();
var fromPointsYMin = new Vector3();
var fromPointsZMin = new Vector3();
var fromPointsXMax = new Vector3();
var fromPointsYMax = new Vector3();
var fromPointsZMax = new Vector3();
var fromPointsCurrentPos = new Vector3();
var fromPointsScratch = new Vector3();
var fromPointsRitterCenter = new Vector3();
var fromPointsMinBoxPt = new Vector3();
var fromPointsMaxBoxPt = new Vector3();
var fromPointsNaiveCenterScratch = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
var scratchMatrix = new Matrix3();
var scratchUnitary = new Matrix3();
var scratchDiagonal = new Matrix3();
var jMatrix = new Matrix3();
var jMatrixTranspose = new Matrix3();
function computeEigenDecomposition(matrix, result = {}) {
  const EIGEN_TOLERANCE = math_utils_exports.EPSILON20;
  const EIGEN_MAX_SWEEPS = 10;
  let count = 0;
  let sweep = 0;
  const unitaryMatrix = scratchUnitary;
  const diagonalMatrix = scratchDiagonal;
  unitaryMatrix.identity();
  diagonalMatrix.copy(matrix);
  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, jMatrix);
    jMatrixTranspose.copy(jMatrix).transpose();
    diagonalMatrix.multiplyRight(jMatrix);
    diagonalMatrix.multiplyLeft(jMatrixTranspose);
    unitaryMatrix.multiplyRight(jMatrix);
    if (++count > 2) {
      ++sweep;
      count = 0;
    }
  }
  result.unitary = unitaryMatrix.toTarget(result.unitary);
  result.diagonal = diagonalMatrix.toTarget(result.diagonal);
  return result;
}
function computeFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 9; ++i3) {
    const temp = matrix[i3];
    norm += temp * temp;
  }
  return Math.sqrt(norm);
}
var rowVal = [1, 0, 0];
var colVal = [2, 2, 1];
function offDiagonalFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])];
    norm += 2 * temp * temp;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
  const tolerance = math_utils_exports.EPSILON15;
  let maxDiagonal = 0;
  let rotAxis = 1;
  for (let i3 = 0; i3 < 3; ++i3) {
    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i3], rowVal[i3])]);
    if (temp > maxDiagonal) {
      rotAxis = i3;
      maxDiagonal = temp;
    }
  }
  const p2 = rowVal[rotAxis];
  const q = colVal[rotAxis];
  let c2 = 1;
  let s2 = 0;
  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p2)]) > tolerance) {
    const qq = matrix[scratchMatrix.getElementIndex(q, q)];
    const pp = matrix[scratchMatrix.getElementIndex(p2, p2)];
    const qp = matrix[scratchMatrix.getElementIndex(q, p2)];
    const tau = (qq - pp) / 2 / qp;
    let t2;
    if (tau < 0) {
      t2 = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t2 = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c2 = 1 / Math.sqrt(1 + t2 * t2);
    s2 = t2 * c2;
  }
  Matrix3.IDENTITY.to(result);
  result[scratchMatrix.getElementIndex(p2, p2)] = result[scratchMatrix.getElementIndex(q, q)] = c2;
  result[scratchMatrix.getElementIndex(q, p2)] = s2;
  result[scratchMatrix.getElementIndex(p2, q)] = -s2;
  return result;
}

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
var scratchVector23 = new Vector3();
var scratchVector32 = new Vector3();
var scratchVector4 = new Vector3();
var scratchVector5 = new Vector3();
var scratchVector6 = new Vector3();
var scratchCovarianceResult = new Matrix3();
var scratchEigenResult = {
  diagonal: new Matrix3(),
  unitary: new Matrix3()
};
function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new Vector3();
    return result;
  }
  const length2 = positions.length;
  const meanPoint = new Vector3(0, 0, 0);
  for (const position of positions) {
    meanPoint.add(position);
  }
  const invLength = 1 / length2;
  meanPoint.multiplyByScalar(invLength);
  let exx = 0;
  let exy = 0;
  let exz = 0;
  let eyy = 0;
  let eyz = 0;
  let ezz = 0;
  for (const position of positions) {
    const p2 = scratchVector23.copy(position).subtract(meanPoint);
    exx += p2.x * p2.x;
    exy += p2.x * p2.y;
    exz += p2.x * p2.z;
    eyy += p2.y * p2.y;
    eyz += p2.y * p2.z;
    ezz += p2.z * p2.z;
  }
  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  const covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;
  const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
  const rotation = result.halfAxes.copy(unitary);
  let v1 = rotation.getColumn(0, scratchVector4);
  let v2 = rotation.getColumn(1, scratchVector5);
  let v3 = rotation.getColumn(2, scratchVector6);
  let u1 = -Number.MAX_VALUE;
  let u2 = -Number.MAX_VALUE;
  let u3 = -Number.MAX_VALUE;
  let l1 = Number.MAX_VALUE;
  let l2 = Number.MAX_VALUE;
  let l3 = Number.MAX_VALUE;
  for (const position of positions) {
    scratchVector23.copy(position);
    u1 = Math.max(scratchVector23.dot(v1), u1);
    u2 = Math.max(scratchVector23.dot(v2), u2);
    u3 = Math.max(scratchVector23.dot(v3), u3);
    l1 = Math.min(scratchVector23.dot(v1), l1);
    l2 = Math.min(scratchVector23.dot(v2), l2);
    l3 = Math.min(scratchVector23.dot(v3), l3);
  }
  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  const scale = scratchVector32.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);
  result.halfAxes.multiplyRight(scaleMatrix);
  return result;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js
var TILE_SIZE2 = 512;
var MAX_MAPS = 3;
var REF_POINTS_5 = [
  [0.5, 0.5],
  [0, 0],
  [0, 1],
  [1, 0],
  [1, 1]
];
var REF_POINTS_9 = REF_POINTS_5.concat([
  [0, 0.5],
  [0.5, 0],
  [1, 0.5],
  [0.5, 1]
]);
var REF_POINTS_11 = REF_POINTS_9.concat([
  [0.25, 0.5],
  [0.75, 0.5]
]);
var OSMNode = class _OSMNode {
  constructor(x2, y2, z) {
    this.x = x2;
    this.y = y2;
    this.z = z;
  }
  get children() {
    if (!this._children) {
      const x2 = this.x * 2;
      const y2 = this.y * 2;
      const z = this.z + 1;
      this._children = [
        new _OSMNode(x2, y2, z),
        new _OSMNode(x2, y2 + 1, z),
        new _OSMNode(x2 + 1, y2, z),
        new _OSMNode(x2 + 1, y2 + 1, z)
      ];
    }
    return this._children;
  }
  // eslint-disable-next-line complexity
  update(params) {
    const { viewport, cullingVolume: cullingVolume2, elevationBounds, minZ, maxZ, bounds, offset, project: project2 } = params;
    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
    if (bounds && !this.insideBounds(bounds)) {
      return false;
    }
    const isInside = cullingVolume2.computeVisibility(boundingVolume);
    if (isInside < 0) {
      return false;
    }
    if (!this.childVisible) {
      let { z } = this;
      if (z < maxZ && z >= minZ) {
        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
        z += Math.floor(Math.log2(distance));
      }
      if (z >= maxZ) {
        this.selected = true;
        return true;
      }
    }
    this.selected = false;
    this.childVisible = true;
    for (const child of this.children) {
      child.update(params);
    }
    return true;
  }
  getSelected(result = []) {
    if (this.selected) {
      result.push(this);
    }
    if (this._children) {
      for (const node of this._children) {
        node.getSelected(result);
      }
    }
    return result;
  }
  insideBounds([minX, minY, maxX, maxY]) {
    const scale = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale;
    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
  }
  getBoundingVolume(zRange, worldOffset, project2) {
    if (project2) {
      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
      const refPointPositions = [];
      for (const p2 of refPoints) {
        const lngLat = osmTile2lngLat(this.x + p2[0], this.y + p2[1], this.z);
        lngLat[2] = zRange[0];
        refPointPositions.push(project2(lngLat));
        if (zRange[0] !== zRange[1]) {
          lngLat[2] = zRange[1];
          refPointPositions.push(project2(lngLat));
        }
      }
      return makeOrientedBoundingBoxFromPoints(refPointPositions);
    }
    const scale = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale;
    const originX = this.x * extent + worldOffset * TILE_SIZE2;
    const originY = TILE_SIZE2 - (this.y + 1) * extent;
    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
  }
};
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project2 = viewport instanceof GlobeViewport && viewport.resolution ? (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    viewport.projectPosition
  ) : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance }) => new Plane(normal.clone().negate(), distance));
  const cullingVolume2 = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof WebMercatorViewport && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project: project2,
    cullingVolume: cullingVolume2,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    // num. of worlds from the center. For repeated maps
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof WebMercatorViewport && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js
var TILE_SIZE3 = 512;
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var urlType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    if (value1 === value2) {
      return true;
    }
    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }
    const len = value1.length;
    if (len !== value2.length) {
      return false;
    }
    for (let i3 = 0; i3 < len; i3++) {
      if (value1[i3] !== value2[i3]) {
        return false;
      }
    }
    return true;
  }
};
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [
    // top-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
    // top-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
    // bottom-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
    // bottom-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
  ];
  const transformedBox = [
    // Minimum x coord
    Math.min(...transformedCoords.map((i3) => i3[0])),
    // Minimum y coord
    Math.min(...transformedCoords.map((i3) => i3[1])),
    // Max x coord
    Math.max(...transformedCoords.map((i3) => i3[0])),
    // Max y coord
    Math.max(...transformedCoords.map((i3) => i3[1]))
  ];
  return transformedBox;
}
function stringHash(s2) {
  return Math.abs(s2.split("").reduce((a3, b2) => (a3 << 5) - a3 + b2.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const { index, id } = tile;
  if (Array.isArray(template)) {
    const i3 = stringHash(id) % template.length;
    template = template[i3];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp(`{${key}}`, "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox2(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    bounds = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [
      // Top corner should not be more then bottom corner in either direction
      Math.max(Math.min(bounds[0], extent[2]), extent[0]),
      Math.max(Math.min(bounds[1], extent[3]), extent[1]),
      // Bottom corner should not be less then top corner in either direction
      Math.min(Math.max(bounds[2], extent[0]), extent[2]),
      Math.min(Math.max(bounds[3], extent[1]), extent[3])
    ];
  }
  return [
    Math.max(bounds[0], extent[0]),
    Math.max(bounds[1], extent[1]),
    Math.min(bounds[2], extent[2]),
    Math.min(bounds[3], extent[3])
  ];
}
function getCullBounds({ viewport, z, cullRect }) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v) => getCullBoundsInViewport(v, z || 0, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x2 = cullRect.x - viewport.x;
    const y2 = cullRect.y - viewport.y;
    const { width, height } = cullRect;
    const unprojectOption = { targetZ: z };
    const topLeft = viewport.unproject([x2, y2], unprojectOption);
    const topRight = viewport.unproject([x2 + width, y2], unprojectOption);
    const bottomLeft = viewport.unproject([x2, y2 + height], unprojectOption);
    const bottomRight = viewport.unproject([x2 + width, y2 + height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [
    Math.min(bounds0[0], bounds1[0]),
    Math.min(bounds0[1], bounds1[1]),
    Math.max(bounds0[2], bounds1[2]),
    Math.max(bounds0[3], bounds1[3])
  ];
}
function getIndexingCoords(bbox, scale, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i3) => i3 * scale / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i3) => i3 * scale / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x2, y2, z) {
  const scale = getScale(z, TILE_SIZE3);
  const lng = x2 / scale * 360 - 180;
  const n2 = Math.PI - 2 * Math.PI * y2 / scale;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2)));
  return [lng, lat];
}
function tile2XY(x2, y2, z, tileSize) {
  const scale = getScale(z, tileSize);
  return [x2 / scale * TILE_SIZE3, y2 / scale * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x2, y2, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x2, y2, z);
    const [east, south] = osmTile2lngLat(x2 + 1, y2 + 1, z);
    return { west, north, east, south };
  }
  const [left, top] = tile2XY(x2, y2, z, tileSize);
  const [right, bottom] = tile2XY(x2 + 1, y2 + 1, z, tileSize);
  return { left, top, right, bottom };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox2(viewport, null, extent);
  const scale = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);
  const indices = [];
  for (let x2 = Math.floor(minX); x2 < maxX; x2++) {
    for (let y2 = Math.floor(minY); y2 < maxY; y2++) {
      indices.push({ x: x2, y: y2, z });
    }
  }
  return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE3, modelMatrix: modelMatrix2, modelMatrixInverse, zoomOffset = 0 }) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s2) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s2);
}
function isGeoBoundingBox(v) {
  return Number.isFinite(v.west) && Number.isFinite(v.north) && Number.isFinite(v.east) && Number.isFinite(v.south);
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (Array.isArray(a3)) {
    const len = a3.length;
    if (!b2 || b2.length !== len) {
      return false;
    }
    for (let i3 = 0; i3 < len; i3++) {
      if (a3[i3] !== b2[i3]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
var STRATEGY_NEVER = "never";
var STRATEGY_REPLACE = "no-overlap";
var STRATEGY_DEFAULT = "best-available";
var DEFAULT_CACHE_SCALE = 5;
var STRATEGIES = {
  [STRATEGY_DEFAULT]: updateTileStateDefault,
  [STRATEGY_REPLACE]: updateTileStateReplace,
  [STRATEGY_NEVER]: () => {
  }
};
var DEFAULT_TILESET2D_PROPS = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0,
  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
var Tileset2D = class {
  /**
   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
   * Cache size defaults to 5 * number of tiles in the current viewport
   */
  constructor(opts) {
    this._getCullBounds = memoize2(getCullBounds);
    this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
    this.setOptions(this.opts);
    this.onTileLoad = (tile) => {
      var _a, _b;
      (_b = (_a = this.opts).onTileLoad) == null ? void 0 : _b.call(_a, tile);
      if (this.opts.maxCacheByteSize) {
        this._cacheByteSize += tile.byteLength;
        this._resizeCache();
      }
    };
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
      maxRequests: this.opts.maxRequests,
      debounceTime: this.opts.debounceTime
    });
    this._cache = /* @__PURE__ */ new Map();
    this._tiles = [];
    this._dirty = false;
    this._cacheByteSize = 0;
    this._viewport = null;
    this._zRange = null;
    this._selectedTiles = null;
    this._frameNumber = 0;
    this._modelMatrix = new Matrix4();
    this._modelMatrixInverse = new Matrix4();
  }
  /* Public API */
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
  }
  setOptions(opts) {
    Object.assign(this.opts, opts);
    if (Number.isFinite(opts.maxZoom)) {
      this._maxZoom = Math.floor(opts.maxZoom);
    }
    if (Number.isFinite(opts.minZoom)) {
      this._minZoom = Math.ceil(opts.minZoom);
    }
  }
  // Clean up any outstanding tile requests.
  finalize() {
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        tile.abort();
      }
    }
    this._cache.clear();
    this._tiles = [];
    this._selectedTiles = null;
  }
  reloadAll() {
    for (const id of this._cache.keys()) {
      const tile = this._cache.get(id);
      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
        this._cache.delete(id);
      } else {
        tile.setNeedsReload();
      }
    }
  }
  /**
   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
   */
  update(viewport, { zRange, modelMatrix: modelMatrix2 } = {
    zRange: null,
    modelMatrix: null
  }) {
    const modelMatrixAsMatrix4 = modelMatrix2 ? new Matrix4(modelMatrix2) : new Matrix4();
    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
      if (isModelMatrixNew) {
        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
        this._modelMatrix = modelMatrixAsMatrix4;
      }
      this._viewport = viewport;
      this._zRange = zRange;
      const tileIndices = this.getTileIndices({
        viewport,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
      if (this._dirty) {
        this._rebuildTree();
      }
    } else if (this.needsReload) {
      this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
    }
    const changed = this.updateTileStates();
    this._pruneRequests();
    if (this._dirty) {
      this._resizeCache();
    }
    if (changed) {
      this._frameNumber++;
    }
    return this._frameNumber;
  }
  // eslint-disable-next-line complexity
  isTileVisible(tile, cullRect) {
    if (!tile.isVisible) {
      return false;
    }
    if (cullRect && this._viewport) {
      const boundsArr = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect
      });
      const { bbox } = tile;
      for (const [minX, minY, maxX, maxY] of boundsArr) {
        let overlaps;
        if ("west" in bbox) {
          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
        } else {
          const y0 = Math.min(bbox.top, bbox.bottom);
          const y1 = Math.max(bbox.top, bbox.bottom);
          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
        }
        if (overlaps) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
  /* Public interface for subclassing */
  /** Returns array of tile indices in the current viewport */
  getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix: modelMatrix2, modelMatrixInverse }) {
    const { tileSize, extent, zoomOffset } = this.opts;
    return getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      tileSize,
      extent,
      modelMatrix: modelMatrix2,
      modelMatrixInverse,
      zoomOffset
    });
  }
  /** Returns unique string key for a tile index */
  getTileId(index) {
    return `${index.x}-${index.y}-${index.z}`;
  }
  /** Returns a zoom level for a tile index */
  getTileZoom(index) {
    return index.z;
  }
  /** Returns additional metadata to add to tile, bbox by default */
  getTileMetadata(index) {
    const { tileSize } = this.opts;
    return { bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize) };
  }
  /** Returns index of the parent tile */
  getParentIndex(index) {
    const x2 = Math.floor(index.x / 2);
    const y2 = Math.floor(index.y / 2);
    const z = index.z - 1;
    return { x: x2, y: y2, z };
  }
  // Returns true if any tile's visibility changed
  updateTileStates() {
    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
    const visibilities = new Array(this._cache.size);
    let i3 = 0;
    for (const tile of this._cache.values()) {
      visibilities[i3++] = tile.isVisible;
      tile.isSelected = false;
      tile.isVisible = false;
    }
    for (const tile of this._selectedTiles) {
      tile.isSelected = true;
      tile.isVisible = true;
    }
    (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
    i3 = 0;
    for (const tile of this._cache.values()) {
      if (visibilities[i3++] !== tile.isVisible) {
        return true;
      }
    }
    return false;
  }
  _pruneRequests() {
    const { maxRequests = 0 } = this.opts;
    const abortCandidates = [];
    let ongoingRequestCount = 0;
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        ongoingRequestCount++;
        if (!tile.isSelected && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abort();
      ongoingRequestCount--;
    }
  }
  // This needs to be called every time some tiles have been added/removed from cache
  _rebuildTree() {
    const { _cache } = this;
    for (const tile of _cache.values()) {
      tile.parent = null;
      if (tile.children) {
        tile.children.length = 0;
      }
    }
    for (const tile of _cache.values()) {
      const parent = this._getNearestAncestor(tile);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  /**
   * Clear tiles that are not visible when the cache is full
   */
  /* eslint-disable complexity */
  _resizeCache() {
    var _a, _b;
    const { _cache, opts } = this;
    const maxCacheSize = opts.maxCacheSize || // @ts-expect-error called only when selectedTiles is initialized
    (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
    if (overflown) {
      for (const [id, tile] of _cache) {
        if (!tile.isVisible && !tile.isSelected) {
          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
          _cache.delete(id);
          (_b = (_a = this.opts).onTileUnload) == null ? void 0 : _b.call(_a, tile);
        }
        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
          break;
        }
      }
      this._rebuildTree();
      this._dirty = true;
    }
    if (this._dirty) {
      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
      this._dirty = false;
    }
  }
  _getTile(index, create) {
    const id = this.getTileId(index);
    let tile = this._cache.get(id);
    let needsReload = false;
    if (!tile && create) {
      tile = new Tile2DHeader(index);
      Object.assign(tile, this.getTileMetadata(tile.index));
      Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
      needsReload = true;
      this._cache.set(id, tile);
      this._dirty = true;
    } else if (tile && tile.needsReload) {
      needsReload = true;
    }
    if (tile && needsReload) {
      tile.loadData({
        getData: this.opts.getTileData,
        requestScheduler: this._requestScheduler,
        onLoad: this.onTileLoad,
        onError: this.opts.onTileError
      });
    }
    return tile;
  }
  _getNearestAncestor(tile) {
    const { _minZoom = 0 } = this;
    let index = tile.index;
    while (this.getTileZoom(index) > _minZoom) {
      index = this.getParentIndex(index);
      const parent = this._getTile(index);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}

// node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js
var defaultProps21 = {
  TilesetClass: Tileset2D,
  data: { type: "data", value: [] },
  dataComparator: urlType.equal,
  renderSubLayers: { type: "function", value: (props) => new GeoJsonLayer(props) },
  getTileData: { type: "function", optional: true, value: null },
  // TODO - change to onViewportLoad to align with Tile3DLayer
  onViewportLoad: { type: "function", optional: true, value: null },
  onTileLoad: { type: "function", value: (tile) => {
  } },
  onTileUnload: { type: "function", value: (tile) => {
  } },
  // eslint-disable-next-line
  onTileError: { type: "function", value: (err) => console.error(err) },
  extent: { type: "array", optional: true, value: null, compare: true },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0
};
var _TileLayer = class _TileLayer extends CompositeLayer {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: false
    };
  }
  finalizeState() {
    var _a, _b;
    (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.finalize();
  }
  get isLoaded() {
    var _a, _b, _c;
    return Boolean((_c = (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.selectedTiles) == null ? void 0 : _c.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)));
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ changeFlags }) {
    let { tileset } = this.state;
    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
    if (!tileset) {
      tileset = new this.props.TilesetClass(this._getTilesetOptions());
      this.setState({ tileset });
    } else if (propsChanged) {
      tileset.setOptions(this._getTilesetOptions());
      if (dataChanged) {
        tileset.reloadAll();
      } else {
        tileset.tiles.forEach((tile) => {
          tile.layers = null;
        });
      }
    }
    this._updateTileset();
  }
  _getTilesetOptions() {
    const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
    return {
      maxCacheSize,
      maxCacheByteSize,
      maxZoom,
      minZoom,
      tileSize,
      refinementStrategy,
      extent,
      maxRequests,
      debounceTime,
      zoomOffset,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const tileset = this.state.tileset;
    const { zRange, modelMatrix: modelMatrix2 } = this.props;
    const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix: modelMatrix2 });
    const { isLoaded } = tileset;
    const loadingStateChanged = this.state.isLoaded !== isLoaded;
    const tilesetChanged = this.state.frameNumber !== frameNumber;
    if (isLoaded && (loadingStateChanged || tilesetChanged)) {
      this._onViewportLoad();
    }
    if (tilesetChanged) {
      this.setState({ frameNumber });
    }
    this.state.isLoaded = isLoaded;
  }
  _onViewportLoad() {
    const { tileset } = this.state;
    const { onViewportLoad } = this.props;
    if (onViewportLoad) {
      onViewportLoad(tileset.selectedTiles);
    }
  }
  _onTileLoad(tile) {
    this.props.onTileLoad(tile);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileError(error, tile) {
    this.props.onTileError(error);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileUnload(tile) {
    this.props.onTileUnload(tile);
  }
  // Methods for subclass to override
  getTileData(tile) {
    const { data, getTileData, fetch: fetch2 } = this.props;
    const { signal } = tile;
    tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
    if (getTileData) {
      return getTileData(tile);
    }
    if (fetch2 && tile.url) {
      return fetch2(tile.url, { propName: "data", layer: this, signal });
    }
    return null;
  }
  renderSubLayers(props) {
    return this.props.renderSubLayers(props);
  }
  getSubLayerPropsByTile(tile) {
    return null;
  }
  getPickingInfo(params) {
    const sourceTile = params.sourceLayer.props.tile;
    const info = params.info;
    if (info.picked) {
      info.tile = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    if (sourceTile && sourceTile.layers) {
      for (const layer of sourceTile.layers) {
        layer.updateAutoHighlight(info);
      }
    }
  }
  renderLayers() {
    return this.state.tileset.tiles.map((tile) => {
      const subLayerProps = this.getSubLayerPropsByTile(tile);
      if (!tile.isLoaded && !tile.content) {
      } else if (!tile.layers) {
        const layers = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: tile.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: tile.content,
          _offset: 0,
          tile
        });
        tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
          tile,
          ...subLayerProps
        }));
      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
        tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
      }
      return tile.layers;
    });
  }
  filterSubLayer({ layer, cullRect }) {
    const { tile } = layer.props;
    return this.state.tileset.isTileVisible(tile, cullRect);
  }
};
_TileLayer.defaultProps = defaultProps21;
_TileLayer.layerName = "TileLayer";
var TileLayer = _TileLayer;

// node_modules/@deck.gl/geo-layers/dist/trips-layer/trips-layer.js
var defaultProps22 = {
  fadeTrail: true,
  trailLength: { type: "number", value: 120, min: 0 },
  currentTime: { type: "number", value: 0, min: 0 },
  getTimestamps: { type: "accessor", value: (d) => d.timestamps }
};
var _TripsLayer = class _TripsLayer extends PathLayer {
  getShaders() {
    const shaders = super.getShaders();
    shaders.inject = {
      "vs:#decl": `uniform float trailLength;
in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
      // Timestamp of the vertex
      "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
      "fs:#decl": `uniform bool fadeTrail;
uniform float trailLength;
uniform float currentTime;
in float vTime;
`,
      // Drop the segments outside of the time window
      "fs:#main-start": `if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {
  discard;
}
`,
      // Fade the color (currentTime - 100%, end of trail - 0%)
      "fs:DECKGL_FILTER_COLOR": `if(fadeTrail) {
  color.a *= 1.0 - (currentTime - vTime) / trailLength;
}
`
    };
    return shaders;
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      timestamps: {
        size: 1,
        accessor: "getTimestamps",
        shaderAttributes: {
          instanceTimestamps: {
            vertexOffset: 0
          },
          instanceNextTimestamps: {
            vertexOffset: 1
          }
        }
      }
    });
  }
  draw(params) {
    const { fadeTrail, trailLength, currentTime } = this.props;
    params.uniforms = {
      ...params.uniforms,
      fadeTrail,
      trailLength,
      currentTime
    };
    super.draw(params);
  }
};
_TripsLayer.layerName = "TripsLayer";
_TripsLayer.defaultProps = defaultProps22;
var TripsLayer = _TripsLayer;

// node_modules/h3-js/dist/browser/h3-js.es.js
var libh3 = function(libh32) {
  libh32 = libh32 || {};
  var Module = typeof libh32 !== "undefined" ? libh32 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readAsync;
  {
    if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    readAsync = function readAsync2(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
          return;
        }
        var data = tryParseAsDataURI(url);
        if (data) {
          onload(data.buffer);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"]) {
    arguments_ = Module["arguments"];
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for getValue: " + type);
    }
    return null;
  }
  var ABORT = false;
  function assert7(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module["_" + ident];
    assert7(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": function(str) {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      },
      "array": function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean") {
        return Boolean(ret2);
      }
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack2 = 0;
    if (args) {
      for (var i3 = 0; i3 < args.length; i3++) {
        var converter = toC[argTypes[i3]];
        if (converter) {
          if (stack2 === 0) {
            stack2 = stackSave();
          }
          cArgs[i3] = converter(args[i3]);
        } else {
          cArgs[i3] = args[i3];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack2 !== 0) {
      stackRestore(stack2);
    }
    return ret;
  }
  function cwrap(ident, returnType, argTypes, opts) {
    argTypes = argTypes || [];
    var numericArgs = argTypes.every(function(type) {
      return type === "number";
    });
    var numericRet = returnType !== "string";
    if (numericRet && numericArgs && !opts) {
      return getCFunc(ident);
    }
    return function() {
      return ccall(ident, returnType, argTypes, arguments, opts);
    };
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (u8Array[endPtr] && !(endPtr >= endIdx)) {
      ++endPtr;
    }
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str = "";
      while (idx < endPtr) {
        var u0 = u8Array[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = u8Array[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) {
      return 0;
    }
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i3 = 0; i3 < str.length; ++i3) {
      var u = str.charCodeAt(i3);
      if (u >= 55296 && u <= 57343) {
        var u1 = str.charCodeAt(++i3);
        u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
        if (outIdx >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 192 | u >> 6;
        outU8Array[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 224 | u >> 12;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 3 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 240 | u >> 18;
        outU8Array[outIdx++] = 128 | u >> 12 & 63;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  function alignUp(x2, multiple) {
    if (x2 % multiple > 0) {
      x2 += multiple - x2 % multiple;
    }
    return x2;
  }
  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var DYNAMIC_BASE = 5267040, DYNAMICTOP_PTR = 24128;
  var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
  if (Module["buffer"]) {
    buffer = Module["buffer"];
  } else {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  INITIAL_TOTAL_MEMORY = buffer.byteLength;
  updateGlobalBufferAndViews(buffer);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func);
        } else {
          Module["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") {
        Module["preRun"] = [Module["preRun"]];
      }
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") {
        Module["postRun"] = [Module["postRun"]];
      }
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }
  var tempDouble;
  var tempI64;
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAOgehWlKfUEEz1zLi+JsiQa2og3wcMfVAWCbHorc0yEDi+Yn/Y6mbQJ11/mfsnG9At6bnG4UQQkBvMCQWKqUUQJVmwwswmOc/3hVgVBL3uj//qqOEOdGOPw/WDN4gnGE/H3ANkCUgND+AA8btKgAHPwTXBqJVSdo+XfRQAqsKrj4fc+zLYbSPQklEmCZHv2FCUP+uDso1NEKYtPhwphUHQptxnyFXYdpB7CddZAMmrkGAt1AxSTqBQUibBVdTsFNBSuX3MV+AJkFocv82SLf5QAqmgj7AY81A23VDSEnLoEDGEJVSeDFzQDYrqvBk70VA8U157pcRGUBWfEF+ZKbsP7KBdLHZTpFAqKYk69AqekDbeGY41MdjQD8AZzHK501A1vcrrjubNkD5LnquvBYhQCbiRRD71QlAqt72EbOH8z8Eu+jL1YbdP4uaox/xUcY/abedg1XfsD+BsUdzJ4KZP5wE9YFySIM/rW1kAKMpbT+rZFthVRhWPy4PKlXIs0A/qMZLlwDnMEHByqEF0I0ZQQYSFD8lUQNBPpY+dFs07UAH8BZImBPWQN9RY0I0sMBA2T7kLfc6qUByFYvfhBKTQMq+0Mis1XxA0XQbeQXMZUBJJ5aEGXpQQP7/SY0a6ThAaMD92b/UIkAs8s8yqXoMQNIegOvCk/U/aOi7NZJP4D8AAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAD/////AAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAA/////wAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAP////8AAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////BQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAEAAQAAAQEAAAAAAAEAAAABAAAAAQABAAAAAAAAAAAAAAAAAAAAAAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAGFsZ29zLmMAaDNOZWlnaGJvclJvdGF0aW9ucwBjb29yZGlqay5jAF91cEFwN0NoZWNrZWQAX3VwQXA3ckNoZWNrZWQAZGlyZWN0ZWRFZGdlLmMAZGlyZWN0ZWRFZGdlVG9Cb3VuZGFyeQBhZGphY2VudEZhY2VEaXJbdG1wRmlqay5mYWNlXVtmaWprLmZhY2VdID09IEtJAGZhY2VpamsuYwBfZmFjZUlqa1BlbnRUb0NlbGxCb3VuZGFyeQBhZGphY2VudEZhY2VEaXJbY2VudGVySUpLLmZhY2VdW2ZhY2UyXSA9PSBLSQBfZmFjZUlqa1RvQ2VsbEJvdW5kYXJ5AGgzSW5kZXguYwBjb21wYWN0Q2VsbHMAbGF0TG5nVG9DZWxsAGNlbGxUb0NoaWxkUG9zAHZhbGlkYXRlQ2hpbGRQb3MAbGF0TG5nLmMAY2VsbEFyZWFSYWRzMgBwb2x5Z29uLT5uZXh0ID09IE5VTEwAbGlua2VkR2VvLmMAYWRkTmV3TGlua2VkUG9seWdvbgBuZXh0ICE9IE5VTEwAbG9vcCAhPSBOVUxMAGFkZE5ld0xpbmtlZExvb3AAcG9seWdvbi0+Zmlyc3QgPT0gTlVMTABhZGRMaW5rZWRMb29wAGNvb3JkICE9IE5VTEwAYWRkTGlua2VkQ29vcmQAbG9vcC0+Zmlyc3QgPT0gTlVMTABpbm5lckxvb3BzICE9IE5VTEwAbm9ybWFsaXplTXVsdGlQb2x5Z29uAGJib3hlcyAhPSBOVUxMAGNhbmRpZGF0ZXMgIT0gTlVMTABmaW5kUG9seWdvbkZvckhvbGUAY2FuZGlkYXRlQkJveGVzICE9IE5VTEwAcmV2RGlyICE9IElOVkFMSURfRElHSVQAbG9jYWxpai5jAGNlbGxUb0xvY2FsSWprAGJhc2VDZWxsICE9IG9yaWdpbkJhc2VDZWxsACEob3JpZ2luT25QZW50ICYmIGluZGV4T25QZW50KQBiYXNlQ2VsbCA9PSBvcmlnaW5CYXNlQ2VsbABiYXNlQ2VsbCAhPSBJTlZBTElEX0JBU0VfQ0VMTABsb2NhbElqa1RvQ2VsbAAhX2lzQmFzZUNlbGxQZW50YWdvbihiYXNlQ2VsbCkAYmFzZUNlbGxSb3RhdGlvbnMgPj0gMABncmlkUGF0aENlbGxzADAAdmVydGV4LmMAY2VsbFRvVmVydGV4AGdyYXBoLT5idWNrZXRzICE9IE5VTEwAdmVydGV4R3JhcGguYwBpbml0VmVydGV4R3JhcGgAbm9kZSAhPSBOVUxMAGFkZFZlcnRleE5vZGU=";
  var tempDoublePtr = 24144;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x2) {
      var y2 = demangle(x2);
      return x2 === y2 ? x2 : y2 + " [" + x2 + "]";
    });
  }
  function jsStackTrace() {
    var err2 = new Error();
    if (!err2.stack) {
      try {
        throw new Error(0);
      } catch (e2) {
        err2 = e2;
      }
      if (!err2.stack) {
        return "(no stack trace available)";
      }
    }
    return err2.stack.toString();
  }
  function stackTrace() {
    var js = jsStackTrace();
    if (Module["extraStackTrace"]) {
      js += "\n" + Module["extraStackTrace"]();
    }
    return demangleAll(js);
  }
  function ___assert_fail(condition, filename, line, func) {
    abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  }
  function _emscripten_get_heap_size() {
    return HEAP8.length;
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
  }
  function ___setErrNo(value) {
    if (Module["___errno_location"]) {
      HEAP32[Module["___errno_location"]() >> 2] = value;
    }
    return value;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function emscripten_realloc_buffer(size) {
    try {
      var newBuffer = new ArrayBuffer(size);
      if (newBuffer.byteLength != size) {
        return;
      }
      new Int8Array(newBuffer).set(HEAP8);
      _emscripten_replace_memory(newBuffer);
      updateGlobalBufferAndViews(newBuffer);
      return 1;
    } catch (e2) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = _emscripten_get_heap_size();
    var PAGE_MULTIPLE = 16777216;
    var LIMIT = 2147483648 - PAGE_MULTIPLE;
    if (requestedSize > LIMIT) {
      return false;
    }
    var MIN_TOTAL_MEMORY = 16777216;
    var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
    while (newSize < requestedSize) {
      if (newSize <= 536870912) {
        newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
      } else {
        newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
      }
    }
    var replacement = emscripten_realloc_buffer(newSize);
    if (!replacement) {
      return false;
    }
    return true;
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i3 = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i3++));
      enc2 = keyStr.indexOf(input.charAt(i3++));
      enc3 = keyStr.indexOf(input.charAt(i3++));
      enc4 = keyStr.indexOf(input.charAt(i3++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i3 < input.length);
    return output;
  };
  function intArrayFromBase64(s2) {
    try {
      var decoded = decodeBase64(s2);
      var bytes = new Uint8Array(decoded.length);
      for (var i3 = 0; i3 < decoded.length; ++i3) {
        bytes[i3] = decoded.charCodeAt(i3);
      }
      return bytes;
    } catch (_2) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }
    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array
  };
  var asmLibraryArg = {
    "a": abort,
    "b": setTempRet0,
    "c": getTempRet0,
    "d": ___assert_fail,
    "e": ___setErrNo,
    "f": _emscripten_get_heap_size,
    "g": _emscripten_memcpy_big,
    "h": _emscripten_resize_heap,
    "i": abortOnCannotGrowMemory,
    "j": demangle,
    "k": demangleAll,
    "l": emscripten_realloc_buffer,
    "m": jsStackTrace,
    "n": stackTrace,
    "o": tempDoublePtr,
    "p": DYNAMICTOP_PTR
  };
  var asm = (
    /** @suppress {uselessCode} */
    function(global2, env, buffer2) {
      "almost asm";
      var a3 = new global2.Int8Array(buffer2), b2 = new global2.Int32Array(buffer2), c2 = new global2.Uint8Array(buffer2), d = new global2.Float32Array(buffer2), e2 = new global2.Float64Array(buffer2), f2 = env.o | 0, g = env.p | 0, p2 = global2.Math.floor, q = global2.Math.abs, r2 = global2.Math.sqrt, s2 = global2.Math.pow, t2 = global2.Math.cos, u = global2.Math.sin, v = global2.Math.tan, w = global2.Math.acos, x2 = global2.Math.asin, y2 = global2.Math.atan, z = global2.Math.atan2, A = global2.Math.ceil, B = global2.Math.imul, C = global2.Math.min, D = global2.Math.max, E = global2.Math.clz32, G = env.b, H = env.c, I = env.d, J = env.e, K = env.f, L = env.g, M = env.h, N = env.i, T = 24160;
      function W(newBuffer) {
        a3 = new Int8Array(newBuffer);
        c2 = new Uint8Array(newBuffer);
        b2 = new Int32Array(newBuffer);
        d = new Float32Array(newBuffer);
        e2 = new Float64Array(newBuffer);
        buffer2 = newBuffer;
        return true;
      }
      function X(a4) {
        a4 = a4 | 0;
        var b3 = 0;
        b3 = T;
        T = T + a4 | 0;
        T = T + 15 & -16;
        return b3 | 0;
      }
      function Y() {
        return T | 0;
      }
      function Z(a4) {
        a4 = a4 | 0;
        T = a4;
      }
      function _2(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        T = a4;
      }
      function $(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0;
        if ((a4 | 0) < 0) {
          c3 = 2;
          return c3 | 0;
        }
        if ((a4 | 0) > 13780509) {
          c3 = ic(15, c3) | 0;
          return c3 | 0;
        } else {
          d2 = ((a4 | 0) < 0) << 31 >> 31;
          f3 = rd(a4 | 0, d2 | 0, 3, 0) | 0;
          e3 = H() | 0;
          d2 = ld(a4 | 0, d2 | 0, 1, 0) | 0;
          d2 = rd(f3 | 0, e3 | 0, d2 | 0, H() | 0) | 0;
          d2 = ld(d2 | 0, H() | 0, 1, 0) | 0;
          a4 = H() | 0;
          b2[c3 >> 2] = d2;
          b2[c3 + 4 >> 2] = a4;
          c3 = 0;
          return c3 | 0;
        }
        return 0;
      }
      function aa(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        return ba(a4, b3, c3, d2, 0) | 0;
      }
      function ba(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        h = j;
        if (!(ca(a4, c3, d2, e3, f3) | 0)) {
          e3 = 0;
          T = j;
          return e3 | 0;
        }
        do {
          if ((d2 | 0) >= 0) {
            if ((d2 | 0) > 13780509) {
              g2 = ic(15, h) | 0;
              if (g2 | 0) {
                break;
              }
              i3 = h;
              h = b2[i3 >> 2] | 0;
              i3 = b2[i3 + 4 >> 2] | 0;
            } else {
              g2 = ((d2 | 0) < 0) << 31 >> 31;
              k = rd(d2 | 0, g2 | 0, 3, 0) | 0;
              i3 = H() | 0;
              g2 = ld(d2 | 0, g2 | 0, 1, 0) | 0;
              g2 = rd(k | 0, i3 | 0, g2 | 0, H() | 0) | 0;
              g2 = ld(g2 | 0, H() | 0, 1, 0) | 0;
              i3 = H() | 0;
              b2[h >> 2] = g2;
              b2[h + 4 >> 2] = i3;
              h = g2;
            }
            Bd(e3 | 0, 0, h << 3 | 0) | 0;
            if (f3 | 0) {
              Bd(f3 | 0, 0, h << 2 | 0) | 0;
              g2 = da(a4, c3, d2, e3, f3, h, i3, 0) | 0;
              break;
            }
            g2 = kd(h, 4) | 0;
            if (!g2) {
              g2 = 13;
            } else {
              k = da(a4, c3, d2, e3, g2, h, i3, 0) | 0;
              jd(g2);
              g2 = k;
            }
          } else {
            g2 = 2;
          }
        } while (0);
        k = g2;
        T = j;
        return k | 0;
      }
      function ca(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        o2 = q2;
        p3 = q2 + 8 | 0;
        n2 = o2;
        b2[n2 >> 2] = a4;
        b2[n2 + 4 >> 2] = c3;
        if ((d2 | 0) < 0) {
          p3 = 2;
          T = q2;
          return p3 | 0;
        }
        g2 = e3;
        b2[g2 >> 2] = a4;
        b2[g2 + 4 >> 2] = c3;
        g2 = (f3 | 0) != 0;
        if (g2) {
          b2[f3 >> 2] = 0;
        }
        if (xb(a4, c3) | 0) {
          p3 = 9;
          T = q2;
          return p3 | 0;
        }
        b2[p3 >> 2] = 0;
        a:
          do {
            if ((d2 | 0) >= 1) {
              if (g2) {
                l2 = 1;
                k = 0;
                m = 0;
                n2 = 1;
                g2 = a4;
                while (1) {
                  if (!(k | m)) {
                    g2 = ea(g2, c3, 4, p3, o2) | 0;
                    if (g2 | 0) {
                      break a;
                    }
                    c3 = o2;
                    g2 = b2[c3 >> 2] | 0;
                    c3 = b2[c3 + 4 >> 2] | 0;
                    if (xb(g2, c3) | 0) {
                      g2 = 9;
                      break a;
                    }
                  }
                  g2 = ea(g2, c3, b2[22384 + (m << 2) >> 2] | 0, p3, o2) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o2;
                  g2 = b2[c3 >> 2] | 0;
                  c3 = b2[c3 + 4 >> 2] | 0;
                  a4 = e3 + (l2 << 3) | 0;
                  b2[a4 >> 2] = g2;
                  b2[a4 + 4 >> 2] = c3;
                  b2[f3 + (l2 << 2) >> 2] = n2;
                  a4 = k + 1 | 0;
                  h = (a4 | 0) == (n2 | 0);
                  i3 = m + 1 | 0;
                  j = (i3 | 0) == 6;
                  if (xb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                  n2 = n2 + (j & h & 1) | 0;
                  if ((n2 | 0) > (d2 | 0)) {
                    g2 = 0;
                    break;
                  } else {
                    l2 = l2 + 1 | 0;
                    k = h ? 0 : a4;
                    m = h ? j ? 0 : i3 : m;
                  }
                }
              } else {
                l2 = 1;
                k = 0;
                m = 0;
                n2 = 1;
                g2 = a4;
                while (1) {
                  if (!(k | m)) {
                    g2 = ea(g2, c3, 4, p3, o2) | 0;
                    if (g2 | 0) {
                      break a;
                    }
                    c3 = o2;
                    g2 = b2[c3 >> 2] | 0;
                    c3 = b2[c3 + 4 >> 2] | 0;
                    if (xb(g2, c3) | 0) {
                      g2 = 9;
                      break a;
                    }
                  }
                  g2 = ea(g2, c3, b2[22384 + (m << 2) >> 2] | 0, p3, o2) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o2;
                  g2 = b2[c3 >> 2] | 0;
                  c3 = b2[c3 + 4 >> 2] | 0;
                  a4 = e3 + (l2 << 3) | 0;
                  b2[a4 >> 2] = g2;
                  b2[a4 + 4 >> 2] = c3;
                  a4 = k + 1 | 0;
                  h = (a4 | 0) == (n2 | 0);
                  i3 = m + 1 | 0;
                  j = (i3 | 0) == 6;
                  if (xb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                  n2 = n2 + (j & h & 1) | 0;
                  if ((n2 | 0) > (d2 | 0)) {
                    g2 = 0;
                    break;
                  } else {
                    l2 = l2 + 1 | 0;
                    k = h ? 0 : a4;
                    m = h ? j ? 0 : i3 : m;
                  }
                }
              }
            } else {
              g2 = 0;
            }
          } while (0);
        p3 = g2;
        T = q2;
        return p3 | 0;
      }
      function da(a4, c3, d2, e3, f3, g2, h, i3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i3 = i3 | 0;
        var j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0;
        q2 = T;
        T = T + 16 | 0;
        o2 = q2 + 8 | 0;
        p3 = q2;
        j = td(a4 | 0, c3 | 0, g2 | 0, h | 0) | 0;
        l2 = H() | 0;
        m = e3 + (j << 3) | 0;
        r3 = m;
        s3 = b2[r3 >> 2] | 0;
        r3 = b2[r3 + 4 >> 2] | 0;
        k = (s3 | 0) == (a4 | 0) & (r3 | 0) == (c3 | 0);
        if (!((s3 | 0) == 0 & (r3 | 0) == 0 | k)) {
          do {
            j = ld(j | 0, l2 | 0, 1, 0) | 0;
            j = sd(j | 0, H() | 0, g2 | 0, h | 0) | 0;
            l2 = H() | 0;
            m = e3 + (j << 3) | 0;
            s3 = m;
            r3 = b2[s3 >> 2] | 0;
            s3 = b2[s3 + 4 >> 2] | 0;
            k = (r3 | 0) == (a4 | 0) & (s3 | 0) == (c3 | 0);
          } while (!((r3 | 0) == 0 & (s3 | 0) == 0 | k));
        }
        j = f3 + (j << 2) | 0;
        if (k ? (b2[j >> 2] | 0) <= (i3 | 0) : 0) {
          s3 = 0;
          T = q2;
          return s3 | 0;
        }
        s3 = m;
        b2[s3 >> 2] = a4;
        b2[s3 + 4 >> 2] = c3;
        b2[j >> 2] = i3;
        if ((i3 | 0) >= (d2 | 0)) {
          s3 = 0;
          T = q2;
          return s3 | 0;
        }
        k = i3 + 1 | 0;
        b2[o2 >> 2] = 0;
        j = ea(a4, c3, 2, o2, p3) | 0;
        switch (j | 0) {
          case 9: {
            n2 = 9;
            break;
          }
          case 0: {
            j = p3;
            j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
            if (!j) {
              n2 = 9;
            }
            break;
          }
          default:
        }
        a:
          do {
            if ((n2 | 0) == 9) {
              b2[o2 >> 2] = 0;
              j = ea(a4, c3, 3, o2, p3) | 0;
              switch (j | 0) {
                case 9:
                  break;
                case 0: {
                  j = p3;
                  j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
                  if (j | 0) {
                    break a;
                  }
                  break;
                }
                default:
                  break a;
              }
              b2[o2 >> 2] = 0;
              j = ea(a4, c3, 1, o2, p3) | 0;
              switch (j | 0) {
                case 9:
                  break;
                case 0: {
                  j = p3;
                  j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
                  if (j | 0) {
                    break a;
                  }
                  break;
                }
                default:
                  break a;
              }
              b2[o2 >> 2] = 0;
              j = ea(a4, c3, 5, o2, p3) | 0;
              switch (j | 0) {
                case 9:
                  break;
                case 0: {
                  j = p3;
                  j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
                  if (j | 0) {
                    break a;
                  }
                  break;
                }
                default:
                  break a;
              }
              b2[o2 >> 2] = 0;
              j = ea(a4, c3, 4, o2, p3) | 0;
              switch (j | 0) {
                case 9:
                  break;
                case 0: {
                  j = p3;
                  j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
                  if (j | 0) {
                    break a;
                  }
                  break;
                }
                default:
                  break a;
              }
              b2[o2 >> 2] = 0;
              j = ea(a4, c3, 6, o2, p3) | 0;
              switch (j | 0) {
                case 9:
                  break;
                case 0: {
                  j = p3;
                  j = da(b2[j >> 2] | 0, b2[j + 4 >> 2] | 0, d2, e3, f3, g2, h, k) | 0;
                  if (j | 0) {
                    break a;
                  }
                  break;
                }
                default:
                  break a;
              }
              s3 = 0;
              T = q2;
              return s3 | 0;
            }
          } while (0);
        s3 = j;
        T = q2;
        return s3 | 0;
      }
      function ea(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
        if (d2 >>> 0 > 6) {
          f3 = 1;
          return f3 | 0;
        }
        m = (b2[e3 >> 2] | 0) % 6 | 0;
        b2[e3 >> 2] = m;
        if ((m | 0) > 0) {
          g2 = 0;
          do {
            d2 = Sa(d2) | 0;
            g2 = g2 + 1 | 0;
          } while ((g2 | 0) < (b2[e3 >> 2] | 0));
        }
        m = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        l2 = m & 127;
        if (l2 >>> 0 > 121) {
          f3 = 5;
          return f3 | 0;
        }
        j = Fb(a4, c3) | 0;
        g2 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        a:
          do {
            if (!g2) {
              k = 8;
            } else {
              while (1) {
                h = (15 - g2 | 0) * 3 | 0;
                i3 = vd(a4 | 0, c3 | 0, h | 0) | 0;
                H() | 0;
                i3 = i3 & 7;
                if ((i3 | 0) == 7) {
                  c3 = 5;
                  break;
                }
                p3 = (Lb(g2) | 0) == 0;
                g2 = g2 + -1 | 0;
                n2 = wd(7, 0, h | 0) | 0;
                c3 = c3 & ~(H() | 0);
                o2 = wd(b2[(p3 ? 432 : 16) + (i3 * 28 | 0) + (d2 << 2) >> 2] | 0, 0, h | 0) | 0;
                h = H() | 0;
                d2 = b2[(p3 ? 640 : 224) + (i3 * 28 | 0) + (d2 << 2) >> 2] | 0;
                a4 = o2 | a4 & ~n2;
                c3 = h | c3;
                if (!d2) {
                  d2 = 0;
                  break a;
                }
                if (!g2) {
                  k = 8;
                  break a;
                }
              }
              return c3 | 0;
            }
          } while (0);
        if ((k | 0) == 8) {
          p3 = b2[848 + (l2 * 28 | 0) + (d2 << 2) >> 2] | 0;
          o2 = wd(p3 | 0, 0, 45) | 0;
          a4 = o2 | a4;
          c3 = H() | 0 | c3 & -1040385;
          d2 = b2[4272 + (l2 * 28 | 0) + (d2 << 2) >> 2] | 0;
          if ((p3 & 127 | 0) == 127) {
            p3 = wd(b2[848 + (l2 * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
            c3 = H() | 0 | c3 & -1040385;
            d2 = b2[4272 + (l2 * 28 | 0) + 20 >> 2] | 0;
            a4 = Hb(p3 | a4, c3) | 0;
            c3 = H() | 0;
            b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
          }
        }
        i3 = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        i3 = i3 & 127;
        b:
          do {
            if (!(ma(i3) | 0)) {
              if ((d2 | 0) > 0) {
                g2 = 0;
                do {
                  a4 = Hb(a4, c3) | 0;
                  c3 = H() | 0;
                  g2 = g2 + 1 | 0;
                } while ((g2 | 0) != (d2 | 0));
              }
            } else {
              c:
                do {
                  if ((Fb(a4, c3) | 0) == 1) {
                    if ((l2 | 0) != (i3 | 0)) {
                      if (sa(i3, b2[7696 + (l2 * 28 | 0) >> 2] | 0) | 0) {
                        a4 = Jb(a4, c3) | 0;
                        h = 1;
                        c3 = H() | 0;
                        break;
                      } else {
                        I(23313, 22416, 436, 22424);
                      }
                    }
                    switch (j | 0) {
                      case 3: {
                        a4 = Hb(a4, c3) | 0;
                        c3 = H() | 0;
                        b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
                        h = 0;
                        break c;
                      }
                      case 5: {
                        a4 = Jb(a4, c3) | 0;
                        c3 = H() | 0;
                        b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 5;
                        h = 0;
                        break c;
                      }
                      case 0: {
                        p3 = 9;
                        return p3 | 0;
                      }
                      default: {
                        p3 = 1;
                        return p3 | 0;
                      }
                    }
                  } else {
                    h = 0;
                  }
                } while (0);
              if ((d2 | 0) > 0) {
                g2 = 0;
                do {
                  a4 = Gb(a4, c3) | 0;
                  c3 = H() | 0;
                  g2 = g2 + 1 | 0;
                } while ((g2 | 0) != (d2 | 0));
              }
              if ((l2 | 0) != (i3 | 0)) {
                if (!(na(i3) | 0)) {
                  if ((h | 0) != 0 | (Fb(a4, c3) | 0) != 5) {
                    break;
                  }
                  b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
                  break;
                }
                switch (m & 127) {
                  case 8:
                  case 118:
                    break b;
                  default:
                }
                if ((Fb(a4, c3) | 0) != 3) {
                  b2[e3 >> 2] = (b2[e3 >> 2] | 0) + 1;
                }
              }
            }
          } while (0);
        b2[e3 >> 2] = ((b2[e3 >> 2] | 0) + d2 | 0) % 6 | 0;
        p3 = f3;
        b2[p3 >> 2] = a4;
        b2[p3 + 4 >> 2] = c3;
        p3 = 0;
        return p3 | 0;
      }
      function fa(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        i3 = T;
        T = T + 16 | 0;
        g2 = i3;
        h = i3 + 8 | 0;
        f3 = (xb(a4, c3) | 0) == 0;
        f3 = f3 ? 1 : 2;
        while (1) {
          b2[h >> 2] = 0;
          k = (ea(a4, c3, f3, h, g2) | 0) == 0;
          j = g2;
          if (k & ((b2[j >> 2] | 0) == (d2 | 0) ? (b2[j + 4 >> 2] | 0) == (e3 | 0) : 0)) {
            a4 = 4;
            break;
          }
          f3 = f3 + 1 | 0;
          if (f3 >>> 0 >= 7) {
            f3 = 7;
            a4 = 4;
            break;
          }
        }
        if ((a4 | 0) == 4) {
          T = i3;
          return f3 | 0;
        }
        return 0;
      }
      function ga(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
        p3 = T;
        T = T + 16 | 0;
        n2 = p3;
        o2 = p3 + 8 | 0;
        m = n2;
        b2[m >> 2] = a4;
        b2[m + 4 >> 2] = c3;
        if (!d2) {
          o2 = e3;
          b2[o2 >> 2] = a4;
          b2[o2 + 4 >> 2] = c3;
          o2 = 0;
          T = p3;
          return o2 | 0;
        }
        b2[o2 >> 2] = 0;
        a:
          do {
            if (!(xb(a4, c3) | 0)) {
              g2 = (d2 | 0) > 0;
              if (g2) {
                f3 = 0;
                m = a4;
                do {
                  a4 = ea(m, c3, 4, o2, n2) | 0;
                  if (a4 | 0) {
                    break a;
                  }
                  c3 = n2;
                  m = b2[c3 >> 2] | 0;
                  c3 = b2[c3 + 4 >> 2] | 0;
                  f3 = f3 + 1 | 0;
                  if (xb(m, c3) | 0) {
                    a4 = 9;
                    break a;
                  }
                } while ((f3 | 0) < (d2 | 0));
                l2 = e3;
                b2[l2 >> 2] = m;
                b2[l2 + 4 >> 2] = c3;
                l2 = d2 + -1 | 0;
                if (g2) {
                  k = 0;
                  a4 = 1;
                  do {
                    f3 = 22384 + (k << 2) | 0;
                    if ((k | 0) == 5) {
                      h = b2[f3 >> 2] | 0;
                      g2 = 0;
                      f3 = a4;
                      while (1) {
                        a4 = n2;
                        a4 = ea(b2[a4 >> 2] | 0, b2[a4 + 4 >> 2] | 0, h, o2, n2) | 0;
                        if (a4 | 0) {
                          break a;
                        }
                        if ((g2 | 0) != (l2 | 0)) {
                          j = n2;
                          i3 = b2[j >> 2] | 0;
                          j = b2[j + 4 >> 2] | 0;
                          a4 = e3 + (f3 << 3) | 0;
                          b2[a4 >> 2] = i3;
                          b2[a4 + 4 >> 2] = j;
                          if (!(xb(i3, j) | 0)) {
                            a4 = f3 + 1 | 0;
                          } else {
                            a4 = 9;
                            break a;
                          }
                        } else {
                          a4 = f3;
                        }
                        g2 = g2 + 1 | 0;
                        if ((g2 | 0) >= (d2 | 0)) {
                          break;
                        } else {
                          f3 = a4;
                        }
                      }
                    } else {
                      h = n2;
                      j = b2[f3 >> 2] | 0;
                      i3 = 0;
                      f3 = a4;
                      g2 = b2[h >> 2] | 0;
                      h = b2[h + 4 >> 2] | 0;
                      while (1) {
                        a4 = ea(g2, h, j, o2, n2) | 0;
                        if (a4 | 0) {
                          break a;
                        }
                        h = n2;
                        g2 = b2[h >> 2] | 0;
                        h = b2[h + 4 >> 2] | 0;
                        a4 = e3 + (f3 << 3) | 0;
                        b2[a4 >> 2] = g2;
                        b2[a4 + 4 >> 2] = h;
                        a4 = f3 + 1 | 0;
                        if (xb(g2, h) | 0) {
                          a4 = 9;
                          break a;
                        }
                        i3 = i3 + 1 | 0;
                        if ((i3 | 0) >= (d2 | 0)) {
                          break;
                        } else {
                          f3 = a4;
                        }
                      }
                    }
                    k = k + 1 | 0;
                  } while (k >>> 0 < 6);
                  a4 = n2;
                  h = m;
                  f3 = b2[a4 >> 2] | 0;
                  g2 = c3;
                  a4 = b2[a4 + 4 >> 2] | 0;
                } else {
                  h = m;
                  f3 = m;
                  g2 = c3;
                  a4 = c3;
                }
              } else {
                h = e3;
                b2[h >> 2] = a4;
                b2[h + 4 >> 2] = c3;
                h = a4;
                f3 = a4;
                g2 = c3;
                a4 = c3;
              }
              a4 = (h | 0) == (f3 | 0) & (g2 | 0) == (a4 | 0) ? 0 : 9;
            } else {
              a4 = 9;
            }
          } while (0);
        o2 = a4;
        T = p3;
        return o2 | 0;
      }
      function ha(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        i3 = T;
        T = T + 48 | 0;
        f3 = i3 + 16 | 0;
        g2 = i3 + 8 | 0;
        h = i3;
        if (d2 | 0) {
          h = 15;
          T = i3;
          return h | 0;
        }
        k = a4;
        j = b2[k + 4 >> 2] | 0;
        d2 = g2;
        b2[d2 >> 2] = b2[k >> 2];
        b2[d2 + 4 >> 2] = j;
        Ec(g2, f3);
        c3 = za(f3, c3, h) | 0;
        if (!c3) {
          d2 = b2[g2 >> 2] | 0;
          g2 = b2[a4 + 8 >> 2] | 0;
          if ((g2 | 0) > 0) {
            f3 = b2[a4 + 12 >> 2] | 0;
            c3 = 0;
            do {
              d2 = (b2[f3 + (c3 << 3) >> 2] | 0) + d2 | 0;
              c3 = c3 + 1 | 0;
            } while ((c3 | 0) < (g2 | 0));
          }
          c3 = h;
          f3 = b2[c3 >> 2] | 0;
          c3 = b2[c3 + 4 >> 2] | 0;
          g2 = ((d2 | 0) < 0) << 31 >> 31;
          if ((c3 | 0) < (g2 | 0) | (c3 | 0) == (g2 | 0) & f3 >>> 0 < d2 >>> 0) {
            c3 = h;
            b2[c3 >> 2] = d2;
            b2[c3 + 4 >> 2] = g2;
            c3 = g2;
          } else {
            d2 = f3;
          }
          j = ld(d2 | 0, c3 | 0, 12, 0) | 0;
          k = H() | 0;
          c3 = h;
          b2[c3 >> 2] = j;
          b2[c3 + 4 >> 2] = k;
          c3 = e3;
          b2[c3 >> 2] = j;
          b2[c3 + 4 >> 2] = k;
          c3 = 0;
        }
        k = c3;
        T = i3;
        return k | 0;
      }
      function ia(a4, c3, d2, f3, g2, h, i3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i3 = i3 | 0;
        var j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F = 0, G2 = 0, I2 = 0, J2 = 0, K2 = 0, L2 = 0, M2 = 0;
        I2 = T;
        T = T + 64 | 0;
        D2 = I2 + 48 | 0;
        E2 = I2 + 32 | 0;
        F = I2 + 24 | 0;
        x3 = I2 + 8 | 0;
        y3 = I2;
        k = b2[a4 >> 2] | 0;
        if ((k | 0) <= 0) {
          G2 = 0;
          T = I2;
          return G2 | 0;
        }
        z2 = a4 + 4 | 0;
        A2 = D2 + 8 | 0;
        B2 = E2 + 8 | 0;
        C2 = x3 + 8 | 0;
        j = 0;
        v2 = 0;
        while (1) {
          l2 = b2[z2 >> 2] | 0;
          u2 = l2 + (v2 << 4) | 0;
          b2[D2 >> 2] = b2[u2 >> 2];
          b2[D2 + 4 >> 2] = b2[u2 + 4 >> 2];
          b2[D2 + 8 >> 2] = b2[u2 + 8 >> 2];
          b2[D2 + 12 >> 2] = b2[u2 + 12 >> 2];
          if ((v2 | 0) == (k + -1 | 0)) {
            b2[E2 >> 2] = b2[l2 >> 2];
            b2[E2 + 4 >> 2] = b2[l2 + 4 >> 2];
            b2[E2 + 8 >> 2] = b2[l2 + 8 >> 2];
            b2[E2 + 12 >> 2] = b2[l2 + 12 >> 2];
          } else {
            u2 = l2 + (v2 + 1 << 4) | 0;
            b2[E2 >> 2] = b2[u2 >> 2];
            b2[E2 + 4 >> 2] = b2[u2 + 4 >> 2];
            b2[E2 + 8 >> 2] = b2[u2 + 8 >> 2];
            b2[E2 + 12 >> 2] = b2[u2 + 12 >> 2];
          }
          k = Aa(D2, E2, f3, F) | 0;
          a:
            do {
              if (!k) {
                l2 = F;
                k = b2[l2 >> 2] | 0;
                l2 = b2[l2 + 4 >> 2] | 0;
                if ((l2 | 0) > 0 | (l2 | 0) == 0 & k >>> 0 > 0) {
                  t3 = 0;
                  u2 = 0;
                  b:
                    while (1) {
                      M2 = +e2[D2 >> 3];
                      s3 = md(k | 0, l2 | 0, t3 | 0, u2 | 0) | 0;
                      L2 = +(s3 >>> 0) + 4294967296 * +(H() | 0);
                      J2 = +(k >>> 0) + 4294967296 * +(l2 | 0);
                      K2 = +(t3 >>> 0) + 4294967296 * +(u2 | 0);
                      e2[x3 >> 3] = M2 * L2 / J2 + +e2[E2 >> 3] * K2 / J2;
                      e2[C2 >> 3] = +e2[A2 >> 3] * L2 / J2 + +e2[B2 >> 3] * K2 / J2;
                      k = Mb(x3, f3, y3) | 0;
                      if (k | 0) {
                        j = k;
                        break;
                      }
                      s3 = y3;
                      r3 = b2[s3 >> 2] | 0;
                      s3 = b2[s3 + 4 >> 2] | 0;
                      o2 = td(r3 | 0, s3 | 0, c3 | 0, d2 | 0) | 0;
                      m = H() | 0;
                      k = i3 + (o2 << 3) | 0;
                      n2 = k;
                      l2 = b2[n2 >> 2] | 0;
                      n2 = b2[n2 + 4 >> 2] | 0;
                      c:
                        do {
                          if ((l2 | 0) == 0 & (n2 | 0) == 0) {
                            w2 = k;
                            G2 = 16;
                          } else {
                            p3 = 0;
                            q2 = 0;
                            while (1) {
                              if ((p3 | 0) > (d2 | 0) | (p3 | 0) == (d2 | 0) & q2 >>> 0 > c3 >>> 0) {
                                j = 1;
                                break b;
                              }
                              if ((l2 | 0) == (r3 | 0) & (n2 | 0) == (s3 | 0)) {
                                break c;
                              }
                              k = ld(o2 | 0, m | 0, 1, 0) | 0;
                              o2 = sd(k | 0, H() | 0, c3 | 0, d2 | 0) | 0;
                              m = H() | 0;
                              q2 = ld(q2 | 0, p3 | 0, 1, 0) | 0;
                              p3 = H() | 0;
                              k = i3 + (o2 << 3) | 0;
                              n2 = k;
                              l2 = b2[n2 >> 2] | 0;
                              n2 = b2[n2 + 4 >> 2] | 0;
                              if ((l2 | 0) == 0 & (n2 | 0) == 0) {
                                w2 = k;
                                G2 = 16;
                                break;
                              }
                            }
                          }
                        } while (0);
                      if ((G2 | 0) == 16 ? (G2 = 0, !((r3 | 0) == 0 & (s3 | 0) == 0)) : 0) {
                        q2 = w2;
                        b2[q2 >> 2] = r3;
                        b2[q2 + 4 >> 2] = s3;
                        q2 = h + (b2[g2 >> 2] << 3) | 0;
                        b2[q2 >> 2] = r3;
                        b2[q2 + 4 >> 2] = s3;
                        q2 = g2;
                        q2 = ld(b2[q2 >> 2] | 0, b2[q2 + 4 >> 2] | 0, 1, 0) | 0;
                        r3 = H() | 0;
                        s3 = g2;
                        b2[s3 >> 2] = q2;
                        b2[s3 + 4 >> 2] = r3;
                      }
                      t3 = ld(t3 | 0, u2 | 0, 1, 0) | 0;
                      u2 = H() | 0;
                      l2 = F;
                      k = b2[l2 >> 2] | 0;
                      l2 = b2[l2 + 4 >> 2] | 0;
                      if (!((l2 | 0) > (u2 | 0) | (l2 | 0) == (u2 | 0) & k >>> 0 > t3 >>> 0)) {
                        l2 = 1;
                        break a;
                      }
                    }
                  l2 = 0;
                } else {
                  l2 = 1;
                }
              } else {
                l2 = 0;
                j = k;
              }
            } while (0);
          v2 = v2 + 1 | 0;
          if (!l2) {
            G2 = 21;
            break;
          }
          k = b2[a4 >> 2] | 0;
          if ((v2 | 0) >= (k | 0)) {
            j = 0;
            G2 = 21;
            break;
          }
        }
        if ((G2 | 0) == 21) {
          T = I2;
          return j | 0;
        }
        return 0;
      }
      function ja(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F = 0, G2 = 0, I2 = 0, J2 = 0, K2 = 0;
        K2 = T;
        T = T + 112 | 0;
        F = K2 + 80 | 0;
        j = K2 + 72 | 0;
        G2 = K2;
        I2 = K2 + 56 | 0;
        if (d2 | 0) {
          J2 = 15;
          T = K2;
          return J2 | 0;
        }
        k = a4 + 8 | 0;
        J2 = id((b2[k >> 2] << 5) + 32 | 0) | 0;
        if (!J2) {
          J2 = 13;
          T = K2;
          return J2 | 0;
        }
        Fc(a4, J2);
        D2 = a4;
        E2 = b2[D2 + 4 >> 2] | 0;
        d2 = j;
        b2[d2 >> 2] = b2[D2 >> 2];
        b2[d2 + 4 >> 2] = E2;
        Ec(j, F);
        d2 = za(F, c3, G2) | 0;
        if (!d2) {
          d2 = b2[j >> 2] | 0;
          g2 = b2[k >> 2] | 0;
          if ((g2 | 0) > 0) {
            h = b2[a4 + 12 >> 2] | 0;
            f3 = 0;
            do {
              d2 = (b2[h + (f3 << 3) >> 2] | 0) + d2 | 0;
              f3 = f3 + 1 | 0;
            } while ((f3 | 0) != (g2 | 0));
            f3 = d2;
          } else {
            f3 = d2;
          }
          d2 = G2;
          g2 = b2[d2 >> 2] | 0;
          d2 = b2[d2 + 4 >> 2] | 0;
          h = ((f3 | 0) < 0) << 31 >> 31;
          if ((d2 | 0) < (h | 0) | (d2 | 0) == (h | 0) & g2 >>> 0 < f3 >>> 0) {
            d2 = G2;
            b2[d2 >> 2] = f3;
            b2[d2 + 4 >> 2] = h;
            d2 = h;
          } else {
            f3 = g2;
          }
          D2 = ld(f3 | 0, d2 | 0, 12, 0) | 0;
          E2 = H() | 0;
          d2 = G2;
          b2[d2 >> 2] = D2;
          b2[d2 + 4 >> 2] = E2;
          d2 = 0;
        } else {
          D2 = 0;
          E2 = 0;
        }
        if (d2 | 0) {
          jd(J2);
          J2 = d2;
          T = K2;
          return J2 | 0;
        }
        f3 = kd(D2, 8) | 0;
        if (!f3) {
          jd(J2);
          J2 = 13;
          T = K2;
          return J2 | 0;
        }
        i3 = kd(D2, 8) | 0;
        if (!i3) {
          jd(J2);
          jd(f3);
          J2 = 13;
          T = K2;
          return J2 | 0;
        }
        B2 = F;
        b2[B2 >> 2] = 0;
        b2[B2 + 4 >> 2] = 0;
        B2 = a4;
        C2 = b2[B2 + 4 >> 2] | 0;
        d2 = j;
        b2[d2 >> 2] = b2[B2 >> 2];
        b2[d2 + 4 >> 2] = C2;
        d2 = ia(j, D2, E2, c3, F, f3, i3) | 0;
        a:
          do {
            if (!d2) {
              b:
                do {
                  if ((b2[k >> 2] | 0) > 0) {
                    h = a4 + 12 | 0;
                    g2 = 0;
                    while (1) {
                      d2 = ia((b2[h >> 2] | 0) + (g2 << 3) | 0, D2, E2, c3, F, f3, i3) | 0;
                      g2 = g2 + 1 | 0;
                      if (d2 | 0) {
                        break;
                      }
                      if ((g2 | 0) >= (b2[k >> 2] | 0)) {
                        break b;
                      }
                    }
                    jd(f3);
                    jd(i3);
                    jd(J2);
                    break a;
                  }
                } while (0);
              if ((E2 | 0) > 0 | (E2 | 0) == 0 & D2 >>> 0 > 0) {
                Bd(i3 | 0, 0, D2 << 3 | 0) | 0;
              }
              C2 = F;
              B2 = b2[C2 + 4 >> 2] | 0;
              c:
                do {
                  if ((B2 | 0) > 0 | (B2 | 0) == 0 & (b2[C2 >> 2] | 0) >>> 0 > 0) {
                    y3 = f3;
                    z2 = i3;
                    A2 = f3;
                    B2 = i3;
                    C2 = f3;
                    d2 = f3;
                    v2 = f3;
                    w2 = i3;
                    x3 = i3;
                    f3 = i3;
                    d:
                      while (1) {
                        r3 = 0;
                        s3 = 0;
                        t3 = 0;
                        u2 = 0;
                        g2 = 0;
                        h = 0;
                        while (1) {
                          i3 = G2;
                          j = i3 + 56 | 0;
                          do {
                            b2[i3 >> 2] = 0;
                            i3 = i3 + 4 | 0;
                          } while ((i3 | 0) < (j | 0));
                          c3 = y3 + (r3 << 3) | 0;
                          k = b2[c3 >> 2] | 0;
                          c3 = b2[c3 + 4 >> 2] | 0;
                          if (ca(k, c3, 1, G2, 0) | 0) {
                            i3 = G2;
                            j = i3 + 56 | 0;
                            do {
                              b2[i3 >> 2] = 0;
                              i3 = i3 + 4 | 0;
                            } while ((i3 | 0) < (j | 0));
                            i3 = kd(7, 4) | 0;
                            if (i3 | 0) {
                              da(k, c3, 1, G2, i3, 7, 0, 0) | 0;
                              jd(i3);
                            }
                          }
                          q2 = 0;
                          while (1) {
                            p3 = G2 + (q2 << 3) | 0;
                            o2 = b2[p3 >> 2] | 0;
                            p3 = b2[p3 + 4 >> 2] | 0;
                            e:
                              do {
                                if (!((o2 | 0) == 0 & (p3 | 0) == 0)) {
                                  l2 = td(o2 | 0, p3 | 0, D2 | 0, E2 | 0) | 0;
                                  k = H() | 0;
                                  i3 = e3 + (l2 << 3) | 0;
                                  c3 = i3;
                                  j = b2[c3 >> 2] | 0;
                                  c3 = b2[c3 + 4 >> 2] | 0;
                                  if (!((j | 0) == 0 & (c3 | 0) == 0)) {
                                    m = 0;
                                    n2 = 0;
                                    do {
                                      if ((m | 0) > (E2 | 0) | (m | 0) == (E2 | 0) & n2 >>> 0 > D2 >>> 0) {
                                        break d;
                                      }
                                      if ((j | 0) == (o2 | 0) & (c3 | 0) == (p3 | 0)) {
                                        i3 = g2;
                                        j = h;
                                        break e;
                                      }
                                      i3 = ld(l2 | 0, k | 0, 1, 0) | 0;
                                      l2 = sd(i3 | 0, H() | 0, D2 | 0, E2 | 0) | 0;
                                      k = H() | 0;
                                      n2 = ld(n2 | 0, m | 0, 1, 0) | 0;
                                      m = H() | 0;
                                      i3 = e3 + (l2 << 3) | 0;
                                      c3 = i3;
                                      j = b2[c3 >> 2] | 0;
                                      c3 = b2[c3 + 4 >> 2] | 0;
                                    } while (!((j | 0) == 0 & (c3 | 0) == 0));
                                  }
                                  if (!((o2 | 0) == 0 & (p3 | 0) == 0)) {
                                    Pb(o2, p3, I2) | 0;
                                    if (Gc(a4, J2, I2) | 0) {
                                      n2 = ld(g2 | 0, h | 0, 1, 0) | 0;
                                      h = H() | 0;
                                      m = i3;
                                      b2[m >> 2] = o2;
                                      b2[m + 4 >> 2] = p3;
                                      g2 = z2 + (g2 << 3) | 0;
                                      b2[g2 >> 2] = o2;
                                      b2[g2 + 4 >> 2] = p3;
                                      g2 = n2;
                                    }
                                    i3 = g2;
                                    j = h;
                                  } else {
                                    i3 = g2;
                                    j = h;
                                  }
                                } else {
                                  i3 = g2;
                                  j = h;
                                }
                              } while (0);
                            q2 = q2 + 1 | 0;
                            if (q2 >>> 0 >= 7) {
                              break;
                            } else {
                              g2 = i3;
                              h = j;
                            }
                          }
                          r3 = ld(r3 | 0, s3 | 0, 1, 0) | 0;
                          s3 = H() | 0;
                          t3 = ld(t3 | 0, u2 | 0, 1, 0) | 0;
                          u2 = H() | 0;
                          h = F;
                          g2 = b2[h >> 2] | 0;
                          h = b2[h + 4 >> 2] | 0;
                          if (!((u2 | 0) < (h | 0) | (u2 | 0) == (h | 0) & t3 >>> 0 < g2 >>> 0)) {
                            break;
                          } else {
                            g2 = i3;
                            h = j;
                          }
                        }
                        if ((h | 0) > 0 | (h | 0) == 0 & g2 >>> 0 > 0) {
                          g2 = 0;
                          h = 0;
                          do {
                            u2 = y3 + (g2 << 3) | 0;
                            b2[u2 >> 2] = 0;
                            b2[u2 + 4 >> 2] = 0;
                            g2 = ld(g2 | 0, h | 0, 1, 0) | 0;
                            h = H() | 0;
                            u2 = F;
                            t3 = b2[u2 + 4 >> 2] | 0;
                          } while ((h | 0) < (t3 | 0) | ((h | 0) == (t3 | 0) ? g2 >>> 0 < (b2[u2 >> 2] | 0) >>> 0 : 0));
                        }
                        u2 = F;
                        b2[u2 >> 2] = i3;
                        b2[u2 + 4 >> 2] = j;
                        if ((j | 0) > 0 | (j | 0) == 0 & i3 >>> 0 > 0) {
                          q2 = f3;
                          r3 = x3;
                          s3 = C2;
                          t3 = w2;
                          u2 = z2;
                          f3 = v2;
                          x3 = d2;
                          w2 = A2;
                          v2 = q2;
                          d2 = r3;
                          C2 = B2;
                          B2 = s3;
                          A2 = t3;
                          z2 = y3;
                          y3 = u2;
                        } else {
                          break c;
                        }
                      }
                    jd(A2);
                    jd(B2);
                    jd(J2);
                    d2 = 1;
                    break a;
                  } else {
                    d2 = i3;
                  }
                } while (0);
              jd(J2);
              jd(f3);
              jd(d2);
              d2 = 0;
            } else {
              jd(f3);
              jd(i3);
              jd(J2);
            }
          } while (0);
        J2 = d2;
        T = K2;
        return J2 | 0;
      }
      function ka(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
        l2 = T;
        T = T + 176 | 0;
        j = l2;
        if ((c3 | 0) < 1) {
          _c(d2, 0, 0);
          k = 0;
          T = l2;
          return k | 0;
        }
        i3 = a4;
        i3 = vd(b2[i3 >> 2] | 0, b2[i3 + 4 >> 2] | 0, 52) | 0;
        H() | 0;
        _c(d2, (c3 | 0) > 6 ? c3 : 6, i3 & 15);
        i3 = 0;
        while (1) {
          e3 = a4 + (i3 << 3) | 0;
          e3 = Qb(b2[e3 >> 2] | 0, b2[e3 + 4 >> 2] | 0, j) | 0;
          if (e3 | 0) {
            break;
          }
          e3 = b2[j >> 2] | 0;
          if ((e3 | 0) > 0) {
            h = 0;
            do {
              g2 = j + 8 + (h << 4) | 0;
              h = h + 1 | 0;
              e3 = j + 8 + (((h | 0) % (e3 | 0) | 0) << 4) | 0;
              f3 = dd(d2, e3, g2) | 0;
              if (!f3) {
                cd(d2, g2, e3) | 0;
              } else {
                bd(d2, f3) | 0;
              }
              e3 = b2[j >> 2] | 0;
            } while ((h | 0) < (e3 | 0));
          }
          i3 = i3 + 1 | 0;
          if ((i3 | 0) >= (c3 | 0)) {
            e3 = 0;
            k = 13;
            break;
          }
        }
        if ((k | 0) == 13) {
          T = l2;
          return e3 | 0;
        }
        $c(d2);
        k = e3;
        T = l2;
        return k | 0;
      }
      function la(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 32 | 0;
        e3 = g2;
        f3 = g2 + 16 | 0;
        a4 = ka(a4, c3, f3) | 0;
        if (a4 | 0) {
          d2 = a4;
          T = g2;
          return d2 | 0;
        }
        b2[d2 >> 2] = 0;
        b2[d2 + 4 >> 2] = 0;
        b2[d2 + 8 >> 2] = 0;
        a4 = ad(f3) | 0;
        if (a4 | 0) {
          do {
            c3 = qc(d2) | 0;
            do {
              rc(c3, a4) | 0;
              h = a4 + 16 | 0;
              b2[e3 >> 2] = b2[h >> 2];
              b2[e3 + 4 >> 2] = b2[h + 4 >> 2];
              b2[e3 + 8 >> 2] = b2[h + 8 >> 2];
              b2[e3 + 12 >> 2] = b2[h + 12 >> 2];
              bd(f3, a4) | 0;
              a4 = ed(f3, e3) | 0;
            } while ((a4 | 0) != 0);
            a4 = ad(f3) | 0;
          } while ((a4 | 0) != 0);
        }
        $c(f3);
        a4 = tc(d2) | 0;
        if (!a4) {
          h = 0;
          T = g2;
          return h | 0;
        }
        sc(d2);
        h = a4;
        T = g2;
        return h | 0;
      }
      function ma(a4) {
        a4 = a4 | 0;
        if (a4 >>> 0 > 121) {
          a4 = 0;
          return a4 | 0;
        }
        a4 = b2[7696 + (a4 * 28 | 0) + 16 >> 2] | 0;
        return a4 | 0;
      }
      function na(a4) {
        a4 = a4 | 0;
        return (a4 | 0) == 4 | (a4 | 0) == 117 | 0;
      }
      function oa(a4) {
        a4 = a4 | 0;
        return b2[11120 + ((b2[a4 >> 2] | 0) * 216 | 0) + ((b2[a4 + 4 >> 2] | 0) * 72 | 0) + ((b2[a4 + 8 >> 2] | 0) * 24 | 0) + (b2[a4 + 12 >> 2] << 3) >> 2] | 0;
      }
      function pa(a4) {
        a4 = a4 | 0;
        return b2[11120 + ((b2[a4 >> 2] | 0) * 216 | 0) + ((b2[a4 + 4 >> 2] | 0) * 72 | 0) + ((b2[a4 + 8 >> 2] | 0) * 24 | 0) + (b2[a4 + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function qa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        a4 = 7696 + (a4 * 28 | 0) | 0;
        b2[c3 >> 2] = b2[a4 >> 2];
        b2[c3 + 4 >> 2] = b2[a4 + 4 >> 2];
        b2[c3 + 8 >> 2] = b2[a4 + 8 >> 2];
        b2[c3 + 12 >> 2] = b2[a4 + 12 >> 2];
        return;
      }
      function ra(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0;
        if (c3 >>> 0 > 20) {
          c3 = -1;
          return c3 | 0;
        }
        do {
          if ((b2[11120 + (c3 * 216 | 0) >> 2] | 0) != (a4 | 0)) {
            if ((b2[11120 + (c3 * 216 | 0) + 8 >> 2] | 0) != (a4 | 0)) {
              if ((b2[11120 + (c3 * 216 | 0) + 16 >> 2] | 0) != (a4 | 0)) {
                if ((b2[11120 + (c3 * 216 | 0) + 24 >> 2] | 0) != (a4 | 0)) {
                  if ((b2[11120 + (c3 * 216 | 0) + 32 >> 2] | 0) != (a4 | 0)) {
                    if ((b2[11120 + (c3 * 216 | 0) + 40 >> 2] | 0) != (a4 | 0)) {
                      if ((b2[11120 + (c3 * 216 | 0) + 48 >> 2] | 0) != (a4 | 0)) {
                        if ((b2[11120 + (c3 * 216 | 0) + 56 >> 2] | 0) != (a4 | 0)) {
                          if ((b2[11120 + (c3 * 216 | 0) + 64 >> 2] | 0) != (a4 | 0)) {
                            if ((b2[11120 + (c3 * 216 | 0) + 72 >> 2] | 0) != (a4 | 0)) {
                              if ((b2[11120 + (c3 * 216 | 0) + 80 >> 2] | 0) != (a4 | 0)) {
                                if ((b2[11120 + (c3 * 216 | 0) + 88 >> 2] | 0) != (a4 | 0)) {
                                  if ((b2[11120 + (c3 * 216 | 0) + 96 >> 2] | 0) != (a4 | 0)) {
                                    if ((b2[11120 + (c3 * 216 | 0) + 104 >> 2] | 0) != (a4 | 0)) {
                                      if ((b2[11120 + (c3 * 216 | 0) + 112 >> 2] | 0) != (a4 | 0)) {
                                        if ((b2[11120 + (c3 * 216 | 0) + 120 >> 2] | 0) != (a4 | 0)) {
                                          if ((b2[11120 + (c3 * 216 | 0) + 128 >> 2] | 0) != (a4 | 0)) {
                                            if ((b2[11120 + (c3 * 216 | 0) + 136 >> 2] | 0) == (a4 | 0)) {
                                              a4 = 2;
                                              d2 = 1;
                                              e3 = 2;
                                            } else {
                                              if ((b2[11120 + (c3 * 216 | 0) + 144 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 152 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 160 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 168 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 176 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 184 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 192 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 200 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b2[11120 + (c3 * 216 | 0) + 208 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              } else {
                                                a4 = -1;
                                              }
                                              return a4 | 0;
                                            }
                                          } else {
                                            a4 = 2;
                                            d2 = 1;
                                            e3 = 1;
                                          }
                                        } else {
                                          a4 = 2;
                                          d2 = 1;
                                          e3 = 0;
                                        }
                                      } else {
                                        a4 = 1;
                                        d2 = 1;
                                        e3 = 2;
                                      }
                                    } else {
                                      a4 = 1;
                                      d2 = 1;
                                      e3 = 1;
                                    }
                                  } else {
                                    a4 = 1;
                                    d2 = 1;
                                    e3 = 0;
                                  }
                                } else {
                                  a4 = 0;
                                  d2 = 1;
                                  e3 = 2;
                                }
                              } else {
                                a4 = 0;
                                d2 = 1;
                                e3 = 1;
                              }
                            } else {
                              a4 = 0;
                              d2 = 1;
                              e3 = 0;
                            }
                          } else {
                            a4 = 2;
                            d2 = 0;
                            e3 = 2;
                          }
                        } else {
                          a4 = 2;
                          d2 = 0;
                          e3 = 1;
                        }
                      } else {
                        a4 = 2;
                        d2 = 0;
                        e3 = 0;
                      }
                    } else {
                      a4 = 1;
                      d2 = 0;
                      e3 = 2;
                    }
                  } else {
                    a4 = 1;
                    d2 = 0;
                    e3 = 1;
                  }
                } else {
                  a4 = 1;
                  d2 = 0;
                  e3 = 0;
                }
              } else {
                a4 = 0;
                d2 = 0;
                e3 = 2;
              }
            } else {
              a4 = 0;
              d2 = 0;
              e3 = 1;
            }
          } else {
            a4 = 0;
            d2 = 0;
            e3 = 0;
          }
        } while (0);
        c3 = b2[11120 + (c3 * 216 | 0) + (d2 * 72 | 0) + (a4 * 24 | 0) + (e3 << 3) + 4 >> 2] | 0;
        return c3 | 0;
      }
      function sa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        if ((b2[7696 + (a4 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        c3 = (b2[7696 + (a4 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0);
        return c3 | 0;
      }
      function ta(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        return b2[848 + (a4 * 28 | 0) + (c3 << 2) >> 2] | 0;
      }
      function ua(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        if ((b2[848 + (a4 * 28 | 0) >> 2] | 0) == (c3 | 0)) {
          c3 = 0;
          return c3 | 0;
        }
        if ((b2[848 + (a4 * 28 | 0) + 4 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        if ((b2[848 + (a4 * 28 | 0) + 8 >> 2] | 0) == (c3 | 0)) {
          c3 = 2;
          return c3 | 0;
        }
        if ((b2[848 + (a4 * 28 | 0) + 12 >> 2] | 0) == (c3 | 0)) {
          c3 = 3;
          return c3 | 0;
        }
        if ((b2[848 + (a4 * 28 | 0) + 16 >> 2] | 0) == (c3 | 0)) {
          c3 = 4;
          return c3 | 0;
        }
        if ((b2[848 + (a4 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 5;
          return c3 | 0;
        } else {
          return ((b2[848 + (a4 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0) ? 6 : 7) | 0;
        }
        return 0;
      }
      function va() {
        return 122;
      }
      function wa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        c3 = 0;
        do {
          wd(c3 | 0, 0, 45) | 0;
          e3 = H() | 0 | 134225919;
          d2 = a4 + (c3 << 3) | 0;
          b2[d2 >> 2] = -1;
          b2[d2 + 4 >> 2] = e3;
          c3 = c3 + 1 | 0;
        } while ((c3 | 0) != 122);
        return 0;
      }
      function xa(a4) {
        a4 = a4 | 0;
        return +e2[a4 + 16 >> 3] < +e2[a4 + 24 >> 3] | 0;
      }
      function ya(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0;
        c3 = +e2[b3 >> 3];
        if (!(c3 >= +e2[a4 + 8 >> 3])) {
          b3 = 0;
          return b3 | 0;
        }
        if (!(c3 <= +e2[a4 >> 3])) {
          b3 = 0;
          return b3 | 0;
        }
        d2 = +e2[a4 + 16 >> 3];
        c3 = +e2[a4 + 24 >> 3];
        f3 = +e2[b3 + 8 >> 3];
        b3 = f3 >= c3;
        a4 = f3 <= d2 & 1;
        if (d2 < c3) {
          if (b3) {
            a4 = 1;
          }
        } else if (!b3) {
          a4 = 0;
        }
        b3 = (a4 | 0) != 0;
        return b3 | 0;
      }
      function za(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0;
        t3 = T;
        T = T + 288 | 0;
        n2 = t3 + 264 | 0;
        o2 = t3 + 96 | 0;
        m = t3;
        k = m;
        l2 = k + 96 | 0;
        do {
          b2[k >> 2] = 0;
          k = k + 4 | 0;
        } while ((k | 0) < (l2 | 0));
        c3 = Ub(c3, m) | 0;
        if (c3 | 0) {
          s3 = c3;
          T = t3;
          return s3 | 0;
        }
        l2 = m;
        m = b2[l2 >> 2] | 0;
        l2 = b2[l2 + 4 >> 2] | 0;
        Pb(m, l2, n2) | 0;
        Qb(m, l2, o2) | 0;
        j = +ac(n2, o2 + 8 | 0);
        e2[n2 >> 3] = +e2[a4 >> 3];
        l2 = n2 + 8 | 0;
        e2[l2 >> 3] = +e2[a4 + 16 >> 3];
        e2[o2 >> 3] = +e2[a4 + 8 >> 3];
        m = o2 + 8 | 0;
        e2[m >> 3] = +e2[a4 + 24 >> 3];
        h = +ac(n2, o2);
        v2 = +e2[l2 >> 3] - +e2[m >> 3];
        i3 = +q(+v2);
        u2 = +e2[n2 >> 3] - +e2[o2 >> 3];
        g2 = +q(+u2);
        if (!(v2 == 0 | u2 == 0) ? (v2 = +xd(+i3, +g2), v2 = +A(+(h * h / +yd(+(v2 / +yd(+i3, +g2)), 3) / (j * (j * 2.59807621135) * 0.8))), e2[f2 >> 3] = v2, r3 = ~~v2 >>> 0, s3 = +q(v2) >= 1 ? v2 > 0 ? ~~+C(+p2(v2 / 4294967296), 4294967295) >>> 0 : ~~+A((v2 - +(~~v2 >>> 0)) / 4294967296) >>> 0 : 0, !((b2[f2 + 4 >> 2] & 2146435072 | 0) == 2146435072)) : 0) {
          o2 = (r3 | 0) == 0 & (s3 | 0) == 0;
          c3 = d2;
          b2[c3 >> 2] = o2 ? 1 : r3;
          b2[c3 + 4 >> 2] = o2 ? 0 : s3;
          c3 = 0;
        } else {
          c3 = 1;
        }
        s3 = c3;
        T = t3;
        return s3 | 0;
      }
      function Aa(a4, c3, d2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
        m = T;
        T = T + 288 | 0;
        j = m + 264 | 0;
        k = m + 96 | 0;
        l2 = m;
        h = l2;
        i3 = h + 96 | 0;
        do {
          b2[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (i3 | 0));
        d2 = Ub(d2, l2) | 0;
        if (d2 | 0) {
          g2 = d2;
          T = m;
          return g2 | 0;
        }
        d2 = l2;
        h = b2[d2 >> 2] | 0;
        d2 = b2[d2 + 4 >> 2] | 0;
        Pb(h, d2, j) | 0;
        Qb(h, d2, k) | 0;
        n2 = +ac(j, k + 8 | 0);
        n2 = +A(+(+ac(a4, c3) / (n2 * 2)));
        e2[f2 >> 3] = n2;
        d2 = ~~n2 >>> 0;
        h = +q(n2) >= 1 ? n2 > 0 ? ~~+C(+p2(n2 / 4294967296), 4294967295) >>> 0 : ~~+A((n2 - +(~~n2 >>> 0)) / 4294967296) >>> 0 : 0;
        if ((b2[f2 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          g2 = 1;
          T = m;
          return g2 | 0;
        }
        l2 = (d2 | 0) == 0 & (h | 0) == 0;
        b2[g2 >> 2] = l2 ? 1 : d2;
        b2[g2 + 4 >> 2] = l2 ? 0 : h;
        g2 = 0;
        T = m;
        return g2 | 0;
      }
      function Ba(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        b2[a4 >> 2] = c3;
        b2[a4 + 4 >> 2] = d2;
        b2[a4 + 8 >> 2] = e3;
        return;
      }
      function Ca(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
        n2 = c3 + 8 | 0;
        b2[n2 >> 2] = 0;
        k = +e2[a4 >> 3];
        i3 = +q(+k);
        l2 = +e2[a4 + 8 >> 3];
        j = +q(+l2) / 0.8660254037844386;
        i3 = i3 + j * 0.5;
        d2 = ~~i3;
        a4 = ~~j;
        i3 = i3 - +(d2 | 0);
        j = j - +(a4 | 0);
        do {
          if (i3 < 0.5) {
            if (i3 < 0.3333333333333333) {
              b2[c3 >> 2] = d2;
              if (j < (i3 + 1) * 0.5) {
                b2[c3 + 4 >> 2] = a4;
                break;
              } else {
                a4 = a4 + 1 | 0;
                b2[c3 + 4 >> 2] = a4;
                break;
              }
            } else {
              o2 = 1 - i3;
              a4 = (!(j < o2) & 1) + a4 | 0;
              b2[c3 + 4 >> 2] = a4;
              if (o2 <= j & j < i3 * 2) {
                d2 = d2 + 1 | 0;
                b2[c3 >> 2] = d2;
                break;
              } else {
                b2[c3 >> 2] = d2;
                break;
              }
            }
          } else {
            if (!(i3 < 0.6666666666666666)) {
              d2 = d2 + 1 | 0;
              b2[c3 >> 2] = d2;
              if (j < i3 * 0.5) {
                b2[c3 + 4 >> 2] = a4;
                break;
              } else {
                a4 = a4 + 1 | 0;
                b2[c3 + 4 >> 2] = a4;
                break;
              }
            }
            if (j < 1 - i3) {
              b2[c3 + 4 >> 2] = a4;
              if (i3 * 2 + -1 < j) {
                b2[c3 >> 2] = d2;
                break;
              }
            } else {
              a4 = a4 + 1 | 0;
              b2[c3 + 4 >> 2] = a4;
            }
            d2 = d2 + 1 | 0;
            b2[c3 >> 2] = d2;
          }
        } while (0);
        do {
          if (k < 0) {
            if (!(a4 & 1)) {
              m = (a4 | 0) / 2 | 0;
              m = md(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - (+(m >>> 0) + 4294967296 * +(H() | 0)) * 2);
              b2[c3 >> 2] = d2;
              break;
            } else {
              m = (a4 + 1 | 0) / 2 | 0;
              m = md(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - ((+(m >>> 0) + 4294967296 * +(H() | 0)) * 2 + 1));
              b2[c3 >> 2] = d2;
              break;
            }
          }
        } while (0);
        m = c3 + 4 | 0;
        if (l2 < 0) {
          d2 = d2 - ((a4 << 1 | 1 | 0) / 2 | 0) | 0;
          b2[c3 >> 2] = d2;
          a4 = 0 - a4 | 0;
          b2[m >> 2] = a4;
        }
        f3 = a4 - d2 | 0;
        if ((d2 | 0) < 0) {
          g2 = 0 - d2 | 0;
          b2[m >> 2] = f3;
          b2[n2 >> 2] = g2;
          b2[c3 >> 2] = 0;
          a4 = f3;
          d2 = 0;
        } else {
          g2 = 0;
        }
        if ((a4 | 0) < 0) {
          d2 = d2 - a4 | 0;
          b2[c3 >> 2] = d2;
          g2 = g2 - a4 | 0;
          b2[n2 >> 2] = g2;
          b2[m >> 2] = 0;
          a4 = 0;
        }
        h = d2 - g2 | 0;
        f3 = a4 - g2 | 0;
        if ((g2 | 0) < 0) {
          b2[c3 >> 2] = h;
          b2[m >> 2] = f3;
          b2[n2 >> 2] = 0;
          a4 = f3;
          d2 = h;
          g2 = 0;
        }
        f3 = (a4 | 0) < (d2 | 0) ? a4 : d2;
        f3 = (g2 | 0) < (f3 | 0) ? g2 : f3;
        if ((f3 | 0) <= 0) {
          return;
        }
        b2[c3 >> 2] = d2 - f3;
        b2[m >> 2] = a4 - f3;
        b2[n2 >> 2] = g2 - f3;
        return;
      }
      function Da(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0;
        c3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d2 = b2[h >> 2] | 0;
        if ((c3 | 0) < 0) {
          d2 = d2 - c3 | 0;
          b2[h >> 2] = d2;
          g2 = a4 + 8 | 0;
          b2[g2 >> 2] = (b2[g2 >> 2] | 0) - c3;
          b2[a4 >> 2] = 0;
          c3 = 0;
        }
        if ((d2 | 0) < 0) {
          c3 = c3 - d2 | 0;
          b2[a4 >> 2] = c3;
          g2 = a4 + 8 | 0;
          f3 = (b2[g2 >> 2] | 0) - d2 | 0;
          b2[g2 >> 2] = f3;
          b2[h >> 2] = 0;
          d2 = 0;
        } else {
          f3 = a4 + 8 | 0;
          g2 = f3;
          f3 = b2[f3 >> 2] | 0;
        }
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[a4 >> 2] = c3;
          d2 = d2 - f3 | 0;
          b2[h >> 2] = d2;
          b2[g2 >> 2] = 0;
          f3 = 0;
        }
        e3 = (d2 | 0) < (c3 | 0) ? d2 : c3;
        e3 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = c3 - e3;
        b2[h >> 2] = d2 - e3;
        b2[g2 >> 2] = f3 - e3;
        return;
      }
      function Ea(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0;
        f3 = b2[a4 + 8 >> 2] | 0;
        d2 = +((b2[a4 + 4 >> 2] | 0) - f3 | 0);
        e2[c3 >> 3] = +((b2[a4 >> 2] | 0) - f3 | 0) - d2 * 0.5;
        e2[c3 + 8 >> 3] = d2 * 0.8660254037844386;
        return;
      }
      function Fa(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        b2[d2 >> 2] = (b2[c3 >> 2] | 0) + (b2[a4 >> 2] | 0);
        b2[d2 + 4 >> 2] = (b2[c3 + 4 >> 2] | 0) + (b2[a4 + 4 >> 2] | 0);
        b2[d2 + 8 >> 2] = (b2[c3 + 8 >> 2] | 0) + (b2[a4 + 8 >> 2] | 0);
        return;
      }
      function Ga(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        b2[d2 >> 2] = (b2[a4 >> 2] | 0) - (b2[c3 >> 2] | 0);
        b2[d2 + 4 >> 2] = (b2[a4 + 4 >> 2] | 0) - (b2[c3 + 4 >> 2] | 0);
        b2[d2 + 8 >> 2] = (b2[a4 + 8 >> 2] | 0) - (b2[c3 + 8 >> 2] | 0);
        return;
      }
      function Ha(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0;
        d2 = B(b2[a4 >> 2] | 0, c3) | 0;
        b2[a4 >> 2] = d2;
        d2 = a4 + 4 | 0;
        e3 = B(b2[d2 >> 2] | 0, c3) | 0;
        b2[d2 >> 2] = e3;
        a4 = a4 + 8 | 0;
        c3 = B(b2[a4 >> 2] | 0, c3) | 0;
        b2[a4 >> 2] = c3;
        return;
      }
      function Ia(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = b2[a4 >> 2] | 0;
        i3 = (h | 0) < 0;
        e3 = (b2[a4 + 4 >> 2] | 0) - (i3 ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f3 = (g2 ? 0 - e3 | 0 : 0) + ((b2[a4 + 8 >> 2] | 0) - (i3 ? h : 0)) | 0;
        d2 = (f3 | 0) < 0;
        a4 = d2 ? 0 : f3;
        c3 = (g2 ? 0 : e3) - (d2 ? f3 : 0) | 0;
        f3 = (i3 ? 0 : h) - (g2 ? e3 : 0) - (d2 ? f3 : 0) | 0;
        d2 = (c3 | 0) < (f3 | 0) ? c3 : f3;
        d2 = (a4 | 0) < (d2 | 0) ? a4 : d2;
        e3 = (d2 | 0) > 0;
        a4 = a4 - (e3 ? d2 : 0) | 0;
        c3 = c3 - (e3 ? d2 : 0) | 0;
        a:
          do {
            switch (f3 - (e3 ? d2 : 0) | 0) {
              case 0:
                switch (c3 | 0) {
                  case 0: {
                    i3 = (a4 | 0) == 0 ? 0 : (a4 | 0) == 1 ? 1 : 7;
                    return i3 | 0;
                  }
                  case 1: {
                    i3 = (a4 | 0) == 0 ? 2 : (a4 | 0) == 1 ? 3 : 7;
                    return i3 | 0;
                  }
                  default:
                    break a;
                }
              case 1:
                switch (c3 | 0) {
                  case 0: {
                    i3 = (a4 | 0) == 0 ? 4 : (a4 | 0) == 1 ? 5 : 7;
                    return i3 | 0;
                  }
                  case 1: {
                    if (!a4) {
                      a4 = 6;
                    } else {
                      break a;
                    }
                    return a4 | 0;
                  }
                  default:
                    break a;
                }
              default:
            }
          } while (0);
        i3 = 7;
        return i3 | 0;
      }
      function Ja(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = a4 + 8 | 0;
        f3 = b2[h >> 2] | 0;
        g2 = (b2[a4 >> 2] | 0) - f3 | 0;
        i3 = a4 + 4 | 0;
        f3 = (b2[i3 >> 2] | 0) - f3 | 0;
        do {
          if (g2 >>> 0 > 715827881 | f3 >>> 0 > 715827881) {
            d2 = (g2 | 0) > 0;
            if (d2) {
              if ((2147483647 - g2 | 0) < (g2 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
              if ((2147483647 - (g2 << 1) | 0) < (g2 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else {
              if ((-2147483648 - g2 | 0) > (g2 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
              if ((-2147483648 - (g2 << 1) | 0) > (g2 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            }
            c3 = g2 * 3 | 0;
            if ((f3 | 0) > 0) {
              if ((2147483647 - f3 | 0) < (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else if ((-2147483648 - f3 | 0) > (f3 | 0)) {
              i3 = 1;
              return i3 | 0;
            }
            e3 = f3 << 1;
            if ((g2 | 0) > -1) {
              if ((c3 | -2147483648 | 0) >= (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else if ((c3 ^ -2147483648 | 0) < (f3 | 0)) {
              i3 = 1;
              return i3 | 0;
            }
            if (d2) {
              if ((2147483647 - g2 | 0) < (e3 | 0)) {
                c3 = 1;
              } else {
                d2 = e3;
                break;
              }
              return c3 | 0;
            } else {
              if ((-2147483648 - g2 | 0) > (e3 | 0)) {
                c3 = 1;
              } else {
                d2 = e3;
                break;
              }
              return c3 | 0;
            }
          } else {
            d2 = f3 << 1;
            c3 = g2 * 3 | 0;
          }
        } while (0);
        e3 = hd(+(c3 - f3 | 0) / 7) | 0;
        b2[a4 >> 2] = e3;
        f3 = hd(+(d2 + g2 | 0) / 7) | 0;
        b2[i3 >> 2] = f3;
        b2[h >> 2] = 0;
        d2 = (f3 | 0) < (e3 | 0);
        c3 = d2 ? e3 : f3;
        d2 = d2 ? f3 : e3;
        do {
          if ((d2 | 0) < 0) {
            if ((c3 | 0) > 0) {
              if ((c3 | -2147483648 | 0) < (d2 | 0) & ((d2 | 0) != -2147483648 & (2147483647 - c3 | 0) >= (d2 | 0))) {
                break;
              }
              I(23313, 22444, 355, 22455);
            }
            if ((d2 | 0) == -2147483648 | (-2147483648 - c3 | 0) > (d2 | 0)) {
              I(23313, 22444, 355, 22455);
            }
            if ((c3 | 0) > -1) {
              if ((c3 | -2147483648 | 0) < (d2 | 0)) {
                break;
              }
              I(23313, 22444, 355, 22455);
            } else {
              if ((c3 ^ -2147483648 | 0) >= (d2 | 0)) {
                break;
              }
              I(23313, 22444, 355, 22455);
            }
          }
        } while (0);
        c3 = f3 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = d2;
          b2[a4 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f3;
          d2 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a4 >> 2] = e3;
          d2 = d2 - c3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d2 | 0;
        f3 = c3 - d2 | 0;
        if ((d2 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[i3 >> 2] = f3;
          b2[h >> 2] = 0;
          c3 = f3;
          f3 = g2;
          d2 = 0;
        } else {
          f3 = e3;
        }
        e3 = (c3 | 0) < (f3 | 0) ? c3 : f3;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          i3 = 0;
          return i3 | 0;
        }
        b2[a4 >> 2] = f3 - e3;
        b2[i3 >> 2] = c3 - e3;
        b2[h >> 2] = d2 - e3;
        i3 = 0;
        return i3 | 0;
      }
      function Ka(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = a4 + 8 | 0;
        f3 = b2[h >> 2] | 0;
        g2 = (b2[a4 >> 2] | 0) - f3 | 0;
        i3 = a4 + 4 | 0;
        f3 = (b2[i3 >> 2] | 0) - f3 | 0;
        do {
          if (g2 >>> 0 > 715827881 | f3 >>> 0 > 715827881) {
            d2 = (g2 | 0) > 0;
            if (d2) {
              if ((2147483647 - g2 | 0) < (g2 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else if ((-2147483648 - g2 | 0) > (g2 | 0)) {
              i3 = 1;
              return i3 | 0;
            }
            c3 = g2 << 1;
            if ((f3 | 0) > 0) {
              if ((2147483647 - f3 | 0) < (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
              if ((2147483647 - (f3 << 1) | 0) < (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else {
              if ((-2147483648 - f3 | 0) > (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
              if ((-2147483648 - (f3 << 1) | 0) > (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            }
            e3 = f3 * 3 | 0;
            if (d2) {
              if ((2147483647 - c3 | 0) < (f3 | 0)) {
                i3 = 1;
                return i3 | 0;
              }
            } else if ((-2147483648 - c3 | 0) > (f3 | 0)) {
              i3 = 1;
              return i3 | 0;
            }
            if ((f3 | 0) > -1) {
              if ((e3 | -2147483648 | 0) < (g2 | 0)) {
                d2 = e3;
                break;
              } else {
                c3 = 1;
              }
              return c3 | 0;
            } else {
              if ((e3 ^ -2147483648 | 0) < (g2 | 0)) {
                c3 = 1;
              } else {
                d2 = e3;
                break;
              }
              return c3 | 0;
            }
          } else {
            d2 = f3 * 3 | 0;
            c3 = g2 << 1;
          }
        } while (0);
        e3 = hd(+(c3 + f3 | 0) / 7) | 0;
        b2[a4 >> 2] = e3;
        f3 = hd(+(d2 - g2 | 0) / 7) | 0;
        b2[i3 >> 2] = f3;
        b2[h >> 2] = 0;
        d2 = (f3 | 0) < (e3 | 0);
        c3 = d2 ? e3 : f3;
        d2 = d2 ? f3 : e3;
        do {
          if ((d2 | 0) < 0) {
            if ((c3 | 0) > 0) {
              if ((c3 | -2147483648 | 0) < (d2 | 0) & ((d2 | 0) != -2147483648 & (2147483647 - c3 | 0) >= (d2 | 0))) {
                break;
              }
              I(23313, 22444, 404, 22469);
            }
            if ((d2 | 0) == -2147483648 | (-2147483648 - c3 | 0) > (d2 | 0)) {
              I(23313, 22444, 404, 22469);
            }
            if ((c3 | 0) > -1) {
              if ((c3 | -2147483648 | 0) < (d2 | 0)) {
                break;
              }
              I(23313, 22444, 404, 22469);
            } else {
              if ((c3 ^ -2147483648 | 0) >= (d2 | 0)) {
                break;
              }
              I(23313, 22444, 404, 22469);
            }
          }
        } while (0);
        c3 = f3 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = d2;
          b2[a4 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f3;
          d2 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a4 >> 2] = e3;
          d2 = d2 - c3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d2 | 0;
        f3 = c3 - d2 | 0;
        if ((d2 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[i3 >> 2] = f3;
          b2[h >> 2] = 0;
          c3 = f3;
          f3 = g2;
          d2 = 0;
        } else {
          f3 = e3;
        }
        e3 = (c3 | 0) < (f3 | 0) ? c3 : f3;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          i3 = 0;
          return i3 | 0;
        }
        b2[a4 >> 2] = f3 - e3;
        b2[i3 >> 2] = c3 - e3;
        b2[h >> 2] = d2 - e3;
        i3 = 0;
        return i3 | 0;
      }
      function La(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = a4 + 8 | 0;
        d2 = b2[h >> 2] | 0;
        c3 = (b2[a4 >> 2] | 0) - d2 | 0;
        i3 = a4 + 4 | 0;
        d2 = (b2[i3 >> 2] | 0) - d2 | 0;
        e3 = hd(+((c3 * 3 | 0) - d2 | 0) / 7) | 0;
        b2[a4 >> 2] = e3;
        c3 = hd(+((d2 << 1) + c3 | 0) / 7) | 0;
        b2[i3 >> 2] = c3;
        b2[h >> 2] = 0;
        d2 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b2[i3 >> 2] = d2;
          b2[h >> 2] = g2;
          b2[a4 >> 2] = 0;
          c3 = d2;
          e3 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a4 >> 2] = e3;
          d2 = d2 - c3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d2 | 0;
        f3 = c3 - d2 | 0;
        if ((d2 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[i3 >> 2] = f3;
          b2[h >> 2] = 0;
          c3 = f3;
          f3 = g2;
          d2 = 0;
        } else {
          f3 = e3;
        }
        e3 = (c3 | 0) < (f3 | 0) ? c3 : f3;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = f3 - e3;
        b2[i3 >> 2] = c3 - e3;
        b2[h >> 2] = d2 - e3;
        return;
      }
      function Ma(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = a4 + 8 | 0;
        d2 = b2[h >> 2] | 0;
        c3 = (b2[a4 >> 2] | 0) - d2 | 0;
        i3 = a4 + 4 | 0;
        d2 = (b2[i3 >> 2] | 0) - d2 | 0;
        e3 = hd(+((c3 << 1) + d2 | 0) / 7) | 0;
        b2[a4 >> 2] = e3;
        c3 = hd(+((d2 * 3 | 0) - c3 | 0) / 7) | 0;
        b2[i3 >> 2] = c3;
        b2[h >> 2] = 0;
        d2 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b2[i3 >> 2] = d2;
          b2[h >> 2] = g2;
          b2[a4 >> 2] = 0;
          c3 = d2;
          e3 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b2[a4 >> 2] = e3;
          d2 = d2 - c3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d2 | 0;
        f3 = c3 - d2 | 0;
        if ((d2 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[i3 >> 2] = f3;
          b2[h >> 2] = 0;
          c3 = f3;
          f3 = g2;
          d2 = 0;
        } else {
          f3 = e3;
        }
        e3 = (c3 | 0) < (f3 | 0) ? c3 : f3;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = f3 - e3;
        b2[i3 >> 2] = c3 - e3;
        b2[h >> 2] = d2 - e3;
        return;
      }
      function Na(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        c3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d2 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        e3 = b2[i3 >> 2] | 0;
        f3 = d2 + (c3 * 3 | 0) | 0;
        b2[a4 >> 2] = f3;
        d2 = e3 + (d2 * 3 | 0) | 0;
        b2[h >> 2] = d2;
        c3 = (e3 * 3 | 0) + c3 | 0;
        b2[i3 >> 2] = c3;
        e3 = d2 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = e3;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          d2 = e3;
          e3 = 0;
        } else {
          e3 = f3;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b2[a4 >> 2] = e3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c3 | 0;
        f3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = f3;
          b2[i3 >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f3 = d2;
        }
        d2 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = e3 - d2;
        b2[h >> 2] = f3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Oa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        f3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        d2 = b2[i3 >> 2] | 0;
        e3 = (c3 * 3 | 0) + f3 | 0;
        f3 = d2 + (f3 * 3 | 0) | 0;
        b2[a4 >> 2] = f3;
        b2[h >> 2] = e3;
        c3 = (d2 * 3 | 0) + c3 | 0;
        b2[i3 >> 2] = c3;
        d2 = e3 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          f3 = 0;
        } else {
          d2 = e3;
        }
        if ((d2 | 0) < 0) {
          f3 = f3 - d2 | 0;
          b2[a4 >> 2] = f3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f3 - c3 | 0;
        e3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = e3;
          b2[i3 >> 2] = 0;
          f3 = g2;
          c3 = 0;
        } else {
          e3 = d2;
        }
        d2 = (e3 | 0) < (f3 | 0) ? e3 : f3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = f3 - d2;
        b2[h >> 2] = e3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Pa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        if ((c3 + -1 | 0) >>> 0 >= 6) {
          return;
        }
        f3 = (b2[15440 + (c3 * 12 | 0) >> 2] | 0) + (b2[a4 >> 2] | 0) | 0;
        b2[a4 >> 2] = f3;
        i3 = a4 + 4 | 0;
        e3 = (b2[15440 + (c3 * 12 | 0) + 4 >> 2] | 0) + (b2[i3 >> 2] | 0) | 0;
        b2[i3 >> 2] = e3;
        h = a4 + 8 | 0;
        c3 = (b2[15440 + (c3 * 12 | 0) + 8 >> 2] | 0) + (b2[h >> 2] | 0) | 0;
        b2[h >> 2] = c3;
        d2 = e3 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[i3 >> 2] = d2;
          b2[h >> 2] = c3;
          b2[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f3;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b2[a4 >> 2] = e3;
          c3 = c3 - d2 | 0;
          b2[h >> 2] = c3;
          b2[i3 >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c3 | 0;
        f3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[i3 >> 2] = f3;
          b2[h >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f3 = d2;
        }
        d2 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = e3 - d2;
        b2[i3 >> 2] = f3 - d2;
        b2[h >> 2] = c3 - d2;
        return;
      }
      function Qa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        f3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        d2 = b2[i3 >> 2] | 0;
        e3 = c3 + f3 | 0;
        f3 = d2 + f3 | 0;
        b2[a4 >> 2] = f3;
        b2[h >> 2] = e3;
        c3 = d2 + c3 | 0;
        b2[i3 >> 2] = c3;
        d2 = e3 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f3;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b2[a4 >> 2] = e3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c3 | 0;
        f3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = f3;
          b2[i3 >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f3 = d2;
        }
        d2 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = e3 - d2;
        b2[h >> 2] = f3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Ra(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        c3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        e3 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        d2 = b2[i3 >> 2] | 0;
        f3 = e3 + c3 | 0;
        b2[a4 >> 2] = f3;
        e3 = d2 + e3 | 0;
        b2[h >> 2] = e3;
        c3 = d2 + c3 | 0;
        b2[i3 >> 2] = c3;
        d2 = e3 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f3;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b2[a4 >> 2] = e3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c3 | 0;
        f3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = f3;
          b2[i3 >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f3 = d2;
        }
        d2 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = e3 - d2;
        b2[h >> 2] = f3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Sa(a4) {
        a4 = a4 | 0;
        switch (a4 | 0) {
          case 1: {
            a4 = 5;
            break;
          }
          case 5: {
            a4 = 4;
            break;
          }
          case 4: {
            a4 = 6;
            break;
          }
          case 6: {
            a4 = 2;
            break;
          }
          case 2: {
            a4 = 3;
            break;
          }
          case 3: {
            a4 = 1;
            break;
          }
          default:
        }
        return a4 | 0;
      }
      function Ta(a4) {
        a4 = a4 | 0;
        switch (a4 | 0) {
          case 1: {
            a4 = 3;
            break;
          }
          case 3: {
            a4 = 2;
            break;
          }
          case 2: {
            a4 = 6;
            break;
          }
          case 6: {
            a4 = 4;
            break;
          }
          case 4: {
            a4 = 5;
            break;
          }
          case 5: {
            a4 = 1;
            break;
          }
          default:
        }
        return a4 | 0;
      }
      function Ua(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        c3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d2 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        e3 = b2[i3 >> 2] | 0;
        f3 = d2 + (c3 << 1) | 0;
        b2[a4 >> 2] = f3;
        d2 = e3 + (d2 << 1) | 0;
        b2[h >> 2] = d2;
        c3 = (e3 << 1) + c3 | 0;
        b2[i3 >> 2] = c3;
        e3 = d2 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = e3;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          d2 = e3;
          e3 = 0;
        } else {
          e3 = f3;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b2[a4 >> 2] = e3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c3 | 0;
        f3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = f3;
          b2[i3 >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f3 = d2;
        }
        d2 = (f3 | 0) < (e3 | 0) ? f3 : e3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = e3 - d2;
        b2[h >> 2] = f3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Va(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        f3 = b2[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b2[h >> 2] | 0;
        i3 = a4 + 8 | 0;
        d2 = b2[i3 >> 2] | 0;
        e3 = (c3 << 1) + f3 | 0;
        f3 = d2 + (f3 << 1) | 0;
        b2[a4 >> 2] = f3;
        b2[h >> 2] = e3;
        c3 = (d2 << 1) + c3 | 0;
        b2[i3 >> 2] = c3;
        d2 = e3 - f3 | 0;
        if ((f3 | 0) < 0) {
          c3 = c3 - f3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = c3;
          b2[a4 >> 2] = 0;
          f3 = 0;
        } else {
          d2 = e3;
        }
        if ((d2 | 0) < 0) {
          f3 = f3 - d2 | 0;
          b2[a4 >> 2] = f3;
          c3 = c3 - d2 | 0;
          b2[i3 >> 2] = c3;
          b2[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f3 - c3 | 0;
        e3 = d2 - c3 | 0;
        if ((c3 | 0) < 0) {
          b2[a4 >> 2] = g2;
          b2[h >> 2] = e3;
          b2[i3 >> 2] = 0;
          f3 = g2;
          c3 = 0;
        } else {
          e3 = d2;
        }
        d2 = (e3 | 0) < (f3 | 0) ? e3 : f3;
        d2 = (c3 | 0) < (d2 | 0) ? c3 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = f3 - d2;
        b2[h >> 2] = e3 - d2;
        b2[i3 >> 2] = c3 - d2;
        return;
      }
      function Wa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = (b2[a4 >> 2] | 0) - (b2[c3 >> 2] | 0) | 0;
        i3 = (h | 0) < 0;
        e3 = (b2[a4 + 4 >> 2] | 0) - (b2[c3 + 4 >> 2] | 0) - (i3 ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f3 = (i3 ? 0 - h | 0 : 0) + (b2[a4 + 8 >> 2] | 0) - (b2[c3 + 8 >> 2] | 0) + (g2 ? 0 - e3 | 0 : 0) | 0;
        a4 = (f3 | 0) < 0;
        c3 = a4 ? 0 : f3;
        d2 = (g2 ? 0 : e3) - (a4 ? f3 : 0) | 0;
        f3 = (i3 ? 0 : h) - (g2 ? e3 : 0) - (a4 ? f3 : 0) | 0;
        a4 = (d2 | 0) < (f3 | 0) ? d2 : f3;
        a4 = (c3 | 0) < (a4 | 0) ? c3 : a4;
        e3 = (a4 | 0) > 0;
        c3 = c3 - (e3 ? a4 : 0) | 0;
        d2 = d2 - (e3 ? a4 : 0) | 0;
        a4 = f3 - (e3 ? a4 : 0) | 0;
        a4 = (a4 | 0) > -1 ? a4 : 0 - a4 | 0;
        d2 = (d2 | 0) > -1 ? d2 : 0 - d2 | 0;
        c3 = (c3 | 0) > -1 ? c3 : 0 - c3 | 0;
        c3 = (d2 | 0) > (c3 | 0) ? d2 : c3;
        return ((a4 | 0) > (c3 | 0) ? a4 : c3) | 0;
      }
      function Xa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        d2 = b2[a4 + 8 >> 2] | 0;
        b2[c3 >> 2] = (b2[a4 >> 2] | 0) - d2;
        b2[c3 + 4 >> 2] = (b2[a4 + 4 >> 2] | 0) - d2;
        return;
      }
      function Ya(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        e3 = b2[a4 >> 2] | 0;
        b2[c3 >> 2] = e3;
        f3 = b2[a4 + 4 >> 2] | 0;
        h = c3 + 4 | 0;
        b2[h >> 2] = f3;
        i3 = c3 + 8 | 0;
        b2[i3 >> 2] = 0;
        d2 = (f3 | 0) < (e3 | 0);
        a4 = d2 ? e3 : f3;
        d2 = d2 ? f3 : e3;
        do {
          if ((d2 | 0) < 0) {
            if ((a4 | 0) > 0) {
              if ((a4 | -2147483648 | 0) < (d2 | 0) & ((d2 | 0) != -2147483648 & (2147483647 - a4 | 0) >= (d2 | 0))) {
                break;
              } else {
                a4 = 1;
              }
              return a4 | 0;
            }
            if ((d2 | 0) == -2147483648 | (-2147483648 - a4 | 0) > (d2 | 0)) {
              c3 = 1;
              return c3 | 0;
            }
            if ((a4 | 0) > -1) {
              if ((a4 | -2147483648 | 0) < (d2 | 0)) {
                break;
              } else {
                a4 = 1;
              }
              return a4 | 0;
            } else {
              if ((a4 ^ -2147483648 | 0) < (d2 | 0)) {
                a4 = 1;
              } else {
                break;
              }
              return a4 | 0;
            }
          }
        } while (0);
        a4 = f3 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b2[h >> 2] = a4;
          b2[i3 >> 2] = d2;
          b2[c3 >> 2] = 0;
          e3 = 0;
        } else {
          a4 = f3;
          d2 = 0;
        }
        if ((a4 | 0) < 0) {
          e3 = e3 - a4 | 0;
          b2[c3 >> 2] = e3;
          d2 = d2 - a4 | 0;
          b2[i3 >> 2] = d2;
          b2[h >> 2] = 0;
          a4 = 0;
        }
        g2 = e3 - d2 | 0;
        f3 = a4 - d2 | 0;
        if ((d2 | 0) < 0) {
          b2[c3 >> 2] = g2;
          b2[h >> 2] = f3;
          b2[i3 >> 2] = 0;
          a4 = f3;
          f3 = g2;
          d2 = 0;
        } else {
          f3 = e3;
        }
        e3 = (a4 | 0) < (f3 | 0) ? a4 : f3;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          c3 = 0;
          return c3 | 0;
        }
        b2[c3 >> 2] = f3 - e3;
        b2[h >> 2] = a4 - e3;
        b2[i3 >> 2] = d2 - e3;
        c3 = 0;
        return c3 | 0;
      }
      function Za(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0;
        c3 = a4 + 8 | 0;
        f3 = b2[c3 >> 2] | 0;
        d2 = f3 - (b2[a4 >> 2] | 0) | 0;
        b2[a4 >> 2] = d2;
        e3 = a4 + 4 | 0;
        a4 = (b2[e3 >> 2] | 0) - f3 | 0;
        b2[e3 >> 2] = a4;
        b2[c3 >> 2] = 0 - (a4 + d2);
        return;
      }
      function _a(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        d2 = b2[a4 >> 2] | 0;
        c3 = 0 - d2 | 0;
        b2[a4 >> 2] = c3;
        h = a4 + 8 | 0;
        b2[h >> 2] = 0;
        i3 = a4 + 4 | 0;
        e3 = b2[i3 >> 2] | 0;
        f3 = e3 + d2 | 0;
        if ((d2 | 0) > 0) {
          b2[i3 >> 2] = f3;
          b2[h >> 2] = d2;
          b2[a4 >> 2] = 0;
          c3 = 0;
          e3 = f3;
        } else {
          d2 = 0;
        }
        if ((e3 | 0) < 0) {
          g2 = c3 - e3 | 0;
          b2[a4 >> 2] = g2;
          d2 = d2 - e3 | 0;
          b2[h >> 2] = d2;
          b2[i3 >> 2] = 0;
          f3 = g2 - d2 | 0;
          c3 = 0 - d2 | 0;
          if ((d2 | 0) < 0) {
            b2[a4 >> 2] = f3;
            b2[i3 >> 2] = c3;
            b2[h >> 2] = 0;
            e3 = c3;
            d2 = 0;
          } else {
            e3 = 0;
            f3 = g2;
          }
        } else {
          f3 = c3;
        }
        c3 = (e3 | 0) < (f3 | 0) ? e3 : f3;
        c3 = (d2 | 0) < (c3 | 0) ? d2 : c3;
        if ((c3 | 0) <= 0) {
          return;
        }
        b2[a4 >> 2] = f3 - c3;
        b2[i3 >> 2] = e3 - c3;
        b2[h >> 2] = d2 - c3;
        return;
      }
      function $a(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        m = T;
        T = T + 64 | 0;
        l2 = m;
        i3 = m + 56 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 134217728 & (true & (e3 & 2013265920 | 0) == 134217728))) {
          f3 = 5;
          T = m;
          return f3 | 0;
        }
        if ((a4 | 0) == (d2 | 0) & (c3 | 0) == (e3 | 0)) {
          b2[f3 >> 2] = 0;
          f3 = 0;
          T = m;
          return f3 | 0;
        }
        h = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        k = vd(d2 | 0, e3 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (k & 15 | 0)) {
          f3 = 12;
          T = m;
          return f3 | 0;
        }
        g2 = h + -1 | 0;
        if (h >>> 0 > 1) {
          vb(a4, c3, g2, l2) | 0;
          vb(d2, e3, g2, i3) | 0;
          k = l2;
          j = b2[k >> 2] | 0;
          k = b2[k + 4 >> 2] | 0;
          a:
            do {
              if ((j | 0) == (b2[i3 >> 2] | 0) ? (k | 0) == (b2[i3 + 4 >> 2] | 0) : 0) {
                h = (h ^ 15) * 3 | 0;
                g2 = vd(a4 | 0, c3 | 0, h | 0) | 0;
                H() | 0;
                g2 = g2 & 7;
                h = vd(d2 | 0, e3 | 0, h | 0) | 0;
                H() | 0;
                h = h & 7;
                do {
                  if (!((g2 | 0) == 0 | (h | 0) == 0)) {
                    if ((g2 | 0) == 7) {
                      g2 = 5;
                    } else {
                      if ((g2 | 0) == 1 | (h | 0) == 1 ? xb(j, k) | 0 : 0) {
                        g2 = 5;
                        break;
                      }
                      if ((b2[15536 + (g2 << 2) >> 2] | 0) != (h | 0) ? (b2[15568 + (g2 << 2) >> 2] | 0) != (h | 0) : 0) {
                        break a;
                      }
                      b2[f3 >> 2] = 1;
                      g2 = 0;
                    }
                  } else {
                    b2[f3 >> 2] = 1;
                    g2 = 0;
                  }
                } while (0);
                f3 = g2;
                T = m;
                return f3 | 0;
              }
            } while (0);
        }
        g2 = l2;
        h = g2 + 56 | 0;
        do {
          b2[g2 >> 2] = 0;
          g2 = g2 + 4 | 0;
        } while ((g2 | 0) < (h | 0));
        aa(a4, c3, 1, l2) | 0;
        c3 = l2;
        if (((((!((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0) ? (c3 = l2 + 8 | 0, !((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l2 + 16 | 0, !((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l2 + 24 | 0, !((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l2 + 32 | 0, !((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l2 + 40 | 0, !((b2[c3 >> 2] | 0) == (d2 | 0) ? (b2[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) {
          g2 = l2 + 48 | 0;
          g2 = ((b2[g2 >> 2] | 0) == (d2 | 0) ? (b2[g2 + 4 >> 2] | 0) == (e3 | 0) : 0) & 1;
        } else {
          g2 = 1;
        }
        b2[f3 >> 2] = g2;
        f3 = 0;
        T = m;
        return f3 | 0;
      }
      function ab(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        d2 = fa(a4, c3, d2, e3) | 0;
        if ((d2 | 0) == 7) {
          f3 = 11;
          return f3 | 0;
        }
        e3 = wd(d2 | 0, 0, 56) | 0;
        c3 = c3 & -2130706433 | (H() | 0) | 268435456;
        b2[f3 >> 2] = a4 | e3;
        b2[f3 + 4 >> 2] = c3;
        f3 = 0;
        return f3 | 0;
      }
      function bb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          d2 = 6;
          return d2 | 0;
        }
        b2[d2 >> 2] = a4;
        b2[d2 + 4 >> 2] = c3 & -2130706433 | 134217728;
        d2 = 0;
        return d2 | 0;
      }
      function cb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        f3 = T;
        T = T + 16 | 0;
        e3 = f3;
        b2[e3 >> 2] = 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f3;
          return e3 | 0;
        }
        g2 = vd(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a4, c3 & -2130706433 | 134217728, g2 & 7, e3, d2) | 0;
        T = f3;
        return e3 | 0;
      }
      function db(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0;
        c3 = vd(a4 | 0, b3 | 0, 56) | 0;
        H() | 0;
        switch (c3 & 7) {
          case 0:
          case 7: {
            c3 = 0;
            return c3 | 0;
          }
          default:
        }
        c3 = b3 & -2130706433 | 134217728;
        if (!(true & (b3 & 2013265920 | 0) == 268435456)) {
          c3 = 0;
          return c3 | 0;
        }
        if (true & (b3 & 117440512 | 0) == 16777216 & (xb(a4, c3) | 0) != 0) {
          c3 = 0;
          return c3 | 0;
        }
        c3 = ub(a4, c3) | 0;
        return c3 | 0;
      }
      function eb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0;
        f3 = T;
        T = T + 16 | 0;
        e3 = f3;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f3;
          return e3 | 0;
        }
        g2 = c3 & -2130706433 | 134217728;
        h = d2;
        b2[h >> 2] = a4;
        b2[h + 4 >> 2] = g2;
        b2[e3 >> 2] = 0;
        c3 = vd(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a4, g2, c3 & 7, e3, d2 + 8 | 0) | 0;
        T = f3;
        return e3 | 0;
      }
      function fb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0;
        f3 = (xb(a4, c3) | 0) == 0;
        c3 = c3 & -2130706433;
        e3 = d2;
        b2[e3 >> 2] = f3 ? a4 : 0;
        b2[e3 + 4 >> 2] = f3 ? c3 | 285212672 : 0;
        e3 = d2 + 8 | 0;
        b2[e3 >> 2] = a4;
        b2[e3 + 4 >> 2] = c3 | 301989888;
        e3 = d2 + 16 | 0;
        b2[e3 >> 2] = a4;
        b2[e3 + 4 >> 2] = c3 | 318767104;
        e3 = d2 + 24 | 0;
        b2[e3 >> 2] = a4;
        b2[e3 + 4 >> 2] = c3 | 335544320;
        e3 = d2 + 32 | 0;
        b2[e3 >> 2] = a4;
        b2[e3 + 4 >> 2] = c3 | 352321536;
        d2 = d2 + 40 | 0;
        b2[d2 >> 2] = a4;
        b2[d2 + 4 >> 2] = c3 | 369098752;
        return 0;
      }
      function gb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        f3 = h;
        g2 = c3 & -2130706433 | 134217728;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        e3 = vd(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = Uc(a4, g2, e3 & 7) | 0;
        if ((e3 | 0) == -1) {
          b2[d2 >> 2] = 0;
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        if (Ob(a4, g2, f3) | 0) {
          I(23313, 22484, 282, 22499);
        }
        c3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(xb(a4, g2) | 0)) {
          qb(f3, c3, e3, 2, d2);
        } else {
          mb(f3, c3, e3, 2, d2);
        }
        g2 = 0;
        T = h;
        return g2 | 0;
      }
      function hb(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0;
        d2 = T;
        T = T + 16 | 0;
        e3 = d2;
        ib(a4, b3, c3, e3);
        Ca(e3, c3 + 4 | 0);
        T = d2;
        return;
      }
      function ib(a4, c3, d2, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        k = j;
        jb(a4, d2, k);
        h = +w(+(1 - +e2[k >> 3] * 0.5));
        if (h < 1e-16) {
          b2[f3 >> 2] = 0;
          b2[f3 + 4 >> 2] = 0;
          b2[f3 + 8 >> 2] = 0;
          b2[f3 + 12 >> 2] = 0;
          T = j;
          return;
        }
        k = b2[d2 >> 2] | 0;
        g2 = +e2[15920 + (k * 24 | 0) >> 3];
        g2 = +Zb(g2 - +Zb(+cc(15600 + (k << 4) | 0, a4)));
        if (!(Lb(c3) | 0)) {
          i3 = g2;
        } else {
          i3 = +Zb(g2 + -0.3334731722518321);
        }
        g2 = +v(+h) / 0.381966011250105;
        if ((c3 | 0) > 0) {
          a4 = 0;
          do {
            g2 = g2 * 2.6457513110645907;
            a4 = a4 + 1 | 0;
          } while ((a4 | 0) != (c3 | 0));
        }
        h = +t2(+i3) * g2;
        e2[f3 >> 3] = h;
        i3 = +u(+i3) * g2;
        e2[f3 + 8 >> 3] = i3;
        T = j;
        return;
      }
      function jb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 32 | 0;
        g2 = h;
        Tc(a4, g2);
        b2[c3 >> 2] = 0;
        e2[d2 >> 3] = 5;
        f3 = +Sc(16400, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 0;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16424, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 1;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16448, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 2;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16472, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 3;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16496, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 4;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16520, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 5;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16544, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 6;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16568, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 7;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16592, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 8;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16616, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 9;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16640, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 10;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16664, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 11;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16688, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 12;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16712, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 13;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16736, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 14;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16760, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 15;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16784, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 16;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16808, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 17;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16832, g2);
        if (f3 < +e2[d2 >> 3]) {
          b2[c3 >> 2] = 18;
          e2[d2 >> 3] = f3;
        }
        f3 = +Sc(16856, g2);
        if (!(f3 < +e2[d2 >> 3])) {
          T = h;
          return;
        }
        b2[c3 >> 2] = 19;
        e2[d2 >> 3] = f3;
        T = h;
        return;
      }
      function kb(a4, c3, d2, f3, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0;
        h = +Pc(a4);
        if (h < 1e-16) {
          c3 = 15600 + (c3 << 4) | 0;
          b2[g2 >> 2] = b2[c3 >> 2];
          b2[g2 + 4 >> 2] = b2[c3 + 4 >> 2];
          b2[g2 + 8 >> 2] = b2[c3 + 8 >> 2];
          b2[g2 + 12 >> 2] = b2[c3 + 12 >> 2];
          return;
        }
        i3 = +z(+ +e2[a4 + 8 >> 3], + +e2[a4 >> 3]);
        if ((d2 | 0) > 0) {
          a4 = 0;
          do {
            h = h / 2.6457513110645907;
            a4 = a4 + 1 | 0;
          } while ((a4 | 0) != (d2 | 0));
        }
        if (!f3) {
          h = +y2(+(h * 0.381966011250105));
          if (Lb(d2) | 0) {
            i3 = +Zb(i3 + 0.3334731722518321);
          }
        } else {
          h = h / 3;
          d2 = (Lb(d2) | 0) == 0;
          h = +y2(+((d2 ? h : h / 2.6457513110645907) * 0.381966011250105));
        }
        dc(15600 + (c3 << 4) | 0, +Zb(+e2[15920 + (c3 * 24 | 0) >> 3] - i3), h, g2);
        return;
      }
      function lb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0;
        e3 = T;
        T = T + 16 | 0;
        f3 = e3;
        Ea(a4 + 4 | 0, f3);
        kb(f3, b2[a4 >> 2] | 0, c3, 0, d2);
        T = e3;
        return;
      }
      function mb(a4, c3, d2, f3, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F = 0, G2 = 0, H2 = 0, J2 = 0;
        G2 = T;
        T = T + 272 | 0;
        h = G2 + 256 | 0;
        u2 = G2 + 240 | 0;
        D2 = G2;
        E2 = G2 + 224 | 0;
        F = G2 + 208 | 0;
        v2 = G2 + 176 | 0;
        w2 = G2 + 160 | 0;
        x3 = G2 + 192 | 0;
        y3 = G2 + 144 | 0;
        z2 = G2 + 128 | 0;
        A2 = G2 + 112 | 0;
        B2 = G2 + 96 | 0;
        C2 = G2 + 80 | 0;
        b2[h >> 2] = c3;
        b2[u2 >> 2] = b2[a4 >> 2];
        b2[u2 + 4 >> 2] = b2[a4 + 4 >> 2];
        b2[u2 + 8 >> 2] = b2[a4 + 8 >> 2];
        b2[u2 + 12 >> 2] = b2[a4 + 12 >> 2];
        nb(u2, h, D2);
        b2[g2 >> 2] = 0;
        u2 = f3 + d2 + ((f3 | 0) == 5 & 1) | 0;
        if ((u2 | 0) <= (d2 | 0)) {
          T = G2;
          return;
        }
        k = b2[h >> 2] | 0;
        l2 = E2 + 4 | 0;
        m = v2 + 4 | 0;
        n2 = d2 + 5 | 0;
        o2 = 16880 + (k << 2) | 0;
        p3 = 16960 + (k << 2) | 0;
        q2 = z2 + 8 | 0;
        r3 = A2 + 8 | 0;
        s3 = B2 + 8 | 0;
        t3 = F + 4 | 0;
        j = d2;
        a:
          while (1) {
            i3 = D2 + (((j | 0) % 5 | 0) << 4) | 0;
            b2[F >> 2] = b2[i3 >> 2];
            b2[F + 4 >> 2] = b2[i3 + 4 >> 2];
            b2[F + 8 >> 2] = b2[i3 + 8 >> 2];
            b2[F + 12 >> 2] = b2[i3 + 12 >> 2];
            do {
            } while ((ob(F, k, 0, 1) | 0) == 2);
            if ((j | 0) > (d2 | 0) & (Lb(c3) | 0) != 0) {
              b2[v2 >> 2] = b2[F >> 2];
              b2[v2 + 4 >> 2] = b2[F + 4 >> 2];
              b2[v2 + 8 >> 2] = b2[F + 8 >> 2];
              b2[v2 + 12 >> 2] = b2[F + 12 >> 2];
              Ea(l2, w2);
              f3 = b2[v2 >> 2] | 0;
              h = b2[17040 + (f3 * 80 | 0) + (b2[E2 >> 2] << 2) >> 2] | 0;
              b2[v2 >> 2] = b2[18640 + (f3 * 80 | 0) + (h * 20 | 0) >> 2];
              i3 = b2[18640 + (f3 * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
              if ((i3 | 0) > 0) {
                a4 = 0;
                do {
                  Qa(m);
                  a4 = a4 + 1 | 0;
                } while ((a4 | 0) < (i3 | 0));
              }
              i3 = 18640 + (f3 * 80 | 0) + (h * 20 | 0) + 4 | 0;
              b2[x3 >> 2] = b2[i3 >> 2];
              b2[x3 + 4 >> 2] = b2[i3 + 4 >> 2];
              b2[x3 + 8 >> 2] = b2[i3 + 8 >> 2];
              Ha(x3, (b2[o2 >> 2] | 0) * 3 | 0);
              Fa(m, x3, m);
              Da(m);
              Ea(m, y3);
              H2 = +(b2[p3 >> 2] | 0);
              e2[z2 >> 3] = H2 * 3;
              e2[q2 >> 3] = 0;
              J2 = H2 * -1.5;
              e2[A2 >> 3] = J2;
              e2[r3 >> 3] = H2 * 2.598076211353316;
              e2[B2 >> 3] = J2;
              e2[s3 >> 3] = H2 * -2.598076211353316;
              switch (b2[17040 + ((b2[v2 >> 2] | 0) * 80 | 0) + (b2[F >> 2] << 2) >> 2] | 0) {
                case 1: {
                  a4 = A2;
                  f3 = z2;
                  break;
                }
                case 3: {
                  a4 = B2;
                  f3 = A2;
                  break;
                }
                case 2: {
                  a4 = z2;
                  f3 = B2;
                  break;
                }
                default: {
                  a4 = 12;
                  break a;
                }
              }
              Qc(w2, y3, f3, a4, C2);
              kb(C2, b2[v2 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
              b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
            }
            if ((j | 0) < (n2 | 0)) {
              Ea(t3, v2);
              kb(v2, b2[F >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
              b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
            }
            b2[E2 >> 2] = b2[F >> 2];
            b2[E2 + 4 >> 2] = b2[F + 4 >> 2];
            b2[E2 + 8 >> 2] = b2[F + 8 >> 2];
            b2[E2 + 12 >> 2] = b2[F + 12 >> 2];
            j = j + 1 | 0;
            if ((j | 0) >= (u2 | 0)) {
              a4 = 3;
              break;
            }
          }
        if ((a4 | 0) == 3) {
          T = G2;
          return;
        } else if ((a4 | 0) == 12) {
          I(22522, 22569, 571, 22579);
        }
      }
      function nb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 128 | 0;
        e3 = j + 64 | 0;
        f3 = j;
        g2 = e3;
        h = 20240;
        i3 = g2 + 60 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i3 | 0));
        g2 = f3;
        h = 20304;
        i3 = g2 + 60 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i3 | 0));
        i3 = (Lb(b2[c3 >> 2] | 0) | 0) == 0;
        e3 = i3 ? e3 : f3;
        f3 = a4 + 4 | 0;
        Ua(f3);
        Va(f3);
        if (Lb(b2[c3 >> 2] | 0) | 0) {
          Oa(f3);
          b2[c3 >> 2] = (b2[c3 >> 2] | 0) + 1;
        }
        b2[d2 >> 2] = b2[a4 >> 2];
        c3 = d2 + 4 | 0;
        Fa(f3, e3, c3);
        Da(c3);
        b2[d2 + 16 >> 2] = b2[a4 >> 2];
        c3 = d2 + 20 | 0;
        Fa(f3, e3 + 12 | 0, c3);
        Da(c3);
        b2[d2 + 32 >> 2] = b2[a4 >> 2];
        c3 = d2 + 36 | 0;
        Fa(f3, e3 + 24 | 0, c3);
        Da(c3);
        b2[d2 + 48 >> 2] = b2[a4 >> 2];
        c3 = d2 + 52 | 0;
        Fa(f3, e3 + 36 | 0, c3);
        Da(c3);
        b2[d2 + 64 >> 2] = b2[a4 >> 2];
        d2 = d2 + 68 | 0;
        Fa(f3, e3 + 48 | 0, d2);
        Da(d2);
        T = j;
        return;
      }
      function ob(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
        p3 = T;
        T = T + 32 | 0;
        n2 = p3 + 12 | 0;
        i3 = p3;
        o2 = a4 + 4 | 0;
        m = b2[16960 + (c3 << 2) >> 2] | 0;
        l2 = (e3 | 0) != 0;
        m = l2 ? m * 3 | 0 : m;
        f3 = b2[o2 >> 2] | 0;
        k = a4 + 8 | 0;
        h = b2[k >> 2] | 0;
        if (l2) {
          g2 = a4 + 12 | 0;
          e3 = b2[g2 >> 2] | 0;
          f3 = h + f3 + e3 | 0;
          if ((f3 | 0) == (m | 0)) {
            o2 = 1;
            T = p3;
            return o2 | 0;
          } else {
            j = g2;
          }
        } else {
          j = a4 + 12 | 0;
          e3 = b2[j >> 2] | 0;
          f3 = h + f3 + e3 | 0;
        }
        if ((f3 | 0) <= (m | 0)) {
          o2 = 0;
          T = p3;
          return o2 | 0;
        }
        do {
          if ((e3 | 0) > 0) {
            e3 = b2[a4 >> 2] | 0;
            if ((h | 0) > 0) {
              g2 = 18640 + (e3 * 80 | 0) + 60 | 0;
              e3 = a4;
              break;
            }
            e3 = 18640 + (e3 * 80 | 0) + 40 | 0;
            if (!d2) {
              g2 = e3;
              e3 = a4;
            } else {
              Ba(n2, m, 0, 0);
              Ga(o2, n2, i3);
              Ra(i3);
              Fa(i3, n2, o2);
              g2 = e3;
              e3 = a4;
            }
          } else {
            g2 = 18640 + ((b2[a4 >> 2] | 0) * 80 | 0) + 20 | 0;
            e3 = a4;
          }
        } while (0);
        b2[e3 >> 2] = b2[g2 >> 2];
        f3 = g2 + 16 | 0;
        if ((b2[f3 >> 2] | 0) > 0) {
          e3 = 0;
          do {
            Qa(o2);
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) < (b2[f3 >> 2] | 0));
        }
        a4 = g2 + 4 | 0;
        b2[n2 >> 2] = b2[a4 >> 2];
        b2[n2 + 4 >> 2] = b2[a4 + 4 >> 2];
        b2[n2 + 8 >> 2] = b2[a4 + 8 >> 2];
        c3 = b2[16880 + (c3 << 2) >> 2] | 0;
        Ha(n2, l2 ? c3 * 3 | 0 : c3);
        Fa(o2, n2, o2);
        Da(o2);
        if (l2) {
          e3 = ((b2[k >> 2] | 0) + (b2[o2 >> 2] | 0) + (b2[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
        } else {
          e3 = 2;
        }
        o2 = e3;
        T = p3;
        return o2 | 0;
      }
      function pb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0;
        do {
          c3 = ob(a4, b3, 0, 1) | 0;
        } while ((c3 | 0) == 2);
        return c3 | 0;
      }
      function qb(a4, c3, d2, f3, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0;
        B2 = T;
        T = T + 240 | 0;
        h = B2 + 224 | 0;
        x3 = B2 + 208 | 0;
        y3 = B2;
        z2 = B2 + 192 | 0;
        A2 = B2 + 176 | 0;
        s3 = B2 + 160 | 0;
        t3 = B2 + 144 | 0;
        u2 = B2 + 128 | 0;
        v2 = B2 + 112 | 0;
        w2 = B2 + 96 | 0;
        b2[h >> 2] = c3;
        b2[x3 >> 2] = b2[a4 >> 2];
        b2[x3 + 4 >> 2] = b2[a4 + 4 >> 2];
        b2[x3 + 8 >> 2] = b2[a4 + 8 >> 2];
        b2[x3 + 12 >> 2] = b2[a4 + 12 >> 2];
        rb(x3, h, y3);
        b2[g2 >> 2] = 0;
        r3 = f3 + d2 + ((f3 | 0) == 6 & 1) | 0;
        if ((r3 | 0) <= (d2 | 0)) {
          T = B2;
          return;
        }
        k = b2[h >> 2] | 0;
        l2 = d2 + 6 | 0;
        m = 16960 + (k << 2) | 0;
        n2 = t3 + 8 | 0;
        o2 = u2 + 8 | 0;
        p3 = v2 + 8 | 0;
        q2 = z2 + 4 | 0;
        i3 = 0;
        j = d2;
        f3 = -1;
        a:
          while (1) {
            h = (j | 0) % 6 | 0;
            a4 = y3 + (h << 4) | 0;
            b2[z2 >> 2] = b2[a4 >> 2];
            b2[z2 + 4 >> 2] = b2[a4 + 4 >> 2];
            b2[z2 + 8 >> 2] = b2[a4 + 8 >> 2];
            b2[z2 + 12 >> 2] = b2[a4 + 12 >> 2];
            a4 = i3;
            i3 = ob(z2, k, 0, 1) | 0;
            if ((j | 0) > (d2 | 0) & (Lb(c3) | 0) != 0 ? (a4 | 0) != 1 ? (b2[z2 >> 2] | 0) != (f3 | 0) : 0 : 0) {
              Ea(y3 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A2);
              Ea(y3 + (h << 4) + 4 | 0, s3);
              C2 = +(b2[m >> 2] | 0);
              e2[t3 >> 3] = C2 * 3;
              e2[n2 >> 3] = 0;
              D2 = C2 * -1.5;
              e2[u2 >> 3] = D2;
              e2[o2 >> 3] = C2 * 2.598076211353316;
              e2[v2 >> 3] = D2;
              e2[p3 >> 3] = C2 * -2.598076211353316;
              h = b2[x3 >> 2] | 0;
              switch (b2[17040 + (h * 80 | 0) + (((f3 | 0) == (h | 0) ? b2[z2 >> 2] | 0 : f3) << 2) >> 2] | 0) {
                case 1: {
                  a4 = u2;
                  f3 = t3;
                  break;
                }
                case 3: {
                  a4 = v2;
                  f3 = u2;
                  break;
                }
                case 2: {
                  a4 = t3;
                  f3 = v2;
                  break;
                }
                default: {
                  a4 = 8;
                  break a;
                }
              }
              Qc(A2, s3, f3, a4, w2);
              if (!(Rc(A2, w2) | 0) ? !(Rc(s3, w2) | 0) : 0) {
                kb(w2, b2[x3 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
                b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
              }
            }
            if ((j | 0) < (l2 | 0)) {
              Ea(q2, A2);
              kb(A2, b2[z2 >> 2] | 0, k, 1, g2 + 8 + (b2[g2 >> 2] << 4) | 0);
              b2[g2 >> 2] = (b2[g2 >> 2] | 0) + 1;
            }
            j = j + 1 | 0;
            if ((j | 0) >= (r3 | 0)) {
              a4 = 3;
              break;
            } else {
              f3 = b2[z2 >> 2] | 0;
            }
          }
        if ((a4 | 0) == 3) {
          T = B2;
          return;
        } else if ((a4 | 0) == 8) {
          I(22606, 22569, 736, 22651);
        }
      }
      function rb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 160 | 0;
        e3 = j + 80 | 0;
        f3 = j;
        g2 = e3;
        h = 20368;
        i3 = g2 + 72 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i3 | 0));
        g2 = f3;
        h = 20448;
        i3 = g2 + 72 | 0;
        do {
          b2[g2 >> 2] = b2[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i3 | 0));
        i3 = (Lb(b2[c3 >> 2] | 0) | 0) == 0;
        e3 = i3 ? e3 : f3;
        f3 = a4 + 4 | 0;
        Ua(f3);
        Va(f3);
        if (Lb(b2[c3 >> 2] | 0) | 0) {
          Oa(f3);
          b2[c3 >> 2] = (b2[c3 >> 2] | 0) + 1;
        }
        b2[d2 >> 2] = b2[a4 >> 2];
        c3 = d2 + 4 | 0;
        Fa(f3, e3, c3);
        Da(c3);
        b2[d2 + 16 >> 2] = b2[a4 >> 2];
        c3 = d2 + 20 | 0;
        Fa(f3, e3 + 12 | 0, c3);
        Da(c3);
        b2[d2 + 32 >> 2] = b2[a4 >> 2];
        c3 = d2 + 36 | 0;
        Fa(f3, e3 + 24 | 0, c3);
        Da(c3);
        b2[d2 + 48 >> 2] = b2[a4 >> 2];
        c3 = d2 + 52 | 0;
        Fa(f3, e3 + 36 | 0, c3);
        Da(c3);
        b2[d2 + 64 >> 2] = b2[a4 >> 2];
        c3 = d2 + 68 | 0;
        Fa(f3, e3 + 48 | 0, c3);
        Da(c3);
        b2[d2 + 80 >> 2] = b2[a4 >> 2];
        d2 = d2 + 84 | 0;
        Fa(f3, e3 + 60 | 0, d2);
        Da(d2);
        T = j;
        return;
      }
      function sb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        b3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        return b3 & 15 | 0;
      }
      function tb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        b3 = vd(a4 | 0, b3 | 0, 45) | 0;
        H() | 0;
        return b3 & 127 | 0;
      }
      function ub(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0;
        if (!(true & (b3 & -16777216 | 0) == 134217728)) {
          b3 = 0;
          return b3 | 0;
        }
        g2 = vd(a4 | 0, b3 | 0, 45) | 0;
        H() | 0;
        g2 = g2 & 127;
        if (g2 >>> 0 > 121) {
          b3 = 0;
          return b3 | 0;
        }
        c3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        do {
          if (c3 | 0) {
            e3 = 1;
            d2 = 0;
            while (1) {
              f3 = vd(a4 | 0, b3 | 0, (15 - e3 | 0) * 3 | 0) | 0;
              H() | 0;
              f3 = f3 & 7;
              if ((f3 | 0) != 0 & (d2 ^ 1)) {
                if ((f3 | 0) == 1 & (ma(g2) | 0) != 0) {
                  h = 0;
                  d2 = 13;
                  break;
                } else {
                  d2 = 1;
                }
              }
              if ((f3 | 0) == 7) {
                h = 0;
                d2 = 13;
                break;
              }
              if (e3 >>> 0 < c3 >>> 0) {
                e3 = e3 + 1 | 0;
              } else {
                d2 = 9;
                break;
              }
            }
            if ((d2 | 0) == 9) {
              if ((c3 | 0) == 15) {
                h = 1;
              } else {
                break;
              }
              return h | 0;
            } else if ((d2 | 0) == 13) {
              return h | 0;
            }
          }
        } while (0);
        while (1) {
          h = vd(a4 | 0, b3 | 0, (14 - c3 | 0) * 3 | 0) | 0;
          H() | 0;
          if (!((h & 7 | 0) == 7 & true)) {
            h = 0;
            d2 = 13;
            break;
          }
          if (c3 >>> 0 < 14) {
            c3 = c3 + 1 | 0;
          } else {
            h = 1;
            d2 = 13;
            break;
          }
        }
        if ((d2 | 0) == 13) {
          return h | 0;
        }
        return 0;
      }
      function vb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0;
        g2 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (d2 >>> 0 > 15) {
          e3 = 4;
          return e3 | 0;
        }
        if ((g2 | 0) < (d2 | 0)) {
          e3 = 12;
          return e3 | 0;
        }
        if ((g2 | 0) == (d2 | 0)) {
          b2[e3 >> 2] = a4;
          b2[e3 + 4 >> 2] = c3;
          e3 = 0;
          return e3 | 0;
        }
        f3 = wd(d2 | 0, 0, 52) | 0;
        f3 = f3 | a4;
        a4 = H() | 0 | c3 & -15728641;
        if ((g2 | 0) > (d2 | 0)) {
          do {
            c3 = wd(7, 0, (14 - d2 | 0) * 3 | 0) | 0;
            d2 = d2 + 1 | 0;
            f3 = c3 | f3;
            a4 = H() | 0 | a4;
          } while ((d2 | 0) < (g2 | 0));
        }
        b2[e3 >> 2] = f3;
        b2[e3 + 4 >> 2] = a4;
        e3 = 0;
        return e3 | 0;
      }
      function wb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0;
        g2 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (!((d2 | 0) < 16 & (g2 | 0) <= (d2 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        f3 = d2 - g2 | 0;
        d2 = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        a:
          do {
            if (!(ma(d2 & 127) | 0)) {
              d2 = Cc(7, 0, f3, ((f3 | 0) < 0) << 31 >> 31) | 0;
              f3 = H() | 0;
            } else {
              b:
                do {
                  if (g2 | 0) {
                    d2 = 1;
                    while (1) {
                      h = wd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                      if (!((h & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                        break;
                      }
                      if (d2 >>> 0 < g2 >>> 0) {
                        d2 = d2 + 1 | 0;
                      } else {
                        break b;
                      }
                    }
                    d2 = Cc(7, 0, f3, ((f3 | 0) < 0) << 31 >> 31) | 0;
                    f3 = H() | 0;
                    break a;
                  }
                } while (0);
              d2 = Cc(7, 0, f3, ((f3 | 0) < 0) << 31 >> 31) | 0;
              d2 = rd(d2 | 0, H() | 0, 5, 0) | 0;
              d2 = ld(d2 | 0, H() | 0, -5, -1) | 0;
              d2 = pd(d2 | 0, H() | 0, 6, 0) | 0;
              d2 = ld(d2 | 0, H() | 0, 1, 0) | 0;
              f3 = H() | 0;
            }
          } while (0);
        h = e3;
        b2[h >> 2] = d2;
        b2[h + 4 >> 2] = f3;
        h = 0;
        return h | 0;
      }
      function xb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        e3 = vd(a4 | 0, b3 | 0, 45) | 0;
        H() | 0;
        if (!(ma(e3 & 127) | 0)) {
          e3 = 0;
          return e3 | 0;
        }
        e3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a:
          do {
            if (!e3) {
              c3 = 0;
            } else {
              d2 = 1;
              while (1) {
                c3 = vd(a4 | 0, b3 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                H() | 0;
                c3 = c3 & 7;
                if (c3 | 0) {
                  break a;
                }
                if (d2 >>> 0 < e3 >>> 0) {
                  d2 = d2 + 1 | 0;
                } else {
                  c3 = 0;
                  break;
                }
              }
            }
          } while (0);
        e3 = (c3 | 0) == 0 & 1;
        return e3 | 0;
      }
      function yb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        Xb(g2, a4, c3, d2);
        c3 = g2;
        a4 = b2[c3 >> 2] | 0;
        c3 = b2[c3 + 4 >> 2] | 0;
        if ((a4 | 0) == 0 & (c3 | 0) == 0) {
          T = h;
          return 0;
        }
        f3 = 0;
        d2 = 0;
        do {
          i3 = e3 + (f3 << 3) | 0;
          b2[i3 >> 2] = a4;
          b2[i3 + 4 >> 2] = c3;
          f3 = ld(f3 | 0, d2 | 0, 1, 0) | 0;
          d2 = H() | 0;
          Yb(g2);
          i3 = g2;
          a4 = b2[i3 >> 2] | 0;
          c3 = b2[i3 + 4 >> 2] | 0;
        } while (!((a4 | 0) == 0 & (c3 | 0) == 0));
        T = h;
        return 0;
      }
      function zb(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        if ((d2 | 0) < (c3 | 0)) {
          c3 = b3;
          d2 = a4;
          G(c3 | 0);
          return d2 | 0;
        }
        c3 = wd(-1, -1, ((d2 - c3 | 0) * 3 | 0) + 3 | 0) | 0;
        d2 = wd(~c3 | 0, ~(H() | 0) | 0, (15 - d2 | 0) * 3 | 0) | 0;
        c3 = ~(H() | 0) & b3;
        d2 = ~d2 & a4;
        G(c3 | 0);
        return d2 | 0;
      }
      function Ab(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0;
        f3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f3 = f3 & 15;
        if (!((d2 | 0) < 16 & (f3 | 0) <= (d2 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        if ((f3 | 0) < (d2 | 0)) {
          f3 = wd(-1, -1, ((d2 + -1 - f3 | 0) * 3 | 0) + 3 | 0) | 0;
          f3 = wd(~f3 | 0, ~(H() | 0) | 0, (15 - d2 | 0) * 3 | 0) | 0;
          c3 = ~(H() | 0) & c3;
          a4 = ~f3 & a4;
        }
        f3 = wd(d2 | 0, 0, 52) | 0;
        d2 = c3 & -15728641 | (H() | 0);
        b2[e3 >> 2] = a4 | f3;
        b2[e3 + 4 >> 2] = d2;
        e3 = 0;
        return e3 | 0;
      }
      function Bb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0;
        if ((d2 | 0) == 0 & (e3 | 0) == 0) {
          y3 = 0;
          return y3 | 0;
        }
        f3 = a4;
        g2 = b2[f3 >> 2] | 0;
        f3 = b2[f3 + 4 >> 2] | 0;
        if (true & (f3 & 15728640 | 0) == 0) {
          if (!((e3 | 0) > 0 | (e3 | 0) == 0 & d2 >>> 0 > 0)) {
            y3 = 0;
            return y3 | 0;
          }
          y3 = c3;
          b2[y3 >> 2] = g2;
          b2[y3 + 4 >> 2] = f3;
          if ((d2 | 0) == 1 & (e3 | 0) == 0) {
            y3 = 0;
            return y3 | 0;
          }
          f3 = 1;
          do {
            w2 = a4 + (f3 << 3) | 0;
            x3 = b2[w2 + 4 >> 2] | 0;
            y3 = c3 + (f3 << 3) | 0;
            b2[y3 >> 2] = b2[w2 >> 2];
            b2[y3 + 4 >> 2] = x3;
            f3 = f3 + 1 | 0;
          } while (0 < (e3 | 0) | 0 == (e3 | 0) & f3 >>> 0 < d2 >>> 0);
          f3 = 0;
          return f3 | 0;
        }
        v2 = d2 << 3;
        x3 = id(v2) | 0;
        if (!x3) {
          y3 = 13;
          return y3 | 0;
        }
        Ad(x3 | 0, a4 | 0, v2 | 0) | 0;
        w2 = kd(d2, 8) | 0;
        if (!w2) {
          jd(x3);
          y3 = 13;
          return y3 | 0;
        }
        a:
          do {
            if (d2 | 0) {
              b:
                while (1) {
                  f3 = x3;
                  s3 = b2[f3 >> 2] | 0;
                  f3 = b2[f3 + 4 >> 2] | 0;
                  t3 = vd(s3 | 0, f3 | 0, 52) | 0;
                  H() | 0;
                  t3 = t3 & 15;
                  u2 = t3 + -1 | 0;
                  r3 = (d2 | 0) > 0;
                  c:
                    do {
                      if ((t3 | 0) != 0 & r3) {
                        o2 = ((d2 | 0) < 0) << 31 >> 31;
                        p3 = wd(u2 | 0, 0, 52) | 0;
                        q2 = H() | 0;
                        if (u2 >>> 0 > 15) {
                          if (!((s3 | 0) == 0 & (f3 | 0) == 0)) {
                            y3 = 17;
                            break b;
                          }
                          g2 = 0;
                          while (1) {
                            g2 = g2 + 1 | 0;
                            if ((g2 | 0) >= (d2 | 0)) {
                              break c;
                            }
                            e3 = x3 + (g2 << 3) | 0;
                            q2 = b2[e3 >> 2] | 0;
                            e3 = b2[e3 + 4 >> 2] | 0;
                            if (!((q2 | 0) == 0 & (e3 | 0) == 0)) {
                              f3 = e3;
                              y3 = 17;
                              break b;
                            }
                          }
                        }
                        g2 = 0;
                        a4 = s3;
                        e3 = f3;
                        while (1) {
                          if (!((a4 | 0) == 0 & (e3 | 0) == 0)) {
                            if (!(true & (e3 & 117440512 | 0) == 0)) {
                              y3 = 22;
                              break b;
                            }
                            i3 = vd(a4 | 0, e3 | 0, 52) | 0;
                            H() | 0;
                            i3 = i3 & 15;
                            if ((i3 | 0) < (u2 | 0)) {
                              f3 = 12;
                              y3 = 28;
                              break b;
                            }
                            if ((i3 | 0) != (u2 | 0)) {
                              a4 = a4 | p3;
                              e3 = e3 & -15728641 | q2;
                              if (i3 >>> 0 >= t3 >>> 0) {
                                h = u2;
                                do {
                                  n2 = wd(7, 0, (14 - h | 0) * 3 | 0) | 0;
                                  h = h + 1 | 0;
                                  a4 = n2 | a4;
                                  e3 = H() | 0 | e3;
                                } while (h >>> 0 < i3 >>> 0);
                              }
                            }
                            h = td(a4 | 0, e3 | 0, d2 | 0, o2 | 0) | 0;
                            H() | 0;
                            k = w2 + (h << 3) | 0;
                            i3 = k;
                            j = b2[i3 >> 2] | 0;
                            i3 = b2[i3 + 4 >> 2] | 0;
                            if ((j | 0) == 0 & (i3 | 0) == 0) {
                              h = k;
                            } else {
                              n2 = 0;
                              while (1) {
                                if ((n2 | 0) > (d2 | 0)) {
                                  y3 = 32;
                                  break b;
                                }
                                if ((j | 0) == (a4 | 0) & (i3 & -117440513 | 0) == (e3 | 0)) {
                                  l2 = vd(j | 0, i3 | 0, 56) | 0;
                                  H() | 0;
                                  l2 = l2 & 7;
                                  m = l2 + 1 | 0;
                                  z2 = vd(j | 0, i3 | 0, 45) | 0;
                                  H() | 0;
                                  d:
                                    do {
                                      if (!(ma(z2 & 127) | 0)) {
                                        i3 = 7;
                                      } else {
                                        j = vd(j | 0, i3 | 0, 52) | 0;
                                        H() | 0;
                                        j = j & 15;
                                        if (!j) {
                                          i3 = 6;
                                          break;
                                        }
                                        i3 = 1;
                                        while (1) {
                                          z2 = wd(7, 0, (15 - i3 | 0) * 3 | 0) | 0;
                                          if (!((z2 & a4 | 0) == 0 & ((H() | 0) & e3 | 0) == 0)) {
                                            i3 = 7;
                                            break d;
                                          }
                                          if (i3 >>> 0 < j >>> 0) {
                                            i3 = i3 + 1 | 0;
                                          } else {
                                            i3 = 6;
                                            break;
                                          }
                                        }
                                      }
                                    } while (0);
                                  if ((l2 + 2 | 0) >>> 0 > i3 >>> 0) {
                                    y3 = 42;
                                    break b;
                                  }
                                  z2 = wd(m | 0, 0, 56) | 0;
                                  e3 = H() | 0 | e3 & -117440513;
                                  m = k;
                                  b2[m >> 2] = 0;
                                  b2[m + 4 >> 2] = 0;
                                  a4 = z2 | a4;
                                } else {
                                  h = (h + 1 | 0) % (d2 | 0) | 0;
                                }
                                k = w2 + (h << 3) | 0;
                                i3 = k;
                                j = b2[i3 >> 2] | 0;
                                i3 = b2[i3 + 4 >> 2] | 0;
                                if ((j | 0) == 0 & (i3 | 0) == 0) {
                                  h = k;
                                  break;
                                } else {
                                  n2 = n2 + 1 | 0;
                                }
                              }
                            }
                            z2 = h;
                            b2[z2 >> 2] = a4;
                            b2[z2 + 4 >> 2] = e3;
                          }
                          g2 = g2 + 1 | 0;
                          if ((g2 | 0) >= (d2 | 0)) {
                            break c;
                          }
                          e3 = x3 + (g2 << 3) | 0;
                          a4 = b2[e3 >> 2] | 0;
                          e3 = b2[e3 + 4 >> 2] | 0;
                        }
                      }
                    } while (0);
                  if ((d2 + 5 | 0) >>> 0 < 11) {
                    y3 = 85;
                    break;
                  }
                  q2 = kd((d2 | 0) / 6 | 0, 8) | 0;
                  if (!q2) {
                    y3 = 49;
                    break;
                  }
                  e:
                    do {
                      if (r3) {
                        n2 = 0;
                        m = 0;
                        do {
                          i3 = w2 + (n2 << 3) | 0;
                          e3 = i3;
                          g2 = b2[e3 >> 2] | 0;
                          e3 = b2[e3 + 4 >> 2] | 0;
                          if (!((g2 | 0) == 0 & (e3 | 0) == 0)) {
                            j = vd(g2 | 0, e3 | 0, 56) | 0;
                            H() | 0;
                            j = j & 7;
                            a4 = j + 1 | 0;
                            k = e3 & -117440513;
                            z2 = vd(g2 | 0, e3 | 0, 45) | 0;
                            H() | 0;
                            f:
                              do {
                                if (ma(z2 & 127) | 0) {
                                  l2 = vd(g2 | 0, e3 | 0, 52) | 0;
                                  H() | 0;
                                  l2 = l2 & 15;
                                  if (l2 | 0) {
                                    h = 1;
                                    while (1) {
                                      z2 = wd(7, 0, (15 - h | 0) * 3 | 0) | 0;
                                      if (!((g2 & z2 | 0) == 0 & (k & (H() | 0) | 0) == 0)) {
                                        break f;
                                      }
                                      if (h >>> 0 < l2 >>> 0) {
                                        h = h + 1 | 0;
                                      } else {
                                        break;
                                      }
                                    }
                                  }
                                  e3 = wd(a4 | 0, 0, 56) | 0;
                                  g2 = e3 | g2;
                                  e3 = H() | 0 | k;
                                  a4 = i3;
                                  b2[a4 >> 2] = g2;
                                  b2[a4 + 4 >> 2] = e3;
                                  a4 = j + 2 | 0;
                                }
                              } while (0);
                            if ((a4 | 0) == 7) {
                              z2 = q2 + (m << 3) | 0;
                              b2[z2 >> 2] = g2;
                              b2[z2 + 4 >> 2] = e3 & -117440513;
                              m = m + 1 | 0;
                            }
                          }
                          n2 = n2 + 1 | 0;
                        } while ((n2 | 0) != (d2 | 0));
                        if (r3) {
                          n2 = ((d2 | 0) < 0) << 31 >> 31;
                          o2 = wd(u2 | 0, 0, 52) | 0;
                          p3 = H() | 0;
                          if (u2 >>> 0 > 15) {
                            if (!((s3 | 0) == 0 & (f3 | 0) == 0)) {
                              f3 = 4;
                              y3 = 84;
                              break b;
                            }
                            f3 = 0;
                            while (1) {
                              f3 = f3 + 1 | 0;
                              if ((f3 | 0) >= (d2 | 0)) {
                                g2 = 0;
                                f3 = m;
                                break e;
                              }
                              z2 = x3 + (f3 << 3) | 0;
                              if (!((b2[z2 >> 2] | 0) == 0 & (b2[z2 + 4 >> 2] | 0) == 0)) {
                                f3 = 4;
                                y3 = 84;
                                break b;
                              }
                            }
                          }
                          l2 = 0;
                          g2 = 0;
                          k = s3;
                          while (1) {
                            do {
                              if (!((k | 0) == 0 & (f3 | 0) == 0)) {
                                i3 = vd(k | 0, f3 | 0, 52) | 0;
                                H() | 0;
                                i3 = i3 & 15;
                                if ((i3 | 0) < (u2 | 0)) {
                                  f3 = 12;
                                  y3 = 84;
                                  break b;
                                }
                                do {
                                  if ((i3 | 0) == (u2 | 0)) {
                                    e3 = k;
                                    i3 = f3;
                                  } else {
                                    e3 = k | o2;
                                    a4 = f3 & -15728641 | p3;
                                    if (i3 >>> 0 < t3 >>> 0) {
                                      i3 = a4;
                                      break;
                                    }
                                    h = u2;
                                    do {
                                      z2 = wd(7, 0, (14 - h | 0) * 3 | 0) | 0;
                                      h = h + 1 | 0;
                                      e3 = z2 | e3;
                                      a4 = H() | 0 | a4;
                                    } while (h >>> 0 < i3 >>> 0);
                                    i3 = a4;
                                  }
                                } while (0);
                                h = td(e3 | 0, i3 | 0, d2 | 0, n2 | 0) | 0;
                                H() | 0;
                                a4 = 0;
                                while (1) {
                                  if ((a4 | 0) > (d2 | 0)) {
                                    y3 = 77;
                                    break b;
                                  }
                                  z2 = w2 + (h << 3) | 0;
                                  j = b2[z2 + 4 >> 2] | 0;
                                  if ((j & -117440513 | 0) == (i3 | 0) ? (b2[z2 >> 2] | 0) == (e3 | 0) : 0) {
                                    y3 = 79;
                                    break;
                                  }
                                  h = (h + 1 | 0) % (d2 | 0) | 0;
                                  z2 = w2 + (h << 3) | 0;
                                  if ((b2[z2 >> 2] | 0) == (e3 | 0) ? (b2[z2 + 4 >> 2] | 0) == (i3 | 0) : 0) {
                                    break;
                                  } else {
                                    a4 = a4 + 1 | 0;
                                  }
                                }
                                if ((y3 | 0) == 79 ? (y3 = 0, true & (j & 117440512 | 0) == 100663296) : 0) {
                                  break;
                                }
                                z2 = c3 + (g2 << 3) | 0;
                                b2[z2 >> 2] = k;
                                b2[z2 + 4 >> 2] = f3;
                                g2 = g2 + 1 | 0;
                              }
                            } while (0);
                            f3 = l2 + 1 | 0;
                            if ((f3 | 0) >= (d2 | 0)) {
                              f3 = m;
                              break e;
                            }
                            z2 = x3 + (f3 << 3) | 0;
                            l2 = f3;
                            k = b2[z2 >> 2] | 0;
                            f3 = b2[z2 + 4 >> 2] | 0;
                          }
                        } else {
                          g2 = 0;
                          f3 = m;
                        }
                      } else {
                        g2 = 0;
                        f3 = 0;
                      }
                    } while (0);
                  Bd(w2 | 0, 0, v2 | 0) | 0;
                  Ad(x3 | 0, q2 | 0, f3 << 3 | 0) | 0;
                  jd(q2);
                  if (!f3) {
                    break a;
                  } else {
                    c3 = c3 + (g2 << 3) | 0;
                    d2 = f3;
                  }
                }
              if ((y3 | 0) == 17) {
                if (true & (f3 & 117440512 | 0) == 0) {
                  f3 = 4;
                  y3 = 28;
                } else {
                  y3 = 22;
                }
              } else if ((y3 | 0) == 32) {
                I(23313, 22674, 362, 22684);
              } else if ((y3 | 0) == 42) {
                jd(x3);
                jd(w2);
                z2 = 10;
                return z2 | 0;
              } else if ((y3 | 0) == 49) {
                jd(x3);
                jd(w2);
                z2 = 13;
                return z2 | 0;
              } else if ((y3 | 0) == 77) {
                I(23313, 22674, 462, 22684);
              } else if ((y3 | 0) == 84) {
                jd(q2);
                jd(x3);
                jd(w2);
                z2 = f3;
                return z2 | 0;
              } else if ((y3 | 0) == 85) {
                Ad(c3 | 0, x3 | 0, d2 << 3 | 0) | 0;
                break;
              }
              if ((y3 | 0) == 22) {
                jd(x3);
                jd(w2);
                z2 = 5;
                return z2 | 0;
              } else if ((y3 | 0) == 28) {
                jd(x3);
                jd(w2);
                z2 = f3;
                return z2 | 0;
              }
            }
          } while (0);
        jd(x3);
        jd(w2);
        z2 = 0;
        return z2 | 0;
      }
      function Cb(a4, c3, d2, e3, f3, g2, h) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        p3 = q2;
        if (!((d2 | 0) > 0 | (d2 | 0) == 0 & c3 >>> 0 > 0)) {
          p3 = 0;
          T = q2;
          return p3 | 0;
        }
        if ((h | 0) >= 16) {
          p3 = 12;
          T = q2;
          return p3 | 0;
        }
        n2 = 0;
        o2 = 0;
        m = 0;
        i3 = 0;
        a:
          while (1) {
            k = a4 + (n2 << 3) | 0;
            j = b2[k >> 2] | 0;
            k = b2[k + 4 >> 2] | 0;
            l2 = vd(j | 0, k | 0, 52) | 0;
            H() | 0;
            if ((l2 & 15 | 0) > (h | 0)) {
              i3 = 12;
              j = 11;
              break;
            }
            Xb(p3, j, k, h);
            l2 = p3;
            k = b2[l2 >> 2] | 0;
            l2 = b2[l2 + 4 >> 2] | 0;
            if ((k | 0) == 0 & (l2 | 0) == 0) {
              j = m;
            } else {
              j = m;
              do {
                if (!((i3 | 0) < (g2 | 0) | (i3 | 0) == (g2 | 0) & j >>> 0 < f3 >>> 0)) {
                  j = 10;
                  break a;
                }
                m = e3 + (j << 3) | 0;
                b2[m >> 2] = k;
                b2[m + 4 >> 2] = l2;
                j = ld(j | 0, i3 | 0, 1, 0) | 0;
                i3 = H() | 0;
                Yb(p3);
                m = p3;
                k = b2[m >> 2] | 0;
                l2 = b2[m + 4 >> 2] | 0;
              } while (!((k | 0) == 0 & (l2 | 0) == 0));
            }
            n2 = ld(n2 | 0, o2 | 0, 1, 0) | 0;
            o2 = H() | 0;
            if (!((o2 | 0) < (d2 | 0) | (o2 | 0) == (d2 | 0) & n2 >>> 0 < c3 >>> 0)) {
              i3 = 0;
              j = 11;
              break;
            } else {
              m = j;
            }
          }
        if ((j | 0) == 10) {
          p3 = 14;
          T = q2;
          return p3 | 0;
        } else if ((j | 0) == 11) {
          T = q2;
          return i3 | 0;
        }
        return 0;
      }
      function Db(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
        n2 = T;
        T = T + 16 | 0;
        m = n2;
        a:
          do {
            if ((d2 | 0) > 0 | (d2 | 0) == 0 & c3 >>> 0 > 0) {
              k = 0;
              h = 0;
              g2 = 0;
              l2 = 0;
              while (1) {
                j = a4 + (k << 3) | 0;
                i3 = b2[j >> 2] | 0;
                j = b2[j + 4 >> 2] | 0;
                if (!((i3 | 0) == 0 & (j | 0) == 0)) {
                  j = (wb(i3, j, e3, m) | 0) == 0;
                  i3 = m;
                  h = ld(b2[i3 >> 2] | 0, b2[i3 + 4 >> 2] | 0, h | 0, g2 | 0) | 0;
                  g2 = H() | 0;
                  if (!j) {
                    g2 = 12;
                    break;
                  }
                }
                k = ld(k | 0, l2 | 0, 1, 0) | 0;
                l2 = H() | 0;
                if (!((l2 | 0) < (d2 | 0) | (l2 | 0) == (d2 | 0) & k >>> 0 < c3 >>> 0)) {
                  break a;
                }
              }
              T = n2;
              return g2 | 0;
            } else {
              h = 0;
              g2 = 0;
            }
          } while (0);
        b2[f3 >> 2] = h;
        b2[f3 + 4 >> 2] = g2;
        f3 = 0;
        T = n2;
        return f3 | 0;
      }
      function Eb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        b3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        return b3 & 1 | 0;
      }
      function Fb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        e3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        if (!e3) {
          e3 = 0;
          return e3 | 0;
        }
        d2 = 1;
        while (1) {
          c3 = vd(a4 | 0, b3 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          H() | 0;
          c3 = c3 & 7;
          if (c3 | 0) {
            d2 = 5;
            break;
          }
          if (d2 >>> 0 < e3 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            c3 = 0;
            d2 = 5;
            break;
          }
        }
        if ((d2 | 0) == 5) {
          return c3 | 0;
        }
        return 0;
      }
      function Gb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        i3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        i3 = i3 & 15;
        if (!i3) {
          h = b3;
          i3 = a4;
          G(h | 0);
          return i3 | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f3 = (15 - h | 0) * 3 | 0;
          d2 = wd(7, 0, f3 | 0) | 0;
          e3 = H() | 0;
          g2 = vd(a4 | 0, b3 | 0, f3 | 0) | 0;
          H() | 0;
          f3 = wd(Sa(g2 & 7) | 0, 0, f3 | 0) | 0;
          g2 = H() | 0;
          a4 = f3 | a4 & ~d2;
          b3 = g2 | b3 & ~e3;
          a:
            do {
              if (!c3) {
                if (!((f3 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                  d2 = vd(a4 | 0, b3 | 0, 52) | 0;
                  H() | 0;
                  d2 = d2 & 15;
                  if (!d2) {
                    c3 = 1;
                  } else {
                    c3 = 1;
                    b:
                      while (1) {
                        g2 = vd(a4 | 0, b3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                        H() | 0;
                        switch (g2 & 7) {
                          case 1:
                            break b;
                          case 0:
                            break;
                          default: {
                            c3 = 1;
                            break a;
                          }
                        }
                        if (c3 >>> 0 < d2 >>> 0) {
                          c3 = c3 + 1 | 0;
                        } else {
                          c3 = 1;
                          break a;
                        }
                      }
                    c3 = 1;
                    while (1) {
                      g2 = (15 - c3 | 0) * 3 | 0;
                      e3 = vd(a4 | 0, b3 | 0, g2 | 0) | 0;
                      H() | 0;
                      f3 = wd(7, 0, g2 | 0) | 0;
                      b3 = b3 & ~(H() | 0);
                      g2 = wd(Sa(e3 & 7) | 0, 0, g2 | 0) | 0;
                      a4 = a4 & ~f3 | g2;
                      b3 = b3 | (H() | 0);
                      if (c3 >>> 0 < d2 >>> 0) {
                        c3 = c3 + 1 | 0;
                      } else {
                        c3 = 1;
                        break;
                      }
                    }
                  }
                } else {
                  c3 = 0;
                }
              }
            } while (0);
          if (h >>> 0 < i3 >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G(b3 | 0);
        return a4 | 0;
      }
      function Hb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0;
        d2 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c3 = b3;
          d2 = a4;
          G(c3 | 0);
          return d2 | 0;
        }
        c3 = 1;
        while (1) {
          f3 = (15 - c3 | 0) * 3 | 0;
          g2 = vd(a4 | 0, b3 | 0, f3 | 0) | 0;
          H() | 0;
          e3 = wd(7, 0, f3 | 0) | 0;
          b3 = b3 & ~(H() | 0);
          f3 = wd(Sa(g2 & 7) | 0, 0, f3 | 0) | 0;
          a4 = f3 | a4 & ~e3;
          b3 = H() | 0 | b3;
          if (c3 >>> 0 < d2 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G(b3 | 0);
        return a4 | 0;
      }
      function Ib(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0;
        i3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        i3 = i3 & 15;
        if (!i3) {
          h = b3;
          i3 = a4;
          G(h | 0);
          return i3 | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f3 = (15 - h | 0) * 3 | 0;
          d2 = wd(7, 0, f3 | 0) | 0;
          e3 = H() | 0;
          g2 = vd(a4 | 0, b3 | 0, f3 | 0) | 0;
          H() | 0;
          f3 = wd(Ta(g2 & 7) | 0, 0, f3 | 0) | 0;
          g2 = H() | 0;
          a4 = f3 | a4 & ~d2;
          b3 = g2 | b3 & ~e3;
          a:
            do {
              if (!c3) {
                if (!((f3 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                  d2 = vd(a4 | 0, b3 | 0, 52) | 0;
                  H() | 0;
                  d2 = d2 & 15;
                  if (!d2) {
                    c3 = 1;
                  } else {
                    c3 = 1;
                    b:
                      while (1) {
                        g2 = vd(a4 | 0, b3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                        H() | 0;
                        switch (g2 & 7) {
                          case 1:
                            break b;
                          case 0:
                            break;
                          default: {
                            c3 = 1;
                            break a;
                          }
                        }
                        if (c3 >>> 0 < d2 >>> 0) {
                          c3 = c3 + 1 | 0;
                        } else {
                          c3 = 1;
                          break a;
                        }
                      }
                    c3 = 1;
                    while (1) {
                      e3 = (15 - c3 | 0) * 3 | 0;
                      f3 = wd(7, 0, e3 | 0) | 0;
                      g2 = b3 & ~(H() | 0);
                      b3 = vd(a4 | 0, b3 | 0, e3 | 0) | 0;
                      H() | 0;
                      b3 = wd(Ta(b3 & 7) | 0, 0, e3 | 0) | 0;
                      a4 = a4 & ~f3 | b3;
                      b3 = g2 | (H() | 0);
                      if (c3 >>> 0 < d2 >>> 0) {
                        c3 = c3 + 1 | 0;
                      } else {
                        c3 = 1;
                        break;
                      }
                    }
                  }
                } else {
                  c3 = 0;
                }
              }
            } while (0);
          if (h >>> 0 < i3 >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G(b3 | 0);
        return a4 | 0;
      }
      function Jb(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0;
        d2 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c3 = b3;
          d2 = a4;
          G(c3 | 0);
          return d2 | 0;
        }
        c3 = 1;
        while (1) {
          g2 = (15 - c3 | 0) * 3 | 0;
          f3 = wd(7, 0, g2 | 0) | 0;
          e3 = b3 & ~(H() | 0);
          b3 = vd(a4 | 0, b3 | 0, g2 | 0) | 0;
          H() | 0;
          b3 = wd(Ta(b3 & 7) | 0, 0, g2 | 0) | 0;
          a4 = b3 | a4 & ~f3;
          b3 = H() | 0 | e3;
          if (c3 >>> 0 < d2 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G(b3 | 0);
        return a4 | 0;
      }
      function Kb(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
        j = T;
        T = T + 64 | 0;
        i3 = j + 40 | 0;
        e3 = j + 24 | 0;
        f3 = j + 12 | 0;
        g2 = j;
        wd(c3 | 0, 0, 52) | 0;
        d2 = H() | 0 | 134225919;
        if (!c3) {
          if ((b2[a4 + 4 >> 2] | 0) > 2) {
            h = 0;
            i3 = 0;
            G(h | 0);
            T = j;
            return i3 | 0;
          }
          if ((b2[a4 + 8 >> 2] | 0) > 2) {
            h = 0;
            i3 = 0;
            G(h | 0);
            T = j;
            return i3 | 0;
          }
          if ((b2[a4 + 12 >> 2] | 0) > 2) {
            h = 0;
            i3 = 0;
            G(h | 0);
            T = j;
            return i3 | 0;
          }
          wd(oa(a4) | 0, 0, 45) | 0;
          h = H() | 0 | d2;
          i3 = -1;
          G(h | 0);
          T = j;
          return i3 | 0;
        }
        b2[i3 >> 2] = b2[a4 >> 2];
        b2[i3 + 4 >> 2] = b2[a4 + 4 >> 2];
        b2[i3 + 8 >> 2] = b2[a4 + 8 >> 2];
        b2[i3 + 12 >> 2] = b2[a4 + 12 >> 2];
        h = i3 + 4 | 0;
        if ((c3 | 0) > 0) {
          a4 = -1;
          while (1) {
            b2[e3 >> 2] = b2[h >> 2];
            b2[e3 + 4 >> 2] = b2[h + 4 >> 2];
            b2[e3 + 8 >> 2] = b2[h + 8 >> 2];
            if (!(c3 & 1)) {
              Ma(h);
              b2[f3 >> 2] = b2[h >> 2];
              b2[f3 + 4 >> 2] = b2[h + 4 >> 2];
              b2[f3 + 8 >> 2] = b2[h + 8 >> 2];
              Oa(f3);
            } else {
              La(h);
              b2[f3 >> 2] = b2[h >> 2];
              b2[f3 + 4 >> 2] = b2[h + 4 >> 2];
              b2[f3 + 8 >> 2] = b2[h + 8 >> 2];
              Na(f3);
            }
            Ga(e3, f3, g2);
            Da(g2);
            l2 = (15 - c3 | 0) * 3 | 0;
            k = wd(7, 0, l2 | 0) | 0;
            d2 = d2 & ~(H() | 0);
            l2 = wd(Ia(g2) | 0, 0, l2 | 0) | 0;
            a4 = l2 | a4 & ~k;
            d2 = H() | 0 | d2;
            if ((c3 | 0) > 1) {
              c3 = c3 + -1 | 0;
            } else {
              break;
            }
          }
        } else {
          a4 = -1;
        }
        a:
          do {
            if (((b2[h >> 2] | 0) <= 2 ? (b2[i3 + 8 >> 2] | 0) <= 2 : 0) ? (b2[i3 + 12 >> 2] | 0) <= 2 : 0) {
              e3 = oa(i3) | 0;
              c3 = wd(e3 | 0, 0, 45) | 0;
              c3 = c3 | a4;
              a4 = H() | 0 | d2 & -1040385;
              g2 = pa(i3) | 0;
              if (!(ma(e3) | 0)) {
                if ((g2 | 0) <= 0) {
                  break;
                }
                f3 = 0;
                while (1) {
                  e3 = vd(c3 | 0, a4 | 0, 52) | 0;
                  H() | 0;
                  e3 = e3 & 15;
                  if (e3) {
                    d2 = 1;
                    while (1) {
                      l2 = (15 - d2 | 0) * 3 | 0;
                      i3 = vd(c3 | 0, a4 | 0, l2 | 0) | 0;
                      H() | 0;
                      k = wd(7, 0, l2 | 0) | 0;
                      a4 = a4 & ~(H() | 0);
                      l2 = wd(Sa(i3 & 7) | 0, 0, l2 | 0) | 0;
                      c3 = c3 & ~k | l2;
                      a4 = a4 | (H() | 0);
                      if (d2 >>> 0 < e3 >>> 0) {
                        d2 = d2 + 1 | 0;
                      } else {
                        break;
                      }
                    }
                  }
                  f3 = f3 + 1 | 0;
                  if ((f3 | 0) == (g2 | 0)) {
                    break a;
                  }
                }
              }
              f3 = vd(c3 | 0, a4 | 0, 52) | 0;
              H() | 0;
              f3 = f3 & 15;
              b:
                do {
                  if (f3) {
                    d2 = 1;
                    c:
                      while (1) {
                        l2 = vd(c3 | 0, a4 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                        H() | 0;
                        switch (l2 & 7) {
                          case 1:
                            break c;
                          case 0:
                            break;
                          default:
                            break b;
                        }
                        if (d2 >>> 0 < f3 >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break b;
                        }
                      }
                    if (sa(e3, b2[i3 >> 2] | 0) | 0) {
                      d2 = 1;
                      while (1) {
                        i3 = (15 - d2 | 0) * 3 | 0;
                        k = wd(7, 0, i3 | 0) | 0;
                        l2 = a4 & ~(H() | 0);
                        a4 = vd(c3 | 0, a4 | 0, i3 | 0) | 0;
                        H() | 0;
                        a4 = wd(Ta(a4 & 7) | 0, 0, i3 | 0) | 0;
                        c3 = c3 & ~k | a4;
                        a4 = l2 | (H() | 0);
                        if (d2 >>> 0 < f3 >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break;
                        }
                      }
                    } else {
                      d2 = 1;
                      while (1) {
                        l2 = (15 - d2 | 0) * 3 | 0;
                        i3 = vd(c3 | 0, a4 | 0, l2 | 0) | 0;
                        H() | 0;
                        k = wd(7, 0, l2 | 0) | 0;
                        a4 = a4 & ~(H() | 0);
                        l2 = wd(Sa(i3 & 7) | 0, 0, l2 | 0) | 0;
                        c3 = c3 & ~k | l2;
                        a4 = a4 | (H() | 0);
                        if (d2 >>> 0 < f3 >>> 0) {
                          d2 = d2 + 1 | 0;
                        } else {
                          break;
                        }
                      }
                    }
                  }
                } while (0);
              if ((g2 | 0) > 0) {
                d2 = 0;
                do {
                  c3 = Gb(c3, a4) | 0;
                  a4 = H() | 0;
                  d2 = d2 + 1 | 0;
                } while ((d2 | 0) != (g2 | 0));
              }
            } else {
              c3 = 0;
              a4 = 0;
            }
          } while (0);
        k = a4;
        l2 = c3;
        G(k | 0);
        T = j;
        return l2 | 0;
      }
      function Lb(a4) {
        a4 = a4 | 0;
        return (a4 | 0) % 2 | 0 | 0;
      }
      function Mb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0;
        f3 = T;
        T = T + 16 | 0;
        e3 = f3;
        if (c3 >>> 0 > 15) {
          e3 = 4;
          T = f3;
          return e3 | 0;
        }
        if ((b2[a4 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f3;
          return e3 | 0;
        }
        if ((b2[a4 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f3;
          return e3 | 0;
        }
        hb(a4, c3, e3);
        c3 = Kb(e3, c3) | 0;
        e3 = H() | 0;
        b2[d2 >> 2] = c3;
        b2[d2 + 4 >> 2] = e3;
        if ((c3 | 0) == 0 & (e3 | 0) == 0) {
          I(23313, 22674, 786, 22697);
        }
        e3 = 0;
        T = f3;
        return e3 | 0;
      }
      function Nb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0;
        f3 = d2 + 4 | 0;
        g2 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        h = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        e3 = (g2 | 0) == 0;
        if (!(ma(h & 127) | 0)) {
          if (e3) {
            h = 0;
            return h | 0;
          }
          if ((b2[f3 >> 2] | 0) == 0 ? (b2[d2 + 8 >> 2] | 0) == 0 : 0) {
            e3 = (b2[d2 + 12 >> 2] | 0) != 0 & 1;
          } else {
            e3 = 1;
          }
        } else if (e3) {
          h = 1;
          return h | 0;
        } else {
          e3 = 1;
        }
        d2 = 1;
        while (1) {
          if (!(d2 & 1)) {
            Oa(f3);
          } else {
            Na(f3);
          }
          h = vd(a4 | 0, c3 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          H() | 0;
          Pa(f3, h & 7);
          if (d2 >>> 0 < g2 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            break;
          }
        }
        return e3 | 0;
      }
      function Ob(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0;
        l2 = T;
        T = T + 16 | 0;
        j = l2;
        k = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        k = k & 127;
        if (k >>> 0 > 121) {
          b2[d2 >> 2] = 0;
          b2[d2 + 4 >> 2] = 0;
          b2[d2 + 8 >> 2] = 0;
          b2[d2 + 12 >> 2] = 0;
          k = 5;
          T = l2;
          return k | 0;
        }
        a:
          do {
            if ((ma(k) | 0) != 0 ? (g2 = vd(a4 | 0, c3 | 0, 52) | 0, H() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
              e3 = 1;
              b:
                while (1) {
                  i3 = vd(a4 | 0, c3 | 0, (15 - e3 | 0) * 3 | 0) | 0;
                  H() | 0;
                  switch (i3 & 7) {
                    case 5:
                      break b;
                    case 0:
                      break;
                    default: {
                      e3 = c3;
                      break a;
                    }
                  }
                  if (e3 >>> 0 < g2 >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    e3 = c3;
                    break a;
                  }
                }
              f3 = 1;
              e3 = c3;
              while (1) {
                c3 = (15 - f3 | 0) * 3 | 0;
                h = wd(7, 0, c3 | 0) | 0;
                i3 = e3 & ~(H() | 0);
                e3 = vd(a4 | 0, e3 | 0, c3 | 0) | 0;
                H() | 0;
                e3 = wd(Ta(e3 & 7) | 0, 0, c3 | 0) | 0;
                a4 = a4 & ~h | e3;
                e3 = i3 | (H() | 0);
                if (f3 >>> 0 < g2 >>> 0) {
                  f3 = f3 + 1 | 0;
                } else {
                  break;
                }
              }
            } else {
              e3 = c3;
            }
          } while (0);
        i3 = 7696 + (k * 28 | 0) | 0;
        b2[d2 >> 2] = b2[i3 >> 2];
        b2[d2 + 4 >> 2] = b2[i3 + 4 >> 2];
        b2[d2 + 8 >> 2] = b2[i3 + 8 >> 2];
        b2[d2 + 12 >> 2] = b2[i3 + 12 >> 2];
        if (!(Nb(a4, e3, d2) | 0)) {
          k = 0;
          T = l2;
          return k | 0;
        }
        h = d2 + 4 | 0;
        b2[j >> 2] = b2[h >> 2];
        b2[j + 4 >> 2] = b2[h + 4 >> 2];
        b2[j + 8 >> 2] = b2[h + 8 >> 2];
        g2 = vd(a4 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i3 = g2 & 15;
        if (!(g2 & 1)) {
          g2 = i3;
        } else {
          Oa(h);
          g2 = i3 + 1 | 0;
        }
        if (!(ma(k) | 0)) {
          e3 = 0;
        } else {
          c:
            do {
              if (!i3) {
                e3 = 0;
              } else {
                c3 = 1;
                while (1) {
                  f3 = vd(a4 | 0, e3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                  H() | 0;
                  f3 = f3 & 7;
                  if (f3 | 0) {
                    e3 = f3;
                    break c;
                  }
                  if (c3 >>> 0 < i3 >>> 0) {
                    c3 = c3 + 1 | 0;
                  } else {
                    e3 = 0;
                    break;
                  }
                }
              }
            } while (0);
          e3 = (e3 | 0) == 4 & 1;
        }
        if (!(ob(d2, g2, e3, 0) | 0)) {
          if ((g2 | 0) != (i3 | 0)) {
            b2[h >> 2] = b2[j >> 2];
            b2[h + 4 >> 2] = b2[j + 4 >> 2];
            b2[h + 8 >> 2] = b2[j + 8 >> 2];
          }
        } else {
          if (ma(k) | 0) {
            do {
            } while ((ob(d2, g2, 0, 0) | 0) != 0);
          }
          if ((g2 | 0) != (i3 | 0)) {
            Ma(h);
          }
        }
        k = 0;
        T = l2;
        return k | 0;
      }
      function Pb(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0;
        f3 = T;
        T = T + 16 | 0;
        d2 = f3;
        e3 = Ob(a4, b3, d2) | 0;
        if (e3 | 0) {
          T = f3;
          return e3 | 0;
        }
        e3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        lb(d2, e3 & 15, c3);
        e3 = 0;
        T = f3;
        return e3 | 0;
      }
      function Qb(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 16 | 0;
        f3 = g2;
        d2 = Ob(a4, b3, f3) | 0;
        if (d2 | 0) {
          f3 = d2;
          T = g2;
          return f3 | 0;
        }
        d2 = vd(a4 | 0, b3 | 0, 45) | 0;
        H() | 0;
        d2 = (ma(d2 & 127) | 0) == 0;
        e3 = vd(a4 | 0, b3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a:
          do {
            if (!d2) {
              if (e3 | 0) {
                d2 = 1;
                while (1) {
                  h = wd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                  if (!((h & a4 | 0) == 0 & ((H() | 0) & b3 | 0) == 0)) {
                    break a;
                  }
                  if (d2 >>> 0 < e3 >>> 0) {
                    d2 = d2 + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              mb(f3, e3, 0, 5, c3);
              h = 0;
              T = g2;
              return h | 0;
            }
          } while (0);
        qb(f3, e3, 0, 6, c3);
        h = 0;
        T = g2;
        return h | 0;
      }
      function Rb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        f3 = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        if (!(ma(f3 & 127) | 0)) {
          f3 = 2;
          b2[d2 >> 2] = f3;
          return 0;
        }
        f3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f3 = f3 & 15;
        if (!f3) {
          f3 = 5;
          b2[d2 >> 2] = f3;
          return 0;
        }
        e3 = 1;
        while (1) {
          g2 = wd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
          if (!((g2 & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
            e3 = 2;
            a4 = 6;
            break;
          }
          if (e3 >>> 0 < f3 >>> 0) {
            e3 = e3 + 1 | 0;
          } else {
            e3 = 5;
            a4 = 6;
            break;
          }
        }
        if ((a4 | 0) == 6) {
          b2[d2 >> 2] = e3;
          return 0;
        }
        return 0;
      }
      function Sb(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        m = T;
        T = T + 128 | 0;
        k = m + 112 | 0;
        g2 = m + 96 | 0;
        l2 = m;
        f3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        i3 = f3 & 15;
        b2[k >> 2] = i3;
        h = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        h = h & 127;
        a:
          do {
            if (ma(h) | 0) {
              if (i3 | 0) {
                e3 = 1;
                while (1) {
                  j = wd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                  if (!((j & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                    f3 = 0;
                    break a;
                  }
                  if (e3 >>> 0 < i3 >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if (!(f3 & 1)) {
                j = wd(i3 + 1 | 0, 0, 52) | 0;
                l2 = H() | 0 | c3 & -15728641;
                k = wd(7, 0, (14 - i3 | 0) * 3 | 0) | 0;
                l2 = Sb((j | a4) & ~k, l2 & ~(H() | 0), d2) | 0;
                T = m;
                return l2 | 0;
              } else {
                f3 = 1;
              }
            } else {
              f3 = 0;
            }
          } while (0);
        e3 = Ob(a4, c3, g2) | 0;
        if (!e3) {
          if (f3) {
            nb(g2, k, l2);
            j = 5;
          } else {
            rb(g2, k, l2);
            j = 6;
          }
          b:
            do {
              if (ma(h) | 0) {
                if (!i3) {
                  a4 = 5;
                } else {
                  e3 = 1;
                  while (1) {
                    h = wd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                    if (!((h & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                      a4 = 2;
                      break b;
                    }
                    if (e3 >>> 0 < i3 >>> 0) {
                      e3 = e3 + 1 | 0;
                    } else {
                      a4 = 5;
                      break;
                    }
                  }
                }
              } else {
                a4 = 2;
              }
            } while (0);
          Bd(d2 | 0, -1, a4 << 2 | 0) | 0;
          c:
            do {
              if (f3) {
                g2 = 0;
                while (1) {
                  h = l2 + (g2 << 4) | 0;
                  pb(h, b2[k >> 2] | 0) | 0;
                  h = b2[h >> 2] | 0;
                  i3 = b2[d2 >> 2] | 0;
                  if ((i3 | 0) == -1 | (i3 | 0) == (h | 0)) {
                    e3 = d2;
                  } else {
                    f3 = 0;
                    do {
                      f3 = f3 + 1 | 0;
                      if (f3 >>> 0 >= a4 >>> 0) {
                        e3 = 1;
                        break c;
                      }
                      e3 = d2 + (f3 << 2) | 0;
                      i3 = b2[e3 >> 2] | 0;
                    } while (!((i3 | 0) == -1 | (i3 | 0) == (h | 0)));
                  }
                  b2[e3 >> 2] = h;
                  g2 = g2 + 1 | 0;
                  if (g2 >>> 0 >= j >>> 0) {
                    e3 = 0;
                    break;
                  }
                }
              } else {
                g2 = 0;
                while (1) {
                  h = l2 + (g2 << 4) | 0;
                  ob(h, b2[k >> 2] | 0, 0, 1) | 0;
                  h = b2[h >> 2] | 0;
                  i3 = b2[d2 >> 2] | 0;
                  if ((i3 | 0) == -1 | (i3 | 0) == (h | 0)) {
                    e3 = d2;
                  } else {
                    f3 = 0;
                    do {
                      f3 = f3 + 1 | 0;
                      if (f3 >>> 0 >= a4 >>> 0) {
                        e3 = 1;
                        break c;
                      }
                      e3 = d2 + (f3 << 2) | 0;
                      i3 = b2[e3 >> 2] | 0;
                    } while (!((i3 | 0) == -1 | (i3 | 0) == (h | 0)));
                  }
                  b2[e3 >> 2] = h;
                  g2 = g2 + 1 | 0;
                  if (g2 >>> 0 >= j >>> 0) {
                    e3 = 0;
                    break;
                  }
                }
              }
            } while (0);
        }
        l2 = e3;
        T = m;
        return l2 | 0;
      }
      function Tb() {
        return 12;
      }
      function Ub(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        if (a4 >>> 0 > 15) {
          i3 = 4;
          return i3 | 0;
        }
        wd(a4 | 0, 0, 52) | 0;
        i3 = H() | 0 | 134225919;
        if (!a4) {
          d2 = 0;
          e3 = 0;
          do {
            if (ma(e3) | 0) {
              wd(e3 | 0, 0, 45) | 0;
              h = i3 | (H() | 0);
              a4 = c3 + (d2 << 3) | 0;
              b2[a4 >> 2] = -1;
              b2[a4 + 4 >> 2] = h;
              d2 = d2 + 1 | 0;
            }
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) != 122);
          d2 = 0;
          return d2 | 0;
        }
        d2 = 0;
        h = 0;
        do {
          if (ma(h) | 0) {
            wd(h | 0, 0, 45) | 0;
            e3 = 1;
            f3 = -1;
            g2 = i3 | (H() | 0);
            while (1) {
              j = wd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
              f3 = f3 & ~j;
              g2 = g2 & ~(H() | 0);
              if ((e3 | 0) == (a4 | 0)) {
                break;
              } else {
                e3 = e3 + 1 | 0;
              }
            }
            j = c3 + (d2 << 3) | 0;
            b2[j >> 2] = f3;
            b2[j + 4 >> 2] = g2;
            d2 = d2 + 1 | 0;
          }
          h = h + 1 | 0;
        } while ((h | 0) != 122);
        d2 = 0;
        return d2 | 0;
      }
      function Vb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0;
        t3 = T;
        T = T + 16 | 0;
        r3 = t3;
        s3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        s3 = s3 & 15;
        if (d2 >>> 0 > 15) {
          s3 = 4;
          T = t3;
          return s3 | 0;
        }
        if ((s3 | 0) < (d2 | 0)) {
          s3 = 12;
          T = t3;
          return s3 | 0;
        }
        if ((s3 | 0) != (d2 | 0)) {
          g2 = wd(d2 | 0, 0, 52) | 0;
          g2 = g2 | a4;
          i3 = H() | 0 | c3 & -15728641;
          if ((s3 | 0) > (d2 | 0)) {
            j = d2;
            do {
              q2 = wd(7, 0, (14 - j | 0) * 3 | 0) | 0;
              j = j + 1 | 0;
              g2 = q2 | g2;
              i3 = H() | 0 | i3;
            } while ((j | 0) < (s3 | 0));
            q2 = g2;
          } else {
            q2 = g2;
          }
        } else {
          q2 = a4;
          i3 = c3;
        }
        p3 = vd(q2 | 0, i3 | 0, 45) | 0;
        H() | 0;
        a:
          do {
            if (ma(p3 & 127) | 0) {
              j = vd(q2 | 0, i3 | 0, 52) | 0;
              H() | 0;
              j = j & 15;
              if (j | 0) {
                g2 = 1;
                while (1) {
                  p3 = wd(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                  if (!((p3 & q2 | 0) == 0 & ((H() | 0) & i3 | 0) == 0)) {
                    k = 33;
                    break a;
                  }
                  if (g2 >>> 0 < j >>> 0) {
                    g2 = g2 + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              p3 = e3;
              b2[p3 >> 2] = 0;
              b2[p3 + 4 >> 2] = 0;
              if ((s3 | 0) > (d2 | 0)) {
                p3 = c3 & -15728641;
                o2 = s3;
                while (1) {
                  n2 = o2;
                  o2 = o2 + -1 | 0;
                  if (o2 >>> 0 > 15 | (s3 | 0) < (o2 | 0)) {
                    k = 19;
                    break;
                  }
                  if ((s3 | 0) != (o2 | 0)) {
                    g2 = wd(o2 | 0, 0, 52) | 0;
                    g2 = g2 | a4;
                    j = H() | 0 | p3;
                    if ((s3 | 0) < (n2 | 0)) {
                      m = g2;
                    } else {
                      k = o2;
                      do {
                        m = wd(7, 0, (14 - k | 0) * 3 | 0) | 0;
                        k = k + 1 | 0;
                        g2 = m | g2;
                        j = H() | 0 | j;
                      } while ((k | 0) < (s3 | 0));
                      m = g2;
                    }
                  } else {
                    m = a4;
                    j = c3;
                  }
                  l2 = vd(m | 0, j | 0, 45) | 0;
                  H() | 0;
                  if (!(ma(l2 & 127) | 0)) {
                    g2 = 0;
                  } else {
                    l2 = vd(m | 0, j | 0, 52) | 0;
                    H() | 0;
                    l2 = l2 & 15;
                    b:
                      do {
                        if (!l2) {
                          g2 = 0;
                        } else {
                          k = 1;
                          while (1) {
                            g2 = vd(m | 0, j | 0, (15 - k | 0) * 3 | 0) | 0;
                            H() | 0;
                            g2 = g2 & 7;
                            if (g2 | 0) {
                              break b;
                            }
                            if (k >>> 0 < l2 >>> 0) {
                              k = k + 1 | 0;
                            } else {
                              g2 = 0;
                              break;
                            }
                          }
                        }
                      } while (0);
                    g2 = (g2 | 0) == 0 & 1;
                  }
                  j = vd(a4 | 0, c3 | 0, (15 - n2 | 0) * 3 | 0) | 0;
                  H() | 0;
                  j = j & 7;
                  if ((j | 0) == 7) {
                    f3 = 5;
                    k = 42;
                    break;
                  }
                  g2 = (g2 | 0) != 0;
                  if ((j | 0) == 1 & g2) {
                    f3 = 5;
                    k = 42;
                    break;
                  }
                  m = j + (((j | 0) != 0 & g2) << 31 >> 31) | 0;
                  if (m | 0) {
                    k = s3 - n2 | 0;
                    k = Cc(7, 0, k, ((k | 0) < 0) << 31 >> 31) | 0;
                    l2 = H() | 0;
                    if (g2) {
                      g2 = rd(k | 0, l2 | 0, 5, 0) | 0;
                      g2 = ld(g2 | 0, H() | 0, -5, -1) | 0;
                      g2 = pd(g2 | 0, H() | 0, 6, 0) | 0;
                      g2 = ld(g2 | 0, H() | 0, 1, 0) | 0;
                      j = H() | 0;
                    } else {
                      g2 = k;
                      j = l2;
                    }
                    n2 = m + -1 | 0;
                    n2 = rd(k | 0, l2 | 0, n2 | 0, ((n2 | 0) < 0) << 31 >> 31 | 0) | 0;
                    n2 = ld(g2 | 0, j | 0, n2 | 0, H() | 0) | 0;
                    m = H() | 0;
                    l2 = e3;
                    l2 = ld(n2 | 0, m | 0, b2[l2 >> 2] | 0, b2[l2 + 4 >> 2] | 0) | 0;
                    m = H() | 0;
                    n2 = e3;
                    b2[n2 >> 2] = l2;
                    b2[n2 + 4 >> 2] = m;
                  }
                  if ((o2 | 0) <= (d2 | 0)) {
                    k = 37;
                    break;
                  }
                }
                if ((k | 0) == 19) {
                  I(23313, 22674, 1099, 22710);
                } else if ((k | 0) == 37) {
                  h = e3;
                  f3 = b2[h + 4 >> 2] | 0;
                  h = b2[h >> 2] | 0;
                  break;
                } else if ((k | 0) == 42) {
                  T = t3;
                  return f3 | 0;
                }
              } else {
                f3 = 0;
                h = 0;
              }
            } else {
              k = 33;
            }
          } while (0);
        c:
          do {
            if ((k | 0) == 33) {
              p3 = e3;
              b2[p3 >> 2] = 0;
              b2[p3 + 4 >> 2] = 0;
              if ((s3 | 0) > (d2 | 0)) {
                g2 = s3;
                while (1) {
                  f3 = vd(a4 | 0, c3 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                  H() | 0;
                  f3 = f3 & 7;
                  if ((f3 | 0) == 7) {
                    f3 = 5;
                    break;
                  }
                  h = s3 - g2 | 0;
                  h = Cc(7, 0, h, ((h | 0) < 0) << 31 >> 31) | 0;
                  f3 = rd(h | 0, H() | 0, f3 | 0, 0) | 0;
                  h = H() | 0;
                  p3 = e3;
                  h = ld(b2[p3 >> 2] | 0, b2[p3 + 4 >> 2] | 0, f3 | 0, h | 0) | 0;
                  f3 = H() | 0;
                  p3 = e3;
                  b2[p3 >> 2] = h;
                  b2[p3 + 4 >> 2] = f3;
                  g2 = g2 + -1 | 0;
                  if ((g2 | 0) <= (d2 | 0)) {
                    break c;
                  }
                }
                T = t3;
                return f3 | 0;
              } else {
                f3 = 0;
                h = 0;
              }
            }
          } while (0);
        if (wb(q2, i3, s3, r3) | 0) {
          I(23313, 22674, 1063, 22725);
        }
        s3 = r3;
        r3 = b2[s3 + 4 >> 2] | 0;
        if (((f3 | 0) > -1 | (f3 | 0) == -1 & h >>> 0 > 4294967295) & ((r3 | 0) > (f3 | 0) | ((r3 | 0) == (f3 | 0) ? (b2[s3 >> 2] | 0) >>> 0 > h >>> 0 : 0))) {
          s3 = 0;
          T = t3;
          return s3 | 0;
        } else {
          I(23313, 22674, 1139, 22710);
        }
        return 0;
      }
      function Wb(a4, c3, d2, e3, f3, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0;
        m = T;
        T = T + 16 | 0;
        h = m;
        if (f3 >>> 0 > 15) {
          g2 = 4;
          T = m;
          return g2 | 0;
        }
        i3 = vd(d2 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i3 = i3 & 15;
        if ((i3 | 0) > (f3 | 0)) {
          g2 = 12;
          T = m;
          return g2 | 0;
        }
        if (wb(d2, e3, f3, h) | 0) {
          I(23313, 22674, 1063, 22725);
        }
        l2 = h;
        k = b2[l2 + 4 >> 2] | 0;
        if (!(((c3 | 0) > -1 | (c3 | 0) == -1 & a4 >>> 0 > 4294967295) & ((k | 0) > (c3 | 0) | ((k | 0) == (c3 | 0) ? (b2[l2 >> 2] | 0) >>> 0 > a4 >>> 0 : 0)))) {
          g2 = 2;
          T = m;
          return g2 | 0;
        }
        l2 = f3 - i3 | 0;
        f3 = wd(f3 | 0, 0, 52) | 0;
        j = H() | 0 | e3 & -15728641;
        k = g2;
        b2[k >> 2] = f3 | d2;
        b2[k + 4 >> 2] = j;
        k = vd(d2 | 0, e3 | 0, 45) | 0;
        H() | 0;
        a:
          do {
            if (ma(k & 127) | 0) {
              if (i3 | 0) {
                h = 1;
                while (1) {
                  k = wd(7, 0, (15 - h | 0) * 3 | 0) | 0;
                  if (!((k & d2 | 0) == 0 & ((H() | 0) & e3 | 0) == 0)) {
                    break a;
                  }
                  if (h >>> 0 < i3 >>> 0) {
                    h = h + 1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if ((l2 | 0) < 1) {
                g2 = 0;
                T = m;
                return g2 | 0;
              }
              k = i3 ^ 15;
              e3 = -1;
              j = 1;
              h = 1;
              while (1) {
                i3 = l2 - j | 0;
                i3 = Cc(7, 0, i3, ((i3 | 0) < 0) << 31 >> 31) | 0;
                d2 = H() | 0;
                do {
                  if (h) {
                    h = rd(i3 | 0, d2 | 0, 5, 0) | 0;
                    h = ld(h | 0, H() | 0, -5, -1) | 0;
                    h = pd(h | 0, H() | 0, 6, 0) | 0;
                    f3 = H() | 0;
                    if ((c3 | 0) > (f3 | 0) | (c3 | 0) == (f3 | 0) & a4 >>> 0 > h >>> 0) {
                      c3 = ld(a4 | 0, c3 | 0, -1, -1) | 0;
                      c3 = md(c3 | 0, H() | 0, h | 0, f3 | 0) | 0;
                      h = H() | 0;
                      n2 = g2;
                      p3 = b2[n2 >> 2] | 0;
                      n2 = b2[n2 + 4 >> 2] | 0;
                      q2 = (k + e3 | 0) * 3 | 0;
                      o2 = wd(7, 0, q2 | 0) | 0;
                      n2 = n2 & ~(H() | 0);
                      e3 = pd(c3 | 0, h | 0, i3 | 0, d2 | 0) | 0;
                      a4 = H() | 0;
                      f3 = ld(e3 | 0, a4 | 0, 2, 0) | 0;
                      q2 = wd(f3 | 0, H() | 0, q2 | 0) | 0;
                      n2 = H() | 0 | n2;
                      f3 = g2;
                      b2[f3 >> 2] = q2 | p3 & ~o2;
                      b2[f3 + 4 >> 2] = n2;
                      a4 = rd(e3 | 0, a4 | 0, i3 | 0, d2 | 0) | 0;
                      a4 = md(c3 | 0, h | 0, a4 | 0, H() | 0) | 0;
                      h = 0;
                      c3 = H() | 0;
                      break;
                    } else {
                      q2 = g2;
                      o2 = b2[q2 >> 2] | 0;
                      q2 = b2[q2 + 4 >> 2] | 0;
                      p3 = wd(7, 0, (k + e3 | 0) * 3 | 0) | 0;
                      q2 = q2 & ~(H() | 0);
                      h = g2;
                      b2[h >> 2] = o2 & ~p3;
                      b2[h + 4 >> 2] = q2;
                      h = 1;
                      break;
                    }
                  } else {
                    o2 = g2;
                    f3 = b2[o2 >> 2] | 0;
                    o2 = b2[o2 + 4 >> 2] | 0;
                    e3 = (k + e3 | 0) * 3 | 0;
                    n2 = wd(7, 0, e3 | 0) | 0;
                    o2 = o2 & ~(H() | 0);
                    q2 = pd(a4 | 0, c3 | 0, i3 | 0, d2 | 0) | 0;
                    h = H() | 0;
                    e3 = wd(q2 | 0, h | 0, e3 | 0) | 0;
                    o2 = H() | 0 | o2;
                    p3 = g2;
                    b2[p3 >> 2] = e3 | f3 & ~n2;
                    b2[p3 + 4 >> 2] = o2;
                    h = rd(q2 | 0, h | 0, i3 | 0, d2 | 0) | 0;
                    a4 = md(a4 | 0, c3 | 0, h | 0, H() | 0) | 0;
                    h = 0;
                    c3 = H() | 0;
                  }
                } while (0);
                if ((l2 | 0) > (j | 0)) {
                  e3 = ~j;
                  j = j + 1 | 0;
                } else {
                  c3 = 0;
                  break;
                }
              }
              T = m;
              return c3 | 0;
            }
          } while (0);
        if ((l2 | 0) < 1) {
          q2 = 0;
          T = m;
          return q2 | 0;
        }
        f3 = i3 ^ 15;
        h = 1;
        while (1) {
          p3 = l2 - h | 0;
          p3 = Cc(7, 0, p3, ((p3 | 0) < 0) << 31 >> 31) | 0;
          q2 = H() | 0;
          j = g2;
          d2 = b2[j >> 2] | 0;
          j = b2[j + 4 >> 2] | 0;
          i3 = (f3 - h | 0) * 3 | 0;
          e3 = wd(7, 0, i3 | 0) | 0;
          j = j & ~(H() | 0);
          n2 = pd(a4 | 0, c3 | 0, p3 | 0, q2 | 0) | 0;
          o2 = H() | 0;
          i3 = wd(n2 | 0, o2 | 0, i3 | 0) | 0;
          j = H() | 0 | j;
          k = g2;
          b2[k >> 2] = i3 | d2 & ~e3;
          b2[k + 4 >> 2] = j;
          q2 = rd(n2 | 0, o2 | 0, p3 | 0, q2 | 0) | 0;
          a4 = md(a4 | 0, c3 | 0, q2 | 0, H() | 0) | 0;
          c3 = H() | 0;
          if ((l2 | 0) <= (h | 0)) {
            c3 = 0;
            break;
          } else {
            h = h + 1 | 0;
          }
        }
        T = m;
        return c3 | 0;
      }
      function Xb(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0;
        f3 = vd(c3 | 0, d2 | 0, 52) | 0;
        H() | 0;
        f3 = f3 & 15;
        if ((c3 | 0) == 0 & (d2 | 0) == 0 | ((e3 | 0) > 15 | (f3 | 0) > (e3 | 0))) {
          e3 = -1;
          f3 = -1;
          c3 = 0;
          d2 = 0;
        } else {
          g2 = zb(c3, d2, f3 + 1 | 0, e3) | 0;
          d2 = (H() | 0) & -15728641;
          c3 = wd(e3 | 0, 0, 52) | 0;
          c3 = g2 | c3;
          d2 = d2 | (H() | 0);
          g2 = (xb(c3, d2) | 0) == 0;
          e3 = g2 ? -1 : e3;
        }
        g2 = a4;
        b2[g2 >> 2] = c3;
        b2[g2 + 4 >> 2] = d2;
        b2[a4 + 8 >> 2] = f3;
        b2[a4 + 12 >> 2] = e3;
        return;
      }
      function Yb(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        d2 = a4;
        c3 = b2[d2 >> 2] | 0;
        d2 = b2[d2 + 4 >> 2] | 0;
        if ((c3 | 0) == 0 & (d2 | 0) == 0) {
          return;
        }
        e3 = vd(c3 | 0, d2 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        i3 = wd(1, 0, (e3 ^ 15) * 3 | 0) | 0;
        c3 = ld(i3 | 0, H() | 0, c3 | 0, d2 | 0) | 0;
        d2 = H() | 0;
        i3 = a4;
        b2[i3 >> 2] = c3;
        b2[i3 + 4 >> 2] = d2;
        i3 = a4 + 8 | 0;
        h = b2[i3 >> 2] | 0;
        if ((e3 | 0) < (h | 0)) {
          return;
        }
        j = a4 + 12 | 0;
        g2 = e3;
        while (1) {
          if ((g2 | 0) == (h | 0)) {
            e3 = 5;
            break;
          }
          k = (g2 | 0) == (b2[j >> 2] | 0);
          f3 = (15 - g2 | 0) * 3 | 0;
          e3 = vd(c3 | 0, d2 | 0, f3 | 0) | 0;
          H() | 0;
          e3 = e3 & 7;
          if (k & ((e3 | 0) == 1 & true)) {
            e3 = 7;
            break;
          }
          if (!((e3 | 0) == 7 & true)) {
            e3 = 10;
            break;
          }
          k = wd(1, 0, f3 | 0) | 0;
          c3 = ld(c3 | 0, d2 | 0, k | 0, H() | 0) | 0;
          d2 = H() | 0;
          k = a4;
          b2[k >> 2] = c3;
          b2[k + 4 >> 2] = d2;
          if ((g2 | 0) > (h | 0)) {
            g2 = g2 + -1 | 0;
          } else {
            e3 = 10;
            break;
          }
        }
        if ((e3 | 0) == 5) {
          k = a4;
          b2[k >> 2] = 0;
          b2[k + 4 >> 2] = 0;
          b2[i3 >> 2] = -1;
          b2[j >> 2] = -1;
          return;
        } else if ((e3 | 0) == 7) {
          h = wd(1, 0, f3 | 0) | 0;
          h = ld(c3 | 0, d2 | 0, h | 0, H() | 0) | 0;
          i3 = H() | 0;
          k = a4;
          b2[k >> 2] = h;
          b2[k + 4 >> 2] = i3;
          b2[j >> 2] = g2 + -1;
          return;
        } else if ((e3 | 0) == 10) {
          return;
        }
      }
      function Zb(a4) {
        a4 = +a4;
        var b3 = 0;
        b3 = a4 < 0 ? a4 + 6.283185307179586 : a4;
        return +(!(a4 >= 6.283185307179586) ? b3 : b3 + -6.283185307179586);
      }
      function _b(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (!(+q(+(+e2[a4 >> 3] - +e2[b3 >> 3])) < 17453292519943298e-27)) {
          b3 = 0;
          return b3 | 0;
        }
        b3 = +q(+(+e2[a4 + 8 >> 3] - +e2[b3 + 8 >> 3])) < 17453292519943298e-27;
        return b3 | 0;
      }
      function $b(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0;
        f3 = +e2[b3 >> 3];
        d2 = +e2[a4 >> 3];
        g2 = +u(+((f3 - d2) * 0.5));
        c3 = +u(+((+e2[b3 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t2(+f3) * +t2(+d2) * c3);
        return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2);
      }
      function ac(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0;
        f3 = +e2[b3 >> 3];
        d2 = +e2[a4 >> 3];
        g2 = +u(+((f3 - d2) * 0.5));
        c3 = +u(+((+e2[b3 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t2(+f3) * +t2(+d2) * c3);
        return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2 * 6371.007180918475);
      }
      function bc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0;
        f3 = +e2[b3 >> 3];
        d2 = +e2[a4 >> 3];
        g2 = +u(+((f3 - d2) * 0.5));
        c3 = +u(+((+e2[b3 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t2(+f3) * +t2(+d2) * c3);
        return +(+z(+ +r2(+c3), + +r2(+(1 - c3))) * 2 * 6371.007180918475 * 1e3);
      }
      function cc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0, h = 0;
        g2 = +e2[b3 >> 3];
        d2 = +t2(+g2);
        f3 = +e2[b3 + 8 >> 3] - +e2[a4 + 8 >> 3];
        h = d2 * +u(+f3);
        c3 = +e2[a4 >> 3];
        return + +z(+h, +(+u(+g2) * +t2(+c3) - +t2(+f3) * (d2 * +u(+c3))));
      }
      function dc(a4, c3, d2, f3) {
        a4 = a4 | 0;
        c3 = +c3;
        d2 = +d2;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0;
        if (d2 < 1e-16) {
          b2[f3 >> 2] = b2[a4 >> 2];
          b2[f3 + 4 >> 2] = b2[a4 + 4 >> 2];
          b2[f3 + 8 >> 2] = b2[a4 + 8 >> 2];
          b2[f3 + 12 >> 2] = b2[a4 + 12 >> 2];
          return;
        }
        h = c3 < 0 ? c3 + 6.283185307179586 : c3;
        h = !(c3 >= 6.283185307179586) ? h : h + -6.283185307179586;
        do {
          if (h < 1e-16) {
            c3 = +e2[a4 >> 3] + d2;
            e2[f3 >> 3] = c3;
            g2 = f3;
          } else {
            g2 = +q(+(h + -3.141592653589793)) < 1e-16;
            c3 = +e2[a4 >> 3];
            if (g2) {
              c3 = c3 - d2;
              e2[f3 >> 3] = c3;
              g2 = f3;
              break;
            }
            i3 = +t2(+d2);
            d2 = +u(+d2);
            c3 = i3 * +u(+c3) + +t2(+h) * (d2 * +t2(+c3));
            c3 = c3 > 1 ? 1 : c3;
            c3 = +x2(+(c3 < -1 ? -1 : c3));
            e2[f3 >> 3] = c3;
            if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
              e2[f3 >> 3] = 1.5707963267948966;
              e2[f3 + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
              e2[f3 >> 3] = -1.5707963267948966;
              e2[f3 + 8 >> 3] = 0;
              return;
            }
            j = +t2(+c3);
            h = d2 * +u(+h) / j;
            d2 = +e2[a4 >> 3];
            c3 = (i3 - +u(+c3) * +u(+d2)) / +t2(+d2) / j;
            i3 = h > 1 ? 1 : h;
            c3 = c3 > 1 ? 1 : c3;
            c3 = +e2[a4 + 8 >> 3] + +z(+(i3 < -1 ? -1 : i3), +(c3 < -1 ? -1 : c3));
            if (c3 > 3.141592653589793) {
              do {
                c3 = c3 + -6.283185307179586;
              } while (c3 > 3.141592653589793);
            }
            if (c3 < -3.141592653589793) {
              do {
                c3 = c3 + 6.283185307179586;
              } while (c3 < -3.141592653589793);
            }
            e2[f3 + 8 >> 3] = c3;
            return;
          }
        } while (0);
        if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = 1.5707963267948966;
          e2[f3 + 8 >> 3] = 0;
          return;
        }
        if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = -1.5707963267948966;
          e2[f3 + 8 >> 3] = 0;
          return;
        }
        c3 = +e2[a4 + 8 >> 3];
        if (c3 > 3.141592653589793) {
          do {
            c3 = c3 + -6.283185307179586;
          } while (c3 > 3.141592653589793);
        }
        if (c3 < -3.141592653589793) {
          do {
            c3 = c3 + 6.283185307179586;
          } while (c3 < -3.141592653589793);
        }
        e2[f3 + 8 >> 3] = c3;
        return;
      }
      function ec(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (a4 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20528 + (a4 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function fc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (a4 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20656 + (a4 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function gc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (a4 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20784 + (a4 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function hc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (a4 >>> 0 > 15) {
          b3 = 4;
          return b3 | 0;
        }
        e2[b3 >> 3] = +e2[20912 + (a4 << 3) >> 3];
        b3 = 0;
        return b3 | 0;
      }
      function ic(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        if (a4 >>> 0 > 15) {
          c3 = 4;
          return c3 | 0;
        }
        d2 = Cc(7, 0, a4, ((a4 | 0) < 0) << 31 >> 31) | 0;
        d2 = rd(d2 | 0, H() | 0, 120, 0) | 0;
        a4 = H() | 0;
        b2[c3 >> 2] = d2 | 2;
        b2[c3 + 4 >> 2] = a4;
        c3 = 0;
        return c3 | 0;
      }
      function jc(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
        n2 = +e2[b3 >> 3];
        l2 = +e2[a4 >> 3];
        j = +u(+((n2 - l2) * 0.5));
        g2 = +e2[b3 + 8 >> 3];
        k = +e2[a4 + 8 >> 3];
        h = +u(+((g2 - k) * 0.5));
        i3 = +t2(+l2);
        m = +t2(+n2);
        h = j * j + h * (m * i3 * h);
        h = +z(+ +r2(+h), + +r2(+(1 - h))) * 2;
        j = +e2[c3 >> 3];
        n2 = +u(+((j - n2) * 0.5));
        d2 = +e2[c3 + 8 >> 3];
        g2 = +u(+((d2 - g2) * 0.5));
        f3 = +t2(+j);
        g2 = n2 * n2 + g2 * (m * f3 * g2);
        g2 = +z(+ +r2(+g2), + +r2(+(1 - g2))) * 2;
        j = +u(+((l2 - j) * 0.5));
        d2 = +u(+((k - d2) * 0.5));
        d2 = j * j + d2 * (i3 * f3 * d2);
        d2 = +z(+ +r2(+d2), + +r2(+(1 - d2))) * 2;
        f3 = (h + g2 + d2) * 0.5;
        return +(+y2(+ +r2(+(+v(+(f3 * 0.5)) * +v(+((f3 - h) * 0.5)) * +v(+((f3 - g2) * 0.5)) * +v(+((f3 - d2) * 0.5))))) * 4);
      }
      function kc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        h = j + 168 | 0;
        i3 = j;
        g2 = Pb(a4, c3, h) | 0;
        if (g2 | 0) {
          d2 = g2;
          T = j;
          return d2 | 0;
        }
        if (Qb(a4, c3, i3) | 0) {
          I(23313, 22742, 386, 22751);
        }
        c3 = b2[i3 >> 2] | 0;
        if ((c3 | 0) > 0) {
          f3 = +jc(i3 + 8 | 0, i3 + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, h) + 0;
          if ((c3 | 0) != 1) {
            a4 = 1;
            do {
              g2 = a4;
              a4 = a4 + 1 | 0;
              f3 = f3 + +jc(i3 + 8 + (g2 << 4) | 0, i3 + 8 + (((a4 | 0) % (c3 | 0) | 0) << 4) | 0, h);
            } while ((a4 | 0) < (c3 | 0));
          }
        } else {
          f3 = 0;
        }
        e2[d2 >> 3] = f3;
        d2 = 0;
        T = j;
        return d2 | 0;
      }
      function lc(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        a4 = kc(a4, b3, c3) | 0;
        if (a4 | 0) {
          return a4 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475;
        return a4 | 0;
      }
      function mc(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        a4 = kc(a4, b3, c3) | 0;
        if (a4 | 0) {
          return a4 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3;
        return a4 | 0;
      }
      function nc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i3 = j;
        a4 = gb(a4, c3, i3) | 0;
        if (a4 | 0) {
          i3 = a4;
          T = j;
          return i3 | 0;
        }
        e2[d2 >> 3] = 0;
        a4 = b2[i3 >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i3 = 0;
          T = j;
          return i3 | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f3 = +e2[i3 + 8 >> 3];
        g2 = +e2[i3 + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l2 = f3;
          f3 = +e2[i3 + 8 + (a4 << 4) >> 3];
          m = +u(+((f3 - l2) * 0.5));
          k = g2;
          g2 = +e2[i3 + 8 + (a4 << 4) + 8 >> 3];
          k = +u(+((g2 - k) * 0.5));
          k = m * m + k * (+t2(+f3) * +t2(+l2) * k);
          h = h + +z(+ +r2(+k), + +r2(+(1 - k))) * 2;
        } while ((a4 | 0) < (c3 | 0));
        e2[d2 >> 3] = h;
        i3 = 0;
        T = j;
        return i3 | 0;
      }
      function oc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i3 = j;
        a4 = gb(a4, c3, i3) | 0;
        if (a4 | 0) {
          i3 = a4;
          h = +e2[d2 >> 3];
          h = h * 6371.007180918475;
          e2[d2 >> 3] = h;
          T = j;
          return i3 | 0;
        }
        e2[d2 >> 3] = 0;
        a4 = b2[i3 >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i3 = 0;
          h = 0;
          h = h * 6371.007180918475;
          e2[d2 >> 3] = h;
          T = j;
          return i3 | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f3 = +e2[i3 + 8 >> 3];
        g2 = +e2[i3 + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l2 = f3;
          f3 = +e2[i3 + 8 + (a4 << 4) >> 3];
          m = +u(+((f3 - l2) * 0.5));
          k = g2;
          g2 = +e2[i3 + 8 + (a4 << 4) + 8 >> 3];
          k = +u(+((g2 - k) * 0.5));
          k = m * m + k * (+t2(+l2) * +t2(+f3) * k);
          h = h + +z(+ +r2(+k), + +r2(+(1 - k))) * 2;
        } while ((a4 | 0) != (c3 | 0));
        e2[d2 >> 3] = h;
        i3 = 0;
        m = h;
        m = m * 6371.007180918475;
        e2[d2 >> 3] = m;
        T = j;
        return i3 | 0;
      }
      function pc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i3 = j;
        a4 = gb(a4, c3, i3) | 0;
        if (a4 | 0) {
          i3 = a4;
          h = +e2[d2 >> 3];
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d2 >> 3] = h;
          T = j;
          return i3 | 0;
        }
        e2[d2 >> 3] = 0;
        a4 = b2[i3 >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i3 = 0;
          h = 0;
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d2 >> 3] = h;
          T = j;
          return i3 | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f3 = +e2[i3 + 8 >> 3];
        g2 = +e2[i3 + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l2 = f3;
          f3 = +e2[i3 + 8 + (a4 << 4) >> 3];
          m = +u(+((f3 - l2) * 0.5));
          k = g2;
          g2 = +e2[i3 + 8 + (a4 << 4) + 8 >> 3];
          k = +u(+((g2 - k) * 0.5));
          k = m * m + k * (+t2(+l2) * +t2(+f3) * k);
          h = h + +z(+ +r2(+k), + +r2(+(1 - k))) * 2;
        } while ((a4 | 0) != (c3 | 0));
        e2[d2 >> 3] = h;
        i3 = 0;
        m = h;
        m = m * 6371.007180918475;
        m = m * 1e3;
        e2[d2 >> 3] = m;
        T = j;
        return i3 | 0;
      }
      function qc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        c3 = kd(1, 12) | 0;
        if (!c3) {
          I(22832, 22787, 49, 22845);
        }
        d2 = a4 + 4 | 0;
        e3 = b2[d2 >> 2] | 0;
        if (e3 | 0) {
          e3 = e3 + 8 | 0;
          b2[e3 >> 2] = c3;
          b2[d2 >> 2] = c3;
          return c3 | 0;
        }
        if (b2[a4 >> 2] | 0) {
          I(22862, 22787, 61, 22885);
        }
        e3 = a4;
        b2[e3 >> 2] = c3;
        b2[d2 >> 2] = c3;
        return c3 | 0;
      }
      function rc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0;
        e3 = id(24) | 0;
        if (!e3) {
          I(22899, 22787, 78, 22913);
        }
        b2[e3 >> 2] = b2[c3 >> 2];
        b2[e3 + 4 >> 2] = b2[c3 + 4 >> 2];
        b2[e3 + 8 >> 2] = b2[c3 + 8 >> 2];
        b2[e3 + 12 >> 2] = b2[c3 + 12 >> 2];
        b2[e3 + 16 >> 2] = 0;
        c3 = a4 + 4 | 0;
        d2 = b2[c3 >> 2] | 0;
        if (d2 | 0) {
          b2[d2 + 16 >> 2] = e3;
          b2[c3 >> 2] = e3;
          return e3 | 0;
        }
        if (b2[a4 >> 2] | 0) {
          I(22928, 22787, 82, 22913);
        }
        b2[a4 >> 2] = e3;
        b2[c3 >> 2] = e3;
        return e3 | 0;
      }
      function sc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0;
        if (!a4) {
          return;
        }
        e3 = 1;
        while (1) {
          c3 = b2[a4 >> 2] | 0;
          if (c3 | 0) {
            do {
              d2 = b2[c3 >> 2] | 0;
              if (d2 | 0) {
                do {
                  f3 = d2;
                  d2 = b2[d2 + 16 >> 2] | 0;
                  jd(f3);
                } while ((d2 | 0) != 0);
              }
              f3 = c3;
              c3 = b2[c3 + 8 >> 2] | 0;
              jd(f3);
            } while ((c3 | 0) != 0);
          }
          c3 = a4;
          a4 = b2[a4 + 8 >> 2] | 0;
          if (!e3) {
            jd(c3);
          }
          if (!a4) {
            break;
          } else {
            e3 = 0;
          }
        }
        return;
      }
      function tc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0, B2 = 0, C2 = 0, D2 = 0, E2 = 0, F = 0, G2 = 0, H2 = 0, J2 = 0, K2 = 0;
        g2 = a4 + 8 | 0;
        if (b2[g2 >> 2] | 0) {
          K2 = 1;
          return K2 | 0;
        }
        f3 = b2[a4 >> 2] | 0;
        if (!f3) {
          K2 = 0;
          return K2 | 0;
        }
        c3 = f3;
        d2 = 0;
        do {
          d2 = d2 + 1 | 0;
          c3 = b2[c3 + 8 >> 2] | 0;
        } while ((c3 | 0) != 0);
        if (d2 >>> 0 < 2) {
          K2 = 0;
          return K2 | 0;
        }
        H2 = id(d2 << 2) | 0;
        if (!H2) {
          I(22948, 22787, 317, 22967);
        }
        G2 = id(d2 << 5) | 0;
        if (!G2) {
          I(22989, 22787, 321, 22967);
        }
        b2[a4 >> 2] = 0;
        z2 = a4 + 4 | 0;
        b2[z2 >> 2] = 0;
        b2[g2 >> 2] = 0;
        d2 = 0;
        F = 0;
        y3 = 0;
        n2 = 0;
        a:
          while (1) {
            m = b2[f3 >> 2] | 0;
            if (m) {
              h = 0;
              i3 = m;
              do {
                k = +e2[i3 + 8 >> 3];
                c3 = i3;
                i3 = b2[i3 + 16 >> 2] | 0;
                l2 = (i3 | 0) == 0;
                g2 = l2 ? m : i3;
                j = +e2[g2 + 8 >> 3];
                if (+q(+(k - j)) > 3.141592653589793) {
                  K2 = 14;
                  break;
                }
                h = h + (j - k) * (+e2[c3 >> 3] + +e2[g2 >> 3]);
              } while (!l2);
              if ((K2 | 0) == 14) {
                K2 = 0;
                h = 0;
                c3 = m;
                do {
                  x3 = +e2[c3 + 8 >> 3];
                  E2 = c3 + 16 | 0;
                  D2 = b2[E2 >> 2] | 0;
                  D2 = (D2 | 0) == 0 ? m : D2;
                  w2 = +e2[D2 + 8 >> 3];
                  h = h + (+e2[c3 >> 3] + +e2[D2 >> 3]) * ((w2 < 0 ? w2 + 6.283185307179586 : w2) - (x3 < 0 ? x3 + 6.283185307179586 : x3));
                  c3 = b2[((c3 | 0) == 0 ? f3 : E2) >> 2] | 0;
                } while ((c3 | 0) != 0);
              }
              if (h > 0) {
                b2[H2 + (F << 2) >> 2] = f3;
                F = F + 1 | 0;
                g2 = y3;
                c3 = n2;
              } else {
                K2 = 19;
              }
            } else {
              K2 = 19;
            }
            if ((K2 | 0) == 19) {
              K2 = 0;
              do {
                if (!d2) {
                  if (!n2) {
                    if (!(b2[a4 >> 2] | 0)) {
                      g2 = z2;
                      i3 = a4;
                      c3 = f3;
                      d2 = a4;
                      break;
                    } else {
                      K2 = 27;
                      break a;
                    }
                  } else {
                    g2 = z2;
                    i3 = n2 + 8 | 0;
                    c3 = f3;
                    d2 = a4;
                    break;
                  }
                } else {
                  c3 = d2 + 8 | 0;
                  if (b2[c3 >> 2] | 0) {
                    K2 = 21;
                    break a;
                  }
                  d2 = kd(1, 12) | 0;
                  if (!d2) {
                    K2 = 23;
                    break a;
                  }
                  b2[c3 >> 2] = d2;
                  g2 = d2 + 4 | 0;
                  i3 = d2;
                  c3 = n2;
                }
              } while (0);
              b2[i3 >> 2] = f3;
              b2[g2 >> 2] = f3;
              i3 = G2 + (y3 << 5) | 0;
              l2 = b2[f3 >> 2] | 0;
              if (l2) {
                m = G2 + (y3 << 5) + 8 | 0;
                e2[m >> 3] = 17976931348623157e292;
                n2 = G2 + (y3 << 5) + 24 | 0;
                e2[n2 >> 3] = 17976931348623157e292;
                e2[i3 >> 3] = -17976931348623157e292;
                o2 = G2 + (y3 << 5) + 16 | 0;
                e2[o2 >> 3] = -17976931348623157e292;
                u2 = 17976931348623157e292;
                v2 = -17976931348623157e292;
                g2 = 0;
                p3 = l2;
                k = 17976931348623157e292;
                s3 = 17976931348623157e292;
                t3 = -17976931348623157e292;
                j = -17976931348623157e292;
                while (1) {
                  h = +e2[p3 >> 3];
                  x3 = +e2[p3 + 8 >> 3];
                  p3 = b2[p3 + 16 >> 2] | 0;
                  r3 = (p3 | 0) == 0;
                  w2 = +e2[(r3 ? l2 : p3) + 8 >> 3];
                  if (h < k) {
                    e2[m >> 3] = h;
                    k = h;
                  }
                  if (x3 < s3) {
                    e2[n2 >> 3] = x3;
                    s3 = x3;
                  }
                  if (h > t3) {
                    e2[i3 >> 3] = h;
                  } else {
                    h = t3;
                  }
                  if (x3 > j) {
                    e2[o2 >> 3] = x3;
                    j = x3;
                  }
                  u2 = x3 > 0 & x3 < u2 ? x3 : u2;
                  v2 = x3 < 0 & x3 > v2 ? x3 : v2;
                  g2 = g2 | +q(+(x3 - w2)) > 3.141592653589793;
                  if (r3) {
                    break;
                  } else {
                    t3 = h;
                  }
                }
                if (g2) {
                  e2[o2 >> 3] = v2;
                  e2[n2 >> 3] = u2;
                }
              } else {
                b2[i3 >> 2] = 0;
                b2[i3 + 4 >> 2] = 0;
                b2[i3 + 8 >> 2] = 0;
                b2[i3 + 12 >> 2] = 0;
                b2[i3 + 16 >> 2] = 0;
                b2[i3 + 20 >> 2] = 0;
                b2[i3 + 24 >> 2] = 0;
                b2[i3 + 28 >> 2] = 0;
              }
              g2 = y3 + 1 | 0;
            }
            E2 = f3 + 8 | 0;
            f3 = b2[E2 >> 2] | 0;
            b2[E2 >> 2] = 0;
            if (!f3) {
              K2 = 45;
              break;
            } else {
              y3 = g2;
              n2 = c3;
            }
          }
        if ((K2 | 0) == 21) {
          I(22765, 22787, 35, 22799);
        } else if ((K2 | 0) == 23) {
          I(22819, 22787, 37, 22799);
        } else if ((K2 | 0) == 27) {
          I(22862, 22787, 61, 22885);
        } else if ((K2 | 0) == 45) {
          b:
            do {
              if ((F | 0) > 0) {
                E2 = (g2 | 0) == 0;
                C2 = g2 << 2;
                D2 = (a4 | 0) == 0;
                B2 = 0;
                c3 = 0;
                while (1) {
                  A2 = b2[H2 + (B2 << 2) >> 2] | 0;
                  if (!E2) {
                    y3 = id(C2) | 0;
                    if (!y3) {
                      K2 = 50;
                      break;
                    }
                    z2 = id(C2) | 0;
                    if (!z2) {
                      K2 = 52;
                      break;
                    }
                    c:
                      do {
                        if (!D2) {
                          g2 = 0;
                          d2 = 0;
                          i3 = a4;
                          while (1) {
                            f3 = G2 + (g2 << 5) | 0;
                            if (uc(b2[i3 >> 2] | 0, f3, b2[A2 >> 2] | 0) | 0) {
                              b2[y3 + (d2 << 2) >> 2] = i3;
                              b2[z2 + (d2 << 2) >> 2] = f3;
                              r3 = d2 + 1 | 0;
                            } else {
                              r3 = d2;
                            }
                            i3 = b2[i3 + 8 >> 2] | 0;
                            if (!i3) {
                              break;
                            } else {
                              g2 = g2 + 1 | 0;
                              d2 = r3;
                            }
                          }
                          if ((r3 | 0) > 0) {
                            f3 = b2[y3 >> 2] | 0;
                            if ((r3 | 0) == 1) {
                              d2 = f3;
                            } else {
                              o2 = 0;
                              p3 = -1;
                              d2 = f3;
                              n2 = f3;
                              while (1) {
                                l2 = b2[n2 >> 2] | 0;
                                f3 = 0;
                                i3 = 0;
                                while (1) {
                                  g2 = b2[b2[y3 + (i3 << 2) >> 2] >> 2] | 0;
                                  if ((g2 | 0) == (l2 | 0)) {
                                    m = f3;
                                  } else {
                                    m = f3 + ((uc(g2, b2[z2 + (i3 << 2) >> 2] | 0, b2[l2 >> 2] | 0) | 0) & 1) | 0;
                                  }
                                  i3 = i3 + 1 | 0;
                                  if ((i3 | 0) == (r3 | 0)) {
                                    break;
                                  } else {
                                    f3 = m;
                                  }
                                }
                                g2 = (m | 0) > (p3 | 0);
                                d2 = g2 ? n2 : d2;
                                f3 = o2 + 1 | 0;
                                if ((f3 | 0) == (r3 | 0)) {
                                  break c;
                                }
                                o2 = f3;
                                p3 = g2 ? m : p3;
                                n2 = b2[y3 + (f3 << 2) >> 2] | 0;
                              }
                            }
                          } else {
                            d2 = 0;
                          }
                        } else {
                          d2 = 0;
                        }
                      } while (0);
                    jd(y3);
                    jd(z2);
                    if (d2) {
                      g2 = d2 + 4 | 0;
                      f3 = b2[g2 >> 2] | 0;
                      if (!f3) {
                        if (b2[d2 >> 2] | 0) {
                          K2 = 70;
                          break;
                        }
                      } else {
                        d2 = f3 + 8 | 0;
                      }
                      b2[d2 >> 2] = A2;
                      b2[g2 >> 2] = A2;
                    } else {
                      K2 = 73;
                    }
                  } else {
                    K2 = 73;
                  }
                  if ((K2 | 0) == 73) {
                    K2 = 0;
                    c3 = b2[A2 >> 2] | 0;
                    if (c3 | 0) {
                      do {
                        z2 = c3;
                        c3 = b2[c3 + 16 >> 2] | 0;
                        jd(z2);
                      } while ((c3 | 0) != 0);
                    }
                    jd(A2);
                    c3 = 1;
                  }
                  B2 = B2 + 1 | 0;
                  if ((B2 | 0) >= (F | 0)) {
                    J2 = c3;
                    break b;
                  }
                }
                if ((K2 | 0) == 50) {
                  I(23004, 22787, 249, 23023);
                } else if ((K2 | 0) == 52) {
                  I(23042, 22787, 252, 23023);
                } else if ((K2 | 0) == 70) {
                  I(22862, 22787, 61, 22885);
                }
              } else {
                J2 = 0;
              }
            } while (0);
          jd(H2);
          jd(G2);
          K2 = J2;
          return K2 | 0;
        }
        return 0;
      }
      function uc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0;
        if (!(ya(c3, d2) | 0)) {
          a4 = 0;
          return a4 | 0;
        }
        c3 = xa(c3) | 0;
        f3 = +e2[d2 >> 3];
        g2 = +e2[d2 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        a4 = b2[a4 >> 2] | 0;
        if (!a4) {
          a4 = 0;
          return a4 | 0;
        }
        if (c3) {
          c3 = 0;
          l2 = g2;
          d2 = a4;
          a:
            while (1) {
              while (1) {
                i3 = +e2[d2 >> 3];
                g2 = +e2[d2 + 8 >> 3];
                d2 = d2 + 16 | 0;
                m = b2[d2 >> 2] | 0;
                m = (m | 0) == 0 ? a4 : m;
                h = +e2[m >> 3];
                j = +e2[m + 8 >> 3];
                if (i3 > h) {
                  k = i3;
                  i3 = j;
                } else {
                  k = h;
                  h = i3;
                  i3 = g2;
                  g2 = j;
                }
                f3 = f3 == h | f3 == k ? f3 + 2220446049250313e-31 : f3;
                if (!(f3 < h | f3 > k)) {
                  break;
                }
                d2 = b2[d2 >> 2] | 0;
                if (!d2) {
                  d2 = 22;
                  break a;
                }
              }
              j = i3 < 0 ? i3 + 6.283185307179586 : i3;
              i3 = g2 < 0 ? g2 + 6.283185307179586 : g2;
              l2 = j == l2 | i3 == l2 ? l2 + -2220446049250313e-31 : l2;
              k = j + (i3 - j) * ((f3 - h) / (k - h));
              if ((k < 0 ? k + 6.283185307179586 : k) > l2) {
                c3 = c3 ^ 1;
              }
              d2 = b2[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break;
              }
            }
          if ((d2 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          l2 = g2;
          d2 = a4;
          b:
            while (1) {
              while (1) {
                i3 = +e2[d2 >> 3];
                g2 = +e2[d2 + 8 >> 3];
                d2 = d2 + 16 | 0;
                m = b2[d2 >> 2] | 0;
                m = (m | 0) == 0 ? a4 : m;
                h = +e2[m >> 3];
                j = +e2[m + 8 >> 3];
                if (i3 > h) {
                  k = i3;
                  i3 = j;
                } else {
                  k = h;
                  h = i3;
                  i3 = g2;
                  g2 = j;
                }
                f3 = f3 == h | f3 == k ? f3 + 2220446049250313e-31 : f3;
                if (!(f3 < h | f3 > k)) {
                  break;
                }
                d2 = b2[d2 >> 2] | 0;
                if (!d2) {
                  d2 = 22;
                  break b;
                }
              }
              l2 = i3 == l2 | g2 == l2 ? l2 + -2220446049250313e-31 : l2;
              if (i3 + (g2 - i3) * ((f3 - h) / (k - h)) > l2) {
                c3 = c3 ^ 1;
              }
              d2 = b2[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break;
              }
            }
          if ((d2 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function vc(c3, d2, e3, f3, g2) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        g2 = g2 | 0;
        var h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0;
        u2 = T;
        T = T + 32 | 0;
        t3 = u2 + 16 | 0;
        s3 = u2;
        h = vd(c3 | 0, d2 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        p3 = vd(e3 | 0, f3 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (p3 & 15 | 0)) {
          t3 = 12;
          T = u2;
          return t3 | 0;
        }
        l2 = vd(c3 | 0, d2 | 0, 45) | 0;
        H() | 0;
        l2 = l2 & 127;
        m = vd(e3 | 0, f3 | 0, 45) | 0;
        H() | 0;
        m = m & 127;
        if (l2 >>> 0 > 121 | m >>> 0 > 121) {
          t3 = 5;
          T = u2;
          return t3 | 0;
        }
        p3 = (l2 | 0) != (m | 0);
        if (p3) {
          j = ua(l2, m) | 0;
          if ((j | 0) == 7) {
            t3 = 1;
            T = u2;
            return t3 | 0;
          }
          k = ua(m, l2) | 0;
          if ((k | 0) == 7) {
            I(23066, 23090, 161, 23100);
          } else {
            q2 = j;
            i3 = k;
          }
        } else {
          q2 = 0;
          i3 = 0;
        }
        n2 = ma(l2) | 0;
        o2 = ma(m) | 0;
        b2[t3 >> 2] = 0;
        b2[t3 + 4 >> 2] = 0;
        b2[t3 + 8 >> 2] = 0;
        b2[t3 + 12 >> 2] = 0;
        do {
          if (!q2) {
            Nb(e3, f3, t3) | 0;
            if ((n2 | 0) != 0 & (o2 | 0) != 0) {
              if ((m | 0) != (l2 | 0)) {
                I(23173, 23090, 261, 23100);
              }
              i3 = Fb(c3, d2) | 0;
              h = Fb(e3, f3) | 0;
              if (!((i3 | 0) == 7 | (h | 0) == 7)) {
                if (!(a3[21872 + (i3 * 7 | 0) + h >> 0] | 0)) {
                  i3 = b2[21040 + (i3 * 28 | 0) + (h << 2) >> 2] | 0;
                  if ((i3 | 0) > 0) {
                    j = t3 + 4 | 0;
                    h = 0;
                    do {
                      Ra(j);
                      h = h + 1 | 0;
                    } while ((h | 0) != (i3 | 0));
                    r3 = 51;
                  } else {
                    r3 = 51;
                  }
                } else {
                  h = 1;
                }
              } else {
                h = 5;
              }
            } else {
              r3 = 51;
            }
          } else {
            m = b2[4272 + (l2 * 28 | 0) + (q2 << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o2) {
              if (j) {
                l2 = 0;
                k = e3;
                j = f3;
                do {
                  k = Jb(k, j) | 0;
                  j = H() | 0;
                  i3 = Ta(i3) | 0;
                  l2 = l2 + 1 | 0;
                } while ((l2 | 0) != (m | 0));
                m = i3;
                l2 = k;
                k = j;
              } else {
                m = i3;
                l2 = e3;
                k = f3;
              }
            } else if (j) {
              l2 = 0;
              k = e3;
              j = f3;
              do {
                k = Ib(k, j) | 0;
                j = H() | 0;
                i3 = Ta(i3) | 0;
                if ((i3 | 0) == 1) {
                  i3 = Ta(1) | 0;
                }
                l2 = l2 + 1 | 0;
              } while ((l2 | 0) != (m | 0));
              m = i3;
              l2 = k;
              k = j;
            } else {
              m = i3;
              l2 = e3;
              k = f3;
            }
            Nb(l2, k, t3) | 0;
            if (!p3) {
              I(23115, 23090, 191, 23100);
            }
            j = (n2 | 0) != 0;
            i3 = (o2 | 0) != 0;
            if (j & i3) {
              I(23142, 23090, 192, 23100);
            }
            if (!j) {
              if (i3) {
                i3 = Fb(l2, k) | 0;
                if ((i3 | 0) == 7) {
                  h = 5;
                  break;
                }
                if (a3[21872 + (i3 * 7 | 0) + m >> 0] | 0) {
                  h = 1;
                  break;
                }
                l2 = 0;
                k = b2[21040 + (m * 28 | 0) + (i3 << 2) >> 2] | 0;
              } else {
                l2 = 0;
                k = 0;
              }
            } else {
              i3 = Fb(c3, d2) | 0;
              if ((i3 | 0) == 7) {
                h = 5;
                break;
              }
              if (a3[21872 + (i3 * 7 | 0) + q2 >> 0] | 0) {
                h = 1;
                break;
              }
              k = b2[21040 + (i3 * 28 | 0) + (q2 << 2) >> 2] | 0;
              l2 = k;
            }
            if ((l2 | k | 0) < 0) {
              h = 5;
            } else {
              if ((k | 0) > 0) {
                j = t3 + 4 | 0;
                i3 = 0;
                do {
                  Ra(j);
                  i3 = i3 + 1 | 0;
                } while ((i3 | 0) != (k | 0));
              }
              b2[s3 >> 2] = 0;
              b2[s3 + 4 >> 2] = 0;
              b2[s3 + 8 >> 2] = 0;
              Pa(s3, q2);
              if (h | 0) {
                while (1) {
                  if (!(Lb(h) | 0)) {
                    Oa(s3);
                  } else {
                    Na(s3);
                  }
                  if ((h | 0) > 1) {
                    h = h + -1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if ((l2 | 0) > 0) {
                h = 0;
                do {
                  Ra(s3);
                  h = h + 1 | 0;
                } while ((h | 0) != (l2 | 0));
              }
              r3 = t3 + 4 | 0;
              Fa(r3, s3, r3);
              Da(r3);
              r3 = 51;
            }
          }
        } while (0);
        if ((r3 | 0) == 51) {
          h = t3 + 4 | 0;
          b2[g2 >> 2] = b2[h >> 2];
          b2[g2 + 4 >> 2] = b2[h + 4 >> 2];
          b2[g2 + 8 >> 2] = b2[h + 8 >> 2];
          h = 0;
        }
        t3 = h;
        T = u2;
        return t3 | 0;
      }
      function wc(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0;
        q2 = T;
        T = T + 48 | 0;
        k = q2 + 36 | 0;
        h = q2 + 24 | 0;
        i3 = q2 + 12 | 0;
        j = q2;
        f3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f3 = f3 & 15;
        n2 = vd(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        n2 = n2 & 127;
        if (n2 >>> 0 > 121) {
          e3 = 5;
          T = q2;
          return e3 | 0;
        }
        l2 = ma(n2) | 0;
        wd(f3 | 0, 0, 52) | 0;
        r3 = H() | 0 | 134225919;
        g2 = e3;
        b2[g2 >> 2] = -1;
        b2[g2 + 4 >> 2] = r3;
        if (!f3) {
          f3 = Ia(d2) | 0;
          if ((f3 | 0) == 7) {
            r3 = 1;
            T = q2;
            return r3 | 0;
          }
          f3 = ta(n2, f3) | 0;
          if ((f3 | 0) == 127) {
            r3 = 1;
            T = q2;
            return r3 | 0;
          }
          o2 = wd(f3 | 0, 0, 45) | 0;
          p3 = H() | 0;
          n2 = e3;
          p3 = b2[n2 + 4 >> 2] & -1040385 | p3;
          r3 = e3;
          b2[r3 >> 2] = b2[n2 >> 2] | o2;
          b2[r3 + 4 >> 2] = p3;
          r3 = 0;
          T = q2;
          return r3 | 0;
        }
        b2[k >> 2] = b2[d2 >> 2];
        b2[k + 4 >> 2] = b2[d2 + 4 >> 2];
        b2[k + 8 >> 2] = b2[d2 + 8 >> 2];
        d2 = f3;
        while (1) {
          g2 = d2;
          d2 = d2 + -1 | 0;
          b2[h >> 2] = b2[k >> 2];
          b2[h + 4 >> 2] = b2[k + 4 >> 2];
          b2[h + 8 >> 2] = b2[k + 8 >> 2];
          if (!(Lb(g2) | 0)) {
            f3 = Ka(k) | 0;
            if (f3 | 0) {
              d2 = 13;
              break;
            }
            b2[i3 >> 2] = b2[k >> 2];
            b2[i3 + 4 >> 2] = b2[k + 4 >> 2];
            b2[i3 + 8 >> 2] = b2[k + 8 >> 2];
            Oa(i3);
          } else {
            f3 = Ja(k) | 0;
            if (f3 | 0) {
              d2 = 13;
              break;
            }
            b2[i3 >> 2] = b2[k >> 2];
            b2[i3 + 4 >> 2] = b2[k + 4 >> 2];
            b2[i3 + 8 >> 2] = b2[k + 8 >> 2];
            Na(i3);
          }
          Ga(h, i3, j);
          Da(j);
          f3 = e3;
          t3 = b2[f3 >> 2] | 0;
          f3 = b2[f3 + 4 >> 2] | 0;
          u2 = (15 - g2 | 0) * 3 | 0;
          s3 = wd(7, 0, u2 | 0) | 0;
          f3 = f3 & ~(H() | 0);
          u2 = wd(Ia(j) | 0, 0, u2 | 0) | 0;
          f3 = H() | 0 | f3;
          r3 = e3;
          b2[r3 >> 2] = u2 | t3 & ~s3;
          b2[r3 + 4 >> 2] = f3;
          if ((g2 | 0) <= 1) {
            d2 = 14;
            break;
          }
        }
        a:
          do {
            if ((d2 | 0) != 13) {
              if ((d2 | 0) == 14) {
                if (((b2[k >> 2] | 0) <= 1 ? (b2[k + 4 >> 2] | 0) <= 1 : 0) ? (b2[k + 8 >> 2] | 0) <= 1 : 0) {
                  d2 = Ia(k) | 0;
                  f3 = ta(n2, d2) | 0;
                  if ((f3 | 0) == 127) {
                    j = 0;
                  } else {
                    j = ma(f3) | 0;
                  }
                  b:
                    do {
                      if (!d2) {
                        if ((l2 | 0) != 0 & (j | 0) != 0) {
                          d2 = Fb(a4, c3) | 0;
                          g2 = e3;
                          g2 = Fb(b2[g2 >> 2] | 0, b2[g2 + 4 >> 2] | 0) | 0;
                          if ((d2 | 0) == 7 | (g2 | 0) == 7) {
                            f3 = 5;
                            break a;
                          }
                          g2 = b2[21248 + (d2 * 28 | 0) + (g2 << 2) >> 2] | 0;
                          if ((g2 | 0) < 0) {
                            f3 = 5;
                            break a;
                          }
                          if (!g2) {
                            d2 = 59;
                          } else {
                            i3 = e3;
                            d2 = 0;
                            h = b2[i3 >> 2] | 0;
                            i3 = b2[i3 + 4 >> 2] | 0;
                            do {
                              h = Hb(h, i3) | 0;
                              i3 = H() | 0;
                              u2 = e3;
                              b2[u2 >> 2] = h;
                              b2[u2 + 4 >> 2] = i3;
                              d2 = d2 + 1 | 0;
                            } while ((d2 | 0) < (g2 | 0));
                            d2 = 58;
                          }
                        } else {
                          d2 = 58;
                        }
                      } else {
                        if (l2) {
                          f3 = Fb(a4, c3) | 0;
                          if ((f3 | 0) == 7) {
                            f3 = 5;
                            break a;
                          }
                          g2 = b2[21248 + (f3 * 28 | 0) + (d2 << 2) >> 2] | 0;
                          if ((g2 | 0) > 0) {
                            f3 = d2;
                            d2 = 0;
                            do {
                              f3 = Sa(f3) | 0;
                              d2 = d2 + 1 | 0;
                            } while ((d2 | 0) != (g2 | 0));
                          } else {
                            f3 = d2;
                          }
                          if ((f3 | 0) == 1) {
                            f3 = 9;
                            break a;
                          }
                          d2 = ta(n2, f3) | 0;
                          if ((d2 | 0) == 127) {
                            I(23200, 23090, 411, 23230);
                          }
                          if (!(ma(d2) | 0)) {
                            p3 = d2;
                            o2 = g2;
                            m = f3;
                          } else {
                            I(23245, 23090, 412, 23230);
                          }
                        } else {
                          p3 = f3;
                          o2 = 0;
                          m = d2;
                        }
                        i3 = b2[4272 + (n2 * 28 | 0) + (m << 2) >> 2] | 0;
                        if ((i3 | 0) <= -1) {
                          I(23276, 23090, 419, 23230);
                        }
                        if (!j) {
                          if ((o2 | 0) < 0) {
                            f3 = 5;
                            break a;
                          }
                          if (o2 | 0) {
                            g2 = e3;
                            f3 = 0;
                            d2 = b2[g2 >> 2] | 0;
                            g2 = b2[g2 + 4 >> 2] | 0;
                            do {
                              d2 = Hb(d2, g2) | 0;
                              g2 = H() | 0;
                              u2 = e3;
                              b2[u2 >> 2] = d2;
                              b2[u2 + 4 >> 2] = g2;
                              f3 = f3 + 1 | 0;
                            } while ((f3 | 0) < (o2 | 0));
                          }
                          if ((i3 | 0) <= 0) {
                            f3 = p3;
                            d2 = 58;
                            break;
                          }
                          g2 = e3;
                          f3 = 0;
                          d2 = b2[g2 >> 2] | 0;
                          g2 = b2[g2 + 4 >> 2] | 0;
                          while (1) {
                            d2 = Hb(d2, g2) | 0;
                            g2 = H() | 0;
                            u2 = e3;
                            b2[u2 >> 2] = d2;
                            b2[u2 + 4 >> 2] = g2;
                            f3 = f3 + 1 | 0;
                            if ((f3 | 0) == (i3 | 0)) {
                              f3 = p3;
                              d2 = 58;
                              break b;
                            }
                          }
                        }
                        h = ua(p3, n2) | 0;
                        if ((h | 0) == 7) {
                          I(23066, 23090, 428, 23230);
                        }
                        f3 = e3;
                        d2 = b2[f3 >> 2] | 0;
                        f3 = b2[f3 + 4 >> 2] | 0;
                        if ((i3 | 0) > 0) {
                          g2 = 0;
                          do {
                            d2 = Hb(d2, f3) | 0;
                            f3 = H() | 0;
                            u2 = e3;
                            b2[u2 >> 2] = d2;
                            b2[u2 + 4 >> 2] = f3;
                            g2 = g2 + 1 | 0;
                          } while ((g2 | 0) != (i3 | 0));
                        }
                        f3 = Fb(d2, f3) | 0;
                        if ((f3 | 0) == 7) {
                          I(23313, 23090, 440, 23230);
                        }
                        d2 = na(p3) | 0;
                        d2 = b2[(d2 ? 21664 : 21456) + (h * 28 | 0) + (f3 << 2) >> 2] | 0;
                        if ((d2 | 0) < 0) {
                          I(23313, 23090, 454, 23230);
                        }
                        if (!d2) {
                          f3 = p3;
                          d2 = 58;
                        } else {
                          h = e3;
                          f3 = 0;
                          g2 = b2[h >> 2] | 0;
                          h = b2[h + 4 >> 2] | 0;
                          do {
                            g2 = Gb(g2, h) | 0;
                            h = H() | 0;
                            u2 = e3;
                            b2[u2 >> 2] = g2;
                            b2[u2 + 4 >> 2] = h;
                            f3 = f3 + 1 | 0;
                          } while ((f3 | 0) < (d2 | 0));
                          f3 = p3;
                          d2 = 58;
                        }
                      }
                    } while (0);
                  if ((d2 | 0) == 58) {
                    if (j) {
                      d2 = 59;
                    }
                  }
                  if ((d2 | 0) == 59) {
                    u2 = e3;
                    if ((Fb(b2[u2 >> 2] | 0, b2[u2 + 4 >> 2] | 0) | 0) == 1) {
                      f3 = 9;
                      break;
                    }
                  }
                  u2 = e3;
                  s3 = b2[u2 >> 2] | 0;
                  u2 = b2[u2 + 4 >> 2] & -1040385;
                  t3 = wd(f3 | 0, 0, 45) | 0;
                  u2 = u2 | (H() | 0);
                  f3 = e3;
                  b2[f3 >> 2] = s3 | t3;
                  b2[f3 + 4 >> 2] = u2;
                  f3 = 0;
                } else {
                  f3 = 1;
                }
              }
            }
          } while (0);
        u2 = f3;
        T = q2;
        return u2 | 0;
      }
      function xc(a4, b3, c3, d2, e3, f3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        if (!e3) {
          a4 = vc(a4, b3, c3, d2, g2) | 0;
          if (!a4) {
            Xa(g2, f3);
            a4 = 0;
          }
        } else {
          a4 = 15;
        }
        T = h;
        return a4 | 0;
      }
      function yc(a4, b3, c3, d2, e3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f3 = g2;
        if (!d2) {
          c3 = Ya(c3, f3) | 0;
          if (!c3) {
            c3 = wc(a4, b3, f3, e3) | 0;
          }
        } else {
          c3 = 15;
        }
        T = g2;
        return c3 | 0;
      }
      function zc(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i3 = j;
        g2 = vc(a4, c3, a4, c3, h) | 0;
        if (g2 | 0) {
          i3 = g2;
          T = j;
          return i3 | 0;
        }
        a4 = vc(a4, c3, d2, e3, i3) | 0;
        if (a4 | 0) {
          i3 = a4;
          T = j;
          return i3 | 0;
        }
        h = Wa(h, i3) | 0;
        i3 = f3;
        b2[i3 >> 2] = h;
        b2[i3 + 4 >> 2] = ((h | 0) < 0) << 31 >> 31;
        i3 = 0;
        T = j;
        return i3 | 0;
      }
      function Ac(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i3 = j;
        g2 = vc(a4, c3, a4, c3, h) | 0;
        if (!g2) {
          g2 = vc(a4, c3, d2, e3, i3) | 0;
          if (!g2) {
            e3 = Wa(h, i3) | 0;
            e3 = ld(e3 | 0, ((e3 | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0;
            h = H() | 0;
            i3 = f3;
            b2[i3 >> 2] = e3;
            b2[i3 + 4 >> 2] = h;
            i3 = 0;
            T = j;
            return i3 | 0;
          }
        }
        i3 = g2;
        T = j;
        return i3 | 0;
      }
      function Bc(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0;
        z2 = T;
        T = T + 48 | 0;
        h = z2 + 24 | 0;
        i3 = z2 + 12 | 0;
        y3 = z2;
        g2 = vc(a4, c3, a4, c3, h) | 0;
        if (!g2) {
          g2 = vc(a4, c3, d2, e3, i3) | 0;
          if (!g2) {
            w2 = Wa(h, i3) | 0;
            x3 = ((w2 | 0) < 0) << 31 >> 31;
            b2[h >> 2] = 0;
            b2[h + 4 >> 2] = 0;
            b2[h + 8 >> 2] = 0;
            b2[i3 >> 2] = 0;
            b2[i3 + 4 >> 2] = 0;
            b2[i3 + 8 >> 2] = 0;
            if (vc(a4, c3, a4, c3, h) | 0) {
              I(23313, 23090, 691, 23299);
            }
            if (vc(a4, c3, d2, e3, i3) | 0) {
              I(23313, 23090, 696, 23299);
            }
            Za(h);
            Za(i3);
            if (!w2) {
              g2 = h + 4 | 0;
              d2 = h + 8 | 0;
              t3 = g2;
              u2 = d2;
              v2 = h;
              e3 = b2[h >> 2] | 0;
              g2 = b2[g2 >> 2] | 0;
              d2 = b2[d2 >> 2] | 0;
              r3 = 0;
              s3 = 0;
              p3 = 0;
            } else {
              m = b2[h >> 2] | 0;
              p3 = +(w2 | 0);
              t3 = h + 4 | 0;
              n2 = b2[t3 >> 2] | 0;
              u2 = h + 8 | 0;
              o2 = b2[u2 >> 2] | 0;
              v2 = h;
              e3 = m;
              g2 = n2;
              d2 = o2;
              r3 = +((b2[i3 >> 2] | 0) - m | 0) / p3;
              s3 = +((b2[i3 + 4 >> 2] | 0) - n2 | 0) / p3;
              p3 = +((b2[i3 + 8 >> 2] | 0) - o2 | 0) / p3;
            }
            b2[y3 >> 2] = e3;
            o2 = y3 + 4 | 0;
            b2[o2 >> 2] = g2;
            n2 = y3 + 8 | 0;
            b2[n2 >> 2] = d2;
            a:
              do {
                if ((w2 | 0) < 0) {
                  g2 = 0;
                } else {
                  l2 = 0;
                  m = 0;
                  g2 = e3;
                  while (1) {
                    k = +(m >>> 0) + 4294967296 * +(l2 | 0);
                    A2 = r3 * k + +(g2 | 0);
                    j = s3 * k + +(b2[t3 >> 2] | 0);
                    k = p3 * k + +(b2[u2 >> 2] | 0);
                    d2 = ~~+zd(+A2);
                    h = ~~+zd(+j);
                    g2 = ~~+zd(+k);
                    A2 = +q(+(+(d2 | 0) - A2));
                    j = +q(+(+(h | 0) - j));
                    k = +q(+(+(g2 | 0) - k));
                    do {
                      if (!(A2 > j & A2 > k)) {
                        i3 = 0 - d2 | 0;
                        if (j > k) {
                          e3 = i3 - g2 | 0;
                          break;
                        } else {
                          e3 = h;
                          g2 = i3 - h | 0;
                          break;
                        }
                      } else {
                        d2 = 0 - (h + g2) | 0;
                        e3 = h;
                      }
                    } while (0);
                    b2[y3 >> 2] = d2;
                    b2[o2 >> 2] = e3;
                    b2[n2 >> 2] = g2;
                    _a(y3);
                    g2 = wc(a4, c3, y3, f3 + (m << 3) | 0) | 0;
                    if (g2 | 0) {
                      break a;
                    }
                    if (!((l2 | 0) < (x3 | 0) | (l2 | 0) == (x3 | 0) & m >>> 0 < w2 >>> 0)) {
                      g2 = 0;
                      break a;
                    }
                    g2 = ld(m | 0, l2 | 0, 1, 0) | 0;
                    i3 = H() | 0;
                    l2 = i3;
                    m = g2;
                    g2 = b2[v2 >> 2] | 0;
                  }
                }
              } while (0);
            y3 = g2;
            T = z2;
            return y3 | 0;
          }
        }
        y3 = g2;
        T = z2;
        return y3 | 0;
      }
      function Cc(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        if ((c3 | 0) == 0 & (d2 | 0) == 0) {
          e3 = 0;
          f3 = 1;
          G(e3 | 0);
          return f3 | 0;
        }
        f3 = a4;
        e3 = b3;
        a4 = 1;
        b3 = 0;
        do {
          g2 = (c3 & 1 | 0) == 0 & true;
          a4 = rd((g2 ? 1 : f3) | 0, (g2 ? 0 : e3) | 0, a4 | 0, b3 | 0) | 0;
          b3 = H() | 0;
          c3 = ud(c3 | 0, d2 | 0, 1) | 0;
          d2 = H() | 0;
          f3 = rd(f3 | 0, e3 | 0, f3 | 0, e3 | 0) | 0;
          e3 = H() | 0;
        } while (!((c3 | 0) == 0 & (d2 | 0) == 0));
        G(b3 | 0);
        return a4 | 0;
      }
      function Dc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0;
        if (!(ya(c3, d2) | 0)) {
          o2 = 0;
          return o2 | 0;
        }
        c3 = xa(c3) | 0;
        f3 = +e2[d2 >> 3];
        g2 = +e2[d2 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        o2 = b2[a4 >> 2] | 0;
        if ((o2 | 0) <= 0) {
          o2 = 0;
          return o2 | 0;
        }
        n2 = b2[a4 + 4 >> 2] | 0;
        if (c3) {
          c3 = 0;
          m = g2;
          d2 = -1;
          a4 = 0;
          a:
            while (1) {
              l2 = a4;
              while (1) {
                i3 = +e2[n2 + (l2 << 4) >> 3];
                g2 = +e2[n2 + (l2 << 4) + 8 >> 3];
                a4 = (d2 + 2 | 0) % (o2 | 0) | 0;
                h = +e2[n2 + (a4 << 4) >> 3];
                j = +e2[n2 + (a4 << 4) + 8 >> 3];
                if (i3 > h) {
                  k = i3;
                  i3 = j;
                } else {
                  k = h;
                  h = i3;
                  i3 = g2;
                  g2 = j;
                }
                f3 = f3 == h | f3 == k ? f3 + 2220446049250313e-31 : f3;
                if (!(f3 < h | f3 > k)) {
                  break;
                }
                d2 = l2 + 1 | 0;
                if ((d2 | 0) >= (o2 | 0)) {
                  d2 = 22;
                  break a;
                } else {
                  a4 = l2;
                  l2 = d2;
                  d2 = a4;
                }
              }
              j = i3 < 0 ? i3 + 6.283185307179586 : i3;
              i3 = g2 < 0 ? g2 + 6.283185307179586 : g2;
              m = j == m | i3 == m ? m + -2220446049250313e-31 : m;
              k = j + (i3 - j) * ((f3 - h) / (k - h));
              if ((k < 0 ? k + 6.283185307179586 : k) > m) {
                c3 = c3 ^ 1;
              }
              a4 = l2 + 1 | 0;
              if ((a4 | 0) >= (o2 | 0)) {
                d2 = 22;
                break;
              } else {
                d2 = l2;
              }
            }
          if ((d2 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          m = g2;
          d2 = -1;
          a4 = 0;
          b:
            while (1) {
              l2 = a4;
              while (1) {
                i3 = +e2[n2 + (l2 << 4) >> 3];
                g2 = +e2[n2 + (l2 << 4) + 8 >> 3];
                a4 = (d2 + 2 | 0) % (o2 | 0) | 0;
                h = +e2[n2 + (a4 << 4) >> 3];
                j = +e2[n2 + (a4 << 4) + 8 >> 3];
                if (i3 > h) {
                  k = i3;
                  i3 = j;
                } else {
                  k = h;
                  h = i3;
                  i3 = g2;
                  g2 = j;
                }
                f3 = f3 == h | f3 == k ? f3 + 2220446049250313e-31 : f3;
                if (!(f3 < h | f3 > k)) {
                  break;
                }
                d2 = l2 + 1 | 0;
                if ((d2 | 0) >= (o2 | 0)) {
                  d2 = 22;
                  break b;
                } else {
                  a4 = l2;
                  l2 = d2;
                  d2 = a4;
                }
              }
              m = i3 == m | g2 == m ? m + -2220446049250313e-31 : m;
              if (i3 + (g2 - i3) * ((f3 - h) / (k - h)) > m) {
                c3 = c3 ^ 1;
              }
              a4 = l2 + 1 | 0;
              if ((a4 | 0) >= (o2 | 0)) {
                d2 = 22;
                break;
              } else {
                d2 = l2;
              }
            }
          if ((d2 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function Ec(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0;
        r3 = b2[a4 >> 2] | 0;
        if (!r3) {
          b2[c3 >> 2] = 0;
          b2[c3 + 4 >> 2] = 0;
          b2[c3 + 8 >> 2] = 0;
          b2[c3 + 12 >> 2] = 0;
          b2[c3 + 16 >> 2] = 0;
          b2[c3 + 20 >> 2] = 0;
          b2[c3 + 24 >> 2] = 0;
          b2[c3 + 28 >> 2] = 0;
          return;
        }
        s3 = c3 + 8 | 0;
        e2[s3 >> 3] = 17976931348623157e292;
        t3 = c3 + 24 | 0;
        e2[t3 >> 3] = 17976931348623157e292;
        e2[c3 >> 3] = -17976931348623157e292;
        u2 = c3 + 16 | 0;
        e2[u2 >> 3] = -17976931348623157e292;
        if ((r3 | 0) <= 0) {
          return;
        }
        o2 = b2[a4 + 4 >> 2] | 0;
        l2 = 17976931348623157e292;
        m = -17976931348623157e292;
        n2 = 0;
        a4 = -1;
        h = 17976931348623157e292;
        i3 = 17976931348623157e292;
        k = -17976931348623157e292;
        f3 = -17976931348623157e292;
        p3 = 0;
        while (1) {
          d2 = +e2[o2 + (p3 << 4) >> 3];
          j = +e2[o2 + (p3 << 4) + 8 >> 3];
          a4 = a4 + 2 | 0;
          g2 = +e2[o2 + (((a4 | 0) == (r3 | 0) ? 0 : a4) << 4) + 8 >> 3];
          if (d2 < h) {
            e2[s3 >> 3] = d2;
            h = d2;
          }
          if (j < i3) {
            e2[t3 >> 3] = j;
            i3 = j;
          }
          if (d2 > k) {
            e2[c3 >> 3] = d2;
          } else {
            d2 = k;
          }
          if (j > f3) {
            e2[u2 >> 3] = j;
            f3 = j;
          }
          l2 = j > 0 & j < l2 ? j : l2;
          m = j < 0 & j > m ? j : m;
          n2 = n2 | +q(+(j - g2)) > 3.141592653589793;
          a4 = p3 + 1 | 0;
          if ((a4 | 0) == (r3 | 0)) {
            break;
          } else {
            v2 = p3;
            k = d2;
            p3 = a4;
            a4 = v2;
          }
        }
        if (!n2) {
          return;
        }
        e2[u2 >> 3] = m;
        e2[t3 >> 3] = l2;
        return;
      }
      function Fc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0, x3 = 0, y3 = 0, z2 = 0, A2 = 0;
        r3 = b2[a4 >> 2] | 0;
        if (r3) {
          s3 = c3 + 8 | 0;
          e2[s3 >> 3] = 17976931348623157e292;
          t3 = c3 + 24 | 0;
          e2[t3 >> 3] = 17976931348623157e292;
          e2[c3 >> 3] = -17976931348623157e292;
          u2 = c3 + 16 | 0;
          e2[u2 >> 3] = -17976931348623157e292;
          if ((r3 | 0) > 0) {
            g2 = b2[a4 + 4 >> 2] | 0;
            o2 = 17976931348623157e292;
            p3 = -17976931348623157e292;
            f3 = 0;
            d2 = -1;
            k = 17976931348623157e292;
            l2 = 17976931348623157e292;
            n2 = -17976931348623157e292;
            i3 = -17976931348623157e292;
            v2 = 0;
            while (1) {
              h = +e2[g2 + (v2 << 4) >> 3];
              m = +e2[g2 + (v2 << 4) + 8 >> 3];
              z2 = d2 + 2 | 0;
              j = +e2[g2 + (((z2 | 0) == (r3 | 0) ? 0 : z2) << 4) + 8 >> 3];
              if (h < k) {
                e2[s3 >> 3] = h;
                k = h;
              }
              if (m < l2) {
                e2[t3 >> 3] = m;
                l2 = m;
              }
              if (h > n2) {
                e2[c3 >> 3] = h;
              } else {
                h = n2;
              }
              if (m > i3) {
                e2[u2 >> 3] = m;
                i3 = m;
              }
              o2 = m > 0 & m < o2 ? m : o2;
              p3 = m < 0 & m > p3 ? m : p3;
              f3 = f3 | +q(+(m - j)) > 3.141592653589793;
              d2 = v2 + 1 | 0;
              if ((d2 | 0) == (r3 | 0)) {
                break;
              } else {
                z2 = v2;
                n2 = h;
                v2 = d2;
                d2 = z2;
              }
            }
            if (f3) {
              e2[u2 >> 3] = p3;
              e2[t3 >> 3] = o2;
            }
          }
        } else {
          b2[c3 >> 2] = 0;
          b2[c3 + 4 >> 2] = 0;
          b2[c3 + 8 >> 2] = 0;
          b2[c3 + 12 >> 2] = 0;
          b2[c3 + 16 >> 2] = 0;
          b2[c3 + 20 >> 2] = 0;
          b2[c3 + 24 >> 2] = 0;
          b2[c3 + 28 >> 2] = 0;
        }
        z2 = a4 + 8 | 0;
        d2 = b2[z2 >> 2] | 0;
        if ((d2 | 0) <= 0) {
          return;
        }
        y3 = a4 + 12 | 0;
        x3 = 0;
        do {
          g2 = b2[y3 >> 2] | 0;
          f3 = x3;
          x3 = x3 + 1 | 0;
          t3 = c3 + (x3 << 5) | 0;
          u2 = b2[g2 + (f3 << 3) >> 2] | 0;
          if (u2) {
            v2 = c3 + (x3 << 5) + 8 | 0;
            e2[v2 >> 3] = 17976931348623157e292;
            a4 = c3 + (x3 << 5) + 24 | 0;
            e2[a4 >> 3] = 17976931348623157e292;
            e2[t3 >> 3] = -17976931348623157e292;
            w2 = c3 + (x3 << 5) + 16 | 0;
            e2[w2 >> 3] = -17976931348623157e292;
            if ((u2 | 0) > 0) {
              r3 = b2[g2 + (f3 << 3) + 4 >> 2] | 0;
              o2 = 17976931348623157e292;
              p3 = -17976931348623157e292;
              g2 = 0;
              f3 = -1;
              s3 = 0;
              k = 17976931348623157e292;
              l2 = 17976931348623157e292;
              m = -17976931348623157e292;
              i3 = -17976931348623157e292;
              while (1) {
                h = +e2[r3 + (s3 << 4) >> 3];
                n2 = +e2[r3 + (s3 << 4) + 8 >> 3];
                f3 = f3 + 2 | 0;
                j = +e2[r3 + (((f3 | 0) == (u2 | 0) ? 0 : f3) << 4) + 8 >> 3];
                if (h < k) {
                  e2[v2 >> 3] = h;
                  k = h;
                }
                if (n2 < l2) {
                  e2[a4 >> 3] = n2;
                  l2 = n2;
                }
                if (h > m) {
                  e2[t3 >> 3] = h;
                } else {
                  h = m;
                }
                if (n2 > i3) {
                  e2[w2 >> 3] = n2;
                  i3 = n2;
                }
                o2 = n2 > 0 & n2 < o2 ? n2 : o2;
                p3 = n2 < 0 & n2 > p3 ? n2 : p3;
                g2 = g2 | +q(+(n2 - j)) > 3.141592653589793;
                f3 = s3 + 1 | 0;
                if ((f3 | 0) == (u2 | 0)) {
                  break;
                } else {
                  A2 = s3;
                  s3 = f3;
                  m = h;
                  f3 = A2;
                }
              }
              if (g2) {
                e2[w2 >> 3] = p3;
                e2[a4 >> 3] = o2;
              }
            }
          } else {
            b2[t3 >> 2] = 0;
            b2[t3 + 4 >> 2] = 0;
            b2[t3 + 8 >> 2] = 0;
            b2[t3 + 12 >> 2] = 0;
            b2[t3 + 16 >> 2] = 0;
            b2[t3 + 20 >> 2] = 0;
            b2[t3 + 24 >> 2] = 0;
            b2[t3 + 28 >> 2] = 0;
            d2 = b2[z2 >> 2] | 0;
          }
        } while ((x3 | 0) < (d2 | 0));
        return;
      }
      function Gc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        if (!(Dc(a4, c3, d2) | 0)) {
          f3 = 0;
          return f3 | 0;
        }
        f3 = a4 + 8 | 0;
        if ((b2[f3 >> 2] | 0) <= 0) {
          f3 = 1;
          return f3 | 0;
        }
        e3 = a4 + 12 | 0;
        a4 = 0;
        while (1) {
          g2 = a4;
          a4 = a4 + 1 | 0;
          if (Dc((b2[e3 >> 2] | 0) + (g2 << 3) | 0, c3 + (a4 << 5) | 0, d2) | 0) {
            a4 = 0;
            e3 = 6;
            break;
          }
          if ((a4 | 0) >= (b2[f3 >> 2] | 0)) {
            a4 = 1;
            e3 = 6;
            break;
          }
        }
        if ((e3 | 0) == 6) {
          return a4 | 0;
        }
        return 0;
      }
      function Hc() {
        return 8;
      }
      function Ic() {
        return 16;
      }
      function Jc() {
        return 168;
      }
      function Kc() {
        return 8;
      }
      function Lc() {
        return 16;
      }
      function Mc() {
        return 12;
      }
      function Nc() {
        return 8;
      }
      function Oc(a4) {
        a4 = a4 | 0;
        return +(+((b2[a4 >> 2] | 0) >>> 0) + 4294967296 * +(b2[a4 + 4 >> 2] | 0));
      }
      function Pc(a4) {
        a4 = a4 | 0;
        var b3 = 0, c3 = 0;
        c3 = +e2[a4 >> 3];
        b3 = +e2[a4 + 8 >> 3];
        return + +r2(+(c3 * c3 + b3 * b3));
      }
      function Qc(a4, b3, c3, d2, f3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0;
        k = +e2[a4 >> 3];
        j = +e2[b3 >> 3] - k;
        i3 = +e2[a4 + 8 >> 3];
        h = +e2[b3 + 8 >> 3] - i3;
        m = +e2[c3 >> 3];
        g2 = +e2[d2 >> 3] - m;
        n2 = +e2[c3 + 8 >> 3];
        l2 = +e2[d2 + 8 >> 3] - n2;
        g2 = (g2 * (i3 - n2) - (k - m) * l2) / (j * l2 - h * g2);
        e2[f3 >> 3] = k + j * g2;
        e2[f3 + 8 >> 3] = i3 + h * g2;
        return;
      }
      function Rc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        if (!(+q(+(+e2[a4 >> 3] - +e2[b3 >> 3])) < 11920928955078125e-23)) {
          b3 = 0;
          return b3 | 0;
        }
        b3 = +q(+(+e2[a4 + 8 >> 3] - +e2[b3 + 8 >> 3])) < 11920928955078125e-23;
        return b3 | 0;
      }
      function Sc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0;
        f3 = +e2[a4 >> 3] - +e2[b3 >> 3];
        d2 = +e2[a4 + 8 >> 3] - +e2[b3 + 8 >> 3];
        c3 = +e2[a4 + 16 >> 3] - +e2[b3 + 16 >> 3];
        return +(f3 * f3 + d2 * d2 + c3 * c3);
      }
      function Tc(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, f3 = 0;
        c3 = +e2[a4 >> 3];
        d2 = +t2(+c3);
        c3 = +u(+c3);
        e2[b3 + 16 >> 3] = c3;
        c3 = +e2[a4 + 8 >> 3];
        f3 = d2 * +t2(+c3);
        e2[b3 >> 3] = f3;
        c3 = d2 * +u(+c3);
        e2[b3 + 8 >> 3] = c3;
        return;
      }
      function Uc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f3 = g2;
        e3 = xb(a4, c3) | 0;
        if ((d2 + -1 | 0) >>> 0 > 5) {
          f3 = -1;
          T = g2;
          return f3 | 0;
        }
        e3 = (e3 | 0) != 0;
        if ((d2 | 0) == 1 & e3) {
          f3 = -1;
          T = g2;
          return f3 | 0;
        }
        do {
          if (!(Vc(a4, c3, f3) | 0)) {
            if (e3) {
              e3 = ((b2[21936 + (d2 << 2) >> 2] | 0) + 5 - (b2[f3 >> 2] | 0) | 0) % 5 | 0;
              break;
            } else {
              e3 = ((b2[21968 + (d2 << 2) >> 2] | 0) + 6 - (b2[f3 >> 2] | 0) | 0) % 6 | 0;
              break;
            }
          } else {
            e3 = -1;
          }
        } while (0);
        f3 = e3;
        T = g2;
        return f3 | 0;
      }
      function Vc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        k = T;
        T = T + 32 | 0;
        h = k + 16 | 0;
        i3 = k;
        e3 = Ob(a4, c3, h) | 0;
        if (e3 | 0) {
          d2 = e3;
          T = k;
          return d2 | 0;
        }
        g2 = tb(a4, c3) | 0;
        j = Fb(a4, c3) | 0;
        qa(g2, i3);
        e3 = ra(g2, b2[h >> 2] | 0) | 0;
        a:
          do {
            if (ma(g2) | 0) {
              do {
                switch (g2 | 0) {
                  case 4: {
                    a4 = 0;
                    break;
                  }
                  case 14: {
                    a4 = 1;
                    break;
                  }
                  case 24: {
                    a4 = 2;
                    break;
                  }
                  case 38: {
                    a4 = 3;
                    break;
                  }
                  case 49: {
                    a4 = 4;
                    break;
                  }
                  case 58: {
                    a4 = 5;
                    break;
                  }
                  case 63: {
                    a4 = 6;
                    break;
                  }
                  case 72: {
                    a4 = 7;
                    break;
                  }
                  case 83: {
                    a4 = 8;
                    break;
                  }
                  case 97: {
                    a4 = 9;
                    break;
                  }
                  case 107: {
                    a4 = 10;
                    break;
                  }
                  case 117: {
                    a4 = 11;
                    break;
                  }
                  default: {
                    e3 = 1;
                    break a;
                  }
                }
              } while (0);
              f3 = b2[22e3 + (a4 * 24 | 0) + 8 >> 2] | 0;
              c3 = b2[22e3 + (a4 * 24 | 0) + 16 >> 2] | 0;
              a4 = b2[h >> 2] | 0;
              if ((a4 | 0) != (b2[i3 >> 2] | 0)) {
                i3 = na(g2) | 0;
                a4 = b2[h >> 2] | 0;
                if (i3 | (a4 | 0) == (c3 | 0)) {
                  e3 = (e3 + 1 | 0) % 6 | 0;
                }
              }
              if ((j | 0) == 3 & (a4 | 0) == (c3 | 0)) {
                e3 = (e3 + 5 | 0) % 6 | 0;
                f3 = 22;
                break;
              }
              if ((j | 0) == 5 & (a4 | 0) == (f3 | 0)) {
                e3 = (e3 + 1 | 0) % 6 | 0;
                f3 = 22;
              } else {
                f3 = 22;
              }
            } else {
              f3 = 22;
            }
          } while (0);
        if ((f3 | 0) == 22) {
          b2[d2 >> 2] = e3;
          e3 = 0;
        }
        d2 = e3;
        T = k;
        return d2 | 0;
      }
      function Wc(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0;
        u2 = T;
        T = T + 32 | 0;
        t3 = u2 + 24 | 0;
        r3 = u2 + 20 | 0;
        p3 = u2 + 8 | 0;
        o2 = u2 + 16 | 0;
        n2 = u2;
        j = (xb(a4, c3) | 0) == 0;
        j = j ? 6 : 5;
        l2 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        l2 = l2 & 15;
        if (j >>> 0 <= d2 >>> 0) {
          e3 = 2;
          T = u2;
          return e3 | 0;
        }
        m = (l2 | 0) == 0;
        if (!m ? (q2 = wd(7, 0, (l2 ^ 15) * 3 | 0) | 0, (q2 & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0) : 0) {
          f3 = d2;
        } else {
          g2 = 4;
        }
        a:
          do {
            if ((g2 | 0) == 4) {
              f3 = (xb(a4, c3) | 0) != 0;
              if (((f3 ? 4 : 5) | 0) < (d2 | 0)) {
                e3 = 1;
                T = u2;
                return e3 | 0;
              }
              if (Vc(a4, c3, t3) | 0) {
                e3 = 1;
                T = u2;
                return e3 | 0;
              }
              g2 = (b2[t3 >> 2] | 0) + d2 | 0;
              if (f3) {
                f3 = 22288 + (((g2 | 0) % 5 | 0) << 2) | 0;
              } else {
                f3 = 22320 + (((g2 | 0) % 6 | 0) << 2) | 0;
              }
              q2 = b2[f3 >> 2] | 0;
              if ((q2 | 0) == 7) {
                e3 = 1;
                T = u2;
                return e3 | 0;
              }
              b2[r3 >> 2] = 0;
              f3 = ea(a4, c3, q2, r3, p3) | 0;
              do {
                if (!f3) {
                  i3 = p3;
                  k = b2[i3 >> 2] | 0;
                  i3 = b2[i3 + 4 >> 2] | 0;
                  h = i3 >>> 0 < c3 >>> 0 | (i3 | 0) == (c3 | 0) & k >>> 0 < a4 >>> 0;
                  g2 = h ? k : a4;
                  h = h ? i3 : c3;
                  if (!m ? (m = wd(7, 0, (l2 ^ 15) * 3 | 0) | 0, (k & m | 0) == 0 & (i3 & (H() | 0) | 0) == 0) : 0) {
                    f3 = d2;
                  } else {
                    i3 = (d2 + -1 + j | 0) % (j | 0) | 0;
                    f3 = xb(a4, c3) | 0;
                    if ((i3 | 0) < 0) {
                      I(23313, 23315, 245, 23324);
                    }
                    j = (f3 | 0) != 0;
                    if (((j ? 4 : 5) | 0) < (i3 | 0)) {
                      I(23313, 23315, 245, 23324);
                    }
                    if (Vc(a4, c3, t3) | 0) {
                      I(23313, 23315, 245, 23324);
                    }
                    f3 = (b2[t3 >> 2] | 0) + i3 | 0;
                    if (j) {
                      f3 = 22288 + (((f3 | 0) % 5 | 0) << 2) | 0;
                    } else {
                      f3 = 22320 + (((f3 | 0) % 6 | 0) << 2) | 0;
                    }
                    i3 = b2[f3 >> 2] | 0;
                    if ((i3 | 0) == 7) {
                      I(23313, 23315, 245, 23324);
                    }
                    b2[o2 >> 2] = 0;
                    f3 = ea(a4, c3, i3, o2, n2) | 0;
                    if (f3 | 0) {
                      break;
                    }
                    k = n2;
                    j = b2[k >> 2] | 0;
                    k = b2[k + 4 >> 2] | 0;
                    do {
                      if (k >>> 0 < h >>> 0 | (k | 0) == (h | 0) & j >>> 0 < g2 >>> 0) {
                        if (!(xb(j, k) | 0)) {
                          g2 = b2[22384 + ((((b2[o2 >> 2] | 0) + (b2[22352 + (i3 << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                        } else {
                          g2 = fa(j, k, a4, c3) | 0;
                        }
                        f3 = xb(j, k) | 0;
                        if ((g2 + -1 | 0) >>> 0 > 5) {
                          f3 = -1;
                          g2 = j;
                          h = k;
                          break;
                        }
                        f3 = (f3 | 0) != 0;
                        if ((g2 | 0) == 1 & f3) {
                          f3 = -1;
                          g2 = j;
                          h = k;
                          break;
                        }
                        do {
                          if (!(Vc(j, k, t3) | 0)) {
                            if (f3) {
                              f3 = ((b2[21936 + (g2 << 2) >> 2] | 0) + 5 - (b2[t3 >> 2] | 0) | 0) % 5 | 0;
                              break;
                            } else {
                              f3 = ((b2[21968 + (g2 << 2) >> 2] | 0) + 6 - (b2[t3 >> 2] | 0) | 0) % 6 | 0;
                              break;
                            }
                          } else {
                            f3 = -1;
                          }
                        } while (0);
                        g2 = j;
                        h = k;
                      } else {
                        f3 = d2;
                      }
                    } while (0);
                    i3 = p3;
                    k = b2[i3 >> 2] | 0;
                    i3 = b2[i3 + 4 >> 2] | 0;
                  }
                  if ((g2 | 0) == (k | 0) & (h | 0) == (i3 | 0)) {
                    j = (xb(k, i3) | 0) != 0;
                    if (j) {
                      a4 = fa(k, i3, a4, c3) | 0;
                    } else {
                      a4 = b2[22384 + ((((b2[r3 >> 2] | 0) + (b2[22352 + (q2 << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                    }
                    f3 = xb(k, i3) | 0;
                    if ((a4 + -1 | 0) >>> 0 <= 5 ? (s3 = (f3 | 0) != 0, !((a4 | 0) == 1 & s3)) : 0) {
                      do {
                        if (!(Vc(k, i3, t3) | 0)) {
                          if (s3) {
                            f3 = ((b2[21936 + (a4 << 2) >> 2] | 0) + 5 - (b2[t3 >> 2] | 0) | 0) % 5 | 0;
                            break;
                          } else {
                            f3 = ((b2[21968 + (a4 << 2) >> 2] | 0) + 6 - (b2[t3 >> 2] | 0) | 0) % 6 | 0;
                            break;
                          }
                        } else {
                          f3 = -1;
                        }
                      } while (0);
                    } else {
                      f3 = -1;
                    }
                    f3 = f3 + 1 | 0;
                    f3 = (f3 | 0) == 6 | j & (f3 | 0) == 5 ? 0 : f3;
                  }
                  c3 = h;
                  a4 = g2;
                  break a;
                }
              } while (0);
              e3 = f3;
              T = u2;
              return e3 | 0;
            }
          } while (0);
        s3 = wd(f3 | 0, 0, 56) | 0;
        t3 = H() | 0 | c3 & -2130706433 | 536870912;
        b2[e3 >> 2] = s3 | a4;
        b2[e3 + 4 >> 2] = t3;
        e3 = 0;
        T = u2;
        return e3 | 0;
      }
      function Xc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0;
        g2 = (xb(a4, c3) | 0) == 0;
        e3 = Wc(a4, c3, 0, d2) | 0;
        f3 = (e3 | 0) == 0;
        if (g2) {
          if (!f3) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = Wc(a4, c3, 1, d2 + 8 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = Wc(a4, c3, 2, d2 + 16 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = Wc(a4, c3, 3, d2 + 24 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = Wc(a4, c3, 4, d2 + 32 | 0) | 0;
          if (!e3) {
            return Wc(a4, c3, 5, d2 + 40 | 0) | 0;
          } else {
            g2 = e3;
            return g2 | 0;
          }
        }
        if (!f3) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = Wc(a4, c3, 1, d2 + 8 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = Wc(a4, c3, 2, d2 + 16 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = Wc(a4, c3, 3, d2 + 24 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = Wc(a4, c3, 4, d2 + 32 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        g2 = d2 + 40 | 0;
        b2[g2 >> 2] = 0;
        b2[g2 + 4 >> 2] = 0;
        g2 = 0;
        return g2 | 0;
      }
      function Yc(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        f3 = j;
        g2 = j + 168 | 0;
        h = vd(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        h = h & 7;
        i3 = c3 & -2130706433 | 134217728;
        e3 = Ob(a4, i3, g2) | 0;
        if (e3 | 0) {
          i3 = e3;
          T = j;
          return i3 | 0;
        }
        c3 = vd(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(xb(a4, i3) | 0)) {
          qb(g2, c3, h, 1, f3);
        } else {
          mb(g2, c3, h, 1, f3);
        }
        i3 = f3 + 8 | 0;
        b2[d2 >> 2] = b2[i3 >> 2];
        b2[d2 + 4 >> 2] = b2[i3 + 4 >> 2];
        b2[d2 + 8 >> 2] = b2[i3 + 8 >> 2];
        b2[d2 + 12 >> 2] = b2[i3 + 12 >> 2];
        i3 = 0;
        T = j;
        return i3 | 0;
      }
      function Zc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, e3 = 0, f3 = 0, g2 = 0;
        f3 = T;
        T = T + 16 | 0;
        d2 = f3;
        if (!(true & (c3 & 2013265920 | 0) == 536870912)) {
          e3 = 0;
          T = f3;
          return e3 | 0;
        }
        e3 = c3 & -2130706433 | 134217728;
        if (!(ub(a4, e3) | 0)) {
          e3 = 0;
          T = f3;
          return e3 | 0;
        }
        g2 = vd(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        g2 = (Wc(a4, e3, g2 & 7, d2) | 0) == 0;
        e3 = d2;
        e3 = g2 & ((b2[e3 >> 2] | 0) == (a4 | 0) ? (b2[e3 + 4 >> 2] | 0) == (c3 | 0) : 0) & 1;
        T = f3;
        return e3 | 0;
      }
      function _c(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0;
        if ((c3 | 0) > 0) {
          e3 = kd(c3, 4) | 0;
          b2[a4 >> 2] = e3;
          if (!e3) {
            I(23337, 23360, 40, 23374);
          }
        } else {
          b2[a4 >> 2] = 0;
        }
        b2[a4 + 4 >> 2] = c3;
        b2[a4 + 8 >> 2] = 0;
        b2[a4 + 12 >> 2] = d2;
        return;
      }
      function $c(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        g2 = a4 + 4 | 0;
        h = a4 + 12 | 0;
        i3 = a4 + 8 | 0;
        a:
          while (1) {
            d2 = b2[g2 >> 2] | 0;
            c3 = 0;
            while (1) {
              if ((c3 | 0) >= (d2 | 0)) {
                break a;
              }
              f3 = b2[a4 >> 2] | 0;
              j = b2[f3 + (c3 << 2) >> 2] | 0;
              if (!j) {
                c3 = c3 + 1 | 0;
              } else {
                break;
              }
            }
            c3 = f3 + (~~(+q(+(+s2(10, + +(15 - (b2[h >> 2] | 0) | 0)) * (+e2[j >> 3] + +e2[j + 8 >> 3]))) % +(d2 | 0)) >>> 0 << 2) | 0;
            d2 = b2[c3 >> 2] | 0;
            b:
              do {
                if (d2 | 0) {
                  f3 = j + 32 | 0;
                  if ((d2 | 0) == (j | 0)) {
                    b2[c3 >> 2] = b2[f3 >> 2];
                  } else {
                    d2 = d2 + 32 | 0;
                    c3 = b2[d2 >> 2] | 0;
                    if (!c3) {
                      break;
                    }
                    while (1) {
                      if ((c3 | 0) == (j | 0)) {
                        break;
                      }
                      d2 = c3 + 32 | 0;
                      c3 = b2[d2 >> 2] | 0;
                      if (!c3) {
                        break b;
                      }
                    }
                    b2[d2 >> 2] = b2[f3 >> 2];
                  }
                  jd(j);
                  b2[i3 >> 2] = (b2[i3 >> 2] | 0) + -1;
                }
              } while (0);
          }
        jd(b2[a4 >> 2] | 0);
        return;
      }
      function ad(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        e3 = b2[a4 + 4 >> 2] | 0;
        d2 = 0;
        while (1) {
          if ((d2 | 0) >= (e3 | 0)) {
            c3 = 0;
            d2 = 4;
            break;
          }
          c3 = b2[(b2[a4 >> 2] | 0) + (d2 << 2) >> 2] | 0;
          if (!c3) {
            d2 = d2 + 1 | 0;
          } else {
            d2 = 4;
            break;
          }
        }
        if ((d2 | 0) == 4) {
          return c3 | 0;
        }
        return 0;
      }
      function bd(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0, f3 = 0, g2 = 0, h = 0;
        d2 = ~~(+q(+(+s2(10, + +(15 - (b2[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a4 + 4 >> 2] | 0)) >>> 0;
        d2 = (b2[a4 >> 2] | 0) + (d2 << 2) | 0;
        f3 = b2[d2 >> 2] | 0;
        if (!f3) {
          h = 1;
          return h | 0;
        }
        h = c3 + 32 | 0;
        do {
          if ((f3 | 0) != (c3 | 0)) {
            d2 = b2[f3 + 32 >> 2] | 0;
            if (!d2) {
              h = 1;
              return h | 0;
            }
            g2 = d2;
            while (1) {
              if ((g2 | 0) == (c3 | 0)) {
                g2 = 8;
                break;
              }
              d2 = b2[g2 + 32 >> 2] | 0;
              if (!d2) {
                d2 = 1;
                g2 = 10;
                break;
              } else {
                f3 = g2;
                g2 = d2;
              }
            }
            if ((g2 | 0) == 8) {
              b2[f3 + 32 >> 2] = b2[h >> 2];
              break;
            } else if ((g2 | 0) == 10) {
              return d2 | 0;
            }
          } else {
            b2[d2 >> 2] = b2[h >> 2];
          }
        } while (0);
        jd(c3);
        h = a4 + 8 | 0;
        b2[h >> 2] = (b2[h >> 2] | 0) + -1;
        h = 0;
        return h | 0;
      }
      function cd(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = id(40) | 0;
        if (!h) {
          I(23390, 23360, 98, 23403);
        }
        b2[h >> 2] = b2[c3 >> 2];
        b2[h + 4 >> 2] = b2[c3 + 4 >> 2];
        b2[h + 8 >> 2] = b2[c3 + 8 >> 2];
        b2[h + 12 >> 2] = b2[c3 + 12 >> 2];
        g2 = h + 16 | 0;
        b2[g2 >> 2] = b2[d2 >> 2];
        b2[g2 + 4 >> 2] = b2[d2 + 4 >> 2];
        b2[g2 + 8 >> 2] = b2[d2 + 8 >> 2];
        b2[g2 + 12 >> 2] = b2[d2 + 12 >> 2];
        b2[h + 32 >> 2] = 0;
        g2 = ~~(+q(+(+s2(10, + +(15 - (b2[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a4 + 4 >> 2] | 0)) >>> 0;
        g2 = (b2[a4 >> 2] | 0) + (g2 << 2) | 0;
        f3 = b2[g2 >> 2] | 0;
        do {
          if (!f3) {
            b2[g2 >> 2] = h;
          } else {
            while (1) {
              if (_b(f3, c3) | 0 ? _b(f3 + 16 | 0, d2) | 0 : 0) {
                break;
              }
              g2 = b2[f3 + 32 >> 2] | 0;
              f3 = (g2 | 0) == 0 ? f3 : g2;
              if (!(b2[f3 + 32 >> 2] | 0)) {
                i3 = 10;
                break;
              }
            }
            if ((i3 | 0) == 10) {
              b2[f3 + 32 >> 2] = h;
              break;
            }
            jd(h);
            i3 = f3;
            return i3 | 0;
          }
        } while (0);
        i3 = a4 + 8 | 0;
        b2[i3 >> 2] = (b2[i3 >> 2] | 0) + 1;
        i3 = h;
        return i3 | 0;
      }
      function dd(a4, c3, d2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var f3 = 0, g2 = 0;
        g2 = ~~(+q(+(+s2(10, + +(15 - (b2[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a4 + 4 >> 2] | 0)) >>> 0;
        g2 = b2[(b2[a4 >> 2] | 0) + (g2 << 2) >> 2] | 0;
        if (!g2) {
          d2 = 0;
          return d2 | 0;
        }
        if (!d2) {
          a4 = g2;
          while (1) {
            if (_b(a4, c3) | 0) {
              f3 = 10;
              break;
            }
            a4 = b2[a4 + 32 >> 2] | 0;
            if (!a4) {
              a4 = 0;
              f3 = 10;
              break;
            }
          }
          if ((f3 | 0) == 10) {
            return a4 | 0;
          }
        }
        a4 = g2;
        while (1) {
          if (_b(a4, c3) | 0 ? _b(a4 + 16 | 0, d2) | 0 : 0) {
            f3 = 10;
            break;
          }
          a4 = b2[a4 + 32 >> 2] | 0;
          if (!a4) {
            a4 = 0;
            f3 = 10;
            break;
          }
        }
        if ((f3 | 0) == 10) {
          return a4 | 0;
        }
        return 0;
      }
      function ed(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        d2 = ~~(+q(+(+s2(10, + +(15 - (b2[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b2[a4 + 4 >> 2] | 0)) >>> 0;
        a4 = b2[(b2[a4 >> 2] | 0) + (d2 << 2) >> 2] | 0;
        if (!a4) {
          d2 = 0;
          return d2 | 0;
        }
        while (1) {
          if (_b(a4, c3) | 0) {
            c3 = 5;
            break;
          }
          a4 = b2[a4 + 32 >> 2] | 0;
          if (!a4) {
            a4 = 0;
            c3 = 5;
            break;
          }
        }
        if ((c3 | 0) == 5) {
          return a4 | 0;
        }
        return 0;
      }
      function fd() {
        return 23424;
      }
      function gd(a4) {
        a4 = +a4;
        return + +Cd(+a4);
      }
      function hd(a4) {
        a4 = +a4;
        return ~~+gd(a4) | 0;
      }
      function id(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0, q2 = 0, r3 = 0, s3 = 0, t3 = 0, u2 = 0, v2 = 0, w2 = 0;
        w2 = T;
        T = T + 16 | 0;
        n2 = w2;
        do {
          if (a4 >>> 0 < 245) {
            k = a4 >>> 0 < 11 ? 16 : a4 + 11 & -8;
            a4 = k >>> 3;
            m = b2[5857] | 0;
            d2 = m >>> a4;
            if (d2 & 3 | 0) {
              c3 = (d2 & 1 ^ 1) + a4 | 0;
              a4 = 23468 + (c3 << 1 << 2) | 0;
              d2 = a4 + 8 | 0;
              e3 = b2[d2 >> 2] | 0;
              f3 = e3 + 8 | 0;
              g2 = b2[f3 >> 2] | 0;
              if ((g2 | 0) == (a4 | 0)) {
                b2[5857] = m & ~(1 << c3);
              } else {
                b2[g2 + 12 >> 2] = a4;
                b2[d2 >> 2] = g2;
              }
              v2 = c3 << 3;
              b2[e3 + 4 >> 2] = v2 | 3;
              v2 = e3 + v2 + 4 | 0;
              b2[v2 >> 2] = b2[v2 >> 2] | 1;
              v2 = f3;
              T = w2;
              return v2 | 0;
            }
            l2 = b2[5859] | 0;
            if (k >>> 0 > l2 >>> 0) {
              if (d2 | 0) {
                c3 = 2 << a4;
                c3 = d2 << a4 & (c3 | 0 - c3);
                c3 = (c3 & 0 - c3) + -1 | 0;
                i3 = c3 >>> 12 & 16;
                c3 = c3 >>> i3;
                d2 = c3 >>> 5 & 8;
                c3 = c3 >>> d2;
                g2 = c3 >>> 2 & 4;
                c3 = c3 >>> g2;
                a4 = c3 >>> 1 & 2;
                c3 = c3 >>> a4;
                e3 = c3 >>> 1 & 1;
                e3 = (d2 | i3 | g2 | a4 | e3) + (c3 >>> e3) | 0;
                c3 = 23468 + (e3 << 1 << 2) | 0;
                a4 = c3 + 8 | 0;
                g2 = b2[a4 >> 2] | 0;
                i3 = g2 + 8 | 0;
                d2 = b2[i3 >> 2] | 0;
                if ((d2 | 0) == (c3 | 0)) {
                  a4 = m & ~(1 << e3);
                  b2[5857] = a4;
                } else {
                  b2[d2 + 12 >> 2] = c3;
                  b2[a4 >> 2] = d2;
                  a4 = m;
                }
                v2 = e3 << 3;
                h = v2 - k | 0;
                b2[g2 + 4 >> 2] = k | 3;
                f3 = g2 + k | 0;
                b2[f3 + 4 >> 2] = h | 1;
                b2[g2 + v2 >> 2] = h;
                if (l2 | 0) {
                  e3 = b2[5862] | 0;
                  c3 = l2 >>> 3;
                  d2 = 23468 + (c3 << 1 << 2) | 0;
                  c3 = 1 << c3;
                  if (!(a4 & c3)) {
                    b2[5857] = a4 | c3;
                    c3 = d2;
                    a4 = d2 + 8 | 0;
                  } else {
                    a4 = d2 + 8 | 0;
                    c3 = b2[a4 >> 2] | 0;
                  }
                  b2[a4 >> 2] = e3;
                  b2[c3 + 12 >> 2] = e3;
                  b2[e3 + 8 >> 2] = c3;
                  b2[e3 + 12 >> 2] = d2;
                }
                b2[5859] = h;
                b2[5862] = f3;
                v2 = i3;
                T = w2;
                return v2 | 0;
              }
              g2 = b2[5858] | 0;
              if (g2) {
                d2 = (g2 & 0 - g2) + -1 | 0;
                f3 = d2 >>> 12 & 16;
                d2 = d2 >>> f3;
                e3 = d2 >>> 5 & 8;
                d2 = d2 >>> e3;
                h = d2 >>> 2 & 4;
                d2 = d2 >>> h;
                i3 = d2 >>> 1 & 2;
                d2 = d2 >>> i3;
                j = d2 >>> 1 & 1;
                j = b2[23732 + ((e3 | f3 | h | i3 | j) + (d2 >>> j) << 2) >> 2] | 0;
                d2 = j;
                i3 = j;
                j = (b2[j + 4 >> 2] & -8) - k | 0;
                while (1) {
                  a4 = b2[d2 + 16 >> 2] | 0;
                  if (!a4) {
                    a4 = b2[d2 + 20 >> 2] | 0;
                    if (!a4) {
                      break;
                    }
                  }
                  h = (b2[a4 + 4 >> 2] & -8) - k | 0;
                  f3 = h >>> 0 < j >>> 0;
                  d2 = a4;
                  i3 = f3 ? a4 : i3;
                  j = f3 ? h : j;
                }
                h = i3 + k | 0;
                if (h >>> 0 > i3 >>> 0) {
                  f3 = b2[i3 + 24 >> 2] | 0;
                  c3 = b2[i3 + 12 >> 2] | 0;
                  do {
                    if ((c3 | 0) == (i3 | 0)) {
                      a4 = i3 + 20 | 0;
                      c3 = b2[a4 >> 2] | 0;
                      if (!c3) {
                        a4 = i3 + 16 | 0;
                        c3 = b2[a4 >> 2] | 0;
                        if (!c3) {
                          d2 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e3 = c3 + 20 | 0;
                        d2 = b2[e3 >> 2] | 0;
                        if (!d2) {
                          e3 = c3 + 16 | 0;
                          d2 = b2[e3 >> 2] | 0;
                          if (!d2) {
                            break;
                          } else {
                            c3 = d2;
                            a4 = e3;
                          }
                        } else {
                          c3 = d2;
                          a4 = e3;
                        }
                      }
                      b2[a4 >> 2] = 0;
                      d2 = c3;
                    } else {
                      d2 = b2[i3 + 8 >> 2] | 0;
                      b2[d2 + 12 >> 2] = c3;
                      b2[c3 + 8 >> 2] = d2;
                      d2 = c3;
                    }
                  } while (0);
                  do {
                    if (f3 | 0) {
                      c3 = b2[i3 + 28 >> 2] | 0;
                      a4 = 23732 + (c3 << 2) | 0;
                      if ((i3 | 0) == (b2[a4 >> 2] | 0)) {
                        b2[a4 >> 2] = d2;
                        if (!d2) {
                          b2[5858] = g2 & ~(1 << c3);
                          break;
                        }
                      } else {
                        v2 = f3 + 16 | 0;
                        b2[((b2[v2 >> 2] | 0) == (i3 | 0) ? v2 : f3 + 20 | 0) >> 2] = d2;
                        if (!d2) {
                          break;
                        }
                      }
                      b2[d2 + 24 >> 2] = f3;
                      c3 = b2[i3 + 16 >> 2] | 0;
                      if (c3 | 0) {
                        b2[d2 + 16 >> 2] = c3;
                        b2[c3 + 24 >> 2] = d2;
                      }
                      c3 = b2[i3 + 20 >> 2] | 0;
                      if (c3 | 0) {
                        b2[d2 + 20 >> 2] = c3;
                        b2[c3 + 24 >> 2] = d2;
                      }
                    }
                  } while (0);
                  if (j >>> 0 < 16) {
                    v2 = j + k | 0;
                    b2[i3 + 4 >> 2] = v2 | 3;
                    v2 = i3 + v2 + 4 | 0;
                    b2[v2 >> 2] = b2[v2 >> 2] | 1;
                  } else {
                    b2[i3 + 4 >> 2] = k | 3;
                    b2[h + 4 >> 2] = j | 1;
                    b2[h + j >> 2] = j;
                    if (l2 | 0) {
                      e3 = b2[5862] | 0;
                      c3 = l2 >>> 3;
                      d2 = 23468 + (c3 << 1 << 2) | 0;
                      c3 = 1 << c3;
                      if (!(c3 & m)) {
                        b2[5857] = c3 | m;
                        c3 = d2;
                        a4 = d2 + 8 | 0;
                      } else {
                        a4 = d2 + 8 | 0;
                        c3 = b2[a4 >> 2] | 0;
                      }
                      b2[a4 >> 2] = e3;
                      b2[c3 + 12 >> 2] = e3;
                      b2[e3 + 8 >> 2] = c3;
                      b2[e3 + 12 >> 2] = d2;
                    }
                    b2[5859] = j;
                    b2[5862] = h;
                  }
                  v2 = i3 + 8 | 0;
                  T = w2;
                  return v2 | 0;
                } else {
                  m = k;
                }
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else if (a4 >>> 0 <= 4294967231) {
            a4 = a4 + 11 | 0;
            k = a4 & -8;
            e3 = b2[5858] | 0;
            if (e3) {
              f3 = 0 - k | 0;
              a4 = a4 >>> 8;
              if (a4) {
                if (k >>> 0 > 16777215) {
                  j = 31;
                } else {
                  m = (a4 + 1048320 | 0) >>> 16 & 8;
                  q2 = a4 << m;
                  i3 = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i3;
                  j = (q2 + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i3 | m | j) + (q2 << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else {
                j = 0;
              }
              d2 = b2[23732 + (j << 2) >> 2] | 0;
              a:
                do {
                  if (!d2) {
                    d2 = 0;
                    a4 = 0;
                    q2 = 61;
                  } else {
                    a4 = 0;
                    i3 = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                    g2 = 0;
                    while (1) {
                      h = (b2[d2 + 4 >> 2] & -8) - k | 0;
                      if (h >>> 0 < f3 >>> 0) {
                        if (!h) {
                          a4 = d2;
                          f3 = 0;
                          q2 = 65;
                          break a;
                        } else {
                          a4 = d2;
                          f3 = h;
                        }
                      }
                      q2 = b2[d2 + 20 >> 2] | 0;
                      d2 = b2[d2 + 16 + (i3 >>> 31 << 2) >> 2] | 0;
                      g2 = (q2 | 0) == 0 | (q2 | 0) == (d2 | 0) ? g2 : q2;
                      if (!d2) {
                        d2 = g2;
                        q2 = 61;
                        break;
                      } else {
                        i3 = i3 << 1;
                      }
                    }
                  }
                } while (0);
              if ((q2 | 0) == 61) {
                if ((d2 | 0) == 0 & (a4 | 0) == 0) {
                  a4 = 2 << j;
                  a4 = (a4 | 0 - a4) & e3;
                  if (!a4) {
                    m = k;
                    break;
                  }
                  m = (a4 & 0 - a4) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g2 = m >>> 5 & 8;
                  m = m >>> g2;
                  i3 = m >>> 2 & 4;
                  m = m >>> i3;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d2 = m >>> 1 & 1;
                  a4 = 0;
                  d2 = b2[23732 + ((g2 | h | i3 | j | d2) + (m >>> d2) << 2) >> 2] | 0;
                }
                if (!d2) {
                  i3 = a4;
                  h = f3;
                } else {
                  q2 = 65;
                }
              }
              if ((q2 | 0) == 65) {
                g2 = d2;
                while (1) {
                  m = (b2[g2 + 4 >> 2] & -8) - k | 0;
                  d2 = m >>> 0 < f3 >>> 0;
                  f3 = d2 ? m : f3;
                  a4 = d2 ? g2 : a4;
                  d2 = b2[g2 + 16 >> 2] | 0;
                  if (!d2) {
                    d2 = b2[g2 + 20 >> 2] | 0;
                  }
                  if (!d2) {
                    i3 = a4;
                    h = f3;
                    break;
                  } else {
                    g2 = d2;
                  }
                }
              }
              if (((i3 | 0) != 0 ? h >>> 0 < ((b2[5859] | 0) - k | 0) >>> 0 : 0) ? (l2 = i3 + k | 0, l2 >>> 0 > i3 >>> 0) : 0) {
                g2 = b2[i3 + 24 >> 2] | 0;
                c3 = b2[i3 + 12 >> 2] | 0;
                do {
                  if ((c3 | 0) == (i3 | 0)) {
                    a4 = i3 + 20 | 0;
                    c3 = b2[a4 >> 2] | 0;
                    if (!c3) {
                      a4 = i3 + 16 | 0;
                      c3 = b2[a4 >> 2] | 0;
                      if (!c3) {
                        c3 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f3 = c3 + 20 | 0;
                      d2 = b2[f3 >> 2] | 0;
                      if (!d2) {
                        f3 = c3 + 16 | 0;
                        d2 = b2[f3 >> 2] | 0;
                        if (!d2) {
                          break;
                        } else {
                          c3 = d2;
                          a4 = f3;
                        }
                      } else {
                        c3 = d2;
                        a4 = f3;
                      }
                    }
                    b2[a4 >> 2] = 0;
                  } else {
                    v2 = b2[i3 + 8 >> 2] | 0;
                    b2[v2 + 12 >> 2] = c3;
                    b2[c3 + 8 >> 2] = v2;
                  }
                } while (0);
                do {
                  if (g2) {
                    a4 = b2[i3 + 28 >> 2] | 0;
                    d2 = 23732 + (a4 << 2) | 0;
                    if ((i3 | 0) == (b2[d2 >> 2] | 0)) {
                      b2[d2 >> 2] = c3;
                      if (!c3) {
                        e3 = e3 & ~(1 << a4);
                        b2[5858] = e3;
                        break;
                      }
                    } else {
                      v2 = g2 + 16 | 0;
                      b2[((b2[v2 >> 2] | 0) == (i3 | 0) ? v2 : g2 + 20 | 0) >> 2] = c3;
                      if (!c3) {
                        break;
                      }
                    }
                    b2[c3 + 24 >> 2] = g2;
                    a4 = b2[i3 + 16 >> 2] | 0;
                    if (a4 | 0) {
                      b2[c3 + 16 >> 2] = a4;
                      b2[a4 + 24 >> 2] = c3;
                    }
                    a4 = b2[i3 + 20 >> 2] | 0;
                    if (a4) {
                      b2[c3 + 20 >> 2] = a4;
                      b2[a4 + 24 >> 2] = c3;
                    }
                  }
                } while (0);
                b:
                  do {
                    if (h >>> 0 < 16) {
                      v2 = h + k | 0;
                      b2[i3 + 4 >> 2] = v2 | 3;
                      v2 = i3 + v2 + 4 | 0;
                      b2[v2 >> 2] = b2[v2 >> 2] | 1;
                    } else {
                      b2[i3 + 4 >> 2] = k | 3;
                      b2[l2 + 4 >> 2] = h | 1;
                      b2[l2 + h >> 2] = h;
                      c3 = h >>> 3;
                      if (h >>> 0 < 256) {
                        d2 = 23468 + (c3 << 1 << 2) | 0;
                        a4 = b2[5857] | 0;
                        c3 = 1 << c3;
                        if (!(a4 & c3)) {
                          b2[5857] = a4 | c3;
                          c3 = d2;
                          a4 = d2 + 8 | 0;
                        } else {
                          a4 = d2 + 8 | 0;
                          c3 = b2[a4 >> 2] | 0;
                        }
                        b2[a4 >> 2] = l2;
                        b2[c3 + 12 >> 2] = l2;
                        b2[l2 + 8 >> 2] = c3;
                        b2[l2 + 12 >> 2] = d2;
                        break;
                      }
                      c3 = h >>> 8;
                      if (c3) {
                        if (h >>> 0 > 16777215) {
                          d2 = 31;
                        } else {
                          u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                          v2 = c3 << u2;
                          t3 = (v2 + 520192 | 0) >>> 16 & 4;
                          v2 = v2 << t3;
                          d2 = (v2 + 245760 | 0) >>> 16 & 2;
                          d2 = 14 - (t3 | u2 | d2) + (v2 << d2 >>> 15) | 0;
                          d2 = h >>> (d2 + 7 | 0) & 1 | d2 << 1;
                        }
                      } else {
                        d2 = 0;
                      }
                      c3 = 23732 + (d2 << 2) | 0;
                      b2[l2 + 28 >> 2] = d2;
                      a4 = l2 + 16 | 0;
                      b2[a4 + 4 >> 2] = 0;
                      b2[a4 >> 2] = 0;
                      a4 = 1 << d2;
                      if (!(e3 & a4)) {
                        b2[5858] = e3 | a4;
                        b2[c3 >> 2] = l2;
                        b2[l2 + 24 >> 2] = c3;
                        b2[l2 + 12 >> 2] = l2;
                        b2[l2 + 8 >> 2] = l2;
                        break;
                      }
                      c3 = b2[c3 >> 2] | 0;
                      c:
                        do {
                          if ((b2[c3 + 4 >> 2] & -8 | 0) != (h | 0)) {
                            e3 = h << ((d2 | 0) == 31 ? 0 : 25 - (d2 >>> 1) | 0);
                            while (1) {
                              d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                              a4 = b2[d2 >> 2] | 0;
                              if (!a4) {
                                break;
                              }
                              if ((b2[a4 + 4 >> 2] & -8 | 0) == (h | 0)) {
                                c3 = a4;
                                break c;
                              } else {
                                e3 = e3 << 1;
                                c3 = a4;
                              }
                            }
                            b2[d2 >> 2] = l2;
                            b2[l2 + 24 >> 2] = c3;
                            b2[l2 + 12 >> 2] = l2;
                            b2[l2 + 8 >> 2] = l2;
                            break b;
                          }
                        } while (0);
                      u2 = c3 + 8 | 0;
                      v2 = b2[u2 >> 2] | 0;
                      b2[v2 + 12 >> 2] = l2;
                      b2[u2 >> 2] = l2;
                      b2[l2 + 8 >> 2] = v2;
                      b2[l2 + 12 >> 2] = c3;
                      b2[l2 + 24 >> 2] = 0;
                    }
                  } while (0);
                v2 = i3 + 8 | 0;
                T = w2;
                return v2 | 0;
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else {
            m = -1;
          }
        } while (0);
        d2 = b2[5859] | 0;
        if (d2 >>> 0 >= m >>> 0) {
          c3 = d2 - m | 0;
          a4 = b2[5862] | 0;
          if (c3 >>> 0 > 15) {
            v2 = a4 + m | 0;
            b2[5862] = v2;
            b2[5859] = c3;
            b2[v2 + 4 >> 2] = c3 | 1;
            b2[a4 + d2 >> 2] = c3;
            b2[a4 + 4 >> 2] = m | 3;
          } else {
            b2[5859] = 0;
            b2[5862] = 0;
            b2[a4 + 4 >> 2] = d2 | 3;
            v2 = a4 + d2 + 4 | 0;
            b2[v2 >> 2] = b2[v2 >> 2] | 1;
          }
          v2 = a4 + 8 | 0;
          T = w2;
          return v2 | 0;
        }
        h = b2[5860] | 0;
        if (h >>> 0 > m >>> 0) {
          t3 = h - m | 0;
          b2[5860] = t3;
          v2 = b2[5863] | 0;
          u2 = v2 + m | 0;
          b2[5863] = u2;
          b2[u2 + 4 >> 2] = t3 | 1;
          b2[v2 + 4 >> 2] = m | 3;
          v2 = v2 + 8 | 0;
          T = w2;
          return v2 | 0;
        }
        if (!(b2[5975] | 0)) {
          b2[5977] = 4096;
          b2[5976] = 4096;
          b2[5978] = -1;
          b2[5979] = -1;
          b2[5980] = 0;
          b2[5968] = 0;
          b2[5975] = n2 & -16 ^ 1431655768;
          a4 = 4096;
        } else {
          a4 = b2[5977] | 0;
        }
        i3 = m + 48 | 0;
        j = m + 47 | 0;
        g2 = a4 + j | 0;
        f3 = 0 - a4 | 0;
        k = g2 & f3;
        if (k >>> 0 <= m >>> 0) {
          v2 = 0;
          T = w2;
          return v2 | 0;
        }
        a4 = b2[5967] | 0;
        if (a4 | 0 ? (l2 = b2[5965] | 0, n2 = l2 + k | 0, n2 >>> 0 <= l2 >>> 0 | n2 >>> 0 > a4 >>> 0) : 0) {
          v2 = 0;
          T = w2;
          return v2 | 0;
        }
        d:
          do {
            if (!(b2[5968] & 4)) {
              d2 = b2[5863] | 0;
              e:
                do {
                  if (d2) {
                    e3 = 23876;
                    while (1) {
                      n2 = b2[e3 >> 2] | 0;
                      if (n2 >>> 0 <= d2 >>> 0 ? (n2 + (b2[e3 + 4 >> 2] | 0) | 0) >>> 0 > d2 >>> 0 : 0) {
                        break;
                      }
                      a4 = b2[e3 + 8 >> 2] | 0;
                      if (!a4) {
                        q2 = 128;
                        break e;
                      } else {
                        e3 = a4;
                      }
                    }
                    c3 = g2 - h & f3;
                    if (c3 >>> 0 < 2147483647) {
                      a4 = Dd(c3 | 0) | 0;
                      if ((a4 | 0) == ((b2[e3 >> 2] | 0) + (b2[e3 + 4 >> 2] | 0) | 0)) {
                        if ((a4 | 0) != (-1 | 0)) {
                          h = c3;
                          g2 = a4;
                          q2 = 145;
                          break d;
                        }
                      } else {
                        e3 = a4;
                        q2 = 136;
                      }
                    } else {
                      c3 = 0;
                    }
                  } else {
                    q2 = 128;
                  }
                } while (0);
              do {
                if ((q2 | 0) == 128) {
                  d2 = Dd(0) | 0;
                  if ((d2 | 0) != (-1 | 0) ? (c3 = d2, o2 = b2[5976] | 0, p3 = o2 + -1 | 0, c3 = ((p3 & c3 | 0) == 0 ? 0 : (p3 + c3 & 0 - o2) - c3 | 0) + k | 0, o2 = b2[5965] | 0, p3 = c3 + o2 | 0, c3 >>> 0 > m >>> 0 & c3 >>> 0 < 2147483647) : 0) {
                    n2 = b2[5967] | 0;
                    if (n2 | 0 ? p3 >>> 0 <= o2 >>> 0 | p3 >>> 0 > n2 >>> 0 : 0) {
                      c3 = 0;
                      break;
                    }
                    a4 = Dd(c3 | 0) | 0;
                    if ((a4 | 0) == (d2 | 0)) {
                      h = c3;
                      g2 = d2;
                      q2 = 145;
                      break d;
                    } else {
                      e3 = a4;
                      q2 = 136;
                    }
                  } else {
                    c3 = 0;
                  }
                }
              } while (0);
              do {
                if ((q2 | 0) == 136) {
                  d2 = 0 - c3 | 0;
                  if (!(i3 >>> 0 > c3 >>> 0 & (c3 >>> 0 < 2147483647 & (e3 | 0) != (-1 | 0)))) {
                    if ((e3 | 0) == (-1 | 0)) {
                      c3 = 0;
                      break;
                    } else {
                      h = c3;
                      g2 = e3;
                      q2 = 145;
                      break d;
                    }
                  }
                  a4 = b2[5977] | 0;
                  a4 = j - c3 + a4 & 0 - a4;
                  if (a4 >>> 0 >= 2147483647) {
                    h = c3;
                    g2 = e3;
                    q2 = 145;
                    break d;
                  }
                  if ((Dd(a4 | 0) | 0) == (-1 | 0)) {
                    Dd(d2 | 0) | 0;
                    c3 = 0;
                    break;
                  } else {
                    h = a4 + c3 | 0;
                    g2 = e3;
                    q2 = 145;
                    break d;
                  }
                }
              } while (0);
              b2[5968] = b2[5968] | 4;
              q2 = 143;
            } else {
              c3 = 0;
              q2 = 143;
            }
          } while (0);
        if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t3 = Dd(k | 0) | 0, p3 = Dd(0) | 0, r3 = p3 - t3 | 0, s3 = r3 >>> 0 > (m + 40 | 0) >>> 0, !((t3 | 0) == (-1 | 0) | s3 ^ 1 | t3 >>> 0 < p3 >>> 0 & ((t3 | 0) != (-1 | 0) & (p3 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h = s3 ? r3 : c3;
          g2 = t3;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          c3 = (b2[5965] | 0) + h | 0;
          b2[5965] = c3;
          if (c3 >>> 0 > (b2[5966] | 0) >>> 0) {
            b2[5966] = c3;
          }
          j = b2[5863] | 0;
          f:
            do {
              if (j) {
                c3 = 23876;
                while (1) {
                  a4 = b2[c3 >> 2] | 0;
                  d2 = b2[c3 + 4 >> 2] | 0;
                  if ((g2 | 0) == (a4 + d2 | 0)) {
                    q2 = 154;
                    break;
                  }
                  e3 = b2[c3 + 8 >> 2] | 0;
                  if (!e3) {
                    break;
                  } else {
                    c3 = e3;
                  }
                }
                if (((q2 | 0) == 154 ? (u2 = c3 + 4 | 0, (b2[c3 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a4 >>> 0 <= j >>> 0 : 0) {
                  b2[u2 >> 2] = d2 + h;
                  v2 = (b2[5860] | 0) + h | 0;
                  t3 = j + 8 | 0;
                  t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                  u2 = j + t3 | 0;
                  t3 = v2 - t3 | 0;
                  b2[5863] = u2;
                  b2[5860] = t3;
                  b2[u2 + 4 >> 2] = t3 | 1;
                  b2[j + v2 + 4 >> 2] = 40;
                  b2[5864] = b2[5979];
                  break;
                }
                if (g2 >>> 0 < (b2[5861] | 0) >>> 0) {
                  b2[5861] = g2;
                }
                d2 = g2 + h | 0;
                c3 = 23876;
                while (1) {
                  if ((b2[c3 >> 2] | 0) == (d2 | 0)) {
                    q2 = 162;
                    break;
                  }
                  a4 = b2[c3 + 8 >> 2] | 0;
                  if (!a4) {
                    break;
                  } else {
                    c3 = a4;
                  }
                }
                if ((q2 | 0) == 162 ? (b2[c3 + 12 >> 2] & 8 | 0) == 0 : 0) {
                  b2[c3 >> 2] = g2;
                  l2 = c3 + 4 | 0;
                  b2[l2 >> 2] = (b2[l2 >> 2] | 0) + h;
                  l2 = g2 + 8 | 0;
                  l2 = g2 + ((l2 & 7 | 0) == 0 ? 0 : 0 - l2 & 7) | 0;
                  c3 = d2 + 8 | 0;
                  c3 = d2 + ((c3 & 7 | 0) == 0 ? 0 : 0 - c3 & 7) | 0;
                  k = l2 + m | 0;
                  i3 = c3 - l2 - m | 0;
                  b2[l2 + 4 >> 2] = m | 3;
                  g:
                    do {
                      if ((j | 0) == (c3 | 0)) {
                        v2 = (b2[5860] | 0) + i3 | 0;
                        b2[5860] = v2;
                        b2[5863] = k;
                        b2[k + 4 >> 2] = v2 | 1;
                      } else {
                        if ((b2[5862] | 0) == (c3 | 0)) {
                          v2 = (b2[5859] | 0) + i3 | 0;
                          b2[5859] = v2;
                          b2[5862] = k;
                          b2[k + 4 >> 2] = v2 | 1;
                          b2[k + v2 >> 2] = v2;
                          break;
                        }
                        a4 = b2[c3 + 4 >> 2] | 0;
                        if ((a4 & 3 | 0) == 1) {
                          h = a4 & -8;
                          e3 = a4 >>> 3;
                          h:
                            do {
                              if (a4 >>> 0 < 256) {
                                a4 = b2[c3 + 8 >> 2] | 0;
                                d2 = b2[c3 + 12 >> 2] | 0;
                                if ((d2 | 0) == (a4 | 0)) {
                                  b2[5857] = b2[5857] & ~(1 << e3);
                                  break;
                                } else {
                                  b2[a4 + 12 >> 2] = d2;
                                  b2[d2 + 8 >> 2] = a4;
                                  break;
                                }
                              } else {
                                g2 = b2[c3 + 24 >> 2] | 0;
                                a4 = b2[c3 + 12 >> 2] | 0;
                                do {
                                  if ((a4 | 0) == (c3 | 0)) {
                                    d2 = c3 + 16 | 0;
                                    e3 = d2 + 4 | 0;
                                    a4 = b2[e3 >> 2] | 0;
                                    if (!a4) {
                                      a4 = b2[d2 >> 2] | 0;
                                      if (!a4) {
                                        a4 = 0;
                                        break;
                                      }
                                    } else {
                                      d2 = e3;
                                    }
                                    while (1) {
                                      f3 = a4 + 20 | 0;
                                      e3 = b2[f3 >> 2] | 0;
                                      if (!e3) {
                                        f3 = a4 + 16 | 0;
                                        e3 = b2[f3 >> 2] | 0;
                                        if (!e3) {
                                          break;
                                        } else {
                                          a4 = e3;
                                          d2 = f3;
                                        }
                                      } else {
                                        a4 = e3;
                                        d2 = f3;
                                      }
                                    }
                                    b2[d2 >> 2] = 0;
                                  } else {
                                    v2 = b2[c3 + 8 >> 2] | 0;
                                    b2[v2 + 12 >> 2] = a4;
                                    b2[a4 + 8 >> 2] = v2;
                                  }
                                } while (0);
                                if (!g2) {
                                  break;
                                }
                                d2 = b2[c3 + 28 >> 2] | 0;
                                e3 = 23732 + (d2 << 2) | 0;
                                do {
                                  if ((b2[e3 >> 2] | 0) != (c3 | 0)) {
                                    v2 = g2 + 16 | 0;
                                    b2[((b2[v2 >> 2] | 0) == (c3 | 0) ? v2 : g2 + 20 | 0) >> 2] = a4;
                                    if (!a4) {
                                      break h;
                                    }
                                  } else {
                                    b2[e3 >> 2] = a4;
                                    if (a4 | 0) {
                                      break;
                                    }
                                    b2[5858] = b2[5858] & ~(1 << d2);
                                    break h;
                                  }
                                } while (0);
                                b2[a4 + 24 >> 2] = g2;
                                d2 = c3 + 16 | 0;
                                e3 = b2[d2 >> 2] | 0;
                                if (e3 | 0) {
                                  b2[a4 + 16 >> 2] = e3;
                                  b2[e3 + 24 >> 2] = a4;
                                }
                                d2 = b2[d2 + 4 >> 2] | 0;
                                if (!d2) {
                                  break;
                                }
                                b2[a4 + 20 >> 2] = d2;
                                b2[d2 + 24 >> 2] = a4;
                              }
                            } while (0);
                          c3 = c3 + h | 0;
                          f3 = h + i3 | 0;
                        } else {
                          f3 = i3;
                        }
                        c3 = c3 + 4 | 0;
                        b2[c3 >> 2] = b2[c3 >> 2] & -2;
                        b2[k + 4 >> 2] = f3 | 1;
                        b2[k + f3 >> 2] = f3;
                        c3 = f3 >>> 3;
                        if (f3 >>> 0 < 256) {
                          d2 = 23468 + (c3 << 1 << 2) | 0;
                          a4 = b2[5857] | 0;
                          c3 = 1 << c3;
                          if (!(a4 & c3)) {
                            b2[5857] = a4 | c3;
                            c3 = d2;
                            a4 = d2 + 8 | 0;
                          } else {
                            a4 = d2 + 8 | 0;
                            c3 = b2[a4 >> 2] | 0;
                          }
                          b2[a4 >> 2] = k;
                          b2[c3 + 12 >> 2] = k;
                          b2[k + 8 >> 2] = c3;
                          b2[k + 12 >> 2] = d2;
                          break;
                        }
                        c3 = f3 >>> 8;
                        do {
                          if (!c3) {
                            e3 = 0;
                          } else {
                            if (f3 >>> 0 > 16777215) {
                              e3 = 31;
                              break;
                            }
                            u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                            v2 = c3 << u2;
                            t3 = (v2 + 520192 | 0) >>> 16 & 4;
                            v2 = v2 << t3;
                            e3 = (v2 + 245760 | 0) >>> 16 & 2;
                            e3 = 14 - (t3 | u2 | e3) + (v2 << e3 >>> 15) | 0;
                            e3 = f3 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                          }
                        } while (0);
                        c3 = 23732 + (e3 << 2) | 0;
                        b2[k + 28 >> 2] = e3;
                        a4 = k + 16 | 0;
                        b2[a4 + 4 >> 2] = 0;
                        b2[a4 >> 2] = 0;
                        a4 = b2[5858] | 0;
                        d2 = 1 << e3;
                        if (!(a4 & d2)) {
                          b2[5858] = a4 | d2;
                          b2[c3 >> 2] = k;
                          b2[k + 24 >> 2] = c3;
                          b2[k + 12 >> 2] = k;
                          b2[k + 8 >> 2] = k;
                          break;
                        }
                        c3 = b2[c3 >> 2] | 0;
                        i:
                          do {
                            if ((b2[c3 + 4 >> 2] & -8 | 0) != (f3 | 0)) {
                              e3 = f3 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                              while (1) {
                                d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                                a4 = b2[d2 >> 2] | 0;
                                if (!a4) {
                                  break;
                                }
                                if ((b2[a4 + 4 >> 2] & -8 | 0) == (f3 | 0)) {
                                  c3 = a4;
                                  break i;
                                } else {
                                  e3 = e3 << 1;
                                  c3 = a4;
                                }
                              }
                              b2[d2 >> 2] = k;
                              b2[k + 24 >> 2] = c3;
                              b2[k + 12 >> 2] = k;
                              b2[k + 8 >> 2] = k;
                              break g;
                            }
                          } while (0);
                        u2 = c3 + 8 | 0;
                        v2 = b2[u2 >> 2] | 0;
                        b2[v2 + 12 >> 2] = k;
                        b2[u2 >> 2] = k;
                        b2[k + 8 >> 2] = v2;
                        b2[k + 12 >> 2] = c3;
                        b2[k + 24 >> 2] = 0;
                      }
                    } while (0);
                  v2 = l2 + 8 | 0;
                  T = w2;
                  return v2 | 0;
                }
                c3 = 23876;
                while (1) {
                  a4 = b2[c3 >> 2] | 0;
                  if (a4 >>> 0 <= j >>> 0 ? (v2 = a4 + (b2[c3 + 4 >> 2] | 0) | 0, v2 >>> 0 > j >>> 0) : 0) {
                    break;
                  }
                  c3 = b2[c3 + 8 >> 2] | 0;
                }
                f3 = v2 + -47 | 0;
                a4 = f3 + 8 | 0;
                a4 = f3 + ((a4 & 7 | 0) == 0 ? 0 : 0 - a4 & 7) | 0;
                f3 = j + 16 | 0;
                a4 = a4 >>> 0 < f3 >>> 0 ? j : a4;
                c3 = a4 + 8 | 0;
                d2 = h + -40 | 0;
                t3 = g2 + 8 | 0;
                t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                u2 = g2 + t3 | 0;
                t3 = d2 - t3 | 0;
                b2[5863] = u2;
                b2[5860] = t3;
                b2[u2 + 4 >> 2] = t3 | 1;
                b2[g2 + d2 + 4 >> 2] = 40;
                b2[5864] = b2[5979];
                d2 = a4 + 4 | 0;
                b2[d2 >> 2] = 27;
                b2[c3 >> 2] = b2[5969];
                b2[c3 + 4 >> 2] = b2[5970];
                b2[c3 + 8 >> 2] = b2[5971];
                b2[c3 + 12 >> 2] = b2[5972];
                b2[5969] = g2;
                b2[5970] = h;
                b2[5972] = 0;
                b2[5971] = c3;
                c3 = a4 + 24 | 0;
                do {
                  u2 = c3;
                  c3 = c3 + 4 | 0;
                  b2[c3 >> 2] = 7;
                } while ((u2 + 8 | 0) >>> 0 < v2 >>> 0);
                if ((a4 | 0) != (j | 0)) {
                  g2 = a4 - j | 0;
                  b2[d2 >> 2] = b2[d2 >> 2] & -2;
                  b2[j + 4 >> 2] = g2 | 1;
                  b2[a4 >> 2] = g2;
                  c3 = g2 >>> 3;
                  if (g2 >>> 0 < 256) {
                    d2 = 23468 + (c3 << 1 << 2) | 0;
                    a4 = b2[5857] | 0;
                    c3 = 1 << c3;
                    if (!(a4 & c3)) {
                      b2[5857] = a4 | c3;
                      c3 = d2;
                      a4 = d2 + 8 | 0;
                    } else {
                      a4 = d2 + 8 | 0;
                      c3 = b2[a4 >> 2] | 0;
                    }
                    b2[a4 >> 2] = j;
                    b2[c3 + 12 >> 2] = j;
                    b2[j + 8 >> 2] = c3;
                    b2[j + 12 >> 2] = d2;
                    break;
                  }
                  c3 = g2 >>> 8;
                  if (c3) {
                    if (g2 >>> 0 > 16777215) {
                      e3 = 31;
                    } else {
                      u2 = (c3 + 1048320 | 0) >>> 16 & 8;
                      v2 = c3 << u2;
                      t3 = (v2 + 520192 | 0) >>> 16 & 4;
                      v2 = v2 << t3;
                      e3 = (v2 + 245760 | 0) >>> 16 & 2;
                      e3 = 14 - (t3 | u2 | e3) + (v2 << e3 >>> 15) | 0;
                      e3 = g2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                    }
                  } else {
                    e3 = 0;
                  }
                  d2 = 23732 + (e3 << 2) | 0;
                  b2[j + 28 >> 2] = e3;
                  b2[j + 20 >> 2] = 0;
                  b2[f3 >> 2] = 0;
                  c3 = b2[5858] | 0;
                  a4 = 1 << e3;
                  if (!(c3 & a4)) {
                    b2[5858] = c3 | a4;
                    b2[d2 >> 2] = j;
                    b2[j + 24 >> 2] = d2;
                    b2[j + 12 >> 2] = j;
                    b2[j + 8 >> 2] = j;
                    break;
                  }
                  c3 = b2[d2 >> 2] | 0;
                  j:
                    do {
                      if ((b2[c3 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                        e3 = g2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                        while (1) {
                          d2 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                          a4 = b2[d2 >> 2] | 0;
                          if (!a4) {
                            break;
                          }
                          if ((b2[a4 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                            c3 = a4;
                            break j;
                          } else {
                            e3 = e3 << 1;
                            c3 = a4;
                          }
                        }
                        b2[d2 >> 2] = j;
                        b2[j + 24 >> 2] = c3;
                        b2[j + 12 >> 2] = j;
                        b2[j + 8 >> 2] = j;
                        break f;
                      }
                    } while (0);
                  u2 = c3 + 8 | 0;
                  v2 = b2[u2 >> 2] | 0;
                  b2[v2 + 12 >> 2] = j;
                  b2[u2 >> 2] = j;
                  b2[j + 8 >> 2] = v2;
                  b2[j + 12 >> 2] = c3;
                  b2[j + 24 >> 2] = 0;
                }
              } else {
                v2 = b2[5861] | 0;
                if ((v2 | 0) == 0 | g2 >>> 0 < v2 >>> 0) {
                  b2[5861] = g2;
                }
                b2[5969] = g2;
                b2[5970] = h;
                b2[5972] = 0;
                b2[5866] = b2[5975];
                b2[5865] = -1;
                b2[5870] = 23468;
                b2[5869] = 23468;
                b2[5872] = 23476;
                b2[5871] = 23476;
                b2[5874] = 23484;
                b2[5873] = 23484;
                b2[5876] = 23492;
                b2[5875] = 23492;
                b2[5878] = 23500;
                b2[5877] = 23500;
                b2[5880] = 23508;
                b2[5879] = 23508;
                b2[5882] = 23516;
                b2[5881] = 23516;
                b2[5884] = 23524;
                b2[5883] = 23524;
                b2[5886] = 23532;
                b2[5885] = 23532;
                b2[5888] = 23540;
                b2[5887] = 23540;
                b2[5890] = 23548;
                b2[5889] = 23548;
                b2[5892] = 23556;
                b2[5891] = 23556;
                b2[5894] = 23564;
                b2[5893] = 23564;
                b2[5896] = 23572;
                b2[5895] = 23572;
                b2[5898] = 23580;
                b2[5897] = 23580;
                b2[5900] = 23588;
                b2[5899] = 23588;
                b2[5902] = 23596;
                b2[5901] = 23596;
                b2[5904] = 23604;
                b2[5903] = 23604;
                b2[5906] = 23612;
                b2[5905] = 23612;
                b2[5908] = 23620;
                b2[5907] = 23620;
                b2[5910] = 23628;
                b2[5909] = 23628;
                b2[5912] = 23636;
                b2[5911] = 23636;
                b2[5914] = 23644;
                b2[5913] = 23644;
                b2[5916] = 23652;
                b2[5915] = 23652;
                b2[5918] = 23660;
                b2[5917] = 23660;
                b2[5920] = 23668;
                b2[5919] = 23668;
                b2[5922] = 23676;
                b2[5921] = 23676;
                b2[5924] = 23684;
                b2[5923] = 23684;
                b2[5926] = 23692;
                b2[5925] = 23692;
                b2[5928] = 23700;
                b2[5927] = 23700;
                b2[5930] = 23708;
                b2[5929] = 23708;
                b2[5932] = 23716;
                b2[5931] = 23716;
                v2 = h + -40 | 0;
                t3 = g2 + 8 | 0;
                t3 = (t3 & 7 | 0) == 0 ? 0 : 0 - t3 & 7;
                u2 = g2 + t3 | 0;
                t3 = v2 - t3 | 0;
                b2[5863] = u2;
                b2[5860] = t3;
                b2[u2 + 4 >> 2] = t3 | 1;
                b2[g2 + v2 + 4 >> 2] = 40;
                b2[5864] = b2[5979];
              }
            } while (0);
          c3 = b2[5860] | 0;
          if (c3 >>> 0 > m >>> 0) {
            t3 = c3 - m | 0;
            b2[5860] = t3;
            v2 = b2[5863] | 0;
            u2 = v2 + m | 0;
            b2[5863] = u2;
            b2[u2 + 4 >> 2] = t3 | 1;
            b2[v2 + 4 >> 2] = m | 3;
            v2 = v2 + 8 | 0;
            T = w2;
            return v2 | 0;
          }
        }
        v2 = fd() | 0;
        b2[v2 >> 2] = 12;
        v2 = 0;
        T = w2;
        return v2 | 0;
      }
      function jd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        if (!a4) {
          return;
        }
        d2 = a4 + -8 | 0;
        f3 = b2[5861] | 0;
        a4 = b2[a4 + -4 >> 2] | 0;
        c3 = a4 & -8;
        j = d2 + c3 | 0;
        do {
          if (!(a4 & 1)) {
            e3 = b2[d2 >> 2] | 0;
            if (!(a4 & 3)) {
              return;
            }
            h = d2 + (0 - e3) | 0;
            g2 = e3 + c3 | 0;
            if (h >>> 0 < f3 >>> 0) {
              return;
            }
            if ((b2[5862] | 0) == (h | 0)) {
              a4 = j + 4 | 0;
              c3 = b2[a4 >> 2] | 0;
              if ((c3 & 3 | 0) != 3) {
                i3 = h;
                c3 = g2;
                break;
              }
              b2[5859] = g2;
              b2[a4 >> 2] = c3 & -2;
              b2[h + 4 >> 2] = g2 | 1;
              b2[h + g2 >> 2] = g2;
              return;
            }
            d2 = e3 >>> 3;
            if (e3 >>> 0 < 256) {
              a4 = b2[h + 8 >> 2] | 0;
              c3 = b2[h + 12 >> 2] | 0;
              if ((c3 | 0) == (a4 | 0)) {
                b2[5857] = b2[5857] & ~(1 << d2);
                i3 = h;
                c3 = g2;
                break;
              } else {
                b2[a4 + 12 >> 2] = c3;
                b2[c3 + 8 >> 2] = a4;
                i3 = h;
                c3 = g2;
                break;
              }
            }
            f3 = b2[h + 24 >> 2] | 0;
            a4 = b2[h + 12 >> 2] | 0;
            do {
              if ((a4 | 0) == (h | 0)) {
                c3 = h + 16 | 0;
                d2 = c3 + 4 | 0;
                a4 = b2[d2 >> 2] | 0;
                if (!a4) {
                  a4 = b2[c3 >> 2] | 0;
                  if (!a4) {
                    a4 = 0;
                    break;
                  }
                } else {
                  c3 = d2;
                }
                while (1) {
                  e3 = a4 + 20 | 0;
                  d2 = b2[e3 >> 2] | 0;
                  if (!d2) {
                    e3 = a4 + 16 | 0;
                    d2 = b2[e3 >> 2] | 0;
                    if (!d2) {
                      break;
                    } else {
                      a4 = d2;
                      c3 = e3;
                    }
                  } else {
                    a4 = d2;
                    c3 = e3;
                  }
                }
                b2[c3 >> 2] = 0;
              } else {
                i3 = b2[h + 8 >> 2] | 0;
                b2[i3 + 12 >> 2] = a4;
                b2[a4 + 8 >> 2] = i3;
              }
            } while (0);
            if (f3) {
              c3 = b2[h + 28 >> 2] | 0;
              d2 = 23732 + (c3 << 2) | 0;
              if ((b2[d2 >> 2] | 0) == (h | 0)) {
                b2[d2 >> 2] = a4;
                if (!a4) {
                  b2[5858] = b2[5858] & ~(1 << c3);
                  i3 = h;
                  c3 = g2;
                  break;
                }
              } else {
                i3 = f3 + 16 | 0;
                b2[((b2[i3 >> 2] | 0) == (h | 0) ? i3 : f3 + 20 | 0) >> 2] = a4;
                if (!a4) {
                  i3 = h;
                  c3 = g2;
                  break;
                }
              }
              b2[a4 + 24 >> 2] = f3;
              c3 = h + 16 | 0;
              d2 = b2[c3 >> 2] | 0;
              if (d2 | 0) {
                b2[a4 + 16 >> 2] = d2;
                b2[d2 + 24 >> 2] = a4;
              }
              c3 = b2[c3 + 4 >> 2] | 0;
              if (c3) {
                b2[a4 + 20 >> 2] = c3;
                b2[c3 + 24 >> 2] = a4;
                i3 = h;
                c3 = g2;
              } else {
                i3 = h;
                c3 = g2;
              }
            } else {
              i3 = h;
              c3 = g2;
            }
          } else {
            i3 = d2;
            h = d2;
          }
        } while (0);
        if (h >>> 0 >= j >>> 0) {
          return;
        }
        a4 = j + 4 | 0;
        e3 = b2[a4 >> 2] | 0;
        if (!(e3 & 1)) {
          return;
        }
        if (!(e3 & 2)) {
          if ((b2[5863] | 0) == (j | 0)) {
            j = (b2[5860] | 0) + c3 | 0;
            b2[5860] = j;
            b2[5863] = i3;
            b2[i3 + 4 >> 2] = j | 1;
            if ((i3 | 0) != (b2[5862] | 0)) {
              return;
            }
            b2[5862] = 0;
            b2[5859] = 0;
            return;
          }
          if ((b2[5862] | 0) == (j | 0)) {
            j = (b2[5859] | 0) + c3 | 0;
            b2[5859] = j;
            b2[5862] = h;
            b2[i3 + 4 >> 2] = j | 1;
            b2[h + j >> 2] = j;
            return;
          }
          f3 = (e3 & -8) + c3 | 0;
          d2 = e3 >>> 3;
          do {
            if (e3 >>> 0 < 256) {
              c3 = b2[j + 8 >> 2] | 0;
              a4 = b2[j + 12 >> 2] | 0;
              if ((a4 | 0) == (c3 | 0)) {
                b2[5857] = b2[5857] & ~(1 << d2);
                break;
              } else {
                b2[c3 + 12 >> 2] = a4;
                b2[a4 + 8 >> 2] = c3;
                break;
              }
            } else {
              g2 = b2[j + 24 >> 2] | 0;
              a4 = b2[j + 12 >> 2] | 0;
              do {
                if ((a4 | 0) == (j | 0)) {
                  c3 = j + 16 | 0;
                  d2 = c3 + 4 | 0;
                  a4 = b2[d2 >> 2] | 0;
                  if (!a4) {
                    a4 = b2[c3 >> 2] | 0;
                    if (!a4) {
                      d2 = 0;
                      break;
                    }
                  } else {
                    c3 = d2;
                  }
                  while (1) {
                    e3 = a4 + 20 | 0;
                    d2 = b2[e3 >> 2] | 0;
                    if (!d2) {
                      e3 = a4 + 16 | 0;
                      d2 = b2[e3 >> 2] | 0;
                      if (!d2) {
                        break;
                      } else {
                        a4 = d2;
                        c3 = e3;
                      }
                    } else {
                      a4 = d2;
                      c3 = e3;
                    }
                  }
                  b2[c3 >> 2] = 0;
                  d2 = a4;
                } else {
                  d2 = b2[j + 8 >> 2] | 0;
                  b2[d2 + 12 >> 2] = a4;
                  b2[a4 + 8 >> 2] = d2;
                  d2 = a4;
                }
              } while (0);
              if (g2 | 0) {
                a4 = b2[j + 28 >> 2] | 0;
                c3 = 23732 + (a4 << 2) | 0;
                if ((b2[c3 >> 2] | 0) == (j | 0)) {
                  b2[c3 >> 2] = d2;
                  if (!d2) {
                    b2[5858] = b2[5858] & ~(1 << a4);
                    break;
                  }
                } else {
                  e3 = g2 + 16 | 0;
                  b2[((b2[e3 >> 2] | 0) == (j | 0) ? e3 : g2 + 20 | 0) >> 2] = d2;
                  if (!d2) {
                    break;
                  }
                }
                b2[d2 + 24 >> 2] = g2;
                a4 = j + 16 | 0;
                c3 = b2[a4 >> 2] | 0;
                if (c3 | 0) {
                  b2[d2 + 16 >> 2] = c3;
                  b2[c3 + 24 >> 2] = d2;
                }
                a4 = b2[a4 + 4 >> 2] | 0;
                if (a4 | 0) {
                  b2[d2 + 20 >> 2] = a4;
                  b2[a4 + 24 >> 2] = d2;
                }
              }
            }
          } while (0);
          b2[i3 + 4 >> 2] = f3 | 1;
          b2[h + f3 >> 2] = f3;
          if ((i3 | 0) == (b2[5862] | 0)) {
            b2[5859] = f3;
            return;
          }
        } else {
          b2[a4 >> 2] = e3 & -2;
          b2[i3 + 4 >> 2] = c3 | 1;
          b2[h + c3 >> 2] = c3;
          f3 = c3;
        }
        a4 = f3 >>> 3;
        if (f3 >>> 0 < 256) {
          d2 = 23468 + (a4 << 1 << 2) | 0;
          c3 = b2[5857] | 0;
          a4 = 1 << a4;
          if (!(c3 & a4)) {
            b2[5857] = c3 | a4;
            a4 = d2;
            c3 = d2 + 8 | 0;
          } else {
            c3 = d2 + 8 | 0;
            a4 = b2[c3 >> 2] | 0;
          }
          b2[c3 >> 2] = i3;
          b2[a4 + 12 >> 2] = i3;
          b2[i3 + 8 >> 2] = a4;
          b2[i3 + 12 >> 2] = d2;
          return;
        }
        a4 = f3 >>> 8;
        if (a4) {
          if (f3 >>> 0 > 16777215) {
            e3 = 31;
          } else {
            h = (a4 + 1048320 | 0) >>> 16 & 8;
            j = a4 << h;
            g2 = (j + 520192 | 0) >>> 16 & 4;
            j = j << g2;
            e3 = (j + 245760 | 0) >>> 16 & 2;
            e3 = 14 - (g2 | h | e3) + (j << e3 >>> 15) | 0;
            e3 = f3 >>> (e3 + 7 | 0) & 1 | e3 << 1;
          }
        } else {
          e3 = 0;
        }
        a4 = 23732 + (e3 << 2) | 0;
        b2[i3 + 28 >> 2] = e3;
        b2[i3 + 20 >> 2] = 0;
        b2[i3 + 16 >> 2] = 0;
        c3 = b2[5858] | 0;
        d2 = 1 << e3;
        a:
          do {
            if (!(c3 & d2)) {
              b2[5858] = c3 | d2;
              b2[a4 >> 2] = i3;
              b2[i3 + 24 >> 2] = a4;
              b2[i3 + 12 >> 2] = i3;
              b2[i3 + 8 >> 2] = i3;
            } else {
              a4 = b2[a4 >> 2] | 0;
              b:
                do {
                  if ((b2[a4 + 4 >> 2] & -8 | 0) != (f3 | 0)) {
                    e3 = f3 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                    while (1) {
                      d2 = a4 + 16 + (e3 >>> 31 << 2) | 0;
                      c3 = b2[d2 >> 2] | 0;
                      if (!c3) {
                        break;
                      }
                      if ((b2[c3 + 4 >> 2] & -8 | 0) == (f3 | 0)) {
                        a4 = c3;
                        break b;
                      } else {
                        e3 = e3 << 1;
                        a4 = c3;
                      }
                    }
                    b2[d2 >> 2] = i3;
                    b2[i3 + 24 >> 2] = a4;
                    b2[i3 + 12 >> 2] = i3;
                    b2[i3 + 8 >> 2] = i3;
                    break a;
                  }
                } while (0);
              h = a4 + 8 | 0;
              j = b2[h >> 2] | 0;
              b2[j + 12 >> 2] = i3;
              b2[h >> 2] = i3;
              b2[i3 + 8 >> 2] = j;
              b2[i3 + 12 >> 2] = a4;
              b2[i3 + 24 >> 2] = 0;
            }
          } while (0);
        j = (b2[5865] | 0) + -1 | 0;
        b2[5865] = j;
        if (j | 0) {
          return;
        }
        a4 = 23884;
        while (1) {
          a4 = b2[a4 >> 2] | 0;
          if (!a4) {
            break;
          } else {
            a4 = a4 + 8 | 0;
          }
        }
        b2[5865] = -1;
        return;
      }
      function kd(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d2 = 0;
        if (a4) {
          d2 = B(c3, a4) | 0;
          if ((c3 | a4) >>> 0 > 65535) {
            d2 = ((d2 >>> 0) / (a4 >>> 0) | 0 | 0) == (c3 | 0) ? d2 : -1;
          }
        } else {
          d2 = 0;
        }
        a4 = id(d2) | 0;
        if (!a4) {
          return a4 | 0;
        }
        if (!(b2[a4 + -4 >> 2] & 3)) {
          return a4 | 0;
        }
        Bd(a4 | 0, 0, d2 | 0) | 0;
        return a4 | 0;
      }
      function ld(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        c3 = a4 + c3 >>> 0;
        return (G(b3 + d2 + (c3 >>> 0 < a4 >>> 0 | 0) >>> 0 | 0), c3 | 0) | 0;
      }
      function md(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        d2 = b3 - d2 - (c3 >>> 0 > a4 >>> 0 | 0) >>> 0;
        return (G(d2 | 0), a4 - c3 >>> 0 | 0) | 0;
      }
      function nd(a4) {
        a4 = a4 | 0;
        return (a4 ? 31 - (E(a4 ^ a4 - 1) | 0) | 0 : 32) | 0;
      }
      function od(a4, c3, d2, e3, f3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f3 = f3 | 0;
        var g2 = 0, h = 0, i3 = 0, j = 0, k = 0, l2 = 0, m = 0, n2 = 0, o2 = 0, p3 = 0;
        l2 = a4;
        j = c3;
        k = j;
        h = d2;
        n2 = e3;
        i3 = n2;
        if (!k) {
          g2 = (f3 | 0) != 0;
          if (!i3) {
            if (g2) {
              b2[f3 >> 2] = (l2 >>> 0) % (h >>> 0);
              b2[f3 + 4 >> 2] = 0;
            }
            n2 = 0;
            f3 = (l2 >>> 0) / (h >>> 0) >>> 0;
            return (G(n2 | 0), f3) | 0;
          } else {
            if (!g2) {
              n2 = 0;
              f3 = 0;
              return (G(n2 | 0), f3) | 0;
            }
            b2[f3 >> 2] = a4 | 0;
            b2[f3 + 4 >> 2] = c3 & 0;
            n2 = 0;
            f3 = 0;
            return (G(n2 | 0), f3) | 0;
          }
        }
        g2 = (i3 | 0) == 0;
        do {
          if (h) {
            if (!g2) {
              g2 = (E(i3 | 0) | 0) - (E(k | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m = g2 + 1 | 0;
                i3 = 31 - g2 | 0;
                c3 = g2 - 31 >> 31;
                h = m;
                a4 = l2 >>> (m >>> 0) & c3 | k << i3;
                c3 = k >>> (m >>> 0) & c3;
                g2 = 0;
                i3 = l2 << i3;
                break;
              }
              if (!f3) {
                n2 = 0;
                f3 = 0;
                return (G(n2 | 0), f3) | 0;
              }
              b2[f3 >> 2] = a4 | 0;
              b2[f3 + 4 >> 2] = j | c3 & 0;
              n2 = 0;
              f3 = 0;
              return (G(n2 | 0), f3) | 0;
            }
            g2 = h - 1 | 0;
            if (g2 & h | 0) {
              i3 = (E(h | 0) | 0) + 33 - (E(k | 0) | 0) | 0;
              p3 = 64 - i3 | 0;
              m = 32 - i3 | 0;
              j = m >> 31;
              o2 = i3 - 32 | 0;
              c3 = o2 >> 31;
              h = i3;
              a4 = m - 1 >> 31 & k >>> (o2 >>> 0) | (k << m | l2 >>> (i3 >>> 0)) & c3;
              c3 = c3 & k >>> (i3 >>> 0);
              g2 = l2 << p3 & j;
              i3 = (k << p3 | l2 >>> (o2 >>> 0)) & j | l2 << m & i3 - 33 >> 31;
              break;
            }
            if (f3 | 0) {
              b2[f3 >> 2] = g2 & l2;
              b2[f3 + 4 >> 2] = 0;
            }
            if ((h | 0) == 1) {
              o2 = j | c3 & 0;
              p3 = a4 | 0 | 0;
              return (G(o2 | 0), p3) | 0;
            } else {
              p3 = nd(h | 0) | 0;
              o2 = k >>> (p3 >>> 0) | 0;
              p3 = k << 32 - p3 | l2 >>> (p3 >>> 0) | 0;
              return (G(o2 | 0), p3) | 0;
            }
          } else {
            if (g2) {
              if (f3 | 0) {
                b2[f3 >> 2] = (k >>> 0) % (h >>> 0);
                b2[f3 + 4 >> 2] = 0;
              }
              o2 = 0;
              p3 = (k >>> 0) / (h >>> 0) >>> 0;
              return (G(o2 | 0), p3) | 0;
            }
            if (!l2) {
              if (f3 | 0) {
                b2[f3 >> 2] = 0;
                b2[f3 + 4 >> 2] = (k >>> 0) % (i3 >>> 0);
              }
              o2 = 0;
              p3 = (k >>> 0) / (i3 >>> 0) >>> 0;
              return (G(o2 | 0), p3) | 0;
            }
            g2 = i3 - 1 | 0;
            if (!(g2 & i3)) {
              if (f3 | 0) {
                b2[f3 >> 2] = a4 | 0;
                b2[f3 + 4 >> 2] = g2 & k | c3 & 0;
              }
              o2 = 0;
              p3 = k >>> ((nd(i3 | 0) | 0) >>> 0);
              return (G(o2 | 0), p3) | 0;
            }
            g2 = (E(i3 | 0) | 0) - (E(k | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              c3 = g2 + 1 | 0;
              i3 = 31 - g2 | 0;
              h = c3;
              a4 = k << i3 | l2 >>> (c3 >>> 0);
              c3 = k >>> (c3 >>> 0);
              g2 = 0;
              i3 = l2 << i3;
              break;
            }
            if (!f3) {
              o2 = 0;
              p3 = 0;
              return (G(o2 | 0), p3) | 0;
            }
            b2[f3 >> 2] = a4 | 0;
            b2[f3 + 4 >> 2] = j | c3 & 0;
            o2 = 0;
            p3 = 0;
            return (G(o2 | 0), p3) | 0;
          }
        } while (0);
        if (!h) {
          k = i3;
          j = 0;
          i3 = 0;
        } else {
          m = d2 | 0 | 0;
          l2 = n2 | e3 & 0;
          k = ld(m | 0, l2 | 0, -1, -1) | 0;
          d2 = H() | 0;
          j = i3;
          i3 = 0;
          do {
            e3 = j;
            j = g2 >>> 31 | j << 1;
            g2 = i3 | g2 << 1;
            e3 = a4 << 1 | e3 >>> 31 | 0;
            n2 = a4 >>> 31 | c3 << 1 | 0;
            md(k | 0, d2 | 0, e3 | 0, n2 | 0) | 0;
            p3 = H() | 0;
            o2 = p3 >> 31 | ((p3 | 0) < 0 ? -1 : 0) << 1;
            i3 = o2 & 1;
            a4 = md(e3 | 0, n2 | 0, o2 & m | 0, (((p3 | 0) < 0 ? -1 : 0) >> 31 | ((p3 | 0) < 0 ? -1 : 0) << 1) & l2 | 0) | 0;
            c3 = H() | 0;
            h = h - 1 | 0;
          } while ((h | 0) != 0);
          k = j;
          j = 0;
        }
        h = 0;
        if (f3 | 0) {
          b2[f3 >> 2] = a4;
          b2[f3 + 4 >> 2] = c3;
        }
        o2 = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
        p3 = (g2 << 1 | 0 >>> 31) & -2 | i3;
        return (G(o2 | 0), p3) | 0;
      }
      function pd(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0;
        j = b3 >> 31 | ((b3 | 0) < 0 ? -1 : 0) << 1;
        i3 = ((b3 | 0) < 0 ? -1 : 0) >> 31 | ((b3 | 0) < 0 ? -1 : 0) << 1;
        f3 = d2 >> 31 | ((d2 | 0) < 0 ? -1 : 0) << 1;
        e3 = ((d2 | 0) < 0 ? -1 : 0) >> 31 | ((d2 | 0) < 0 ? -1 : 0) << 1;
        h = md(j ^ a4 | 0, i3 ^ b3 | 0, j | 0, i3 | 0) | 0;
        g2 = H() | 0;
        a4 = f3 ^ j;
        b3 = e3 ^ i3;
        return md((od(h, g2, md(f3 ^ c3 | 0, e3 ^ d2 | 0, f3 | 0, e3 | 0) | 0, H() | 0, 0) | 0) ^ a4 | 0, (H() | 0) ^ b3 | 0, a4 | 0, b3 | 0) | 0;
      }
      function qd(a4, b3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        var c3 = 0, d2 = 0, e3 = 0, f3 = 0;
        f3 = a4 & 65535;
        e3 = b3 & 65535;
        c3 = B(e3, f3) | 0;
        d2 = a4 >>> 16;
        a4 = (c3 >>> 16) + (B(e3, d2) | 0) | 0;
        e3 = b3 >>> 16;
        b3 = B(e3, f3) | 0;
        return (G((a4 >>> 16) + (B(e3, d2) | 0) + (((a4 & 65535) + b3 | 0) >>> 16) | 0), a4 + b3 << 16 | c3 & 65535 | 0) | 0;
      }
      function rd(a4, b3, c3, d2) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        var e3 = 0, f3 = 0;
        e3 = a4;
        f3 = c3;
        c3 = qd(e3, f3) | 0;
        a4 = H() | 0;
        return (G((B(b3, f3) | 0) + (B(d2, e3) | 0) + a4 | a4 & 0 | 0), c3 | 0 | 0) | 0;
      }
      function sd(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0, j = 0, k = 0;
        f3 = T;
        T = T + 16 | 0;
        i3 = f3 | 0;
        h = c3 >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        g2 = ((c3 | 0) < 0 ? -1 : 0) >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        k = e3 >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        j = ((e3 | 0) < 0 ? -1 : 0) >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        a4 = md(h ^ a4 | 0, g2 ^ c3 | 0, h | 0, g2 | 0) | 0;
        c3 = H() | 0;
        od(a4, c3, md(k ^ d2 | 0, j ^ e3 | 0, k | 0, j | 0) | 0, H() | 0, i3) | 0;
        e3 = md(b2[i3 >> 2] ^ h | 0, b2[i3 + 4 >> 2] ^ g2 | 0, h | 0, g2 | 0) | 0;
        d2 = H() | 0;
        T = f3;
        return (G(d2 | 0), e3) | 0;
      }
      function td(a4, c3, d2, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f3 = g2 | 0;
        od(a4, c3, d2, e3, f3) | 0;
        T = g2;
        return (G(b2[f3 + 4 >> 2] | 0), b2[f3 >> 2] | 0) | 0;
      }
      function ud(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G(b3 >> c3 | 0);
          return a4 >>> c3 | (b3 & (1 << c3) - 1) << 32 - c3;
        }
        G(((b3 | 0) < 0 ? -1 : 0) | 0);
        return b3 >> c3 - 32 | 0;
      }
      function vd(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G(b3 >>> c3 | 0);
          return a4 >>> c3 | (b3 & (1 << c3) - 1) << 32 - c3;
        }
        G(0);
        return b3 >>> c3 - 32 | 0;
      }
      function wd(a4, b3, c3) {
        a4 = a4 | 0;
        b3 = b3 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G(b3 << c3 | (a4 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3 | 0);
          return a4 << c3;
        }
        G(a4 << c3 - 32 | 0);
        return 0;
      }
      function xd(a4, b3) {
        a4 = +a4;
        b3 = +b3;
        if (a4 != a4) {
          return +b3;
        }
        if (b3 != b3) {
          return +a4;
        }
        return +D(+a4, +b3);
      }
      function yd(a4, b3) {
        a4 = +a4;
        b3 = +b3;
        if (a4 != a4) {
          return +b3;
        }
        if (b3 != b3) {
          return +a4;
        }
        return +C(+a4, +b3);
      }
      function zd(a4) {
        a4 = +a4;
        return a4 >= 0 ? +p2(a4 + 0.5) : +A(a4 - 0.5);
      }
      function Ad(c3, d2, e3) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0;
        if ((e3 | 0) >= 8192) {
          L(c3 | 0, d2 | 0, e3 | 0) | 0;
          return c3 | 0;
        }
        h = c3 | 0;
        g2 = c3 + e3 | 0;
        if ((c3 & 3) == (d2 & 3)) {
          while (c3 & 3) {
            if (!e3) {
              return h | 0;
            }
            a3[c3 >> 0] = a3[d2 >> 0] | 0;
            c3 = c3 + 1 | 0;
            d2 = d2 + 1 | 0;
            e3 = e3 - 1 | 0;
          }
          e3 = g2 & -4 | 0;
          f3 = e3 - 64 | 0;
          while ((c3 | 0) <= (f3 | 0)) {
            b2[c3 >> 2] = b2[d2 >> 2];
            b2[c3 + 4 >> 2] = b2[d2 + 4 >> 2];
            b2[c3 + 8 >> 2] = b2[d2 + 8 >> 2];
            b2[c3 + 12 >> 2] = b2[d2 + 12 >> 2];
            b2[c3 + 16 >> 2] = b2[d2 + 16 >> 2];
            b2[c3 + 20 >> 2] = b2[d2 + 20 >> 2];
            b2[c3 + 24 >> 2] = b2[d2 + 24 >> 2];
            b2[c3 + 28 >> 2] = b2[d2 + 28 >> 2];
            b2[c3 + 32 >> 2] = b2[d2 + 32 >> 2];
            b2[c3 + 36 >> 2] = b2[d2 + 36 >> 2];
            b2[c3 + 40 >> 2] = b2[d2 + 40 >> 2];
            b2[c3 + 44 >> 2] = b2[d2 + 44 >> 2];
            b2[c3 + 48 >> 2] = b2[d2 + 48 >> 2];
            b2[c3 + 52 >> 2] = b2[d2 + 52 >> 2];
            b2[c3 + 56 >> 2] = b2[d2 + 56 >> 2];
            b2[c3 + 60 >> 2] = b2[d2 + 60 >> 2];
            c3 = c3 + 64 | 0;
            d2 = d2 + 64 | 0;
          }
          while ((c3 | 0) < (e3 | 0)) {
            b2[c3 >> 2] = b2[d2 >> 2];
            c3 = c3 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        } else {
          e3 = g2 - 4 | 0;
          while ((c3 | 0) < (e3 | 0)) {
            a3[c3 >> 0] = a3[d2 >> 0] | 0;
            a3[c3 + 1 >> 0] = a3[d2 + 1 >> 0] | 0;
            a3[c3 + 2 >> 0] = a3[d2 + 2 >> 0] | 0;
            a3[c3 + 3 >> 0] = a3[d2 + 3 >> 0] | 0;
            c3 = c3 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        }
        while ((c3 | 0) < (g2 | 0)) {
          a3[c3 >> 0] = a3[d2 >> 0] | 0;
          c3 = c3 + 1 | 0;
          d2 = d2 + 1 | 0;
        }
        return h | 0;
      }
      function Bd(c3, d2, e3) {
        c3 = c3 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f3 = 0, g2 = 0, h = 0, i3 = 0;
        h = c3 + e3 | 0;
        d2 = d2 & 255;
        if ((e3 | 0) >= 67) {
          while (c3 & 3) {
            a3[c3 >> 0] = d2;
            c3 = c3 + 1 | 0;
          }
          f3 = h & -4 | 0;
          i3 = d2 | d2 << 8 | d2 << 16 | d2 << 24;
          g2 = f3 - 64 | 0;
          while ((c3 | 0) <= (g2 | 0)) {
            b2[c3 >> 2] = i3;
            b2[c3 + 4 >> 2] = i3;
            b2[c3 + 8 >> 2] = i3;
            b2[c3 + 12 >> 2] = i3;
            b2[c3 + 16 >> 2] = i3;
            b2[c3 + 20 >> 2] = i3;
            b2[c3 + 24 >> 2] = i3;
            b2[c3 + 28 >> 2] = i3;
            b2[c3 + 32 >> 2] = i3;
            b2[c3 + 36 >> 2] = i3;
            b2[c3 + 40 >> 2] = i3;
            b2[c3 + 44 >> 2] = i3;
            b2[c3 + 48 >> 2] = i3;
            b2[c3 + 52 >> 2] = i3;
            b2[c3 + 56 >> 2] = i3;
            b2[c3 + 60 >> 2] = i3;
            c3 = c3 + 64 | 0;
          }
          while ((c3 | 0) < (f3 | 0)) {
            b2[c3 >> 2] = i3;
            c3 = c3 + 4 | 0;
          }
        }
        while ((c3 | 0) < (h | 0)) {
          a3[c3 >> 0] = d2;
          c3 = c3 + 1 | 0;
        }
        return h - e3 | 0;
      }
      function Cd(a4) {
        a4 = +a4;
        return a4 >= 0 ? +p2(a4 + 0.5) : +A(a4 - 0.5);
      }
      function Dd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d2 = 0, e3 = 0;
        e3 = K() | 0;
        d2 = b2[g >> 2] | 0;
        c3 = d2 + a4 | 0;
        if ((a4 | 0) > 0 & (c3 | 0) < (d2 | 0) | (c3 | 0) < 0) {
          N(c3 | 0) | 0;
          J(12);
          return -1;
        }
        if ((c3 | 0) > (e3 | 0)) {
          if (!(M(c3 | 0) | 0)) {
            J(12);
            return -1;
          }
        }
        b2[g >> 2] = c3;
        return d2 | 0;
      }
      return {
        ___divdi3: pd,
        ___muldi3: rd,
        ___remdi3: sd,
        ___uremdi3: td,
        _areNeighborCells: $a,
        _bitshift64Ashr: ud,
        _bitshift64Lshr: vd,
        _bitshift64Shl: wd,
        _calloc: kd,
        _cellAreaKm2: lc,
        _cellAreaM2: mc,
        _cellAreaRads2: kc,
        _cellToBoundary: Qb,
        _cellToCenterChild: Ab,
        _cellToChildPos: Vb,
        _cellToChildren: yb,
        _cellToChildrenSize: wb,
        _cellToLatLng: Pb,
        _cellToLocalIj: xc,
        _cellToParent: vb,
        _cellToVertex: Wc,
        _cellToVertexes: Xc,
        _cellsToDirectedEdge: ab,
        _cellsToLinkedMultiPolygon: la,
        _childPosToCell: Wb,
        _compactCells: Bb,
        _destroyLinkedMultiPolygon: sc,
        _directedEdgeToBoundary: gb,
        _directedEdgeToCells: eb,
        _edgeLengthKm: oc,
        _edgeLengthM: pc,
        _edgeLengthRads: nc,
        _emscripten_replace_memory: W,
        _free: jd,
        _getBaseCellNumber: tb,
        _getDirectedEdgeDestination: cb,
        _getDirectedEdgeOrigin: bb,
        _getHexagonAreaAvgKm2: ec,
        _getHexagonAreaAvgM2: fc,
        _getHexagonEdgeLengthAvgKm: gc,
        _getHexagonEdgeLengthAvgM: hc,
        _getIcosahedronFaces: Sb,
        _getNumCells: ic,
        _getPentagons: Ub,
        _getRes0Cells: wa,
        _getResolution: sb,
        _greatCircleDistanceKm: ac,
        _greatCircleDistanceM: bc,
        _greatCircleDistanceRads: $b,
        _gridDisk: aa,
        _gridDiskDistances: ba,
        _gridDistance: zc,
        _gridPathCells: Bc,
        _gridPathCellsSize: Ac,
        _gridRingUnsafe: ga,
        _i64Add: ld,
        _i64Subtract: md,
        _isPentagon: xb,
        _isResClassIII: Eb,
        _isValidCell: ub,
        _isValidDirectedEdge: db,
        _isValidVertex: Zc,
        _latLngToCell: Mb,
        _llvm_maxnum_f64: xd,
        _llvm_minnum_f64: yd,
        _llvm_round_f64: zd,
        _localIjToCell: yc,
        _malloc: id,
        _maxFaceCount: Rb,
        _maxGridDiskSize: $,
        _maxPolygonToCellsSize: ha,
        _memcpy: Ad,
        _memset: Bd,
        _originToDirectedEdges: fb,
        _pentagonCount: Tb,
        _polygonToCells: ja,
        _readInt64AsDoubleFromPointer: Oc,
        _res0CellCount: va,
        _round: Cd,
        _sbrk: Dd,
        _sizeOfCellBoundary: Jc,
        _sizeOfCoordIJ: Nc,
        _sizeOfGeoLoop: Kc,
        _sizeOfGeoPolygon: Lc,
        _sizeOfH3Index: Hc,
        _sizeOfLatLng: Ic,
        _sizeOfLinkedGeoPolygon: Mc,
        _uncompactCells: Cb,
        _uncompactCellsSize: Db,
        _vertexToLatLng: Yc,
        establishStackSpace: _2,
        stackAlloc: X,
        stackRestore: Z,
        stackSave: Y
      };
    }(
      // EMSCRIPTEN_END_ASM
      asmGlobalArg,
      asmLibraryArg,
      buffer
    )
  );
  var ___divdi3 = Module["___divdi3"] = asm["___divdi3"];
  var ___muldi3 = Module["___muldi3"] = asm["___muldi3"];
  var ___remdi3 = Module["___remdi3"] = asm["___remdi3"];
  var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  var _areNeighborCells = Module["_areNeighborCells"] = asm["_areNeighborCells"];
  var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
  var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _calloc = Module["_calloc"] = asm["_calloc"];
  var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
  var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
  var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
  var _cellToBoundary = Module["_cellToBoundary"] = asm["_cellToBoundary"];
  var _cellToCenterChild = Module["_cellToCenterChild"] = asm["_cellToCenterChild"];
  var _cellToChildPos = Module["_cellToChildPos"] = asm["_cellToChildPos"];
  var _cellToChildren = Module["_cellToChildren"] = asm["_cellToChildren"];
  var _cellToChildrenSize = Module["_cellToChildrenSize"] = asm["_cellToChildrenSize"];
  var _cellToLatLng = Module["_cellToLatLng"] = asm["_cellToLatLng"];
  var _cellToLocalIj = Module["_cellToLocalIj"] = asm["_cellToLocalIj"];
  var _cellToParent = Module["_cellToParent"] = asm["_cellToParent"];
  var _cellToVertex = Module["_cellToVertex"] = asm["_cellToVertex"];
  var _cellToVertexes = Module["_cellToVertexes"] = asm["_cellToVertexes"];
  var _cellsToDirectedEdge = Module["_cellsToDirectedEdge"] = asm["_cellsToDirectedEdge"];
  var _cellsToLinkedMultiPolygon = Module["_cellsToLinkedMultiPolygon"] = asm["_cellsToLinkedMultiPolygon"];
  var _childPosToCell = Module["_childPosToCell"] = asm["_childPosToCell"];
  var _compactCells = Module["_compactCells"] = asm["_compactCells"];
  var _destroyLinkedMultiPolygon = Module["_destroyLinkedMultiPolygon"] = asm["_destroyLinkedMultiPolygon"];
  var _directedEdgeToBoundary = Module["_directedEdgeToBoundary"] = asm["_directedEdgeToBoundary"];
  var _directedEdgeToCells = Module["_directedEdgeToCells"] = asm["_directedEdgeToCells"];
  var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
  var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
  var _edgeLengthRads = Module["_edgeLengthRads"] = asm["_edgeLengthRads"];
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
  var _free = Module["_free"] = asm["_free"];
  var _getBaseCellNumber = Module["_getBaseCellNumber"] = asm["_getBaseCellNumber"];
  var _getDirectedEdgeDestination = Module["_getDirectedEdgeDestination"] = asm["_getDirectedEdgeDestination"];
  var _getDirectedEdgeOrigin = Module["_getDirectedEdgeOrigin"] = asm["_getDirectedEdgeOrigin"];
  var _getHexagonAreaAvgKm2 = Module["_getHexagonAreaAvgKm2"] = asm["_getHexagonAreaAvgKm2"];
  var _getHexagonAreaAvgM2 = Module["_getHexagonAreaAvgM2"] = asm["_getHexagonAreaAvgM2"];
  var _getHexagonEdgeLengthAvgKm = Module["_getHexagonEdgeLengthAvgKm"] = asm["_getHexagonEdgeLengthAvgKm"];
  var _getHexagonEdgeLengthAvgM = Module["_getHexagonEdgeLengthAvgM"] = asm["_getHexagonEdgeLengthAvgM"];
  var _getIcosahedronFaces = Module["_getIcosahedronFaces"] = asm["_getIcosahedronFaces"];
  var _getNumCells = Module["_getNumCells"] = asm["_getNumCells"];
  var _getPentagons = Module["_getPentagons"] = asm["_getPentagons"];
  var _getRes0Cells = Module["_getRes0Cells"] = asm["_getRes0Cells"];
  var _getResolution = Module["_getResolution"] = asm["_getResolution"];
  var _greatCircleDistanceKm = Module["_greatCircleDistanceKm"] = asm["_greatCircleDistanceKm"];
  var _greatCircleDistanceM = Module["_greatCircleDistanceM"] = asm["_greatCircleDistanceM"];
  var _greatCircleDistanceRads = Module["_greatCircleDistanceRads"] = asm["_greatCircleDistanceRads"];
  var _gridDisk = Module["_gridDisk"] = asm["_gridDisk"];
  var _gridDiskDistances = Module["_gridDiskDistances"] = asm["_gridDiskDistances"];
  var _gridDistance = Module["_gridDistance"] = asm["_gridDistance"];
  var _gridPathCells = Module["_gridPathCells"] = asm["_gridPathCells"];
  var _gridPathCellsSize = Module["_gridPathCellsSize"] = asm["_gridPathCellsSize"];
  var _gridRingUnsafe = Module["_gridRingUnsafe"] = asm["_gridRingUnsafe"];
  var _i64Add = Module["_i64Add"] = asm["_i64Add"];
  var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  var _isPentagon = Module["_isPentagon"] = asm["_isPentagon"];
  var _isResClassIII = Module["_isResClassIII"] = asm["_isResClassIII"];
  var _isValidCell = Module["_isValidCell"] = asm["_isValidCell"];
  var _isValidDirectedEdge = Module["_isValidDirectedEdge"] = asm["_isValidDirectedEdge"];
  var _isValidVertex = Module["_isValidVertex"] = asm["_isValidVertex"];
  var _latLngToCell = Module["_latLngToCell"] = asm["_latLngToCell"];
  var _llvm_maxnum_f64 = Module["_llvm_maxnum_f64"] = asm["_llvm_maxnum_f64"];
  var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
  var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
  var _localIjToCell = Module["_localIjToCell"] = asm["_localIjToCell"];
  var _malloc = Module["_malloc"] = asm["_malloc"];
  var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
  var _maxGridDiskSize = Module["_maxGridDiskSize"] = asm["_maxGridDiskSize"];
  var _maxPolygonToCellsSize = Module["_maxPolygonToCellsSize"] = asm["_maxPolygonToCellsSize"];
  var _memcpy = Module["_memcpy"] = asm["_memcpy"];
  var _memset = Module["_memset"] = asm["_memset"];
  var _originToDirectedEdges = Module["_originToDirectedEdges"] = asm["_originToDirectedEdges"];
  var _pentagonCount = Module["_pentagonCount"] = asm["_pentagonCount"];
  var _polygonToCells = Module["_polygonToCells"] = asm["_polygonToCells"];
  var _readInt64AsDoubleFromPointer = Module["_readInt64AsDoubleFromPointer"] = asm["_readInt64AsDoubleFromPointer"];
  var _res0CellCount = Module["_res0CellCount"] = asm["_res0CellCount"];
  var _round = Module["_round"] = asm["_round"];
  var _sbrk = Module["_sbrk"] = asm["_sbrk"];
  var _sizeOfCellBoundary = Module["_sizeOfCellBoundary"] = asm["_sizeOfCellBoundary"];
  var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
  var _sizeOfGeoLoop = Module["_sizeOfGeoLoop"] = asm["_sizeOfGeoLoop"];
  var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
  var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
  var _sizeOfLatLng = Module["_sizeOfLatLng"] = asm["_sizeOfLatLng"];
  var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
  var _uncompactCells = Module["_uncompactCells"] = asm["_uncompactCells"];
  var _uncompactCellsSize = Module["_uncompactCellsSize"] = asm["_uncompactCellsSize"];
  var _vertexToLatLng = Module["_vertexToLatLng"] = asm["_vertexToLatLng"];
  var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
  var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module["stackRestore"] = asm["stackRestore"];
  var stackSave = Module["stackSave"] = asm["stackSave"];
  Module["asm"] = asm;
  Module["cwrap"] = cwrap;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data) {
        if (data.byteLength) {
          data = new Uint8Array(data);
        }
        HEAPU8.set(data, GLOBAL_BASE);
        if (Module["memoryInitializerRequest"]) {
          delete Module["memoryInitializerRequest"].response;
        }
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
            if (data) {
              response = data.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) {
      run();
    }
    if (!calledRun) {
      dependenciesFulfilled = runCaller;
    }
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) {
        return;
      }
      calledRun = true;
      if (ABORT) {
        return;
      }
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"]) {
        Module["onRuntimeInitialized"]();
      }
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what += "";
    out(what);
    err(what);
    ABORT = true;
    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  }
  Module["abort"] = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") {
      Module["preInit"] = [Module["preInit"]];
    }
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return libh32;
}(typeof libh3 === "object" ? libh3 : {});
var NUMBER = "number";
var H3_ERROR = NUMBER;
var BOOLEAN = NUMBER;
var H3_LOWER = NUMBER;
var H3_UPPER = NUMBER;
var RESOLUTION = NUMBER;
var POINTER = NUMBER;
var BINDINGS = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", NUMBER],
  ["sizeOfLatLng", NUMBER],
  ["sizeOfCellBoundary", NUMBER],
  ["sizeOfGeoLoop", NUMBER],
  ["sizeOfGeoPolygon", NUMBER],
  ["sizeOfLinkedGeoPolygon", NUMBER],
  ["sizeOfCoordIJ", NUMBER],
  ["readInt64AsDoubleFromPointer", NUMBER],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["latLngToCell", H3_ERROR, [NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["cellToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["maxGridDiskSize", H3_ERROR, [NUMBER, POINTER]],
  ["gridDisk", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridDiskDistances", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
  ["gridRingUnsafe", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["maxPolygonToCellsSize", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCells", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["cellsToLinkedMultiPolygon", H3_ERROR, [POINTER, NUMBER, POINTER]],
  ["destroyLinkedMultiPolygon", null, [POINTER]],
  ["compactCells", H3_ERROR, [POINTER, POINTER, NUMBER, NUMBER]],
  ["uncompactCells", H3_ERROR, [POINTER, NUMBER, NUMBER, POINTER, NUMBER, RESOLUTION]],
  ["uncompactCellsSize", H3_ERROR, [POINTER, NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["isPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["getBaseCellNumber", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getResolution", NUMBER, [H3_LOWER, H3_UPPER]],
  ["maxFaceCount", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getIcosahedronFaces", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToParent", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildren", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToCenterChild", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildrenSize", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildPos", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["childPosToCell", H3_ERROR, [NUMBER, NUMBER, H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["areNeighborCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellsToDirectedEdge", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeOrigin", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeDestination", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidDirectedEdge", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["directedEdgeToCells", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["originToDirectedEdges", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["directedEdgeToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["gridDistance", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCellsSize", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellToLocalIj", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["localIjToCell", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER, NUMBER, POINTER]],
  ["getHexagonAreaAvgM2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonAreaAvgKm2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgM", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgKm", H3_ERROR, [RESOLUTION, POINTER]],
  ["greatCircleDistanceM", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceKm", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceRads", NUMBER, [POINTER, POINTER]],
  ["cellAreaM2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaKm2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaRads2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthM", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthKm", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthRads", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getNumCells", H3_ERROR, [RESOLUTION, POINTER]],
  ["getRes0Cells", H3_ERROR, [POINTER]],
  ["res0CellCount", NUMBER],
  ["getPentagons", H3_ERROR, [NUMBER, POINTER]],
  ["pentagonCount", NUMBER],
  ["cellToVertex", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["cellToVertexes", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["vertexToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidVertex", BOOLEAN, [H3_LOWER, H3_UPPER]]
];
var E_SUCCESS = 0;
var E_FAILED = 1;
var E_DOMAIN = 2;
var E_LATLNG_DOMAIN = 3;
var E_RES_DOMAIN = 4;
var E_CELL_INVALID = 5;
var E_DIR_EDGE_INVALID = 6;
var E_UNDIR_EDGE_INVALID = 7;
var E_VERTEX_INVALID = 8;
var E_PENTAGON = 9;
var E_DUPLICATE_INPUT = 10;
var E_NOT_NEIGHBORS = 11;
var E_RES_MISMATCH = 12;
var E_MEMORY_ALLOC = 13;
var E_MEMORY_BOUNDS = 14;
var E_OPTION_INVALID = 15;
var H3_ERROR_MSGS = {};
H3_ERROR_MSGS[E_SUCCESS] = "Success";
H3_ERROR_MSGS[E_FAILED] = "The operation failed but a more specific error is not available";
H3_ERROR_MSGS[E_DOMAIN] = "Argument was outside of acceptable range";
H3_ERROR_MSGS[E_LATLNG_DOMAIN] = "Latitude or longitude arguments were outside of acceptable range";
H3_ERROR_MSGS[E_RES_DOMAIN] = "Resolution argument was outside of acceptable range";
H3_ERROR_MSGS[E_CELL_INVALID] = "Cell argument was not valid";
H3_ERROR_MSGS[E_DIR_EDGE_INVALID] = "Directed edge argument was not valid";
H3_ERROR_MSGS[E_UNDIR_EDGE_INVALID] = "Undirected edge argument was not valid";
H3_ERROR_MSGS[E_VERTEX_INVALID] = "Vertex argument was not valid";
H3_ERROR_MSGS[E_PENTAGON] = "Pentagon distortion was encountered";
H3_ERROR_MSGS[E_DUPLICATE_INPUT] = "Duplicate input";
H3_ERROR_MSGS[E_NOT_NEIGHBORS] = "Cell arguments were not neighbors";
H3_ERROR_MSGS[E_RES_MISMATCH] = "Cell arguments had incompatible resolutions";
H3_ERROR_MSGS[E_MEMORY_ALLOC] = "Memory allocation failed";
H3_ERROR_MSGS[E_MEMORY_BOUNDS] = "Bounds of provided memory were insufficient";
H3_ERROR_MSGS[E_OPTION_INVALID] = "Mode or flags argument was not valid";
var E_UNKNOWN_UNIT = 1e3;
var E_ARRAY_LENGTH = 1001;
var E_NULL_INDEX = 1002;
var JS_ERROR_MESSAGES = {};
JS_ERROR_MESSAGES[E_UNKNOWN_UNIT] = "Unknown unit";
JS_ERROR_MESSAGES[E_ARRAY_LENGTH] = "Array length out of bounds";
JS_ERROR_MESSAGES[E_NULL_INDEX] = "Got unexpected null value for H3 index";
var UNKNOWN_ERROR_MSG = "Unknown error";
function createError(messages, errCode, meta) {
  var hasValue = meta && "value" in meta;
  var err = new Error((messages[errCode] || UNKNOWN_ERROR_MSG) + " (code: " + errCode + (hasValue ? ", value: " + meta.value : "") + ")");
  err.code = errCode;
  return err;
}
function H3LibraryError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(H3_ERROR_MSGS, errCode, meta);
}
function JSBindingError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(JS_ERROR_MESSAGES, errCode, meta);
}
function throwIfError(errCode) {
  if (errCode !== 0) {
    throw H3LibraryError(errCode);
  }
}
var H3 = {};
BINDINGS.forEach(function bind(def) {
  H3[def[0]] = libh3.cwrap.apply(libh3, def);
});
var BASE_16 = 16;
var SZ_INT = 4;
var SZ_PTR = 4;
var SZ_DBL = 8;
var SZ_INT64 = 8;
var SZ_H3INDEX = H3.sizeOfH3Index();
var SZ_LATLNG = H3.sizeOfLatLng();
var SZ_CELLBOUNDARY = H3.sizeOfCellBoundary();
var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
var SZ_GEOLOOP = H3.sizeOfGeoLoop();
var SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
var SZ_COORDIJ = H3.sizeOfCoordIJ();
var UNITS = {
  m: "m",
  m2: "m2",
  km: "km",
  km2: "km2",
  rads: "rads",
  rads2: "rads2"
};
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw H3LibraryError(E_RES_DOMAIN, res);
  }
  return res;
}
function validateH3Index(h3Index) {
  if (!h3Index) {
    throw JSBindingError(E_NULL_INDEX);
  }
  return h3Index;
}
var MAX_JS_ARRAY_LENGTH = Math.pow(2, 32) - 1;
var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToH3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i3 = 0; i3 < numZeroes; i3++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
var UPPER_BIT_DIVISOR = Math.pow(2, 32);
function readH3IndexFromPointer(cAddress, offset) {
  if (offset === void 0)
    offset = 0;
  var lower = libh3.getValue(cAddress + SZ_H3INDEX * offset, "i32");
  var upper = libh3.getValue(cAddress + SZ_H3INDEX * offset + SZ_INT, "i32");
  return upper ? splitLongToH3Index(lower, upper) : null;
}
function readDoubleFromPointer(cAddress, offset) {
  if (offset === void 0)
    offset = 0;
  return libh3.getValue(cAddress + SZ_DBL * offset, "double");
}
function readInt64AsDoubleFromPointer(cAddress) {
  return H3.readInt64AsDoubleFromPointer(cAddress);
}
function storeH3Index(h3Index, cAddress, offset) {
  libh3.HEAPU32.set(h3IndexToSplitLong(h3Index), cAddress / SZ_INT + 2 * offset);
}
function storeArrayOfH3Indexes(cAddress, hexagons) {
  var count = hexagons.length;
  for (var i3 = 0; i3 < count; i3++) {
    storeH3Index(hexagons[i3], cAddress, i3);
  }
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readLatLng(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readLatLngGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readCellBoundary(cellBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(cellBoundary, "i32");
  var vertsPos = cellBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readLatLngGeoJson : readLatLng;
  for (var i3 = 0; i3 < numVerts * 2; i3 += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i3));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function readMultiPolygon(polygon, formatAsGeoJson) {
  var output = [];
  var readCoord = formatAsGeoJson ? readLatLngGeoJson : readLatLng;
  var loops;
  var loop;
  var coords;
  var coord;
  while (polygon) {
    output.push(loops = []);
    loop = libh3.getValue(polygon, "i8*");
    while (loop) {
      loops.push(coords = []);
      coord = libh3.getValue(loop, "i8*");
      while (coord) {
        coords.push(readCoord(coord));
        coord = libh3.getValue(coord + SZ_DBL * 2, "i8*");
      }
      if (formatAsGeoJson) {
        coords.push(coords[0]);
      }
      loop = libh3.getValue(loop + SZ_PTR * 2, "i8*");
    }
    polygon = libh3.getValue(polygon + SZ_PTR * 2, "i8*");
  }
  return output;
}
function isPentagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.isPentagon(lower, upper));
}
function getResolution(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  if (!H3.isValidCell(lower, upper)) {
    return -1;
  }
  return H3.getResolution(lower, upper);
}
function latLngToCell(lat, lng, res) {
  var latLng = libh3._malloc(SZ_LATLNG);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latLng / SZ_DBL);
  var h3Index = libh3._malloc(SZ_H3INDEX);
  try {
    throwIfError(H3.latLngToCell(latLng, res, h3Index));
    return validateH3Index(readH3IndexFromPointer(h3Index));
  } finally {
    libh3._free(h3Index);
    libh3._free(latLng);
  }
}
function cellToLatLng(h3Index) {
  var latLng = libh3._malloc(SZ_LATLNG);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToLatLng(lower, upper, latLng));
    return readLatLng(latLng);
  } finally {
    libh3._free(latLng);
  }
}
function cellToBoundary(h3Index, formatAsGeoJson) {
  var cellBoundary = libh3._malloc(SZ_CELLBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToBoundary(lower, upper, cellBoundary));
    return readCellBoundary(cellBoundary, formatAsGeoJson, formatAsGeoJson);
  } finally {
    libh3._free(cellBoundary);
  }
}
function cellsToMultiPolygon(h3Indexes, formatAsGeoJson) {
  if (!h3Indexes || !h3Indexes.length) {
    return [];
  }
  var indexCount = h3Indexes.length;
  var set = libh3._calloc(indexCount, SZ_H3INDEX);
  storeArrayOfH3Indexes(set, h3Indexes);
  var polygon = libh3._calloc(SZ_LINKED_GEOPOLYGON);
  try {
    throwIfError(H3.cellsToLinkedMultiPolygon(set, indexCount, polygon));
    return readMultiPolygon(polygon, formatAsGeoJson);
  } finally {
    H3.destroyLinkedMultiPolygon(polygon);
    libh3._free(polygon);
    libh3._free(set);
  }
}
function gridDistance(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  var countPtr = libh3._malloc(SZ_INT64);
  try {
    throwIfError(H3.gridDistance(oLower, oUpper, dLower, dUpper, countPtr));
    return readInt64AsDoubleFromPointer(countPtr);
  } finally {
    libh3._free(countPtr);
  }
}
function getHexagonEdgeLengthAvg(res, unit) {
  validateRes(res);
  var out = libh3._malloc(SZ_DBL);
  try {
    switch (unit) {
      case UNITS.m:
        throwIfError(H3.getHexagonEdgeLengthAvgM(res, out));
        break;
      case UNITS.km:
        throwIfError(H3.getHexagonEdgeLengthAvgKm(res, out));
        break;
      default:
        throw JSBindingError(E_UNKNOWN_UNIT, unit);
    }
    return readDoubleFromPointer(out);
  } finally {
    libh3._free(out);
  }
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-utils.js
function normalizeLongitudes(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = cellToLatLng(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i3 = 0; i3 < vertexCount; i3++) {
    vertices[i3][0] = lerp(lng, vertices[i3][0], factor);
    vertices[i3][1] = lerp(lat, vertices[i3][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = cellToLatLng(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = cellToBoundary(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i3 = 0;
  for (const pt of vertices) {
    positions[i3++] = pt[0];
    positions[i3++] = pt[1];
  }
  return positions;
}

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js
var UPDATE_THRESHOLD_KM = 10;
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = { ...getHexagon, coverage };
  } else {
    trigger = { getHexagon, coverage };
  }
  return trigger;
}
var defaultProps23 = {
  ...PolygonLayer.defaultProps,
  highPrecision: "auto",
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  centerHexagon: null,
  getHexagon: { type: "accessor", value: (x2) => x2.hexagon },
  extruded: true
};
var _H3HexagonLayer = class _H3HexagonLayer extends CompositeLayer {
  initializeState() {
    _H3HexagonLayer._checkH3Lib();
    this.state = {
      edgeLengthKM: 0,
      resolution: -1
    };
  }
  shouldUpdateState({ changeFlags }) {
    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
  }
  updateState({ props, changeFlags }) {
    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
      const dataProps = this._calculateH3DataProps();
      this.setState(dataProps);
    }
    this._updateVertices(this.context.viewport);
  }
  _calculateH3DataProps() {
    let resolution = -1;
    let hasPentagon = false;
    let hasMultipleRes = false;
    const { iterable, objectInfo } = createIterable(this.props.data);
    for (const object of iterable) {
      objectInfo.index++;
      const hexId = this.props.getHexagon(object, objectInfo);
      const hexResolution = getResolution(hexId);
      if (resolution < 0) {
        resolution = hexResolution;
        if (!this.props.highPrecision)
          break;
      } else if (resolution !== hexResolution) {
        hasMultipleRes = true;
        break;
      }
      if (isPentagon(hexId)) {
        hasPentagon = true;
        break;
      }
    }
    return {
      resolution,
      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, "km") : 0,
      hasMultipleRes,
      hasPentagon
    };
  }
  _shouldUseHighPrecision() {
    if (this.props.highPrecision === "auto") {
      const { resolution, hasPentagon, hasMultipleRes } = this.state;
      const { viewport } = this.context;
      return Boolean(viewport == null ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
    }
    return this.props.highPrecision;
  }
  _updateVertices(viewport) {
    if (this._shouldUseHighPrecision()) {
      return;
    }
    const { resolution, edgeLengthKM, centerHex } = this.state;
    if (resolution < 0) {
      return;
    }
    const hex = this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);
    if (centerHex === hex) {
      return;
    }
    if (centerHex) {
      try {
        const distance = gridDistance(centerHex, hex);
        if (distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {
          return;
        }
      } catch {
      }
    }
    const { unitsPerMeter } = viewport.distanceScales;
    let vertices = h3ToPolygon(hex);
    const [centerLat, centerLng] = cellToLatLng(hex);
    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
    vertices = vertices.map((p2) => {
      const worldPosition = viewport.projectFlat(p2);
      return [
        (worldPosition[0] - centerX) / unitsPerMeter[0],
        (worldPosition[1] - centerY) / unitsPerMeter[1]
      ];
    });
    this.setState({ centerHex: hex, vertices });
  }
  renderLayers() {
    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
  }
  _getForwardProps() {
    const { elevationScale, material, coverage, extruded, wireframe, stroked, filled, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, getFillColor, getElevation, getLineColor, getLineWidth, transitions, updateTriggers } = this.props;
    return {
      elevationScale,
      extruded,
      coverage,
      wireframe,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      material,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth,
      transitions,
      updateTriggers: {
        getFillColor: updateTriggers.getFillColor,
        getElevation: updateTriggers.getElevation,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    };
  }
  _renderPolygonLayer() {
    const { data, getHexagon, updateTriggers, coverage } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
    const forwardProps2 = this._getForwardProps();
    forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
    return new SubLayerClass(forwardProps2, this.getSubLayerProps({
      id: "hexagon-cell-hifi",
      updateTriggers: forwardProps2.updateTriggers
    }), {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (object, objectInfo) => {
        const hexagonId = getHexagon(object, objectInfo);
        return flattenPolygon(h3ToPolygon(hexagonId, coverage));
      }
    });
  }
  _renderColumnLayer() {
    const { data, getHexagon, updateTriggers } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
    const forwardProps2 = this._getForwardProps();
    forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
    return new SubLayerClass(forwardProps2, this.getSubLayerProps({
      id: "hexagon-cell",
      flatShading: true,
      updateTriggers: forwardProps2.updateTriggers
    }), {
      data,
      diskResolution: 6,
      // generate an extruded hexagon as the base geometry
      radius: 1,
      vertices: this.state.vertices,
      getPosition: getHexagonCentroid.bind(null, getHexagon)
    });
  }
};
_H3HexagonLayer.defaultProps = defaultProps23;
_H3HexagonLayer.layerName = "H3HexagonLayer";
_H3HexagonLayer._checkH3Lib = () => {
};
var H3HexagonLayer = _H3HexagonLayer;

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-cluster-layer.js
var defaultProps24 = {
  getHexagons: { type: "accessor", value: (d) => d.hexagons }
};
var _H3ClusterLayer = class _H3ClusterLayer extends GeoCellLayer {
  initializeState() {
    H3HexagonLayer._checkH3Lib();
  }
  updateState({ props, changeFlags }) {
    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
      const { data, getHexagons } = props;
      const polygons = [];
      const { iterable, objectInfo } = createIterable(data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexagons = getHexagons(object, objectInfo);
        const multiPolygon = cellsToMultiPolygon(hexagons, true);
        for (const polygon of multiPolygon) {
          for (const ring of polygon) {
            normalizeLongitudes(ring);
          }
          polygons.push(this.getSubLayerRow({ polygon }, object, objectInfo.index));
        }
      }
      this.setState({ polygons });
    }
  }
  indexToBounds() {
    const { getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    return {
      data: this.state.polygons,
      getPolygon: (d) => d.polygon,
      getElevation: this.getSubLayerAccessor(getElevation),
      getFillColor: this.getSubLayerAccessor(getFillColor),
      getLineColor: this.getSubLayerAccessor(getLineColor),
      getLineWidth: this.getSubLayerAccessor(getLineWidth)
    };
  }
};
_H3ClusterLayer.layerName = "H3ClusterLayer";
_H3ClusterLayer.defaultProps = defaultProps24;
var H3ClusterLayer = _H3ClusterLayer;

// node_modules/@deck.gl/mesh-layers/dist/utils/matrix.js
var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);
function calculateTransformMatrix(targetMatrix, orientation, scale) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale[0];
  const scy = scale[1];
  const scz = scale[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(attribute, { startRow, endRow }) {
    const { data, getOrientation, getScale: getScale2, getTranslation, getTransformMatrix } = this.props;
    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale2);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);
    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }
    const instanceModelMatrixData = attribute.value;
    if (attribute.constant) {
      let matrix;
      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        const orientation = getOrientation;
        const scale = getScale2;
        calculateTransformMatrix(matrix, orientation, scale);
        matrix.set(getTranslation, 9);
      }
      attribute.value = new Float32Array(matrix);
    } else {
      let i3 = startRow * attribute.size;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
          const scale = constantScale ? getScale2 : getScale2(object, objectInfo);
          calculateTransformMatrix(matrix, orientation, scale);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }
        instanceModelMatrixData[i3++] = matrix[0];
        instanceModelMatrixData[i3++] = matrix[1];
        instanceModelMatrixData[i3++] = matrix[2];
        instanceModelMatrixData[i3++] = matrix[3];
        instanceModelMatrixData[i3++] = matrix[4];
        instanceModelMatrixData[i3++] = matrix[5];
        instanceModelMatrixData[i3++] = matrix[6];
        instanceModelMatrixData[i3++] = matrix[7];
        instanceModelMatrixData[i3++] = matrix[8];
        instanceModelMatrixData[i3++] = matrix[9];
        instanceModelMatrixData[i3++] = matrix[10];
        instanceModelMatrixData[i3++] = matrix[11];
      }
    }
  }
};
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;
if (composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer.js
function normalizeGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  log_default.assert(positionAttribute, 'no "postions" or "POSITION" attribute in mesh');
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  let colorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!colorAttribute) {
    colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };
  }
  let normalAttribute = attributes.NORMAL || attributes.normals;
  if (!normalAttribute) {
    normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };
  }
  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;
  if (!texCoordAttribute) {
    texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };
  }
  return {
    positions: positionAttribute,
    colors: colorAttribute,
    normals: normalAttribute,
    texCoords: texCoordAttribute
  };
}
function getGeometry(data) {
  if (data instanceof Geometry) {
    data.attributes = normalizeGeometryAttributes(data.attributes);
    return data;
  } else if (data.attributes) {
    return new Geometry({
      ...data,
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data.attributes)
    });
  } else {
    return new Geometry({
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data)
    });
  }
}
var DEFAULT_COLOR10 = [0, 0, 0, 255];
var defaultProps25 = {
  mesh: { type: "object", value: null, async: true },
  texture: { type: "image", value: null, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: true,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: false,
  // Optional material for 'lighting' shader module
  material: true,
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR10 },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var _SimpleMeshLayer = class _SimpleMeshLayer extends Layer {
  getShaders() {
    return super.getShaders({
      vs: simple_mesh_layer_vertex_glsl_default,
      fs: simple_mesh_layer_fragment_glsl_default,
      modules: [project32_default, phongLighting, picking_default]
    });
  }
  getBounds() {
    var _a;
    if (this.props._instanced) {
      return super.getBounds();
    }
    let result = this.state.positionBounds;
    if (result) {
      return result;
    }
    const { mesh } = this.props;
    if (!mesh) {
      return null;
    }
    result = (_a = mesh.header) == null ? void 0 : _a.boundingBox;
    if (!result) {
      const { attributes } = getGeometry(mesh);
      attributes.POSITION = attributes.POSITION || attributes.positions;
      result = getMeshBoundingBox(attributes);
    }
    this.state.positionBounds = result;
    return result;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: true,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
    this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      this.state.positionBounds = null;
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);
        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {
      this.setTexture(props.texture);
    }
    if (this.state.model) {
      this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.emptyTexture.delete();
  }
  draw({ uniforms }) {
    const { model } = this.state;
    if (!model) {
      return;
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, coordinateSystem, _instanced } = this.props;
    model.setUniforms(uniforms);
    model.setUniforms({
      sizeScale,
      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
      flatShading: !this.state.hasNormals
    });
    model.draw(renderPass);
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.model) && super.isLoaded);
  }
  getModel(mesh) {
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: getGeometry(mesh),
      isInstanced: true
    });
    const { texture } = this.props;
    const { emptyTexture } = this.state;
    model.setBindings({
      sampler: texture || emptyTexture
    });
    model.setUniforms({
      hasTexture: Boolean(texture)
    });
    return model;
  }
  setTexture(texture) {
    const { emptyTexture, model } = this.state;
    if (model) {
      model.setBindings({
        sampler: texture || emptyTexture
      });
      model.setUniforms({
        hasTexture: Boolean(texture)
      });
    }
  }
};
_SimpleMeshLayer.defaultProps = defaultProps25;
_SimpleMeshLayer.layerName = "SimpleMeshLayer";
var SimpleMeshLayer = _SimpleMeshLayer;

// node_modules/@luma.gl/gltf/dist/pbr/parse-pbr-material.js
var GLEnum;
(function(GLEnum4) {
  GLEnum4[GLEnum4["FUNC_ADD"] = 32774] = "FUNC_ADD";
  GLEnum4[GLEnum4["ONE"] = 1] = "ONE";
  GLEnum4[GLEnum4["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  GLEnum4[GLEnum4["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  GLEnum4[GLEnum4["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  GLEnum4[GLEnum4["LINEAR"] = 9729] = "LINEAR";
  GLEnum4[GLEnum4["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  GLEnum4[GLEnum4["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(GLEnum || (GLEnum = {}));
function parsePBRMaterial(device, material, attributes, options) {
  const parsedMaterial = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      u_Camera: [0, 0, 0],
      // Model should override
      u_MetallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  parsedMaterial.defines.USE_TEX_LOD = 1;
  const { imageBasedLightingEnvironment } = options;
  if (imageBasedLightingEnvironment) {
    parsedMaterial.bindings.u_DiffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler;
    parsedMaterial.bindings.u_SpecularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler;
    parsedMaterial.bindings.u_brdfLUT = imageBasedLightingEnvironment.brdfLutTexture;
    parsedMaterial.uniforms.u_ScaleIBLAmbient = [1, 1];
  }
  if (options == null ? void 0 : options.pbrDebug) {
    parsedMaterial.defines.PBR_DEBUG = 1;
    parsedMaterial.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
    parsedMaterial.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
  }
  if (attributes.NORMAL)
    parsedMaterial.defines.HAS_NORMALS = 1;
  if (attributes.TANGENT && (options == null ? void 0 : options.useTangents))
    parsedMaterial.defines.HAS_TANGENTS = 1;
  if (attributes.TEXCOORD_0)
    parsedMaterial.defines.HAS_UV = 1;
  if (options == null ? void 0 : options.imageBasedLightingEnvironment)
    parsedMaterial.defines.USE_IBL = 1;
  if (options == null ? void 0 : options.lights)
    parsedMaterial.defines.USE_LIGHTS = 1;
  if (material) {
    parseMaterial(device, material, parsedMaterial);
  }
  return parsedMaterial;
}
function parseMaterial(device, material, parsedMaterial) {
  parsedMaterial.uniforms.pbr_uUnlit = Boolean(material.unlit);
  if (material.pbrMetallicRoughness) {
    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);
  }
  if (material.normalTexture) {
    addTexture(device, material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP", parsedMaterial);
    const { scale = 1 } = material.normalTexture;
    parsedMaterial.uniforms.u_NormalScale = scale;
  }
  if (material.occlusionTexture) {
    addTexture(device, material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP", parsedMaterial);
    const { strength = 1 } = material.occlusionTexture;
    parsedMaterial.uniforms.u_OcclusionStrength = strength;
  }
  if (material.emissiveTexture) {
    addTexture(device, material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP", parsedMaterial);
    parsedMaterial.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
  }
  switch (material.alphaMode) {
    case "MASK":
      const { alphaCutoff = 0.5 } = material;
      parsedMaterial.defines.ALPHA_CUTOFF = 1;
      parsedMaterial.uniforms.u_AlphaCutoff = alphaCutoff;
      break;
    case "BLEND":
      log.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")();
      parsedMaterial.parameters.blendColorOperation = "add";
      parsedMaterial.parameters.blendColorSrcFactor = "src-alpha";
      parsedMaterial.parameters.blendColorDstFactor = "one-minus-src-alpha";
      parsedMaterial.parameters.blendAlphaOperation = "add";
      parsedMaterial.parameters.blendAlphaSrcFactor = "one";
      parsedMaterial.parameters.blendAlphaDstFactor = "one-minus-src-alpha";
      parsedMaterial.glParameters.blend = true;
      parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;
      parsedMaterial.glParameters.blendFunc = [
        GLEnum.SRC_ALPHA,
        GLEnum.ONE_MINUS_SRC_ALPHA,
        GLEnum.ONE,
        GLEnum.ONE_MINUS_SRC_ALPHA
      ];
      break;
  }
}
function parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {
  if (pbrMetallicRoughness.baseColorTexture) {
    addTexture(device, pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP", parsedMaterial);
  }
  parsedMaterial.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
  if (pbrMetallicRoughness.metallicRoughnessTexture) {
    addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP", parsedMaterial);
  }
  const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;
  parsedMaterial.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
}
function addTexture(device, gltfTexture, uniformName, define2 = null, parsedMaterial) {
  var _a, _b;
  const parameters2 = ((_b = (_a = gltfTexture == null ? void 0 : gltfTexture.texture) == null ? void 0 : _a.sampler) == null ? void 0 : _b.parameters) || {};
  const image = gltfTexture.texture.source.image;
  let textureOptions;
  let specialTextureParameters = {};
  if (image.compressed) {
    textureOptions = image;
    specialTextureParameters = {
      [GLEnum.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR
    };
  } else {
    textureOptions = { data: image };
  }
  const texture = device.createTexture({
    id: gltfTexture.uniformName || gltfTexture.id,
    parameters: {
      ...parameters2,
      ...specialTextureParameters
    },
    pixelStore: {
      [GLEnum.UNPACK_FLIP_Y_WEBGL]: false
    },
    ...textureOptions
  });
  parsedMaterial.bindings[uniformName] = texture;
  if (define2)
    parsedMaterial.defines[define2] = 1;
  parsedMaterial.generatedTextures.push(texture);
}

// node_modules/@loaders.gl/textures/dist/lib/utils/version.js
var VERSION4 = true ? "4.2.0-beta.2" : "latest";

// node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
var BASIS_EXTERNAL_LIBRARIES = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
var loadBasisTranscoderPromise;
async function loadBasisTranscoderModule(options) {
  registerJSModules(options.modules);
  const basis = getJSModuleOrNull("basis");
  if (basis) {
    return basis;
  }
  loadBasisTranscoderPromise || (loadBasisTranscoderPromise = loadBasisTranscoder(options));
  return await loadBasisTranscoderPromise;
}
async function loadBasisTranscoder(options) {
  let BASIS = null;
  let wasmBinary = null;
  [BASIS, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
  ]);
  BASIS = BASIS || globalThis.BASIS;
  return await initializeBasisTranscoderModule(BASIS, wasmBinary);
}
function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisModule(options).then((module) => {
      const { BasisFile, initializeBasis } = module;
      initializeBasis();
      resolve({ BasisFile });
    });
  });
}
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisEncoderModule(options).then((module) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module;
      initializeBasis();
      resolve({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_es3
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_atc
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  // EXT_texture_compression_rgtc
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
};

// node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
var WEBGL_EXTENSIONS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
var formats = null;
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || void 0;
    formats = /* @__PURE__ */ new Set();
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension(`${prefix}${extension}`)) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas = document.createElement("canvas");
    return canvas.getContext("webgl");
  } catch (error) {
    return null;
  }
}

// node_modules/ktx-parse/dist/ktx-parse.modern.js
var t = new Uint8Array([0]);
var e = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
var n;
var i;
var s;
var a;
var r;
var o;
var l;
var f;
!function(t2) {
  t2[t2.NONE = 0] = "NONE", t2[t2.BASISLZ = 1] = "BASISLZ", t2[t2.ZSTD = 2] = "ZSTD", t2[t2.ZLIB = 3] = "ZLIB";
}(n || (n = {})), function(t2) {
  t2[t2.BASICFORMAT = 0] = "BASICFORMAT";
}(i || (i = {})), function(t2) {
  t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.ETC1S = 163] = "ETC1S", t2[t2.UASTC = 166] = "UASTC";
}(s || (s = {})), function(t2) {
  t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.SRGB = 1] = "SRGB";
}(a || (a = {})), function(t2) {
  t2[t2.UNSPECIFIED = 0] = "UNSPECIFIED", t2[t2.LINEAR = 1] = "LINEAR", t2[t2.SRGB = 2] = "SRGB", t2[t2.ITU = 3] = "ITU", t2[t2.NTSC = 4] = "NTSC", t2[t2.SLOG = 5] = "SLOG", t2[t2.SLOG2 = 6] = "SLOG2";
}(r || (r = {})), function(t2) {
  t2[t2.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t2[t2.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
}(o || (o = {})), function(t2) {
  t2[t2.RGB = 0] = "RGB", t2[t2.RRR = 3] = "RRR", t2[t2.GGG = 4] = "GGG", t2[t2.AAA = 15] = "AAA";
}(l || (l = {})), function(t2) {
  t2[t2.RGB = 0] = "RGB", t2[t2.RGBA = 3] = "RGBA", t2[t2.RRR = 4] = "RRR", t2[t2.RRRG = 5] = "RRRG";
}(f || (f = {}));
var U = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = n.NONE, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: i.BASICFORMAT, versionNumber: 2, descriptorBlockSize: 40, colorModel: s.UNSPECIFIED, colorPrimaries: a.SRGB, transferFunction: a.SRGB, flags: o.ALPHA_STRAIGHT, texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 }, bytesPlane: [], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var c = class {
  constructor(t2, e2, n2, i3) {
    this._dataView = new DataView(t2.buffer, t2.byteOffset + e2, n2), this._littleEndian = i3, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e2 = 0) {
    const n2 = this._offset;
    let i3 = 0;
    for (; this._dataView.getUint8(this._offset) !== e2 && i3 < t2; )
      i3++, this._offset++;
    return i3 < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i3);
  }
};
function _(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function p(t2) {
  const n2 = new Uint8Array(t2.buffer, t2.byteOffset, e.length);
  if (n2[0] !== e[0] || n2[1] !== e[1] || n2[2] !== e[2] || n2[3] !== e[3] || n2[4] !== e[4] || n2[5] !== e[5] || n2[6] !== e[6] || n2[7] !== e[7] || n2[8] !== e[8] || n2[9] !== e[9] || n2[10] !== e[10] || n2[11] !== e[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const i3 = new U(), s2 = 17 * Uint32Array.BYTES_PER_ELEMENT, a3 = new c(t2, e.length, s2, true);
  i3.vkFormat = a3._nextUint32(), i3.typeSize = a3._nextUint32(), i3.pixelWidth = a3._nextUint32(), i3.pixelHeight = a3._nextUint32(), i3.pixelDepth = a3._nextUint32(), i3.layerCount = a3._nextUint32(), i3.faceCount = a3._nextUint32();
  const r2 = a3._nextUint32();
  i3.supercompressionScheme = a3._nextUint32();
  const o2 = a3._nextUint32(), l2 = a3._nextUint32(), f2 = a3._nextUint32(), h = a3._nextUint32(), g = a3._nextUint64(), p2 = a3._nextUint64(), x2 = new c(t2, e.length + s2, 3 * r2 * 8, true);
  for (let e2 = 0; e2 < r2; e2++)
    i3.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + x2._nextUint64(), x2._nextUint64()), uncompressedByteLength: x2._nextUint64() });
  const u = new c(t2, o2, l2, true), y2 = { vendorId: u._skip(4)._nextUint16(), descriptorType: u._nextUint16(), versionNumber: u._nextUint16(), descriptorBlockSize: u._nextUint16(), colorModel: u._nextUint8(), colorPrimaries: u._nextUint8(), transferFunction: u._nextUint8(), flags: u._nextUint8(), texelBlockDimension: { x: u._nextUint8() + 1, y: u._nextUint8() + 1, z: u._nextUint8() + 1, w: u._nextUint8() + 1 }, bytesPlane: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()], samples: [] }, D = (y2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < D; t3++)
    y2.samples[t3] = { bitOffset: u._nextUint16(), bitLength: u._nextUint8(), channelID: u._nextUint8(), samplePosition: [u._nextUint8(), u._nextUint8(), u._nextUint8(), u._nextUint8()], sampleLower: u._nextUint32(), sampleUpper: u._nextUint32() };
  i3.dataFormatDescriptor.length = 0, i3.dataFormatDescriptor.push(y2);
  const b2 = new c(t2, f2, h, true);
  for (; b2._offset < h; ) {
    const t3 = b2._nextUint32(), e2 = b2._scan(t3), n3 = _(e2), s3 = b2._scan(t3 - e2.byteLength);
    i3.keyValue[n3] = n3.match(/^ktx/i) ? _(s3) : s3, t3 % 4 && b2._skip(4 - t3 % 4);
  }
  if (p2 <= 0)
    return i3;
  const d = new c(t2, g, p2, true), B = d._nextUint16(), w = d._nextUint16(), A = d._nextUint32(), S = d._nextUint32(), m = d._nextUint32(), L = d._nextUint32(), I = [];
  for (let t3 = 0; t3 < r2; t3++)
    I.push({ imageFlags: d._nextUint32(), rgbSliceByteOffset: d._nextUint32(), rgbSliceByteLength: d._nextUint32(), alphaSliceByteOffset: d._nextUint32(), alphaSliceByteLength: d._nextUint32() });
  const R = g + d._offset, E = R + A, T = E + S, O = T + m, P = new Uint8Array(t2.buffer, t2.byteOffset + R, A), C = new Uint8Array(t2.buffer, t2.byteOffset + E, S), F = new Uint8Array(t2.buffer, t2.byteOffset + T, m), G = new Uint8Array(t2.buffer, t2.byteOffset + O, L);
  return i3.globalData = { endpointCount: B, selectorCount: w, imageDescs: I, endpointsData: P, selectorsData: C, tablesData: F, extendedData: G }, i3;
}

// node_modules/@loaders.gl/textures/dist/lib/utils/extract-mipmap-images.js
function extractMipmapImages(data, options) {
  const images = new Array(options.mipMapLevels);
  let levelWidth = options.width;
  let levelHeight = options.height;
  let offset = 0;
  for (let i3 = 0; i3 < options.mipMapLevels; ++i3) {
    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i3);
    const levelData = getLevelData(data, i3, offset, levelSize);
    images[i3] = {
      compressed: true,
      format: options.internalFormat,
      data: levelData,
      width: levelWidth,
      height: levelHeight,
      levelSize
    };
    levelWidth = Math.max(1, levelWidth >> 1);
    levelHeight = Math.max(1, levelHeight >> 1);
    offset += levelSize;
  }
  return images;
}
function getLevelData(data, index, offset, levelSize) {
  if (!Array.isArray(data)) {
    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);
  }
  return data[index].levelData;
}
function getLevelSize(options, levelWidth, levelHeight, data, index) {
  if (!Array.isArray(data)) {
    return options.sizeFunction(levelWidth, levelHeight);
  }
  return options.sizeFunction(data[index]);
}

// node_modules/@loaders.gl/textures/dist/lib/utils/ktx-format-helper.js
var VULKAN_TO_WEBGL_FORMAT_MAP = {
  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,
  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,
  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,
  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,
  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,
  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,
  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,
  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,
  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,
  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,
  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,
  // @ts-ignore
  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
  // @ts-ignore
  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
  // @ts-ignore
  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
  // @ts-ignore
  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
  // @ts-ignore
  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
  // @ts-ignore
  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
  // @ts-ignore
  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
  // @ts-ignore
  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
  // @ts-ignore
  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
  // @ts-ignore
  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
  // @ts-ignore
  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
  // @ts-ignore
  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
  // @ts-ignore
  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
  // @ts-ignore
  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,
  // @ts-ignore
  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
  1000054e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  // @ts-ignore
  1000066e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR
};
function mapVkFormatToWebGL(vkFormat) {
  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
var KTX2_ID = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || // '´'
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // 'ª'
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11];
  return !notKTX;
}
function parseKTX(arrayBuffer) {
  const uint8Array = new Uint8Array(arrayBuffer);
  const ktx = p(uint8Array);
  const mipMapLevels = Math.max(1, ktx.levels.length);
  const width = ktx.pixelWidth;
  const height = ktx.pixelHeight;
  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);
  return extractMipmapImages(ktx.levels, {
    mipMapLevels,
    width,
    height,
    sizeFunction: (level) => level.uncompressedByteLength,
    internalFormat
  });
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
var OutputFormat = {
  etc1: {
    basisFormat: 0,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: true },
  bc1: {
    basisFormat: 2,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: true },
  bc5: { basisFormat: 5, compressed: true },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
  "bc7-m5": { basisFormat: 7, compressed: true },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: true },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
  rgba32: { basisFormat: 13, compressed: false },
  rgb565: { basisFormat: 14, compressed: false },
  bgr565: { basisFormat: 15, compressed: false },
  rgba4444: { basisFormat: 16, compressed: false }
};
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const { BasisFile } = await loadBasisTranscoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha(
    /* imageIndex, levelIndex */
  );
  const { compressed, format: format2, basisFormat } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    format: format2,
    // Additional fields
    // Add levelSize field.
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
      break;
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const { compressed, format: format2, basisFormat } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(
    decodedData,
    levelIndex,
    0,
    0,
    basisFormat,
    0,
    -1,
    -1
    /* channel1 */
  )) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    // Additional fields
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format: format2
  };
}
function getBasisOptions(options, hasAlpha) {
  let format2 = options && options.basis && options.basis.format;
  if (format2 === "auto") {
    format2 = selectSupportedBasisFormat();
  }
  if (typeof format2 === "object") {
    format2 = hasAlpha ? format2.alpha : format2.noAlpha;
  }
  format2 = format2.toLowerCase();
  return OutputFormat[format2];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}

// node_modules/@loaders.gl/textures/dist/basis-loader.js
var BasisWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: true,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
};
var BasisLoader = {
  ...BasisWorkerLoader,
  parse: parseBasis
};

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-dds.js
var DDS_CONSTANTS = {
  MAGIC_NUMBER: 542327876,
  HEADER_LENGTH: 31,
  MAGIC_NUMBER_INDEX: 0,
  HEADER_SIZE_INDEX: 1,
  HEADER_FLAGS_INDEX: 2,
  HEADER_HEIGHT_INDEX: 3,
  HEADER_WIDTH_INDEX: 4,
  MIPMAPCOUNT_INDEX: 7,
  HEADER_PF_FLAGS_INDEX: 20,
  HEADER_PF_FOURCC_INDEX: 21,
  DDSD_MIPMAPCOUNT: 131072,
  DDPF_FOURCC: 4
};
var DDS_PIXEL_FORMATS = {
  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  "ATC ": GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,
  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
};
var getATCLevelSize = getDxt1LevelSize;
var getATCALevelSize = getDxtXLevelSize;
var getATCILevelSize = getDxtXLevelSize;
var DDS_SIZE_FUNCTIONS = {
  DXT1: getDxt1LevelSize,
  DXT3: getDxtXLevelSize,
  DXT5: getDxtXLevelSize,
  "ATC ": getATCLevelSize,
  ATCA: getATCALevelSize,
  ATCI: getATCILevelSize
};
function isDDS(data) {
  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];
  return magic === DDS_CONSTANTS.MAGIC_NUMBER;
}
function parseDDS(data) {
  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];
  assert2(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), "DDS: Unsupported format, must contain a FourCC code");
  const fourCC = int32ToFourCC(pixelFormatNumber);
  const internalFormat = DDS_PIXEL_FORMATS[fourCC];
  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];
  assert2(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);
  let mipMapLevels = 1;
  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {
    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);
  }
  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];
  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];
  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function getDxt1LevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 8;
}
function getDxtXLevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 16;
}
function int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-pvr.js
var PVR_CONSTANTS = {
  MAGIC_NUMBER: 55727696,
  MAGIC_NUMBER_EXTRA: 1347834371,
  HEADER_LENGTH: 13,
  HEADER_SIZE: 52,
  MAGIC_NUMBER_INDEX: 0,
  PIXEL_FORMAT_INDEX: 2,
  COLOUR_SPACE_INDEX: 4,
  HEIGHT_INDEX: 6,
  WIDTH_INDEX: 7,
  MIPMAPCOUNT_INDEX: 11,
  METADATA_SIZE_INDEX: 12
};
var PVR_PIXEL_FORMATS = {
  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],
  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],
  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],
  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],
  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],
  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],
  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],
  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],
  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],
  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],
  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],
  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],
  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],
  27: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR
  ],
  28: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR
  ],
  29: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR
  ],
  30: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR
  ],
  31: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR
  ],
  32: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR
  ],
  33: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR
  ],
  34: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR
  ],
  35: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR
  ],
  36: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR
  ],
  37: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR
  ],
  38: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR
  ],
  39: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR
  ],
  40: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR
  ]
};
var PVR_SIZE_FUNCTIONS = {
  0: pvrtc2bppSize,
  1: pvrtc2bppSize,
  2: pvrtc4bppSize,
  3: pvrtc4bppSize,
  6: dxtEtcSmallSize,
  7: dxtEtcSmallSize,
  9: dxtEtcAstcBigSize,
  11: dxtEtcAstcBigSize,
  22: dxtEtcSmallSize,
  23: dxtEtcAstcBigSize,
  24: dxtEtcSmallSize,
  25: dxtEtcSmallSize,
  26: dxtEtcAstcBigSize,
  27: dxtEtcAstcBigSize,
  28: atc5x4Size,
  29: atc5x5Size,
  30: atc6x5Size,
  31: atc6x6Size,
  32: atc8x5Size,
  33: atc8x6Size,
  34: atc8x8Size,
  35: atc10x5Size,
  36: atc10x6Size,
  37: atc10x8Size,
  38: atc10x10Size,
  39: atc12x10Size,
  40: atc12x12Size
};
function isPVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];
  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;
}
function parsePVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];
  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];
  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];
  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];
  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];
  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];
  const width = header[PVR_CONSTANTS.WIDTH_INDEX];
  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];
  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function pvrtc2bppSize(width, height) {
  width = Math.max(width, 16);
  height = Math.max(height, 8);
  return width * height / 4;
}
function pvrtc4bppSize(width, height) {
  width = Math.max(width, 8);
  height = Math.max(height, 8);
  return width * height / 2;
}
function dxtEtcSmallSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
}
function dxtEtcAstcBigSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
}
function atc5x4Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
}
function atc5x5Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
}
function atc6x5Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
}
function atc6x6Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
}
function atc8x5Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
}
function atc8x6Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
}
function atc8x8Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
}
function atc10x5Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
}
function atc10x6Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
}
function atc10x8Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
}
function atc10x10Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
}
function atc12x10Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
}
function atc12x12Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-compressed-texture.js
function parseCompressedTexture(data) {
  if (isKTX(data)) {
    return parseKTX(data);
  }
  if (isDDS(data)) {
    return parseDDS(data);
  }
  if (isPVR(data)) {
    return parsePVR(data);
  }
  throw new Error("Texture container format not recognized");
}

// node_modules/@loaders.gl/textures/dist/compressed-texture-loader.js
var CompressedTextureWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Texture Containers",
  id: "compressed-texture",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: [
    "ktx",
    "ktx2",
    "dds",
    // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc
    "pvr"
    // WEBGL_compressed_texture_pvrtc
  ],
  mimeTypes: [
    "image/ktx2",
    "image/ktx",
    "image/vnd-ms.dds",
    "image/x-dds",
    "application/octet-stream"
  ],
  binary: true,
  options: {
    "compressed-texture": {
      libraryPath: "libs/",
      useBasis: false
    }
  }
};
var CompressedTextureLoader = {
  ...CompressedTextureWorkerLoader,
  parse: async (arrayBuffer, options) => {
    var _a;
    if ((_a = options == null ? void 0 : options["compressed-texture"]) == null ? void 0 : _a.useBasis) {
      options.basis = {
        format: {
          alpha: "BC3",
          noAlpha: "BC1"
        },
        // @ts-expect-error TODO not allowed to modify inputs
        ...options.basis,
        containerFormat: "ktx2",
        module: "encoder"
      };
      const result = await parseBasis(arrayBuffer, options);
      return result[0];
    }
    return parseCompressedTexture(arrayBuffer);
  }
};

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-npy.js
var a2 = new Uint32Array([305419896]);
var b = new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
var isLittleEndian = !(b[0] === 18);
var LITTLE_ENDIAN_OS = isLittleEndian;
var DTYPES = {
  u1: Uint8Array,
  i1: Int8Array,
  u2: Uint16Array,
  i2: Int16Array,
  u4: Uint32Array,
  i4: Int32Array,
  f4: Float32Array,
  f8: Float64Array
};
function parseNPY(arrayBuffer, options) {
  var _a;
  const view = new DataView(arrayBuffer);
  const { header, headerEndOffset } = parseHeader(view);
  const numpyType = header.descr;
  const ArrayType = DTYPES[numpyType.slice(1, 3)];
  if (!ArrayType) {
    throw new Error(`Unimplemented type ${numpyType}`);
  }
  const nArrayElements = (_a = header.shape) == null ? void 0 : _a.reduce((a3, b2) => a3 * b2);
  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;
  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {
    throw new Error("Buffer overflow");
  }
  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));
  if (numpyType[0] === ">" && LITTLE_ENDIAN_OS || numpyType[0] === "<" && !LITTLE_ENDIAN_OS) {
    throw new Error("Incorrect endianness");
  }
  return {
    data,
    header
  };
}
function parseHeader(view) {
  const majorVersion = view.getUint8(6);
  let offset = 8;
  let headerLength;
  if (majorVersion >= 2) {
    headerLength = view.getUint32(offset, true);
    offset += 4;
  } else {
    headerLength = view.getUint16(offset, true);
    offset += 2;
  }
  const encoding = majorVersion <= 2 ? "latin1" : "utf-8";
  const decoder = new TextDecoder(encoding);
  const headerArray = new Uint8Array(view.buffer, offset, headerLength);
  const headerText = decoder.decode(headerArray);
  offset += headerLength;
  const header = JSON.parse(headerText.replace(/'/g, '"').replace("False", "false").replace("(", "[").replace(/,*\),*/g, "]"));
  return { header, headerEndOffset: offset };
}

// node_modules/@loaders.gl/textures/dist/npy-loader.js
var NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);
var NPYWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "NPY",
  id: "npy",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: ["npy"],
  mimeTypes: [],
  tests: [NPY_MAGIC_NUMBER.buffer],
  options: {
    npy: {}
  }
};
var NPYLoader = {
  ...NPYWorkerLoader,
  parseSync: parseNPY,
  parse: async (arrayBuffer, options) => parseNPY(arrayBuffer, options)
};

// node_modules/@luma.gl/gltf/dist/gltf/gltf-animator.js
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var GLTFAnimation = class {
  constructor(props) {
    __publicField(this, "name");
    __publicField(this, "startTime", 0);
    __publicField(this, "playing", true);
    __publicField(this, "speed", 1);
    __publicField(this, "channels", []);
    Object.assign(this, props);
  }
  animate(timeMs) {
    if (!this.playing) {
      return;
    }
    const absTime = timeMs / 1e3;
    const time = (absTime - this.startTime) * this.speed;
    this.channels.forEach(({ sampler, target, path }) => {
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }
};
var GLTFAnimator = class {
  constructor(gltf) {
    __publicField(this, "animations");
    this.animations = gltf.animations.map((animation, index) => {
      const name12 = animation.name || `Animation-${index}`;
      const samplers = animation.samplers.map(({ input, interpolation = "LINEAR", output }) => ({
        input: accessorToJsArray(gltf.accessors[input]),
        interpolation,
        output: accessorToJsArray(gltf.accessors[output])
      }));
      const channels = animation.channels.map(({ sampler, target }) => ({
        sampler: samplers[sampler],
        target: gltf.nodes[target.node],
        path: target.path
      }));
      return new GLTFAnimation({ name: name12, channels });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(time) {
    this.setTime(time);
  }
  setTime(time) {
    this.animations.forEach((animation) => animation.animate(time));
  }
  getAnimations() {
    return this.animations;
  }
};
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
    const length2 = components * accessor.count;
    const { buffer, byteOffset } = accessor.bufferView.data;
    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length2);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i3 = 0; i3 < array.length; i3 += components) {
        slicedArray.push(Array.from(array.slice(i3, i3 + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}
var helperMatrix = new Matrix4();
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}
var quaternion = new Quaternion();
function linearInterpolate(target, path, start, stop, ratio) {
  if (path === "rotation") {
    quaternion.slerp({ start, target: stop, ratio });
    for (let i3 = 0; i3 < quaternion.length; i3++) {
      target[path][i3] = quaternion[i3];
    }
  } else {
    for (let i3 = 0; i3 < start.length; i3++) {
      target[path][i3] = ratio * stop[i3] + (1 - ratio) * start[i3];
    }
  }
}
function cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t2 }) {
  for (let i3 = 0; i3 < target[path].length; i3++) {
    const m0 = outTangent0[i3] * tDiff;
    const m1 = inTangent1[i3] * tDiff;
    target[path][i3] = (2 * Math.pow(t2, 3) - 3 * Math.pow(t2, 2) + 1) * p0[i3] + (Math.pow(t2, 3) - 2 * Math.pow(t2, 2) + t2) * m0 + (-2 * Math.pow(t2, 3) + 3 * Math.pow(t2, 2)) * p1[i3] + (Math.pow(t2, 3) - Math.pow(t2, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  for (let i3 = 0; i3 < value.length; i3++) {
    target[path][i3] = value[i3];
  }
}
function interpolate(time, { input, interpolation, output }, target, path) {
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t2) => t2 >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log.warn(`Bad animation path ${path}`)();
    }
  }
  assert3(target[path].length === output[previousIndex].length);
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });
      }
      break;
    default:
      log.warn(`Interpolation ${interpolation} not supported`)();
      break;
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/create-gltf-model.js
var vs = `
#pragma vscode_glsllint_stage: vert
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  // _attr vec4 POSITION;
  _attr vec4 positions;

  #ifdef HAS_NORMALS
    // _attr vec4 NORMAL;
    _attr vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // _attr vec2 TEXCOORD_0;
    _attr vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }
`;
var fs = `
#pragma vscode_glsllint_stage: frag
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;
function createGLTFModel(device, options) {
  const { id, geometry, material, vertexCount, materialOptions, modelOptions } = options;
  const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);
  log.info(4, "createGLTFModel defines: ", parsedMaterial.defines)();
  const managedResources = [];
  const parameters2 = {
    depthWriteEnabled: true,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  };
  const modelProps = {
    id,
    geometry,
    topology: geometry.topology,
    vertexCount,
    modules: [pbr],
    vs: addVersionToShader(device, vs),
    fs: addVersionToShader(device, fs),
    ...modelOptions,
    bindings: { ...parsedMaterial.bindings, ...modelOptions.bindings },
    defines: { ...parsedMaterial.defines, ...modelOptions.defines },
    parameters: { ...parameters2, ...parsedMaterial.parameters, ...modelOptions.parameters },
    uniforms: { ...parsedMaterial.uniforms, ...modelOptions.uniforms }
  };
  const model = new Model(device, modelProps);
  return new ModelNode({ managedResources, model });
}
function addVersionToShader(device, source) {
  return `#version 300 es
${source}`;
}

// node_modules/@luma.gl/gltf/dist/gltf/gltf-instantiator.js
var DEFAULT_OPTIONS = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: null,
  lights: true,
  useTangents: false
};
var GLTFInstantiator = class {
  constructor(device, options = {}) {
    __publicField(this, "device");
    __publicField(this, "options");
    __publicField(this, "gltf");
    this.device = device;
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }
  instantiate(gltf) {
    this.gltf = gltf;
    const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
    return scenes;
  }
  createAnimator() {
    if (Array.isArray(this.gltf.animations)) {
      return new GLTFAnimator(this.gltf);
    }
    return null;
  }
  createScene(gltfScene) {
    const gltfNodes = gltfScene.nodes || [];
    const nodes = gltfNodes.map((node) => this.createNode(node));
    const scene = new GroupNode({
      id: gltfScene.name || gltfScene.id,
      children: nodes
    });
    return scene;
  }
  createNode(gltfNode) {
    if (!gltfNode._node) {
      const gltfChildren = gltfNode.children || [];
      const children = gltfChildren.map((child) => this.createNode(child));
      if (gltfNode.mesh) {
        children.push(this.createMesh(gltfNode.mesh));
      }
      const node = new GroupNode({
        id: gltfNode.name || gltfNode.id,
        children
      });
      if (gltfNode.matrix) {
        node.setMatrix(gltfNode.matrix);
      } else {
        node.matrix.identity();
        if (gltfNode.translation) {
          node.matrix.translate(gltfNode.translation);
        }
        if (gltfNode.rotation) {
          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
          node.matrix.multiplyRight(rotationMatrix);
        }
        if (gltfNode.scale) {
          node.matrix.scale(gltfNode.scale);
        }
      }
      gltfNode._node = node;
    }
    return gltfNode._node;
  }
  createMesh(gltfMesh) {
    if (!gltfMesh._mesh) {
      const gltfPrimitives = gltfMesh.primitives || [];
      const primitives = gltfPrimitives.map((gltfPrimitive, i3) => this.createPrimitive(gltfPrimitive, i3, gltfMesh));
      const mesh = new GroupNode({
        id: gltfMesh.name || gltfMesh.id,
        children: primitives
      });
      gltfMesh._mesh = mesh;
    }
    return gltfMesh._mesh;
  }
  createPrimitive(gltfPrimitive, i3, gltfMesh) {
    const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i3}`;
    const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);
    const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes);
    const modelNode = createGLTFModel(this.device, {
      id,
      geometry: this.createGeometry(id, gltfPrimitive, topology),
      material: gltfPrimitive.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount
    });
    modelNode.bounds = [
      gltfPrimitive.attributes.POSITION.min,
      gltfPrimitive.attributes.POSITION.max
    ];
    return modelNode;
  }
  getVertexCount(attributes) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(id, gltfPrimitive, topology) {
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {
      const { components, size, value } = attribute;
      attributes[attributeName] = { size: size ?? components, value };
    }
    return new Geometry({
      id,
      topology,
      indices: gltfPrimitive.indices.value,
      attributes
    });
  }
  createBuffer(attribute, usage) {
    if (!attribute.bufferView) {
      attribute.bufferView = {};
    }
    const { bufferView } = attribute;
    if (!bufferView.lumaBuffers) {
      bufferView.lumaBuffers = {};
    }
    if (!bufferView.lumaBuffers[usage]) {
      bufferView.lumaBuffers[usage] = this.device.createBuffer({
        id: `from-${bufferView.id}`,
        // Draco decoded files have attribute.value
        data: bufferView.data || attribute.value
      });
    }
    return bufferView.lumaBuffers[usage];
  }
  // TODO - create sampler in WebGL2
  createSampler(gltfSampler) {
    return gltfSampler;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return false;
  }
};
var GLEnum2;
(function(GLEnum4) {
  GLEnum4[GLEnum4["POINTS"] = 0] = "POINTS";
  GLEnum4[GLEnum4["LINES"] = 1] = "LINES";
  GLEnum4[GLEnum4["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum4[GLEnum4["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum4[GLEnum4["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum4[GLEnum4["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum4[GLEnum4["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(GLEnum2 || (GLEnum2 = {}));
function convertGLDrawModeToTopology(drawMode) {
  switch (drawMode) {
    case GLEnum2.POINTS:
      return "point-list";
    case GLEnum2.LINES:
      return "line-list";
    case GLEnum2.LINE_STRIP:
      return "line-strip";
    case GLEnum2.LINE_LOOP:
      return "line-loop-webgl";
    case GLEnum2.TRIANGLES:
      return "triangle-list";
    case GLEnum2.TRIANGLE_STRIP:
      return "triangle-strip";
    case GLEnum2.TRIANGLE_FAN:
      return "triangle-fan-webgl";
    default:
      throw new Error(drawMode);
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/create-gltf-objects.js
function createScenegraphsFromGLTF(device, gltf, options) {
  const instantiator = new GLTFInstantiator(device, options);
  const scenes = instantiator.instantiate(gltf);
  const animator = instantiator.createAnimator();
  return { scenes, animator };
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_mesh_features_exports = {};
__export(EXT_mesh_features_exports, {
  decode: () => decode,
  name: () => name
});

// node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(message || "assert failed: gltf");
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
var MIPMAP_FACTOR = 1.33;
var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
];
var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error("Illegal typed array");
  }
  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length2 = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  assert5(byteLength >= 0 && byteLength <= bufferView.byteLength);
  const componentByteSize = BYTES[accessor.componentType];
  const numberOfComponentsInElement = COMPONENTS[accessor.type];
  return { ArrayType, length: length2, byteLength, componentByteSize, numberOfComponentsInElement };
}
function getMemoryUsageGLTF(gltf) {
  let { images, bufferViews } = gltf;
  images = images || [];
  bufferViews = bufferViews || [];
  const imageBufferViews = images.map((i3) => i3.bufferView);
  bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));
  const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);
  const pixelCount = images.reduce((acc, image) => {
    const { width, height } = image.image;
    return acc + width * height;
  }, 0);
  return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  assert5(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  assert5(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
function getTypedArrayForAccessor(json, buffers, accessor) {
  var _a, _b;
  const gltfAccessor = typeof accessor === "number" ? (_a = json.accessors) == null ? void 0 : _a[accessor] : accessor;
  if (!gltfAccessor) {
    throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
  }
  const bufferView = (_b = json.bufferViews) == null ? void 0 : _b[gltfAccessor.bufferView || 0];
  if (!bufferView) {
    throw new Error(`No gltf buffer view for accessor ${bufferView}`);
  }
  const { arrayBuffer, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];
  const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
  const { ArrayType, length: length2, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
  const elementByteSize = componentByteSize * numberOfComponentsInElement;
  const elementAddressScale = bufferView.byteStride || elementByteSize;
  if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
    const result2 = new ArrayType(arrayBuffer, byteOffset, length2);
    return result2;
  }
  const result = new ArrayType(length2);
  for (let i3 = 0; i3 < gltfAccessor.count; i3++) {
    const values = new ArrayType(arrayBuffer, byteOffset + i3 * elementAddressScale, numberOfComponentsInElement);
    result.set(values, i3 * numberOfComponentsInElement);
  }
  return result;
}

// node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
function makeDefaultGLTFJson() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
var GLTFScenegraph = class {
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(gltf) {
    // internal
    __publicField(this, "gltf");
    __publicField(this, "sourceBuffers");
    __publicField(this, "byteLength");
    this.gltf = {
      json: (gltf == null ? void 0 : gltf.json) || makeDefaultGLTFJson(),
      buffers: (gltf == null ? void 0 : gltf.buffers) || [],
      images: (gltf == null ? void 0 : gltf.images) || []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;
    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }
  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }
  hasExtension(extensionName) {
    const isUsedExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const isRequiredExtension = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
  }
  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] : null;
  }
  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }
  getScene(index) {
    return this.getObject("scenes", index);
  }
  getNode(index) {
    return this.getObject("nodes", index);
  }
  getSkin(index) {
    return this.getObject("skins", index);
  }
  getMesh(index) {
    return this.getObject("meshes", index);
  }
  getMaterial(index) {
    return this.getObject("materials", index);
  }
  getAccessor(index) {
    return this.getObject("accessors", index);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(index) {
    return this.getObject("textures", index);
  }
  getSampler(index) {
    return this.getObject("samplers", index);
  }
  getImage(index) {
    return this.getObject("images", index);
  }
  getBufferView(index) {
    return this.getObject("bufferViews", index);
  }
  getBuffer(index) {
    return this.getObject("buffers", index);
  }
  getObject(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = this.gltf.buffers[bufferIndex];
    assert5(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(accessor) {
    const gltfAccessor = this.getAccessor(accessor);
    return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }
  addObjectExtension(object, extensionName, data) {
    object.extensions = object.extensions || {};
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }
  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
  }
  removeObjectExtension(object, extensionName) {
    const extensions = (object == null ? void 0 : object.extensions) || {};
    if (extensions[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    delete extensions[extensionName];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(extensionName, extensionData = {}) {
    assert5(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(extensionName, extensionData = {}) {
    assert5(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(extensionName) {
    var _a;
    if ((_a = this.json.extensions) == null ? void 0 : _a[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(sceneIndex) {
    this.json.scene = sceneIndex;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(scene) {
    const { nodeIndices } = scene;
    this.json.scenes = this.json.scenes || [];
    this.json.scenes.push({ nodes: nodeIndices });
    return this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(node) {
    const { meshIndex, matrix } = node;
    this.json.nodes = this.json.nodes || [];
    const nodeData = { mesh: meshIndex };
    if (matrix) {
      nodeData.matrix = matrix;
    }
    this.json.nodes.push(nodeData);
    return this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(mesh) {
    const { attributes, indices, material, mode = 4 } = mesh;
    const accessors = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          mode
        }
      ]
    };
    if (indices) {
      const indicesAccessor = this._addIndices(indices);
      glTFMesh.primitives[0].indices = indicesAccessor;
    }
    if (Number.isFinite(material)) {
      glTFMesh.primitives[0].material = material;
    }
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0
          // GL.POINTS
        }
      ]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(imageData, mimeTypeOpt) {
    const metadata = getBinaryImageMetadata(imageData);
    const mimeType = mimeTypeOpt || (metadata == null ? void 0 : metadata.mimeType);
    const bufferViewIndex = this.addBufferView(imageData);
    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };
    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {
    const byteLength = buffer.byteLength;
    assert5(Number.isFinite(byteLength));
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);
    const glTFBufferView = {
      buffer: bufferIndex,
      // Write offset from the start of the binary body
      byteOffset,
      byteLength
    };
    this.byteLength += padToNBytes(byteLength, 4);
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      // @ts-ignore
      type: getAccessorTypeFromSize(accessor.size),
      // @ts-ignore
      componentType: accessor.componentType,
      // @ts-ignore
      count: accessor.count,
      // @ts-ignore
      max: accessor.max,
      // @ts-ignore
      min: accessor.min
    };
    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    let minMax = { min: accessor.min, max: accessor.max };
    if (!minMax.min || !minMax.max) {
      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
    }
    const accessorDefaults = {
      // @ts-ignore
      size: accessor.size,
      componentType: getComponentTypeFromArray(sourceBuffer),
      // @ts-ignore
      count: Math.round(sourceBuffer.length / accessor.size),
      min: minMax.min,
      max: minMax.max
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(texture) {
    const { imageIndex } = texture;
    const glTFTexture = {
      source: imageIndex
    };
    this.json.textures = this.json.textures || [];
    this.json.textures.push(glTFTexture);
    return this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(pbrMaterialInfo) {
    this.json.materials = this.json.materials || [];
    this.json.materials.push(pbrMaterialInfo);
    return this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    var _a, _b;
    this.gltf.buffers = [];
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;
    for (const sourceBuffer of this.sourceBuffers || []) {
      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
    }
    if ((_b = (_a = this.json) == null ? void 0 : _a.buffers) == null ? void 0 : _b[0]) {
      this.json.buffers[0].byteLength = totalByteLength;
    } else {
      this.json.buffers = [{ byteLength: totalByteLength }];
    }
    this.gltf.binary = arrayBuffer;
    this.sourceBuffers = [arrayBuffer];
  }
  // PRIVATE
  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(attributes = {}) {
    const result = {};
    for (const attributeKey in attributes) {
      const attributeData = attributes[attributeKey];
      const attrName = this._getGltfAttributeName(attributeKey);
      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
      result[attrName] = accessor;
    }
    return result;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(indices) {
    return this.addBinaryBuffer(indices, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(attributeName) {
    switch (attributeName.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return attributeName;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(buffer, size) {
    const result = { min: null, max: null };
    if (buffer.length < size) {
      return result;
    }
    result.min = [];
    result.max = [];
    const initValues = buffer.subarray(0, size);
    for (const value of initValues) {
      result.min.push(value);
      result.max.push(value);
    }
    for (let index = size; index < buffer.length; index += size) {
      for (let componentIndex = 0; componentIndex < size; componentIndex++) {
        result.min[0 + componentIndex] = Math.min(
          // @ts-ignore
          result.min[0 + componentIndex],
          buffer[index + componentIndex]
        );
        result.max[0 + componentIndex] = Math.max(
          // @ts-ignore
          result.max[0 + componentIndex],
          buffer[index + componentIndex]
        );
      }
    }
    return result;
  }
};

// node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
function emod(n2) {
  return (n2 % 1 + 1) % 1;
}
var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3 = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function getArrayElementByteSize(attributeType, componentType) {
  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
}
function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
  if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
    return null;
  }
  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
  const arrayOffsets = convertRawBufferToMetadataArray(
    arrayOffsetsBytes,
    "SCALAR",
    // offsets consist of ONE component
    offsetType,
    numberOfElements + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
    return null;
  }
  return arrayOffsets;
}
function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {
  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3[componentType];
  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
  const length2 = elementCount * numberOfComponents;
  const byteLength = length2 * size;
  let buffer = data.buffer;
  let offset = data.byteOffset;
  if (offset % size !== 0) {
    const bufferArray = new Uint8Array(buffer);
    buffer = bufferArray.slice(offset, offset + byteLength).buffer;
    offset = 0;
  }
  return new ArrayType(buffer, offset, length2);
}
function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
  var _a, _b, _c, _d, _e;
  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
  const json = scenegraph.gltf.json;
  const textureIndex = textureInfo.index;
  const imageIndex = (_b = (_a = json.textures) == null ? void 0 : _a[textureIndex]) == null ? void 0 : _b.source;
  if (typeof imageIndex !== "undefined") {
    const mimeType = (_d = (_c = json.images) == null ? void 0 : _c[imageIndex]) == null ? void 0 : _d.mimeType;
    const parsedImage = (_e = scenegraph.gltf.images) == null ? void 0 : _e[imageIndex];
    if (parsedImage && typeof parsedImage.width !== "undefined") {
      const textureData = [];
      for (let index = 0; index < textureCoordinates.length; index += 2) {
        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);
        textureData.push(value);
      }
      return textureData;
    }
  }
  return [];
}
function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
  if (!(propertyData == null ? void 0 : propertyData.length)) {
    return;
  }
  const featureIndices = [];
  for (const texelData of propertyData) {
    let index = featureTable.findIndex((item) => item === texelData);
    if (index === -1) {
      index = featureTable.push(texelData) - 1;
    }
    featureIndices.push(index);
  }
  const typedArray = new Uint32Array(featureIndices);
  const bufferIndex = scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  }) - 1;
  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
    size: 1,
    componentType: getComponentTypeFromArray(typedArray),
    count: typedArray.length
  });
  primitive.attributes[attributeName] = accessorIndex;
}
function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {
  const CHANNELS_MAP = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  };
  const u = textureCoordinates[index];
  const v = textureCoordinates[index + 1];
  let components = 1;
  if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
    components = 4;
  const offset = coordinatesToOffset(u, v, parsedImage, components);
  let value = 0;
  for (const c2 of channels) {
    const map = typeof c2 === "number" ? Object.values(CHANNELS_MAP)[c2] : CHANNELS_MAP[c2];
    const imageOffset = offset + map.offset;
    const imageData = getImageData(parsedImage);
    if (imageData.data.length <= imageOffset) {
      throw new Error(`${imageData.data.length} <= ${imageOffset}`);
    }
    const imageValue = imageData.data[imageOffset];
    value |= imageValue << map.shift;
  }
  return value;
}
function coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {
  const w = parsedImage.width;
  const iX = emod(u) * (w - 1);
  const indX = Math.round(iX);
  const h = parsedImage.height;
  const iY = emod(v) * (h - 1);
  const indY = Math.round(iY);
  const components = parsedImage.components ? parsedImage.components : componentsCount;
  const offset = (indY * w + indX) * components;
  return offset;
}
function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / valueSize;
    const elementCount = arrayByteSize / valueSize;
    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
  }
  return attributeValueArray;
}
function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = index * arrayCount;
    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
  }
  return attributeValueArray;
}
function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
  if (arrayOffsets) {
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  }
  if (stringOffsets) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    for (let index = 0; index < numberOfElements; index++) {
      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];
      if (stringByteSize + stringOffset <= valuesDataBytes.length) {
        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
        const stringAttribute = textDecoder.decode(stringData);
        stringsArray.push(stringAttribute);
        stringOffset += stringByteSize;
      }
    }
    return stringsArray;
  }
  return [];
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
var name = EXT_MESH_FEATURES_NAME;
async function decode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtMeshFeatures(scenegraph, options);
}
function decodeExtMeshFeatures(scenegraph, options) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return;
  }
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processMeshPrimitiveFeatures(scenegraph, primitive, options);
    }
  }
}
function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
  var _a, _b, _c;
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = (_b = primitive.extensions) == null ? void 0 : _b[EXT_MESH_FEATURES_NAME];
  const featureIds = extension == null ? void 0 : extension.featureIds;
  if (!featureIds) {
    return;
  }
  for (const featureId of featureIds) {
    let featureIdData;
    if (typeof featureId.attribute !== "undefined") {
      const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
      const accessorIndex = primitive.attributes[accessorKey];
      featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
    } else if (typeof featureId.texture !== "undefined" && ((_c = options == null ? void 0 : options.gltf) == null ? void 0 : _c.loadImages)) {
      featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
    } else {
      featureIdData = [];
    }
    featureId.data = featureIdData;
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
var EXT_structural_metadata_exports = {};
__export(EXT_structural_metadata_exports, {
  decode: () => decode2,
  name: () => name2
});
var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
var name2 = EXT_STRUCTURAL_METADATA_NAME;
async function decode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtStructuralMetadata(scenegraph, options);
}
function decodeExtStructuralMetadata(scenegraph, options) {
  var _a, _b;
  if (!((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if ((_b = options.gltf) == null ? void 0 : _b.loadImages) {
    decodePropertyTextures(scenegraph, extension);
  }
  decodePropertyTables(scenegraph, extension);
}
function decodePropertyTextures(scenegraph, extension) {
  const propertyTextures = extension.propertyTextures;
  const json = scenegraph.gltf.json;
  if (propertyTextures && json.meshes) {
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
      }
    }
  }
}
function decodePropertyTables(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.propertyTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass(propertyTables, schemaClassName) {
  for (const propertyTable of propertyTables) {
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
  var _a;
  if (!propertyTextures) {
    return;
  }
  const primitiveExtension = (_a = primitive.extensions) == null ? void 0 : _a[EXT_STRUCTURAL_METADATA_NAME];
  const primitivePropertyTextureIndices = primitiveExtension == null ? void 0 : primitiveExtension.propertyTextures;
  if (!primitivePropertyTextureIndices) {
    return;
  }
  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
  }
}
function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
  var _a;
  if (!propertyTexture.properties) {
    return;
  }
  if (!extension.dataAttributeNames) {
    extension.dataAttributeNames = [];
  }
  const className = propertyTexture.class;
  for (const propertyName in propertyTexture.properties) {
    const attributeName = `${className}_${propertyName}`;
    const textureInfoTopLevel = (_a = propertyTexture.properties) == null ? void 0 : _a[propertyName];
    if (!textureInfoTopLevel) {
      continue;
    }
    if (!textureInfoTopLevel.data) {
      textureInfoTopLevel.data = [];
    }
    const featureTextureTable = textureInfoTopLevel.data;
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (propertyData === null) {
      continue;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
    textureInfoTopLevel.data = featureTextureTable;
    extension.dataAttributeNames.push(attributeName);
  }
}
function processPropertyTable(scenegraph, schema, propertyTable) {
  var _a, _b;
  const schemaClass = (_a = schema.classes) == null ? void 0 : _a[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = (_b = propertyTable.properties) == null ? void 0 : _b[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
  let data = [];
  const valuesBufferView = propertyTableProperty.values;
  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
  switch (classProperty.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    case "BOOLEAN": {
      throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
    }
    case "STRING": {
      data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
      break;
    }
    case "ENUM": {
      data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${classProperty.type}`);
  }
  return data;
}
function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.count === "undefined" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray2 = classProperty.array;
  const arrayCount = classProperty.count;
  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData;
  if (classProperty.componentType) {
    valuesData = convertRawBufferToMetadataArray(
      valuesDataBytes,
      classProperty.type,
      // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
      classProperty.componentType,
      elementCount
    );
  } else {
    valuesData = valuesDataBytes;
  }
  if (isArray2) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  var _a;
  const enumType = classProperty.enumType;
  if (!enumType) {
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  }
  const enumEntry = (_a = schema.enums) == null ? void 0 : _a[enumType];
  if (!enumEntry) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
  }
  const enumValueType = enumEntry.valueType || "UINT16";
  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
  if (!valuesData) {
    valuesData = valuesDataBytes;
  }
  if (classProperty.array) {
    if (arrayOffsets) {
      return parseVariableLengthArrayENUM({
        valuesData,
        numberOfElements,
        arrayOffsets,
        valuesDataBytesLength: valuesDataBytes.length,
        elementSize,
        enumEntry
      });
    }
    const arrayCount = classProperty.count;
    if (arrayCount) {
      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
    }
    return [];
  }
  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
}
function parseVariableLengthArrayENUM(params) {
  const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / elementSize;
    const elementCount = arrayByteSize / elementSize;
    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = arrayCount * index;
    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function getEnumsArray(valuesData, offset, count, enumEntry) {
  const array = [];
  for (let i3 = 0; i3 < count; i3++) {
    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
      array.push("");
    } else {
      const value = valuesData[offset + i3];
      const enumObject = getEnumByValue(enumEntry, value);
      if (enumObject) {
        array.push(enumObject.name);
      } else {
        array.push("");
      }
    }
  }
  return array;
}
function getEnumByValue(enumEntry, value) {
  for (const enumValue of enumEntry.values) {
    if (enumValue.value === value) {
      return enumValue;
    }
  }
  return null;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
var EXT_feature_metadata_exports = {};
__export(EXT_feature_metadata_exports, {
  decode: () => decode3,
  name: () => name3
});
var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
var name3 = EXT_FEATURE_METADATA_NAME;
async function decode3(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtFeatureMetadata(scenegraph, options);
}
function decodeExtFeatureMetadata(scenegraph, options) {
  var _a, _b;
  if (!((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
  if (!extension) {
    return;
  }
  if ((_b = options.gltf) == null ? void 0 : _b.loadImages) {
    decodePropertyTextures2(scenegraph, extension);
  }
  decodePropertyTables2(scenegraph, extension);
}
function decodePropertyTextures2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const { featureTextures } = extension;
  if (schemaClasses && featureTextures) {
    for (const schemaName in schemaClasses) {
      const schemaClass = schemaClasses[schemaName];
      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
      if (featureTexture) {
        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
      }
    }
  }
}
function decodePropertyTables2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.featureTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable2(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass2(propertyTables, schemaClassName) {
  for (const propertyTableName in propertyTables) {
    const propertyTable = propertyTables[propertyTableName];
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function findFeatureTextureByClass(featureTextures, schemaClassName) {
  for (const featureTexturesName in featureTextures) {
    const featureTable = featureTextures[featureTexturesName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function processPropertyTable2(scenegraph, schema, propertyTable) {
  var _a, _b;
  if (!propertyTable.class) {
    return;
  }
  const schemaClass = (_a = schema.classes) == null ? void 0 : _a[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = (_b = propertyTable.properties) == null ? void 0 : _b[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
  var _a;
  const attributeName = featureTexture.class;
  for (const propertyName in schemaClass.properties) {
    const featureTextureProperty = (_a = featureTexture == null ? void 0 : featureTexture.properties) == null ? void 0 : _a[propertyName];
    if (featureTextureProperty) {
      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
      featureTextureProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
  let data = [];
  const bufferView = featureTableProperty.bufferView;
  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
  const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
  } else if (isNumericProperty(classProperty)) {
    data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
  }
  return data;
}
function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.componentCount === "undefined" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.arrayOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.stringOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function isNumericProperty(schemaProperty) {
  const types = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
}
function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray2 = classProperty.type === "ARRAY";
  const arrayCount = classProperty.componentCount;
  const attributeType = "SCALAR";
  const componentType = classProperty.componentType || classProperty.type;
  const elementSize = getArrayElementByteSize(attributeType, componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
  if (isArray2) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return [];
  }
  const featureTextureTable = [];
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
    }
  }
  return featureTextureTable;
}
function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
  const textureInfoTopLevel = {
    channels: featureTextureProperty.channels,
    ...featureTextureProperty.texture
  };
  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
  if (!propertyData) {
    return;
  }
  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
}

// node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
var VERSION5 = true ? "4.2.0-beta.2" : "latest";

// node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
var LITTLE_ENDIAN = true;
var MAGIC_glTF = 1735152710;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLB_V1_CONTENT_FORMAT_JSON = 0;
var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString(dataView, byteOffset = 0) {
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const { magic = MAGIC_glTF } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN);
  Object.assign(glb, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset,
      // Byte offset into the initial arrayBuffer
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += padToNBytes(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder("utf8");
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return padToNBytes(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
    // TODO - copy, or create typed array view?
  });
  return padToNBytes(chunkLength, 4);
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
function resolveUrl(url, options) {
  const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_meshopt_compression_exports = {};
__export(EXT_meshopt_compression_exports, {
  decode: () => decode5,
  name: () => name4
});

// node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
var detector = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]);
var wasmpack = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]);
var FILTERS = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
};
var DECODERS = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = "NONE") {
  const instance = await loadWasmInstance();
  decode4(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
}
var wasmPromise;
async function loadWasmInstance() {
  if (!wasmPromise) {
    wasmPromise = loadWasmModule();
  }
  return wasmPromise;
}
async function loadWasmModule() {
  let wasm3 = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm3 = wasm_simd;
    console.log("Warning: meshopt_decoder is using experimental SIMD support");
  }
  const result = await WebAssembly.instantiate(unpack(wasm3), {});
  await result.instance.exports.__wasm_call_ctors();
  return result.instance;
}
function unpack(data) {
  const result = new Uint8Array(data.length);
  for (let i3 = 0; i3 < data.length; ++i3) {
    const ch = data.charCodeAt(i3);
    result[i3] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
  }
  let write = 0;
  for (let i3 = 0; i3 < data.length; ++i3) {
    result[write++] = result[i3] < 60 ? wasmpack[result[i3]] : (result[i3] - 60) * 64 + result[++i3];
  }
  return result.buffer.slice(0, write);
}
function decode4(instance, fun, target, count, size, source, filter) {
  const sbrk = instance.exports.sbrk;
  const count4 = count + 3 & ~3;
  const tp = sbrk(count4 * size);
  const sp = sbrk(source.length);
  const heap = new Uint8Array(instance.exports.memory.buffer);
  heap.set(source, sp);
  const res = fun(tp, count, size, sp, source.length);
  if (res === 0 && filter) {
    filter(tp, count4, size);
  }
  target.set(heap.subarray(tp, tp + count * size));
  sbrk(tp - sbrk(0));
  if (res !== 0) {
    throw new Error(`Malformed buffer data: ${res}`);
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
var name4 = EXT_MESHOPT_COMPRESSION;
async function decode5(gltfData, options) {
  var _a, _b;
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.decompressMeshes) || !((_b = options.gltf) == null ? void 0 : _b.loadBuffers)) {
    return;
  }
  const promises = [];
  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
  }
  await Promise.all(promises);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
async function decodeMeshoptBufferView(scenegraph, bufferView) {
  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  if (meshoptExtension) {
    const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = "NONE", buffer: bufferIndex } = meshoptExtension;
    const buffer = scenegraph.gltf.buffers[bufferIndex];
    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
    scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
var EXT_texture_webp_exports = {};
__export(EXT_texture_webp_exports, {
  name: () => name5,
  preprocess: () => preprocess
});
var EXT_TEXTURE_WEBP = "EXT_texture_webp";
var name5 = EXT_TEXTURE_WEBP;
function preprocess(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!isImageFormatSupported("image/webp")) {
    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
    }
    return;
  }
  const { json } = scenegraph;
  for (const texture of json.textures || []) {
    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
    if (extension) {
      texture.source = extension.source;
    }
    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
  }
  scenegraph.removeExtension(EXT_TEXTURE_WEBP);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
var KHR_texture_basisu_exports = {};
__export(KHR_texture_basisu_exports, {
  name: () => name6,
  preprocess: () => preprocess2
});
var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
var name6 = KHR_TEXTURE_BASISU;
function preprocess2(gltfData, options) {
  const scene = new GLTFScenegraph(gltfData);
  const { json } = scene;
  for (const texture of json.textures || []) {
    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
    if (extension) {
      texture.source = extension.source;
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
  }
  scene.removeExtension(KHR_TEXTURE_BASISU);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_draco_mesh_compression_exports = {};
__export(KHR_draco_mesh_compression_exports, {
  decode: () => decode6,
  encode: () => encode,
  name: () => name7,
  preprocess: () => preprocess3
});

// node_modules/@loaders.gl/draco/dist/lib/utils/version.js
var VERSION6 = true ? "4.2.0-beta.2" : "latest";

// node_modules/@loaders.gl/draco/dist/draco-loader.js
var DracoLoader = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: VERSION6,
  worker: true,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: true,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};

// node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
function getDracoSchema(attributes, loaderData, indices) {
  const metadata = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }
  if (indices) {
    const indicesField = getArrowFieldFromAttribute("indices", indices);
    fields.push(indicesField);
  }
  return { fields, metadata };
}
function transformAttributesLoaderData(loaderData) {
  const result = {};
  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || "undefined"] = dracoAttribute;
  }
  return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
  const field = deduceMeshField(attributeName, attribute, metadataMap);
  return field;
}
function makeMetadata(metadata) {
  Object.entries(metadata);
  const serializedMetadata = {};
  for (const key in metadata) {
    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
  }
  return serializedMetadata;
}

// node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
};
var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
};
var INDEX_ITEM_SIZE = 4;
var DracoParser = class {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(draco) {
    __publicField(this, "draco");
    __publicField(this, "decoder");
    __publicField(this, "metadataQuerier");
    this.draco = draco;
    this.decoder = new this.draco.Decoder();
    this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder);
    this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(arrayBuffer, options = {}) {
    const buffer = new this.draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
    this._disableAttributeTransforms(options);
    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let dracoStatus;
      switch (geometry_type) {
        case this.draco.TRIANGULAR_MESH:
          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          break;
        case this.draco.POINT_CLOUD:
          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
        throw new Error(message);
      }
      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
      const geometry = this._getMeshData(dracoGeometry, loaderData, options);
      const boundingBox = getMeshBoundingBox(geometry.attributes);
      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
      const data = {
        loader: "draco",
        loaderData,
        header: {
          vertexCount: dracoGeometry.num_points(),
          boundingBox
        },
        ...geometry,
        schema
      };
      return data;
    } finally {
      this.draco.destroy(buffer);
      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry);
      }
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(dracoGeometry, geometry_type, options) {
    const metadata = this._getTopLevelMetadata(dracoGeometry);
    const attributes = this._getDracoAttributes(dracoGeometry, options);
    return {
      geometry_type,
      num_attributes: dracoGeometry.num_attributes(),
      num_points: dracoGeometry.num_points(),
      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
      metadata,
      attributes
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(dracoGeometry, options) {
    const dracoAttributes = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
      dracoAttributes[dracoAttribute.unique_id()] = {
        unique_id: dracoAttribute.unique_id(),
        attribute_type: dracoAttribute.attribute_type(),
        data_type: dracoAttribute.data_type(),
        num_components: dracoAttribute.num_components(),
        byte_offset: dracoAttribute.byte_offset(),
        byte_stride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        attribute_index: attributeId,
        metadata
      };
      const quantization = this._getQuantizationTransform(dracoAttribute, options);
      if (quantization) {
        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
      }
      const octahedron = this._getOctahedronTransform(dracoAttribute, options);
      if (octahedron) {
        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
      }
    }
    return dracoAttributes;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(dracoGeometry, loaderData, options) {
    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
    const positionAttribute = attributes.POSITION;
    if (!positionAttribute) {
      throw new Error("DRACO: No position attribute found.");
    }
    if (dracoGeometry instanceof this.draco.Mesh) {
      switch (options.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes,
            indices: {
              value: this._getTriangleStripIndices(dracoGeometry),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes,
            indices: {
              value: this._getTriangleListIndices(dracoGeometry),
              size: 1
            }
          };
      }
    }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes
    };
  }
  _getMeshAttributes(loaderData, dracoGeometry, options) {
    const attributes = {};
    for (const loaderAttribute of Object.values(loaderData.attributes)) {
      const attributeName = this._deduceAttributeName(loaderAttribute, options);
      loaderAttribute.name = attributeName;
      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);
      if (values) {
        const { value, size } = values;
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
    }
    return attributes;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * INDEX_ITEM_SIZE;
    const ptr = this.draco._malloc(byteLength);
    try {
      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
    } finally {
      this.draco._free(ptr);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      return getUint32Array(dracoArray);
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(dracoGeometry, attribute) {
    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
    if (!TypedArrayCtor) {
      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);
      return null;
    }
    const numComponents = attribute.num_components;
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(this.draco, TypedArrayCtor);
    let value;
    const ptr = this.draco._malloc(byteLength);
    try {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
    } finally {
      this.draco._free(ptr);
    }
    return { value, size: numComponents };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(attribute, options) {
    const uniqueId = attribute.unique_id;
    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
      if (attributeUniqueId === uniqueId) {
        return attributeName;
      }
    }
    const thisAttributeType = attribute.attribute_type;
    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];
      if (attributeType === thisAttributeType) {
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }
    const entryName = options.attributeNameEntry || "name";
    if (attribute.metadata[entryName]) {
      return attribute.metadata[entryName].string;
    }
    return `CUSTOM_ATTRIBUTE_${uniqueId}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(dracoGeometry) {
    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
    return this._getDracoMetadata(dracoMetadata);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(dracoGeometry, attributeId) {
    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._getDracoMetadata(dracoMetadata);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }
    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
    }
    return result;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(dracoMetadata, entryName) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
      const intArray = getInt32Array(dracoArray);
      return {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray
      };
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(options) {
    const { quantizedAttributes = [], octahedronAttributes = [] } = options;
    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
    for (const dracoAttributeName of skipAttributes) {
      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
    }
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(dracoAttribute, options) {
    const { quantizedAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (skip) {
      const transform2 = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform2.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform2.quantization_bits(),
            range: transform2.range(),
            min_values: new Float32Array([1, 2, 3]).map((i3) => transform2.min_value(i3))
          };
        }
      } finally {
        this.draco.destroy(transform2);
      }
    }
    return null;
  }
  _getOctahedronTransform(dracoAttribute, options) {
    const { octahedronAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (octahedron) {
      const transform2 = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform2.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform2.quantization_bits()
          };
        }
      } finally {
        this.draco.destroy(transform2);
      }
    }
    return null;
  }
};
function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;
    case Int8Array:
      return draco.DT_INT8;
    case Int16Array:
      return draco.DT_INT16;
    case Int32Array:
      return draco.DT_INT32;
    case Uint8Array:
      return draco.DT_UINT8;
    case Uint16Array:
      return draco.DT_UINT16;
    case Uint32Array:
      return draco.DT_UINT32;
    default:
      return draco.DT_INVALID;
  }
}
function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i3 = 0; i3 < numValues; i3++) {
    intArray[i3] = dracoArray.GetValue(i3);
  }
  return intArray;
}
function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i3 = 0; i3 < numValues; i3++) {
    intArray[i3] = dracoArray.GetValue(i3);
  }
  return intArray;
}

// node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
var DRACO_DECODER_VERSION = "1.5.6";
var DRACO_ENCODER_VERSION = "1.4.1";
var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
var DRACO_EXTERNAL_LIBRARIES = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
};
var DRACO_EXTERNAL_LIBRARY_URLS = {
  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
};
var loadDecoderPromise;
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};
  if (modules.draco3d) {
    loadDecoderPromise || (loadDecoderPromise = modules.draco3d.createDecoderModule({}).then((draco) => {
      return { draco };
    }));
  } else {
    loadDecoderPromise || (loadDecoderPromise = loadDracoDecoder(options));
  }
  return await loadDecoderPromise;
}
async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case "js":
      DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER),
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)
      ]);
  }
  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}
function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: (draco) => resolve({ draco })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}

// node_modules/@loaders.gl/draco/dist/index.js
var DracoLoader2 = {
  ...DracoLoader,
  parse
};
async function parse(arrayBuffer, options) {
  const { draco } = await loadDracoDecoderModule(options);
  const dracoParser = new DracoParser(draco);
  try {
    return dracoParser.parseSync(arrayBuffer, options == null ? void 0 : options.draco);
  } finally {
    dracoParser.destroy();
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name12 in attributes) {
    const attribute = attributes[name12];
    if (name12 !== "indices") {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name12] = glTFAccessor;
    }
  }
  return accessors;
}
function getGLTFAccessor(attribute) {
  const { buffer, size, count } = getAccessorData(attribute);
  const glTFAccessor = {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: buffer,
    size,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count,
    type: getAccessorTypeFromSize(size),
    componentType: getComponentTypeFromArray(buffer)
  };
  return glTFAccessor;
}
function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;
  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }
  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }
  return { buffer, size, count };
}
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
var name7 = KHR_DRACO_MESH_COMPRESSION;
function preprocess3(gltfData, options, context) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
    }
  }
}
async function decode6(gltfData, options, context) {
  var _a;
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.decompressMeshes)) {
    return;
  }
  const scenegraph = new GLTFScenegraph(gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }
  await Promise.all(promises);
  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
}
function encode(gltfData, options = {}) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
  }
}
async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  if (!dracoExtension) {
    return;
  }
  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
  const dracoOptions = { ...options };
  delete dracoOptions["3d-tiles"];
  const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
  const decodedAttributes = getGLTFAccessors(decodedData.attributes);
  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);
      if ((accessor == null ? void 0 : accessor.min) && (accessor == null ? void 0 : accessor.max)) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }
  primitive.attributes = decodedAttributes;
  if (decodedData.indices) {
    primitive.indices = getGLTFAccessor(decodedData.indices);
  }
  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  checkPrimitive(primitive);
}
function compressMesh(attributes, indices, mode = 4, options, context) {
  var _a;
  if (!options.DracoWriter) {
    throw new Error("options.gltf.DracoWriter not provided");
  }
  const compressedData = options.DracoWriter.encodeSync({ attributes });
  const decodedData = (_a = context == null ? void 0 : context.parseSync) == null ? void 0 : _a.call(context, { attributes });
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors,
        // TODO - verify with spec
        mode,
        // GL.POINTS
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
            // TODO - verify with spec
          }
        }
      }
    ]
  };
  return glTFMesh;
}
function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
  }
}
function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var KHR_texture_transform_exports = {};
__export(KHR_texture_transform_exports, {
  decode: () => decode7,
  name: () => name8
});
var KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
var name8 = KHR_TEXTURE_TRANSFORM;
var scratchVector7 = new Vector3();
var scratchRotationMatrix = new Matrix3();
var scratchScaleMatrix = new Matrix3();
async function decode7(gltfData, options) {
  var _a;
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);
  if (!hasExtension || !((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const materials = gltfData.json.materials || [];
  for (let i3 = 0; i3 < materials.length; i3++) {
    transformTexCoords(i3, gltfData);
  }
}
function transformTexCoords(materialIndex, gltfData) {
  var _a, _b, _c, _d;
  const material = (_a = gltfData.json.materials) == null ? void 0 : _a[materialIndex];
  const materialTextures = [
    (_b = material == null ? void 0 : material.pbrMetallicRoughness) == null ? void 0 : _b.baseColorTexture,
    material == null ? void 0 : material.emissiveTexture,
    material == null ? void 0 : material.normalTexture,
    material == null ? void 0 : material.occlusionTexture,
    (_c = material == null ? void 0 : material.pbrMetallicRoughness) == null ? void 0 : _c.metallicRoughnessTexture
  ];
  const processedTexCoords = [];
  for (const textureInfo of materialTextures) {
    if (textureInfo && ((_d = textureInfo == null ? void 0 : textureInfo.extensions) == null ? void 0 : _d[KHR_TEXTURE_TRANSFORM])) {
      transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);
    }
  }
}
function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
  const transformParameters = getTransformParameters(texture, processedTexCoords);
  if (!transformParameters) {
    return;
  }
  const meshes = gltfData.json.meshes || [];
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      const material = primitive.material;
      if (Number.isFinite(material) && materialIndex === material) {
        transformPrimitive(gltfData, primitive, transformParameters);
      }
    }
  }
}
function getTransformParameters(texture, processedTexCoords) {
  var _a;
  const textureInfo = (_a = texture.extensions) == null ? void 0 : _a[KHR_TEXTURE_TRANSFORM];
  const { texCoord: originalTexCoord = 0 } = texture;
  const { texCoord = originalTexCoord } = textureInfo;
  const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;
  if (!isProcessed) {
    const matrix = makeTransformationMatrix(textureInfo);
    if (originalTexCoord !== texCoord) {
      texture.texCoord = texCoord;
    }
    processedTexCoords.push([originalTexCoord, texCoord]);
    return { originalTexCoord, texCoord, matrix };
  }
  return null;
}
function transformPrimitive(gltfData, primitive, transformParameters) {
  var _a, _b;
  const { originalTexCoord, texCoord, matrix } = transformParameters;
  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
  if (Number.isFinite(texCoordAccessor)) {
    const accessor = (_a = gltfData.json.accessors) == null ? void 0 : _a[texCoordAccessor];
    if (accessor && accessor.bufferView) {
      const bufferView = (_b = gltfData.json.bufferViews) == null ? void 0 : _b[accessor.bufferView];
      if (bufferView) {
        const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];
        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
        const { ArrayType, length: length2 } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const bytes = BYTES[accessor.componentType];
        const components = COMPONENTS[accessor.type];
        const elementAddressScale = bufferView.byteStride || bytes * components;
        const result = new Float32Array(length2);
        for (let i3 = 0; i3 < accessor.count; i3++) {
          const uv = new ArrayType(arrayBuffer, byteOffset + i3 * elementAddressScale, 2);
          scratchVector7.set(uv[0], uv[1], 1);
          scratchVector7.transformByMatrix3(matrix);
          result.set([scratchVector7[0], scratchVector7[1]], i3 * components);
        }
        if (originalTexCoord === texCoord) {
          updateGltf(accessor, bufferView, gltfData.buffers, result);
        } else {
          createAttribute(texCoord, accessor, primitive, gltfData, result);
        }
      }
    }
  }
}
function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
  accessor.componentType = 5126;
  buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  bufferView.buffer = buffers.length - 1;
  bufferView.byteLength = newTexCoordArray.buffer.byteLength;
  bufferView.byteOffset = 0;
  delete bufferView.byteStride;
}
function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
  gltfData.buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  const bufferViews = gltfData.json.bufferViews;
  if (!bufferViews) {
    return;
  }
  bufferViews.push({
    buffer: gltfData.buffers.length - 1,
    byteLength: newTexCoordArray.buffer.byteLength,
    byteOffset: 0
  });
  const accessors = gltfData.json.accessors;
  if (!accessors) {
    return;
  }
  accessors.push({
    bufferView: (bufferViews == null ? void 0 : bufferViews.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: originalAccessor.count,
    type: "VEC2"
  });
  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
}
function makeTransformationMatrix(extensionData) {
  const { offset = [0, 0], rotation = 0, scale = [1, 1] } = extensionData;
  const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
  const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);
  return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
var KHR_lights_punctual_exports = {};
__export(KHR_lights_punctual_exports, {
  decode: () => decode8,
  encode: () => encode2,
  name: () => name9
});
var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
var name9 = KHR_LIGHTS_PUNCTUAL;
async function decode8(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
  }
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    if (nodeExtension) {
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
  }
}
async function encode2(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (json.lights) {
    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
    assert5(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
    }
    delete gltfScenegraph.json.lights;
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
var KHR_materials_unlit_exports = {};
__export(KHR_materials_unlit_exports, {
  decode: () => decode9,
  encode: () => encode3,
  name: () => name10
});
var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
var name10 = KHR_MATERIALS_UNLIT;
async function decode9(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
  }
  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
}
function encode3(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
      }
    }
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
var KHR_techniques_webgl_exports = {};
__export(KHR_techniques_webgl_exports, {
  decode: () => decode10,
  encode: () => encode4,
  name: () => name11
});
var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
var name11 = KHR_TECHNIQUES_WEBGL;
async function decode10(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);
    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      if (materialExtension) {
        material.technique = Object.assign(
          {},
          materialExtension,
          // @ts-ignore
          techniques[materialExtension.technique]
        );
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
    }
    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
  }
}
async function encode4(gltfData, options) {
}
function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const { programs = [], shaders = [], techniques = [] } = techniquesExtension;
  const textDecoder = new TextDecoder();
  shaders.forEach((shader) => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error("KHR_techniques_webgl: no shader code");
    }
  });
  programs.forEach((program) => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach((technique) => {
    technique.program = programs[technique.program];
  });
  return techniques;
}
function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach((uniform) => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach((uniform) => {
    if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}

// node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
var EXTENSIONS = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  EXT_structural_metadata_exports,
  EXT_mesh_features_exports,
  EXT_meshopt_compression_exports,
  EXT_texture_webp_exports,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  KHR_texture_basisu_exports,
  KHR_draco_mesh_compression_exports,
  KHR_lights_punctual_exports,
  KHR_materials_unlit_exports,
  KHR_techniques_webgl_exports,
  KHR_texture_transform_exports,
  EXT_feature_metadata_exports
];
function preprocessExtensions(gltf, options = {}, context) {
  var _a;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    (_a = extension.preprocess) == null ? void 0 : _a.call(extension, gltf, options, context);
  }
}
async function decodeExtensions(gltf, options = {}, context) {
  var _a;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    await ((_a = extension.decode) == null ? void 0 : _a.call(extension, gltf, options, context));
  }
}
function useExtension(extensionName, options) {
  var _a;
  const excludes = ((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.excludeExtensions) || {};
  const exclude = extensionName in excludes && !excludes[extensionName];
  return !exclude;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
var KHR_BINARY_GLTF = "KHR_binary_glTF";
function preprocess4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const image of json.images || []) {
    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
    if (extension) {
      Object.assign(image, extension);
    }
    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
  }
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }
  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
}

// node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
var GLTF_ARRAYS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
};
var GLTF_KEYS = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
var GLTFV1Normalizer = class {
  constructor() {
    __publicField(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    });
    __publicField(this, "json");
  }
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;
    switch (json.asset && json.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${json.asset.version}`);
        return;
    }
    if (!options.normalize) {
      throw new Error("glTF v1 is not supported.");
    }
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
    this._addAsset(json);
    this._convertTopLevelObjectsToArrays(json);
    preprocess4(gltf);
    this._convertObjectIdsToArrayIndices(json);
    this._updateObjects(json);
    this._updateMaterial(json);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(json) {
    json.asset = json.asset || {};
    json.asset.version = "2.0";
    json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];
    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }
    json[mapName] = [];
    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id;
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }
    if ("scene" in json) {
      json.scene = this._convertIdToIndex(json.scene, "scene");
    }
    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }
    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }
    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }
    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }
  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, "image");
    }
  }
  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const { attributes, indices, material } = primitive;
      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
      }
      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, "accessor");
      }
      if (material) {
        primitive.material = this._convertIdToIndex(material, "material");
      }
    }
  }
  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
    }
    if (node.meshes) {
      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
    }
  }
  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
    }
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(json, topLevelArrayName) {
    if (!json[topLevelArrayName]) {
      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
      json[topLevelArrayName] = [];
    }
    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];
        const index = this._convertIdToIndex(id, key);
        object[key] = index;
      }
    }
  }
  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];
    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];
      if (!Number.isFinite(index)) {
        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
      }
      return index;
    }
    return id;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      delete buffer.type;
    }
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(json) {
    var _a, _b, _c;
    for (const material of json.materials) {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const textureId = ((_a = material.values) == null ? void 0 : _a.tex) || ((_b = material.values) == null ? void 0 : _b.texture2d_0) || ((_c = material.values) == null ? void 0 : _c.diffuseTex);
      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
      if (textureIndex !== -1) {
        material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
      }
    }
  }
};
function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}

// node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  var _a, _b, _c;
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, { normalize: (_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.normalize });
  preprocessExtensions(gltf, options, context);
  if (((_b = options == null ? void 0 : options.gltf) == null ? void 0 : _b.loadBuffers) && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }
  if ((_c = options == null ? void 0 : options.gltf) == null ? void 0 : _c.loadImages) {
    await loadImages(gltf, options, context);
  }
  await decodeExtensions(gltf, options, context);
  return gltf;
}
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }
  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }
  if (typeof data === "string") {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
    assert5(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert5(false, "GLTF: must be ArrayBuffer or string");
  }
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const { binChunks } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}
async function loadBuffers(gltf, options, context) {
  var _a, _b;
  const buffers = gltf.json.buffers || [];
  for (let i3 = 0; i3 < buffers.length; ++i3) {
    const buffer = buffers[i3];
    if (buffer.uri) {
      const { fetch: fetch2 } = context;
      assert5(fetch2);
      const uri = resolveUrl(buffer.uri, options);
      const response = await ((_a = context == null ? void 0 : context.fetch) == null ? void 0 : _a.call(context, uri));
      const arrayBuffer = await ((_b = response == null ? void 0 : response.arrayBuffer) == null ? void 0 : _b.call(response));
      gltf.buffers[i3] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    } else if (gltf.buffers[i3] === null) {
      gltf.buffers[i3] = {
        arrayBuffer: new ArrayBuffer(buffer.byteLength),
        byteOffset: 0,
        byteLength: buffer.byteLength
      };
    }
  }
}
async function loadImages(gltf, options, context) {
  const imageIndices = getReferencesImageIndices(gltf);
  const images = gltf.json.images || [];
  const promises = [];
  for (const imageIndex of imageIndices) {
    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
  }
  return await Promise.all(promises);
}
function getReferencesImageIndices(gltf) {
  const imageIndices = /* @__PURE__ */ new Set();
  const textures = gltf.json.textures || [];
  for (const texture of textures) {
    if (texture.source !== void 0) {
      imageIndices.add(texture.source);
    }
  }
  return Array.from(imageIndices).sort();
}
async function loadImage(gltf, image, index, options, context) {
  let arrayBuffer;
  if (image.uri && !image.hasOwnProperty("bufferView")) {
    const uri = resolveUrl(image.uri, options);
    const { fetch: fetch2 } = context;
    const response = await fetch2(uri);
    arrayBuffer = await response.arrayBuffer();
    image.bufferView = {
      data: arrayBuffer
    };
  }
  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }
  assert5(arrayBuffer, "glTF image has no data");
  let parsedImage = await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {
    ...options,
    mimeType: image.mimeType,
    basis: options.basis || { format: selectSupportedBasisFormat() }
  }, context);
  if (parsedImage && parsedImage[0]) {
    parsedImage = {
      compressed: true,
      // @ts-expect-error
      mipmaps: false,
      width: parsedImage[0].width,
      height: parsedImage[0].height,
      data: parsedImage[0]
    };
  }
  gltf.images = gltf.images || [];
  gltf.images[index] = parsedImage;
}

// node_modules/@loaders.gl/gltf/dist/gltf-loader.js
var GLTFLoader = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: VERSION5,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: true,
  binary: true,
  tests: ["glTF"],
  parse: parse2,
  options: {
    gltf: {
      normalize: true,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: true,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: true,
      // Create image objects
      decompressMeshes: true
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function parse2(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options, ...options };
  options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };
  const { byteOffset = 0 } = options;
  const gltf = {};
  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
}

// node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
var COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES2 = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};
var GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER_PARAMETERS2 = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
};
function makeDefaultSampler() {
  return {
    id: "default-sampler",
    parameters: DEFAULT_SAMPLER_PARAMETERS2
  };
}
function getBytesFromComponentType(componentType) {
  return BYTES2[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS2[type];
}
var GLTFPostProcessor = class {
  constructor() {
    __publicField(this, "baseUri", "");
    // @ts-expect-error
    __publicField(this, "jsonUnprocessed");
    // @ts-expect-error
    __publicField(this, "json");
    __publicField(this, "buffers", []);
    __publicField(this, "images", []);
  }
  postProcess(gltf, options = {}) {
    const { json, buffers = [], images = [] } = gltf;
    const { baseUri = "" } = gltf;
    assert5(json);
    this.baseUri = baseUri;
    this.buffers = buffers;
    this.images = images;
    this.jsonUnprocessed = json;
    this.json = this._resolveTree(gltf.json, options);
    return this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(gltf, options = {}) {
    const json = { ...gltf };
    this.json = json;
    if (gltf.bufferViews) {
      json.bufferViews = gltf.bufferViews.map((bufView, i3) => this._resolveBufferView(bufView, i3));
    }
    if (gltf.images) {
      json.images = gltf.images.map((image, i3) => this._resolveImage(image, i3));
    }
    if (gltf.samplers) {
      json.samplers = gltf.samplers.map((sampler, i3) => this._resolveSampler(sampler, i3));
    }
    if (gltf.textures) {
      json.textures = gltf.textures.map((texture, i3) => this._resolveTexture(texture, i3));
    }
    if (gltf.accessors) {
      json.accessors = gltf.accessors.map((accessor, i3) => this._resolveAccessor(accessor, i3));
    }
    if (gltf.materials) {
      json.materials = gltf.materials.map((material, i3) => this._resolveMaterial(material, i3));
    }
    if (gltf.meshes) {
      json.meshes = gltf.meshes.map((mesh, i3) => this._resolveMesh(mesh, i3));
    }
    if (gltf.nodes) {
      json.nodes = gltf.nodes.map((node, i3) => this._resolveNode(node, i3));
      json.nodes = json.nodes.map((node, i3) => this._resolveNodeChildren(node));
    }
    if (gltf.skins) {
      json.skins = gltf.skins.map((skin, i3) => this._resolveSkin(skin, i3));
    }
    if (gltf.scenes) {
      json.scenes = gltf.scenes.map((scene, i3) => this._resolveScene(scene, i3));
    }
    if (typeof this.json.scene === "number" && json.scenes) {
      json.scene = json.scenes[this.json.scene];
    }
    return json;
  }
  getScene(index) {
    return this._get(this.json.scenes, index);
  }
  getNode(index) {
    return this._get(this.json.nodes, index);
  }
  getSkin(index) {
    return this._get(this.json.skins, index);
  }
  getMesh(index) {
    return this._get(this.json.meshes, index);
  }
  getMaterial(index) {
    return this._get(this.json.materials, index);
  }
  getAccessor(index) {
    return this._get(this.json.accessors, index);
  }
  getCamera(index) {
    return this._get(this.json.cameras, index);
  }
  getTexture(index) {
    return this._get(this.json.textures, index);
  }
  getSampler(index) {
    return this._get(this.json.samplers, index);
  }
  getImage(index) {
    return this._get(this.json.images, index);
  }
  getBufferView(index) {
    return this._get(this.json.bufferViews, index);
  }
  getBuffer(index) {
    return this._get(this.json.buffers, index);
  }
  _get(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = array && array[index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  // PARSING HELPERS
  _resolveScene(scene, index) {
    return {
      ...scene,
      // @ts-ignore
      id: scene.id || `scene-${index}`,
      nodes: (scene.nodes || []).map((node) => this.getNode(node))
    };
  }
  _resolveNode(gltfNode, index) {
    const node = {
      ...gltfNode,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: (gltfNode == null ? void 0 : gltfNode.id) || `node-${index}`
    };
    if (gltfNode.mesh !== void 0) {
      node.mesh = this.getMesh(gltfNode.mesh);
    }
    if (gltfNode.camera !== void 0) {
      node.camera = this.getCamera(gltfNode.camera);
    }
    if (gltfNode.skin !== void 0) {
      node.skin = this.getSkin(gltfNode.skin);
    }
    if (gltfNode.meshes !== void 0 && gltfNode.meshes.length) {
      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
        const mesh = this.getMesh(meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, { primitives: [] });
    }
    return node;
  }
  _resolveNodeChildren(node) {
    if (node.children) {
      node.children = node.children.map((child) => this.getNode(child));
    }
    return node;
  }
  _resolveSkin(gltfSkin, index) {
    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : void 0;
    return {
      ...gltfSkin,
      id: gltfSkin.id || `skin-${index}`,
      inverseBindMatrices
    };
  }
  _resolveMesh(gltfMesh, index) {
    const mesh = {
      ...gltfMesh,
      id: gltfMesh.id || `mesh-${index}`,
      primitives: []
    };
    if (gltfMesh.primitives) {
      mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
        const primitive = {
          ...gltfPrimitive,
          attributes: {},
          indices: void 0,
          material: void 0
        };
        const attributes = gltfPrimitive.attributes;
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (gltfPrimitive.indices !== void 0) {
          primitive.indices = this.getAccessor(gltfPrimitive.indices);
        }
        if (gltfPrimitive.material !== void 0) {
          primitive.material = this.getMaterial(gltfPrimitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }
  _resolveMaterial(gltfMaterial, index) {
    const material = {
      ...gltfMaterial,
      // @ts-expect-error
      id: gltfMaterial.id || `material-${index}`
    };
    if (material.normalTexture) {
      material.normalTexture = { ...material.normalTexture };
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture = { ...material.occlusionTexture };
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture = { ...material.emissiveTexture };
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }
    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
    }
    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = { ...mr.baseColorTexture };
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }
  _resolveAccessor(gltfAccessor, index) {
    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
    const components = getSizeFromAccessorType(gltfAccessor.type);
    const bytesPerElement = bytesPerComponent * components;
    const accessor = {
      ...gltfAccessor,
      // @ts-expect-error
      id: gltfAccessor.id || `accessor-${index}`,
      bytesPerComponent,
      components,
      bytesPerElement,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (gltfAccessor.bufferView !== void 0) {
      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
    }
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
      if (accessor.bufferView.byteStride) {
        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
      }
      accessor.value = new ArrayType(cutBuffer);
    }
    return accessor;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
    const result = new Uint8Array(count * bytesPerElement);
    for (let i3 = 0; i3 < count; i3++) {
      const elementOffset = byteOffset + i3 * byteStride;
      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i3 * bytesPerElement);
    }
    return result.buffer;
  }
  _resolveTexture(gltfTexture, index) {
    return {
      ...gltfTexture,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfTexture.id || `texture-${index}`,
      sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
      source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : void 0
    };
  }
  _resolveSampler(gltfSampler, index) {
    const sampler = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfSampler.id || `sampler-${index}`,
      ...gltfSampler,
      parameters: {}
    };
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== void 0) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }
  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }
  _resolveImage(gltfImage, index) {
    const image = {
      ...gltfImage,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfImage.id || `image-${index}`,
      image: null,
      bufferView: gltfImage.bufferView !== void 0 ? this.getBufferView(gltfImage.bufferView) : void 0
    };
    const preloadedImage = this.images[index];
    if (preloadedImage) {
      image.image = preloadedImage;
    }
    return image;
  }
  _resolveBufferView(gltfBufferView, index) {
    const bufferIndex = gltfBufferView.buffer;
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
    if (gltfBufferView.byteOffset) {
      byteOffset += gltfBufferView.byteOffset;
    }
    const bufferView = {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${index}`,
      ...gltfBufferView,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[bufferIndex],
      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)
    };
    return bufferView;
  }
  _resolveCamera(gltfCamera, index) {
    const camera = {
      ...gltfCamera,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfCamera.id || `camera-${index}`
    };
    if (camera.perspective) {
    }
    if (camera.orthographic) {
    }
    return camera;
  }
};
function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((modelNode) => {
      Object.values(modelNode.model.uniforms).forEach((uniform) => {
        if (uniform.loaded === false) {
          remaining.push(uniform);
        }
      });
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(MODULE_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef MODULE_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(sizeScale);
float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
uniform float opacity;
in vec4 vColor;
out vec4 fragColor;
#ifndef MODULE_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D u_BaseColorSampler;
#endif
#endif
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR11 = [255, 255, 255, 255];
var defaultProps26 = {
  scenegraph: { type: "object", value: null, async: true },
  getScene: (gltf) => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (x2) => x2.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR11 },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [GLTFLoader]
};
var _ScenegraphLayer = class _ScenegraphLayer extends Layer {
  getShaders() {
    const modules = [project32_default, picking_default];
    if (this.props._lighting === "pbr") {
      modules.push(pbr);
    }
    return super.getShaders({ vs: scenegraph_layer_vertex_glsl_default, fs: scenegraph_layer_fragment_glsl_default, modules });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: true
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR11,
        transition: true
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph();
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.animator, props._animations);
    }
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.scenegraph) && super.isLoaded);
  }
  _updateScenegraph() {
    var _a;
    const props = this.props;
    const { device } = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof ScenegraphNode) {
      scenegraphData = { scenes: [props.scenegraph] };
    } else if (props.scenegraph && typeof props.scenegraph === "object") {
      const gltf = props.scenegraph;
      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;
      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());
      scenegraphData = { gltf: processedGLTF, ...gltfObjects };
      waitForGLTFAssets(gltfObjects).then(() => {
        this.setNeedsRedraw();
      }).catch((ex) => {
        this.raiseError(ex, "loading glTF");
      });
    }
    const options = { layer: this, device: this.context.device };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);
    if (scenegraph instanceof GroupNode) {
      (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
      this._applyAnimationsProp(animator, props._animations);
      const models = [];
      scenegraph.traverse((node) => {
        if (node instanceof ModelNode) {
          models.push(node.model);
        }
      });
      this.setState({ scenegraph, animator, models });
      this.getAttributeManager().invalidateAll();
    } else if (scenegraph !== null) {
      log_default.warn("invalid scenegraph:", scenegraph)();
    }
  }
  _applyAnimationsProp(animator, animationsProp) {
    if (!animator || !animationsProp) {
      return;
    }
    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach((key) => {
      const value = animationsProp[key];
      if (key === "*") {
        animations.forEach((animation) => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);
        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      } else {
        const findResult = animations.find(({ name: name12 }) => name12 === key);
        if (findResult) {
          Object.assign(findResult, value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment } = this.props;
    let env;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === "function") {
        env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }
    return {
      imageBasedLightingEnvironment: env,
      modelOptions: {
        id: this.props.id,
        isInstanced: true,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: false
    };
  }
  draw({ context }) {
    if (!this.state.scenegraph)
      return;
    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem } = this.props;
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((node, { worldMatrix }) => {
      if (node instanceof ModelNode) {
        const { model } = node;
        model.setInstanceCount(numInstances);
        model.setUniforms({
          sizeScale,
          opacity,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix,
          // Needed for PBR (TODO: find better way to get it)
          // eslint-disable-next-line camelcase
          u_Camera: model.uniforms.project_uCameraPosition
        });
        model.draw(renderPass);
      }
    });
  }
};
_ScenegraphLayer.defaultProps = defaultProps26;
_ScenegraphLayer.layerName = "ScenegraphLayer";
var ScenegraphLayer = _ScenegraphLayer;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project_uCameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer.js
function validateGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      size: 4,
      value: new Uint8Array(vertexCount * 4).fill(255),
      normalized: true
    };
  }
}
var defaultProps27 = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: true }
};
var _MeshLayer = class _MeshLayer extends SimpleMeshLayer {
  getShaders() {
    const shaders = super.getShaders();
    const modules = shaders.modules;
    modules.push(pbr);
    return { ...shaders, vs: mesh_layer_vertex_glsl_default, fs: mesh_layer_fragment_glsl_default };
  }
  initializeState() {
    const { featureIds } = this.props;
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    if (featureIds) {
      attributeManager.add({
        featureIdsPickingColors: {
          type: "uint8",
          size: 3,
          noAlloc: true,
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateFeatureIdsPickingColors
        }
      });
    }
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.pbrMaterial !== oldProps.pbrMaterial) {
      this.updatePbrMaterialUniforms(props.pbrMaterial);
    }
  }
  draw(opts) {
    const { featureIds } = this.props;
    if (!this.state.model) {
      return;
    }
    this.state.model.setUniforms({
      // Needed for PBR (TODO: find better way to get it)
      // eslint-disable-next-line camelcase
      u_Camera: this.state.model.uniforms.project_uCameraPosition,
      pickFeatureIds: Boolean(featureIds)
    });
    super.draw(opts);
  }
  getModel(mesh) {
    const { id, pbrMaterial } = this.props;
    const parsedPBRMaterial = this.parseMaterial(pbrMaterial, mesh);
    this.setState({ parsedPBRMaterial });
    const shaders = this.getShaders();
    validateGeometryAttributes(mesh.attributes);
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id,
      geometry: mesh,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...shaders.defines,
        ...parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.defines,
        HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0
      },
      parameters: parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.parameters,
      isInstanced: true
    });
    return model;
  }
  updatePbrMaterialUniforms(pbrMaterial) {
    const { model } = this.state;
    if (model) {
      const { mesh } = this.props;
      const parsedPBRMaterial = this.parseMaterial(pbrMaterial, mesh);
      this.setState({ parsedPBRMaterial });
      model.setBindings(parsedPBRMaterial.bindings);
      model.setUniforms(parsedPBRMaterial.uniforms);
    }
  }
  parseMaterial(pbrMaterial, mesh) {
    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);
    return parsePBRMaterial(this.context.device, { unlit, ...pbrMaterial }, { NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords }, {
      pbrDebug: false,
      lights: true,
      useTangents: false
    });
  }
  calculateFeatureIdsPickingColors(attribute) {
    const featureIds = this.props.featureIds;
    const value = new Uint8ClampedArray(featureIds.length * attribute.size);
    const pickingColor = [];
    for (let index = 0; index < featureIds.length; index++) {
      this.encodePickingColor(featureIds[index], pickingColor);
      value[index * 3] = pickingColor[0];
      value[index * 3 + 1] = pickingColor[1];
      value[index * 3 + 2] = pickingColor[2];
    }
    attribute.value = value;
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.parsedPBRMaterial) == null ? void 0 : _a.generatedTextures.forEach((texture) => texture.destroy());
    this.setState({ parsedPBRMaterial: null });
  }
};
_MeshLayer.layerName = "MeshLayer";
_MeshLayer.defaultProps = defaultProps27;
var MeshLayer = _MeshLayer;

// node_modules/@math.gl/geospatial/dist/constants.js
var WGS84_RADIUS_X = 6378137;
var WGS84_RADIUS_Y = 6378137;
var WGS84_RADIUS_Z = 6356752314245179e-9;
var WGS84_CONSTANTS = {
  radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
  radiiSquared: [
    WGS84_RADIUS_X * WGS84_RADIUS_X,
    WGS84_RADIUS_Y * WGS84_RADIUS_Y,
    WGS84_RADIUS_Z * WGS84_RADIUS_Z
  ],
  oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
  oneOverRadiiSquared: [
    1 / (WGS84_RADIUS_X * WGS84_RADIUS_X),
    1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),
    1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)
  ],
  maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
  centerToleranceSquared: 0.1
  // EPSILON1;
};

// node_modules/@math.gl/geospatial/dist/type-utils.js
function identity(x2) {
  return x2;
}
var scratchVector8 = new Vector3();
function fromCartographic(cartographic, result = [], map = identity) {
  if ("longitude" in cartographic) {
    result[0] = map(cartographic.longitude);
    result[1] = map(cartographic.latitude);
    result[2] = cartographic.height;
  } else if ("x" in cartographic) {
    result[0] = map(cartographic.x);
    result[1] = map(cartographic.y);
    result[2] = cartographic.z;
  } else {
    result[0] = map(cartographic[0]);
    result[1] = map(cartographic[1]);
    result[2] = cartographic[2];
  }
  return result;
}
function fromCartographicToRadians(cartographic, vector = []) {
  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);
}
function toCartographic(vector, cartographic, map = identity) {
  if ("longitude" in cartographic) {
    cartographic.longitude = map(vector[0]);
    cartographic.latitude = map(vector[1]);
    cartographic.height = vector[2];
  } else if ("x" in cartographic) {
    cartographic.x = map(vector[0]);
    cartographic.y = map(vector[1]);
    cartographic.z = vector[2];
  } else {
    cartographic[0] = map(vector[0]);
    cartographic[1] = map(vector[1]);
    cartographic[2] = vector[2];
  }
  return cartographic;
}
function toCartographicFromRadians(vector, cartographic) {
  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/ellipsoid-transform.js
var EPSILON14 = 1e-14;
var scratchOrigin = new Vector3();
var VECTOR_PRODUCT_LOCAL_FRAME = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
};
var degeneratePositionLocalFrame = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
};
var scratchAxisVectors = {
  east: new Vector3(),
  north: new Vector3(),
  up: new Vector3(),
  west: new Vector3(),
  south: new Vector3(),
  down: new Vector3()
};
var scratchVector1 = new Vector3();
var scratchVector24 = new Vector3();
var scratchVector33 = new Vector3();
function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
  assert4(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
  let firstAxisVector;
  let secondAxisVector;
  let thirdAxisVector;
  const origin = scratchOrigin.copy(cartesianOrigin);
  const atPole = equals(origin.x, 0, EPSILON14) && equals(origin.y, 0, EPSILON14);
  if (atPole) {
    const sign2 = Math.sign(origin.z);
    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
    if (firstAxis !== "east" && firstAxis !== "west") {
      firstAxisVector.scale(sign2);
    }
    secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
    if (secondAxis !== "east" && secondAxis !== "west") {
      secondAxisVector.scale(sign2);
    }
    thirdAxisVector = scratchVector33.fromArray(degeneratePositionLocalFrame[thirdAxis]);
    if (thirdAxis !== "east" && thirdAxis !== "west") {
      thirdAxisVector.scale(sign2);
    }
  } else {
    const { up, east, north } = scratchAxisVectors;
    east.set(-origin.y, origin.x, 0).normalize();
    ellipsoid.geodeticSurfaceNormal(origin, up);
    north.copy(up).cross(east);
    const { down, west, south } = scratchAxisVectors;
    down.copy(up).scale(-1);
    west.copy(east).scale(-1);
    south.copy(north).scale(-1);
    firstAxisVector = scratchAxisVectors[firstAxis];
    secondAxisVector = scratchAxisVectors[secondAxis];
    thirdAxisVector = scratchAxisVectors[thirdAxis];
  }
  result[0] = firstAxisVector.x;
  result[1] = firstAxisVector.y;
  result[2] = firstAxisVector.z;
  result[3] = 0;
  result[4] = secondAxisVector.x;
  result[5] = secondAxisVector.y;
  result[6] = secondAxisVector.z;
  result[7] = 0;
  result[8] = thirdAxisVector.x;
  result[9] = thirdAxisVector.y;
  result[10] = thirdAxisVector.z;
  result[11] = 0;
  result[12] = origin.x;
  result[13] = origin.y;
  result[14] = origin.z;
  result[15] = 1;
  return result;
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/scale-to-geodetic-surface.js
var scratchVector9 = new Vector3();
var scaleToGeodeticSurfaceIntersection = new Vector3();
var scaleToGeodeticSurfaceGradient = new Vector3();
function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
  const { oneOverRadii, oneOverRadiiSquared, centerToleranceSquared } = ellipsoid;
  scratchVector9.from(cartesian);
  const positionX = scratchVector9.x;
  const positionY = scratchVector9.y;
  const positionZ = scratchVector9.z;
  const oneOverRadiiX = oneOverRadii.x;
  const oneOverRadiiY = oneOverRadii.y;
  const oneOverRadiiZ = oneOverRadii.z;
  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
  const squaredNorm = x2 + y2 + z2;
  const ratio = Math.sqrt(1 / squaredNorm);
  if (!Number.isFinite(ratio)) {
    return void 0;
  }
  const intersection = scaleToGeodeticSurfaceIntersection;
  intersection.copy(cartesian).scale(ratio);
  if (squaredNorm < centerToleranceSquared) {
    return intersection.to(result);
  }
  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
  const gradient = scaleToGeodeticSurfaceGradient;
  gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
  let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
  let correction = 0;
  let xMultiplier;
  let yMultiplier;
  let zMultiplier;
  let func;
  do {
    lambda -= correction;
    xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
    yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
    zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
    const xMultiplier2 = xMultiplier * xMultiplier;
    const yMultiplier2 = yMultiplier * yMultiplier;
    const zMultiplier2 = zMultiplier * zMultiplier;
    const xMultiplier3 = xMultiplier2 * xMultiplier;
    const yMultiplier3 = yMultiplier2 * yMultiplier;
    const zMultiplier3 = zMultiplier2 * zMultiplier;
    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
    const derivative = -2 * denominator;
    correction = func / derivative;
  } while (Math.abs(func) > math_utils_exports.EPSILON12);
  return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/ellipsoid.js
var scratchVector10 = new Vector3();
var scratchNormal3 = new Vector3();
var scratchK = new Vector3();
var scratchPosition2 = new Vector3();
var scratchHeight = new Vector3();
var scratchCartesian = new Vector3();
var Ellipsoid = class {
  constructor(x2 = 0, y2 = 0, z = 0) {
    this.centerToleranceSquared = math_utils_exports.EPSILON1;
    assert4(x2 >= 0);
    assert4(y2 >= 0);
    assert4(z >= 0);
    this.radii = new Vector3(x2, y2, z);
    this.radiiSquared = new Vector3(x2 * x2, y2 * y2, z * z);
    this.radiiToTheFourth = new Vector3(x2 * x2 * x2 * x2, y2 * y2 * y2 * y2, z * z * z * z);
    this.oneOverRadii = new Vector3(x2 === 0 ? 0 : 1 / x2, y2 === 0 ? 0 : 1 / y2, z === 0 ? 0 : 1 / z);
    this.oneOverRadiiSquared = new Vector3(x2 === 0 ? 0 : 1 / (x2 * x2), y2 === 0 ? 0 : 1 / (y2 * y2), z === 0 ? 0 : 1 / (z * z));
    this.minimumRadius = Math.min(x2, y2, z);
    this.maximumRadius = Math.max(x2, y2, z);
    if (this.radiiSquared.z !== 0) {
      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
    }
    Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(right) {
    return this === right || Boolean(right && this.radii.equals(right.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(cartographic, result = [0, 0, 0]) {
    const normal = scratchNormal3;
    const k = scratchK;
    const [, , height] = cartographic;
    this.geodeticSurfaceNormalCartographic(cartographic, normal);
    k.copy(this.radiiSquared).scale(normal);
    const gamma = Math.sqrt(normal.dot(k));
    k.scale(1 / gamma);
    normal.scale(height);
    k.add(normal);
    return k.to(result);
  }
  cartesianToCartographic(cartesian, result = [0, 0, 0]) {
    scratchCartesian.from(cartesian);
    const point2 = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
    if (!point2) {
      return void 0;
    }
    const normal = this.geodeticSurfaceNormal(point2, scratchNormal3);
    const h = scratchHeight;
    h.copy(scratchCartesian).subtract(point2);
    const longitude = Math.atan2(normal.y, normal.x);
    const latitude = Math.asin(normal.z);
    const height = Math.sign(vec3_exports.dot(h, scratchCartesian)) * vec3_exports.length(h);
    return toCartographicFromRadians([longitude, latitude, height], result);
  }
  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
    return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
  }
  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
    return scratchVector10.from(cartesian).normalize().to(result);
  }
  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
    const cartographicVectorRadians = fromCartographicToRadians(cartographic);
    const longitude = cartographicVectorRadians[0];
    const latitude = cartographicVectorRadians[1];
    const cosLatitude = Math.cos(latitude);
    scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
    return scratchVector10.to(result);
  }
  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
    return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(cartesian, result) {
    return scaleToGeodeticSurface(cartesian, this, result);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
    scratchPosition2.from(cartesian);
    const positionX = scratchPosition2.x;
    const positionY = scratchPosition2.y;
    const positionZ = scratchPosition2.z;
    const oneOverRadiiSquared = this.oneOverRadiiSquared;
    const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
    return scratchPosition2.multiplyScalar(beta).to(result);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(position, result = [0, 0, 0]) {
    return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
    return scratchPosition2.from(position).scale(this.radii).to(result);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
    assert4(equals(this.radii.x, this.radii.y, math_utils_exports.EPSILON15));
    assert4(this.radii.z > 0);
    scratchPosition2.from(position);
    const z = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
    if (Math.abs(z) >= this.radii.z - buffer) {
      return void 0;
    }
    return scratchPosition2.set(0, 0, z).to(result);
  }
};
Ellipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);

// node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list-node.js
var DoublyLinkedListNode = class {
  constructor(item, previous, next) {
    __publicField(this, "item");
    __publicField(this, "previous");
    __publicField(this, "next");
    this.item = item;
    this.previous = previous;
    this.next = next;
  }
};

// node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list.js
var DoublyLinkedList = class {
  constructor() {
    __publicField(this, "head", null);
    __publicField(this, "tail", null);
    __publicField(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(item) {
    const node = new DoublyLinkedListNode(item, this.tail, null);
    if (this.tail) {
      this.tail.next = node;
      this.tail = node;
    } else {
      this.head = node;
      this.tail = node;
    }
    ++this._length;
    return node;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(node) {
    if (!node) {
      return;
    }
    if (node.previous && node.next) {
      node.previous.next = node.next;
      node.next.previous = node.previous;
    } else if (node.previous) {
      node.previous.next = null;
      this.tail = node.previous;
    } else if (node.next) {
      node.next.previous = null;
      this.head = node.next;
    } else {
      this.head = null;
      this.tail = null;
    }
    node.next = null;
    node.previous = null;
    --this._length;
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(node, nextNode) {
    if (node === nextNode) {
      return;
    }
    this.remove(nextNode);
    this._insert(node, nextNode);
  }
  _insert(node, nextNode) {
    const oldNodeNext = node.next;
    node.next = nextNode;
    if (this.tail === node) {
      this.tail = nextNode;
    } else {
      oldNodeNext.previous = nextNode;
    }
    nextNode.next = oldNodeNext;
    nextNode.previous = node;
    ++this._length;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-cache.js
var TilesetCache = class {
  constructor() {
    __publicField(this, "_list");
    __publicField(this, "_sentinel");
    __publicField(this, "_trimTiles");
    this._list = new DoublyLinkedList();
    this._sentinel = this._list.add("sentinel");
    this._trimTiles = false;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(tile) {
    const node = tile._cacheNode;
    if (node) {
      this._list.splice(this._sentinel, node);
    }
  }
  add(tileset, tile, addCallback) {
    if (!tile._cacheNode) {
      tile._cacheNode = this._list.add(tile);
      if (addCallback) {
        addCallback(tileset, tile);
      }
    }
  }
  unloadTile(tileset, tile, unloadCallback) {
    const node = tile._cacheNode;
    if (!node) {
      return;
    }
    this._list.remove(node);
    tile._cacheNode = null;
    if (unloadCallback) {
      unloadCallback(tileset, tile);
    }
  }
  unloadTiles(tileset, unloadCallback) {
    const trimTiles = this._trimTiles;
    this._trimTiles = false;
    const list = this._list;
    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
    const sentinel = this._sentinel;
    let node = list.head;
    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
      const tile = node.item;
      node = node.next;
      this.unloadTile(tileset, tile, unloadCallback);
    }
  }
  trim() {
    this._trimTiles = true;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/transform-utils.js
function calculateTransformProps(tileHeader, tile) {
  assert2(tileHeader);
  assert2(tile);
  const { rtcCenter, gltfUpAxis } = tile;
  const { computedTransform, boundingVolume: { center } } = tileHeader;
  let modelMatrix2 = new Matrix4(computedTransform);
  if (rtcCenter) {
    modelMatrix2.translate(rtcCenter);
  }
  switch (gltfUpAxis) {
    case "Z":
      break;
    case "Y":
      const rotationY = new Matrix4().rotateX(Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
      break;
    case "X":
      const rotationX = new Matrix4().rotateY(-Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
      break;
    default:
      break;
  }
  if (tile.isQuantized) {
    modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
  }
  const cartesianOrigin = new Vector3(center);
  tile.cartesianModelMatrix = modelMatrix2;
  tile.cartesianOrigin = cartesianOrigin;
  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
  tile.cartographicOrigin = cartographicOrigin;
  if (!tile.coordinateSystem) {
    tile.modelMatrix = tile.cartographicModelMatrix;
  }
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/frame-state.js
var scratchVector11 = new Vector3();
var scratchPosition3 = new Vector3();
var cullingVolume = new CullingVolume([
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane()
]);
function getFrameState(viewport, frameNumber) {
  const { cameraDirection, cameraUp, height } = viewport;
  const { metersPerUnit } = viewport.distanceScales;
  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
  const cameraDirectionCartesian = new Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))
  ).normalize();
  const cameraUpCartesian = new Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))
  ).normalize();
  commonSpacePlanesToWGS84(viewport);
  const ViewportClass = viewport.constructor;
  const { longitude, latitude, width, bearing, zoom } = viewport;
  const topDownViewport = new ViewportClass({
    longitude,
    latitude,
    height,
    width,
    bearing,
    zoom,
    pitch: 0
  });
  return {
    camera: {
      position: cameraPositionCartesian2,
      direction: cameraDirectionCartesian,
      up: cameraUpCartesian
    },
    viewport,
    topDownViewport,
    height,
    cullingVolume,
    frameNumber,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
    return [tiles, []];
  }
  const tuples = [];
  const { longitude: viewportLongitude, latitude: viewportLatitude } = frameState.viewport;
  for (const [index, tile] of tiles.entries()) {
    const [longitude, latitude] = tile.header.mbs;
    const deltaLon = Math.abs(viewportLongitude - longitude);
    const deltaLat = Math.abs(viewportLatitude - latitude);
    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
    tuples.push([index, distance]);
  }
  const tuplesSorted = tuples.sort((a3, b2) => a3[1] - b2[1]);
  const selectedTiles = [];
  for (let i3 = 0; i3 < maximumTilesSelected; i3++) {
    selectedTiles.push(tiles[tuplesSorted[i3][0]]);
  }
  const unselectedTiles = [];
  for (let i3 = maximumTilesSelected; i3 < tuplesSorted.length; i3++) {
    unselectedTiles.push(tiles[tuplesSorted[i3][0]]);
  }
  return [selectedTiles, unselectedTiles];
}
function commonSpacePlanesToWGS84(viewport) {
  const frustumPlanes = viewport.getFrustumPlanes();
  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
  let i3 = 0;
  cullingVolume.planes[i3++].fromPointNormal(nearCenterCartesian, scratchVector11.copy(nearCenterCartesian).subtract(cameraCartesian));
  for (const dir in frustumPlanes) {
    if (dir === "near") {
      continue;
    }
    const plane = frustumPlanes[dir];
    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
    cullingVolume.planes[i3++].fromPointNormal(
      cartesianPos,
      // Want the normal to point into the frustum since that's what culling expects
      scratchVector11.copy(nearCenterCartesian).subtract(cartesianPos)
    );
  }
}
function closestPointOnPlane(plane, refPoint, out = new Vector3()) {
  const distanceToRef = plane.normal.dot(refPoint);
  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
  return out;
}
function worldToCartesian(viewport, point2, out = new Vector3()) {
  const cartographicPos = viewport.unprojectPosition(point2);
  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/zoom.js
var WGS84_RADIUS_X2 = 6378137;
var WGS84_RADIUS_Y2 = 6378137;
var WGS84_RADIUS_Z2 = 6356752314245179e-9;
var scratchVector12 = new Vector3();
function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
  if (boundingVolume instanceof OrientedBoundingBox) {
    const { halfAxes } = boundingVolume;
    const obbSize = getObbSize(halfAxes);
    return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
  } else if (boundingVolume instanceof BoundingSphere) {
    const { radius } = boundingVolume;
    return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
  } else if (boundingVolume.width && boundingVolume.height) {
    const { width, height } = boundingVolume;
    const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
    const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
    return (zoomX + zoomY) / 2;
  }
  return 1;
}
function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
  Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector12);
  const extentSize = Math.sqrt(Math.pow(scratchVector12[0] - cartesianCenter[0], 2) + Math.pow(scratchVector12[1] - cartesianCenter[1], 2) + Math.pow(scratchVector12[2] - cartesianCenter[2], 2));
  return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
}
function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
  const [xmin, ymin, xmax, ymax] = extent;
  return getZoomFromFullExtent({ xmin, xmax, ymin, ymax, zmin: 0, zmax: 0 }, cartorgraphicCenter, cartesianCenter);
}
function getObbSize(halfAxes) {
  halfAxes.getColumn(0, scratchVector12);
  const axeY = halfAxes.getColumn(1);
  const axeZ = halfAxes.getColumn(2);
  const farthestVertex = scratchVector12.add(axeY).add(axeZ);
  const size = farthestVertex.len();
  return size;
}

// node_modules/@loaders.gl/tiles/dist/constants.js
var TILE_CONTENT_STATE = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var TILE_REFINEMENT;
(function(TILE_REFINEMENT2) {
  TILE_REFINEMENT2[TILE_REFINEMENT2["ADD"] = 1] = "ADD";
  TILE_REFINEMENT2[TILE_REFINEMENT2["REPLACE"] = 2] = "REPLACE";
})(TILE_REFINEMENT || (TILE_REFINEMENT = {}));
var TILE_TYPE;
(function(TILE_TYPE2) {
  TILE_TYPE2["EMPTY"] = "empty";
  TILE_TYPE2["SCENEGRAPH"] = "scenegraph";
  TILE_TYPE2["POINTCLOUD"] = "pointcloud";
  TILE_TYPE2["MESH"] = "mesh";
})(TILE_TYPE || (TILE_TYPE = {}));
var TILESET_TYPE;
(function(TILESET_TYPE2) {
  TILESET_TYPE2["I3S"] = "I3S";
  TILESET_TYPE2["TILES3D"] = "TILES3D";
})(TILESET_TYPE || (TILESET_TYPE = {}));
var LOD_METRIC_TYPE;
(function(LOD_METRIC_TYPE2) {
  LOD_METRIC_TYPE2["GEOMETRIC_ERROR"] = "geometricError";
  LOD_METRIC_TYPE2["MAX_SCREEN_THRESHOLD"] = "maxScreenThreshold";
})(LOD_METRIC_TYPE || (LOD_METRIC_TYPE = {}));
var TILE3D_OPTIMIZATION_HINT = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/bounding-volume.js
function defined(x2) {
  return x2 !== void 0 && x2 !== null;
}
var scratchPoint = new Vector3();
var scratchScale = new Vector3();
var scratchNorthWest = new Vector3();
var scratchSouthEast = new Vector3();
var scratchCenter = new Vector3();
var scratchXAxis = new Vector3();
var scratchYAxis = new Vector3();
var scratchZAxis = new Vector3();
function createBoundingVolume(boundingVolumeHeader, transform2, result) {
  assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
  if (boundingVolumeHeader.box) {
    return createBox(boundingVolumeHeader.box, transform2, result);
  }
  if (boundingVolumeHeader.region) {
    return createObbFromRegion(boundingVolumeHeader.region);
  }
  if (boundingVolumeHeader.sphere) {
    return createSphere(boundingVolumeHeader.sphere, transform2, result);
  }
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
  if (boundingVolumeHeader.box) {
    return orientedBoundingBoxToCartographicBounds(boundingVolume);
  }
  if (boundingVolumeHeader.region) {
    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
    return [
      [degrees(west), degrees(south), minHeight],
      [degrees(east), degrees(north), maxHeight]
    ];
  }
  if (boundingVolumeHeader.sphere) {
    return boundingSphereToCartographicBounds(boundingVolume);
  }
  throw new Error("Unkown boundingVolume type");
}
function createBox(box, transform2, result) {
  const center = new Vector3(box[0], box[1], box[2]);
  transform2.transform(center, center);
  let origin = [];
  if (box.length === 10) {
    const halfSize = box.slice(3, 6);
    const quaternion2 = new Quaternion();
    quaternion2.fromArray(box, 6);
    const x2 = new Vector3([1, 0, 0]);
    const y2 = new Vector3([0, 1, 0]);
    const z = new Vector3([0, 0, 1]);
    x2.transformByQuaternion(quaternion2);
    x2.scale(halfSize[0]);
    y2.transformByQuaternion(quaternion2);
    y2.scale(halfSize[1]);
    z.transformByQuaternion(quaternion2);
    z.scale(halfSize[2]);
    origin = [...x2.toArray(), ...y2.toArray(), ...z.toArray()];
  } else {
    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
  }
  const xAxis = transform2.transformAsVector(origin.slice(0, 3));
  const yAxis = transform2.transformAsVector(origin.slice(3, 6));
  const zAxis = transform2.transformAsVector(origin.slice(6, 9));
  const halfAxes = new Matrix3([
    xAxis[0],
    xAxis[1],
    xAxis[2],
    yAxis[0],
    yAxis[1],
    yAxis[2],
    zAxis[0],
    zAxis[1],
    zAxis[2]
  ]);
  if (defined(result)) {
    result.center = center;
    result.halfAxes = halfAxes;
    return result;
  }
  return new OrientedBoundingBox(center, halfAxes);
}
function createSphere(sphere, transform2, result) {
  const center = new Vector3(sphere[0], sphere[1], sphere[2]);
  transform2.transform(center, center);
  const scale = transform2.getScale(scratchScale);
  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);
  const radius = sphere[3] * uniformScale;
  if (defined(result)) {
    result.center = center;
    result.radius = radius;
    return result;
  }
  return new BoundingSphere(center, radius);
}
function createObbFromRegion(region) {
  const [west, south, east, north, minHeight, maxHeight] = region;
  const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
  const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
  const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);
  Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);
  Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);
  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);
  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);
  return createBox([
    ...centerInCartesian,
    ...scratchXAxis.subtract(centerInCartesian),
    ...scratchYAxis.subtract(centerInCartesian),
    ...scratchZAxis.subtract(centerInCartesian)
  ], new Matrix4());
}
function orientedBoundingBoxToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const { halfAxes } = boundingVolume;
  const xAxis = new Vector3(halfAxes.getColumn(0));
  const yAxis = new Vector3(halfAxes.getColumn(1));
  const zAxis = new Vector3(halfAxes.getColumn(2));
  for (let x2 = 0; x2 < 2; x2++) {
    for (let y2 = 0; y2 < 2; y2++) {
      for (let z = 0; z < 2; z++) {
        scratchPoint.copy(boundingVolume.center);
        scratchPoint.add(xAxis);
        scratchPoint.add(yAxis);
        scratchPoint.add(zAxis);
        addToCartographicBounds(result, scratchPoint);
        zAxis.negate();
      }
      yAxis.negate();
    }
    xAxis.negate();
  }
  return result;
}
function boundingSphereToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const { center, radius } = boundingVolume;
  const point2 = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);
  let zAxis;
  if (point2) {
    zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point2);
  } else {
    zAxis = new Vector3(0, 0, 1);
  }
  let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);
  if (xAxis.len() > 0) {
    xAxis.normalize();
  } else {
    xAxis = new Vector3(0, 1, 0);
  }
  const yAxis = xAxis.clone().cross(zAxis);
  for (const axis of [xAxis, yAxis, zAxis]) {
    scratchScale.copy(axis).scale(radius);
    for (let dir = 0; dir < 2; dir++) {
      scratchPoint.copy(center);
      scratchPoint.add(scratchScale);
      addToCartographicBounds(result, scratchPoint);
      scratchScale.negate();
    }
  }
  return result;
}
function emptyCartographicBounds() {
  return [
    [Infinity, Infinity, Infinity],
    [-Infinity, -Infinity, -Infinity]
  ];
}
function addToCartographicBounds(target, cartesian) {
  Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
  target[0][0] = Math.min(target[0][0], scratchPoint[0]);
  target[0][1] = Math.min(target[0][1], scratchPoint[1]);
  target[0][2] = Math.min(target[0][2], scratchPoint[2]);
  target[1][0] = Math.max(target[1][0], scratchPoint[0]);
  target[1][1] = Math.max(target[1][1], scratchPoint[1]);
  target[1][2] = Math.max(target[1][2], scratchPoint[2]);
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/tiles-3d-lod.js
var scratchPositionNormal = new Vector3();
var scratchCartographic = new Vector3();
var scratchMatrix2 = new Matrix4();
var scratchCenter2 = new Vector3();
var scratchPosition4 = new Vector3();
var scratchDirection = new Vector3();
function fog(distanceToCamera, density) {
  const scalar = distanceToCamera * density;
  return 1 - Math.exp(-(scalar * scalar));
}
function getDynamicScreenSpaceError(tileset, distanceToCamera) {
  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
    const density = tileset.dynamicScreenSpaceErrorComputedDensity;
    const factor = tileset.dynamicScreenSpaceErrorFactor;
    const dynamicError = fog(distanceToCamera, density) * factor;
    return dynamicError;
  }
  return 0;
}
function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
  const tileset = tile.tileset;
  const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
  if (lodMetricValue === 0) {
    return 0;
  }
  const distance = Math.max(tile._distanceToCamera, 1e-7);
  const { height, sseDenominator } = frameState;
  const { viewDistanceScale } = tileset.options;
  let error = lodMetricValue * height * (viewDistanceScale || 1) / (distance * sseDenominator);
  error -= getDynamicScreenSpaceError(tileset, distance);
  return error;
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/i3s-lod.js
var cameraPositionCartesian = new Vector3();
var toEye = new Vector3();
var cameraPositionEnu = new Vector3();
var extraVertexEnu = new Vector3();
var projectedOriginVector = new Vector3();
var enuToCartesianMatrix = new Matrix4();
var cartesianToEnuMatrix = new Matrix4();
function getLodStatus(tile, frameState) {
  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
    return "DIG";
  }
  const screenSize = 2 * getProjectedRadius(tile, frameState);
  if (screenSize < 2) {
    return "OUT";
  }
  if (!tile.header.children || screenSize <= tile.lodMetricValue) {
    return "DRAW";
  } else if (tile.header.children) {
    return "DIG";
  }
  return "OUT";
}
function getProjectedRadius(tile, frameState) {
  const { topDownViewport: viewport } = frameState;
  const mbsLat = tile.header.mbs[1];
  const mbsLon = tile.header.mbs[0];
  const mbsZ = tile.header.mbs[2];
  const mbsR = tile.header.mbs[3];
  const mbsCenterCartesian = [...tile.boundingVolume.center];
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
  const extraZ = projection * projection / cameraPositionEnu[2];
  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
  const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
  return projectedRadius;
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/3d-tiles-options.js
function get3dTilesOptions(tileset) {
  return {
    assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
  };
}

// node_modules/@loaders.gl/tiles/dist/utils/managed-array.js
var ManagedArray = class {
  constructor(length2 = 0) {
    __publicField(this, "_map", /* @__PURE__ */ new Map());
    __publicField(this, "_array");
    __publicField(this, "_length");
    this._array = new Array(length2);
    this._length = length2;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(length2) {
    this._length = length2;
    if (length2 > this._array.length) {
      this._array.length = length2;
    }
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(index) {
    assert2(index < this._array.length);
    return this._array[index];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(index, element) {
    assert2(index >= 0);
    if (index >= this.length) {
      this.length = index + 1;
    }
    if (this._map.has(this._array[index])) {
      this._map.delete(this._array[index]);
    }
    this._array[index] = element;
    this._map.set(element, index);
  }
  delete(element) {
    const index = this._map.get(element);
    if (index >= 0) {
      this._array.splice(index, 1);
      this._map.delete(element);
      this.length--;
    }
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(element) {
    if (!this._map.has(element)) {
      const index = this.length++;
      this._array[index] = element;
      this._map.set(element, index);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const element = this._array[--this.length];
    this._map.delete(element);
    return element;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(length2) {
    assert2(length2 >= 0);
    if (length2 > this._array.length) {
      this._array.length = length2;
    }
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(length2) {
    assert2(length2 >= 0);
    this.length = length2;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(length2) {
    if (length2 === null || length2 === void 0) {
      length2 = this.length;
    }
    this._array.length = length2;
  }
  reset() {
    this._array = [];
    this._map = /* @__PURE__ */ new Map();
    this._length = 0;
  }
  find(target) {
    return this._map.has(target);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-traverser.js
var DEFAULT_PROPS = {
  loadSiblings: false,
  skipLevelOfDetail: false,
  updateTransforms: true,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
var TilesetTraverser = class {
  // TODO nested props
  constructor(options) {
    __publicField(this, "options");
    // fulfill in traverse call
    __publicField(this, "root", null);
    // tiles should be rendered
    __publicField(this, "selectedTiles", {});
    // tiles should be loaded from server
    __publicField(this, "requestedTiles", {});
    // tiles does not have render content
    __publicField(this, "emptyTiles", {});
    __publicField(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
    __publicField(this, "updateDebounceTime", 1e3);
    /** temporary storage to hold the traversed tiles during a traversal */
    __publicField(this, "_traversalStack", new ManagedArray());
    __publicField(this, "_emptyTraversalStack", new ManagedArray());
    /** set in every traverse cycle */
    __publicField(this, "_frameNumber", null);
    this.options = { ...DEFAULT_PROPS, ...options };
  }
  // RESULT
  traversalFinished(frameState) {
    return true;
  }
  // tiles should be visible
  traverse(root, frameState, options) {
    this.root = root;
    this.options = { ...this.options, ...options };
    this.reset();
    this.updateTile(root, frameState);
    this._frameNumber = frameState.frameNumber;
    this.executeTraversal(root, frameState);
  }
  reset() {
    this.requestedTiles = {};
    this.selectedTiles = {};
    this.emptyTiles = {};
    this._traversalStack.reset();
    this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(root, frameState) {
    const stack2 = this._traversalStack;
    root._selectionDepth = 1;
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop();
      let shouldRefine = false;
      if (this.canTraverse(tile, frameState)) {
        this.updateChildTiles(tile, frameState);
        shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
      }
      const parent = tile.parent;
      const parentRefines = Boolean(!parent || parent._shouldRefine);
      const stoppedRefining = !shouldRefine;
      if (!tile.hasRenderContent) {
        this.emptyTiles[tile.id] = tile;
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectTile(tile, frameState);
        }
      } else if (tile.refine === TILE_REFINEMENT.ADD) {
        this.loadTile(tile, frameState);
        this.selectTile(tile, frameState);
      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectTile(tile, frameState);
        }
      }
      this.touchTile(tile, frameState);
      tile._shouldRefine = shouldRefine && parentRefines;
    }
    const newTime = (/* @__PURE__ */ new Date()).getTime();
    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
      this.lastUpdate = newTime;
      this.options.onTraversalEnd(frameState);
    }
  }
  updateChildTiles(tile, frameState) {
    const children = tile.children;
    for (const child of children) {
      this.updateTile(child, frameState);
    }
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(tile, frameState, stack2, depth) {
    const { loadSiblings, skipLevelOfDetail } = this.options;
    const children = tile.children;
    children.sort(this.compareDistanceToCamera.bind(this));
    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
    let hasVisibleChild = false;
    let refines = true;
    for (const child of children) {
      child._selectionDepth = depth;
      if (child.isVisibleAndInRequestVolume) {
        if (stack2.find(child)) {
          stack2.delete(child);
        }
        stack2.push(child);
        hasVisibleChild = true;
      } else if (checkRefines || loadSiblings) {
        this.loadTile(child, frameState);
        this.touchTile(child, frameState);
      }
      if (checkRefines) {
        let childRefines;
        if (!child._inRequestVolume) {
          childRefines = false;
        } else if (!child.hasRenderContent) {
          childRefines = this.executeEmptyTraversal(child, frameState);
        } else {
          childRefines = child.contentAvailable;
        }
        refines = refines && childRefines;
        if (!refines) {
          return false;
        }
      }
    }
    if (!hasVisibleChild) {
      refines = false;
    }
    return refines;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(tile, frameState) {
    this.updateTileVisibility(tile, frameState);
  }
  // tile to render in the browser
  selectTile(tile, frameState) {
    if (this.shouldSelectTile(tile)) {
      tile._selectedFrame = frameState.frameNumber;
      this.selectedTiles[tile.id] = tile;
    }
  }
  // tile to load from server
  loadTile(tile, frameState) {
    if (this.shouldLoadTile(tile)) {
      tile._requestedFrame = frameState.frameNumber;
      tile._priority = tile._getPriority();
      this.requestedTiles[tile.id] = tile;
    }
  }
  // cache tile
  touchTile(tile, frameState) {
    tile.tileset._cache.touch(tile);
    tile._touchedFrame = frameState.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {
    if (!tile.hasChildren) {
      return false;
    }
    if (tile.hasTilesetContent) {
      return !tile.contentExpired;
    }
    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
      return false;
    }
    return this.shouldRefine(tile, frameState, useParentMetric);
  }
  shouldLoadTile(tile) {
    return tile.hasUnloadedContent || tile.contentExpired;
  }
  shouldSelectTile(tile) {
    return tile.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(tile, frameState, useParentMetric = false) {
    let screenSpaceError = tile._screenSpaceError;
    if (useParentMetric) {
      screenSpaceError = tile.getScreenSpaceError(frameState, true);
    }
    return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(tile, frameState) {
    const viewportIds = [];
    if (this.options.viewportTraversersMap) {
      for (const key in this.options.viewportTraversersMap) {
        const value = this.options.viewportTraversersMap[key];
        if (value === frameState.viewport.id) {
          viewportIds.push(key);
        }
      }
    } else {
      viewportIds.push(frameState.viewport.id);
    }
    tile.updateVisibility(frameState, viewportIds);
  }
  // UTILITIES
  compareDistanceToCamera(b2, a3) {
    return b2._distanceToCamera - a3._distanceToCamera;
  }
  anyChildrenVisible(tile, frameState) {
    let anyVisible = false;
    for (const child of tile.children) {
      child.updateVisibility(frameState);
      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
    }
    return anyVisible;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(root, frameState) {
    let allDescendantsLoaded = true;
    const stack2 = this._emptyTraversalStack;
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop();
      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, false);
      const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;
      if (!traverse && !tile.contentAvailable && !emptyLeaf) {
        allDescendantsLoaded = false;
      }
      this.updateTile(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        this.loadTile(tile, frameState);
        this.touchTile(tile, frameState);
      }
      if (traverse) {
        const children = tile.children;
        for (const child of children) {
          stack2.push(child);
        }
      }
    }
    return allDescendantsLoaded;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tile-3d.js
var scratchVector13 = new Vector3();
function defined2(x2) {
  return x2 !== void 0 && x2 !== null;
}
var Tile3D = class {
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(tileset, header, parentHeader, extendedId = "") {
    __publicField(this, "tileset");
    __publicField(this, "header");
    __publicField(this, "id");
    __publicField(this, "url");
    __publicField(this, "parent");
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    __publicField(this, "refine");
    __publicField(this, "type");
    __publicField(this, "contentUrl");
    /** Different refinement algorithms used by I3S and 3D tiles */
    __publicField(this, "lodMetricType", "geometricError");
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    __publicField(this, "lodMetricValue", 0);
    /** @todo math.gl is not exporting BoundingVolume base type? */
    __publicField(this, "boundingVolume", null);
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    __publicField(this, "content", null);
    __publicField(this, "contentState", TILE_CONTENT_STATE.UNLOADED);
    __publicField(this, "gpuMemoryUsageInBytes", 0);
    /** The tile's children - an array of Tile3D objects. */
    __publicField(this, "children", []);
    __publicField(this, "depth", 0);
    __publicField(this, "viewportIds", []);
    __publicField(this, "transform", new Matrix4());
    __publicField(this, "extensions", null);
    /** TODO Cesium 3d tiles specific */
    __publicField(this, "implicitTiling", null);
    /** Container to store application specific data */
    __publicField(this, "userData", {});
    __publicField(this, "computedTransform");
    __publicField(this, "hasEmptyContent", false);
    __publicField(this, "hasTilesetContent", false);
    __publicField(this, "traverser", new TilesetTraverser({}));
    /** Used by TilesetCache */
    __publicField(this, "_cacheNode", null);
    __publicField(this, "_frameNumber", null);
    // TODO Cesium 3d tiles specific
    __publicField(this, "_expireDate", null);
    __publicField(this, "_expiredContent", null);
    __publicField(this, "_boundingBox");
    /** updated every frame for tree traversal and rendering optimizations: */
    __publicField(this, "_distanceToCamera", 0);
    __publicField(this, "_screenSpaceError", 0);
    __publicField(this, "_visibilityPlaneMask");
    __publicField(this, "_visible");
    __publicField(this, "_contentBoundingVolume");
    __publicField(this, "_viewerRequestVolume");
    __publicField(this, "_initialTransform", new Matrix4());
    // Used by traverser, cannot be marked private
    __publicField(this, "_priority", 0);
    __publicField(this, "_selectedFrame", 0);
    __publicField(this, "_requestedFrame", 0);
    __publicField(this, "_selectionDepth", 0);
    __publicField(this, "_touchedFrame", 0);
    __publicField(this, "_centerZDepth", 0);
    __publicField(this, "_shouldRefine", false);
    __publicField(this, "_stackLength", 0);
    __publicField(this, "_visitedFrame", 0);
    __publicField(this, "_inRequestVolume", false);
    __publicField(this, "_lodJudge", null);
    this.header = header;
    this.tileset = tileset;
    this.id = extendedId || header.id;
    this.url = header.url;
    this.parent = parentHeader;
    this.refine = this._getRefine(header.refine);
    this.type = header.type;
    this.contentUrl = header.contentUrl;
    this._initializeLodMetric(header);
    this._initializeTransforms(header);
    this._initializeBoundingVolumes(header);
    this._initializeContent(header);
    this._initializeRenderingState(header);
    Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === TILE_CONTENT_STATE.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === TILE_CONTENT_STATE.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === TILE_CONTENT_STATE.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    if (!this._boundingBox) {
      this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
    }
    return this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(frameState, useParentLodMetric) {
    switch (this.tileset.type) {
      case TILESET_TYPE.I3S:
        return getProjectedRadius(this, frameState);
      case TILESET_TYPE.TILES3D:
        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const traverser = this.tileset._traverser;
    const { skipLevelOfDetail } = traverser.options;
    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
    if (maySkipTile && !this.isVisible && this._visible !== void 0) {
      return -1;
    }
    if (this.tileset._frameNumber - this._touchedFrame >= 1) {
      return -1;
    }
    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
      return -1;
    }
    const parent = this.parent;
    const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
    const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
    return Math.max(rootScreenSpaceError - screenSpaceError, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent) {
      return false;
    }
    if (this.content) {
      return true;
    }
    const expired = this.contentExpired;
    if (expired) {
      this._expireDate = null;
    }
    this.contentState = TILE_CONTENT_STATE.LOADING;
    const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!requestToken) {
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return false;
    }
    try {
      const contentUrl = this.tileset.getTileUrl(this.contentUrl);
      const loader = this.tileset.loader;
      const options = {
        ...this.tileset.loadOptions,
        [loader.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[loader.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(loader.id)
        }
      };
      this.content = await load(contentUrl, loader, options);
      if (this.tileset.options.contentLoader) {
        await this.tileset.options.contentLoader(this);
      }
      if (this._isTileset()) {
        this.tileset._initializeTileHeaders(this.content, this);
      }
      this.contentState = TILE_CONTENT_STATE.READY;
      this._onContentLoaded();
      return true;
    } catch (error) {
      this.contentState = TILE_CONTENT_STATE.FAILED;
      throw error;
    } finally {
      requestToken.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    if (this.content && this.content.destroy) {
      this.content.destroy();
    }
    this.content = null;
    if (this.header.content && this.header.content.destroy) {
      this.header.content.destroy();
    }
    this.header.content = null;
    this.contentState = TILE_CONTENT_STATE.UNLOADED;
    return true;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(frameState, viewportIds) {
    if (this._frameNumber === frameState.frameNumber) {
      return;
    }
    const parent = this.parent;
    const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(parentTransform);
    }
    this._distanceToCamera = this.distanceToTile(frameState);
    this._screenSpaceError = this.getScreenSpaceError(frameState, false);
    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
    this._inRequestVolume = this.insideViewerRequestVolume(frameState);
    this._frameNumber = frameState.frameNumber;
    this.viewportIds = viewportIds;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(frameState, parentVisibilityPlaneMask) {
    const { cullingVolume: cullingVolume2 } = frameState;
    const { boundingVolume } = this;
    return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return true;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(frameState) {
    const boundingVolume = this.boundingVolume;
    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera }) {
    const boundingVolume = this.boundingVolume;
    scratchVector13.subVectors(boundingVolume.center, camera.position);
    return camera.direction.dot(scratchVector13);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(frameState) {
    const viewerRequestVolume = this._viewerRequestVolume;
    return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (defined2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const now = Date.now();
      if (Date.lessThan(this._expireDate, now)) {
        this.contentState = TILE_CONTENT_STATE.EXPIRED;
        this._expiredContent = this.content;
      }
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(header) {
    if ("lodMetricType" in header) {
      this.lodMetricType = header.lodMetricType;
    } else {
      this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);
    }
    if ("lodMetricValue" in header) {
      this.lodMetricValue = header.lodMetricValue;
    } else {
      this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
      console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
    }
  }
  _initializeTransforms(tileHeader) {
    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
    const parent = this.parent;
    const tileset = this.tileset;
    const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
    const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(tileHeader) {
    this._contentBoundingVolume = null;
    this._viewerRequestVolume = null;
    this._updateBoundingVolume(tileHeader);
  }
  _initializeContent(tileHeader) {
    this.content = { _tileset: this.tileset, _tile: this };
    this.hasEmptyContent = true;
    this.contentState = TILE_CONTENT_STATE.UNLOADED;
    this.hasTilesetContent = false;
    if (tileHeader.contentUrl) {
      this.content = null;
      this.hasEmptyContent = false;
    }
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(header) {
    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
    this._shouldRefine = false;
    this._distanceToCamera = 0;
    this._centerZDepth = 0;
    this._screenSpaceError = 0;
    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
    this._visible = void 0;
    this._inRequestVolume = false;
    this._stackLength = 0;
    this._selectionDepth = 0;
    this._frameNumber = 0;
    this._touchedFrame = 0;
    this._visitedFrame = 0;
    this._selectedFrame = 0;
    this._requestedFrame = 0;
    this._priority = 0;
  }
  _getRefine(refine) {
    return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = true;
        break;
      default:
    }
    if (this._isTileset()) {
      this.hasTilesetContent = true;
    } else {
      this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
    }
  }
  _updateBoundingVolume(header) {
    this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
    const content = header.content;
    if (!content) {
      return;
    }
    if (content.boundingVolume) {
      this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
    }
    if (header.viewerRequestVolume) {
      this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
    }
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(parentTransform = new Matrix4()) {
    const computedTransform = parentTransform.clone().multiplyRight(this.transform);
    const didTransformChange = !computedTransform.equals(this.computedTransform);
    if (!didTransformChange) {
      return;
    }
    this.computedTransform = computedTransform;
    this._updateBoundingVolume(this.header);
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(loaderId) {
    switch (loaderId) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: false
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return get3dTilesOptions(this.tileset.tileset);
    }
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-3d-tiles/tileset-3d-traverser.js
var Tileset3DTraverser = class extends TilesetTraverser {
  compareDistanceToCamera(a3, b2) {
    return b2._distanceToCamera === 0 && a3._distanceToCamera === 0 ? b2._centerZDepth - a3._centerZDepth : b2._distanceToCamera - a3._distanceToCamera;
  }
  updateTileVisibility(tile, frameState) {
    super.updateTileVisibility(tile, frameState);
    if (!tile.isVisibleAndInRequestVolume) {
      return;
    }
    const hasChildren = tile.children.length > 0;
    if (tile.hasTilesetContent && hasChildren) {
      const firstChild = tile.children[0];
      this.updateTileVisibility(firstChild, frameState);
      tile._visible = firstChild._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
      tile._visible = false;
      return;
    }
    const replace = tile.refine === TILE_REFINEMENT.REPLACE;
    const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
    if (replace && useOptimization && hasChildren) {
      if (!this.anyChildrenVisible(tile, frameState)) {
        tile._visible = false;
        return;
      }
    }
  }
  meetsScreenSpaceErrorEarly(tile, frameState) {
    const { parent } = tile;
    if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
      return false;
    }
    return !this.shouldRefine(tile, frameState, true);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-pending-tiles-register.js
var I3SPendingTilesRegister = class {
  constructor() {
    __publicField(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(viewportId, frameNumber) {
    const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
    const oldCount = viewportMap.get(frameNumber) || 0;
    viewportMap.set(frameNumber, oldCount + 1);
    this.frameNumberMap.set(viewportId, viewportMap);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(viewportId, frameNumber) {
    const viewportMap = this.frameNumberMap.get(viewportId);
    if (!viewportMap) {
      return;
    }
    const oldCount = viewportMap.get(frameNumber) || 1;
    viewportMap.set(frameNumber, oldCount - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(viewportId, frameNumber) {
    var _a;
    const count = ((_a = this.frameNumberMap.get(viewportId)) == null ? void 0 : _a.get(frameNumber)) || 0;
    return count === 0;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tile-manager.js
var STATUS = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
var I3STileManager = class {
  constructor() {
    __publicField(this, "_statusMap");
    __publicField(this, "pendingTilesRegister", new I3SPendingTilesRegister());
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(request, key, callback, frameState) {
    if (!this._statusMap[key]) {
      const { frameNumber, viewport: { id } } = frameState;
      this._statusMap[key] = { request, callback, key, frameState, status: STATUS.REQUESTED };
      this.pendingTilesRegister.register(id, frameNumber);
      request().then((data) => {
        this._statusMap[key].status = STATUS.COMPLETED;
        const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id2, actualFrameNumber);
        this._statusMap[key].callback(data, frameState);
      }).catch((error) => {
        this._statusMap[key].status = STATUS.ERROR;
        const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id2, actualFrameNumber);
        callback(error);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(key, frameState) {
    if (this._statusMap[key]) {
      const { frameNumber, viewport: { id } } = this._statusMap[key].frameState;
      this.pendingTilesRegister.deregister(id, frameNumber);
      const { frameNumber: newFrameNumber, viewport: { id: newViewportId } } = frameState;
      this.pendingTilesRegister.register(newViewportId, newFrameNumber);
      this._statusMap[key].frameState = frameState;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(key) {
    return this._statusMap[key];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(viewportId, frameNumber) {
    return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tileset-traverser.js
var I3STilesetTraverser = class extends TilesetTraverser {
  constructor(options) {
    super(options);
    __publicField(this, "_tileManager");
    this._tileManager = new I3STileManager();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(frameState) {
    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(tile, frameState) {
    tile._lodJudge = getLodStatus(tile, frameState);
    return tile._lodJudge === "DIG";
  }
  updateChildTiles(tile, frameState) {
    const children = tile.header.children || [];
    const childTiles = tile.children;
    const tileset = tile.tileset;
    for (const child of children) {
      const extendedId = `${child.id}-${frameState.viewport.id}`;
      const childTile = childTiles && childTiles.find((t2) => t2.id === extendedId);
      if (!childTile) {
        let request = () => this._loadTile(child.id, tileset);
        const cachedRequest = this._tileManager.find(extendedId);
        if (!cachedRequest) {
          if (tileset.tileset.nodePages) {
            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
          }
          this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
        } else {
          this._tileManager.update(extendedId, frameState);
        }
      } else if (childTile) {
        this.updateTile(childTile, frameState);
      }
    }
    return false;
  }
  async _loadTile(nodeId, tileset) {
    const { loader } = tileset;
    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);
    const options = {
      ...tileset.loadOptions,
      i3s: {
        ...tileset.loadOptions.i3s,
        isTileHeader: true
      }
    };
    return await load(nodeUrl, loader, options);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(header, tile, extendedId) {
    const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
    tile.children.push(childTile);
    const frameState = this._tileManager.find(childTile.id).frameState;
    this.updateTile(childTile, frameState);
    if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime)) {
      this.executeTraversal(childTile, frameState);
    }
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-3d.js
var DEFAULT_PROPS2 = {
  description: "",
  ellipsoid: Ellipsoid.WGS84,
  modelMatrix: new Matrix4(),
  throttleRequests: true,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (selectedTiles) => selectedTiles,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: false,
  loadTiles: true,
  updateTransforms: true,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
};
var TILES_TOTAL = "Tiles In Tileset(s)";
var TILES_IN_MEMORY = "Tiles In Memory";
var TILES_IN_VIEW = "Tiles In View";
var TILES_RENDERABLE = "Tiles To Render";
var TILES_LOADED = "Tiles Loaded";
var TILES_LOADING = "Tiles Loading";
var TILES_UNLOADED = "Tiles Unloaded";
var TILES_LOAD_FAILED = "Failed Tile Loads";
var POINTS_COUNT = "Points/Vertices";
var TILES_GPU_MEMORY = "Tile Memory Use";
var MAXIMUM_SSE = "Maximum Screen Space Error";
var Tileset3D = class {
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(tileset, options) {
    // props: Tileset3DProps;
    __publicField(this, "options");
    __publicField(this, "loadOptions");
    __publicField(this, "type");
    __publicField(this, "tileset");
    __publicField(this, "loader");
    __publicField(this, "url");
    __publicField(this, "basePath");
    __publicField(this, "modelMatrix");
    __publicField(this, "ellipsoid");
    __publicField(this, "lodMetricType");
    __publicField(this, "lodMetricValue");
    __publicField(this, "refine");
    __publicField(this, "root", null);
    __publicField(this, "roots", {});
    /** @todo any->unknown */
    __publicField(this, "asset", {});
    // Metadata for the entire tileset
    __publicField(this, "description", "");
    __publicField(this, "properties");
    __publicField(this, "extras", null);
    __publicField(this, "attributions", {});
    __publicField(this, "credits", {});
    __publicField(this, "stats");
    /** flags that contain information about data types in nested tiles */
    __publicField(this, "contentFormats", { draco: false, meshopt: false, dds: false, ktx2: false });
    // view props
    __publicField(this, "cartographicCenter", null);
    __publicField(this, "cartesianCenter", null);
    __publicField(this, "zoom", 1);
    __publicField(this, "boundingVolume", null);
    /** Updated based on the camera position and direction */
    __publicField(this, "dynamicScreenSpaceErrorComputedDensity", 0);
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    __publicField(this, "maximumMemoryUsage", 32);
    /** The total amount of GPU memory in bytes used by the tileset. */
    __publicField(this, "gpuMemoryUsageInBytes", 0);
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    __publicField(this, "memoryAdjustedScreenSpaceError", 0);
    __publicField(this, "_cacheBytes", 0);
    __publicField(this, "_cacheOverflowBytes", 0);
    /** Update tracker. increase in each update cycle. */
    __publicField(this, "_frameNumber", 0);
    __publicField(this, "_queryParams", {});
    __publicField(this, "_extensionsUsed", []);
    __publicField(this, "_tiles", {});
    /** counter for tracking tiles requests */
    __publicField(this, "_pendingCount", 0);
    /** Hold traversal results */
    __publicField(this, "selectedTiles", []);
    // TRAVERSAL
    __publicField(this, "traverseCounter", 0);
    __publicField(this, "geometricError", 0);
    __publicField(this, "lastUpdatedVieports", null);
    __publicField(this, "_requestedTiles", []);
    __publicField(this, "_emptyTiles", []);
    __publicField(this, "frameStateData", {});
    __publicField(this, "_traverser");
    __publicField(this, "_cache", new TilesetCache());
    __publicField(this, "_requestScheduler");
    // Promise tracking
    __publicField(this, "updatePromise", null);
    __publicField(this, "tilesetInitializationPromise");
    this.options = { ...DEFAULT_PROPS2, ...options };
    this.tileset = tileset;
    this.loader = tileset.loader;
    this.type = tileset.type;
    this.url = tileset.url;
    this.basePath = tileset.basePath || path_exports.dirname(this.url);
    this.modelMatrix = this.options.modelMatrix;
    this.ellipsoid = this.options.ellipsoid;
    this.lodMetricType = tileset.lodMetricType;
    this.lodMetricValue = tileset.lodMetricValue;
    this.refine = tileset.root.refine;
    this.loadOptions = this.options.loadOptions || {};
    this._traverser = this._initializeTraverser();
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    });
    this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;
    this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;
    this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;
    this.stats = new Stats({ id: this.url });
    this._initializeStats();
    this.tilesetInitializationPromise = this._initializeTileSet(tileset);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(props) {
    this.options = { ...this.options, ...props };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(tilePath) {
    const isDataUrl = tilePath.startsWith("data:");
    if (isDataUrl) {
      return tilePath;
    }
    let tileUrl = tilePath;
    if (this.queryParams.length) {
      tileUrl = `${tilePath}${tilePath.includes("?") ? "&" : "?"}${this.queryParams}`;
    }
    return tileUrl;
  }
  // TODO CESIUM specific
  hasExtension(extensionName) {
    return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(viewports = null) {
    this.tilesetInitializationPromise.then(() => {
      if (!viewports && this.lastUpdatedVieports) {
        viewports = this.lastUpdatedVieports;
      } else {
        this.lastUpdatedVieports = viewports;
      }
      if (viewports) {
        this.doUpdate(viewports);
      }
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(viewports = null) {
    await this.tilesetInitializationPromise;
    if (viewports) {
      this.lastUpdatedVieports = viewports;
    }
    if (!this.updatePromise) {
      this.updatePromise = new Promise((resolve) => {
        setTimeout(() => {
          if (this.lastUpdatedVieports) {
            this.doUpdate(this.lastUpdatedVieports);
          }
          resolve(this._frameNumber);
          this.updatePromise = null;
        }, this.options.debounceTime);
      });
    }
    return this.updatePromise;
  }
  adjustScreenSpaceError() {
    if (this.gpuMemoryUsageInBytes < this._cacheBytes) {
      this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);
    } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {
      this.memoryAdjustedScreenSpaceError *= 1.02;
    }
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(viewports) {
    if ("loadTiles" in this.options && !this.options.loadTiles) {
      return;
    }
    if (this.traverseCounter > 0) {
      return;
    }
    const preparedViewports = viewports instanceof Array ? viewports : [viewports];
    this._cache.reset();
    this._frameNumber++;
    this.traverseCounter = preparedViewports.length;
    const viewportsToTraverse = [];
    for (const viewport of preparedViewports) {
      const id = viewport.id;
      if (this._needTraverse(id)) {
        viewportsToTraverse.push(id);
      } else {
        this.traverseCounter--;
      }
    }
    for (const viewport of preparedViewports) {
      const id = viewport.id;
      if (!this.roots[id]) {
        this.roots[id] = this._initializeTileHeaders(this.tileset, null);
      }
      if (!viewportsToTraverse.includes(id)) {
        continue;
      }
      const frameState = getFrameState(viewport, this._frameNumber);
      this._traverser.traverse(this.roots[id], frameState, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(viewportId) {
    let traverserId = viewportId;
    if (this.options.viewportTraversersMap) {
      traverserId = this.options.viewportTraversersMap[viewportId];
    }
    if (traverserId !== viewportId) {
      return false;
    }
    return true;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(frameState) {
    const id = frameState.viewport.id;
    if (!this.frameStateData[id]) {
      this.frameStateData[id] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] };
    }
    const currentFrameStateData = this.frameStateData[id];
    const selectedTiles = Object.values(this._traverser.selectedTiles);
    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
    currentFrameStateData.selectedTiles = filteredSelectedTiles;
    for (const tile of unselectedTiles) {
      tile.unselect();
    }
    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
    this.traverseCounter--;
    if (this.traverseCounter > 0) {
      return;
    }
    this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [];
    this._requestedTiles = [];
    this._emptyTiles = [];
    for (const frameStateKey in this.frameStateData) {
      const frameStateDataValue = this.frameStateData[frameStateKey];
      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const tile of this.selectedTiles) {
      this._tiles[tile.id] = tile;
    }
    this._loadTiles();
    this._unloadTiles();
    this._updateStats();
  }
  _tilesChanged(oldSelectedTiles, selectedTiles) {
    if (oldSelectedTiles.length !== selectedTiles.length) {
      return true;
    }
    const set1 = new Set(oldSelectedTiles.map((t2) => t2.id));
    const set2 = new Set(selectedTiles.map((t2) => t2.id));
    let changed = oldSelectedTiles.filter((x2) => !set2.has(x2.id)).length > 0;
    changed = changed || selectedTiles.filter((x2) => !set1.has(x2.id)).length > 0;
    return changed;
  }
  _loadTiles() {
    for (const tile of this._requestedTiles) {
      if (tile.contentUnloaded) {
        this._loadTile(tile);
      }
    }
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
  }
  _updateStats() {
    let tilesRenderable = 0;
    let pointsRenderable = 0;
    for (const tile of this.selectedTiles) {
      if (tile.contentAvailable && tile.content) {
        tilesRenderable++;
        if (tile.content.pointCount) {
          pointsRenderable += tile.content.pointCount;
        } else {
          pointsRenderable += tile.content.vertexCount;
        }
      }
    }
    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
    this.stats.get(POINTS_COUNT).count = pointsRenderable;
    this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(tilesetJson) {
    if (this.type === TILESET_TYPE.I3S) {
      this.calculateViewPropsI3S();
      tilesetJson.root = await tilesetJson.root;
    }
    this.root = this._initializeTileHeaders(tilesetJson, null);
    if (this.type === TILESET_TYPE.TILES3D) {
      this._initializeTiles3DTileset(tilesetJson);
      this.calculateViewPropsTiles3D();
    }
    if (this.type === TILESET_TYPE.I3S) {
      this._initializeI3STileset();
    }
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    var _a;
    const fullExtent = this.tileset.fullExtent;
    if (fullExtent) {
      const { xmin, xmax, ymin, ymax, zmin, zmax } = fullExtent;
      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
      this.cartesianCenter = new Vector3();
      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const extent = (_a = this.tileset.store) == null ? void 0 : _a.extent;
    if (extent) {
      const [xmin, ymin, xmax, ymax] = extent;
      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
      this.cartesianCenter = new Vector3();
      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header");
    this.cartographicCenter = new Vector3();
    this.zoom = 1;
    return;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const root = this.root;
    const { center } = root.boundingVolume;
    if (!center) {
      console.warn("center was not pre-calculated for the root tile");
      this.cartographicCenter = new Vector3();
      this.zoom = 1;
      return;
    }
    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
      this.cartographicCenter = new Vector3();
      Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);
    } else {
      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
    }
    this.cartesianCenter = center;
    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(TILES_TOTAL);
    this.stats.get(TILES_LOADING);
    this.stats.get(TILES_IN_MEMORY);
    this.stats.get(TILES_IN_VIEW);
    this.stats.get(TILES_RENDERABLE);
    this.stats.get(TILES_LOADED);
    this.stats.get(TILES_UNLOADED);
    this.stats.get(TILES_LOAD_FAILED);
    this.stats.get(POINTS_COUNT);
    this.stats.get(TILES_GPU_MEMORY, "memory");
    this.stats.get(MAXIMUM_SSE);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(tilesetJson, parentTileHeader) {
    var _a;
    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
    if (parentTileHeader) {
      parentTileHeader.children.push(rootTile);
      rootTile.depth = parentTileHeader.depth + 1;
    }
    if (this.type === TILESET_TYPE.TILES3D) {
      const stack2 = [];
      stack2.push(rootTile);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        this.stats.get(TILES_TOTAL).incrementCount();
        const children = tile.header.children || [];
        for (const childHeader of children) {
          const childTile = new Tile3D(this, childHeader, tile);
          if ((_a = childTile.contentUrl) == null ? void 0 : _a.includes("?session=")) {
            const url = new URL(childTile.contentUrl);
            const session = url.searchParams.get("session");
            if (session) {
              this._queryParams.session = session;
            }
          }
          tile.children.push(childTile);
          childTile.depth = tile.depth + 1;
          stack2.push(childTile);
        }
      }
    }
    return rootTile;
  }
  _initializeTraverser() {
    let TraverserClass;
    const type = this.type;
    switch (type) {
      case TILESET_TYPE.TILES3D:
        TraverserClass = Tileset3DTraverser;
        break;
      case TILESET_TYPE.I3S:
        TraverserClass = I3STilesetTraverser;
        break;
      default:
        TraverserClass = TilesetTraverser;
    }
    return new TraverserClass({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(parentTile) {
    this._destroySubtree(parentTile);
  }
  async _loadTile(tile) {
    let loaded;
    try {
      this._onStartTileLoading();
      loaded = await tile.loadContent();
    } catch (error) {
      this._onTileLoadError(tile, error instanceof Error ? error : new Error("load failed"));
    } finally {
      this._onEndTileLoading();
      this._onTileLoad(tile, loaded);
    }
  }
  _onTileLoadError(tile, error) {
    this.stats.get(TILES_LOAD_FAILED).incrementCount();
    const message = error.message || error.toString();
    const url = tile.url;
    console.error(`A 3D tile failed to load: ${tile.url} ${message}`);
    this.options.onTileError(tile, message, url);
  }
  _onTileLoad(tile, loaded) {
    var _a, _b;
    if (!loaded) {
      return;
    }
    if (this.type === TILESET_TYPE.I3S) {
      const nodesInNodePages = ((_b = (_a = this.tileset) == null ? void 0 : _a.nodePagesTile) == null ? void 0 : _b.nodesInNodePages) || 0;
      this.stats.get(TILES_TOTAL).reset();
      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
    }
    if (tile && tile.content) {
      calculateTransformProps(tile, tile.content);
    }
    this.updateContentTypes(tile);
    this._addTileToCache(tile);
    this.options.onTileLoad(tile);
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(tile) {
    var _a;
    if (this.type === TILESET_TYPE.I3S) {
      if (tile.header.isDracoGeometry) {
        this.contentFormats.draco = true;
      }
      switch (tile.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = true;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = true;
          break;
        default:
      }
    } else if (this.type === TILESET_TYPE.TILES3D) {
      const { extensionsRemoved = [] } = ((_a = tile.content) == null ? void 0 : _a.gltf) || {};
      if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
        this.contentFormats.draco = true;
      }
      if (extensionsRemoved.includes("EXT_meshopt_compression")) {
        this.contentFormats.meshopt = true;
      }
      if (extensionsRemoved.includes("KHR_texture_basisu")) {
        this.contentFormats.ktx2 = true;
      }
    }
  }
  _onStartTileLoading() {
    this._pendingCount++;
    this.stats.get(TILES_LOADING).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--;
    this.stats.get(TILES_LOADING).decrementCount();
  }
  _addTileToCache(tile) {
    this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
  }
  _updateCacheStats(tile) {
    this.stats.get(TILES_LOADED).incrementCount();
    this.stats.get(TILES_IN_MEMORY).incrementCount();
    this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    if (this.options.memoryAdjustedScreenSpaceError) {
      this.adjustScreenSpaceError();
    }
  }
  _unloadTile(tile) {
    this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;
    this.stats.get(TILES_IN_MEMORY).decrementCount();
    this.stats.get(TILES_UNLOADED).incrementCount();
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    this.options.onTileUnload(tile);
    tile.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const stack2 = [];
    if (this.root) {
      stack2.push(this.root);
    }
    while (stack2.length > 0) {
      const tile = stack2.pop();
      for (const child of tile.children) {
        stack2.push(child);
      }
      this._destroyTile(tile);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(tile) {
    const root = tile;
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      tile = stack2.pop();
      for (const child of tile.children) {
        stack2.push(child);
      }
      if (tile !== root) {
        this._destroyTile(tile);
      }
    }
    root.children = [];
  }
  _destroyTile(tile) {
    this._cache.unloadTile(this, tile);
    this._unloadTile(tile);
    tile.destroy();
  }
  _initializeTiles3DTileset(tilesetJson) {
    if (tilesetJson.queryString) {
      const searchParams = new URLSearchParams(tilesetJson.queryString);
      const queryParams = Object.fromEntries(searchParams.entries());
      this._queryParams = { ...this._queryParams, ...queryParams };
    }
    this.asset = tilesetJson.asset;
    if (!this.asset) {
      throw new Error("Tileset must have an asset property.");
    }
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1") {
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    }
    if ("tilesetVersion" in this.asset) {
      this._queryParams.v = this.asset.tilesetVersion;
    }
    this.credits = {
      attributions: this.options.attributions || []
    };
    this.description = this.options.description || "";
    this.properties = tilesetJson.properties;
    this.geometricError = tilesetJson.geometricError;
    this._extensionsUsed = tilesetJson.extensionsUsed || [];
    this.extras = tilesetJson.extras;
  }
  _initializeI3STileset() {
    if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
      this._queryParams.token = this.loadOptions.i3s.token;
    }
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/version.js
var VERSION7 = true ? "4.2.0-beta.2" : "latest";

// node_modules/@loaders.gl/3d-tiles/dist/lib/constants.js
var TILE3D_TYPE = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-utils.js
function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  assert2(arrayBuffer instanceof ArrayBuffer);
  const textDecoder = new TextDecoder("utf8");
  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
  const string = textDecoder.decode(typedArray);
  return string;
}
function getMagicString2(arrayBuffer, byteOffset = 0) {
  const dataView = new DataView(arrayBuffer);
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}

// node_modules/@loaders.gl/math/dist/geometry/constants.js
var GL_PRIMITIVE_MODE = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
};
var GL_TYPE = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
};
var GL2 = {
  ...GL_PRIMITIVE_MODE,
  ...GL_TYPE
};

// node_modules/@loaders.gl/math/dist/geometry/gl/gl-type.js
var GL_TYPE_TO_ARRAY_TYPE = {
  [GL_TYPE.DOUBLE]: Float64Array,
  [GL_TYPE.FLOAT]: Float32Array,
  [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
  [GL_TYPE.UNSIGNED_INT]: Uint32Array,
  [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
  [GL_TYPE.BYTE]: Int8Array,
  [GL_TYPE.SHORT]: Int16Array,
  [GL_TYPE.INT]: Int32Array
};
var NAME_TO_GL_TYPE = {
  DOUBLE: GL_TYPE.DOUBLE,
  FLOAT: GL_TYPE.FLOAT,
  UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
  UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
  UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
  BYTE: GL_TYPE.BYTE,
  SHORT: GL_TYPE.SHORT,
  INT: GL_TYPE.INT
};
var ERR_TYPE_CONVERSION = "Failed to convert GL type";
var GLType = class _GLType {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(arrayOrType) {
    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
      if (ArrayType === arrayOrType) {
        return glType;
      }
    }
    throw new Error(ERR_TYPE_CONVERSION);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(name12) {
    const glType = NAME_TO_GL_TYPE[name12];
    if (!glType) {
      throw new Error(ERR_TYPE_CONVERSION);
    }
    return glType;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(glType) {
    switch (glType) {
      case GL_TYPE.UNSIGNED_SHORT_5_6_5:
      case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
      case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (!ArrayType) {
          throw new Error(ERR_TYPE_CONVERSION);
        }
        return ArrayType;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(glType) {
    const ArrayType = _GLType.getArrayType(glType);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(glType) {
    return Boolean(_GLType.getArrayType(glType));
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(glType, buffer, byteOffset = 0, length2) {
    if (length2 === void 0) {
      length2 = (buffer.byteLength - byteOffset) / _GLType.getByteSize(glType);
    }
    const ArrayType = _GLType.getArrayType(glType);
    return new ArrayType(buffer, byteOffset, length2);
  }
};

// node_modules/@loaders.gl/math/dist/geometry/utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion failed. ${message}`);
  }
}

// node_modules/@loaders.gl/math/dist/geometry/colors/rgb565.js
function decodeRGB565(rgb565, target = [0, 0, 0]) {
  const r5 = rgb565 >> 11 & 31;
  const g6 = rgb565 >> 5 & 63;
  const b5 = rgb565 & 31;
  target[0] = r5 << 3;
  target[1] = g6 << 2;
  target[2] = b5 << 3;
  return target;
}

// node_modules/@loaders.gl/math/dist/geometry/compression/attribute-compression.js
var RIGHT_SHIFT = 1 / 256;
var scratchVector25 = new Vector2();
var scratchVector34 = new Vector3();
var scratchEncodeVector2 = new Vector2();
var octEncodeScratch = new Vector2();
var uint8ForceArray = new Uint8Array(1);
function fromSNorm(value, rangeMaximum = 255) {
  return clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
}
function signNotZero(value) {
  return value < 0 ? -1 : 1;
}
function octDecodeInRange(x2, y2, rangeMax, result) {
  assert6(result);
  if (x2 < 0 || x2 > rangeMax || y2 < 0 || y2 > rangeMax) {
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);
  }
  result.x = fromSNorm(x2, rangeMax);
  result.y = fromSNorm(y2, rangeMax);
  result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
  if (result.z < 0) {
    const oldVX = result.x;
    result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
    result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
  }
  return result.normalize();
}
function octDecode(x2, y2, result) {
  return octDecodeInRange(x2, y2, 255, result);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-feature-table.js
var Tile3DFeatureTable = class {
  constructor(featureTableJson, featureTableBinary) {
    __publicField(this, "json");
    __publicField(this, "buffer");
    __publicField(this, "featuresLength", 0);
    __publicField(this, "_cachedTypedArrays", {});
    this.json = featureTableJson;
    this.buffer = featureTableBinary;
  }
  getExtension(extensionName) {
    return this.json.extensions && this.json.extensions[extensionName];
  }
  hasProperty(propertyName) {
    return Boolean(this.json[propertyName]);
  }
  getGlobalProperty(propertyName, componentType = GL2.UNSIGNED_INT, componentLength = 1) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
    }
    return jsonValue;
  }
  getPropertyArray(propertyName, componentType, componentLength) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      if ("componentType" in jsonValue) {
        componentType = GLType.fromName(jsonValue.componentType);
      }
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
    }
    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
  }
  getProperty(propertyName, componentType, componentLength, featureId, result) {
    const jsonValue = this.json[propertyName];
    if (!jsonValue) {
      return jsonValue;
    }
    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
    if (componentLength === 1) {
      return typedArray[featureId];
    }
    for (let i3 = 0; i3 < componentLength; ++i3) {
      result[i3] = typedArray[componentLength * featureId + i3];
    }
    return result;
  }
  // HELPERS
  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
  _getTypedArrayFromArray(propertyName, componentType, array) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = GLType.createTypedArray(componentType, array);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/helpers/tile-3d-accessor-utils.js
var COMPONENTS_PER_ATTRIBUTE = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var UNPACKER = {
  SCALAR: (values, i3) => values[i3],
  VEC2: (values, i3) => [values[2 * i3 + 0], values[2 * i3 + 1]],
  VEC3: (values, i3) => [values[3 * i3 + 0], values[3 * i3 + 1], values[3 * i3 + 2]],
  VEC4: (values, i3) => [values[4 * i3 + 0], values[4 * i3 + 1], values[4 * i3 + 2], values[4 * i3 + 3]],
  // TODO: check column major
  MAT2: (values, i3) => [
    values[4 * i3 + 0],
    values[4 * i3 + 1],
    values[4 * i3 + 2],
    values[4 * i3 + 3]
  ],
  MAT3: (values, i3) => [
    values[9 * i3 + 0],
    values[9 * i3 + 1],
    values[9 * i3 + 2],
    values[9 * i3 + 3],
    values[9 * i3 + 4],
    values[9 * i3 + 5],
    values[9 * i3 + 6],
    values[9 * i3 + 7],
    values[9 * i3 + 8]
  ],
  MAT4: (values, i3) => [
    values[16 * i3 + 0],
    values[16 * i3 + 1],
    values[16 * i3 + 2],
    values[16 * i3 + 3],
    values[16 * i3 + 4],
    values[16 * i3 + 5],
    values[16 * i3 + 6],
    values[16 * i3 + 7],
    values[16 * i3 + 8],
    values[16 * i3 + 9],
    values[16 * i3 + 10],
    values[16 * i3 + 11],
    values[16 * i3 + 12],
    values[16 * i3 + 13],
    values[16 * i3 + 14],
    values[16 * i3 + 15]
  ]
};
var PACKER = {
  SCALAR: (x2, values, i3) => {
    values[i3] = x2;
  },
  VEC2: (x2, values, i3) => {
    values[2 * i3 + 0] = x2[0];
    values[2 * i3 + 1] = x2[1];
  },
  VEC3: (x2, values, i3) => {
    values[3 * i3 + 0] = x2[0];
    values[3 * i3 + 1] = x2[1];
    values[3 * i3 + 2] = x2[2];
  },
  VEC4: (x2, values, i3) => {
    values[4 * i3 + 0] = x2[0];
    values[4 * i3 + 1] = x2[1];
    values[4 * i3 + 2] = x2[2];
    values[4 * i3 + 3] = x2[3];
  },
  // TODO: check column major correctness
  MAT2: (x2, values, i3) => {
    values[4 * i3 + 0] = x2[0];
    values[4 * i3 + 1] = x2[1];
    values[4 * i3 + 2] = x2[2];
    values[4 * i3 + 3] = x2[3];
  },
  MAT3: (x2, values, i3) => {
    values[9 * i3 + 0] = x2[0];
    values[9 * i3 + 1] = x2[1];
    values[9 * i3 + 2] = x2[2];
    values[9 * i3 + 3] = x2[3];
    values[9 * i3 + 4] = x2[4];
    values[9 * i3 + 5] = x2[5];
    values[9 * i3 + 6] = x2[6];
    values[9 * i3 + 7] = x2[7];
    values[9 * i3 + 8] = x2[8];
    values[9 * i3 + 9] = x2[9];
  },
  MAT4: (x2, values, i3) => {
    values[16 * i3 + 0] = x2[0];
    values[16 * i3 + 1] = x2[1];
    values[16 * i3 + 2] = x2[2];
    values[16 * i3 + 3] = x2[3];
    values[16 * i3 + 4] = x2[4];
    values[16 * i3 + 5] = x2[5];
    values[16 * i3 + 6] = x2[6];
    values[16 * i3 + 7] = x2[7];
    values[16 * i3 + 8] = x2[8];
    values[16 * i3 + 9] = x2[9];
    values[16 * i3 + 10] = x2[10];
    values[16 * i3 + 11] = x2[11];
    values[16 * i3 + 12] = x2[12];
    values[16 * i3 + 13] = x2[13];
    values[16 * i3 + 14] = x2[14];
    values[16 * i3 + 15] = x2[15];
  }
};
function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length2) {
  const { componentType } = tile3DAccessor;
  assert2(tile3DAccessor.componentType);
  const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
  const unpacker = UNPACKER[tile3DAccessor.type];
  const packer = PACKER[tile3DAccessor.type];
  byteOffset += tile3DAccessor.byteOffset;
  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length2);
  return {
    values,
    type,
    size,
    unpacker,
    packer
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table-hierarchy.js
var defined3 = (x2) => x2 !== void 0;
function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
  if (!jsonHeader) {
    return null;
  }
  let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
  const legacyHierarchy = jsonHeader.HIERARCHY;
  if (legacyHierarchy) {
    console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
    jsonHeader.extensions = jsonHeader.extensions || {};
    jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
    hierarchy = legacyHierarchy;
  }
  if (!hierarchy) {
    return null;
  }
  return initializeHierarchyValues(hierarchy, binaryBody);
}
function initializeHierarchyValues(hierarchyJson, binaryBody) {
  let i3;
  let classId;
  let binaryAccessor;
  const instancesLength = hierarchyJson.instancesLength;
  const classes = hierarchyJson.classes;
  let classIds = hierarchyJson.classIds;
  let parentCounts = hierarchyJson.parentCounts;
  let parentIds = hierarchyJson.parentIds;
  let parentIdsLength = instancesLength;
  if (defined3(classIds.byteOffset)) {
    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
    classIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(classIds);
    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
  }
  let parentIndexes;
  if (defined3(parentCounts)) {
    if (defined3(parentCounts.byteOffset)) {
      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
      parentCounts.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentCounts);
      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
    }
    parentIndexes = new Uint16Array(instancesLength);
    parentIdsLength = 0;
    for (i3 = 0; i3 < instancesLength; ++i3) {
      parentIndexes[i3] = parentIdsLength;
      parentIdsLength += parentCounts[i3];
    }
  }
  if (defined3(parentIds) && defined3(parentIds.byteOffset)) {
    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
    parentIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(parentIds);
    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
  }
  const classesLength = classes.length;
  for (i3 = 0; i3 < classesLength; ++i3) {
    const classInstancesLength = classes[i3].length;
    const properties = classes[i3].instances;
    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
    classes[i3].instances = combine(binaryProperties, properties);
  }
  const classCounts = new Array(classesLength).fill(0);
  const classIndexes = new Uint16Array(instancesLength);
  for (i3 = 0; i3 < instancesLength; ++i3) {
    classId = classIds[i3];
    classIndexes[i3] = classCounts[classId];
    ++classCounts[classId];
  }
  const hierarchy = {
    classes,
    classIds,
    classIndexes,
    parentCounts,
    parentIndexes,
    parentIds
  };
  validateHierarchy(hierarchy);
  return hierarchy;
}
function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
  if (!hierarchy) {
    return;
  }
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  if (parentIds) {
    return endConditionCallback(hierarchy, instanceIndex);
  }
  if (parentCounts > 0) {
    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
  }
  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
}
function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
  const classIds = hierarchy.classIds;
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const instancesLength = classIds.length;
  const visited = scratchVisited;
  visited.length = Math.max(visited.length, instancesLength);
  const visitedMarker = ++marker;
  const stack2 = scratchStack;
  stack2.length = 0;
  stack2.push(instanceIndex);
  while (stack2.length > 0) {
    instanceIndex = stack2.pop();
    if (visited[instanceIndex] === visitedMarker) {
      continue;
    }
    visited[instanceIndex] = visitedMarker;
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined3(result)) {
      return result;
    }
    const parentCount = parentCounts[instanceIndex];
    const parentIndex = parentIndexes[instanceIndex];
    for (let i3 = 0; i3 < parentCount; ++i3) {
      const parentId = parentIds[parentIndex + i3];
      if (parentId !== instanceIndex) {
        stack2.push(parentId);
      }
    }
  }
  return null;
}
function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
  let hasParent = true;
  while (hasParent) {
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined3(result)) {
      return result;
    }
    const parentId = hierarchy.parentIds[instanceIndex];
    hasParent = parentId !== instanceIndex;
    instanceIndex = parentId;
  }
  throw new Error("traverseHierarchySingleParent");
}
function validateHierarchy(hierarchy) {
  const scratchValidateStack = [];
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  for (let i3 = 0; i3 < instancesLength; ++i3) {
    validateInstance(hierarchy, i3, stack);
  }
}
function validateInstance(hierarchy, instanceIndex, stack2) {
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  if (!defined3(parentIds)) {
    return;
  }
  assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);
  assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
  stack2.push(instanceIndex);
  const parentCount = defined3(parentCounts) ? parentCounts[instanceIndex] : 1;
  const parentIndex = defined3(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
  for (let i3 = 0; i3 < parentCount; ++i3) {
    const parentId = parentIds[parentIndex + i3];
    if (parentId !== instanceIndex) {
      validateInstance(hierarchy, parentId, stack2);
    }
  }
  stack2.pop(instanceIndex);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table.js
function defined4(x2) {
  return x2 !== void 0 && x2 !== null;
}
var clone = (x2, y2) => x2;
var IGNORED_PROPERTY_FIELDS = {
  HIERARCHY: true,
  // Deprecated HIERARCHY property
  extensions: true,
  extras: true
};
var Tile3DBatchTableParser = class {
  constructor(json, binary, featureCount, options = {}) {
    __publicField(this, "json");
    __publicField(this, "binary");
    __publicField(this, "featureCount");
    __publicField(this, "_extensions");
    // Copy all top-level property fields from the json object, ignoring special fields
    __publicField(this, "_properties");
    __publicField(this, "_binaryProperties");
    // TODO: hierarchy support is only partially implemented and not tested
    __publicField(this, "_hierarchy");
    var _a;
    assert2(featureCount >= 0);
    this.json = json || {};
    this.binary = binary;
    this.featureCount = featureCount;
    this._extensions = ((_a = this.json) == null ? void 0 : _a.extensions) || {};
    this._properties = {};
    for (const propertyName in this.json) {
      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
        this._properties[propertyName] = this.json[propertyName];
      }
    }
    this._binaryProperties = this._initializeBinaryProperties();
    if (options["3DTILES_batch_table_hierarchy"]) {
      this._hierarchy = initializeHierarchy(this, this.json, this.binary);
    }
  }
  getExtension(extensionName) {
    return this.json && this.json.extensions && this.json.extensions[extensionName];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(batchId, className) {
    this._checkBatchId(batchId);
    assert2(typeof className === "string", className);
    if (this._hierarchy) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        return instanceClass.name === className;
      });
      return defined4(result);
    }
    return false;
  }
  isExactClass(batchId, className) {
    assert2(typeof className === "string", className);
    return this.getExactClassName(batchId) === className;
  }
  getExactClassName(batchId) {
    this._checkBatchId(batchId);
    if (this._hierarchy) {
      const classId = this._hierarchy.classIds[batchId];
      const instanceClass = this._hierarchy.classes[classId];
      return instanceClass.name;
    }
    return void 0;
  }
  hasProperty(batchId, name12) {
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    return defined4(this._properties[name12]) || this._hasPropertyInHierarchy(batchId, name12);
  }
  getPropertyNames(batchId, results) {
    this._checkBatchId(batchId);
    results = defined4(results) ? results : [];
    results.length = 0;
    const propertyNames = Object.keys(this._properties);
    results.push(...propertyNames);
    if (this._hierarchy) {
      this._getPropertyNamesInHierarchy(batchId, results);
    }
    return results;
  }
  getProperty(batchId, name12) {
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name12];
      if (defined4(binaryProperty)) {
        return this._getBinaryProperty(binaryProperty, batchId);
      }
    }
    const propertyValues = this._properties[name12];
    if (defined4(propertyValues)) {
      return clone(propertyValues[batchId], true);
    }
    if (this._hierarchy) {
      const hierarchyProperty = this._getHierarchyProperty(batchId, name12);
      if (defined4(hierarchyProperty)) {
        return hierarchyProperty;
      }
    }
    return void 0;
  }
  setProperty(batchId, name12, value) {
    const featureCount = this.featureCount;
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name12];
      if (binaryProperty) {
        this._setBinaryProperty(binaryProperty, batchId, value);
        return;
      }
    }
    if (this._hierarchy) {
      if (this._setHierarchyProperty(this, batchId, name12, value)) {
        return;
      }
    }
    let propertyValues = this._properties[name12];
    if (!defined4(propertyValues)) {
      this._properties[name12] = new Array(featureCount);
      propertyValues = this._properties[name12];
    }
    propertyValues[batchId] = clone(value, true);
  }
  // PRIVATE METHODS
  _checkBatchId(batchId) {
    const valid = batchId >= 0 && batchId < this.featureCount;
    if (!valid) {
      throw new Error("batchId not in range [0, featureCount - 1].");
    }
  }
  _getBinaryProperty(binaryProperty, index) {
    return binaryProperty.unpack(binaryProperty.typedArray, index);
  }
  _setBinaryProperty(binaryProperty, index, value) {
    binaryProperty.pack(value, binaryProperty.typedArray, index);
  }
  _initializeBinaryProperties() {
    let binaryProperties = null;
    for (const name12 in this._properties) {
      const property = this._properties[name12];
      const binaryProperty = this._initializeBinaryProperty(name12, property);
      if (binaryProperty) {
        binaryProperties = binaryProperties || {};
        binaryProperties[name12] = binaryProperty;
      }
    }
    return binaryProperties;
  }
  _initializeBinaryProperty(name12, property) {
    if ("byteOffset" in property) {
      const tile3DAccessor = property;
      assert2(this.binary, `Property ${name12} requires a batch table binary.`);
      assert2(tile3DAccessor.type, `Property ${name12} requires a type.`);
      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: accessor.values,
        componentCount: accessor.size,
        unpack: accessor.unpacker,
        pack: accessor.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(batchId, name12) {
    if (!this._hierarchy) {
      return false;
    }
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      return defined4(instances[name12]);
    });
    return defined4(result);
  }
  _getPropertyNamesInHierarchy(batchId, results) {
    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      for (const name12 in instances) {
        if (instances.hasOwnProperty(name12)) {
          if (results.indexOf(name12) === -1) {
            results.push(name12);
          }
        }
      }
    });
  }
  _getHierarchyProperty(batchId, name12) {
    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name12];
      if (defined4(propertyValues)) {
        if (defined4(propertyValues.typedArray)) {
          return this._getBinaryProperty(propertyValues, indexInClass);
        }
        return clone(propertyValues[indexInClass], true);
      }
      return null;
    });
  }
  _setHierarchyProperty(batchTable, batchId, name12, value) {
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name12];
      if (defined4(propertyValues)) {
        assert2(instanceIndex === batchId, `Inherited property "${name12}" is read-only.`);
        if (defined4(propertyValues.typedArray)) {
          this._setBinaryProperty(propertyValues, indexInClass, value);
        } else {
          propertyValues[indexInClass] = clone(value, true);
        }
        return true;
      }
      return false;
    });
    return defined4(result);
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-header.js
var SIZEOF_UINT32 = 4;
function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {
  const view = new DataView(arrayBuffer);
  tile.magic = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.version = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.byteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  if (tile.version !== 1) {
    throw new Error(`3D Tile Version ${tile.version} not supported`);
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-tables.js
var SIZEOF_UINT322 = 4;
var DEPRECATION_WARNING = "b3dm tile in legacy format.";
function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
  const view = new DataView(arrayBuffer);
  let batchLength;
  tile.header = tile.header || {};
  let featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  if (batchTableJsonByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322 * 2;
    batchLength = featureTableJsonByteLength;
    batchTableJsonByteLength = featureTableBinaryByteLength;
    batchTableBinaryByteLength = 0;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  } else if (batchTableBinaryByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322;
    batchLength = batchTableJsonByteLength;
    batchTableJsonByteLength = featureTableJsonByteLength;
    batchTableBinaryByteLength = featureTableBinaryByteLength;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  }
  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
  tile.header.batchLength = batchLength;
  return byteOffset;
}
function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
  return byteOffset;
}
function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
  const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};
  tile.featureTableJson = {
    BATCH_LENGTH: batchLength || 0
  };
  if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {
    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);
    tile.featureTableJson = JSON.parse(featureTableString);
  }
  byteOffset += featureTableJsonByteLength || 0;
  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength || 0;
  return byteOffset;
}
function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
  const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};
  if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {
    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);
    tile.batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;
    if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {
      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-colors.js
function normalize3DTileColorAttribute(tile, colors, batchTable) {
  if (!colors && (!tile || !tile.batchIds || !batchTable)) {
    return null;
  }
  const { batchIds, isRGB565, pointCount = 0 } = tile;
  if (batchIds && batchTable) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i3 = 0; i3 < pointCount; i3++) {
      const batchId = batchIds[i3];
      const dimensions = batchTable.getProperty(batchId, "dimensions");
      const color = dimensions.map((d) => d * 255);
      colorArray[i3 * 3] = color[0];
      colorArray[i3 * 3 + 1] = color[1];
      colorArray[i3 * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && isRGB565) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i3 = 0; i3 < pointCount; i3++) {
      const color = decodeRGB565(colors[i3]);
      colorArray[i3 * 3] = color[0];
      colorArray[i3 * 3 + 1] = color[1];
      colorArray[i3 * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && colors.length === pointCount * 3) {
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors,
      size: 3,
      normalized: true
    };
  }
  return {
    type: GL2.UNSIGNED_BYTE,
    value: colors || new Uint8ClampedArray(),
    size: 4,
    normalized: true
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-normals.js
var scratchNormal4 = new Vector3();
function normalize3DTileNormalAttribute(tile, normals) {
  if (!normals) {
    return null;
  }
  if (tile.isOctEncoded16P) {
    const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);
    for (let i3 = 0; i3 < (tile.pointsLength || 0); i3++) {
      octDecode(normals[i3 * 2], normals[i3 * 2 + 1], scratchNormal4);
      scratchNormal4.toArray(decodedArray, i3 * 3);
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: decodedArray
    };
  }
  return {
    type: GL2.FLOAT,
    size: 2,
    value: normals
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-positions.js
function normalize3DTilePositionAttribute(tile, positions, options) {
  if (!tile.isQuantized) {
    return positions;
  }
  if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
    tile.isQuantized = false;
    return decodeQuantizedPositions(tile, positions);
  }
  return {
    type: GL2.UNSIGNED_SHORT,
    value: positions,
    size: 3,
    normalized: true
  };
}
function decodeQuantizedPositions(tile, positions) {
  const scratchPosition5 = new Vector3();
  const decodedArray = new Float32Array(tile.pointCount * 3);
  for (let i3 = 0; i3 < tile.pointCount; i3++) {
    scratchPosition5.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i3 * 3);
  }
  return decodedArray;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-point-cloud.js
async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  initializeTile(tile);
  const { featureTable, batchTable } = parsePointCloudTables(tile);
  await parseDraco(tile, featureTable, batchTable, options, context);
  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, batchTable);
  parseNormals(tile, featureTable);
  return byteOffset;
}
function initializeTile(tile) {
  tile.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  tile.isQuantized = false;
  tile.isTranslucent = false;
  tile.isRGB565 = false;
  tile.isOctEncoded16P = false;
}
function parsePointCloudTables(tile) {
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(pointsLength)) {
    throw new Error("POINTS_LENGTH must be defined");
  }
  featureTable.featuresLength = pointsLength;
  tile.featuresLength = pointsLength;
  tile.pointsLength = pointsLength;
  tile.pointCount = pointsLength;
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = parseBatchIds(tile, featureTable);
  return { featureTable, batchTable };
}
function parsePositions(tile, featureTable, options) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.positions) {
    if (featureTable.hasProperty("POSITION")) {
      tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
      tile.isQuantized = true;
      tile.quantizedRange = (1 << 16) - 1;
      tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeScale) {
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeOffset) {
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
    }
  }
  if (!tile.attributes.positions) {
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
  }
}
function parseColors(tile, featureTable, batchTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.colors) {
    let colors = null;
    if (featureTable.hasProperty("RGBA")) {
      colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty("RGB")) {
      colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
    } else if (featureTable.hasProperty("RGB565")) {
      colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }
    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
  }
  if (featureTable.hasProperty("CONSTANT_RGBA")) {
    tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
  }
}
function parseNormals(tile, featureTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.normals) {
    let normals = null;
    if (featureTable.hasProperty("NORMAL")) {
      normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
      normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }
    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
  }
}
function parseBatchIds(tile, featureTable) {
  let batchTable = null;
  if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
    tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
    if (tile.batchIds) {
      const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
      if (!batchFeatureLength) {
        throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
      }
      const { batchTableJson, batchTableBinary } = tile;
      batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
    }
  }
  return batchTable;
}
async function parseDraco(tile, featureTable, batchTable, options, context) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;
  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }
  const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    }
    dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
  }
  if (!dracoBuffer) {
    return true;
  }
  const dracoData = {
    buffer: dracoBuffer,
    properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },
    featureTableProperties: dracoFeatureTableProperties,
    batchTableProperties: dracoBatchTableProperties,
    dequantizeInShader: false
  };
  return await loadDraco(tile, dracoData, options, context);
}
async function loadDraco(tile, dracoData, options, context) {
  if (!context) {
    return;
  }
  const dracoOptions = {
    ...options,
    draco: {
      ...options == null ? void 0 : options.draco,
      extraAttributes: dracoData.batchTableProperties || {}
    }
  };
  delete dracoOptions["3d-tiles"];
  const data = await parseFromContext(dracoData.buffer, DracoLoader2, dracoOptions, context);
  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
  if (isQuantizedDraco) {
    const quantization = data.POSITION.data.quantization;
    const range = quantization.range;
    tile.quantizedVolumeScale = new Vector3(range, range, range);
    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
    tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
    tile.isQuantizedDraco = true;
  }
  if (isOctEncodedDraco) {
    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
    tile.isOctEncodedDraco = true;
  }
  const batchTableAttributes = {};
  if (dracoData.batchTableProperties) {
    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
      if (data.attributes[attributeName] && data.attributes[attributeName].value) {
        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
      }
    }
  }
  tile.attributes = {
    // @ts-expect-error
    positions: decodedPositions,
    // @ts-expect-error
    colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
    // @ts-expect-error
    normals: decodedNormals,
    // @ts-expect-error
    batchIds: decodedBatchIds,
    ...batchTableAttributes
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js
var GLTF_FORMAT = {
  URI: 0,
  EMBEDDED: 1
};
function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {
  tile.rotateYtoZ = true;
  const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;
  if (gltfByteLength === 0) {
    throw new Error("glTF byte length must be greater than 0.");
  }
  tile.gltfUpAxis = (options == null ? void 0 : options["3d-tiles"]) && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  if (byteOffset % 4 === 0) {
  } else {
    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
  }
  return (tile.byteOffset || 0) + (tile.byteLength || 0);
}
async function extractGLTF(tile, gltfFormat, options, context) {
  const tile3DOptions = (options == null ? void 0 : options["3d-tiles"]) || {};
  extractGLTFBufferOrURL(tile, gltfFormat, options);
  if (tile3DOptions.loadGLTF) {
    if (!context) {
      return;
    }
    if (tile.gltfUrl) {
      const { fetch: fetch2 } = context;
      const response = await fetch2(tile.gltfUrl, options);
      tile.gltfArrayBuffer = await response.arrayBuffer();
      tile.gltfByteOffset = 0;
    }
    if (tile.gltfArrayBuffer) {
      const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);
      tile.gltf = postProcessGLTF(gltfWithBuffers);
      tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
    }
  }
}
function extractGLTFBufferOrURL(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      if (tile.gltfArrayBuffer) {
        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
        const textDecoder = new TextDecoder();
        const gltfUrl = textDecoder.decode(gltfUrlBytes);
        tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
      }
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
      break;
    case GLTF_FORMAT.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-batched-model.js
async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
  const extensions = (_a = tile == null ? void 0 : tile.gltf) == null ? void 0 : _a.extensions;
  if (extensions && extensions.CESIUM_RTC) {
    tile.rtcCenter = extensions.CESIUM_RTC.center;
  }
  return byteOffset;
}
function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-instanced-model.js
async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, tile.gltfFormat || 0, options, context);
  return byteOffset;
}
function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  if (tile.version !== 1) {
    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
  }
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.gltfFormat = view.getUint32(byteOffset, true);
  byteOffset += 4;
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  if (!((_a = tile == null ? void 0 : tile.header) == null ? void 0 : _a.featureTableJsonByteLength) || tile.header.featureTableJsonByteLength === 0) {
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  }
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
  featureTable.featuresLength = instancesLength;
  if (!Number.isFinite(instancesLength)) {
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  }
  tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
  return byteOffset;
}
function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
  const instances = new Array(instancesLength);
  const instancePosition = new Vector3();
  const instanceNormalRight = new Vector3();
  const instanceNormalUp = new Vector3();
  const instanceNormalForward = new Vector3();
  const instanceRotation = new Matrix3();
  const instanceQuaternion = new Quaternion();
  const instanceScale = new Vector3();
  const instanceTranslationRotationScale = {};
  const instanceTransform = new Matrix4();
  const scratch1 = [];
  const scratch2 = [];
  const scratch3 = [];
  const scratch4 = [];
  for (let i3 = 0; i3 < instancesLength; i3++) {
    let position;
    if (featureTable.hasProperty("POSITION")) {
      position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i3, instancePosition);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i3, instancePosition);
      const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
      if (!quantizedVolumeOffset) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
      if (!quantizedVolumeScale) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      const MAX_UNSIGNED_SHORT = 65535;
      for (let j = 0; j < 3; j++) {
        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }
    if (!position) {
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    }
    instancePosition.copy(position);
    instanceTranslationRotationScale.translation = instancePosition;
    tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i3, scratch1);
    tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i3, scratch2);
    const hasCustomOrientation = false;
    if (tile.normalUp) {
      if (!tile.normalRight) {
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      }
      tile.hasCustomOrientation = true;
    } else {
      tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, i3, scratch1);
      tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, i3, scratch2);
      if (tile.octNormalUp) {
        if (!tile.octNormalRight) {
          throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
        }
        throw new Error("i3dm: oct-encoded orientation not implemented");
      } else if (tile.eastNorthUp) {
        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
        instanceTransform.getRotationMatrix3(instanceRotation);
      } else {
        instanceRotation.identity();
      }
    }
    if (hasCustomOrientation) {
      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
      instanceRotation.setColumn(0, instanceNormalRight);
      instanceRotation.setColumn(1, instanceNormalUp);
      instanceRotation.setColumn(2, instanceNormalForward);
    }
    instanceQuaternion.fromMatrix3(instanceRotation);
    instanceTranslationRotationScale.rotation = instanceQuaternion;
    instanceScale.set(1, 1, 1);
    const scale = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i3, scratch3);
    if (Number.isFinite(scale)) {
      instanceScale.multiplyByScalar(scale);
    }
    const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i3, scratch1);
    if (nonUniformScale) {
      instanceScale.scale(nonUniformScale);
    }
    instanceTranslationRotationScale.scale = instanceScale;
    let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i3, scratch4);
    if (batchId === void 0) {
      batchId = i3;
    }
    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
    instanceTransform.identity();
    instanceTransform.translate(instanceTranslationRotationScale.translation);
    instanceTransform.multiplyRight(rotationMatrix);
    instanceTransform.scale(instanceTranslationRotationScale.scale);
    const modelMatrix2 = instanceTransform.clone();
    instances[i3] = {
      modelMatrix: modelMatrix2,
      batchId
    };
  }
  tile.instances = instances;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-composite.js
async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile2) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {
    const subtile = { shape: "tile3d" };
    tile.tiles.push(subtile);
    byteOffset = await parse3DTile2(arrayBuffer, byteOffset, options, context, subtile);
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-gltf.js
async function parseGltf3DTile(tile, arrayBuffer, options, context) {
  var _a, _b;
  tile.rotateYtoZ = true;
  tile.gltfUpAxis = ((_a = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _a.assetGltfUpAxis) ? options["3d-tiles"].assetGltfUpAxis : "Y";
  if ((_b = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _b.loadGLTF) {
    if (!context) {
      return arrayBuffer.byteLength;
    }
    const gltfWithBuffers = await parseFromContext(arrayBuffer, GLTFLoader, options, context);
    tile.gltf = postProcessGLTF(gltfWithBuffers);
    tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
  } else {
    tile.gltfArrayBuffer = arrayBuffer;
  }
  return arrayBuffer.byteLength;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile.js
async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = { shape: "tile3d" }) {
  tile.byteOffset = byteOffset;
  tile.type = getMagicString2(arrayBuffer, byteOffset);
  switch (tile.type) {
    case TILE3D_TYPE.COMPOSITE:
      return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);
    case TILE3D_TYPE.BATCHED_3D_MODEL:
      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.GLTF:
      return await parseGltf3DTile(tile, arrayBuffer, options, context);
    case TILE3D_TYPE.INSTANCED_3D_MODEL:
      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.POINT_CLOUD:
      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);
    default:
      throw new Error(`3DTileLoader: unknown type ${tile.type}`);
  }
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-subtree.js
var SUBTREE_FILE_MAGIC = 1952609651;
var SUBTREE_FILE_VERSION = 1;
async function parse3DTilesSubtree(data, options, context) {
  const magic = new Uint32Array(data.slice(0, 4));
  if (magic[0] !== SUBTREE_FILE_MAGIC) {
    throw new Error("Wrong subtree file magic number");
  }
  const version = new Uint32Array(data.slice(4, 8));
  if (version[0] !== SUBTREE_FILE_VERSION) {
    throw new Error("Wrong subtree file verson, must be 1");
  }
  const jsonByteLength = parseUint64Value(data.slice(8, 16));
  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
  const textDecoder = new TextDecoder("utf8");
  const string = textDecoder.decode(stringAttribute);
  const subtree = JSON.parse(string);
  const binaryByteLength = parseUint64Value(data.slice(16, 24));
  let internalBinaryBuffer = new ArrayBuffer(0);
  if (binaryByteLength) {
    internalBinaryBuffer = data.slice(24 + jsonByteLength);
  }
  await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);
  if (Array.isArray(subtree.contentAvailability)) {
    for (const contentAvailability of subtree.contentAvailability) {
      await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);
    }
  } else {
    await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);
  }
  await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);
  return subtree;
}
async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {
  const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;
  if (typeof bufferViewIndex !== "number") {
    return;
  }
  const bufferView = subtree.bufferViews[bufferViewIndex];
  const buffer = subtree.buffers[bufferView.buffer];
  if (!(context == null ? void 0 : context.baseUrl)) {
    throw new Error("Url is not provided");
  }
  if (!context.fetch) {
    throw new Error("fetch is not provided");
  }
  if (buffer.uri) {
    const bufferUri = `${(context == null ? void 0 : context.baseUrl) || ""}/${buffer.uri}`;
    const response = await context.fetch(bufferUri);
    const data = await response.arrayBuffer();
    availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
    return;
  }
  const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);
  availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);
}
function parseUint64Value(buffer) {
  const dataView = new DataView(buffer);
  const left = dataView.getUint32(0, true);
  const right = dataView.getUint32(4, true);
  return left + 2 ** 32 * right;
}

// node_modules/@loaders.gl/3d-tiles/dist/tile-3d-subtree-loader.js
var Tile3DSubtreeLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: VERSION7,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: parse3DTilesSubtree,
  options: {}
};

// node_modules/long/index.js
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e2) {
}
function Long3(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long3.prototype.__isLong__;
Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c2 = Math.clz32(value & -value);
  return value ? 31 - c2 : c2;
}
Long3.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long3.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long3.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long3(lowBits, highBits, unsigned);
}
Long3.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p2;
  if ((p2 = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p2 === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i3 = 0; i3 < str.length; i3 += 8) {
    var size = Math.min(8, str.length - i3), value = parseInt(str.substring(i3, i3 + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long3.fromString = fromString;
function fromValue(val2, unsigned) {
  if (typeof val2 === "number")
    return fromNumber(val2, unsigned);
  if (typeof val2 === "string")
    return fromString(val2, unsigned);
  return fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
}
Long3.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long3.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long3.UZERO = UZERO;
var ONE = fromInt(1);
Long3.ONE = ONE;
var UONE = fromInt(1, true);
Long3.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long3.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long3.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long3.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long3.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val2 = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val2 & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals3(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](
      this.low,
      this.high,
      multiplier.low,
      multiplier.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
  if (numBits === 32)
    return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b2;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b2 = 32 - numBits;
    return fromBits(this.low << numBits | this.high >>> b2, this.high << numBits | this.low >>> b2, this.unsigned);
  }
  numBits -= 32;
  b2 = 32 - numBits;
  return fromBits(this.high << numBits | this.low >>> b2, this.low << numBits | this.high >>> b2, this.unsigned);
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b2;
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  if (numBits === 32)
    return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b2 = 32 - numBits;
    return fromBits(this.high << b2 | this.low >>> numBits, this.low << b2 | this.high >>> numBits, this.unsigned);
  }
  numBits -= 32;
  b2 = 32 - numBits;
  return fromBits(this.low << b2 | this.high >>> numBits, this.high << b2 | this.low >>> numBits, this.unsigned);
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long3.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
};
Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long3(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long3(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
var long_default = Long3;

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-token-functions.js
var MAXIMUM_TOKEN_LENGTH = 16;
function getS2CellIdFromToken(token) {
  if (token === "X") {
    token = "";
  }
  const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
  return long_default.fromString(paddedToken, true, 16);
}
function getS2TokenFromCellId(cellId) {
  if (cellId.isZero()) {
    return "X";
  }
  let numZeroDigits = cellId.countTrailingZeros();
  const remainder = numZeroDigits % 4;
  numZeroDigits = (numZeroDigits - remainder) / 4;
  const trailingZeroHexChars = numZeroDigits;
  numZeroDigits *= 4;
  const x2 = cellId.shiftRightUnsigned(numZeroDigits);
  const hexString = x2.toString(16).replace(/0+$/, "");
  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
  return zeroString + hexString;
}
function getS2ChildCellId(cellId, index) {
  const newLsb = lsb(cellId).shiftRightUnsigned(2);
  const childCellId = cellId.add(long_default.fromNumber(2 * index + 1 - 4).multiply(newLsb));
  return childCellId;
}
function lsb(cellId) {
  return cellId.and(cellId.not().add(1));
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-geometry.js
var FACE_BITS2 = 3;
var MAX_LEVEL2 = 30;
var POS_BITS2 = 2 * MAX_LEVEL2 + 1;
var RADIAN_TO_DEGREE2 = 180 / Math.PI;
function getS2CellFromQuadKey(hilbertQuadkey) {
  if (hilbertQuadkey.length === 0) {
    throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);
  }
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  let level = 0;
  const point2 = [0, 0];
  for (let i3 = maxLevel - 1; i3 >= 0; i3--) {
    level = maxLevel - i3;
    const bit = position[i3];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val2 = Math.pow(2, level - 1);
    rotateAndFlipQuadrant2(val2, point2, rx, ry);
    point2[0] += val2 * rx;
    point2[1] += val2 * ry;
  }
  if (face % 2 === 1) {
    const t2 = point2[0];
    point2[0] = point2[1];
    point2[1] = t2;
  }
  return { face, ij: point2, level };
}
function getS2QuadkeyFromCellId(cellId) {
  if (cellId.isZero()) {
    return "";
  }
  let bin = cellId.toString(2);
  while (bin.length < FACE_BITS2 + POS_BITS2) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = long_default.fromString(faceB, true, 2).toString(10);
  let posS = "";
  if (levelN !== 0) {
    posS = long_default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
  }
  return `${faceS}/${posS}`;
}
function IJToST2(ij, level, offsets) {
  const maxSize = 1 << level;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV2(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV2(st) {
  return [singleSTtoUV2(st[0]), singleSTtoUV2(st[1])];
}
function FaceUVToXYZ2(face, [u, v]) {
  switch (face) {
    case 0:
      return [1, u, v];
    case 1:
      return [-u, 1, v];
    case 2:
      return [-u, -v, 1];
    case 3:
      return [-1, -v, -u];
    case 4:
      return [v, -1, -u];
    case 5:
      return [v, u, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat2([x2, y2, z]) {
  const lat = Math.atan2(z, Math.sqrt(x2 * x2 + y2 * y2));
  const lng = Math.atan2(y2, x2);
  return [lng * RADIAN_TO_DEGREE2, lat * RADIAN_TO_DEGREE2];
}
function rotateAndFlipQuadrant2(n2, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n2 - 1 - point2[0];
      point2[1] = n2 - 1 - point2[1];
    }
    const x2 = point2[0];
    point2[0] = point2[1];
    point2[1] = x2;
  }
}
function getS2LngLatFromS2Cell(s2Cell) {
  const st = IJToST2(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
  const uv = STToUV2(st);
  const xyz = FaceUVToXYZ2(s2Cell.face, uv);
  return XYZToLngLat2(xyz);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-boundary.js
var MAX_RESOLUTION2 = 100;
function getS2BoundaryFlatFromS2Cell(s2cell) {
  const { face, ij, level } = s2cell;
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i3 = 0; i3 < 4; i3++) {
    const offset = offsets[i3].slice(0);
    const nextOffset = offsets[i3 + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST2(ij, level, offset);
      const uv = STToUV2(st);
      const xyz = FaceUVToXYZ2(face, uv);
      const lngLat = XYZToLngLat2(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-cell-utils.js
function getS2Cell(tokenOrKey) {
  const key = getS2QuadKey2(tokenOrKey);
  const s2cell = getS2CellFromQuadKey(key);
  return s2cell;
}
function getS2QuadKey2(tokenOrKey) {
  if (tokenOrKey.indexOf("/") > 0) {
    return tokenOrKey;
  }
  const id = getS2CellIdFromToken(tokenOrKey);
  return getS2QuadkeyFromCellId(id);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-geometry-functions.js
function getS2LngLat(s2Token) {
  const s2cell = getS2Cell(s2Token);
  return getS2LngLatFromS2Cell(s2cell);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-region.js
function getS2Region(s2cell) {
  let region;
  if (s2cell.face === 2 || s2cell.face === 5) {
    let corners = null;
    let len = 0;
    for (let i3 = 0; i3 < 4; i3++) {
      const key = `${s2cell.face}/${i3}`;
      const cell = getS2Cell(key);
      const corns = getS2BoundaryFlatFromS2Cell(cell);
      if (typeof corners === "undefined" || corners === null)
        corners = new Float64Array(4 * corns.length);
      corners.set(corns, len);
      len += corns.length;
    }
    region = get2DRegionFromS2Corners(corners);
  } else {
    const corners = getS2BoundaryFlatFromS2Cell(s2cell);
    region = get2DRegionFromS2Corners(corners);
  }
  return region;
}
function get2DRegionFromS2Corners(corners) {
  if (corners.length % 2 !== 0) {
    throw new Error("Invalid corners");
  }
  const longitudes = [];
  const latitudes = [];
  for (let i3 = 0; i3 < corners.length; i3 += 2) {
    longitudes.push(corners[i3]);
    latitudes.push(corners[i3 + 1]);
  }
  longitudes.sort((a3, b2) => a3 - b2);
  latitudes.sort((a3, b2) => a3 - b2);
  return {
    west: longitudes[0],
    east: longitudes[longitudes.length - 1],
    north: latitudes[latitudes.length - 1],
    south: latitudes[0]
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-obb-points.js
function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
  const min = (heightInfo == null ? void 0 : heightInfo.minimumHeight) || 0;
  const max = (heightInfo == null ? void 0 : heightInfo.maximumHeight) || 0;
  const s2cell = getS2Cell(tokenOrKey);
  const region = getS2Region(s2cell);
  const W = region.west;
  const S = region.south;
  const E = region.east;
  const N = region.north;
  const points = [];
  points.push(new Vector3(W, N, min));
  points.push(new Vector3(E, N, min));
  points.push(new Vector3(E, S, min));
  points.push(new Vector3(W, S, min));
  points.push(new Vector3(W, N, max));
  points.push(new Vector3(E, N, max));
  points.push(new Vector3(E, S, max));
  points.push(new Vector3(W, S, max));
  return points;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/obb/s2-corners-to-obb.js
function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
  const token = s2VolumeInfo.token;
  const heightInfo = {
    minimumHeight: s2VolumeInfo.minimumHeight,
    maximumHeight: s2VolumeInfo.maximumHeight
  };
  const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
  const center = getS2LngLat(token);
  const centerLng = center[0];
  const centerLat = center[1];
  const point2 = Ellipsoid.WGS84.cartographicToCartesian([
    centerLng,
    centerLat,
    heightInfo.maximumHeight
  ]);
  const centerPointAdditional = new Vector3(point2[0], point2[1], point2[2]);
  corners.push(centerPointAdditional);
  const obb = makeOrientedBoundingBoxFromPoints(corners);
  const box = [...obb.center, ...obb.halfAxes];
  return box;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
var QUADTREE_DIVISION_COUNT = 4;
var OCTREE_DIVISION_COUNT = 8;
var SUBDIVISION_COUNT_MAP = {
  QUADTREE: QUADTREE_DIVISION_COUNT,
  OCTREE: OCTREE_DIVISION_COUNT
};
function getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {
  if (s2VolumeBox == null ? void 0 : s2VolumeBox.box) {
    const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
    const childCellId = getS2ChildCellId(cellId, index);
    const childToken = getS2TokenFromCellId(childCellId);
    const s2ChildVolumeInfo = { ...s2VolumeBox.s2VolumeInfo };
    s2ChildVolumeInfo.token = childToken;
    switch (subdivisionScheme) {
      case "OCTREE":
        const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
        const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
        const sizeZ = delta / 2;
        const midZ = s2VolumeInfo.minimumHeight + delta / 2;
        s2VolumeInfo.minimumHeight = midZ - sizeZ;
        s2VolumeInfo.maximumHeight = midZ + sizeZ;
        break;
      default:
        break;
    }
    const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
    const childS2VolumeBox = {
      box,
      s2VolumeInfo: s2ChildVolumeInfo
    };
    return childS2VolumeBox;
  }
  return void 0;
}
async function parseImplicitTiles(params) {
  const { implicitOptions, parentData = {
    mortonIndex: 0,
    x: 0,
    y: 0,
    z: 0
  }, childIndex = 0, s2VolumeBox, loaderOptions } = params;
  let { subtree, level = 0, globalData = {
    level: 0,
    mortonIndex: 0,
    x: 0,
    y: 0,
    z: 0
  } } = params;
  const { subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath } = implicitOptions;
  const tile = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!maximumLevel) {
    dist_default.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);
    return tile;
  }
  const lev = level + globalData.level;
  if (lev > maximumLevel) {
    return tile;
  }
  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
  const bitsPerTile = Math.log2(childrenPerTile);
  const childX = childIndex & 1;
  const childY = childIndex >> 1 & 1;
  const childZ = childIndex >> 2 & 1;
  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);
  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
  let childTileX = concatBits(parentData.x, childX, 1);
  let childTileY = concatBits(parentData.y, childY, 1);
  let childTileZ = concatBits(parentData.z, childZ, 1);
  let isChildSubtreeAvailable = false;
  if (level >= subtreeLevels) {
    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
  }
  const x2 = concatBits(globalData.x, childTileX, level);
  const y2 = concatBits(globalData.y, childTileY, level);
  const z = concatBits(globalData.z, childTileZ, level);
  if (isChildSubtreeAvailable) {
    const subtreePath = `${basePath}/${subtreesUriTemplate}`;
    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x2, y2, z);
    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);
    subtree = childSubtree;
    globalData = {
      mortonIndex: childTileMortonIndex,
      x: childTileX,
      y: childTileY,
      z: childTileZ,
      level
    };
    childTileMortonIndex = 0;
    tileAvailabilityIndex = 0;
    childTileX = 0;
    childTileY = 0;
    childTileZ = 0;
    level = 0;
  }
  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
  if (!isTileAvailable) {
    return tile;
  }
  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
  if (isContentAvailable) {
    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x2, y2, z);
  }
  const childTileLevel = level + 1;
  const pData = { mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ };
  for (let index = 0; index < childrenPerTile; index++) {
    const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);
    const childTileParsed = await parseImplicitTiles({
      subtree,
      implicitOptions,
      loaderOptions,
      parentData: pData,
      childIndex: index,
      level: childTileLevel,
      globalData: { ...globalData },
      s2VolumeBox: childS2VolumeBox
    });
    if (childTileParsed.contentUrl || childTileParsed.children.length) {
      const globalLevel = lev + 1;
      const childCoordinates = { childTileX, childTileY, childTileZ };
      const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, implicitOptions, s2VolumeBox);
      tile.children.push(formattedTile);
    }
  }
  return tile;
}
function getAvailabilityResult(availabilityData, index) {
  let availabilityObject;
  if (Array.isArray(availabilityData)) {
    availabilityObject = availabilityData[0];
    if (availabilityData.length > 1) {
      dist_default.once('Not supported extension "3DTILES_multiple_contents" has been detected');
    }
  } else {
    availabilityObject = availabilityData;
  }
  if ("constant" in availabilityObject) {
    return Boolean(availabilityObject.constant);
  }
  if (availabilityObject.explicitBitstream) {
    return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);
  }
  return false;
}
function formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {
  const { basePath, refine, getRefine: getRefine2, lodMetricType, getTileType: getTileType2, rootLodMetricValue, rootBoundingVolume } = options;
  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, "");
  const lodMetricValue = rootLodMetricValue / 2 ** level;
  const boundingVolume = (s2VolumeBox == null ? void 0 : s2VolumeBox.box) ? { box: s2VolumeBox.box } : rootBoundingVolume;
  const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);
  return {
    children: tile.children,
    contentUrl: tile.contentUrl,
    content: { uri },
    id: tile.contentUrl,
    refine: getRefine2(refine),
    type: getTileType2(tile),
    lodMetricType,
    lodMetricValue,
    geometricError: lodMetricValue,
    transform: tile.transform,
    boundingVolume: boundingVolumeForChildTile
  };
}
function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
  if (rootBoundingVolume.region) {
    const { childTileX, childTileY, childTileZ } = childCoordinates;
    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
    const boundingVolumesCount = 2 ** level;
    const sizeX = (east - west) / boundingVolumesCount;
    const sizeY = (north - south) / boundingVolumesCount;
    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
    const [childMinimumHeight, childMaximumHeight] = [
      minimumHeight + sizeZ * childTileZ,
      minimumHeight + sizeZ * (childTileZ + 1)
    ];
    return {
      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
    };
  }
  if (rootBoundingVolume.box) {
    return rootBoundingVolume;
  }
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);
}
function concatBits(higher, lower, shift) {
  return (higher << shift) + lower;
}
function replaceContentUrlTemplate(templateUrl, level, x2, y2, z) {
  const mapUrl = generateMapUrl({ level, x: x2, y: y2, z });
  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
}
function generateMapUrl(items) {
  const mapUrl = {};
  for (const key in items) {
    mapUrl[`{${key}}`] = items[key];
  }
  return mapUrl;
}
function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
  const byteIndex = Math.floor(availabilityIndex / 8);
  const bitIndex = availabilityIndex % 8;
  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
  return bitValue === 1;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-header.js
function getTileType(tile, tileContentUrl = "") {
  if (!tileContentUrl) {
    return TILE_TYPE.EMPTY;
  }
  const contentUrl = tileContentUrl.split("?")[0];
  const fileExtension = contentUrl.split(".").pop();
  switch (fileExtension) {
    case "pnts":
      return TILE_TYPE.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return TILE_TYPE.SCENEGRAPH;
    default:
      return fileExtension || TILE_TYPE.EMPTY;
  }
}
function getRefine(refine) {
  switch (refine) {
    case "REPLACE":
    case "replace":
      return TILE_REFINEMENT.REPLACE;
    case "ADD":
    case "add":
      return TILE_REFINEMENT.ADD;
    default:
      return refine;
  }
}
function resolveUri(uri, basePath) {
  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
  if (urlSchemeRegex.test(basePath)) {
    const url = new URL(uri, `${basePath}/`);
    return decodeURI(url.toString());
  } else if (uri.startsWith("/")) {
    return uri;
  }
  return path_exports.resolve(basePath, uri);
}
function normalizeTileData(tile, basePath) {
  var _a;
  if (!tile) {
    return null;
  }
  let tileContentUrl;
  if (tile.content) {
    const contentUri = tile.content.uri || ((_a = tile.content) == null ? void 0 : _a.url);
    if (typeof contentUri !== "undefined") {
      tileContentUrl = resolveUri(contentUri, basePath);
    }
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine)
  };
  return tilePostprocessed;
}
async function normalizeTileHeaders(tileset, basePath, options) {
  let root = null;
  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);
  if (rootImplicitTilingExtension && tileset.root) {
    root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);
  } else {
    root = normalizeTileData(tileset.root, basePath);
  }
  const stack2 = [];
  stack2.push(root);
  while (stack2.length > 0) {
    const tile = stack2.pop() || {};
    const children = tile.children || [];
    const childrenPostprocessed = [];
    for (const childHeader of children) {
      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
      let childHeaderPostprocessed;
      if (childImplicitTilingExtension) {
        childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);
      } else {
        childHeaderPostprocessed = normalizeTileData(childHeader, basePath);
      }
      if (childHeaderPostprocessed) {
        childrenPostprocessed.push(childHeaderPostprocessed);
        stack2.push(childHeaderPostprocessed);
      }
    }
    tile.children = childrenPostprocessed;
  }
  return root;
}
async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {
  var _a, _b, _c;
  const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;
  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
  const tileContentUri = (_a = tile.content) == null ? void 0 : _a.uri;
  const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : "";
  const refine = (_b = tileset == null ? void 0 : tileset.root) == null ? void 0 : _b.refine;
  const rootLodMetricValue = tile.geometricError;
  const s2VolumeInfo = (_c = tile.boundingVolume.extensions) == null ? void 0 : _c["3DTILES_bounding_volume_S2"];
  if (s2VolumeInfo) {
    const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
    const s2VolumeBox = { box, s2VolumeInfo };
    tile.boundingVolume = s2VolumeBox;
  }
  const rootBoundingVolume = tile.boundingVolume;
  const implicitOptions = {
    contentUrlTemplate,
    subtreesUriTemplate,
    subdivisionScheme,
    subtreeLevels,
    maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,
    refine,
    basePath,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    rootLodMetricValue,
    rootBoundingVolume,
    getTileType,
    getRefine
  };
  return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);
}
async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {
  if (!tile) {
    return null;
  }
  const { children, contentUrl } = await parseImplicitTiles({
    subtree: rootSubtree,
    implicitOptions,
    loaderOptions
  });
  let tileContentUrl;
  let tileContent = null;
  if (contentUrl) {
    tileContentUrl = contentUrl;
    tileContent = { uri: contentUrl.replace(`${basePath}/`, "") };
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine),
    content: tileContent || tile.content,
    children
  };
  return tilePostprocessed;
}
function getImplicitTilingExtensionData(tile) {
  var _a;
  return ((_a = tile == null ? void 0 : tile.extensions) == null ? void 0 : _a["3DTILES_implicit_tiling"]) || (tile == null ? void 0 : tile.implicitTiling);
}

// node_modules/@loaders.gl/3d-tiles/dist/tiles-3d-loader.js
var Tiles3DLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: VERSION7,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: parse3,
  options: {
    "3d-tiles": {
      loadGLTF: true,
      decodeQuantizedPositions: false,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function parse3(data, options = {}, context) {
  const loaderOptions = options["3d-tiles"] || {};
  let isTileset;
  if (loaderOptions.isTileset === "auto") {
    isTileset = (context == null ? void 0 : context.url) && context.url.indexOf(".json") !== -1;
  } else {
    isTileset = loaderOptions.isTileset;
  }
  return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);
}
async function parseTileset(data, options, context) {
  var _a;
  const tilesetJson = JSON.parse(new TextDecoder().decode(data));
  const tilesetUrl = (context == null ? void 0 : context.url) || "";
  const basePath = getBaseUri(tilesetUrl);
  const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});
  const tilesetJsonPostprocessed = {
    ...tilesetJson,
    shape: "tileset3d",
    loader: Tiles3DLoader,
    url: tilesetUrl,
    queryString: (context == null ? void 0 : context.queryString) || "",
    basePath,
    root: normalizedRoot || tilesetJson.root,
    type: TILESET_TYPE.TILES3D,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: ((_a = tilesetJson.root) == null ? void 0 : _a.geometricError) || 0
  };
  return tilesetJsonPostprocessed;
}
async function parseTile(arrayBuffer, options, context) {
  const tile = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  const byteOffset = 0;
  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);
  return tile.content;
}
function getBaseUri(tilesetUrl) {
  return path_exports.dirname(tilesetUrl);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/ion/ion.js
var CESIUM_ION_URL = "https://api.cesium.com/v1/assets";
async function getIonTilesetMetadata(accessToken, assetId) {
  if (!assetId) {
    const assets = await getIonAssets(accessToken);
    for (const item of assets.items) {
      if (item.type === "3DTILES") {
        assetId = item.id;
      }
    }
  }
  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);
  const { type, url } = ionAssetMetadata;
  assert2(type === "3DTILES" && url);
  ionAssetMetadata.headers = {
    Authorization: `Bearer ${ionAssetMetadata.accessToken}`
  };
  return ionAssetMetadata;
}
async function getIonAssets(accessToken) {
  assert2(accessToken);
  const url = CESIUM_ION_URL;
  const headers = { Authorization: `Bearer ${accessToken}` };
  const response = await fetchFile(url, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  return await response.json();
}
async function getIonAssetMetadata(accessToken, assetId) {
  assert2(accessToken, assetId);
  const headers = { Authorization: `Bearer ${accessToken}` };
  const url = `${CESIUM_ION_URL}/${assetId}`;
  let response = await fetchFile(`${url}`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let metadata = await response.json();
  response = await fetchFile(`${url}/endpoint`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  const tilesetInfo = await response.json();
  metadata = {
    ...metadata,
    ...tilesetInfo
  };
  return metadata;
}

// node_modules/@loaders.gl/3d-tiles/dist/cesium-ion-loader.js
async function preload(url, options = {}) {
  options = options["cesium-ion"] || {};
  const { accessToken } = options;
  let assetId = options.assetId;
  if (!Number.isFinite(assetId)) {
    const matched = url.match(/\/([0-9]+)\/tileset.json/);
    assetId = matched && matched[1];
  }
  return getIonTilesetMetadata(accessToken, assetId);
}
var CesiumIonLoader = {
  ...Tiles3DLoader,
  id: "cesium-ion",
  name: "Cesium Ion",
  // @ts-ignore
  preload,
  parse: async (data, options, context) => {
    options = { ...options };
    options["3d-tiles"] = options["cesium-ion"];
    options.loader = CesiumIonLoader;
    return Tiles3DLoader.parse(data, options, context);
  },
  options: {
    "cesium-ion": {
      ...Tiles3DLoader.options["3d-tiles"],
      accessToken: null
    }
  }
};

// node_modules/@loaders.gl/zip/dist/zip-loader.js
var import_jszip = __toESM(require_jszip_min(), 1);

// node_modules/@loaders.gl/zip/dist/zip-writer.js
var import_jszip2 = __toESM(require_jszip_min(), 1);

// node_modules/@loaders.gl/zip/dist/parse-zip/zip64-info-generation.js
var signature = new Uint8Array([1, 0]);
var ZIP64_FIELDS = [
  // Header ID 0x0001
  {
    size: 2,
    default: new DataView(signature.buffer).getUint16(0, true)
  },
  // Size of the extra field chunk (8, 16, 24 or 28)
  {
    size: 2,
    name: "zip64Length"
  },
  // Original uncompressed file size
  {
    size: 8,
    name: "size"
  },
  // Size of compressed data
  {
    size: 8,
    name: "size"
  },
  // Offset of local header record
  {
    size: 8,
    name: "offset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/end-of-central-directory.js
var eoCDSignature = new Uint8Array([80, 75, 5, 6]);
var zip64EoCDLocatorSignature = new Uint8Array([80, 75, 6, 7]);
var zip64EoCDSignature = new Uint8Array([80, 75, 6, 6]);
var EOCD_FIELDS = [
  // End of central directory signature = 0x06054b50
  {
    offset: 0,
    size: 4,
    default: new DataView(eoCDSignature.buffer).getUint32(0, true)
  },
  // Number of this disk (or 0xffff for ZIP64)
  {
    offset: 4,
    size: 2,
    default: 0
  },
  // Disk where central directory starts (or 0xffff for ZIP64)
  {
    offset: 6,
    size: 2,
    default: 0
  },
  // Number of central directory records on this disk (or 0xffff for ZIP64)
  {
    offset: 8,
    size: 2,
    name: "recordsNumber"
  },
  // Total number of central directory records (or 0xffff for ZIP64)
  {
    offset: 10,
    size: 2,
    name: "recordsNumber"
  },
  // Size of central directory (bytes) (or 0xffffffff for ZIP64)
  {
    offset: 12,
    size: 4,
    name: "cdSize"
  },
  // Offset of start of central directory, relative to start of archive (or 0xffffffff for ZIP64)
  {
    offset: 16,
    size: 4,
    name: "cdOffset"
  },
  // Comment length (n)
  {
    offset: 20,
    size: 2,
    default: 0
  }
];
var ZIP64_EOCD_LOCATOR_FIELDS = [
  // zip64 end of central dir locator signature
  {
    offset: 0,
    size: 4,
    default: new DataView(zip64EoCDLocatorSignature.buffer).getUint32(0, true)
  },
  // number of the disk with the start of the zip64 end of
  {
    offset: 4,
    size: 4,
    default: 0
  },
  // start of the zip64 end of central directory
  {
    offset: 8,
    size: 8,
    name: "eoCDStart"
  },
  // total number of disks
  {
    offset: 16,
    size: 4,
    default: 1
  }
];
var ZIP64_EOCD_FIELDS = [
  // End of central directory signature = 0x06064b50
  {
    offset: 0,
    size: 4,
    default: new DataView(zip64EoCDSignature.buffer).getUint32(0, true)
  },
  // Size of the EOCD64 minus 12
  {
    offset: 4,
    size: 8,
    default: 44
  },
  // Version made by
  {
    offset: 12,
    size: 2,
    default: 45
  },
  // Version needed to extract (minimum)
  {
    offset: 14,
    size: 2,
    default: 45
  },
  // Number of this disk
  {
    offset: 16,
    size: 4,
    default: 0
  },
  // Disk where central directory starts
  {
    offset: 20,
    size: 4,
    default: 0
  },
  // Number of central directory records on this disk
  {
    offset: 24,
    size: 8,
    name: "recordsNumber"
  },
  // Total number of central directory records
  {
    offset: 32,
    size: 8,
    name: "recordsNumber"
  },
  // Size of central directory (bytes)
  {
    offset: 40,
    size: 8,
    name: "cdSize"
  },
  // Offset of start of central directory, relative to start of archive
  {
    offset: 48,
    size: 8,
    name: "cdOffset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/cd-file-header.js
var signature2 = new Uint8Array([80, 75, 1, 2]);
var ZIP_HEADER_FIELDS = [
  // Central directory file header signature = 0x02014b50
  {
    offset: 0,
    size: 4,
    default: new DataView(signature2.buffer).getUint32(0, true)
  },
  // Version made by
  {
    offset: 4,
    size: 2,
    default: 45
  },
  // Version needed to extract (minimum)
  {
    offset: 6,
    size: 2,
    default: 45
  },
  // General purpose bit flag
  {
    offset: 8,
    size: 2,
    default: 0
  },
  // Compression method
  {
    offset: 10,
    size: 2,
    default: 0
  },
  // File last modification time
  {
    offset: 12,
    size: 2,
    default: 0
  },
  // File last modification date
  {
    offset: 14,
    size: 2,
    default: 0
  },
  // CRC-32 of uncompressed data
  {
    offset: 16,
    size: 4,
    name: "crc32"
  },
  // Compressed size (or 0xffffffff for ZIP64)
  {
    offset: 20,
    size: 4,
    name: "length"
  },
  // Uncompressed size (or 0xffffffff for ZIP64)
  {
    offset: 24,
    size: 4,
    name: "length"
  },
  // File name length (n)
  {
    offset: 28,
    size: 2,
    name: "fnlength"
  },
  // Extra field length (m)
  {
    offset: 30,
    size: 2,
    default: 0,
    name: "extraLength"
  },
  // File comment length (k)
  {
    offset: 32,
    size: 2,
    default: 0
  },
  // Disk number where file starts (or 0xffff for ZIP64)
  {
    offset: 34,
    size: 2,
    default: 0
  },
  // Internal file attributes
  {
    offset: 36,
    size: 2,
    default: 0
  },
  // External file attributes
  {
    offset: 38,
    size: 4,
    default: 0
  },
  // Relative offset of local file header
  {
    offset: 42,
    size: 4,
    name: "offset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/local-file-header.js
var signature3 = new Uint8Array([80, 75, 3, 4]);
var ZIP_HEADER_FIELDS2 = [
  // Local file header signature = 0x04034b50
  {
    offset: 0,
    size: 4,
    default: new DataView(signature3.buffer).getUint32(0, true)
  },
  // Version needed to extract (minimum)
  {
    offset: 4,
    size: 2,
    default: 45
  },
  // General purpose bit flag
  {
    offset: 6,
    size: 2,
    default: 0
  },
  // Compression method
  {
    offset: 8,
    size: 2,
    default: 0
  },
  // File last modification time
  {
    offset: 10,
    size: 2,
    default: 0
  },
  // File last modification date
  {
    offset: 12,
    size: 2,
    default: 0
  },
  // CRC-32 of uncompressed data
  {
    offset: 14,
    size: 4,
    name: "crc32"
  },
  // Compressed size (or 0xffffffff for ZIP64)
  {
    offset: 18,
    size: 4,
    name: "length"
  },
  // Uncompressed size (or 0xffffffff for ZIP64)
  {
    offset: 22,
    size: 4,
    name: "length"
  },
  // File name length (n)
  {
    offset: 26,
    size: 2,
    name: "fnlength"
  },
  // Extra field length (m)
  {
    offset: 28,
    size: 2,
    default: 0,
    name: "extraLength"
  }
];

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/crc32.js
var CRC32TAB = Uint32Array.of(0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117);

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/crc32c.js
var CRC32C_TABLE = Int32Array.of(0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872, 3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744, 3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192, 51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488, 1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768, 1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393, 357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846, 3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905, 3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761, 3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161, 2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843, 1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459, 969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427, 526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692, 1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379, 3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810, 2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378, 3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522, 3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938, 1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322, 153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002, 797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927, 3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976, 461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119, 1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871, 1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383, 763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017, 2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673, 3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049, 4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758, 2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545, 731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620, 837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500, 390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756, 2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364, 3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044, 2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292, 2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029, 3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738, 2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981, 17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933, 665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285, 1279665062, 1595330642, 2910671697);

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/md5-wasm.js
var atb = typeof atob === "function" ? atob : typeof Buffer === "function" ? nodeATOB : identity2;
var wasmB64 = atb("AGFzbQEAAAABDANgAX8AYAAAYAABfwIeAgdpbXBvcnRzA2xvZwAAB2ltcG9ydHMDbWVtAgABAzIxAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAgICAgIAAAAAAAaYARt/AUGBxpS6Bgt/AUGJ17b+fgt/AUH+uevFeQt/AUH2qMmBAQt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALB7oCJQhvbmVGdWxsQQAYCG9uZUZ1bGxCABkIb25lRnVsbEMAGghvbmVGdWxsRAAbBWxvb3BzAAEEbG9vcAACBXByaW1lAAMFbG9vcEEABAZsb29wQTEABQZsb29wQTIABgZsb29wQTMABwZsb29wQTQACAVsb29wQgAJBmxvb3BCMQAKBmxvb3BCMgALBmxvb3BCMwAMBmxvb3BCNAANBWxvb3BDAA4GbG9vcEMxAA8GbG9vcEMyABAGbG9vcEMzABEGbG9vcEM0ABIFbG9vcEQAEwZsb29wRDEAFAZsb29wRDIAFQZsb29wRDMAFgZsb29wRDQAFwRnZXRBACgEZ2V0QgApBGdldEMAKgRnZXREACsEZ2V0WAAsBHNldEEALQRzZXRCAC4Ec2V0QwAvBHNldEQAMARzZXRYADEKzA0xWwEBf0EAJAggAEEGdCEBAkADQCMIIAFGDQEjACQEIwEkBSMCJAYjAyQHEAIjBCMAaiQAIwUjAWokASMGIwJqJAIjByMDaiQDIwhBwABqJAgMAAsLIwgjGmokGgsTACMIIxpqJAkQAxAEEAkQDhATC6IBAEEAIwlqKAIAJApBBCMJaigCACQLQQgjCWooAgAkDEEMIwlqKAIAJA1BECMJaigCACQOQRQjCWooAgAkD0EYIwlqKAIAJBBBHCMJaigCACQRQSAjCWooAgAkEkEkIwlqKAIAJBNBKCMJaigCACQUQSwjCWooAgAkFUEwIwlqKAIAJBZBNCMJaigCACQXQTgjCWooAgAkGEE8IwlqKAIAJBkLCgAQBRAGEAcQCAsuAEH4yKq7fSMKahAYQdbunsZ+IwtqEBtB2+GBoQIjDGoQGkHunfeNfCMNahAZCy0AQa+f8Kt/Iw5qEBhBqoyfvAQjD2oQG0GTjMHBeiMQahAaQYGqmmojEWoQGQssAEHYsYLMBiMSahAYQa/vk9p4IxNqEBtBsbd9IxRqEBpBvq/zyngjFWoQGQstAEGiosDcBiMWahAYQZPj4WwjF2oQG0GOh+WzeiMYahAaQaGQ0M0EIxlqEBkLCgAQChALEAwQDQsuAEHiyviwfyMLahAcQcDmgoJ8IxBqEB9B0bT5sgIjFWoQHkGqj9vNfiMKahAdCy0AQd2gvLF9Iw9qEBxB06iQEiMUahAfQYHNh8V9IxlqEB5ByPfPvn4jDmoQHQsuAEHmm4ePAiMTahAcQdaP3Jl8IxhqEB9Bh5vUpn8jDWoQHkHtqeiqBCMSahAdCy0AQYXSj896IxdqEBxB+Me+ZyMMahAfQdmFvLsGIxFqEB5Bipmp6XgjFmoQHQsKABAPEBAQERASCysAQcLyaCMPahAgQYHtx7t4IxJqECNBosL17AYjFWoQIkGM8JRvIxhqECELLgBBxNT7pXojC2oQIEGpn/veBCMOahAjQeCW7bV/IxFqECJB8Pj+9XsjFGoQIQstAEHG/e3EAiMXahAgQfrPhNV+IwpqECNBheG8p30jDWoQIkGFuqAkIxBqECELLgBBuaDTzn0jE2oQIEHls+62fiMWahAjQfj5if0BIxlqECJB5ayxpXwjDGoQIQsKABAUEBUQFhAXCy0AQcTEpKF/IwpqECRBl/+rmQQjEWoQJ0Gnx9DceiMYahAmQbnAzmQjD2oQJQstAEHDs+2qBiMWahAkQZKZs/h4Iw1qECdB/ei/fyMUahAmQdG7kax4IwtqECULLQBBz/yh/QYjEmoQJEHgzbNxIxlqECdBlIaFmHojEGoQJkGho6DwBCMXahAlCy4AQYL9zbp/Iw5qECRBteTr6XsjFWoQJ0G7pd/WAiMMahAmQZGnm9x+IxNqECULKAEBf0F/IwFzIwNxIwEjAnFyIwBqIABqIgFBB3QgAUEZdnIjAWokAAsoAQF/QX8jAnMjAHEjAiMDcXIjAWogAGoiAUEWdCABQQp2ciMCaiQBCygBAX9BfyMDcyMBcSMDIwBxciMCaiAAaiIBQRF0IAFBD3ZyIwNqJAILKAEBf0F/IwBzIwJxIwAjAXFyIwNqIABqIgFBDHQgAUEUdnIjAGokAwsoAQF/IwJBfyMDc3EjASMDcXIjAGogAGoiAUEFdCABQRt2ciMBaiQACygBAX8jA0F/IwBzcSMCIwBxciMBaiAAaiIBQRR0IAFBDHZyIwJqJAELKAEBfyMAQX8jAXNxIwMjAXFyIwJqIABqIgFBDnQgAUESdnIjA2okAgsoAQF/IwFBfyMCc3EjACMCcXIjA2ogAGoiAUEJdCABQRd2ciMAaiQDCyIBAX8jASMCcyMDcyMAaiAAaiIBQQR0IAFBHHZyIwFqJAALIgEBfyMCIwNzIwBzIwFqIABqIgFBF3QgAUEJdnIjAmokAQsiAQF/IwMjAHMjAXMjAmogAGoiAUEQdCABQRB2ciMDaiQCCyIBAX8jACMBcyMCcyMDaiAAaiIBQQt0IAFBFXZyIwBqJAMLJQEBf0F/IwNzIwFyIwJzIwBqIABqIgFBBnQgAUEadnIjAWokAAslAQF/QX8jAHMjAnIjA3MjAWogAGoiAUEVdCABQQt2ciMCaiQBCyUBAX9BfyMBcyMDciMAcyMCaiAAaiIBQQ90IAFBEXZyIwNqJAILJQEBf0F/IwJzIwByIwFzIwNqIABqIgFBCnQgAUEWdnIjAGokAwsEACMACwQAIwELBAAjAgsEACMDCwQAIxoLBgAgACQACwYAIAAkAQsGACAAJAILBgAgACQDCwYAIAAkGgsA6gQEbmFtZQGSAzIAA2xvZwEFbG9vcHMCBGxvb3ADBXByaW1lBAVsb29wQQUGbG9vcEExBgZsb29wQTIHBmxvb3BBMwgGbG9vcEE0CQVsb29wQgoGbG9vcEIxCwZsb29wQjIMBmxvb3BCMw0GbG9vcEI0DgVsb29wQw8GbG9vcEMxEAZsb29wQzIRBmxvb3BDMxIGbG9vcEM0EwVsb29wRBQGbG9vcEQxFQZsb29wRDIWBmxvb3BEMxcGbG9vcEQ0GAhvbmVGdWxsQRkIb25lRnVsbEIaCG9uZUZ1bGxDGwhvbmVGdWxsRBwIdHdvRnVsbEEdCHR3b0Z1bGxCHgh0d29GdWxsQx8IdHdvRnVsbEQgCHRyZUZ1bGxBIQh0cmVGdWxsQiIIdHJlRnVsbEMjCHRyZUZ1bGxEJAhxdWFGdWxsQSUIcXVhRnVsbEImCHF1YUZ1bGxDJwhxdWFGdWxsRCgEZ2V0QSkEZ2V0QioEZ2V0QysEZ2V0RCwEZ2V0WC0Ec2V0QS4Ec2V0Qi8Ec2V0QzAEc2V0RDEEc2V0WALNATIAAQAAAQIAAAEIbnVtbG9vcHMCAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgCAAABAW4ZAgAAAQFuGgIAAAEBbhsCAAABAW4cAgAAAQFuHQIAAAEBbh4CAAABAW4fAgAAAQFuIAIAAAEBbiECAAABAW4iAgAAAQFuIwIAAAEBbiQCAAABAW4lAgAAAQFuJgIAAAEBbicCAAABAW4oACkAKgArACwALQEAAC4BAAAvAQAAMAEAADEBAAA=");
var wasm2 = WebAssembly && atb !== identity2 ? str2AB(wasmB64).buffer : false;
var crypt = makeCrypt();
var biteSize = 240 * 16 * 16;
var bounder = Math.floor(biteSize * 16 * 1.066666667);
var upperLimit = 268435456 - 65536;
if (!wasm2) {
  console.log("WebAssembly not available or WASM module could not be decoded; md5WASM will fall back to JavaScript");
}
function str2AB(str) {
  var l2, buff, buffView, i3 = -1;
  l2 = str.length - 1;
  buff = new ArrayBuffer(str.length);
  buffView = new Uint8Array(buff);
  while (l2 > i3++) {
    buffView[i3] = str.charCodeAt(i3);
  }
  return buffView;
}
function nodeATOB(str) {
  return Buffer.from(str, "base64").toString("binary");
}
function identity2(x2) {
  return x2;
}
function makeCrypt() {
  var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  return {
    rotl: function(n2, b2) {
      return n2 << b2 | n2 >>> 32 - b2;
    },
    endian: function(n2) {
      if (n2.constructor == Number) {
        return crypt.rotl(n2, 8) & 16711935 | crypt.rotl(n2, 24) & 4278255360;
      }
      for (var i3 = 0; i3 < n2.length; i3++)
        n2[i3] = crypt.endian(n2[i3]);
      return n2;
    },
    bytesToWords: function(bytes) {
      for (var words = [], i3 = 0, b2 = 0; i3 < bytes.length; i3++, b2 += 8)
        words[b2 >>> 5] |= bytes[i3] << 24 - b2 % 32;
      return words;
    },
    wordsToBytes: function(words) {
      for (var bytes = [], b2 = 0; b2 < words.length * 32; b2 += 8)
        bytes.push(words[b2 >>> 5] >>> 24 - b2 % 32 & 255);
      return bytes;
    },
    bytesconvertNumberToHex: function(bytes) {
      for (var hex = [], i3 = 0; i3 < bytes.length; i3++) {
        hex.push((bytes[i3] >>> 4).toString(16));
        hex.push((bytes[i3] & 15).toString(16));
      }
      return hex.join("");
    }
  };
}

// node_modules/@loaders.gl/compression/dist/lib/deflate-compression.js
var import_pako = __toESM(require_pako(), 1);
var import_zlib = __toESM(require_zlib(), 1);

// node_modules/@loaders.gl/compression/dist/brotli/decode.js
var makeBrotliDecode = () => {
  function InputStream(bytes) {
    this.data = bytes;
    this.offset = 0;
  }
  let MAX_HUFFMAN_TABLE_SIZE = Int32Array.from([
    256,
    402,
    436,
    468,
    500,
    534,
    566,
    598,
    630,
    662,
    694,
    726,
    758,
    790,
    822,
    854,
    886,
    920,
    952,
    984,
    1016,
    1048,
    1080
  ]);
  let CODE_LENGTH_CODE_ORDER = Int32Array.from([
    1,
    2,
    3,
    4,
    0,
    5,
    17,
    6,
    16,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15
  ]);
  let DISTANCE_SHORT_CODE_INDEX_OFFSET = Int32Array.from([
    0,
    3,
    2,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    3,
    3,
    3,
    3,
    3
  ]);
  let DISTANCE_SHORT_CODE_VALUE_OFFSET = Int32Array.from([
    0,
    0,
    0,
    0,
    -1,
    1,
    -2,
    2,
    -3,
    3,
    -1,
    1,
    -2,
    2,
    -3,
    3
  ]);
  let FIXED_TABLE = Int32Array.from([
    131072,
    131076,
    131075,
    196610,
    131072,
    131076,
    131075,
    262145,
    131072,
    131076,
    131075,
    196610,
    131072,
    131076,
    131075,
    262149
  ]);
  let BLOCK_LENGTH_OFFSET = Int32Array.from([
    1,
    5,
    9,
    13,
    17,
    25,
    33,
    41,
    49,
    65,
    81,
    97,
    113,
    145,
    177,
    209,
    241,
    305,
    369,
    497,
    753,
    1265,
    2289,
    4337,
    8433,
    16625
  ]);
  let BLOCK_LENGTH_N_BITS = Int32Array.from([
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    6,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    24
  ]);
  let INSERT_LENGTH_N_BITS = Int16Array.from([
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    7,
    8,
    9,
    10,
    12,
    14,
    24
  ]);
  let COPY_LENGTH_N_BITS = Int16Array.from([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    7,
    8,
    9,
    10,
    24
  ]);
  let CMD_LOOKUP = new Int16Array(2816);
  {
    unpackCommandLookupTable(CMD_LOOKUP);
  }
  function log2floor(i3) {
    let result = -1;
    let step = 16;
    while (step > 0) {
      if (i3 >>> step != 0) {
        result += step;
        i3 = i3 >>> step;
      }
      step = step >> 1;
    }
    return result + i3;
  }
  function calculateDistanceAlphabetSize(npostfix, ndirect, maxndistbits) {
    return 16 + ndirect + 2 * (maxndistbits << npostfix);
  }
  function calculateDistanceAlphabetLimit(maxDistance, npostfix, ndirect) {
    if (maxDistance < ndirect + (2 << npostfix)) {
      throw "maxDistance is too small";
    }
    let offset = (maxDistance - ndirect >> npostfix) + 4;
    let ndistbits = log2floor(offset) - 1;
    let group = ndistbits - 1 << 1 | offset >> ndistbits & 1;
    return (group - 1 << npostfix) + (1 << npostfix) + ndirect + 16;
  }
  function unpackCommandLookupTable(cmdLookup) {
    let insertLengthOffsets = new Int16Array(24);
    let copyLengthOffsets = new Int16Array(24);
    copyLengthOffsets[0] = 2;
    for (let i3 = 0; i3 < 23; ++i3) {
      insertLengthOffsets[i3 + 1] = insertLengthOffsets[i3] + (1 << INSERT_LENGTH_N_BITS[i3]);
      copyLengthOffsets[i3 + 1] = copyLengthOffsets[i3] + (1 << COPY_LENGTH_N_BITS[i3]);
    }
    for (let cmdCode = 0; cmdCode < 704; ++cmdCode) {
      let rangeIdx = cmdCode >>> 6;
      let distanceContextOffset = -4;
      if (rangeIdx >= 2) {
        rangeIdx -= 2;
        distanceContextOffset = 0;
      }
      let insertCode = (170064 >>> rangeIdx * 2 & 3) << 3 | cmdCode >>> 3 & 7;
      let copyCode = (156228 >>> rangeIdx * 2 & 3) << 3 | cmdCode & 7;
      let copyLengthOffset = copyLengthOffsets[copyCode];
      let distanceContext = distanceContextOffset + (copyLengthOffset > 4 ? 3 : copyLengthOffset - 2);
      let index = cmdCode * 4;
      cmdLookup[index + 0] = INSERT_LENGTH_N_BITS[insertCode] | COPY_LENGTH_N_BITS[copyCode] << 8;
      cmdLookup[index + 1] = insertLengthOffsets[insertCode];
      cmdLookup[index + 2] = copyLengthOffsets[copyCode];
      cmdLookup[index + 3] = distanceContext;
    }
  }
  function decodeWindowBits(s2) {
    let largeWindowEnabled = s2.isLargeWindow;
    s2.isLargeWindow = 0;
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    if (readFewBits(s2, 1) == 0) {
      return 16;
    }
    let n2 = readFewBits(s2, 3);
    if (n2 != 0) {
      return 17 + n2;
    }
    n2 = readFewBits(s2, 3);
    if (n2 != 0) {
      if (n2 == 1) {
        if (largeWindowEnabled == 0) {
          return -1;
        }
        s2.isLargeWindow = 1;
        if (readFewBits(s2, 1) == 1) {
          return -1;
        }
        n2 = readFewBits(s2, 6);
        if (n2 < 10 || n2 > 30) {
          return -1;
        }
        return n2;
      } else {
        return 8 + n2;
      }
    }
    return 17;
  }
  function enableEagerOutput(s2) {
    if (s2.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    s2.isEager = 1;
  }
  function enableLargeWindow(s2) {
    if (s2.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    s2.isLargeWindow = 1;
  }
  function attachDictionaryChunk(s2, data2) {
    if (s2.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    if (s2.cdNumChunks == 0) {
      s2.cdChunks = new Array(16);
      s2.cdChunkOffsets = new Int32Array(16);
      s2.cdBlockBits = -1;
    }
    if (s2.cdNumChunks == 15) {
      throw "Too many dictionary chunks";
    }
    s2.cdChunks[s2.cdNumChunks] = data2;
    s2.cdNumChunks++;
    s2.cdTotalSize += data2.length;
    s2.cdChunkOffsets[s2.cdNumChunks] = s2.cdTotalSize;
  }
  function initState(s2, input) {
    if (s2.runningState != 0) {
      throw "State MUST be uninitialized";
    }
    s2.blockTrees = new Int32Array(3091);
    s2.blockTrees[0] = 7;
    s2.distRbIdx = 3;
    let maxDistanceAlphabetLimit = calculateDistanceAlphabetLimit(2147483644, 3, 15 << 3);
    s2.distExtraBits = new Int8Array(maxDistanceAlphabetLimit);
    s2.distOffset = new Int32Array(maxDistanceAlphabetLimit);
    s2.input = input;
    initBitReader(s2);
    s2.runningState = 1;
  }
  function close(s2) {
    if (s2.runningState == 0) {
      throw "State MUST be initialized";
    }
    if (s2.runningState == 11) {
      return;
    }
    s2.runningState = 11;
    if (s2.input != null) {
      closeInput(s2.input);
      s2.input = null;
    }
  }
  function decodeVarLenUnsignedByte(s2) {
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    if (readFewBits(s2, 1) != 0) {
      let n2 = readFewBits(s2, 3);
      if (n2 == 0) {
        return 1;
      } else {
        return readFewBits(s2, n2) + (1 << n2);
      }
    }
    return 0;
  }
  function decodeMetaBlockLength(s2) {
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    s2.inputEnd = readFewBits(s2, 1);
    s2.metaBlockLength = 0;
    s2.isUncompressed = 0;
    s2.isMetadata = 0;
    if (s2.inputEnd != 0 && readFewBits(s2, 1) != 0) {
      return;
    }
    let sizeNibbles = readFewBits(s2, 2) + 4;
    if (sizeNibbles == 7) {
      s2.isMetadata = 1;
      if (readFewBits(s2, 1) != 0) {
        throw "Corrupted reserved bit";
      }
      let sizeBytes = readFewBits(s2, 2);
      if (sizeBytes == 0) {
        return;
      }
      for (let i3 = 0; i3 < sizeBytes; i3++) {
        if (s2.bitOffset >= 16) {
          s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
          s2.bitOffset -= 16;
        }
        let bits = readFewBits(s2, 8);
        if (bits == 0 && i3 + 1 == sizeBytes && sizeBytes > 1) {
          throw "Exuberant nibble";
        }
        s2.metaBlockLength |= bits << i3 * 8;
      }
    } else {
      for (let i3 = 0; i3 < sizeNibbles; i3++) {
        if (s2.bitOffset >= 16) {
          s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
          s2.bitOffset -= 16;
        }
        let bits = readFewBits(s2, 4);
        if (bits == 0 && i3 + 1 == sizeNibbles && sizeNibbles > 4) {
          throw "Exuberant nibble";
        }
        s2.metaBlockLength |= bits << i3 * 4;
      }
    }
    s2.metaBlockLength++;
    if (s2.inputEnd == 0) {
      s2.isUncompressed = readFewBits(s2, 1);
    }
  }
  function readSymbol(tableGroup, tableIdx, s2) {
    let offset = tableGroup[tableIdx];
    let val2 = s2.accumulator32 >>> s2.bitOffset;
    offset += val2 & 255;
    let bits = tableGroup[offset] >> 16;
    let sym = tableGroup[offset] & 65535;
    if (bits <= 8) {
      s2.bitOffset += bits;
      return sym;
    }
    offset += sym;
    let mask = (1 << bits) - 1;
    offset += (val2 & mask) >>> 8;
    s2.bitOffset += (tableGroup[offset] >> 16) + 8;
    return tableGroup[offset] & 65535;
  }
  function readBlockLength(tableGroup, tableIdx, s2) {
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    let code = readSymbol(tableGroup, tableIdx, s2);
    let n2 = BLOCK_LENGTH_N_BITS[code];
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    return BLOCK_LENGTH_OFFSET[code] + (n2 <= 16 ? readFewBits(s2, n2) : readManyBits(s2, n2));
  }
  function moveToFront(v, index) {
    let value = v[index];
    for (; index > 0; index--) {
      v[index] = v[index - 1];
    }
    v[0] = value;
  }
  function inverseMoveToFrontTransform(v, vLen) {
    let mtf = new Int32Array(256);
    for (let i3 = 0; i3 < 256; i3++) {
      mtf[i3] = i3;
    }
    for (let i3 = 0; i3 < vLen; i3++) {
      let index = v[i3] & 255;
      v[i3] = mtf[index];
      if (index != 0) {
        moveToFront(mtf, index);
      }
    }
  }
  function readHuffmanCodeLengths(codeLengthCodeLengths, numSymbols, codeLengths, s2) {
    let symbol = 0;
    let prevCodeLen = 8;
    let repeat = 0;
    let repeatCodeLen = 0;
    let space = 32768;
    let table = new Int32Array(32 + 1);
    let tableIdx = table.length - 1;
    buildHuffmanTable(table, tableIdx, 5, codeLengthCodeLengths, 18);
    while (symbol < numSymbols && space > 0) {
      if (s2.halfOffset > 2030) {
        doReadMoreInput(s2);
      }
      if (s2.bitOffset >= 16) {
        s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
        s2.bitOffset -= 16;
      }
      let p2 = s2.accumulator32 >>> s2.bitOffset & 31;
      s2.bitOffset += table[p2] >> 16;
      let codeLen = table[p2] & 65535;
      if (codeLen < 16) {
        repeat = 0;
        codeLengths[symbol++] = codeLen;
        if (codeLen != 0) {
          prevCodeLen = codeLen;
          space -= 32768 >> codeLen;
        }
      } else {
        let extraBits = codeLen - 14;
        let newLen = 0;
        if (codeLen == 16) {
          newLen = prevCodeLen;
        }
        if (repeatCodeLen != newLen) {
          repeat = 0;
          repeatCodeLen = newLen;
        }
        let oldRepeat = repeat;
        if (repeat > 0) {
          repeat -= 2;
          repeat <<= extraBits;
        }
        if (s2.bitOffset >= 16) {
          s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
          s2.bitOffset -= 16;
        }
        repeat += readFewBits(s2, extraBits) + 3;
        let repeatDelta = repeat - oldRepeat;
        if (symbol + repeatDelta > numSymbols) {
          throw "symbol + repeatDelta > numSymbols";
        }
        for (let i3 = 0; i3 < repeatDelta; i3++) {
          codeLengths[symbol++] = repeatCodeLen;
        }
        if (repeatCodeLen != 0) {
          space -= repeatDelta << 15 - repeatCodeLen;
        }
      }
    }
    if (space != 0) {
      throw "Unused space";
    }
    codeLengths.fill(0, symbol, numSymbols);
  }
  function checkDupes(symbols, length2) {
    for (let i3 = 0; i3 < length2 - 1; ++i3) {
      for (let j = i3 + 1; j < length2; ++j) {
        if (symbols[i3] == symbols[j]) {
          throw "Duplicate simple Huffman code symbol";
        }
      }
    }
  }
  function readSimpleHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s2) {
    let codeLengths = new Int32Array(alphabetSizeLimit);
    let symbols = new Int32Array(4);
    let maxBits = 1 + log2floor(alphabetSizeMax - 1);
    let numSymbols = readFewBits(s2, 2) + 1;
    for (let i3 = 0; i3 < numSymbols; i3++) {
      if (s2.bitOffset >= 16) {
        s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
        s2.bitOffset -= 16;
      }
      let symbol = readFewBits(s2, maxBits);
      if (symbol >= alphabetSizeLimit) {
        throw "Can't readHuffmanCode";
      }
      symbols[i3] = symbol;
    }
    checkDupes(symbols, numSymbols);
    let histogramId = numSymbols;
    if (numSymbols == 4) {
      histogramId += readFewBits(s2, 1);
    }
    switch (histogramId) {
      case 1:
        codeLengths[symbols[0]] = 1;
        break;
      case 2:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 1;
        break;
      case 3:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 2;
        break;
      case 4:
        codeLengths[symbols[0]] = 2;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 2;
        codeLengths[symbols[3]] = 2;
        break;
      case 5:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 3;
        codeLengths[symbols[3]] = 3;
        break;
      default:
        break;
    }
    return buildHuffmanTable(tableGroup, tableIdx, 8, codeLengths, alphabetSizeLimit);
  }
  function readComplexHuffmanCode(alphabetSizeLimit, skip, tableGroup, tableIdx, s2) {
    let codeLengths = new Int32Array(alphabetSizeLimit);
    let codeLengthCodeLengths = new Int32Array(18);
    let space = 32;
    let numCodes = 0;
    for (let i3 = skip; i3 < 18 && space > 0; i3++) {
      let codeLenIdx = CODE_LENGTH_CODE_ORDER[i3];
      if (s2.bitOffset >= 16) {
        s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
        s2.bitOffset -= 16;
      }
      let p2 = s2.accumulator32 >>> s2.bitOffset & 15;
      s2.bitOffset += FIXED_TABLE[p2] >> 16;
      let v = FIXED_TABLE[p2] & 65535;
      codeLengthCodeLengths[codeLenIdx] = v;
      if (v != 0) {
        space -= 32 >> v;
        numCodes++;
      }
    }
    if (space != 0 && numCodes != 1) {
      throw "Corrupted Huffman code histogram";
    }
    readHuffmanCodeLengths(codeLengthCodeLengths, alphabetSizeLimit, codeLengths, s2);
    return buildHuffmanTable(tableGroup, tableIdx, 8, codeLengths, alphabetSizeLimit);
  }
  function readHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s2) {
    if (s2.halfOffset > 2030) {
      doReadMoreInput(s2);
    }
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    let simpleCodeOrSkip = readFewBits(s2, 2);
    if (simpleCodeOrSkip == 1) {
      return readSimpleHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s2);
    } else {
      return readComplexHuffmanCode(alphabetSizeLimit, simpleCodeOrSkip, tableGroup, tableIdx, s2);
    }
  }
  function decodeContextMap(contextMapSize, contextMap, s2) {
    if (s2.halfOffset > 2030) {
      doReadMoreInput(s2);
    }
    let numTrees = decodeVarLenUnsignedByte(s2) + 1;
    if (numTrees == 1) {
      contextMap.fill(0, 0, contextMapSize);
      return numTrees;
    }
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    let useRleForZeros = readFewBits(s2, 1);
    let maxRunLengthPrefix = 0;
    if (useRleForZeros != 0) {
      maxRunLengthPrefix = readFewBits(s2, 4) + 1;
    }
    let alphabetSize = numTrees + maxRunLengthPrefix;
    let tableSize = MAX_HUFFMAN_TABLE_SIZE[alphabetSize + 31 >> 5];
    let table = new Int32Array(tableSize + 1);
    let tableIdx = table.length - 1;
    readHuffmanCode(alphabetSize, alphabetSize, table, tableIdx, s2);
    for (let i3 = 0; i3 < contextMapSize; ) {
      if (s2.halfOffset > 2030) {
        doReadMoreInput(s2);
      }
      if (s2.bitOffset >= 16) {
        s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
        s2.bitOffset -= 16;
      }
      let code = readSymbol(table, tableIdx, s2);
      if (code == 0) {
        contextMap[i3] = 0;
        i3++;
      } else if (code <= maxRunLengthPrefix) {
        if (s2.bitOffset >= 16) {
          s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
          s2.bitOffset -= 16;
        }
        let reps = (1 << code) + readFewBits(s2, code);
        while (reps != 0) {
          if (i3 >= contextMapSize) {
            throw "Corrupted context map";
          }
          contextMap[i3] = 0;
          i3++;
          reps--;
        }
      } else {
        contextMap[i3] = code - maxRunLengthPrefix;
        i3++;
      }
    }
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    if (readFewBits(s2, 1) == 1) {
      inverseMoveToFrontTransform(contextMap, contextMapSize);
    }
    return numTrees;
  }
  function decodeBlockTypeAndLength(s2, treeType, numBlockTypes) {
    let ringBuffers = s2.rings;
    let offset = 4 + treeType * 2;
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    let blockType = readSymbol(s2.blockTrees, 2 * treeType, s2);
    let result = readBlockLength(s2.blockTrees, 2 * treeType + 1, s2);
    if (blockType == 1) {
      blockType = ringBuffers[offset + 1] + 1;
    } else if (blockType == 0) {
      blockType = ringBuffers[offset];
    } else {
      blockType -= 2;
    }
    if (blockType >= numBlockTypes) {
      blockType -= numBlockTypes;
    }
    ringBuffers[offset] = ringBuffers[offset + 1];
    ringBuffers[offset + 1] = blockType;
    return result;
  }
  function decodeLiteralBlockSwitch(s2) {
    s2.literalBlockLength = decodeBlockTypeAndLength(s2, 0, s2.numLiteralBlockTypes);
    let literalBlockType = s2.rings[5];
    s2.contextMapSlice = literalBlockType << 6;
    s2.literalTreeIdx = s2.contextMap[s2.contextMapSlice] & 255;
    let contextMode = s2.contextModes[literalBlockType];
    s2.contextLookupOffset1 = contextMode << 9;
    s2.contextLookupOffset2 = s2.contextLookupOffset1 + 256;
  }
  function decodeCommandBlockSwitch(s2) {
    s2.commandBlockLength = decodeBlockTypeAndLength(s2, 1, s2.numCommandBlockTypes);
    s2.commandTreeIdx = s2.rings[7];
  }
  function decodeDistanceBlockSwitch(s2) {
    s2.distanceBlockLength = decodeBlockTypeAndLength(s2, 2, s2.numDistanceBlockTypes);
    s2.distContextMapSlice = s2.rings[9] << 2;
  }
  function maybeReallocateRingBuffer(s2) {
    let newSize = s2.maxRingBufferSize;
    if (newSize > s2.expectedTotalSize) {
      let minimalNewSize = s2.expectedTotalSize;
      while (newSize >> 1 > minimalNewSize) {
        newSize >>= 1;
      }
      if (s2.inputEnd == 0 && newSize < 16384 && s2.maxRingBufferSize >= 16384) {
        newSize = 16384;
      }
    }
    if (newSize <= s2.ringBufferSize) {
      return;
    }
    let ringBufferSizeWithSlack = newSize + 37;
    let newBuffer = new Int8Array(ringBufferSizeWithSlack);
    if (s2.ringBuffer.length != 0) {
      newBuffer.set(s2.ringBuffer.subarray(0, 0 + s2.ringBufferSize), 0);
    }
    s2.ringBuffer = newBuffer;
    s2.ringBufferSize = newSize;
  }
  function readNextMetablockHeader(s2) {
    if (s2.inputEnd != 0) {
      s2.nextRunningState = 10;
      s2.runningState = 12;
      return;
    }
    s2.literalTreeGroup = new Int32Array(0);
    s2.commandTreeGroup = new Int32Array(0);
    s2.distanceTreeGroup = new Int32Array(0);
    if (s2.halfOffset > 2030) {
      doReadMoreInput(s2);
    }
    decodeMetaBlockLength(s2);
    if (s2.metaBlockLength == 0 && s2.isMetadata == 0) {
      return;
    }
    if (s2.isUncompressed != 0 || s2.isMetadata != 0) {
      jumpToByteBoundary(s2);
      s2.runningState = s2.isMetadata != 0 ? 5 : 6;
    } else {
      s2.runningState = 3;
    }
    if (s2.isMetadata != 0) {
      return;
    }
    s2.expectedTotalSize += s2.metaBlockLength;
    if (s2.expectedTotalSize > 1 << 30) {
      s2.expectedTotalSize = 1 << 30;
    }
    if (s2.ringBufferSize < s2.maxRingBufferSize) {
      maybeReallocateRingBuffer(s2);
    }
  }
  function readMetablockPartition(s2, treeType, numBlockTypes) {
    let offset = s2.blockTrees[2 * treeType];
    if (numBlockTypes <= 1) {
      s2.blockTrees[2 * treeType + 1] = offset;
      s2.blockTrees[2 * treeType + 2] = offset;
      return 1 << 28;
    }
    let blockTypeAlphabetSize = numBlockTypes + 2;
    offset += readHuffmanCode(blockTypeAlphabetSize, blockTypeAlphabetSize, s2.blockTrees, 2 * treeType, s2);
    s2.blockTrees[2 * treeType + 1] = offset;
    let blockLengthAlphabetSize = 26;
    offset += readHuffmanCode(blockLengthAlphabetSize, blockLengthAlphabetSize, s2.blockTrees, 2 * treeType + 1, s2);
    s2.blockTrees[2 * treeType + 2] = offset;
    return readBlockLength(s2.blockTrees, 2 * treeType + 1, s2);
  }
  function calculateDistanceLut(s2, alphabetSizeLimit) {
    let distExtraBits = s2.distExtraBits;
    let distOffset = s2.distOffset;
    let npostfix = s2.distancePostfixBits;
    let ndirect = s2.numDirectDistanceCodes;
    let postfix = 1 << npostfix;
    let bits = 1;
    let half = 0;
    let i3 = 16;
    for (let j = 0; j < ndirect; ++j) {
      distExtraBits[i3] = 0;
      distOffset[i3] = j + 1;
      ++i3;
    }
    while (i3 < alphabetSizeLimit) {
      let base = ndirect + ((2 + half << bits) - 4 << npostfix) + 1;
      for (let j = 0; j < postfix; ++j) {
        distExtraBits[i3] = bits;
        distOffset[i3] = base + j;
        ++i3;
      }
      bits = bits + half;
      half = half ^ 1;
    }
  }
  function readMetablockHuffmanCodesAndContextMaps(s2) {
    s2.numLiteralBlockTypes = decodeVarLenUnsignedByte(s2) + 1;
    s2.literalBlockLength = readMetablockPartition(s2, 0, s2.numLiteralBlockTypes);
    s2.numCommandBlockTypes = decodeVarLenUnsignedByte(s2) + 1;
    s2.commandBlockLength = readMetablockPartition(s2, 1, s2.numCommandBlockTypes);
    s2.numDistanceBlockTypes = decodeVarLenUnsignedByte(s2) + 1;
    s2.distanceBlockLength = readMetablockPartition(s2, 2, s2.numDistanceBlockTypes);
    if (s2.halfOffset > 2030) {
      doReadMoreInput(s2);
    }
    if (s2.bitOffset >= 16) {
      s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
      s2.bitOffset -= 16;
    }
    s2.distancePostfixBits = readFewBits(s2, 2);
    s2.numDirectDistanceCodes = readFewBits(s2, 4) << s2.distancePostfixBits;
    s2.contextModes = new Int8Array(s2.numLiteralBlockTypes);
    for (let i3 = 0; i3 < s2.numLiteralBlockTypes; ) {
      let limit = min(i3 + 96, s2.numLiteralBlockTypes);
      for (; i3 < limit; ++i3) {
        if (s2.bitOffset >= 16) {
          s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
          s2.bitOffset -= 16;
        }
        s2.contextModes[i3] = readFewBits(s2, 2);
      }
      if (s2.halfOffset > 2030) {
        doReadMoreInput(s2);
      }
    }
    s2.contextMap = new Int8Array(s2.numLiteralBlockTypes << 6);
    let numLiteralTrees = decodeContextMap(s2.numLiteralBlockTypes << 6, s2.contextMap, s2);
    s2.trivialLiteralContext = 1;
    for (let j = 0; j < s2.numLiteralBlockTypes << 6; j++) {
      if (s2.contextMap[j] != j >> 6) {
        s2.trivialLiteralContext = 0;
        break;
      }
    }
    s2.distContextMap = new Int8Array(s2.numDistanceBlockTypes << 2);
    let numDistTrees = decodeContextMap(s2.numDistanceBlockTypes << 2, s2.distContextMap, s2);
    s2.literalTreeGroup = decodeHuffmanTreeGroup(256, 256, numLiteralTrees, s2);
    s2.commandTreeGroup = decodeHuffmanTreeGroup(704, 704, s2.numCommandBlockTypes, s2);
    let distanceAlphabetSizeMax = calculateDistanceAlphabetSize(s2.distancePostfixBits, s2.numDirectDistanceCodes, 24);
    let distanceAlphabetSizeLimit = distanceAlphabetSizeMax;
    if (s2.isLargeWindow == 1) {
      distanceAlphabetSizeMax = calculateDistanceAlphabetSize(s2.distancePostfixBits, s2.numDirectDistanceCodes, 62);
      distanceAlphabetSizeLimit = calculateDistanceAlphabetLimit(2147483644, s2.distancePostfixBits, s2.numDirectDistanceCodes);
    }
    s2.distanceTreeGroup = decodeHuffmanTreeGroup(distanceAlphabetSizeMax, distanceAlphabetSizeLimit, numDistTrees, s2);
    calculateDistanceLut(s2, distanceAlphabetSizeLimit);
    s2.contextMapSlice = 0;
    s2.distContextMapSlice = 0;
    s2.contextLookupOffset1 = s2.contextModes[0] * 512;
    s2.contextLookupOffset2 = s2.contextLookupOffset1 + 256;
    s2.literalTreeIdx = 0;
    s2.commandTreeIdx = 0;
    s2.rings[4] = 1;
    s2.rings[5] = 0;
    s2.rings[6] = 1;
    s2.rings[7] = 0;
    s2.rings[8] = 1;
    s2.rings[9] = 0;
  }
  function copyUncompressedData(s2) {
    let ringBuffer = s2.ringBuffer;
    if (s2.metaBlockLength <= 0) {
      reload(s2);
      s2.runningState = 2;
      return;
    }
    let chunkLength = min(s2.ringBufferSize - s2.pos, s2.metaBlockLength);
    copyRawBytes(s2, ringBuffer, s2.pos, chunkLength);
    s2.metaBlockLength -= chunkLength;
    s2.pos += chunkLength;
    if (s2.pos == s2.ringBufferSize) {
      s2.nextRunningState = 6;
      s2.runningState = 12;
      return;
    }
    reload(s2);
    s2.runningState = 2;
  }
  function writeRingBuffer(s2) {
    let toWrite = min(s2.outputLength - s2.outputUsed, s2.ringBufferBytesReady - s2.ringBufferBytesWritten);
    if (toWrite != 0) {
      s2.output.set(s2.ringBuffer.subarray(s2.ringBufferBytesWritten, s2.ringBufferBytesWritten + toWrite), s2.outputOffset + s2.outputUsed);
      s2.outputUsed += toWrite;
      s2.ringBufferBytesWritten += toWrite;
    }
    if (s2.outputUsed < s2.outputLength) {
      return 1;
    } else {
      return 0;
    }
  }
  function decodeHuffmanTreeGroup(alphabetSizeMax, alphabetSizeLimit, n2, s2) {
    let maxTableSize = MAX_HUFFMAN_TABLE_SIZE[alphabetSizeLimit + 31 >> 5];
    let group = new Int32Array(n2 + n2 * maxTableSize);
    let next = n2;
    for (let i3 = 0; i3 < n2; ++i3) {
      group[i3] = next;
      next += readHuffmanCode(alphabetSizeMax, alphabetSizeLimit, group, i3, s2);
    }
    return group;
  }
  function calculateFence(s2) {
    let result = s2.ringBufferSize;
    if (s2.isEager != 0) {
      result = min(result, s2.ringBufferBytesWritten + s2.outputLength - s2.outputUsed);
    }
    return result;
  }
  function doUseDictionary(s2, fence) {
    if (s2.distance > 2147483644) {
      throw "Invalid backward reference";
    }
    let address = s2.distance - s2.maxDistance - 1 - s2.cdTotalSize;
    if (address < 0) {
      initializeCompoundDictionaryCopy(s2, -address - 1, s2.copyLength);
      s2.runningState = 14;
    } else {
      let dictionaryData = (
        /** @type{!Int8Array} */
        data
      );
      let wordLength = s2.copyLength;
      if (wordLength > 31) {
        throw "Invalid backward reference";
      }
      let shift = sizeBits[wordLength];
      if (shift == 0) {
        throw "Invalid backward reference";
      }
      let offset = offsets[wordLength];
      let mask = (1 << shift) - 1;
      let wordIdx = address & mask;
      let transformIdx = address >>> shift;
      offset += wordIdx * wordLength;
      let transforms = RFC_TRANSFORMS;
      if (transformIdx >= transforms.numTransforms) {
        throw "Invalid backward reference";
      }
      let len = transformDictionaryWord(s2.ringBuffer, s2.pos, dictionaryData, offset, wordLength, transforms, transformIdx);
      s2.pos += len;
      s2.metaBlockLength -= len;
      if (s2.pos >= fence) {
        s2.nextRunningState = 4;
        s2.runningState = 12;
        return;
      }
      s2.runningState = 4;
    }
  }
  function initializeCompoundDictionary(s2) {
    s2.cdBlockMap = new Int8Array(256);
    let blockBits = 8;
    while (s2.cdTotalSize - 1 >>> blockBits != 0) {
      blockBits++;
    }
    blockBits -= 8;
    s2.cdBlockBits = blockBits;
    let cursor = 0;
    let index = 0;
    while (cursor < s2.cdTotalSize) {
      while (s2.cdChunkOffsets[index + 1] < cursor) {
        index++;
      }
      s2.cdBlockMap[cursor >>> blockBits] = index;
      cursor += 1 << blockBits;
    }
  }
  function initializeCompoundDictionaryCopy(s2, address, length2) {
    if (s2.cdBlockBits == -1) {
      initializeCompoundDictionary(s2);
    }
    let index = s2.cdBlockMap[address >>> s2.cdBlockBits];
    while (address >= s2.cdChunkOffsets[index + 1]) {
      index++;
    }
    if (s2.cdTotalSize > address + length2) {
      throw "Invalid backward reference";
    }
    s2.distRbIdx = s2.distRbIdx + 1 & 3;
    s2.rings[s2.distRbIdx] = s2.distance;
    s2.metaBlockLength -= length2;
    s2.cdBrIndex = index;
    s2.cdBrOffset = address - s2.cdChunkOffsets[index];
    s2.cdBrLength = length2;
    s2.cdBrCopied = 0;
  }
  function copyFromCompoundDictionary(s2, fence) {
    let pos = s2.pos;
    let origPos = pos;
    while (s2.cdBrLength != s2.cdBrCopied) {
      let space = fence - pos;
      let chunkLength = s2.cdChunkOffsets[s2.cdBrIndex + 1] - s2.cdChunkOffsets[s2.cdBrIndex];
      let remChunkLength = chunkLength - s2.cdBrOffset;
      let length2 = s2.cdBrLength - s2.cdBrCopied;
      if (length2 > remChunkLength) {
        length2 = remChunkLength;
      }
      if (length2 > space) {
        length2 = space;
      }
      copyBytes(s2.ringBuffer, pos, s2.cdChunks[s2.cdBrIndex], s2.cdBrOffset, s2.cdBrOffset + length2);
      pos += length2;
      s2.cdBrOffset += length2;
      s2.cdBrCopied += length2;
      if (length2 == remChunkLength) {
        s2.cdBrIndex++;
        s2.cdBrOffset = 0;
      }
      if (pos >= fence) {
        break;
      }
    }
    return pos - origPos;
  }
  function decompress(s2) {
    if (s2.runningState == 0) {
      throw "Can't decompress until initialized";
    }
    if (s2.runningState == 11) {
      throw "Can't decompress after close";
    }
    if (s2.runningState == 1) {
      let windowBits = decodeWindowBits(s2);
      if (windowBits == -1) {
        throw "Invalid 'windowBits' code";
      }
      s2.maxRingBufferSize = 1 << windowBits;
      s2.maxBackwardDistance = s2.maxRingBufferSize - 16;
      s2.runningState = 2;
    }
    let fence = calculateFence(s2);
    let ringBufferMask = s2.ringBufferSize - 1;
    let ringBuffer = s2.ringBuffer;
    while (s2.runningState != 10) {
      switch (s2.runningState) {
        case 2:
          if (s2.metaBlockLength < 0) {
            throw "Invalid metablock length";
          }
          readNextMetablockHeader(s2);
          fence = calculateFence(s2);
          ringBufferMask = s2.ringBufferSize - 1;
          ringBuffer = s2.ringBuffer;
          continue;
        case 3:
          readMetablockHuffmanCodesAndContextMaps(s2);
          s2.runningState = 4;
        case 4:
          if (s2.metaBlockLength <= 0) {
            s2.runningState = 2;
            continue;
          }
          if (s2.halfOffset > 2030) {
            doReadMoreInput(s2);
          }
          if (s2.commandBlockLength == 0) {
            decodeCommandBlockSwitch(s2);
          }
          s2.commandBlockLength--;
          if (s2.bitOffset >= 16) {
            s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
            s2.bitOffset -= 16;
          }
          let cmdCode = readSymbol(s2.commandTreeGroup, s2.commandTreeIdx, s2) << 2;
          let insertAndCopyExtraBits = CMD_LOOKUP[cmdCode];
          let insertLengthOffset = CMD_LOOKUP[cmdCode + 1];
          let copyLengthOffset = CMD_LOOKUP[cmdCode + 2];
          s2.distanceCode = CMD_LOOKUP[cmdCode + 3];
          if (s2.bitOffset >= 16) {
            s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
            s2.bitOffset -= 16;
          }
          let insertLengthExtraBits = insertAndCopyExtraBits & 255;
          s2.insertLength = insertLengthOffset + (insertLengthExtraBits <= 16 ? readFewBits(s2, insertLengthExtraBits) : readManyBits(s2, insertLengthExtraBits));
          if (s2.bitOffset >= 16) {
            s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
            s2.bitOffset -= 16;
          }
          let copyLengthExtraBits = insertAndCopyExtraBits >> 8;
          s2.copyLength = copyLengthOffset + (copyLengthExtraBits <= 16 ? readFewBits(s2, copyLengthExtraBits) : readManyBits(s2, copyLengthExtraBits));
          s2.j = 0;
          s2.runningState = 7;
        case 7:
          if (s2.trivialLiteralContext != 0) {
            while (s2.j < s2.insertLength) {
              if (s2.halfOffset > 2030) {
                doReadMoreInput(s2);
              }
              if (s2.literalBlockLength == 0) {
                decodeLiteralBlockSwitch(s2);
              }
              s2.literalBlockLength--;
              if (s2.bitOffset >= 16) {
                s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
                s2.bitOffset -= 16;
              }
              ringBuffer[s2.pos] = readSymbol(s2.literalTreeGroup, s2.literalTreeIdx, s2);
              s2.pos++;
              s2.j++;
              if (s2.pos >= fence) {
                s2.nextRunningState = 7;
                s2.runningState = 12;
                break;
              }
            }
          } else {
            let prevByte1 = ringBuffer[s2.pos - 1 & ringBufferMask] & 255;
            let prevByte2 = ringBuffer[s2.pos - 2 & ringBufferMask] & 255;
            while (s2.j < s2.insertLength) {
              if (s2.halfOffset > 2030) {
                doReadMoreInput(s2);
              }
              if (s2.literalBlockLength == 0) {
                decodeLiteralBlockSwitch(s2);
              }
              let literalContext = LOOKUP[s2.contextLookupOffset1 + prevByte1] | LOOKUP[s2.contextLookupOffset2 + prevByte2];
              let literalTreeIdx = s2.contextMap[s2.contextMapSlice + literalContext] & 255;
              s2.literalBlockLength--;
              prevByte2 = prevByte1;
              if (s2.bitOffset >= 16) {
                s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
                s2.bitOffset -= 16;
              }
              prevByte1 = readSymbol(s2.literalTreeGroup, literalTreeIdx, s2);
              ringBuffer[s2.pos] = prevByte1;
              s2.pos++;
              s2.j++;
              if (s2.pos >= fence) {
                s2.nextRunningState = 7;
                s2.runningState = 12;
                break;
              }
            }
          }
          if (s2.runningState != 7) {
            continue;
          }
          s2.metaBlockLength -= s2.insertLength;
          if (s2.metaBlockLength <= 0) {
            s2.runningState = 4;
            continue;
          }
          let distanceCode = s2.distanceCode;
          if (distanceCode < 0) {
            s2.distance = s2.rings[s2.distRbIdx];
          } else {
            if (s2.halfOffset > 2030) {
              doReadMoreInput(s2);
            }
            if (s2.distanceBlockLength == 0) {
              decodeDistanceBlockSwitch(s2);
            }
            s2.distanceBlockLength--;
            if (s2.bitOffset >= 16) {
              s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
              s2.bitOffset -= 16;
            }
            let distTreeIdx = s2.distContextMap[s2.distContextMapSlice + distanceCode] & 255;
            distanceCode = readSymbol(s2.distanceTreeGroup, distTreeIdx, s2);
            if (distanceCode < 16) {
              let index = s2.distRbIdx + DISTANCE_SHORT_CODE_INDEX_OFFSET[distanceCode] & 3;
              s2.distance = s2.rings[index] + DISTANCE_SHORT_CODE_VALUE_OFFSET[distanceCode];
              if (s2.distance < 0) {
                throw "Negative distance";
              }
            } else {
              let extraBits = s2.distExtraBits[distanceCode];
              let bits;
              if (s2.bitOffset + extraBits <= 32) {
                bits = readFewBits(s2, extraBits);
              } else {
                if (s2.bitOffset >= 16) {
                  s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
                  s2.bitOffset -= 16;
                }
                bits = extraBits <= 16 ? readFewBits(s2, extraBits) : readManyBits(s2, extraBits);
              }
              s2.distance = s2.distOffset[distanceCode] + (bits << s2.distancePostfixBits);
            }
          }
          if (s2.maxDistance != s2.maxBackwardDistance && s2.pos < s2.maxBackwardDistance) {
            s2.maxDistance = s2.pos;
          } else {
            s2.maxDistance = s2.maxBackwardDistance;
          }
          if (s2.distance > s2.maxDistance) {
            s2.runningState = 9;
            continue;
          }
          if (distanceCode > 0) {
            s2.distRbIdx = s2.distRbIdx + 1 & 3;
            s2.rings[s2.distRbIdx] = s2.distance;
          }
          if (s2.copyLength > s2.metaBlockLength) {
            throw "Invalid backward reference";
          }
          s2.j = 0;
          s2.runningState = 8;
        case 8:
          let src = s2.pos - s2.distance & ringBufferMask;
          let dst = s2.pos;
          let copyLength = s2.copyLength - s2.j;
          let srcEnd = src + copyLength;
          let dstEnd = dst + copyLength;
          if (srcEnd < ringBufferMask && dstEnd < ringBufferMask) {
            if (copyLength < 12 || srcEnd > dst && dstEnd > src) {
              for (let k = 0; k < copyLength; k += 4) {
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
              }
            } else {
              ringBuffer.copyWithin(dst, src, srcEnd);
            }
            s2.j += copyLength;
            s2.metaBlockLength -= copyLength;
            s2.pos += copyLength;
          } else {
            for (; s2.j < s2.copyLength; ) {
              ringBuffer[s2.pos] = ringBuffer[s2.pos - s2.distance & ringBufferMask];
              s2.metaBlockLength--;
              s2.pos++;
              s2.j++;
              if (s2.pos >= fence) {
                s2.nextRunningState = 8;
                s2.runningState = 12;
                break;
              }
            }
          }
          if (s2.runningState == 8) {
            s2.runningState = 4;
          }
          continue;
        case 9:
          doUseDictionary(s2, fence);
          continue;
        case 14:
          s2.pos += copyFromCompoundDictionary(s2, fence);
          if (s2.pos >= fence) {
            s2.nextRunningState = 14;
            s2.runningState = 12;
            return;
          }
          s2.runningState = 4;
          continue;
        case 5:
          while (s2.metaBlockLength > 0) {
            if (s2.halfOffset > 2030) {
              doReadMoreInput(s2);
            }
            if (s2.bitOffset >= 16) {
              s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
              s2.bitOffset -= 16;
            }
            readFewBits(s2, 8);
            s2.metaBlockLength--;
          }
          s2.runningState = 2;
          continue;
        case 6:
          copyUncompressedData(s2);
          continue;
        case 12:
          s2.ringBufferBytesReady = min(s2.pos, s2.ringBufferSize);
          s2.runningState = 13;
        case 13:
          if (writeRingBuffer(s2) == 0) {
            return;
          }
          if (s2.pos >= s2.maxBackwardDistance) {
            s2.maxDistance = s2.maxBackwardDistance;
          }
          if (s2.pos >= s2.ringBufferSize) {
            if (s2.pos > s2.ringBufferSize) {
              ringBuffer.copyWithin(0, s2.ringBufferSize, s2.pos);
            }
            s2.pos &= ringBufferMask;
            s2.ringBufferBytesWritten = 0;
          }
          s2.runningState = s2.nextRunningState;
          continue;
        default:
          throw "Unexpected state " + s2.runningState;
      }
    }
    if (s2.runningState == 10) {
      if (s2.metaBlockLength < 0) {
        throw "Invalid metablock length";
      }
      jumpToByteBoundary(s2);
      checkHealth(s2, 1);
    }
  }
  function Transforms(numTransforms, prefixSuffixLen, prefixSuffixCount) {
    this.numTransforms = 0;
    this.triplets = new Int32Array(0);
    this.prefixSuffixStorage = new Int8Array(0);
    this.prefixSuffixHeads = new Int32Array(0);
    this.params = new Int16Array(0);
    this.numTransforms = numTransforms;
    this.triplets = new Int32Array(numTransforms * 3);
    this.params = new Int16Array(numTransforms);
    this.prefixSuffixStorage = new Int8Array(prefixSuffixLen);
    this.prefixSuffixHeads = new Int32Array(prefixSuffixCount + 1);
  }
  let RFC_TRANSFORMS = new Transforms(121, 167, 50);
  function unpackTransforms(prefixSuffix, prefixSuffixHeads, transforms, prefixSuffixSrc, transformsSrc) {
    let n2 = prefixSuffixSrc.length;
    let index = 1;
    let j = 0;
    for (let i3 = 0; i3 < n2; ++i3) {
      let c2 = prefixSuffixSrc.charCodeAt(i3);
      if (c2 == 35) {
        prefixSuffixHeads[index++] = j;
      } else {
        prefixSuffix[j++] = c2;
      }
    }
    for (let i3 = 0; i3 < 363; ++i3) {
      transforms[i3] = transformsSrc.charCodeAt(i3) - 32;
    }
  }
  {
    unpackTransforms(RFC_TRANSFORMS.prefixSuffixStorage, RFC_TRANSFORMS.prefixSuffixHeads, RFC_TRANSFORMS.triplets, `# #s #, #e #.# the #.com/#Â # of # and # in # to #"#">#
#]# for # a # that #. # with #'# from # by #. The # on # as # is #ing #
	#:#ed #(# at #ly #="# of the #. This #,# not #er #al #='#ful #ive #less #est #ize #ous #`, `     !! ! ,  *!  &!  " !  ) *   * -  ! # !  #!*!  +  ,$ !  -  %  .  / #   0  1 .  "   2  3!*   4%  ! # /   5  6  7  8 0  1 &   $   9 +   :  ;  < '  !=  >  ?! 4  @ 4  2  &   A *# (   B  C& ) %  ) !*# *-% A +! *.  D! %'  & E *6  F  G% ! *A *%  H! D  I!+!  J!+   K +- *4! A  L!*4  M  N +6  O!*% +.! K *G  P +%(  ! G *D +D  Q +# *K!*G!+D!+# +G +A +4!+% +K!+4!*D!+K!*K`);
  }
  function transformDictionaryWord(dst, dstOffset, src, srcOffset, len, transforms, transformIndex) {
    let offset = dstOffset;
    let triplets = transforms.triplets;
    let prefixSuffixStorage = transforms.prefixSuffixStorage;
    let prefixSuffixHeads = transforms.prefixSuffixHeads;
    let transformOffset = 3 * transformIndex;
    let prefixIdx = triplets[transformOffset];
    let transformType = triplets[transformOffset + 1];
    let suffixIdx = triplets[transformOffset + 2];
    let prefix = prefixSuffixHeads[prefixIdx];
    let prefixEnd = prefixSuffixHeads[prefixIdx + 1];
    let suffix = prefixSuffixHeads[suffixIdx];
    let suffixEnd = prefixSuffixHeads[suffixIdx + 1];
    let omitFirst = transformType - 11;
    let omitLast = transformType - 0;
    if (omitFirst < 1 || omitFirst > 9) {
      omitFirst = 0;
    }
    if (omitLast < 1 || omitLast > 9) {
      omitLast = 0;
    }
    while (prefix != prefixEnd) {
      dst[offset++] = prefixSuffixStorage[prefix++];
    }
    if (omitFirst > len) {
      omitFirst = len;
    }
    srcOffset += omitFirst;
    len -= omitFirst;
    len -= omitLast;
    let i3 = len;
    while (i3 > 0) {
      dst[offset++] = src[srcOffset++];
      i3--;
    }
    if (transformType == 10 || transformType == 11) {
      let uppercaseOffset = offset - len;
      if (transformType == 10) {
        len = 1;
      }
      while (len > 0) {
        let c0 = dst[uppercaseOffset] & 255;
        if (c0 < 192) {
          if (c0 >= 97 && c0 <= 122) {
            dst[uppercaseOffset] ^= 32;
          }
          uppercaseOffset += 1;
          len -= 1;
        } else if (c0 < 224) {
          dst[uppercaseOffset + 1] ^= 32;
          uppercaseOffset += 2;
          len -= 2;
        } else {
          dst[uppercaseOffset + 2] ^= 5;
          uppercaseOffset += 3;
          len -= 3;
        }
      }
    } else if (transformType == 21 || transformType == 22) {
      let shiftOffset = offset - len;
      let param = transforms.params[transformIndex];
      let scalar = (param & 32767) + (16777216 - (param & 32768));
      while (len > 0) {
        let step = 1;
        let c0 = dst[shiftOffset] & 255;
        if (c0 < 128) {
          scalar += c0;
          dst[shiftOffset] = scalar & 127;
        } else if (c0 < 192) {
        } else if (c0 < 224) {
          if (len >= 2) {
            let c1 = dst[shiftOffset + 1];
            scalar += c1 & 63 | (c0 & 31) << 6;
            dst[shiftOffset] = 192 | scalar >> 6 & 31;
            dst[shiftOffset + 1] = c1 & 192 | scalar & 63;
            step = 2;
          } else {
            step = len;
          }
        } else if (c0 < 240) {
          if (len >= 3) {
            let c1 = dst[shiftOffset + 1];
            let c2 = dst[shiftOffset + 2];
            scalar += c2 & 63 | (c1 & 63) << 6 | (c0 & 15) << 12;
            dst[shiftOffset] = 224 | scalar >> 12 & 15;
            dst[shiftOffset + 1] = c1 & 192 | scalar >> 6 & 63;
            dst[shiftOffset + 2] = c2 & 192 | scalar & 63;
            step = 3;
          } else {
            step = len;
          }
        } else if (c0 < 248) {
          if (len >= 4) {
            let c1 = dst[shiftOffset + 1];
            let c2 = dst[shiftOffset + 2];
            let c3 = dst[shiftOffset + 3];
            scalar += c3 & 63 | (c2 & 63) << 6 | (c1 & 63) << 12 | (c0 & 7) << 18;
            dst[shiftOffset] = 240 | scalar >> 18 & 7;
            dst[shiftOffset + 1] = c1 & 192 | scalar >> 12 & 63;
            dst[shiftOffset + 2] = c2 & 192 | scalar >> 6 & 63;
            dst[shiftOffset + 3] = c3 & 192 | scalar & 63;
            step = 4;
          } else {
            step = len;
          }
        }
        shiftOffset += step;
        len -= step;
        if (transformType == 21) {
          len = 0;
        }
      }
    }
    while (suffix != suffixEnd) {
      dst[offset++] = prefixSuffixStorage[suffix++];
    }
    return offset - dstOffset;
  }
  function getNextKey(key, len) {
    let step = 1 << len - 1;
    while ((key & step) != 0) {
      step >>= 1;
    }
    return (key & step - 1) + step;
  }
  function replicateValue(table, offset, step, end, item) {
    do {
      end -= step;
      table[offset + end] = item;
    } while (end > 0);
  }
  function nextTableBitSize(count, len, rootBits) {
    let left = 1 << len - rootBits;
    while (len < 15) {
      left -= count[len];
      if (left <= 0) {
        break;
      }
      len++;
      left <<= 1;
    }
    return len - rootBits;
  }
  function buildHuffmanTable(tableGroup, tableIdx, rootBits, codeLengths, codeLengthsSize) {
    let tableOffset = tableGroup[tableIdx];
    let key;
    let sorted = new Int32Array(codeLengthsSize);
    let count = new Int32Array(16);
    let offset = new Int32Array(16);
    let symbol;
    for (symbol = 0; symbol < codeLengthsSize; symbol++) {
      count[codeLengths[symbol]]++;
    }
    offset[1] = 0;
    for (let len = 1; len < 15; len++) {
      offset[len + 1] = offset[len] + count[len];
    }
    for (symbol = 0; symbol < codeLengthsSize; symbol++) {
      if (codeLengths[symbol] != 0) {
        sorted[offset[codeLengths[symbol]]++] = symbol;
      }
    }
    let tableBits = rootBits;
    let tableSize = 1 << tableBits;
    let totalSize = tableSize;
    if (offset[15] == 1) {
      for (key = 0; key < totalSize; key++) {
        tableGroup[tableOffset + key] = sorted[0];
      }
      return totalSize;
    }
    key = 0;
    symbol = 0;
    for (let len = 1, step = 2; len <= rootBits; len++, step <<= 1) {
      for (; count[len] > 0; count[len]--) {
        replicateValue(tableGroup, tableOffset + key, step, tableSize, len << 16 | sorted[symbol++]);
        key = getNextKey(key, len);
      }
    }
    let mask = totalSize - 1;
    let low = -1;
    let currentOffset = tableOffset;
    for (let len = rootBits + 1, step = 2; len <= 15; len++, step <<= 1) {
      for (; count[len] > 0; count[len]--) {
        if ((key & mask) != low) {
          currentOffset += tableSize;
          tableBits = nextTableBitSize(count, len, rootBits);
          tableSize = 1 << tableBits;
          totalSize += tableSize;
          low = key & mask;
          tableGroup[tableOffset + low] = tableBits + rootBits << 16 | currentOffset - tableOffset - low;
        }
        replicateValue(tableGroup, currentOffset + (key >> rootBits), step, tableSize, len - rootBits << 16 | sorted[symbol++]);
        key = getNextKey(key, len);
      }
    }
    return totalSize;
  }
  function doReadMoreInput(s2) {
    if (s2.endOfStreamReached != 0) {
      if (halfAvailable(s2) >= -2) {
        return;
      }
      throw "No more input";
    }
    let readOffset = s2.halfOffset << 1;
    let bytesInBuffer = 4096 - readOffset;
    s2.byteBuffer.copyWithin(0, readOffset, 4096);
    s2.halfOffset = 0;
    while (bytesInBuffer < 4096) {
      let spaceLeft = 4096 - bytesInBuffer;
      let len = readInput(s2.input, s2.byteBuffer, bytesInBuffer, spaceLeft);
      if (len <= 0) {
        s2.endOfStreamReached = 1;
        s2.tailBytes = bytesInBuffer;
        bytesInBuffer += 1;
        break;
      }
      bytesInBuffer += len;
    }
    bytesToNibbles(s2, bytesInBuffer);
  }
  function checkHealth(s2, endOfStream) {
    if (s2.endOfStreamReached == 0) {
      return;
    }
    let byteOffset = (s2.halfOffset << 1) + (s2.bitOffset + 7 >> 3) - 4;
    if (byteOffset > s2.tailBytes) {
      throw "Read after end";
    }
    if (endOfStream != 0 && byteOffset != s2.tailBytes) {
      throw "Unused bytes after end";
    }
  }
  function assertAccumulatorHealthy(s2) {
    if (s2.bitOffset > 32) {
      throw "Accumulator underloaded: " + s2.bitOffset;
    }
  }
  function readFewBits(s2, n2) {
    let val2 = s2.accumulator32 >>> s2.bitOffset & (1 << n2) - 1;
    s2.bitOffset += n2;
    return val2;
  }
  function readManyBits(s2, n2) {
    let low = readFewBits(s2, 16);
    s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
    s2.bitOffset -= 16;
    return low | readFewBits(s2, n2 - 16) << 16;
  }
  function initBitReader(s2) {
    s2.byteBuffer = new Int8Array(4160);
    s2.accumulator32 = 0;
    s2.shortBuffer = new Int16Array(2080);
    s2.bitOffset = 32;
    s2.halfOffset = 2048;
    s2.endOfStreamReached = 0;
    prepare(s2);
  }
  function prepare(s2) {
    if (s2.halfOffset > 2030) {
      doReadMoreInput(s2);
    }
    checkHealth(s2, 0);
    s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
    s2.bitOffset -= 16;
    s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
    s2.bitOffset -= 16;
  }
  function reload(s2) {
    if (s2.bitOffset == 32) {
      prepare(s2);
    }
  }
  function jumpToByteBoundary(s2) {
    let padding = 32 - s2.bitOffset & 7;
    if (padding != 0) {
      let paddingBits = readFewBits(s2, padding);
      if (paddingBits != 0) {
        throw "Corrupted padding bits";
      }
    }
  }
  function halfAvailable(s2) {
    let limit = 2048;
    if (s2.endOfStreamReached != 0) {
      limit = s2.tailBytes + 1 >> 1;
    }
    return limit - s2.halfOffset;
  }
  function copyRawBytes(s2, data2, offset, length2) {
    if ((s2.bitOffset & 7) != 0) {
      throw "Unaligned copyBytes";
    }
    while (s2.bitOffset != 32 && length2 != 0) {
      data2[offset++] = s2.accumulator32 >>> s2.bitOffset;
      s2.bitOffset += 8;
      length2--;
    }
    if (length2 == 0) {
      return;
    }
    let copyNibbles = min(halfAvailable(s2), length2 >> 1);
    if (copyNibbles > 0) {
      let readOffset = s2.halfOffset << 1;
      let delta = copyNibbles << 1;
      data2.set(s2.byteBuffer.subarray(readOffset, readOffset + delta), offset);
      offset += delta;
      length2 -= delta;
      s2.halfOffset += copyNibbles;
    }
    if (length2 == 0) {
      return;
    }
    if (halfAvailable(s2) > 0) {
      if (s2.bitOffset >= 16) {
        s2.accumulator32 = s2.shortBuffer[s2.halfOffset++] << 16 | s2.accumulator32 >>> 16;
        s2.bitOffset -= 16;
      }
      while (length2 != 0) {
        data2[offset++] = s2.accumulator32 >>> s2.bitOffset;
        s2.bitOffset += 8;
        length2--;
      }
      checkHealth(s2, 0);
      return;
    }
    while (length2 > 0) {
      let len = readInput(s2.input, data2, offset, length2);
      if (len == -1) {
        throw "Unexpected end of input";
      }
      offset += len;
      length2 -= len;
    }
  }
  function bytesToNibbles(s2, byteLen) {
    let byteBuffer = s2.byteBuffer;
    let halfLen = byteLen >> 1;
    let shortBuffer = s2.shortBuffer;
    for (let i3 = 0; i3 < halfLen; ++i3) {
      shortBuffer[i3] = byteBuffer[i3 * 2] & 255 | (byteBuffer[i3 * 2 + 1] & 255) << 8;
    }
  }
  let LOOKUP = new Int32Array(2048);
  function unpackLookupTable(lookup, map, rle) {
    for (let i3 = 0; i3 < 256; ++i3) {
      lookup[i3] = i3 & 63;
      lookup[512 + i3] = i3 >> 2;
      lookup[1792 + i3] = 2 + (i3 >> 6);
    }
    for (let i3 = 0; i3 < 128; ++i3) {
      lookup[1024 + i3] = 4 * (map.charCodeAt(i3) - 32);
    }
    for (let i3 = 0; i3 < 64; ++i3) {
      lookup[1152 + i3] = i3 & 1;
      lookup[1216 + i3] = 2 + (i3 & 1);
    }
    let offset = 1280;
    for (let k = 0; k < 19; ++k) {
      let value = k & 3;
      let rep = rle.charCodeAt(k) - 32;
      for (let i3 = 0; i3 < rep; ++i3) {
        lookup[offset++] = value;
      }
    }
    for (let i3 = 0; i3 < 16; ++i3) {
      lookup[1792 + i3] = 1;
      lookup[2032 + i3] = 6;
    }
    lookup[1792] = 0;
    lookup[2047] = 7;
    for (let i3 = 0; i3 < 256; ++i3) {
      lookup[1536 + i3] = lookup[1792 + i3] << 3;
    }
  }
  {
    unpackLookupTable(LOOKUP, `         !!  !                  "#$##%#$&'##(#)#++++++++++((&*'##,---,---,-----,-----,-----&#'###.///.///./////./////./////&#'# `, "A/*  ':  & : $   @");
  }
  function State() {
    this.ringBuffer = new Int8Array(0);
    this.contextModes = new Int8Array(0);
    this.contextMap = new Int8Array(0);
    this.distContextMap = new Int8Array(0);
    this.distExtraBits = new Int8Array(0);
    this.output = new Int8Array(0);
    this.byteBuffer = new Int8Array(0);
    this.shortBuffer = new Int16Array(0);
    this.intBuffer = new Int32Array(0);
    this.rings = new Int32Array(0);
    this.blockTrees = new Int32Array(0);
    this.literalTreeGroup = new Int32Array(0);
    this.commandTreeGroup = new Int32Array(0);
    this.distanceTreeGroup = new Int32Array(0);
    this.distOffset = new Int32Array(0);
    this.runningState = 0;
    this.nextRunningState = 0;
    this.accumulator32 = 0;
    this.bitOffset = 0;
    this.halfOffset = 0;
    this.tailBytes = 0;
    this.endOfStreamReached = 0;
    this.metaBlockLength = 0;
    this.inputEnd = 0;
    this.isUncompressed = 0;
    this.isMetadata = 0;
    this.literalBlockLength = 0;
    this.numLiteralBlockTypes = 0;
    this.commandBlockLength = 0;
    this.numCommandBlockTypes = 0;
    this.distanceBlockLength = 0;
    this.numDistanceBlockTypes = 0;
    this.pos = 0;
    this.maxDistance = 0;
    this.distRbIdx = 0;
    this.trivialLiteralContext = 0;
    this.literalTreeIdx = 0;
    this.commandTreeIdx = 0;
    this.j = 0;
    this.insertLength = 0;
    this.contextMapSlice = 0;
    this.distContextMapSlice = 0;
    this.contextLookupOffset1 = 0;
    this.contextLookupOffset2 = 0;
    this.distanceCode = 0;
    this.numDirectDistanceCodes = 0;
    this.distancePostfixBits = 0;
    this.distance = 0;
    this.copyLength = 0;
    this.maxBackwardDistance = 0;
    this.maxRingBufferSize = 0;
    this.ringBufferSize = 0;
    this.expectedTotalSize = 0;
    this.outputOffset = 0;
    this.outputLength = 0;
    this.outputUsed = 0;
    this.ringBufferBytesWritten = 0;
    this.ringBufferBytesReady = 0;
    this.isEager = 0;
    this.isLargeWindow = 0;
    this.cdNumChunks = 0;
    this.cdTotalSize = 0;
    this.cdBrIndex = 0;
    this.cdBrOffset = 0;
    this.cdBrLength = 0;
    this.cdBrCopied = 0;
    this.cdChunks = new Array(0);
    this.cdChunkOffsets = new Int32Array(0);
    this.cdBlockBits = 0;
    this.cdBlockMap = new Int8Array(0);
    this.input = null;
    this.ringBuffer = new Int8Array(0);
    this.rings = new Int32Array(10);
    this.rings[0] = 16;
    this.rings[1] = 15;
    this.rings[2] = 11;
    this.rings[3] = 4;
  }
  let data = null;
  let offsets = new Int32Array(32);
  let sizeBits = new Int32Array(32);
  function setData(newData, newSizeBits) {
    if (isDirect(newData) == 0 || isReadOnly(newData) == 0) {
      throw "newData must be a direct read-only byte buffer";
    }
    if (newSizeBits.length > 31) {
      throw "sizeBits length must be at most 31";
    }
    for (let i3 = 0; i3 < 4; ++i3) {
      if (newSizeBits[i3] != 0) {
        throw "first 4 must be 0";
      }
    }
    let dictionaryOffsets = offsets;
    let dictionarySizeBits = sizeBits;
    dictionarySizeBits.set(newSizeBits.subarray(0, 0 + newSizeBits.length), 0);
    let pos = 0;
    let limit = newData.length;
    for (let i3 = 0; i3 < newSizeBits.length; ++i3) {
      dictionaryOffsets[i3] = pos;
      let bits = dictionarySizeBits[i3];
      if (bits != 0) {
        if (bits >= 31) {
          throw "newSizeBits values must be less than 31";
        }
        pos += i3 << bits;
        if (pos <= 0 || pos > limit) {
          throw "newSizeBits is inconsistent: overflow";
        }
      }
    }
    for (let i3 = newSizeBits.length; i3 < 32; ++i3) {
      dictionaryOffsets[i3] = pos;
    }
    if (pos != limit) {
      throw "newSizeBits is inconsistent: underflow";
    }
    data = newData;
  }
  function unpackDictionaryData(dictionary, data0, data1, skipFlip, sizeBits2, sizeBitsData) {
    let dict = toUsAsciiBytes(data0 + data1);
    if (dict.length != dictionary.length) {
      throw "Corrupted brotli dictionary";
    }
    let offset = 0;
    let n2 = skipFlip.length;
    for (let i3 = 0; i3 < n2; i3 += 2) {
      let skip = skipFlip.charCodeAt(i3) - 36;
      let flip = skipFlip.charCodeAt(i3 + 1) - 36;
      for (let j = 0; j < skip; ++j) {
        dict[offset] ^= 3;
        offset++;
      }
      for (let j = 0; j < flip; ++j) {
        dict[offset] ^= 236;
        offset++;
      }
    }
    for (let i3 = 0; i3 < sizeBitsData.length; ++i3) {
      sizeBits2[i3] = sizeBitsData.charCodeAt(i3) - 65;
    }
    dictionary.set(dict);
  }
  {
    let dictionaryData = new Int8Array(122784);
    let dictionarySizeBits = new Int32Array(25);
    unpackDictionaryData(dictionaryData, 'wjnfgltmojefofewab`h`lgfgbwbpkltlmozpjwf`jwzlsfmivpwojhfeqfftlqhwf{wzfbqlufqalgzolufelqnallhsobzojufojmfkfosklnfpjgfnlqftlqgolmdwkfnujftejmgsbdfgbzpevookfbgwfqnfb`kbqfbeqlnwqvfnbqhbaofvslmkjdkgbwfobmgmftpfufmmf{w`bpfalwkslpwvpfgnbgfkbmgkfqftkbwmbnfOjmhaoldpjyfabpfkfognbhfnbjmvpfq$*#(klogfmgptjwkMftpqfbgtfqfpjdmwbhfkbufdbnfpffm`boosbwktfoosovpnfmvejonsbqwiljmwkjpojpwdllgmffgtbzptfpwilapnjmgboploldlqj`kvpfpobpwwfbnbqnzellghjmdtjoofbpwtbqgafpwejqfSbdfhmltbtbz-smdnlufwkbmolbgdjufpfoemlwfnv`keffgnbmzql`hj`lmlm`follhkjgfgjfgKlnfqvofklpwbib{jmel`ovaobtpofppkboeplnfpv`kylmf233&lmfp`bqfWjnfqb`faovfelvqtffheb`fklsfdbufkbqgolpwtkfmsbqhhfswsbpppkjsqllnKWNOsobmWzsfglmfpbufhffseobdojmhplogejufwllhqbwfwltmivnswkvpgbqh`bqgejofefbqpwbzhjoowkbweboobvwlfufq-`lnwbohpklsulwfgffsnlgfqfpwwvqmalqmabmgefooqlpfvqo+phjmqlof`lnfb`wpbdfpnffwdlog-isdjwfnubqzefowwkfmpfmggqlsUjft`lsz2-3!?,b=pwlsfopfojfpwlvqsb`h-djesbpw`pp<dqbznfbm%dw8qjgfpklwobwfpbjgqlbgubq#effoilkmqj`hslqwebpw$VB.gfbg?,a=sllqajoowzsfV-P-tllgnvpw1s{8JmelqbmhtjgftbmwtbooofbgX3^8sbvotbufpvqf\'+$ tbjwnbppbqnpdlfpdbjmobmdsbjg"..#ol`hvmjwqllwtbohejqntjef{no!plmdwfpw13s{hjmgqltpwlloelmwnbjopbefpwbqnbsp`lqfqbjmeoltabazpsbmpbzp7s{85s{8bqwpellwqfbotjhjkfbwpwfswqjslqd,obhftfbhwlogElqn`bpwebmpabmhufqzqvmpivozwbph2s{8dlbodqftpoltfgdfjg>!pfwp6s{8-ip<73s{je#+pllmpfbwmlmfwvafyfqlpfmwqffgeb`wjmwldjewkbqn2;s{`bnfkjooalogyllnuljgfbpzqjmdejoosfbhjmjw`lpw0s{8ib`hwbdpajwpqloofgjwhmftmfbq?"..dqltIPLMgvwzMbnfpbofzlv#olwpsbjmibyy`logfzfpejpkttt-qjphwbapsqfu23s{qjpf16s{Aovfgjmd033/abooelqgfbqmtjogal{-ebjqob`hufqpsbjqivmfwf`kje+"sj`hfujo\'+! tbqnolqgglfpsvoo/333jgfbgqbtkvdfpslwevmgavqmkqfe`foohfzpwj`hklvqolppevfo21s{pvjwgfboQPP!bdfgdqfzDFW!fbpfbjnpdjqobjgp;s{8mbuzdqjgwjsp :::tbqpobgz`bqp*8#~sks<kfoowbootklnyk9	),	#233kboo-		B4s{8svpk`kbw3s{8`qft),?,kbpk46s{eobwqbqf#%%#wfoo`bnslmwlobjgnjppphjswfmwejmfnbofdfwpsolw733/		`lloeffw-sks?aq=fqj`nlpwdvjgafoogfp`kbjqnbwkbwln,jnd% ;1ov`h`fmw3338wjmzdlmfkwnopfoogqvdEQFFmlgfmj`h<jg>olpfmvooubpwtjmgQPP#tfbqqfozaffmpbnfgvhfmbpb`bsftjpkdvoeW109kjwppolwdbwfhj`haovqwkfz26s{$$*8*8!=npjftjmpajqgplqwafwbpffhW2;9lqgpwqffnboo53s{ebqnlupalzpX3^-$*8!SLPWafbqhjgp*8~~nbqzwfmg+VH*rvbgyk9\n.pjy....sqls$*8ojewW2:9uj`fbmgzgfaw=QPPsllomf`haoltW259gllqfuboW249ofwpebjolqbosloomlub`lopdfmf#lxplewqlnfwjooqlpp?k0=slvqebgfsjmh?wq=njmj*"+njmfyk9abqpkfbq33*8njoh#..=jqlmeqfggjphtfmwpljosvwp,ip,klozW119JPAMW139bgbnpffp?k1=iplm$/#$`lmwW129#QPPollsbpjbnllm?,s=plvoOJMFelqw`bqwW279?k2=;3s{"..?:s{8W379njhf975Ymj`fjm`kZlqhqj`fyk9\b$**8svqfnbdfsbqbwlmfalmg904Y\\le\\$^*8333/yk9\vwbmhzbqgaltoavpk965YIbub03s{	~	&@0&907YifeeF[SJ`bpkujpbdloepmltyk9rvfq-`pppj`hnfbwnjm-ajmggfookjqfsj`pqfmw905YKWWS.132elwltloeFMG#{al{967YALGZgj`h8	~	f{jw906Yubqpafbw$~*8gjfw:::8bmmf~~?,Xj^-Obmdhn.^tjqfwlzpbggppfbobof{8	\n~f`klmjmf-lqd336*wlmziftppbmgofdpqlle333*#133tjmfdfbqgldpallwdbqz`vwpwzofwfnswjlm-{no`l`hdbmd\'+$-63s{Sk-Gnjp`bobmolbmgfphnjofqzbmvmj{gjp`*8~	gvpw`ojs*-		43s{.133GUGp4^=?wbsfgfnlj((*tbdffvqlskjolswpklofEBRpbpjm.15WobapsfwpVQO#avoh`llh8~	KFBGX3^*baaqivbm+2:;ofpkwtjm?,j=plmzdvzpev`hsjsf.	"331*mgltX2^8X^8	Old#pbow	\n\nabmdwqjnabwk*x	33s{	~*8hl9\0effpbg=p9,,#X^8wloosovd+*x	x	#-ip$133sgvboalbw-ISD*8	~rvlw*8		$*8		~1327132613251324132;132:13131312131113101317131613151314131;131:130313021301130013071306130513041320132113221323133:133;133413351336133713301331133213332:::2::;2::42::52::62::72::02::12::22::32:;:2:;;2:;42:;52:;62:;72:;02:;12:;22:;32:4:2:4;2:442:452:462:472:402:412:422:432:5:2:5;2:542:552:562:572:502:512:522:532:6:2:6;2:642:652:662:672:602:612:622:632333231720:73333::::`lnln/Mpfpwffpwbsfqlwlglkb`f`bgbb/]lajfmg/Abbp/Aujgb`bpllwqlelqlplollwqb`vbogjilpjgldqbmwjslwfnbgfafbodlrv/Efpwlmbgbwqfpsl`l`bpbabilwlgbpjmlbdvbsvfpvmlpbmwfgj`fovjpfoobnbzlylmbbnlqsjpllaqb`oj`foolgjlpklqb`bpj<[<\\<Q<\\<R<P=l<\\=l=o=n<\\<Q<Y<S<R<R=n<T<[<Q<R<X<R=n<R<Z<Y<R<Q<T=i<q<\\<Y<Y<]=g<P=g<~=g=m<R<^=g<^<R<q<R<R<]<s<R<W<T<Q<T<L<H<q<Y<p=g=n=g<r<Q<T<P<X<\\<{<\\<x<\\<q=o<r<]=n<Y<t<[<Y<U<Q=o<P<P<N=g=o<Z5m5f4O5j5i4K5i4U5o5h4O5d4]4C5f4K5m5e5k5d5h5i5h5o4K5d5h5k4D4_4K5h4I5j5k5f4O5f5n4C5k5h4G5i4D5k5h5d5h5f4D5h4K5f4D5o4X5f4K5i4O5i5j4F4D5f5h5j4A4D5k5i5i4X5d4Xejqpwujgflojdkwtlqognfgjbtkjwf`olpfaob`hqjdkwpnbooallhpsob`fnvpj`ejfoglqgfqsljmwubovfofufowbaofalbqgklvpfdqlvstlqhpzfbqppwbwfwlgbztbwfqpwbqwpwzofgfbwksltfqsklmfmjdkwfqqlqjmsvwbalvwwfqnpwjwofwllopfufmwol`bowjnfpobqdftlqgpdbnfppklqwpsb`fel`vp`ofbqnlgfoaol`hdvjgfqbgjlpkbqftlnfmbdbjmnlmfzjnbdfmbnfpzlvmdojmfpobwfq`lolqdqffmeqlmw%bns8tbw`kelq`fsqj`fqvofpafdjmbewfqujpjwjppvfbqfbpafoltjmgf{wlwboklvqpobafosqjmwsqfppavjowojmhppsffgpwvgzwqbgfelvmgpfmpfvmgfqpkltmelqnpqbmdfbggfgpwjoonlufgwbhfmbalufeobpkej{fglewfmlwkfqujftp`kf`hofdboqjufqjwfnprvj`hpkbsfkvnbmf{jpwdljmdnlujfwkjqgabpj`sfb`fpwbdftjgwkoldjmjgfbptqlwfsbdfpvpfqpgqjufpwlqfaqfbhplvwkulj`fpjwfpnlmwktkfqfavjogtkj`kfbqwkelqvnwkqffpslqwsbqwz@oj`holtfqojufp`obppobzfqfmwqzpwlqzvpbdfplvmg`lvqwzlvq#ajqwkslsvswzsfpbssozJnbdfafjmdvssfqmlwfpfufqzpkltpnfbmpf{wqbnbw`kwqb`hhmltmfbqozafdbmpvsfqsbsfqmlqwkofbqmdjufmmbnfgfmgfgWfqnpsbqwpDqlvsaqbmgvpjmdtlnbmebopfqfbgzbvgjlwbhfptkjof-`ln,ojufg`bpfpgbjoz`kjogdqfbwivgdfwklpfvmjwpmfufqaqlbg`lbpw`lufqbssofejofp`z`ofp`fmfsobmp`oj`htqjwfrvffmsjf`ffnbjoeqbnflogfqsklwlojnjw`b`kf`jujop`boffmwfqwkfnfwkfqfwlv`kalvmgqlzbobphfgtklofpjm`fpwl`h#mbnfebjwkkfbqwfnswzleefqp`lsfltmfgnjdkwboavnwkjmhaollgbqqbznbilqwqvpw`bmlmvmjlm`lvmwubojgpwlmfPwzofOldjmkbsszl``vqofew9eqfpkrvjwfejonpdqbgfmffgpvqabmejdkwabpjpklufqbvwl8qlvwf-kwnonj{fgejmboZlvq#pojgfwlsj`aqltmbolmfgqbtmpsojwqfb`kQjdkwgbwfpnbq`krvlwfdllgpOjmhpglvawbpzm`wkvnaboolt`kjfezlvwkmlufo23s{8pfqufvmwjokbmgp@kf`hPsb`frvfqzibnfpfrvbowtj`f3/333Pwbqwsbmfoplmdpqlvmgfjdkwpkjewtlqwkslpwpofbgptffhpbuljgwkfpfnjofpsobmfpnbqwboskbsobmwnbqhpqbwfpsobzp`objnpbofpwf{wppwbqptqlmd?,k0=wkjmd-lqd,nvowjkfbqgSltfqpwbmgwlhfmplojg+wkjpaqjmdpkjsppwbeewqjfg`boopevoozeb`wpbdfmwWkjp#,,..=bgnjmfdzswFufmw26s{8Fnbjowqvf!`qlpppsfmwaoldpal{!=mlwfgofbuf`kjmbpjyfpdvfpw?,k7=qlalwkfbuzwqvf/pfufmdqbmg`qjnfpjdmpbtbqfgbm`fskbpf=?"..fm\\VP% 0:8133s{\\mbnfobwjmfmilzbib{-bwjlmpnjwkV-P-#klogpsfwfqjmgjbmbu!=`kbjmp`lqf`lnfpgljmdsqjlqPkbqf2::3pqlnbmojpwpibsbmeboopwqjboltmfqbdqff?,k1=bavpfbofqwlsfqb!.,,T`bqgpkjoopwfbnpSklwlwqvwk`ofbm-sks<pbjmwnfwboolvjpnfbmwsqlleaqjfeqlt!=dfmqfwqv`hollhpUbovfEqbnf-mfw,..=	?wqz#x	ubq#nbhfp`lpwpsobjmbgvowrvfpwwqbjmobalqkfosp`bvpfnbdj`nlwlqwkfjq163s{ofbpwpwfsp@lvmw`lvogdobpppjgfpevmgpklwfobtbqgnlvwknlufpsbqjpdjufpgvw`kwf{bpeqvjwmvoo/X^8wls!=	?"..SLPW!l`fbm?aq,=eollqpsfbhgfswk#pjyfabmhp`bw`k`kbqw13s{8bojdmgfboptlvog63s{8vqo>!sbqhpnlvpfNlpw#---?,bnlmdaqbjmalgz#mlmf8abpfg`bqqzgqbewqfefqsbdf\\klnf-nfwfqgfobzgqfbnsqlufiljmw?,wq=gqvdp?"..#bsqjojgfboboofmf{b`welqwk`lgfpoldj`Ujft#pffnpaobmhslqwp#+133pbufg\\ojmhdlbopdqbmwdqffhklnfpqjmdpqbwfg03s{8tklpfsbqpf+*8!#Aol`hojmv{ilmfpsj{fo$*8!=*8je+.ofewgbujgklqpfEl`vpqbjpfal{fpWqb`hfnfmw?,fn=abq!=-pq`>wltfqbow>!`baofkfmqz17s{8pfwvsjwbozpkbqsnjmlqwbpwftbmwpwkjp-qfpfwtkffodjqop,`pp,233&8`ovappwveeajaofulwfp#2333hlqfb~*8	abmgprvfvf>#x~8;3s{8`hjmdx	\n\nbkfbg`ol`hjqjpkojhf#qbwjlpwbwpElqn!zbkll*X3^8Balvwejmgp?,k2=gfavdwbphpVQO#>`foop~*+*821s{8sqjnfwfoopwvqmp3{533-isd!psbjmafb`kwb{fpnj`qlbmdfo..=?,djewppwfuf.ojmhalgz-~*8	\nnlvmw#+2::EBR?,qldfqeqbmh@obpp1;s{8effgp?k2=?p`lwwwfpwp11s{8gqjmh*##oftjppkboo 30:8#elq#olufgtbpwf33s{8ib9npjnlm?elmwqfsoznffwpvmwfq`kfbswjdkwAqbmg*#">#gqfpp`ojspqllnplmhfznlajonbjm-Mbnf#sobwfevmmzwqffp`ln,!2-isdtnlgfsbqbnPWBQWofew#jggfm/#132*8	~	elqn-ujqvp`kbjqwqbmptlqpwSbdfpjwjlmsbw`k?"..	l.`b`ejqnpwlvqp/333#bpjbmj((*xbglaf$*X3^jg>23alwk8nfmv#-1-nj-smd!hfujm`lb`k@kjogaqv`f1-isdVQO*(-isdpvjwfpoj`fkbqqz213!#ptffwwq=	mbnf>gjfdlsbdf#ptjpp..=		 eee8!=Old-`ln!wqfbwpkffw*#%%#27s{8poffsmwfmwejofgib9ojg>!`Mbnf!tlqpfpklwp.al{.gfowb	%ow8afbqp97;Y?gbwb.qvqbo?,b=#psfmgabhfqpklsp>#!!8sks!=`wjlm20s{8aqjbmkfoolpjyf>l>&1E#iljmnbzaf?jnd#jnd!=/#eipjnd!#!*X3^NWlsAWzsf!mftozGbmph`yf`kwqbjohmltp?,k6=ebr!=yk.`m23*8	.2!*8wzsf>aovfpwqvozgbujp-ip$8=	?"pwffo#zlv#k1=	elqn#ifpvp233&#nfmv-	\n	tbofpqjphpvnfmwggjmda.ojhwfb`kdje!#ufdbpgbmphffpwjpkrjspvlnjplaqfgfpgffmwqfwlglpsvfgfb/]lpfpw/Mwjfmfkbpwblwqlpsbqwfglmgfmvfulkb`fqelqnbnjpnlnfilqnvmglbrv/Ag/Abpp/_olbzvgbef`kbwlgbpwbmwlnfmlpgbwlplwqbppjwjlnv`klbklqbovdbqnbzlqfpwlpklqbpwfmfqbmwfpelwlpfpwbpsb/Apmvfubpbovgelqlpnfgjlrvjfmnfpfpslgfq`kjofpfq/Muf`fpgf`jqilp/Efpwbqufmwbdqvslkf`klfoolpwfmdlbnjdl`lpbpmjufodfmwfnjpnbbjqfpivojlwfnbpkb`jbebulqivmjlojaqfsvmwlavfmlbvwlqbaqjoavfmbwf{wlnbqylpbafqojpwbovfdl`/_nlfmfqlivfdlsfq/Vkbafqfpwlzmvm`bnvifqubolqevfqbojaqldvpwbjdvboulwlp`bplpdv/Absvfglplnlpbujplvpwfggfafmml`kfavp`bebowbfvqlppfqjfgj`kl`vqpl`obuf`bpbpof/_msobylobqdllaqbpujpwbbslzlivmwlwqbwbujpwl`qfbq`bnslkfnlp`jm`l`bqdlsjplplqgfmkb`fm/Mqfbgjp`lsfgql`fq`bsvfgbsbsfonfmlq/Vwjo`obqlilqdf`boofslmfqwbqgfmbgjfnbq`bpjdvffoobppjdol`l`kfnlwlpnbgqf`obpfqfpwlmj/]lrvfgbsbpbqabm`lkjilpujbifsbaol/Epwfujfmfqfjmlgfibqelmgl`bmbomlqwfofwqb`bvpbwlnbqnbmlpovmfpbvwlpujoobufmglsfpbqwjslpwfmdbnbq`loofubsbgqfvmjglubnlpylmbpbnalpabmgbnbqjbbavplnv`kbpvajqqjlibujujqdqbgl`kj`bboo/Ailufmgj`kbfpwbmwbofppbojqpvfolsfplpejmfpoobnbavp`l/Epwboofdbmfdqlsobybkvnlqsbdbqivmwbglaofjpobpalopbab/]lkbaobov`kb/mqfbgj`fmivdbqmlwbpuboofboo/M`bqdbglolqbabilfpw/Edvpwlnfmwfnbqjlejqnb`lpwlej`kbsobwbkldbqbqwfpofzfpbrvfonvpflabpfpsl`lpnjwbg`jfol`kj`lnjfgldbmbqpbmwlfwbsbgfafpsobzbqfgfppjfwf`lqwf`lqfbgvgbpgfpflujfilgfpfbbdvbp%rvlw8glnbjm`lnnlmpwbwvpfufmwpnbpwfqpzpwfnb`wjlmabmmfqqfnlufp`qloovsgbwfdolabonfgjvnejowfqmvnafq`kbmdfqfpvowsvaoj`p`qffm`kllpfmlqnbowqbufojppvfpplvq`fwbqdfwpsqjmdnlgvofnlajofptjw`ksklwlpalqgfqqfdjlmjwpfoepl`jbob`wjuf`lovnmqf`lqgelooltwjwof=fjwkfqofmdwkebnjozeqjfmgobzlvwbvwklq`qfbwfqfujftpvnnfqpfqufqsobzfgsobzfqf{sbmgsloj`zelqnbwglvaofsljmwppfqjfpsfqplmojujmdgfpjdmnlmwkpelq`fpvmjrvftfjdkwsflsoffmfqdzmbwvqfpfbq`kejdvqfkbujmd`vpwlnleepfwofwwfqtjmgltpvanjwqfmgfqdqlvspvsolbgkfbowknfwklgujgflpp`klloevwvqfpkbgltgfabwfubovfpLaif`wlwkfqpqjdkwpofbdvf`kqlnfpjnsofmlwj`fpkbqfgfmgjmdpfbplmqfslqwlmojmfprvbqfavwwlmjnbdfpfmbaofnlujmdobwfpwtjmwfqEqbm`fsfqjlgpwqlmdqfsfbwOlmglmgfwbjoelqnfggfnbmgpf`vqfsbppfgwlddofsob`fpgfuj`fpwbwj``jwjfppwqfbnzfooltbwwb`hpwqffweojdkwkjggfmjmel!=lsfmfgvpfevouboofz`bvpfpofbgfqpf`qfwpf`lmggbnbdfpslqwpf{`fswqbwjmdpjdmfgwkjmdpfeef`wejfogppwbwfpleej`fujpvbofgjwlqulovnfQfslqwnvpfvnnlujfpsbqfmwb``fppnlpwoznlwkfq!#jg>!nbqhfwdqlvmg`kbm`fpvqufzafelqfpznalonlnfmwpsff`knlwjlmjmpjgfnbwwfq@fmwfqlaif`wf{jpwpnjggofFvqlsfdqltwkofdb`znbmmfqfmlvdk`bqffqbmptfqlqjdjmslqwbo`ojfmwpfof`wqbmgln`olpfgwlsj`p`lnjmdebwkfqlswjlmpjnsozqbjpfgfp`bsf`klpfm`kvq`kgfejmfqfbplm`lqmfqlvwsvwnfnlqzjeqbnfsloj`fnlgfopMvnafqgvqjmdleefqppwzofphjoofgojpwfg`boofgpjoufqnbqdjmgfofwfafwwfqaqltpfojnjwpDolabopjmdoftjgdfw`fmwfqavgdfwmltqbs`qfgjw`objnpfmdjmfpbefwz`klj`fpsjqjw.pwzofpsqfbgnbhjmdmffgfgqvppjbsofbpff{wfmwP`qjswaqlhfmbooltp`kbqdfgjujgfeb`wlqnfnafq.abpfgwkflqz`lmejdbqlvmgtlqhfgkfosfg@kvq`kjnsb`wpklvogbotbzpoldl!#alwwlnojpw!=*xubq#sqfej{lqbmdfKfbgfq-svpk+`lvsofdbqgfmaqjgdfobvm`kQfujftwbhjmdujpjlmojwwofgbwjmdAvwwlmafbvwzwkfnfpelqdlwPfbq`kbm`klqbonlpwolbgfg@kbmdfqfwvqmpwqjmdqfolbgNlajofjm`lnfpvssozPlvq`flqgfqpujftfg%maps8`lvqpfBalvw#jpobmg?kwno#`llhjfmbnf>!bnbylmnlgfqmbguj`fjm?,b=9#Wkf#gjboldklvpfpAFDJM#Nf{j`lpwbqwp`fmwqfkfjdkwbggjmdJpobmgbppfwpFnsjqfP`kllofeelqwgjqf`wmfbqoznbmvboPfof`w-		Lmfiljmfgnfmv!=SkjojsbtbqgpkbmgofjnslqwLeej`fqfdbqgphjoopmbwjlmPslqwpgfdqfftffhoz#+f-d-afkjmggl`wlqolddfgvmjwfg?,a=?,afdjmpsobmwpbppjpwbqwjpwjppvfg033s{`bmbgbbdfm`zp`kfnfqfnbjmAqbyjopbnsofoldl!=afzlmg.p`bofb``fswpfqufgnbqjmfEllwfq`bnfqb?,k2=	\\elqn!ofbufppwqfpp!#,=	-dje!#lmolbgolbgfqL{elqgpjpwfqpvqujuojpwfmefnbofGfpjdmpjyf>!bssfbowf{w!=ofufopwkbmhpkjdkfqelq`fgbmjnbobmzlmfBeqj`bbdqffgqf`fmwSflsof?aq#,=tlmgfqsqj`fpwvqmfg#x~8nbjm!=jmojmfpvmgbztqbs!=ebjofg`fmpvpnjmvwfafb`lmrvlwfp263s{fpwbwfqfnlwffnbjo!ojmhfgqjdkw8pjdmboelqnbo2-kwnopjdmvssqjm`feolbw9-smd!#elqvn-B``fppsbsfqpplvmgpf{wfmgKfjdkwpojgfqVWE.;!%bns8#Afelqf-#TjwkpwvgjlltmfqpnbmbdfsqlejwiRvfqzbmmvbosbqbnpalvdkwebnlvpdlldofolmdfqj((*#xjpqbfopbzjmdgf`jgfklnf!=kfbgfqfmpvqfaqbm`ksjf`fpaol`h8pwbwfgwls!=?qb`jmdqfpjyf..%dw8sb`jwzpf{vboavqfbv-isd!#23/333lawbjmwjwofpbnlvmw/#Jm`-`lnfgznfmv!#ozqj`pwlgbz-jmgffg`lvmwz\\oldl-EbnjozollhfgNbqhfwopf#jeSobzfqwvqhfz*8ubq#elqfpwdjujmdfqqlqpGlnbjm~fopfxjmpfqwAold?,ellwfqoldjm-ebpwfqbdfmwp?algz#23s{#3sqbdnbeqjgbzivmjlqgloobqsob`fg`lufqpsovdjm6/333#sbdf!=alpwlm-wfpw+bubwbqwfpwfg\\`lvmwelqvnpp`kfnbjmgf{/ejoofgpkbqfpqfbgfqbofqw+bssfbqPvanjwojmf!=algz!=	)#WkfWklvdkpffjmdifqpfzMftp?,ufqjezf{sfqwjmivqztjgwk>@llhjfPWBQW#b`qlpp\\jnbdfwkqfbgmbwjufsl`hfwal{!=	Pzpwfn#Gbujg`bm`fqwbaofpsqlufgBsqjo#qfboozgqjufqjwfn!=nlqf!=albqgp`lolqp`bnsvpejqpw##X^8nfgjb-dvjwbqejmjpktjgwk9pkltfgLwkfq#-sks!#bppvnfobzfqptjoplmpwlqfpqfojfeptfgfm@vpwlnfbpjoz#zlvq#Pwqjmd		Tkjowbzolq`ofbq9qfplqweqfm`kwklvdk!*#(#!?algz=avzjmdaqbmgpNfnafqmbnf!=lssjmdpf`wlq6s{8!=upsb`fslpwfqnbilq#`leeffnbqwjmnbwvqfkbssfm?,mbu=hbmpbpojmh!=Jnbdfp>ebopftkjof#kpsb`f3%bns8#		Jm##sltfqSlophj.`lolqilqgbmAlwwlnPwbqw#.`lvmw1-kwnomftp!=32-isdLmojmf.qjdkwnjoofqpfmjlqJPAM#33/333#dvjgfpubovf*f`wjlmqfsbjq-{no!##qjdkwp-kwno.aol`hqfdF{s9klufqtjwkjmujqdjmsklmfp?,wq=vpjmd#	\nubq#=$*8	\n?,wg=	?,wq=	abkbpbaqbpjodbofdlnbdzbqslophjpqsphj4]4C5d\bTA\nzk\vBl\bQ\vUmGx\bSM\nmC\bTA	wQ\nd}\bW@\bTl\bTF	i@	cT\vBM\v|jBV	qw	cC\bWI\npa	fM\n{Z{X\bTF\bVV\bVK	mkF	[]\bPm\bTv\nsI\vpg	[I\bQpmx\v_W\n^M\npe\vQ}\vGu\nel\npeChBV\bTA	So\nzk\vGL\vxD\nd[JzMY\bQpli\nfl\npC{BNt\vwT	i_\bTgQQ\n|p\vXN\bQS\vxDQC\bWZ	pD\vVS\bTWNtYh\nzuKjN}	wr	Ha\n_D	j`\vQ}\vWp\nxZ{c	ji	BU\nbDa|	Tn	pV\nZd\nmC\vEV{X	c}	To\bWl\bUd	IQ	cg\vxs\nXW	wR\vek	c}	]y	Jn\nrp\neg\npV\nz\\{W\npl\nz\\\nzU	Pc	`{\bV@\nc|\bRw	i_\bVb\nwX	HvSu\bTF\v_W\vWs\vsIm\nTT\ndc	US	}f	iZ\bWz	c}MD	Be	iD\v@@\bTl\bPv	}tSwM`\vnU	kW\ved\nqo\vxY	A|\bTz\vy`BRBM	iaXU\nyun^	fL	iI\nXW	fD\bWz\bW@	yj	m	av	BN\vb\\	pD\bTf\nY[	Jn\bQy	[^\vWc\vyuDlCJ\vWj\vHR	`V\vuW	Qy\np@\vGuplJm\bW[\nLP\nxC\n`m	wQuiR\nbI	wQ	BZ	WVBR\npg	cgtiCW\n_y	Rg\bQa\vQB\vWc\nYble\ngESu\nL[	Q	ea	dj\v]W\nb~M`	wL\bTV\bVH\nt\npl	|bs_\bU|\bTaoQlvSkM`\bTv\vK}\nfl	cCoQBR	Hk	|d\bQp	HK	BZ\vHR\bPv\vLx\vEZ\bT\bTv	iDoDMU\vwBSuk`St\ntC	Pl	Kg\noi	jY\vxYh}\nzk\bWZ	m\ve`	TB	fE\nzk	`zYh\nV|	HK	AJ	AJ\bUL	p\\	ql\nYcKd\nfyYh	[I\vDgJm\n]n\nlb\bUd\n{Z	lu	fsoQ\bTWJm\vwB	eaYhBC	sb	Tn\nzU\n_y\vxY	Q]\ngwmt	O\\\ntb\bWW\bQy	mI	V[\ny\\\naB\vRb	wQ\n]QQJ\bWg\vWa\bQj\ntC\bVH\nYm\vxs\bVK\nel\bWI\vxYCq\ntR\vHV\bTl\bVw	ay\bQa\bVV	}t	dj\nr|	p\\	wR\n{i\nTT	[I	i[	AJ\vxs\v_W	d{\vQ}	cg	Tz	A|	Cj\vLmN}m\nbK	dZ	p\\	`V	sV\np@	iD	wQ\vQ}\bTfkaJm\v@@\bV`	zp\n@NSw	iI	cg\noiSu\bVwloCy	c}\vb\\	sUBA\bWI\bTf\nxS	Vp\nd|\bTV\vbC	NoJu\nTC	|`\n{Z	D]\bU|	c}lm\bTl	Bv	Pl	c}\bQp	m\nLk	kj\n@NSbKO	j_	p\\\nzU\bTl\bTg\bWI	cfXO\bWW\ndzli	BN\nd[\bWOMD\vKC	dj	I_\bVV\ny\\\vLmxl	xB	kV\vb\\\vJW\vVS	Vx\vxD	d{MD\bTa	|`\vPzR}\vWsBM\nsICN\bTaJm\npe	i_\npV\nrh	Rd	Hv\n~A\nxR\vWh\vWk\nxS\vAz\vwX\nbIoQ	fw\nqI\nV|\nunz\vpg	d\\\voA{D	i_xB\bT	`Vqr	TTg]CA\vuR	VJ	T`\npw\vRb	I_\nCxRo\vsICjKh	Bv	WVBBoD{D\nhcKm\v^R	QE\n{I\np@\nc|Gt	c}Dl\nzUqN	sVk}	Hh\v|j\nqou|	Q]\vekZM`St\npe	dj\bVG\veE	m\vWc|I\n[W	fL\bT	BZSu\vKaCqNtY[\nqI\bTv	fM	i@	}fB\\	Qy\vBl\bWgXDkc\vx[\bVV	Q]	a	Py\vxD\nfI	}foD	dj	SGls	~DCN\n{Z	\\v\n_D\nhc\vx_C[	AJ\nLM	VxCI	bj	c^	cF\ntCSx	wrXA\bU\\	|a\vK\\\bTV\bVj\nd|	fsCX\ntb\bRw	Vx	AE	A|\bTNt\vDg	Vc\bTld@\npo	M	cF\npe	iZ	Bo\bSq\nfHl`\bTx\bWf	HE\vF{	cO	fD\nlm\vfZ\nlm\veU	dGBH\bTV	SiMW\nwX\nz\\	\\cCX\nd}	l}\bQp\bTV	F~\bQ	`i\ng@nO\bUd\bTl\nL[	wQ	ji\ntC	|J\nLU\naB\vxYKj	AJuN	i[\npeSk\vDg\vx]\bVb\bVV\nea	kV\nqI\bTaSk\nAO	pD\ntb\nts\nyi\bVg	i_\v_W\nLkNt	yj	fMR	iI\bTl\vwX	sV\vMl\nyu	AJ\bVjKO	WV\vA}\vW\nrp	iD\v|olv\vsIBM	d~	CU\bVbeV\npC\vwT	j`	c}\vxs\vps\vvh	WV\vGg\vAe\vVK\v]W	rg\vWcF`	Br\vb\\	dZ\bQp\nqIkF\nLk\vAR\bWI\bTg	bs	dw\n{L\n_y	iZ\bTA	lg\bVV\bTl	dk\n`k	a{	i_{Awj	wN\v@@\bTe	i_\n_D	wL\nAH\viK\vek\n[]	p_	yj\bTv	US	[r\n{I\npsGt\vVK\nplS}\vWP	|dMD\vHV\bTR}M`\bTV\bVHlvCh\bW[Ke	R{\v^R	ab	BZ	VA	B`\nd|\nhsKe	BeOi	R{	d\\nB\bWZ	dZ	VJOs	muQ\vhZQ@QQ\nfI\bW[B\\li\nzU\nMdM`\nxS\bVV\n\\}\vxD	m\bTpIS\nc|	kVi~	V{\vhZ	|b\bWt\n@R\voA\vnU\bWI	ea	B`	iD	c}	TzBR\vQBNj	CP	[I\bTv	`WuN\vpg\vpg\vWc	iT	bs	wL	U_	c\\	|h\vKa	Nr	fL\nq|\nzu\nz\\	Nr\bUg	|bm`\bTv\nyd\nrp\bWf	UXBV\nzk\nd}	wQ	}fCe\ved\bTW\bSB\nxU	cn\bTb\ne	a\\	SG\bU|\npV\nN\\Kn\vnU	At	pD\v^R\vIrb[	R{	dE\vxD\vWK\vWA\bQL\bW@Su\bUd\nDM	PcCADloQ	Hswiub\na\bQpOb\nLP\bTlY[\vK}	AJ\bQn^\vsA\bSM\nqM\bWZ\n^W\vz{S|	fD\bVK\bTv\bPvBB	CPdF	id\vxsmx\vws	cC\ntC	ycM`\vW\nrh\bQp\vxD\\o\nsI_k\nzukF	fDXsXO	jp\bTvBS{B	Br\nzQ\nbI	c{BDBVnO\bTF	caJd	fL	PV	I_\nlK`o	wX\npa	gu\bP}{^\bWf\n{I	BN\npaKl\vpg	cn	fL\vvhCq\bTl\vnU\bSqCm	wR\bUJ\npe\nyd\nYgCy\vKW	fD\neaoQ	j_	BvnM\vID\bTa\nzApl\n]n\bTa	R{	fr\n_y\bUg{Xkk\vxD|Ixl\nfyCe\vwB\nLk\vd]\noi\n}h	Q]\npe\bVwHkOQ\nzk	AJ\npV\bPv\ny\\	A{Oi\bSBXA\veE	jp\nq}	iDqN\v^R	m	iZ	Br\bVg\noi\n\\X	U_\nc|\vHV\bTf	Tn\\N\\N\nuBlv\nyu	Td\bTf\bPL\v]W	dG\nA`\nw^\ngI\npe	dw\nz\\ia\bWZ	cFJm\n{Z\bWO_kDfRR	d\\\bVV\vxsBNtilm	Td	]y\vHV	So\v|jXX	A|\vZ^\vGu\bTWM`kF\vhZ\vVK	dG\vBl	ay\nxUqEnO\bVw\nqICX\ne	Pl\bWO\vLm	dLuHCm	dTfn\vwBka\vnU\n@M\nyT	Hv	\\}Kh	d~Yhk}\neR	d\\\bWI	|b	HK	iD\bTWMY\npl\bQ_	wr\vAx	HE\bTg\bSqvp\vb\\\bWO\nOl\nsI\nfy\vID	\\c\n{Z\n^~\npe\nAO	TT\vxvk_\bWO\v|j\vwB	Qy	i@	Pl	Ha	dZk}ra	UT\vJc\ved\np@	QN\nd|	kj	HkM`\noi	wr	d\\\nlq\no_\nlb\nL[	acBBBHCm\npl	IQ\bVK\vxs\n`e\viK\npaOi	US\bTp	fD\nPGkkXA\nz\\\neg\vWh	wRqN\nqS	cnlo\nxS\n^W	BU\nt	HE	p\\	fF	fw\bVV\bW@	ak\vVKls	VJ\bVV\veE\\o\nyX\nYmM`lL\nd|\nzk	A{sE	wQXT\nt	Pl	]y\vwT{pMD\vb\\	Q]Kj	Jn\nAH\vRb	BU	HK	\\c\nfIm\nqM\n@R	So\noiBT	Hv\n_yKh	BZ	]i\bUJ	V{Sr\nbI\vGg	a_\bTR\nfI\nfl	[K	IIS|\vuW	iI\bWI\nqI\v|jBV\bVg\bWZkF\vx]\bTA	ab	fr	i@	Jd	Jd\vps\nAO\bTaxu	iD\nzk	|d	|`\bW[	lP	dG\bVV\vw}\vqO	i[\bQ\bTz\vVF	wNts	dw\bTv\neS\ngi	NryS\npe\bVV\bSq\n`m	yj	BZ\vWX\bSB	c\\\nUR	[J	c_nM\bWQ\vAx\nMd	Brui\vxY\bSM\vWc\v|j\vxs	}Q	BO\bPL\bWW	fM\nAO	Pc\veUe^\bTg\nqI	ac\bPv	cFoQ	Q\vhZka\nz\\	iK	BU\n`k	CPS|M`\n{I	S{_O	BZZiSk	ps	p\\\nYu\n]s\nxC\bWt\nbD	kV\vGuyS\nqA	[r\neKM`	dZlL\bUg\bTl\nbD	US\vb\\	pV\nccS\\	ct	`z\bPL\vWs\nA`\neg\bSquECR\vDg	`W\vz{\vWcSkSk	bW\bUg	ea\nxZ	iI	UX	VJ\nqn	S{\vRb\bTQ\nplGt\vuWuj\npF\nqI	fL	[I	iaXO\nyu\vDg\ved	q{VG\bQka	Vj	kV	xB\nd|\np@	QN	Pc	ps]j	kV	oU\bTp\nzUnB\vB]	a{\bV@\n]nm`	cz	R{m`\bQa\vwT\bSMMYqN	dj~s\vQ}MY\vMB	Bv	wR\bRg\vQ}	ql\vKC\nrmxuCC\vwB\vvh	BqXq\npV	i_ObuE\nbd\nqo\v{i\nC~	BL\veEuH\bVjEyGz\vzR\v{i	cf\n{Z\n]nXA\vGu\vnU	hS\vGI\nCc	HE\bTA	HBBHCj\nCc\bTF	HE\nXI	A{\bQ	c\\\vmO\vWX\nfH\np@MY\bTF\nlK	Bt\nzU	TTKm\vwT\npV\ndt\vyI	Vx	Q	Rg	Td\nzU\bRS\nLM	wAnM	Tn\ndS	]g\nLc\vwB	}t	[I	CPkX\vFm\vhZm	i[\np@\vQ}\vW	|d\nMO\nMd	f_	fD	cJ	Hz\vRb	io	PyY[\nxU	ct\v@@	ww\bPvBMFF\ntbv|\vKm	Bq	BqKh`o\nZdXU	i]	|`	StB\\\bQ\v_W	TJ\nqI	|a	A{\vuPMD	Pl\nxR	fL\vws	c{	d\\\bV`\neg	HKkc\nd|\bVV\ny\\kc	i]\bVG	`V	ss	I_	AE	bs	du\nel	pD\vW\nqslv\bSMZi\vVKia\vQB	Q\n{Z\bPt\vKl\nlK\nhs\ndS\bVKmf\nd^	kV	cO\nc|\bVH	\\]\bTv\bSq	mI\vDg	VJ	cn\ny\\\bVg\bTv\nyX\bTF	]]\bTp\noi\nhs\veU\nBf	djMr\n|p	\\g	]r\bVb{D\nd[XN	fM	O\\s_	cf	iZXN\vWc	qv\n`m	U^oD\nd|\vGg	dE\vwflou}\nd|oQ	`iOi\vxD\ndZ\nCxYw\nzk\ntb\ngw	yj	B`\nyX\vps\ntC\vpP\vqw\bPu\bPX	Dm\npwNj	ss	aG\vxs\bPt\noLGz	Ok	i@	i]eC	IQ	ii	dj\v@J	|duh\bWZ\veU\vnU\bTa	cCg]\nzkYh\bVK\nLU\np@\ntb\ntR	Cj\vNP	i@\bP{\n\\}\n{c\nwX	fL\bVG	c{	|`	AJ	|C	fDln	|d	bs\nqI{B\vAx\np@\nzk\vRbOs\vWSe^\vD_	Bv\vWd\bVb\vxs\veE\bRw\n]n\n|p\vg|	fwkc\bTIka\n\\TSp	ju\vps\npeu|\vGr\bVe	CU]MXU\vxD\bTa	IQ\vWq	CU	am	dj\bSoSw\vnUCh	Q]s_\bPt	fS\bTa	\\}\n@OYc	UZ\bTx\npe\vnU\nzU	|}	iD\nz\\\bSM\vxDBR\nzQ	QN]MYh\nLP\vFm\vLXvc\vqlka	HK\bVb\ntC\nCy\bTv\nuVoQ	`z	[I	B`\vRb	yj	sb\vWs\bTl	kV\ved\nelL\vxN	m\nJn	jY\vxD\bVb\bSq\vyu	wL\vXL\bTA	pg	At	nDXX	wR\npl\nhwyS\nps	cO\bW[\v|jXN	sV	p\\	Be\nb~\nAJ\n]ek`qN	dw	WV	HE\vEVJz	id	B`	zhE]	fD\bTgqN\bTa	jaCv\bSM\nhc\bUet_	ieg]	wQ\nPn\bVB	jw\bVg\vbE	BZ\vRH\bP{	jp\n\\}	a_	cC	|a\vD]	BZ	i[	fD\vxW\no_	d\\\n_D\ntb	\\c	AJ\nlKoQlo\vLx\vM@\bWZKn\vpg\nTi\nIv\n|r\v@}JzLmWhk}ln\vxD\n]sgc\vps	Br\bTW\vBMtZ\nBYDW	jf\vSWC}\nqo	dE	mv	IQ\bPP\bUblvBC\nzQ	[I\vgl\nig\bUsBT\vbC\bSq	sU	iW\nJn	SY	HK	rg\npV\vID\v|jKO	`S	|a`vbmglfmujbqnbgqjgavp`bqjmj`jlwjfnslslqrvf`vfmwbfpwbglsvfgfmivfdlp`lmwqbfpw/Mmmlnaqfwjfmfmsfqejonbmfqbbnjdlp`jvgbg`fmwqlbvmrvfsvfgfpgfmwqlsqjnfqsqf`jlpfd/Vmavfmlpuloufqsvmwlppfnbmbkba/Abbdlpwlmvfulpvmjglp`bqolpfrvjslmj/]lpnv`klpbodvmb`lqqfljnbdfmsbqwjqbqqjabnbq/Abklnaqffnsoflufqgbg`bnajlnv`kbpevfqlmsbpbglo/Amfbsbqf`fmvfubp`vqplpfpwbabrvjfqlojaqlp`vbmwlb``fplnjdvfoubqjlp`vbwqlwjfmfpdqvslppfq/Mmfvqlsbnfgjlpeqfmwfb`fq`bgfn/Mplefqwb`l`kfpnlgfoljwbojbofwqbpbod/Vm`lnsqb`vbofpf{jpwf`vfqslpjfmglsqfmpboofdbqujbifpgjmfqlnvq`jbslgq/Msvfpwlgjbqjlsvfaolrvjfqfnbmvfosqlsjl`qjpjp`jfqwlpfdvqlnvfqwfevfmwf`fqqbqdqbmgffef`wlsbqwfpnfgjgbsqlsjbleqf`fwjfqqbf.nbjoubqjbpelqnbpevwvqllaifwlpfdvjqqjfpdlmlqnbpnjpnlp/Vmj`l`bnjmlpjwjlpqby/_mgfajglsqvfabwlofglwfm/Abifp/Vpfpsfql`l`jmblqjdfmwjfmgb`jfmwl`/Mgjykbaobqpfq/Abobwjmbevfqybfpwjoldvfqqbfmwqbq/E{jwlo/_sfybdfmgbu/Agflfujwbqsbdjmbnfwqlpibujfqsbgqfpe/M`jo`bafyb/Mqfbppbojgbfmu/Alibs/_mbavplpajfmfpwf{wlpoofubqsvfgbmevfqwf`ln/Vm`obpfpkvnbmlwfmjglajoablvmjgbgfpw/Mpfgjwbq`qfbgl<X<W=c=k=n<R<V<\\<V<T<W<T=a=n<R<^=m<Y<Y<_<R<S=l<T=n<\\<V<Y=e<Y=o<Z<Y<v<\\<V<]<Y<[<]=g<W<R<Q<T<~=m<Y<S<R<X<A=n<R=n<R<P=k<Y<P<Q<Y=n<W<Y=n=l<\\<[<R<Q<\\<_<X<Y<P<Q<Y<x<W=c<s=l<T<Q<\\=m<Q<T=i=n<Y<P<V=n<R<_<R<X<^<R=n=n<\\<P<M<D<|<P<\\=c<K=n<R<^<\\=m<^<\\<P<Y<P=o<N<\\<V<X<^<\\<Q<\\<P=a=n<T=a=n=o<~<\\<P=n<Y=i<S=l<R=n=o=n<Q<\\<X<X<Q=c<~<R=n=n=l<T<Q<Y<U<~<\\=m<Q<T<P=m<\\<P=n<R=n=l=o<]<r<Q<T<P<T=l<Q<Y<Y<r<r<r<W<T=j=a=n<\\<r<Q<\\<Q<Y<P<X<R<P<P<R<U<X<^<Y<R<Q<R=m=o<X\fHy\fIk\fHU\fId\fHy\fIl\fHT\fIk\fHy\fHR\fHy\fIg\fHx\fH\\\fHF\fH\\\fHD\fIk\fHc\fHy\fHy\fHS\fHA\fIl\fHk\fHT\fHy\fH\\\fHH\fIg\fHU\fIg\fHj\fHF\fHU\fIl\fHC\fHU\fHC\fHR\fHH\fHy\fHI\fHRibdqbm\fHj\fHp\fHp\fIg\fHi\fH@\fHJ\fIg\fH{\fHd\fHp\fHR\fH{\fHc\fHU\fHB\fHk\fHD\fHY\fHU\fHC\fIk\fHI\fIk\fHI\fIl\fHt\fH\\\fHp\fH@\fHJ\fIl\fHy\fHd\fHp\fIl\fHY\fIk\fHD\fHd\fHD\fHc\fHU\fH\\\fHe\fHT\fHB\fIk\fHy\fHB\fHY\fIg\fH^\fIk\fHT\fH@\fHB\fHd\fHJ\fIk\fH\fH\\\fHj\fHB\fH@\fHT\fHA\fH\\\fH@\fHD\fHv\fH^\fHB\fHD\fHj\fH{\fHT\fIl\fH^\fIl4U5h5e4I5h5e5k4\\4K4N4B4]4U4C4C4K5h5e5k4\\5k4Y5d4]4V5f4]5o4K5j5d5h4K4D5f5j4U4]4Z4\\5h5o5k5j4K5f5d5i5n4K5h4U5h5f4K5j4K5h5o5j4A4F5e5n4D5h5d4A4E4K4B4]5m5n4[4U4D4C4]5o5j4I4\\4K5o5i4K4K4A4C4I5h4K5m5f5k4D4U4Z5o5f5m4D4A4G5d5i5j5d5k5d4O5j4K4@4C4K5h5k4K4_5h5i4U5j4C5h5f4_4U4D4]4Y5h5e5i5j4\\4D5k4K4O5j5k5i4G5h5o5j4F4K5h4K4A5f4G5i4Y4]4X4]4A4A5d5h5d5m5f4K4\\4K5h5o5h5i4]4E4K5j4F4K5h5m4O4D5d4B4K4Y4O5j4F4K5j5k4K5h5f4U4Z5d5d5n4C4K4D5j4B5f4]4D5j4F5h5o5i4X4K4M5d5k5f4K4D5d5n4Y4Y5d5i4K4]5n5i4O4A4C5j4A5j4U4C5i4]4O5f4K4A4E5o4F4D4C5d5j5f4@4D5i5j5k4F4A4F4@5k4E4_5j4E5f4F5i5o4]4E4V4^4E5j5m4_4D5f4F5h5h5k5h5j4K4F5h5o5n5h4D5h5i4K4U5j5k4O5d5h4X5f4M5j5d4]4O5i4K5m5f5o4D5o5h4\\4K4F4]4F4D4D4O5j5k5i4_4K5j5o4D5f4U5m5n4C4A4_5j5h5k5i4X4U4]4O5k5h4X5k4]5n4[4]4[5h4Dsqlejofpfquj`fgfebvowkjnpfoegfwbjop`lmwfmwpvsslqwpwbqwfgnfppbdfpv``fppebpkjlm?wjwof=`lvmwqzb``lvmw`qfbwfgpwlqjfpqfpvowpqvmmjmdsql`fpptqjwjmdlaif`wpujpjaoftfo`lnfbqwj`ofvmhmltmmfwtlqh`lnsbmzgzmbnj`aqltpfqsqjub`zsqlaofnPfquj`fqfpsf`wgjpsobzqfrvfpwqfpfquftfapjwfkjpwlqzeqjfmgplswjlmptlqhjmdufqpjlmnjoojlm`kbmmfotjmglt-bggqfppujpjwfgtfbwkfq`lqqf`wsqlgv`wfgjqf`welqtbqgzlv#`bmqfnlufgpvaif`w`lmwqlobq`kjuf`vqqfmwqfbgjmdojaqbqzojnjwfgnbmbdfqevqwkfqpvnnbqznb`kjmfnjmvwfpsqjubwf`lmwf{wsqldqbnpl`jfwzmvnafqptqjwwfmfmbaofgwqjddfqplvq`fpolbgjmdfofnfmwsbqwmfqejmboozsfqef`wnfbmjmdpzpwfnphffsjmd`vowvqf%rvlw8/ilvqmbosqlif`wpvqeb`fp%rvlw8f{sjqfpqfujftpabobm`fFmdojpk@lmwfmwwkqlvdkSofbpf#lsjmjlm`lmwb`wbufqbdfsqjnbqzujoobdfPsbmjpkdboofqzgf`ojmfnffwjmdnjppjlmslsvobqrvbojwznfbpvqfdfmfqbopsf`jfppfppjlmpf`wjlmtqjwfqp`lvmwfqjmjwjboqfslqwpejdvqfpnfnafqpklogjmdgjpsvwffbqojfqf{sqfppgjdjwbosj`wvqfBmlwkfqnbqqjfgwqbeej`ofbgjmd`kbmdfg`fmwqbouj`wlqzjnbdfp,qfbplmppwvgjfpefbwvqfojpwjmdnvpw#afp`kllopUfqpjlmvpvboozfsjplgfsobzjmddqltjmdlaujlvplufqobzsqfpfmwb`wjlmp?,vo=	tqbssfqboqfbgz`fqwbjmqfbojwzpwlqbdfbmlwkfqgfphwlsleefqfgsbwwfqmvmvpvboGjdjwbo`bsjwboTfapjwfebjovqf`lmmf`wqfgv`fgBmgqljggf`bgfpqfdvobq#%bns8#bmjnbopqfofbpfBvwlnbwdfwwjmdnfwklgpmlwkjmdSlsvobq`bswjlmofwwfqp`bswvqfp`jfm`foj`fmpf`kbmdfpFmdobmg>2%bns8Kjpwlqz#>#mft#@fmwqbovsgbwfgPsf`jboMfwtlqhqfrvjqf`lnnfmwtbqmjmd@loofdfwlloabqqfnbjmpaf`bvpffof`wfgGfvwp`kejmbm`ftlqhfqprvj`hozafwtffmf{b`wozpfwwjmdgjpfbpfPl`jfwztfbslmpf{kjajw%ow8"..@lmwqlo`obppfp`lufqfglvwojmfbwwb`hpgfuj`fp+tjmgltsvqslpfwjwof>!Nlajof#hjoojmdpkltjmdJwbojbmgqlssfgkfbujozfeef`wp.2$^*8	`lmejqn@vqqfmwbgubm`fpkbqjmdlsfmjmdgqbtjmdajoojlmlqgfqfgDfqnbmzqfobwfg?,elqn=jm`ovgftkfwkfqgfejmfgP`jfm`f`bwboldBqwj`ofavwwlmpobqdfpwvmjelqnilvqmfzpjgfabq@kj`bdlklojgbzDfmfqbosbppbdf/%rvlw8bmjnbwfeffojmdbqqjufgsbppjmdmbwvqboqlvdkoz-		Wkf#avw#mlwgfmpjwzAqjwbjm@kjmfpfob`h#lewqjavwfJqfobmg!#gbwb.eb`wlqpqf`fjufwkbw#jpOjaqbqzkvpabmgjm#eb`wbeebjqp@kbqofpqbgj`boaqlvdkwejmgjmdobmgjmd9obmd>!qfwvqm#ofbgfqpsobmmfgsqfnjvnsb`hbdfBnfqj`bFgjwjlm^%rvlw8Nfppbdfmffg#wlubovf>!`lnsof{ollhjmdpwbwjlmafojfufpnboofq.nlajofqf`lqgptbmw#wlhjmg#leEjqfel{zlv#bqfpjnjobqpwvgjfgnb{jnvnkfbgjmdqbsjgoz`ojnbwfhjmdglnfnfqdfgbnlvmwpelvmgfgsjlmffqelqnvobgzmbpwzklt#wl#Pvsslqwqfufmvff`lmlnzQfpvowpaqlwkfqplogjfqobqdfoz`boojmd-%rvlw8B``lvmwFgtbqg#pfdnfmwQlafqw#feelqwpSb`jej`ofbqmfgvs#tjwkkfjdkw9tf#kbufBmdfofpmbwjlmp\\pfbq`kbssojfgb`rvjqfnbppjufdqbmwfg9#ebopfwqfbwfgajddfpwafmfejwgqjujmdPwvgjfpnjmjnvnsfqkbspnlqmjmdpfoojmdjp#vpfgqfufqpfubqjbmw#qlof>!njppjmdb`kjfufsqlnlwfpwvgfmwplnflmff{wqfnfqfpwlqfalwwln9fuloufgboo#wkfpjwfnbsfmdojpktbz#wl##Bvdvpwpznalop@lnsbmznbwwfqpnvpj`bobdbjmpwpfqujmd~*+*8	sbznfmwwqlvaof`lm`fsw`lnsbqfsbqfmwpsobzfqpqfdjlmpnlmjwlq#$$Wkf#tjmmjmdf{solqfbgbswfgDboofqzsqlgv`fbajojwzfmkbm`f`bqffqp*-#Wkf#`loof`wPfbq`k#bm`jfmwf{jpwfgellwfq#kbmgofqsqjmwfg`lmplofFbpwfqmf{slqwptjmgltp@kbmmfojoofdbomfvwqbopvddfpw\\kfbgfqpjdmjmd-kwno!=pfwwofgtfpwfqm`bvpjmd.tfahjw`objnfgIvpwj`f`kbswfquj`wjnpWklnbp#nlyjoobsqlnjpfsbqwjfpfgjwjlmlvwpjgf9ebopf/kvmgqfgLoznsj`\\avwwlmbvwklqpqfb`kfg`kqlmj`gfnbmgppf`lmgpsqlwf`wbglswfgsqfsbqfmfjwkfqdqfbwozdqfbwfqlufqboojnsqluf`lnnbmgpsf`jbopfbq`k-tlqpkjsevmgjmdwklvdkwkjdkfpwjmpwfbgvwjojwzrvbqwfq@vowvqfwfpwjmd`ofbqozf{slpfgAqltpfqojafqbo~#`bw`kSqlif`wf{bnsofkjgf+*8EolqjgbbmptfqpbooltfgFnsfqlqgfefmpfpfqjlvpeqffglnPfufqbo.avwwlmEvqwkfqlvw#le#">#mvoowqbjmfgGfmnbqhuljg+3*,boo-ipsqfufmwQfrvfpwPwfskfm		Tkfm#lapfquf?,k1=	Nlgfqm#sqlujgf!#bow>!alqgfqp-		Elq#		Nbmz#bqwjpwpsltfqfgsfqelqnej`wjlmwzsf#lenfgj`bowj`hfwplsslpfg@lvm`jotjwmfppivpwj`fDflqdf#Afodjvn---?,b=wtjwwfqmlwbaoztbjwjmdtbqebqf#Lwkfq#qbmhjmdskqbpfpnfmwjlmpvqujufp`klobq?,s=	#@lvmwqzjdmlqfgolpp#leivpw#bpDflqdjbpwqbmdf?kfbg=?pwlssfg2$^*8	jpobmgpmlwbaofalqgfq9ojpw#le`bqqjfg233/333?,k0=	#pfufqboaf`lnfppfof`w#tfggjmd33-kwnonlmbq`klee#wkfwfb`kfqkjdkoz#ajloldzojef#lelq#fufmqjpf#le%qbrvl8sovplmfkvmwjmd+wklvdkGlvdobpiljmjmd`jq`ofpElq#wkfBm`jfmwUjfwmbnufkj`ofpv`k#bp`qzpwboubovf#>Tjmgltpfmilzfgb#pnboobppvnfg?b#jg>!elqfjdm#Boo#qjklt#wkfGjpsobzqfwjqfgkltfufqkjggfm8abwwofppffhjmd`bajmfwtbp#mlwollh#bw`lmgv`wdfw#wkfIbmvbqzkbssfmpwvqmjmdb9klufqLmojmf#Eqfm`k#ob`hjmdwzsj`bof{wqb`wfmfnjfpfufm#jedfmfqbwgf`jgfgbqf#mlw,pfbq`kafojfep.jnbdf9ol`bwfgpwbwj`-oldjm!=`lmufqwujlofmwfmwfqfgejqpw!=`jq`vjwEjmobmg`kfnjpwpkf#tbp23s{8!=bp#pv`kgjujgfg?,psbm=tjoo#afojmf#leb#dqfbwnzpwfqz,jmgf{-eboojmdgvf#wl#qbjotbz`loofdfnlmpwfqgfp`fmwjw#tjwkmv`ofbqIftjpk#sqlwfpwAqjwjpkeoltfqpsqfgj`wqfelqnpavwwlm#tkl#tbpof`wvqfjmpwbmwpvj`jgfdfmfqj`sfqjlgpnbqhfwpPl`jbo#ejpkjmd`lnajmfdqbskj`tjmmfqp?aq#,=?az#wkf#MbwvqboSqjub`z`llhjfplvw`lnfqfploufPtfgjpkaqjfeozSfqpjbmpl#nv`k@fmwvqzgfsj`wp`lovnmpklvpjmdp`qjswpmf{w#wlafbqjmdnbssjmdqfujpfgiRvfqz+.tjgwk9wjwof!=wllowjsPf`wjlmgfpjdmpWvqhjpkzlvmdfq-nbw`k+~*+*8		avqmjmdlsfqbwfgfdqffpplvq`f>Qj`kbqg`olpfozsobpwj`fmwqjfp?,wq=	`lolq9 vo#jg>!slppfppqloojmdskzpj`pebjojmdf{f`vwf`lmwfpwojmh#wlGfebvow?aq#,=	9#wqvf/`kbqwfqwlvqjpn`obppj`sql`ffgf{sobjm?,k2=	lmojmf-<{no#ufkfosjmdgjbnlmgvpf#wkfbjqojmffmg#..=*-bwwq+qfbgfqpklpwjmd eeeeeeqfbojyfUjm`fmwpjdmbop#pq`>!,Sqlgv`wgfpsjwfgjufqpfwfoojmdSvaoj`#kfog#jmIlpfsk#wkfbwqfbeef`wp?pwzof=b#obqdfglfpm$wobwfq/#Fofnfmwebuj`lm`qfbwlqKvmdbqzBjqslqwpff#wkfpl#wkbwNj`kbfoPzpwfnpSqldqbnp/#bmg##tjgwk>f%rvlw8wqbgjmdofew!=	sfqplmpDlogfm#Beebjqpdqbnnbqelqnjmdgfpwqlzjgfb#le`bpf#lelogfpw#wkjp#jp-pq`#>#`bqwllmqfdjpwq@lnnlmpNvpojnpTkbw#jpjm#nbmznbqhjmdqfufbopJmgffg/frvbooz,pklt\\blvwgllqfp`bsf+Bvpwqjbdfmfwj`pzpwfn/Jm#wkf#pjwwjmdKf#boplJpobmgpB`bgfnz	\n\n?"..Gbmjfo#ajmgjmdaol`h!=jnslpfgvwjojyfBaqbkbn+f{`fswxtjgwk9svwwjmd*-kwno+#X^8	GBWBX#)hjw`kfmnlvmwfgb`wvbo#gjbof`wnbjmoz#\\aobmh$jmpwboof{sfqwpje+wzsfJw#bopl%`lsz8#!=Wfqnpalqm#jmLswjlmpfbpwfqmwbohjmd`lm`fqmdbjmfg#lmdljmdivpwjez`qjwj`peb`wlqzjwp#ltmbppbvowjmujwfgobpwjmdkjp#ltmkqfe>!,!#qfo>!gfufols`lm`fqwgjbdqbngloobqp`ovpwfqsks<jg>bo`lklo*8~*+*8vpjmd#b=?psbm=ufppfopqfujuboBggqfppbnbwfvqbmgqljgboofdfgjoomfpptbohjmd`fmwfqprvbojeznbw`kfpvmjejfgf{wjm`wGfefmpfgjfg#jm	\n?"..#`vpwlnpojmhjmdOjwwof#Allh#lefufmjmdnjm-ip<bqf#wkfhlmwbhwwlgbz$p-kwno!#wbqdfw>tfbqjmdBoo#Qjd8	~*+*8qbjpjmd#Bopl/#`qv`jbobalvw!=gf`obqf..=	?p`ejqfel{bp#nv`kbssojfpjmgf{/#p/#avw#wzsf#>#		?"..wltbqgpQf`lqgpSqjubwfElqfjdmSqfnjfq`klj`fpUjqwvboqfwvqmp@lnnfmwSltfqfgjmojmf8slufqwz`kbnafqOjujmd#ulovnfpBmwklmzoldjm!#QfobwfgF`lmlnzqfb`kfp`vwwjmddqbujwzojef#jm@kbswfq.pkbgltMlwbaof?,wg=	#qfwvqmpwbgjvntjgdfwpubqzjmdwqbufopkfog#aztkl#bqftlqh#jmeb`vowzbmdvobqtkl#kbgbjqslqwwltm#le		Plnf#$`oj`h$`kbqdfphfztlqgjw#tjoo`jwz#le+wkjp*8Bmgqft#vmjrvf#`kf`hfglq#nlqf033s{8#qfwvqm8qpjlm>!sovdjmptjwkjm#kfqpfoePwbwjlmEfgfqboufmwvqfsvaojpkpfmw#wlwfmpjlmb`wqfpp`lnf#wlejmdfqpGvhf#lesflsof/f{soljwtkbw#jpkbqnlmzb#nbilq!9!kwwsjm#kjp#nfmv!=	nlmwkozleej`fq`lvm`jodbjmjmdfufm#jmPvnnbqzgbwf#leolzbowzejwmfppbmg#tbpfnsfqlqpvsqfnfPf`lmg#kfbqjmdQvppjbmolmdfpwBoafqwbobwfqbopfw#le#pnboo!=-bssfmggl#tjwkefgfqboabmh#leafmfbwkGfpsjwf@bsjwbodqlvmgp*/#bmg#sfq`fmwjw#eqln`olpjmd`lmwbjmJmpwfbgejewffmbp#tfoo-zbkll-qfpslmgejdkwfqlap`vqfqfeof`wlqdbmj`>#Nbwk-fgjwjmdlmojmf#sbggjmdb#tkloflmfqqlqzfbq#lefmg#le#abqqjfqtkfm#jwkfbgfq#klnf#leqfpvnfgqfmbnfgpwqlmd=kfbwjmdqfwbjmp`olvgeqtbz#le#Nbq`k#2hmltjmdjm#sbqwAfwtffmofpplmp`olpfpwujqwvboojmhp!=`qlppfgFMG#..=ebnlvp#btbqgfgOj`fmpfKfbowk#ebjqoz#tfbowkznjmjnboBeqj`bm`lnsfwfobafo!=pjmdjmdebqnfqpAqbpjo*gjp`vppqfsob`fDqfdlqzelmw#`lsvqpvfgbssfbqpnbhf#vsqlvmgfgalwk#leaol`hfgpbt#wkfleej`fp`lolvqpje+gl`vtkfm#kffmelq`fsvpk+evBvdvpw#VWE.;!=Ebmwbpzjm#nlpwjmivqfgVpvboozebqnjmd`olpvqflaif`w#gfefm`fvpf#le#Nfgj`bo?algz=	fujgfmwaf#vpfghfz@lgfpj{wffmJpobnj` 333333fmwjqf#tjgfoz#b`wjuf#+wzsflelmf#`bm`lolq#>psfbhfqf{wfmgpSkzpj`pwfqqbjm?walgz=evmfqboujftjmdnjggof#`qj`hfwsqlskfwpkjewfggl`wlqpQvppfoo#wbqdfw`lnsb`wbodfaqbpl`jbo.avoh#lenbm#bmg?,wg=	#kf#ofew*-ubo+*ebopf*8oldj`boabmhjmdklnf#wlmbnjmd#Bqjylmb`qfgjwp*8	~*8	elvmgfqjm#wvqm@loojmpafelqf#Avw#wkf`kbqdfgWjwof!=@bswbjmpsfoofgdlggfppWbd#..=Bggjmd9avw#tbpQf`fmw#sbwjfmwab`h#jm>ebopf%Ojm`lomtf#hmlt@lvmwfqIvgbjpnp`qjsw#bowfqfg$^*8	##kbp#wkfvm`ofbqFufmw$/alwk#jmmlw#boo		?"..#sob`jmdkbqg#wl#`fmwfqplqw#le`ojfmwppwqffwpAfqmbqgbppfqwpwfmg#wlebmwbpzgltm#jmkbqalvqEqffglniftfoqz,balvw--pfbq`kofdfmgpjp#nbgfnlgfqm#lmoz#lmlmoz#wljnbdf!#ojmfbq#sbjmwfqbmg#mlwqbqfoz#b`qlmzngfojufqpklqwfq33%bns8bp#nbmztjgwk>!,)#?"X@wjwof#>le#wkf#oltfpw#sj`hfg#fp`bsfgvpfp#lesflsofp#Svaoj`Nbwwkftwb`wj`pgbnbdfgtbz#elqobtp#lefbpz#wl#tjmgltpwqlmd##pjnsof~`bw`k+pfufmwkjmelal{tfmw#wlsbjmwfg`jwjyfmJ#glm$wqfwqfbw-#Plnf#tt-!*8	alnajmdnbjowl9nbgf#jm-#Nbmz#`bqqjfpx~8tjtlqh#lepzmlmzngfefbwpebulqfglswj`bosbdfWqbvmofpp#pfmgjmdofew!=?`lnP`lqBoo#wkfiRvfqz-wlvqjpw@obppj`ebopf!#Tjokfonpvavqapdfmvjmfajpklsp-psojw+dolabo#elooltpalgz#lemlnjmbo@lmwb`wpf`vobqofew#wl`kjfeoz.kjggfm.abmmfq?,oj=		-#Tkfm#jm#alwkgjpnjppF{solqfbotbzp#ujb#wkfpsb/]lotfoebqfqvojmd#bqqbmdf`bswbjmkjp#plmqvof#lekf#wllhjwpfoe/>3%bns8+`boofgpbnsofpwl#nbhf`ln,sbdNbqwjm#Hfmmfgzb``fswpevoo#lekbmgofgAfpjgfp,,..=?,baof#wlwbqdfwpfppfm`fkjn#wl#jwp#az#`lnnlm-njmfqbowl#wbhftbzp#wlp-lqd,obgujpfgsfmbowzpjnsof9je#wkfzOfwwfqpb#pklqwKfqafqwpwqjhfp#dqlvsp-ofmdwkeojdkwplufqobspoltoz#ofppfq#pl`jbo#?,s=	\n\njw#jmwlqbmhfg#qbwf#levo=	##bwwfnswsbjq#lenbhf#jwHlmwbhwBmwlmjlkbujmd#qbwjmdp#b`wjufpwqfbnpwqbssfg!*-`pp+klpwjofofbg#wlojwwof#dqlvsp/Sj`wvqf..=		#qltp>!#laif`wjmufqpf?ellwfq@vpwlnU=?_,p`qploujmd@kbnafqpobufqztlvmgfgtkfqfbp">#$vmgelq#boosbqwoz#.qjdkw9Bqbajbmab`hfg#`fmwvqzvmjw#lenlajof.Fvqlsf/jp#klnfqjph#legfpjqfg@ojmwlm`lpw#lebdf#le#af`lnf#mlmf#les%rvlw8Njggof#fbg$*X3@qjwj`ppwvgjlp=%`lsz8dqlvs!=bppfnaonbhjmd#sqfppfgtjgdfw-sp9!#<#qfavjowaz#plnfElqnfq#fgjwlqpgfobzfg@bmlmj`kbg#wkfsvpkjmd`obpp>!avw#bqfsbqwjboAbazolmalwwln#`bqqjfq@lnnbmgjwp#vpfBp#tjwk`lvqpfpb#wkjqggfmlwfpbopl#jmKlvpwlm13s{8!=b``vpfgglvaof#dlbo#leEbnlvp#*-ajmg+sqjfpwp#Lmojmfjm#Ivozpw#(#!d`lmpvowgf`jnbokfosevoqfujufgjp#ufqzq$($jswolpjmd#efnbofpjp#boplpwqjmdpgbzp#lebqqjuboevwvqf#?laif`welq`jmdPwqjmd+!#,=	\n\nkfqf#jpfm`lgfg-##Wkf#aboollmglmf#az,`lnnlmad`lolqobt#le#Jmgjbmbbuljgfgavw#wkf1s{#0s{irvfqz-bewfq#bsloj`z-nfm#bmgellwfq.>#wqvf8elq#vpfp`qffm-Jmgjbm#jnbdf#>ebnjoz/kwws9,,#%maps8gqjufqpfwfqmbopbnf#bpmlwj`fgujftfqp~*+*8	#jp#nlqfpfbplmpelqnfq#wkf#mftjp#ivpw`lmpfmw#Pfbq`ktbp#wkftkz#wkfpkjssfgaq=?aq=tjgwk9#kfjdkw>nbgf#le`vjpjmfjp#wkbwb#ufqz#Bgnjqbo#ej{fg8mlqnbo#NjppjlmSqfpp/#lmwbqjl`kbqpfwwqz#wl#jmubgfg>!wqvf!psb`jmdjp#nlpwb#nlqf#wlwboozeboo#le~*8	##jnnfmpfwjnf#jmpfw#lvwpbwjpezwl#ejmggltm#wlolw#le#Sobzfqpjm#Ivmfrvbmwvnmlw#wkfwjnf#wlgjpwbmwEjmmjpkpq`#>#+pjmdof#kfos#leDfqnbm#obt#bmgobafofgelqfpwp`llhjmdpsb`f!=kfbgfq.tfoo#bpPwbmofzaqjgdfp,dolabo@qlbwjb#Balvw#X3^8	##jw/#bmgdqlvsfgafjmd#b*xwkqltkf#nbgfojdkwfqfwkj`boEEEEEE!alwwln!ojhf#b#fnsolzpojuf#jmbp#pffmsqjmwfqnlpw#leva.ojmhqfif`wpbmg#vpfjnbdf!=pv``ffgeffgjmdMv`ofbqjmelqnbwl#kfosTlnfm$pMfjwkfqNf{j`bmsqlwfjm?wbaof#az#nbmzkfbowkzobtpvjwgfujpfg-svpk+xpfoofqppjnsoz#Wkqlvdk-`llhjf#Jnbdf+logfq!=vp-ip!=#Pjm`f#vmjufqpobqdfq#lsfm#wl"..#fmgojfp#jm$^*8	##nbqhfwtkl#jp#+!GLN@lnbmbdfglmf#elqwzsfle#Hjmdglnsqlejwpsqlslpfwl#pklt`fmwfq8nbgf#jwgqfppfgtfqf#jmnj{wvqfsqf`jpfbqjpjmdpq`#>#$nbhf#b#pf`vqfgAbswjpwulwjmd#	\n\nubq#Nbq`k#1dqft#vs@ojnbwf-qfnlufphjoofgtbz#wkf?,kfbg=eb`f#leb`wjmd#qjdkw!=wl#tlqhqfgv`fpkbp#kbgfqf`wfgpklt+*8b`wjlm>allh#lebm#bqfb>>#!kww?kfbgfq	?kwno=`lmelqneb`jmd#`llhjf-qfoz#lmklpwfg#-`vpwlnkf#tfmwavw#elqpsqfbg#Ebnjoz#b#nfbmplvw#wkfelqvnp-ellwbdf!=Nlajo@ofnfmwp!#jg>!bp#kjdkjmwfmpf..=?"..efnbof#jp#pffmjnsojfgpfw#wkfb#pwbwfbmg#kjpebpwfpwafpjgfpavwwlm\\alvmgfg!=?jnd#Jmelal{fufmwp/b#zlvmdbmg#bqfMbwjuf#`kfbsfqWjnflvwbmg#kbpfmdjmfptlm#wkf+nlpwozqjdkw9#ejmg#b#.alwwlnSqjm`f#bqfb#lenlqf#lepfbq`k\\mbwvqf/ofdboozsfqjlg/obmg#lelq#tjwkjmgv`fgsqlujmdnjppjofol`boozBdbjmpwwkf#tbzh%rvlw8s{8!=	svpkfg#babmglmmvnfqbo@fqwbjmJm#wkjpnlqf#jmlq#plnfmbnf#jpbmg/#jm`qltmfgJPAM#3.`qfbwfpL`wlafqnbz#mlw`fmwfq#obwf#jmGfefm`ffmb`wfgtjpk#wlaqlbgoz`llojmdlmolbg>jw-#Wkfqf`lufqNfnafqpkfjdkw#bppvnfp?kwno=	sflsof-jm#lmf#>tjmgltellwfq\\b#dllg#qfhobnblwkfqp/wl#wkjp\\`llhjfsbmfo!=Olmglm/gfejmfp`qvpkfgabswjpn`lbpwbopwbwvp#wjwof!#nluf#wlolpw#jmafwwfq#jnsojfpqjuboqzpfqufqp#PzpwfnSfqkbspfp#bmg#`lmwfmgeoltjmdobpwfg#qjpf#jmDfmfpjpujft#leqjpjmd#pffn#wlavw#jm#ab`hjmdkf#tjoodjufm#bdjujmd#`jwjfp-eolt#le#Obwfq#boo#avwKjdktbzlmoz#azpjdm#lekf#glfpgjeefqpabwwfqz%bns8obpjmdofpwkqfbwpjmwfdfqwbhf#lmqfevpfg`boofg#>VP%bnsPff#wkfmbwjufpaz#wkjppzpwfn-kfbg#le9klufq/ofpajbmpvqmbnfbmg#boo`lnnlm,kfbgfq\\\\sbqbnpKbqubqg,sj{fo-qfnlubopl#olmdqlof#leiljmwozphzp`qbVmj`lgfaq#,=	Bwobmwbmv`ofvp@lvmwz/svqfoz#`lvmw!=fbpjoz#avjog#blm`oj`hb#djufmsljmwfqk%rvlw8fufmwp#fopf#x	gjwjlmpmlt#wkf/#tjwk#nbm#tkllqd,Tfalmf#bmg`buboqzKf#gjfgpfbwwof33/333#xtjmgltkbuf#wlje+tjmgbmg#jwpplofoz#n%rvlw8qfmftfgGfwqljwbnlmdpwfjwkfq#wkfn#jmPfmbwlqVp?,b=?Hjmd#leEqbm`jp.sqlgv`kf#vpfgbqw#bmgkjn#bmgvpfg#azp`lqjmdbw#klnfwl#kbufqfobwfpjajojwzeb`wjlmAveebolojmh!=?tkbw#kfeqff#wl@jwz#le`lnf#jmpf`wlqp`lvmwfglmf#gbzmfqulvpprvbqf#~8je+dljm#tkbwjnd!#bojp#lmozpfbq`k,wvfpgbzollpfozPlolnlmpf{vbo#.#?b#kqnfgjvn!GL#MLW#Eqbm`f/tjwk#b#tbq#bmgpf`lmg#wbhf#b#=			nbqhfw-kjdktbzglmf#jm`wjujwz!obpw!=laojdfgqjpf#wl!vmgfejnbgf#wl#Fbqoz#sqbjpfgjm#jwp#elq#kjpbwkofwfIvsjwfqZbkll"#wfqnfg#pl#nbmzqfbooz#p-#Wkf#b#tlnbm<ubovf>gjqf`w#qjdkw!#aj`z`ofb`jmd>!gbz#bmgpwbwjmdQbwkfq/kjdkfq#Leej`f#bqf#mltwjnfp/#tkfm#b#sbz#elqlm#wkjp.ojmh!=8alqgfqbqlvmg#bmmvbo#wkf#Mftsvw#wkf-`ln!#wbhjm#wlb#aqjfe+jm#wkfdqlvsp-8#tjgwkfmyznfppjnsof#jm#obwfxqfwvqmwkfqbszb#sljmwabmmjmdjmhp!=	+*8!#qfb#sob`f_v330@bbalvw#bwq=	\n\n``lvmw#djufp#b?P@QJSWQbjotbzwkfnfp,wlloal{AzJg+!{kvnbmp/tbw`kfpjm#plnf#je#+tj`lnjmd#elqnbwp#Vmgfq#avw#kbpkbmgfg#nbgf#azwkbm#jmefbq#legfmlwfg,jeqbnfofew#jmulowbdfjm#fb`kb%rvlw8abpf#leJm#nbmzvmgfqdlqfdjnfpb`wjlm#?,s=	?vpwlnUb8%dw8?,jnslqwplq#wkbwnlpwoz#%bns8qf#pjyf>!?,b=?,kb#`obppsbppjufKlpw#>#TkfwkfqefqwjofUbqjlvp>X^8+ev`bnfqbp,=?,wg=b`wp#bpJm#plnf=		?"lqdbmjp#?aq#,=Afjijmd`bwbo/Lgfvwp`kfvqlsfvfvphbqbdbfjodfpufmphbfpsb/]bnfmpbifvpvbqjlwqbabiln/E{j`ls/Mdjmbpjfnsqfpjpwfnbl`wvaqfgvqbmwfb/]bgjqfnsqfpbnlnfmwlmvfpwqlsqjnfqbwqbu/Epdqb`jbpmvfpwqbsql`fplfpwbglp`bojgbgsfqplmbm/Vnfqlb`vfqgln/Vpj`bnjfnaqllefqwbpbodvmlpsb/Apfpfifnsolgfqf`klbgfn/Mpsqjubglbdqfdbqfmob`fpslpjaofklwfofppfujoobsqjnfql/Vowjnlfufmwlpbq`kjul`vowvqbnvifqfpfmwqbgbbmvm`jlfnabqdlnfq`bgldqbmgfpfpwvgjlnfilqfpefaqfqlgjpf/]lwvqjpnl`/_gjdlslqwbgbfpsb`jlebnjojbbmwlmjlsfqnjwfdvbqgbqbodvmbpsqf`jlpbodvjfmpfmwjglujpjwbpw/Awvol`lml`fqpfdvmgl`lmpfileqbm`jbnjmvwlppfdvmgbwfmfnlpfef`wlpn/Mobdbpfpj/_mqfujpwbdqbmbgb`lnsqbqjmdqfpldbq`/Abb``j/_mf`vbglqrvjfmfpjm`ovplgfafq/Mnbwfqjbklnaqfpnvfpwqbslgq/Abnb/]bmb/Vowjnbfpwbnlplej`jbowbnajfmmjmd/Vmpbovglpslgfnlpnfilqbqslpjwjlmavpjmfppklnfsbdfpf`vqjwzobmdvbdfpwbmgbqg`bnsbjdmefbwvqfp`bwfdlqzf{wfqmbo`kjogqfmqfpfqufgqfpfbq`kf{`kbmdfebulqjwfwfnsobwfnjojwbqzjmgvpwqzpfquj`fpnbwfqjbosqlgv`wpy.jmgf{9`lnnfmwpplewtbqf`lnsofwf`bofmgbqsobwelqnbqwj`ofpqfrvjqfgnlufnfmwrvfpwjlmavjogjmdslojwj`pslppjaofqfojdjlmskzpj`boeffgab`hqfdjpwfqsj`wvqfpgjpbaofgsqlwl`lobvgjfm`fpfwwjmdpb`wjujwzfofnfmwpofbqmjmdbmzwkjmdbapwqb`wsqldqfpplufqujftnbdbyjmff`lmlnj`wqbjmjmdsqfppvqfubqjlvp#?pwqlmd=sqlsfqwzpklssjmdwldfwkfqbgubm`fgafkbujlqgltmolbgefbwvqfgellwaboopfof`wfgObmdvbdfgjpwbm`fqfnfnafqwqb`hjmdsbpptlqgnlgjejfgpwvgfmwpgjqf`wozejdkwjmdmlqwkfqmgbwbabpfefpwjuboaqfbhjmdol`bwjlmjmwfqmfwgqlsgltmsqb`wj`ffujgfm`fevm`wjlmnbqqjbdfqfpslmpfsqlaofnpmfdbwjufsqldqbnpbmbozpjpqfofbpfgabmmfq!=svq`kbpfsloj`jfpqfdjlmbo`qfbwjufbqdvnfmwallhnbqhqfefqqfq`kfnj`bogjujpjlm`booab`hpfsbqbwfsqlif`wp`lmeoj`wkbqgtbqfjmwfqfpwgfojufqznlvmwbjmlawbjmfg>#ebopf8elq+ubq#b``fswfg`bsb`jwz`lnsvwfqjgfmwjwzbjq`qbewfnsolzfgsqlslpfgglnfpwj`jm`ovgfpsqlujgfgklpsjwboufqwj`bo`loobspfbssqlb`ksbqwmfqpoldl!=?bgbvdkwfqbvwklq!#`vowvqboebnjojfp,jnbdfp,bppfnaozsltfqevowfb`kjmdejmjpkfggjpwqj`w`qjwj`bo`dj.ajm,svqslpfpqfrvjqfpfof`wjlmaf`lnjmdsqlujgfpb`bgfnj`f{fq`jpfb`wvbooznfgj`jmf`lmpwbmwb``jgfmwNbdbyjmfgl`vnfmwpwbqwjmdalwwln!=lapfqufg9#%rvlw8f{wfmgfgsqfujlvpPlewtbqf`vpwlnfqgf`jpjlmpwqfmdwkgfwbjofgpojdkwozsobmmjmdwf{wbqfb`vqqfm`zfufqzlmfpwqbjdkwwqbmpefqslpjwjufsqlgv`fgkfqjwbdfpkjssjmdbaplovwfqf`fjufgqfofubmwavwwlm!#ujlofm`fbmztkfqfafmfejwpobvm`kfgqf`fmwozboojbm`felooltfgnvowjsofavoofwjmjm`ovgfgl``vqqfgjmwfqmbo\'+wkjp*-qfsvaoj`=?wq=?wg`lmdqfppqf`lqgfgvowjnbwfplovwjlm?vo#jg>!gjp`lufqKlnf?,b=tfapjwfpmfwtlqhpbowklvdkfmwjqfoznfnlqjbonfppbdfp`lmwjmvfb`wjuf!=plnftkbwuj`wlqjbTfpwfqm##wjwof>!Ol`bwjlm`lmwqb`wujpjwlqpGltmolbgtjwklvw#qjdkw!=	nfbpvqfptjgwk#>#ubqjbaofjmuloufgujqdjmjbmlqnboozkbssfmfgb``lvmwppwbmgjmdmbwjlmboQfdjpwfqsqfsbqfg`lmwqlopb``vqbwfajqwkgbzpwqbwfdzleej`jbodqbskj`p`qjnjmboslppjaoz`lmpvnfqSfqplmbopsfbhjmdubojgbwfb`kjfufg-isd!#,=nb`kjmfp?,k1=	##hfztlqgpeqjfmgozaqlwkfqp`lnajmfglqjdjmbo`lnslpfgf{sf`wfgbgfrvbwfsbhjpwbmeloolt!#ubovbaof?,obafo=qfobwjufaqjmdjmdjm`qfbpfdlufqmlqsovdjmp,Ojpw#le#Kfbgfq!=!#mbnf>!#+%rvlw8dqbgvbwf?,kfbg=	`lnnfq`fnbobzpjbgjqf`wlqnbjmwbjm8kfjdkw9p`kfgvof`kbmdjmdab`h#wl#`bwkloj`sbwwfqmp`lolq9# dqfbwfpwpvssojfpqfojbaof?,vo=	\n\n?pfof`w#`jwjyfmp`olwkjmdtbw`kjmd?oj#jg>!psf`jej``bqqzjmdpfmwfm`f?`fmwfq=`lmwqbpwwkjmhjmd`bw`k+f*plvwkfqmNj`kbfo#nfq`kbmw`bqlvpfosbggjmd9jmwfqjlq-psojw+!ojybwjlmL`wlafq#*xqfwvqmjnsqlufg..%dw8		`lufqbdf`kbjqnbm-smd!#,=pvaif`wpQj`kbqg#tkbwfufqsqlabaozqf`lufqzabpfabooivgdnfmw`lmmf`w--`pp!#,=#tfapjwfqfslqwfggfebvow!,=?,b=	fof`wqj`p`lwobmg`qfbwjlmrvbmwjwz-#JPAM#3gjg#mlw#jmpwbm`f.pfbq`k.!#obmd>!psfbhfqp@lnsvwfq`lmwbjmpbq`kjufpnjmjpwfqqfb`wjlmgjp`lvmwJwbojbml`qjwfqjbpwqlmdoz9#$kwws9$p`qjsw$`lufqjmdleefqjmdbssfbqfgAqjwjpk#jgfmwjezEb`fallhmvnfqlvpufkj`ofp`lm`fqmpBnfqj`bmkbmgojmdgju#jg>!Tjoojbn#sqlujgfq\\`lmwfmwb``vqb`zpf`wjlm#bmgfqplmeof{jaof@bwfdlqzobtqfm`f?p`qjsw=obzlvw>!bssqlufg#nb{jnvnkfbgfq!=?,wbaof=Pfquj`fpkbnjowlm`vqqfmw#`bmbgjbm`kbmmfop,wkfnfp,,bqwj`oflswjlmboslqwvdboubovf>!!jmwfqubotjqfofppfmwjwofgbdfm`jfpPfbq`k!#nfbpvqfgwklvpbmgpsfmgjmd%kfoojs8mft#Gbwf!#pjyf>!sbdfMbnfnjggof!#!#,=?,b=kjggfm!=pfrvfm`fsfqplmbolufqeoltlsjmjlmpjoojmljpojmhp!=	\n?wjwof=ufqpjlmppbwvqgbzwfqnjmbojwfnsqlsfmdjmffqpf`wjlmpgfpjdmfqsqlslpbo>!ebopf!Fpsb/]loqfofbpfppvanjw!#fq%rvlw8bggjwjlmpznswlnplqjfmwfgqfplvq`fqjdkw!=?sofbpvqfpwbwjlmpkjpwlqz-ofbujmd##alqgfq>`lmwfmwp`fmwfq!=-		Plnf#gjqf`wfgpvjwbaofavodbqjb-pklt+*8gfpjdmfgDfmfqbo#`lm`fswpF{bnsofptjoojbnpLqjdjmbo!=?psbm=pfbq`k!=lsfqbwlqqfrvfpwpb#%rvlw8booltjmdGl`vnfmwqfujpjlm-#		Wkf#zlvqpfoe@lmwb`w#nj`kjdbmFmdojpk#`lovnajbsqjlqjwzsqjmwjmdgqjmhjmdeb`jojwzqfwvqmfg@lmwfmw#leej`fqpQvppjbm#dfmfqbwf.;;6:.2!jmgj`bwfebnjojbq#rvbojwznbqdjm93#`lmwfmwujftslqw`lmwb`wp.wjwof!=slqwbaof-ofmdwk#fojdjaofjmuloufpbwobmwj`lmolbg>!gfebvow-pvssojfgsbznfmwpdolppbqz		Bewfq#dvjgbm`f?,wg=?wgfm`lgjmdnjggof!=`bnf#wl#gjpsobzpp`lwwjpkilmbwkbmnbilqjwztjgdfwp-`ojmj`bowkbjobmgwfb`kfqp?kfbg=	\nbeef`wfgpvsslqwpsljmwfq8wlPwqjmd?,pnboo=lhobklnbtjoo#af#jmufpwlq3!#bow>!klojgbzpQfplvq`foj`fmpfg#+tkj`k#-#Bewfq#`lmpjgfqujpjwjmdf{solqfqsqjnbqz#pfbq`k!#bmgqljg!rvj`hoz#nffwjmdpfpwjnbwf8qfwvqm#8`lolq9 #kfjdkw>bssqlubo/#%rvlw8#`kf`hfg-njm-ip!nbdmfwj`=?,b=?,kelqf`bpw-#Tkjof#wkvqpgbzgufqwjpf%fb`vwf8kbp@obppfubovbwflqgfqjmdf{jpwjmdsbwjfmwp#Lmojmf#`lolqbglLswjlmp!`bnsafoo?"..#fmg?,psbm=??aq#,=	\\slsvspp`jfm`fp/%rvlw8#rvbojwz#Tjmgltp#bppjdmfgkfjdkw9#?a#`obppof%rvlw8#ubovf>!#@lnsbmzf{bnsofp?jeqbnf#afojfufpsqfpfmwpnbqpkboosbqw#le#sqlsfqoz*-		Wkf#wb{lmlnznv`k#le#?,psbm=	!#gbwb.pqwvdv/Fpp`qlooWl#sqlif`w?kfbg=	bwwlqmfzfnskbpjppslmplqpebm`zal{tlqog$p#tjogojef`kf`hfg>pfppjlmpsqldqbnns{8elmw.#Sqlif`wilvqmbopafojfufgub`bwjlmwklnsplmojdkwjmdbmg#wkf#psf`jbo#alqgfq>3`kf`hjmd?,walgz=?avwwlm#@lnsofwf`ofbqej{	?kfbg=	bqwj`of#?pf`wjlmejmgjmdpqlof#jm#slsvobq##L`wlafqtfapjwf#f{slpvqfvpfg#wl##`kbmdfplsfqbwfg`oj`hjmdfmwfqjmd`lnnbmgpjmelqnfg#mvnafqp##?,gju=`qfbwjmdlmPvanjwnbqzobmg`loofdfpbmbozwj`ojpwjmdp`lmwb`w-olddfgJmbgujplqzpjaojmdp`lmwfmw!p%rvlw8*p-#Wkjp#sb`hbdfp`kf`hal{pvddfpwpsqfdmbmwwlnlqqltpsb`jmd>j`lm-smdibsbmfpf`lgfabpfavwwlm!=dbnaojmdpv`k#bp#/#tkjof#?,psbm=#njpplvqjpslqwjmdwls92s{#-?,psbm=wfmpjlmptjgwk>!1obyzolbgmlufnafqvpfg#jm#kfjdkw>!`qjsw!=	%maps8?,?wq=?wg#kfjdkw91,sqlgv`w`lvmwqz#jm`ovgf#ellwfq!#%ow8"..#wjwof!=?,irvfqz-?,elqn=	+\vBl\bQ*+\vUmGx*kqubwphjjwbojbmlqln/Nm(ow/Pqh/Kf4K4]4C5dwbnaj/Emmlwj`jbpnfmpbifpsfqplmbpgfqf`klpmb`jlmbopfquj`jl`lmwb`wlvpvbqjlpsqldqbnbdlajfqmlfnsqfpbpbmvm`jlpubofm`jb`lolnajbgfpsv/Epgfslqwfpsqlzf`wlsqlgv`wls/Vaoj`lmlplwqlpkjpwlqjbsqfpfmwfnjoolmfpnfgjbmwfsqfdvmwbbmwfqjlqqf`vqplpsqlaofnbpbmwjbdlmvfpwqlplsjmj/_mjnsqjnjqnjfmwqbpbn/Eqj`bufmgfglqpl`jfgbgqfpsf`wlqfbojybqqfdjpwqlsbobaqbpjmwfq/Epfmwlm`fpfpsf`jbonjfnaqlpqfbojgbg`/_qglabybqbdlybs/Mdjmbppl`jbofpaolrvfbqdfpwj/_mborvjofqpjpwfnbp`jfm`jbp`lnsofwlufqpj/_m`lnsofwbfpwvgjlps/Vaoj`blaifwjulboj`bmwfavp`bglq`bmwjgbgfmwqbgbpb``jlmfpbq`kjulppvsfqjlqnbzlq/Abbofnbmjbevm`j/_m/Vowjnlpkb`jfmglbrvfoolpfgj`j/_mefqmbmglbnajfmwfeb`fallhmvfpwqbp`ojfmwfpsql`fplpabpwbmwfsqfpfmwbqfslqwbq`lmdqfplsvaoj`bq`lnfq`jl`lmwqbwli/_ufmfpgjpwqjwlw/E`mj`b`lmivmwlfmfqd/Abwqbabibqbpwvqjbpqf`jfmwfvwjojybqalofw/Ampboubglq`lqqf`wbwqbabilpsqjnfqlpmfdl`jlpojafqwbggfwboofpsbmwboobsq/_{jnlbonfq/Abbmjnbofprvj/Emfp`lqby/_mpf``j/_mavp`bmglls`jlmfpf{wfqjlq`lm`fswlwlgbu/Abdbofq/Abfp`qjajqnfgj`jmboj`fm`jb`lmpvowbbpsf`wlp`q/Awj`bg/_obqfpivpwj`jbgfafq/Mmsfq/Alglmf`fpjwbnbmwfmfqsfrvf/]lqf`jajgbwqjavmbowfmfqjef`bm`j/_m`bmbqjbpgfp`bqdbgjufqplpnboolq`bqfrvjfqfw/E`mj`lgfafq/Abujujfmgbejmbmybpbgfobmwfevm`jlmb`lmpfilpgje/A`jo`jvgbgfpbmwjdvbpbubmybgbw/Eqnjmlvmjgbgfpp/Mm`kfy`bnsb/]bplewlmj`qfujpwbp`lmwjfmfpf`wlqfpnlnfmwlpeb`vowbg`q/Egjwlgjufqpbppvsvfpwleb`wlqfppfdvmglpsfrvf/]b<_<R<X<\\<Y=m<W<T<Y=m=n=`<]=g<W<R<]=g=n=`=a=n<R<P<y=m<W<T=n<R<_<R<P<Y<Q=c<^=m<Y=i=a=n<R<U<X<\\<Z<Y<]=g<W<T<_<R<X=o<X<Y<Q=`=a=n<R=n<]=g<W<\\=m<Y<]=c<R<X<T<Q=m<Y<]<Y<Q<\\<X<R=m<\\<U=n=h<R=n<R<Q<Y<_<R=m<^<R<T=m<^<R<U<T<_=l=g=n<R<Z<Y<^=m<Y<P=m<^<R=b<W<T=d=`=a=n<T=i<S<R<V<\\<X<Q<Y<U<X<R<P<\\<P<T=l<\\<W<T<]<R=n<Y<P=o=i<R=n=c<X<^=o=i=m<Y=n<T<W=b<X<T<X<Y<W<R<P<T=l<Y=n<Y<]=c=m<^<R<Y<^<T<X<Y=k<Y<_<R=a=n<T<P=m=k<Y=n=n<Y<P=g=j<Y<Q=g=m=n<\\<W<^<Y<X=`=n<Y<P<Y<^<R<X=g=n<Y<]<Y<^=g=d<Y<Q<\\<P<T=n<T<S<\\=n<R<P=o<S=l<\\<^<W<T=j<\\<R<X<Q<\\<_<R<X=g<[<Q<\\=b<P<R<_=o<X=l=o<_<^=m<Y<U<T<X<Y=n<V<T<Q<R<R<X<Q<R<X<Y<W<\\<X<Y<W<Y=m=l<R<V<T=b<Q=c<^<Y=m=`<y=m=n=`=l<\\<[<\\<Q<\\=d<T4K5h5h5k4K5h4F5f4@5i5f4U4B4K4Y4E4K5h4\\5f4U5h5f5k4@4C5f4C4K5h4N5j4K5h4]4C4F4A5o5i4Y5m4A4E5o4K5j4F4K5h5h5f5f5o5d5j4X4D5o4E5m5f5k4K4D5j4K4F4A5d4K4M4O5o4G4]4B5h4K5h4K5h4A4D4C5h5f5h4C4]5d4_4K4Z4V4[4F5o5d5j5k5j4K5o4_4K4A4E5j4K4C5f4K5h4[4D4U5h5f5o4X5o4]4K5f5i5o5j5i5j5k4K4X4]5o4E4]4J5f4_5j4X5f4[5i4K4\\4K4K5h5m5j4X4D4K4D4F4U4D4]4]4A5i4E5o4K5m4E5f5n5d5h5i4]5o4^5o5h5i4E4O4A5i4C5n5h4D5f5f4U5j5f4Y5d4]4E4[4]5f5n4X4K4]5o4@5d4K5h4O4B4]5e5i4U5j4K4K4D4A4G4U4]5d4Z4D4X5o5h5i4_4@5h4D5j4K5j4B4K5h4C5o4F4K4D5o5h5f4E4D4C5d5j4O5f4Z4K5f5d4@4C5m4]5f5n5o4F4D4F4O5m4Z5h5i4[4D4B4K5o4G4]4D4K4]5o4K5m4Z5h4K4A5h5e5j5m4_5k4O5f4K5i4]4C5d4C4O5j5k4K4C5f5j4K4K5h4K5j5i4U4]4Z4F4U5h5i4C4K4B5h5i5i5o5j\x07\x07\x07\x07\0\x07\x07\0\v\n	\b\r\f\f\r\b	\n\v\x1B\x1B\0\v\v\v\v\0\x07qfplvq`fp`lvmwqjfprvfpwjlmpfrvjsnfmw`lnnvmjwzbubjobaofkjdkojdkwGWG,{kwnonbqhfwjmdhmltofgdfplnfwkjmd`lmwbjmfqgjqf`wjlmpvap`qjafbgufqwjpf`kbqb`wfq!#ubovf>!?,pfof`w=Bvpwqbojb!#`obpp>!pjwvbwjlmbvwklqjwzelooltjmdsqjnbqjozlsfqbwjlm`kboofmdfgfufolsfgbmlmznlvpevm`wjlm#evm`wjlmp`lnsbmjfppwqv`wvqfbdqffnfmw!#wjwof>!slwfmwjbofgv`bwjlmbqdvnfmwppf`lmgbqz`lszqjdkwobmdvbdfpf{`ovpjuf`lmgjwjlm?,elqn=	pwbwfnfmwbwwfmwjlmAjldqbskz~#fopf#x	plovwjlmptkfm#wkf#Bmbozwj`pwfnsobwfpgbmdfqlvppbwfoojwfgl`vnfmwpsvaojpkfqjnslqwbmwsqlwlwzsfjmeovfm`f%qbrvl8?,feef`wjufdfmfqboozwqbmpelqnafbvwjevowqbmpslqwlqdbmjyfgsvaojpkfgsqlnjmfmwvmwjo#wkfwkvnambjoMbwjlmbo#-el`vp+*8lufq#wkf#njdqbwjlmbmmlvm`fgellwfq!=	f{`fswjlmofpp#wkbmf{sfmpjufelqnbwjlmeqbnftlqhwfqqjwlqzmgj`bwjlm`vqqfmwoz`obppMbnf`qjwj`jpnwqbgjwjlmfopftkfqfBof{bmgfqbssljmwfgnbwfqjbopaqlbg`bpwnfmwjlmfgbeejojbwf?,lswjlm=wqfbwnfmwgjeefqfmw,gfebvow-Sqfpjgfmwlm`oj`h>!ajldqbskzlwkfqtjpfsfqnbmfmwEqbm/KbjpKlooztllgf{sbmpjlmpwbmgbqgp?,pwzof=	qfgv`wjlmGf`fnafq#sqfefqqfg@bnaqjgdflsslmfmwpAvpjmfpp#`lmevpjlm=	?wjwof=sqfpfmwfgf{sobjmfgglfp#mlw#tlqogtjgfjmwfqeb`fslpjwjlmpmftpsbsfq?,wbaof=	nlvmwbjmpojhf#wkf#fppfmwjboejmbm`jbopfof`wjlmb`wjlm>!,babmglmfgFgv`bwjlmsbqpfJmw+pwbajojwzvmbaof#wl?,wjwof=	qfobwjlmpMlwf#wkbwfeej`jfmwsfqelqnfgwtl#zfbqpPjm`f#wkfwkfqfelqftqbssfq!=bowfqmbwfjm`qfbpfgAbwwof#lesfq`fjufgwqzjmd#wlmf`fppbqzslqwqbzfgfof`wjlmpFojybafwk?,jeqbnf=gjp`lufqzjmpvqbm`fp-ofmdwk8ofdfmgbqzDfldqbskz`bmgjgbwf`lqslqbwfplnfwjnfppfquj`fp-jmkfqjwfg?,pwqlmd=@lnnvmjwzqfojdjlvpol`bwjlmp@lnnjwwffavjogjmdpwkf#tlqogml#olmdfqafdjmmjmdqfefqfm`f`bmmlw#afeqfrvfm`zwzsj`boozjmwl#wkf#qfobwjuf8qf`lqgjmdsqfpjgfmwjmjwjboozwf`kmjrvfwkf#lwkfqjw#`bm#aff{jpwfm`fvmgfqojmfwkjp#wjnfwfofsklmfjwfnp`lsfsqb`wj`fpbgubmwbdf*8qfwvqm#Elq#lwkfqsqlujgjmdgfnl`qb`zalwk#wkf#f{wfmpjufpveefqjmdpvsslqwfg`lnsvwfqp#evm`wjlmsqb`wj`bopbjg#wkbwjw#nbz#afFmdojpk?,eqln#wkf#p`kfgvofggltmolbgp?,obafo=	pvpsf`wfgnbqdjm9#3psjqjwvbo?,kfbg=		nj`qlplewdqbgvboozgjp`vppfgkf#af`bnff{f`vwjufirvfqz-ipklvpfklog`lmejqnfgsvq`kbpfgojwfqboozgfpwqlzfgvs#wl#wkfubqjbwjlmqfnbjmjmdjw#jp#mlw`fmwvqjfpIbsbmfpf#bnlmd#wkf`lnsofwfgbodlqjwknjmwfqfpwpqfafoojlmvmgfejmfgfm`lvqbdfqfpjybaofjmuloujmdpfmpjwjufvmjufqpbosqlujpjlm+bowklvdkefbwvqjmd`lmgv`wfg*/#tkj`k#`lmwjmvfg.kfbgfq!=Efaqvbqz#mvnfqlvp#lufqeolt9`lnslmfmweqbdnfmwpf{`foofmw`lopsbm>!wf`kmj`bomfbq#wkf#Bgubm`fg#plvq`f#lef{sqfppfgKlmd#Hlmd#Eb`fallhnvowjsof#nf`kbmjpnfofubwjlmleefmpjuf?,elqn=	\npslmplqfggl`vnfmw-lq#%rvlw8wkfqf#bqfwklpf#tklnlufnfmwpsql`fppfpgjeej`vowpvanjwwfgqf`lnnfmg`lmujm`fgsqlnlwjmd!#tjgwk>!-qfsob`f+`obppj`bo`lbojwjlmkjp#ejqpwgf`jpjlmpbppjpwbmwjmgj`bwfgfulovwjlm.tqbssfq!fmlvdk#wlbolmd#wkfgfojufqfg..=	?"..Bnfqj`bm#sqlwf`wfgMlufnafq#?,pwzof=?evqmjwvqfJmwfqmfw##lmaovq>!pvpsfmgfgqf`jsjfmwabpfg#lm#Nlqflufq/balojpkfg`loof`wfgtfqf#nbgffnlwjlmbofnfqdfm`zmbqqbwjufbgul`bwfps{8alqgfq`lnnjwwfggjq>!owq!fnsolzffpqfpfbq`k-#pfof`wfgpv``fpplq`vpwlnfqpgjpsobzfgPfswfnafqbgg@obpp+Eb`fallh#pvddfpwfgbmg#obwfqlsfqbwjmdfobalqbwfPlnfwjnfpJmpwjwvwf`fqwbjmozjmpwboofgelooltfqpIfqvpbofnwkfz#kbuf`lnsvwjmddfmfqbwfgsqlujm`fpdvbqbmwffbqajwqbqzqf`ldmjyftbmwfg#wls{8tjgwk9wkflqz#leafkbujlvqTkjof#wkffpwjnbwfgafdbm#wl#jw#af`bnfnbdmjwvgfnvpw#kbufnlqf#wkbmGjqf`wlqzf{wfmpjlmpf`qfwbqzmbwvqboozl``vqqjmdubqjbaofpdjufm#wkfsobwelqn-?,obafo=?ebjofg#wl`lnslvmgphjmgp#le#pl`jfwjfpbolmdpjgf#..%dw8		plvwktfpwwkf#qjdkwqbgjbwjlmnbz#kbuf#vmfp`bsf+pslhfm#jm!#kqfe>!,sqldqbnnflmoz#wkf#`lnf#eqlngjqf`wlqzavqjfg#jmb#pjnjobqwkfz#tfqf?,elmw=?,Mlqtfdjbmpsf`jejfgsqlgv`jmdsbppfmdfq+mft#Gbwfwfnslqbqzej`wjlmboBewfq#wkffrvbwjlmpgltmolbg-qfdvobqozgfufolsfqbaluf#wkfojmhfg#wlskfmlnfmbsfqjlg#lewllowjs!=pvapwbm`fbvwlnbwj`bpsf`w#leBnlmd#wkf`lmmf`wfgfpwjnbwfpBjq#Elq`fpzpwfn#lelaif`wjufjnnfgjbwfnbhjmd#jwsbjmwjmdp`lmrvfqfgbqf#pwjoosql`fgvqfdqltwk#lekfbgfg#azFvqlsfbm#gjujpjlmpnlof`vofpeqbm`kjpfjmwfmwjlmbwwqb`wfg`kjogkllgbopl#vpfggfgj`bwfgpjmdbslqfgfdqff#leebwkfq#le`lmeoj`wp?,b=?,s=	`bnf#eqlntfqf#vpfgmlwf#wkbwqf`fjujmdF{f`vwjuffufm#nlqfb``fpp#wl`lnnbmgfqSlojwj`bonvpj`jbmpgfoj`jlvpsqjplmfqpbgufmw#leVWE.;!#,=?"X@GBWBX!=@lmwb`wPlvwkfqm#ad`lolq>!pfqjfp#le-#Jw#tbp#jm#Fvqlsfsfqnjwwfgubojgbwf-bssfbqjmdleej`jboppfqjlvpoz.obmdvbdfjmjwjbwfgf{wfmgjmdolmd.wfqnjmeobwjlmpv`k#wkbwdfw@llhjfnbqhfg#az?,avwwlm=jnsofnfmwavw#jw#jpjm`qfbpfpgltm#wkf#qfrvjqjmdgfsfmgfmw..=	?"..#jmwfqujftTjwk#wkf#`lsjfp#le`lmpfmpvptbp#avjowUfmfyvfob+elqnfqozwkf#pwbwfsfqplmmfopwqbwfdj`ebulvq#lejmufmwjlmTjhjsfgjb`lmwjmfmwujqwvbooztkj`k#tbpsqjm`jsof@lnsofwf#jgfmwj`bopklt#wkbwsqjnjwjufbtbz#eqlnnlof`vobqsqf`jpfozgjpploufgVmgfq#wkfufqpjlm>!=%maps8?,Jw#jp#wkf#Wkjp#jp#tjoo#kbuflqdbmjpnpplnf#wjnfEqjfgqj`ktbp#ejqpwwkf#lmoz#eb`w#wkbwelqn#jg>!sqf`fgjmdWf`kmj`boskzpj`jpwl``vqp#jmmbujdbwlqpf`wjlm!=psbm#jg>!plvdkw#wlafolt#wkfpvqujujmd~?,pwzof=kjp#gfbwkbp#jm#wkf`bvpfg#azsbqwjboozf{jpwjmd#vpjmd#wkftbp#djufmb#ojpw#leofufop#lemlwjlm#leLeej`jbo#gjpnjppfgp`jfmwjpwqfpfnaofpgvsoj`bwff{solpjufqf`lufqfgboo#lwkfqdboofqjfpxsbggjmd9sflsof#leqfdjlm#lebggqfppfpbppl`jbwfjnd#bow>!jm#nlgfqmpklvog#afnfwklg#leqfslqwjmdwjnfpwbnsmffgfg#wlwkf#Dqfbwqfdbqgjmdpffnfg#wlujftfg#bpjnsb`w#lmjgfb#wkbwwkf#Tlqogkfjdkw#lef{sbmgjmdWkfpf#bqf`vqqfmw!=`bqfevooznbjmwbjmp`kbqdf#le@obppj`bobggqfppfgsqfgj`wfgltmfqpkjs?gju#jg>!qjdkw!=	qfpjgfm`fofbuf#wkf`lmwfmw!=bqf#lewfm##~*+*8	sqlabaoz#Sqlefpplq.avwwlm!#qfpslmgfgpbzp#wkbwkbg#wl#afsob`fg#jmKvmdbqjbmpwbwvp#lepfqufp#bpVmjufqpbof{f`vwjlmbddqfdbwfelq#tkj`kjmef`wjlmbdqffg#wlkltfufq/#slsvobq!=sob`fg#lm`lmpwqv`wfof`wlqbopznalo#lejm`ovgjmdqfwvqm#wlbq`kjwf`w@kqjpwjbmsqfujlvp#ojujmd#jmfbpjfq#wlsqlefpplq	%ow8"..#feef`w#lebmbozwj`ptbp#wbhfmtkfqf#wkfwllh#lufqafojfe#jmBeqjhbbmpbp#ebq#bpsqfufmwfgtlqh#tjwkb#psf`jbo?ejfogpfw@kqjpwnbpQfwqjfufg		Jm#wkf#ab`h#jmwlmlqwkfbpwnbdbyjmfp=?pwqlmd=`lnnjwwffdlufqmjmddqlvsp#lepwlqfg#jmfpwbaojpkb#dfmfqbojwp#ejqpwwkfjq#ltmslsvobwfgbm#laif`w@bqjaafbmboolt#wkfgjpwqj`wptjp`lmpjmol`bwjlm-8#tjgwk9#jmkbajwfgPl`jbojpwIbmvbqz#2?,ellwfq=pjnjobqoz`klj`f#lewkf#pbnf#psf`jej`#avpjmfpp#Wkf#ejqpw-ofmdwk8#gfpjqf#wlgfbo#tjwkpjm`f#wkfvpfqBdfmw`lm`fjufgjmgf{-sksbp#%rvlw8fmdbdf#jmqf`fmwoz/eft#zfbqptfqf#bopl	?kfbg=	?fgjwfg#azbqf#hmltm`jwjfp#jmb``fpphfz`lmgfnmfgbopl#kbufpfquj`fp/ebnjoz#leP`kllo#le`lmufqwfgmbwvqf#le#obmdvbdfnjmjpwfqp?,laif`w=wkfqf#jp#b#slsvobqpfrvfm`fpbgul`bwfgWkfz#tfqfbmz#lwkfqol`bwjlm>fmwfq#wkfnv`k#nlqfqfeof`wfgtbp#mbnfglqjdjmbo#b#wzsj`botkfm#wkfzfmdjmffqp`lvog#mlwqfpjgfmwptfgmfpgbzwkf#wkjqg#sqlgv`wpIbmvbqz#1tkbw#wkfzb#`fqwbjmqfb`wjlmpsql`fpplqbewfq#kjpwkf#obpw#`lmwbjmfg!=?,gju=	?,b=?,wg=gfsfmg#lmpfbq`k!=	sjf`fp#le`lnsfwjmdQfefqfm`fwfmmfppfftkj`k#kbp#ufqpjlm>?,psbm=#??,kfbgfq=djufp#wkfkjpwlqjbmubovf>!!=sbggjmd93ujft#wkbwwldfwkfq/wkf#nlpw#tbp#elvmgpvapfw#lebwwb`h#lm`kjogqfm/sljmwp#lesfqplmbo#slpjwjlm9boofdfgoz@ofufobmgtbp#obwfqbmg#bewfqbqf#djufmtbp#pwjoop`qloojmdgfpjdm#lenbhfp#wkfnv`k#ofppBnfqj`bmp-		Bewfq#/#avw#wkfNvpfvn#leolvjpjbmb+eqln#wkfnjmmfplwbsbqwj`ofpb#sql`fppGlnjmj`bmulovnf#leqfwvqmjmdgfefmpjuf33s{qjdknbgf#eqlnnlvpflufq!#pwzof>!pwbwfp#le+tkj`k#jp`lmwjmvfpEqbm`jp`lavjogjmd#tjwklvw#btjwk#plnftkl#tlvogb#elqn#leb#sbqw#leafelqf#jwhmltm#bp##Pfquj`fpol`bwjlm#bmg#lewfmnfbpvqjmdbmg#jw#jpsbsfqab`hubovfp#le	?wjwof=>#tjmglt-gfwfqnjmffq%rvlw8#sobzfg#azbmg#fbqoz?,`fmwfq=eqln#wkjpwkf#wkqffsltfq#bmgle#%rvlw8jmmfqKWNO?b#kqfe>!z9jmojmf8@kvq`k#lewkf#fufmwufqz#kjdkleej`jbo#.kfjdkw9#`lmwfmw>!,`dj.ajm,wl#`qfbwfbeqjhbbmpfpsfqbmwleqbm/Kbjpobwujf)Mvojfwvuj)_(`f)Mwjmb(af)Mwjmb\fUh\fT{\fTN\n{I\np@Fr\vBl\bQ	A{\vUmGx	A{ypYA\0zX\bTV\bWl\bUdBM\vB{\npV\v@xB\\\np@DbGz	al\npa	fM	uD\bV~mx\vQ}\ndS	p\\\bVK\bS]\bU|oD	kV\ved\vHR\nb~M`\nJpoD|Q\nLPSw\bTl\nAI\nxC\bWt	BqF`Cm\vLm	Kx	}t\bPv\ny\\\naB	V\nZdXUli	fr	i@	BHBDBV	`V\n[]	p_	Tn\n~A\nxR	uD	`{\bV@	Tn	HK	AJ\vxsZf\nqIZf\vBM\v|j	}t\bSM\nmC\vQ}pfquj`jlpbqw/A`volbqdfmwjmbabq`folmb`vborvjfqsvaoj`bglsqlgv`wlpslo/Awj`bqfpsvfpwbtjhjsfgjbpjdvjfmwfa/Vprvfgb`lnvmjgbgpfdvqjgbgsqjm`jsbosqfdvmwbp`lmwfmjglqfpslmgfqufmfyvfobsqlaofnbpgj`jfnaqfqfob`j/_mmlujfnaqfpjnjobqfpsqlzf`wlpsqldqbnbpjmpwjwvwlb`wjujgbgfm`vfmwqbf`lmln/Abjn/Mdfmfp`lmwb`wbqgfp`bqdbqmf`fpbqjlbwfm`j/_mwfo/Eelml`lnjpj/_m`bm`jlmfp`bsb`jgbgfm`lmwqbqbm/Mojpjpebulqjwlpw/Eqnjmlpsqlujm`jbfwjrvfwbpfofnfmwlpevm`jlmfpqfpvowbgl`bq/M`wfqsqlsjfgbgsqjm`jsjlmf`fpjgbgnvmj`jsbo`qfb`j/_mgfp`bqdbpsqfpfm`jb`lnfq`jbolsjmjlmfpfifq`j`jlfgjwlqjbopbobnbm`bdlmy/Mofygl`vnfmwlsfo/A`vobqf`jfmwfpdfmfqbofpwbqqbdlmbsq/M`wj`bmlufgbgfpsqlsvfpwbsb`jfmwfpw/E`mj`bplaifwjulp`lmwb`wlp\fHB\fIk\fHn\fH^\fHS\fHc\fHU\fId\fHn\fH{\fHC\fHR\fHT\fHR\fHI\fHc\fHY\fHn\fH\\\fHU\fIk\fHy\fIg\fHd\fHy\fIm\fHw\fH\\\fHU\fHR\fH@\fHR\fHJ\fHy\fHU\fHR\fHT\fHA\fIl\fHU\fIm\fHc\fH\\\fHU\fIl\fHB\fId\fHn\fHJ\fHS\fHD\fH@\fHR\fHHgjsolgl`p\fHT\fHB\fHC\fH\\\fIn\fHF\fHD\fHR\fHB\fHF\fHH\fHR\fHG\fHS\fH\\\fHx\fHT\fHH\fHH\fH\\\fHU\fH^\fIg\fH{\fHU\fIm\fHj\fH@\fHR\fH\\\fHJ\fIk\fHZ\fHU\fIm\fHd\fHz\fIk\fH^\fHC\fHJ\fHS\fHy\fHR\fHB\fHY\fIk\fH@\fHH\fIl\fHD\fH@\fIl\fHv\fHB\fI`\fHH\fHT\fHR\fH^\fH^\fIk\fHz\fHp\fIe\fH@\fHB\fHJ\fHJ\fHH\fHI\fHR\fHD\fHU\fIl\fHZ\fHU\fH\\\fHi\fH^\fH{\fHy\fHA\fIl\fHD\fH{\fH\\\fHF\fHR\fHT\fH\\\fHR\fHH\fHy\fHS\fHc\fHe\fHT\fIk\fH{\fHC\fIl\fHU\fIn\fHm\fHj\fH{\fIk\fHs\fIl\fHB\fHz\fIg\fHp\fHy\fHR\fH\\\fHi\fHA\fIl\fH{\fHC\fIk\fHH\fIm\fHB\fHY\fIg\fHs\fHJ\fIk\fHn\fHi\fH{\fH\\\fH|\fHT\fIk\fHB\fIk\fH^\fH^\fH{\fHR\fHU\fHR\fH^\fHf\fHF\fH\\\fHv\fHR\fH\\\fH|\fHT\fHR\fHJ\fIk\fH\\\fHp\fHS\fHT\fHJ\fHS\fH^\fH@\fHn\fHJ\fH@\fHD\fHR\fHU\fIn\fHn\fH^\fHR\fHz\fHp\fIl\fHH\fH@\fHs\fHD\fHB\fHS\fH^\fHk\fHT\fIk\fHj\fHD\fIk\fHD\fHC\fHR\fHy\fIm\fH^\fH^\fIe\fH{\fHA\fHR\fH{\fH\\\fIk\fH^\fHp\fH{\fHU\fH\\\fHR\fHB\fH^\fH{\fIk\fHF\fIk\fHp\fHU\fHR\fHI\fHk\fHT\fIl\fHT\fHU\fIl\fHy\fH^\fHR\fHL\fIl\fHy\fHU\fHR\fHm\fHJ\fIn\fH\\\fHH\fHU\fHH\fHT\fHR\fHH\fHC\fHR\fHJ\fHj\fHC\fHR\fHF\fHR\fHy\fHy\fI`\fHD\fHZ\fHR\fHB\fHJ\fIk\fHz\fHC\fHU\fIl\fH\\\fHR\fHC\fHz\fIm\fHJ\fH^\fH{\fIl`bwfdlqjfpf{sfqjfm`f?,wjwof=	@lszqjdkw#ibubp`qjsw`lmgjwjlmpfufqzwkjmd?s#`obpp>!wf`kmloldzab`hdqlvmg?b#`obpp>!nbmbdfnfmw%`lsz8#132ibubP`qjsw`kbqb`wfqpaqfbg`qvnawkfnpfoufpklqjylmwbodlufqmnfmw@bojelqmjbb`wjujwjfpgjp`lufqfgMbujdbwjlmwqbmpjwjlm`lmmf`wjlmmbujdbwjlmbssfbqbm`f?,wjwof=?n`kf`hal{!#wf`kmjrvfpsqlwf`wjlmbssbqfmwozbp#tfoo#bpvmw$/#$VB.qfplovwjlmlsfqbwjlmpwfofujpjlmwqbmpobwfgTbpkjmdwlmmbujdbwlq-#>#tjmglt-jnsqfppjlm%ow8aq%dw8ojwfqbwvqfslsvobwjlmad`lolq>! fpsf`jbooz#`lmwfmw>!sqlgv`wjlmmftpofwwfqsqlsfqwjfpgfejmjwjlmofbgfqpkjsWf`kmloldzSbqojbnfmw`lnsbqjplmvo#`obpp>!-jmgf{Le+!`lm`ovpjlmgjp`vppjlm`lnslmfmwpajloldj`boQfulovwjlm\\`lmwbjmfqvmgfqpwllgmlp`qjsw=?sfqnjppjlmfb`k#lwkfqbwnlpskfqf#lmel`vp>!?elqn#jg>!sql`fppjmdwkjp-ubovfdfmfqbwjlm@lmefqfm`fpvapfrvfmwtfoo.hmltmubqjbwjlmpqfsvwbwjlmskfmlnfmlmgjp`jsojmfoldl-smd!#+gl`vnfmw/alvmgbqjfpf{sqfppjlmpfwwofnfmwAb`hdqlvmglvw#le#wkffmwfqsqjpf+!kwwsp9!#vmfp`bsf+!sbpptlqg!#gfnl`qbwj`?b#kqfe>!,tqbssfq!=	nfnafqpkjsojmdvjpwj`s{8sbggjmdskjolplskzbppjpwbm`fvmjufqpjwzeb`jojwjfpqf`ldmjyfgsqfefqfm`fje#+wzsflenbjmwbjmfgul`bavobqzkzslwkfpjp-pvanjw+*8%bns8maps8bmmlwbwjlmafkjmg#wkfElvmgbwjlmsvaojpkfq!bppvnswjlmjmwqlgv`fg`lqqvswjlmp`jfmwjpwpf{soj`jwozjmpwfbg#legjnfmpjlmp#lm@oj`h>!`lmpjgfqfggfsbqwnfmwl``vsbwjlmpllm#bewfqjmufpwnfmwsqlmlvm`fgjgfmwjejfgf{sfqjnfmwNbmbdfnfmwdfldqbskj`!#kfjdkw>!ojmh#qfo>!-qfsob`f+,gfsqfppjlm`lmefqfm`fsvmjpknfmwfojnjmbwfgqfpjpwbm`fbgbswbwjlmlsslpjwjlmtfoo#hmltmpvssofnfmwgfwfqnjmfgk2#`obpp>!3s{8nbqdjmnf`kbmj`bopwbwjpwj`p`fofaqbwfgDlufqmnfmw		Gvqjmd#wgfufolsfqpbqwjej`jbofrvjubofmwlqjdjmbwfg@lnnjppjlmbwwb`knfmw?psbm#jg>!wkfqf#tfqfMfgfqobmgpafzlmg#wkfqfdjpwfqfgilvqmbojpweqfrvfmwozboo#le#wkfobmd>!fm!#?,pwzof=	baplovwf8#pvsslqwjmdf{wqfnfoz#nbjmpwqfbn?,pwqlmd=#slsvobqjwzfnsolznfmw?,wbaof=	#`lopsbm>!?,elqn=	##`lmufqpjlmbalvw#wkf#?,s=?,gju=jmwfdqbwfg!#obmd>!fmSlqwvdvfpfpvapwjwvwfjmgjujgvbojnslppjaofnvowjnfgjbbonlpw#boos{#plojg# bsbqw#eqlnpvaif`w#wljm#Fmdojpk`qjwj`jyfgf{`fsw#elqdvjgfojmfplqjdjmboozqfnbqhbaofwkf#pf`lmgk1#`obpp>!?b#wjwof>!+jm`ovgjmdsbqbnfwfqpsqlkjajwfg>#!kwws9,,gj`wjlmbqzsfq`fswjlmqfulovwjlmelvmgbwjlms{8kfjdkw9pv``fppevopvsslqwfqpnjoofmmjvnkjp#ebwkfqwkf#%rvlw8ml.qfsfbw8`lnnfq`jbojmgvpwqjbofm`lvqbdfgbnlvmw#le#vmleej`jbofeej`jfm`zQfefqfm`fp`llqgjmbwfgjp`objnfqf{sfgjwjlmgfufolsjmd`bo`vobwfgpjnsojejfgofdjwjnbwfpvapwqjmd+3!#`obpp>!`lnsofwfozjoovpwqbwfejuf#zfbqpjmpwqvnfmwSvaojpkjmd2!#`obpp>!spz`kloldz`lmejgfm`fmvnafq#le#bapfm`f#leel`vpfg#lmiljmfg#wkfpwqv`wvqfpsqfujlvpoz=?,jeqbnf=lm`f#bdbjmavw#qbwkfqjnnjdqbmwple#`lvqpf/b#dqlvs#leOjwfqbwvqfVmojhf#wkf?,b=%maps8	evm`wjlm#jw#tbp#wkf@lmufmwjlmbvwlnlajofSqlwfpwbmwbddqfppjufbewfq#wkf#Pjnjobqoz/!#,=?,gju=`loof`wjlm	evm`wjlmujpjajojwzwkf#vpf#leulovmwffqpbwwqb`wjlmvmgfq#wkf#wkqfbwfmfg)?"X@GBWBXjnslqwbm`fjm#dfmfqbowkf#obwwfq?,elqn=	?,-jmgf{Le+$j#>#38#j#?gjeefqfm`fgfulwfg#wlwqbgjwjlmppfbq`k#elqvowjnbwfozwlvqmbnfmwbwwqjavwfppl.`boofg#~	?,pwzof=fubovbwjlmfnskbpjyfgb``fppjaof?,pf`wjlm=pv``fppjlmbolmd#tjwkNfbmtkjof/jmgvpwqjfp?,b=?aq#,=kbp#af`lnfbpsf`wp#leWfofujpjlmpveej`jfmwabphfwabooalwk#pjgfp`lmwjmvjmdbm#bqwj`of?jnd#bow>!bgufmwvqfpkjp#nlwkfqnbm`kfpwfqsqjm`jsofpsbqwj`vobq`lnnfmwbqzfeef`wp#legf`jgfg#wl!=?pwqlmd=svaojpkfqpIlvqmbo#legjeej`vowzeb`jojwbwfb``fswbaofpwzof-`pp!\nevm`wjlm#jmmlubwjlm=@lszqjdkwpjwvbwjlmptlvog#kbufavpjmfppfpGj`wjlmbqzpwbwfnfmwplewfm#vpfgsfqpjpwfmwjm#Ibmvbqz`lnsqjpjmd?,wjwof=	\ngjsolnbwj``lmwbjmjmdsfqelqnjmdf{wfmpjlmpnbz#mlw#af`lm`fsw#le#lm`oj`h>!Jw#jp#boplejmbm`jbo#nbhjmd#wkfOv{fnalvqdbggjwjlmbobqf#`boofgfmdbdfg#jm!p`qjsw!*8avw#jw#tbpfof`wqlmj`lmpvanjw>!	?"..#Fmg#fof`wqj`boleej`jboozpvddfpwjlmwls#le#wkfvmojhf#wkfBvpwqbojbmLqjdjmboozqfefqfm`fp	?,kfbg=	qf`ldmjpfgjmjwjbojyfojnjwfg#wlBof{bmgqjbqfwjqfnfmwBgufmwvqfpelvq#zfbqp		%ow8"..#jm`qfbpjmdgf`lqbwjlmk0#`obpp>!lqjdjmp#lelaojdbwjlmqfdvobwjlm`obppjejfg+evm`wjlm+bgubmwbdfpafjmd#wkf#kjpwlqjbmp?abpf#kqfeqfsfbwfgoztjoojmd#wl`lnsbqbaofgfpjdmbwfgmlnjmbwjlmevm`wjlmbojmpjgf#wkfqfufobwjlmfmg#le#wkfp#elq#wkf#bvwklqjyfgqfevpfg#wlwbhf#sob`fbvwlmlnlvp`lnsqlnjpfslojwj`bo#qfpwbvqbmwwtl#le#wkfEfaqvbqz#1rvbojwz#leptelaif`w-vmgfqpwbmgmfbqoz#bootqjwwfm#azjmwfqujftp!#tjgwk>!2tjwkgqbtboeolbw9ofewjp#vpvbooz`bmgjgbwfpmftpsbsfqpnzpwfqjlvpGfsbqwnfmwafpw#hmltmsbqojbnfmwpvssqfppfg`lmufmjfmwqfnfnafqfggjeefqfmw#pzpwfnbwj`kbp#ofg#wlsqlsbdbmgb`lmwqloofgjmeovfm`fp`fqfnlmjbosql`objnfgSqlwf`wjlmoj#`obpp>!P`jfmwjej``obpp>!ml.wqbgfnbqhpnlqf#wkbm#tjgfpsqfbgOjafqbwjlmwllh#sob`fgbz#le#wkfbp#olmd#bpjnsqjplmfgBggjwjlmbo	?kfbg=	?nObalqbwlqzMlufnafq#1f{`fswjlmpJmgvpwqjboubqjfwz#leeolbw9#ofeGvqjmd#wkfbppfppnfmwkbuf#affm#gfbop#tjwkPwbwjpwj`pl``vqqfm`f,vo=?,gju=`ofbqej{!=wkf#svaoj`nbmz#zfbqptkj`k#tfqflufq#wjnf/pzmlmznlvp`lmwfmw!=	sqfpvnbaozkjp#ebnjozvpfqBdfmw-vmf{sf`wfgjm`ovgjmd#`kboofmdfgb#njmlqjwzvmgfejmfg!afolmdp#wlwbhfm#eqlnjm#L`wlafqslpjwjlm9#pbjg#wl#afqfojdjlvp#Efgfqbwjlm#qltpsbm>!lmoz#b#eftnfbmw#wkbwofg#wl#wkf..=	?gju#?ejfogpfw=Bq`kajpkls#`obpp>!mlafjmd#vpfgbssqlb`kfpsqjujofdfpmlp`qjsw=	qfpvowp#jmnbz#af#wkfFbpwfq#fddnf`kbmjpnpqfbplmbaofSlsvobwjlm@loof`wjlmpfof`wfg!=mlp`qjsw=,jmgf{-sksbqqjubo#le.ippgh$**8nbmbdfg#wljm`lnsofwf`bpvbowjfp`lnsofwjlm@kqjpwjbmpPfswfnafq#bqjwknfwj`sql`fgvqfpnjdkw#kbufSqlgv`wjlmjw#bssfbqpSkjolplskzeqjfmgpkjsofbgjmd#wldjujmd#wkfwltbqg#wkfdvbqbmwffggl`vnfmwfg`lolq9 333ujgfl#dbnf`lnnjppjlmqfeof`wjmd`kbmdf#wkfbppl`jbwfgpbmp.pfqjelmhfzsqfpp8#sbggjmd9Kf#tbp#wkfvmgfqozjmdwzsj`booz#/#bmg#wkf#pq`Fofnfmwpv``fppjufpjm`f#wkf#pklvog#af#mfwtlqhjmdb``lvmwjmdvpf#le#wkfoltfq#wkbmpkltp#wkbw?,psbm=	\n\n`lnsobjmwp`lmwjmvlvprvbmwjwjfpbpwqlmlnfqkf#gjg#mlwgvf#wl#jwpbssojfg#wlbm#bufqbdffeelqwp#wlwkf#evwvqfbwwfnsw#wlWkfqfelqf/`bsbajojwzQfsvaoj`bmtbp#elqnfgFof`wqlmj`hjolnfwfqp`kboofmdfpsvaojpkjmdwkf#elqnfqjmgjdfmlvpgjqf`wjlmppvapjgjbqz`lmpsjqb`zgfwbjop#lebmg#jm#wkfbeelqgbaofpvapwbm`fpqfbplm#elq`lmufmwjlmjwfnwzsf>!baplovwfozpvsslpfgozqfnbjmfg#bbwwqb`wjufwqbufoojmdpfsbqbwfozel`vpfp#lmfofnfmwbqzbssoj`baofelvmg#wkbwpwzofpkffwnbmvp`qjswpwbmgp#elq#ml.qfsfbw+plnfwjnfp@lnnfq`jbojm#Bnfqj`bvmgfqwbhfmrvbqwfq#lebm#f{bnsofsfqplmboozjmgf{-sks<?,avwwlm=	sfq`fmwbdfafpw.hmltm`qfbwjmd#b!#gjq>!owqOjfvwfmbmw	?gju#jg>!wkfz#tlvogbajojwz#lenbgf#vs#lemlwfg#wkbw`ofbq#wkbwbqdvf#wkbwwl#bmlwkfq`kjogqfm$psvqslpf#leelqnvobwfgabpfg#vslmwkf#qfdjlmpvaif`w#lesbppfmdfqpslppfppjlm-		Jm#wkf#Afelqf#wkfbewfqtbqgp`vqqfmwoz#b`qlpp#wkfp`jfmwjej``lnnvmjwz-`bsjwbojpnjm#Dfqnbmzqjdkw.tjmdwkf#pzpwfnPl`jfwz#leslojwj`jbmgjqf`wjlm9tfmw#lm#wlqfnlubo#le#Mft#Zlqh#bsbqwnfmwpjmgj`bwjlmgvqjmd#wkfvmofpp#wkfkjpwlqj`bokbg#affm#bgfejmjwjufjmdqfgjfmwbwwfmgbm`f@fmwfq#elqsqlnjmfm`fqfbgzPwbwfpwqbwfdjfpavw#jm#wkfbp#sbqw#le`lmpwjwvwf`objn#wkbwobalqbwlqz`lnsbwjaofebjovqf#le/#pv`k#bp#afdbm#tjwkvpjmd#wkf#wl#sqlujgfefbwvqf#leeqln#tkj`k,!#`obpp>!dfloldj`bopfufqbo#legfojafqbwfjnslqwbmw#klogp#wkbwjmd%rvlw8#ubojdm>wlswkf#Dfqnbmlvwpjgf#lemfdlwjbwfgkjp#`bqffqpfsbqbwjlmjg>!pfbq`ktbp#`boofgwkf#elvqwkqf`qfbwjlmlwkfq#wkbmsqfufmwjlmtkjof#wkf#fgv`bwjlm/`lmmf`wjmdb``vqbwfoztfqf#avjowtbp#hjoofgbdqffnfmwpnv`k#nlqf#Gvf#wl#wkftjgwk9#233plnf#lwkfqHjmdgln#lewkf#fmwjqfebnlvp#elqwl#`lmmf`wlaif`wjufpwkf#Eqfm`ksflsof#bmgefbwvqfg!=jp#pbjg#wlpwqv`wvqboqfefqfmgvnnlpw#lewfmb#pfsbqbwf.=	?gju#jg#Leej`jbo#tlqogtjgf-bqjb.obafowkf#sobmfwbmg#jw#tbpg!#ubovf>!ollhjmd#bwafmfej`jbobqf#jm#wkfnlmjwlqjmdqfslqwfgozwkf#nlgfqmtlqhjmd#lmbooltfg#wltkfqf#wkf#jmmlubwjuf?,b=?,gju=plvmgwqb`hpfbq`kElqnwfmg#wl#afjmsvw#jg>!lsfmjmd#leqfpwqj`wfgbglswfg#azbggqfppjmdwkfloldjbmnfwklgp#leubqjbmw#le@kqjpwjbm#ufqz#obqdfbvwlnlwjufaz#ebq#wkfqbmdf#eqlnsvqpvjw#leeloolt#wkfaqlvdkw#wljm#Fmdobmgbdqff#wkbwb``vpfg#le`lnfp#eqlnsqfufmwjmdgju#pwzof>kjp#lq#kfqwqfnfmglvpeqffgln#le`lm`fqmjmd3#2fn#2fn8Abphfwaboo,pwzof-`ppbm#fbqojfqfufm#bewfq,!#wjwof>!-`ln,jmgf{wbhjmd#wkfsjwwpavqdk`lmwfmw!=?p`qjsw=+ewvqmfg#lvwkbujmd#wkf?,psbm=	#l``bpjlmboaf`bvpf#jwpwbqwfg#wlskzpj`booz=?,gju=	##`qfbwfg#az@vqqfmwoz/#ad`lolq>!wbajmgf{>!gjpbpwqlvpBmbozwj`p#bopl#kbp#b=?gju#jg>!?,pwzof=	?`boofg#elqpjmdfq#bmg-pq`#>#!,,ujlobwjlmpwkjp#sljmw`lmpwbmwozjp#ol`bwfgqf`lqgjmdpg#eqln#wkfmfgfqobmgpslqwvdv/Fp;N;};D;u;F5m4K4]4_7`gfpbqqlool`lnfmwbqjlfgv`b`j/_mpfswjfnaqfqfdjpwqbglgjqf``j/_mvaj`b`j/_msvaoj`jgbgqfpsvfpwbpqfpvowbglpjnslqwbmwfqfpfqubglpbqw/A`volpgjefqfmwfppjdvjfmwfpqfs/Vaoj`bpjwvb`j/_mnjmjpwfqjlsqjub`jgbggjqf`wlqjlelqnb`j/_mslaob`j/_msqfpjgfmwf`lmw', 'fmjglpb``fplqjlpwf`kmlqbwjsfqplmbofp`bwfdlq/Abfpsf`jbofpgjpslmjaofb`wvbojgbgqfefqfm`jbuboobglojgajaojlwf`bqfob`jlmfp`bofmgbqjlslo/Awj`bpbmwfqjlqfpgl`vnfmwlpmbwvqbofybnbwfqjbofpgjefqfm`jbf`lm/_nj`bwqbmpslqwfqlgq/Advfysbqwj`jsbqfm`vfmwqbmgjp`vpj/_mfpwqv`wvqbevmgb`j/_meqf`vfmwfpsfqnbmfmwfwlwbonfmwf<P<R<Z<Q<R<]=o<X<Y=n<P<R<Z<Y=n<^=l<Y<P=c=n<\\<V<Z<Y=k=n<R<]=g<]<R<W<Y<Y<R=k<Y<Q=`=a=n<R<_<R<V<R<_<X<\\<S<R=m<W<Y<^=m<Y<_<R=m<\\<U=n<Y=k<Y=l<Y<[<P<R<_=o=n=m<\\<U=n<\\<Z<T<[<Q<T<P<Y<Z<X=o<]=o<X=o=n<s<R<T=m<V<[<X<Y=m=`<^<T<X<Y<R=m<^=c<[<T<Q=o<Z<Q<R=m<^<R<Y<U<W=b<X<Y<U<S<R=l<Q<R<P<Q<R<_<R<X<Y=n<Y<U=m<^<R<T=i<S=l<\\<^<\\=n<\\<V<R<U<P<Y=m=n<R<T<P<Y<Y=n<Z<T<[<Q=`<R<X<Q<R<U<W=o=k=d<Y<S<Y=l<Y<X=k<\\=m=n<T=k<\\=m=n=`=l<\\<]<R=n<Q<R<^=g=i<S=l<\\<^<R=m<R<]<R<U<S<R=n<R<P<P<Y<Q<Y<Y=k<T=m<W<Y<Q<R<^=g<Y=o=m<W=o<_<R<V<R<W<R<Q<\\<[<\\<X=n<\\<V<R<Y=n<R<_<X<\\<S<R=k=n<T<s<R=m<W<Y=n<\\<V<T<Y<Q<R<^=g<U=m=n<R<T=n=n<\\<V<T=i=m=l<\\<[=o<M<\\<Q<V=n=h<R=l=o<P<v<R<_<X<\\<V<Q<T<_<T=m<W<R<^<\\<Q<\\=d<Y<U<Q<\\<U=n<T=m<^<R<T<P=m<^=c<[=`<W=b<]<R<U=k<\\=m=n<R=m=l<Y<X<T<v=l<R<P<Y<H<R=l=o<P=l=g<Q<V<Y=m=n<\\<W<T<S<R<T=m<V=n=g=m=c=k<P<Y=m=c=j=j<Y<Q=n=l=n=l=o<X<\\=m<\\<P=g=i=l=g<Q<V<\\<q<R<^=g<U=k<\\=m<R<^<P<Y=m=n<\\=h<T<W=`<P<P<\\=l=n<\\=m=n=l<\\<Q<P<Y=m=n<Y=n<Y<V=m=n<Q<\\=d<T=i<P<T<Q=o=n<T<P<Y<Q<T<T<P<Y=b=n<Q<R<P<Y=l<_<R=l<R<X=m<\\<P<R<P=a=n<R<P=o<V<R<Q=j<Y=m<^<R<Y<P<V<\\<V<R<U<|=l=i<T<^5i5j4F4C5e4I4]4_4K5h4]4_4K5h4E4K5h4U4K5i5o4F4D5k4K4D4]4K5i4@4K5h5f5d5i4K5h4Y5d4]4@4C5f4C4E4K5h4U4Z5d4I4Z4K5m4E4K5h5n4_5i4K5h4U4K4D4F4A5i5f5h5i5h5m4K4F5i5h4F5n5e4F4U4C5f5h4K5h4X4U4]4O4B4D4K4]4F4[5d5f4]4U5h5f5o5i4I4]5m4K5n4[5h4D4K4F4K5h5h4V4E4F4]4F5f4D4K5h5j4K4_4K5h4X5f4B5i5j4F4C5f4K5h4U4]4D4K5h5n4Y4Y4K5m5h4K5i4U5h5f5k4K4F4A4C5f4G4K5h5h5k5i4K5h4U5i5h5i5o4F4D4E5f5i5o5j5o4K5h4[5m5h5m5f4C5f5d4I4C4K4]4E4F4K4]5f4B4K5h4Y4A4E4F4_4@5f5h4K5h5d5n4F4U5j4C5i4K5i4C5f5j4E4F4Y5i5f5i4O4]4X5f5m4K5h4\\5f5j4U4]4D5f4E4D5d4K4D4E4O5h4U4K4D4K5h4_5m4]5i4X4K5o5h4F4U4K5h5e4K5h4O5d5h4K5h4_5j4E4@4K5i4U4E4K5h4Y4A5m4K5h4C5f5j5o5h5i4K4F4K5h4B4K4Y4K5h5i5h5m4O4U4Z4K4M5o4F4K4D4E4K5h4B5f4]4]4_4K4J5h4K5h5n5h4D4K5h4O4C4D5i5n4K4[4U5i4]4K4_5h5i5j4[5n4E4K5h5o4F4D4K5h4]4@5h4K4X4F4]5o4K5h5n4C5i5f4U4[5f5opAzWbdMbnf+-isd!#bow>!2s{#plojg# -dje!#bow>!wqbmpsbqfmwjmelqnbwjlmbssoj`bwjlm!#lm`oj`h>!fpwbaojpkfgbgufqwjpjmd-smd!#bow>!fmujqlmnfmwsfqelqnbm`fbssqlsqjbwf%bns8ngbpk8jnnfgjbwfoz?,pwqlmd=?,qbwkfq#wkbmwfnsfqbwvqfgfufolsnfmw`lnsfwjwjlmsob`fklogfqujpjajojwz9`lszqjdkw!=3!#kfjdkw>!fufm#wklvdkqfsob`fnfmwgfpwjmbwjlm@lqslqbwjlm?vo#`obpp>!Bppl`jbwjlmjmgjujgvbopsfqpsf`wjufpfwWjnflvw+vqo+kwws9,,nbwkfnbwj`pnbqdjm.wls9fufmwvbooz#gfp`qjswjlm*#ml.qfsfbw`loof`wjlmp-ISDwkvnasbqwj`jsbwf,kfbg=?algzeolbw9ofew8?oj#`obpp>!kvmgqfgp#le		Kltfufq/#`lnslpjwjlm`ofbq9alwk8`llsfqbwjlmtjwkjm#wkf#obafo#elq>!alqgfq.wls9Mft#Yfbobmgqf`lnnfmgfgsklwldqbskzjmwfqfpwjmd%ow8pvs%dw8`lmwqlufqpzMfwkfqobmgpbowfqmbwjufnb{ofmdwk>!ptjwyfqobmgGfufolsnfmwfppfmwjbooz		Bowklvdk#?,wf{wbqfb=wkvmgfqajqgqfsqfpfmwfg%bns8mgbpk8psf`vobwjlm`lnnvmjwjfpofdjpobwjlmfof`wqlmj`p	\n?gju#jg>!joovpwqbwfgfmdjmffqjmdwfqqjwlqjfpbvwklqjwjfpgjpwqjavwfg5!#kfjdkw>!pbmp.pfqje8`bsbaof#le#gjpbssfbqfgjmwfqb`wjufollhjmd#elqjw#tlvog#afBedkbmjpwbmtbp#`qfbwfgNbwk-eollq+pvqqlvmgjmd`bm#bopl#aflapfqubwjlmnbjmwfmbm`ffm`lvmwfqfg?k1#`obpp>!nlqf#qf`fmwjw#kbp#affmjmubpjlm#le*-dfwWjnf+*evmgbnfmwboGfpsjwf#wkf!=?gju#jg>!jmpsjqbwjlmf{bnjmbwjlmsqfsbqbwjlmf{sobmbwjlm?jmsvw#jg>!?,b=?,psbm=ufqpjlmp#lejmpwqvnfmwpafelqf#wkf##>#$kwws9,,Gfp`qjswjlmqfobwjufoz#-pvapwqjmd+fb`k#le#wkff{sfqjnfmwpjmeovfmwjbojmwfdqbwjlmnbmz#sflsofgvf#wl#wkf#`lnajmbwjlmgl#mlw#kbufNjggof#Fbpw?mlp`qjsw=?`lszqjdkw!#sfqkbsp#wkfjmpwjwvwjlmjm#Gf`fnafqbqqbmdfnfmwnlpw#ebnlvpsfqplmbojwz`qfbwjlm#leojnjwbwjlmpf{`ovpjufozplufqfjdmwz.`lmwfmw!=	?wg#`obpp>!vmgfqdqlvmgsbqboofo#wlgl`wqjmf#lel``vsjfg#azwfqnjmloldzQfmbjppbm`fb#mvnafq#lepvsslqw#elqf{solqbwjlmqf`ldmjwjlmsqfgf`fpplq?jnd#pq`>!,?k2#`obpp>!svaoj`bwjlmnbz#bopl#afpsf`jbojyfg?,ejfogpfw=sqldqfppjufnjoojlmp#lepwbwfp#wkbwfmelq`fnfmwbqlvmg#wkf#lmf#bmlwkfq-sbqfmwMlgfbdqj`vowvqfBowfqmbwjufqfpfbq`kfqpwltbqgp#wkfNlpw#le#wkfnbmz#lwkfq#+fpsf`jbooz?wg#tjgwk>!8tjgwk9233&jmgfsfmgfmw?k0#`obpp>!#lm`kbmdf>!*-bgg@obpp+jmwfqb`wjlmLmf#le#wkf#gbvdkwfq#leb``fpplqjfpaqbm`kfp#le	?gju#jg>!wkf#obqdfpwgf`obqbwjlmqfdvobwjlmpJmelqnbwjlmwqbmpobwjlmgl`vnfmwbqzjm#lqgfq#wl!=	?kfbg=	?!#kfjdkw>!2b`qlpp#wkf#lqjfmwbwjlm*8?,p`qjsw=jnsofnfmwfg`bm#af#pffmwkfqf#tbp#bgfnlmpwqbwf`lmwbjmfq!=`lmmf`wjlmpwkf#Aqjwjpktbp#tqjwwfm"jnslqwbmw8s{8#nbqdjm.elooltfg#azbajojwz#wl#`lnsoj`bwfggvqjmd#wkf#jnnjdqbwjlmbopl#`boofg?k7#`obpp>!gjpwjm`wjlmqfsob`fg#azdlufqmnfmwpol`bwjlm#lejm#Mlufnafqtkfwkfq#wkf?,s=	?,gju=b`rvjpjwjlm`boofg#wkf#sfqpf`vwjlmgfpjdmbwjlmxelmw.pjyf9bssfbqfg#jmjmufpwjdbwff{sfqjfm`fgnlpw#ojhfoztjgfoz#vpfggjp`vppjlmpsqfpfm`f#le#+gl`vnfmw-f{wfmpjufozJw#kbp#affmjw#glfp#mlw`lmwqbqz#wljmkbajwbmwpjnsqlufnfmwp`klobqpkjs`lmpvnswjlmjmpwqv`wjlmelq#f{bnsoflmf#lq#nlqfs{8#sbggjmdwkf#`vqqfmwb#pfqjfp#lebqf#vpvboozqlof#jm#wkfsqfujlvpoz#gfqjubwjufpfujgfm`f#lef{sfqjfm`fp`lolqp`kfnfpwbwfg#wkbw`fqwjej`bwf?,b=?,gju=	#pfof`wfg>!kjdk#p`klloqfpslmpf#wl`lnelqwbaofbglswjlm#lewkqff#zfbqpwkf#`lvmwqzjm#Efaqvbqzpl#wkbw#wkfsflsof#tkl#sqlujgfg#az?sbqbn#mbnfbeef`wfg#azjm#wfqnp#lebssljmwnfmwJPL.;;6:.2!tbp#alqm#jmkjpwlqj`bo#qfdbqgfg#bpnfbpvqfnfmwjp#abpfg#lm#bmg#lwkfq#9#evm`wjlm+pjdmjej`bmw`fofaqbwjlmwqbmpnjwwfg,ip,irvfqz-jp#hmltm#bpwkflqfwj`bo#wbajmgf{>!jw#`lvog#af?mlp`qjsw=	kbujmd#affm	?kfbg=	?#%rvlw8Wkf#`lnsjobwjlmkf#kbg#affmsqlgv`fg#azskjolplskfq`lmpwqv`wfgjmwfmgfg#wlbnlmd#lwkfq`lnsbqfg#wlwl#pbz#wkbwFmdjmffqjmdb#gjeefqfmwqfefqqfg#wlgjeefqfm`fpafojfe#wkbwsklwldqbskpjgfmwjezjmdKjpwlqz#le#Qfsvaoj`#lemf`fppbqjozsqlabajojwzwf`kmj`boozofbujmd#wkfpsf`wb`vobqeqb`wjlm#lefof`wqj`jwzkfbg#le#wkfqfpwbvqbmwpsbqwmfqpkjsfnskbpjp#lmnlpw#qf`fmwpkbqf#tjwk#pbzjmd#wkbwejoofg#tjwkgfpjdmfg#wljw#jp#lewfm!=?,jeqbnf=bp#elooltp9nfqdfg#tjwkwkqlvdk#wkf`lnnfq`jbo#sljmwfg#lvwlsslqwvmjwzujft#le#wkfqfrvjqfnfmwgjujpjlm#lesqldqbnnjmdkf#qf`fjufgpfwJmwfqubo!=?,psbm=?,jm#Mft#Zlqhbggjwjlmbo#`lnsqfppjlm		?gju#jg>!jm`lqslqbwf8?,p`qjsw=?bwwb`kFufmwaf`bnf#wkf#!#wbqdfw>!\\`bqqjfg#lvwPlnf#le#wkfp`jfm`f#bmgwkf#wjnf#le@lmwbjmfq!=nbjmwbjmjmd@kqjpwlskfqNv`k#le#wkftqjwjmdp#le!#kfjdkw>!1pjyf#le#wkfufqpjlm#le#nj{wvqf#le#afwtffm#wkfF{bnsofp#lefgv`bwjlmbo`lnsfwjwjuf#lmpvanjw>!gjqf`wlq#legjpwjm`wjuf,GWG#[KWNO#qfobwjmd#wlwfmgfm`z#wlsqlujm`f#letkj`k#tlvoggfpsjwf#wkfp`jfmwjej`#ofdjpobwvqf-jmmfqKWNO#boofdbwjlmpBdqj`vowvqftbp#vpfg#jmbssqlb`k#wljmwfoojdfmwzfbqp#obwfq/pbmp.pfqjegfwfqnjmjmdSfqelqnbm`fbssfbqbm`fp/#tkj`k#jp#elvmgbwjlmpbaaqfujbwfgkjdkfq#wkbmp#eqln#wkf#jmgjujgvbo#`lnslpfg#lepvsslpfg#wl`objnp#wkbwbwwqjavwjlmelmw.pjyf92fofnfmwp#leKjpwlqj`bo#kjp#aqlwkfqbw#wkf#wjnfbmmjufqpbqzdlufqmfg#azqfobwfg#wl#vowjnbwfoz#jmmlubwjlmpjw#jp#pwjoo`bm#lmoz#afgfejmjwjlmpwlDNWPwqjmdB#mvnafq#lejnd#`obpp>!Fufmwvbooz/tbp#`kbmdfgl``vqqfg#jmmfjdkalqjmdgjpwjmdvjpktkfm#kf#tbpjmwqlgv`jmdwfqqfpwqjboNbmz#le#wkfbqdvfp#wkbwbm#Bnfqj`bm`lmrvfpw#letjgfpsqfbg#tfqf#hjoofgp`qffm#bmg#Jm#lqgfq#wlf{sf`wfg#wlgfp`fmgbmwpbqf#ol`bwfgofdjpobwjufdfmfqbwjlmp#ab`hdqlvmgnlpw#sflsofzfbqp#bewfqwkfqf#jp#mlwkf#kjdkfpweqfrvfmwoz#wkfz#gl#mlwbqdvfg#wkbwpkltfg#wkbwsqfglnjmbmwwkfloldj`boaz#wkf#wjnf`lmpjgfqjmdpklqw.ojufg?,psbm=?,b=`bm#af#vpfgufqz#ojwwoflmf#le#wkf#kbg#boqfbgzjmwfqsqfwfg`lnnvmj`bwfefbwvqfp#ledlufqmnfmw/?,mlp`qjsw=fmwfqfg#wkf!#kfjdkw>!0Jmgfsfmgfmwslsvobwjlmpobqdf.p`bof-#Bowklvdk#vpfg#jm#wkfgfpwqv`wjlmslppjajojwzpwbqwjmd#jmwtl#lq#nlqff{sqfppjlmppvalqgjmbwfobqdfq#wkbmkjpwlqz#bmg?,lswjlm=	@lmwjmfmwbofojnjmbwjmdtjoo#mlw#afsqb`wj`f#lejm#eqlmw#lepjwf#le#wkffmpvqf#wkbwwl#`qfbwf#bnjppjppjssjslwfmwjboozlvwpwbmgjmdafwwfq#wkbmtkbw#jp#mltpjwvbwfg#jmnfwb#mbnf>!WqbgjwjlmbopvddfpwjlmpWqbmpobwjlmwkf#elqn#lebwnlpskfqj`jgfloldj`bofmwfqsqjpfp`bo`vobwjmdfbpw#le#wkfqfnmbmwp#lesovdjmpsbdf,jmgf{-sks<qfnbjmfg#jmwqbmpelqnfgKf#tbp#bopltbp#boqfbgzpwbwjpwj`bojm#ebulq#leNjmjpwqz#lenlufnfmw#leelqnvobwjlmjp#qfrvjqfg?ojmh#qfo>!Wkjp#jp#wkf#?b#kqfe>!,slsvobqjyfgjmuloufg#jmbqf#vpfg#wlbmg#pfufqbonbgf#az#wkfpffnp#wl#afojhfoz#wkbwSbofpwjmjbmmbnfg#bewfqjw#kbg#affmnlpw#`lnnlmwl#qfefq#wlavw#wkjp#jp`lmpf`vwjufwfnslqbqjozJm#dfmfqbo/`lmufmwjlmpwbhfp#sob`fpvagjujpjlmwfqqjwlqjbolsfqbwjlmbosfqnbmfmwoztbp#obqdfozlvwaqfbh#lejm#wkf#sbpwelooltjmd#b#{nomp9ld>!=?b#`obpp>!`obpp>!wf{w@lmufqpjlm#nbz#af#vpfgnbmveb`wvqfbewfq#afjmd`ofbqej{!=	rvfpwjlm#letbp#fof`wfgwl#af`lnf#baf`bvpf#le#plnf#sflsofjmpsjqfg#azpv``fppevo#b#wjnf#tkfmnlqf#`lnnlmbnlmdpw#wkfbm#leej`jbotjgwk9233&8wf`kmloldz/tbp#bglswfgwl#hffs#wkfpfwwofnfmwpojuf#ajqwkpjmgf{-kwno!@lmmf`wj`vwbppjdmfg#wl%bns8wjnfp8b``lvmw#elqbojdm>qjdkwwkf#`lnsbmzbotbzp#affmqfwvqmfg#wljmuloufnfmwAf`bvpf#wkfwkjp#sfqjlg!#mbnf>!r!#`lmejmfg#wlb#qfpvow#leubovf>!!#,=jp#b`wvboozFmujqlmnfmw	?,kfbg=	@lmufqpfoz/=	?gju#jg>!3!#tjgwk>!2jp#sqlabaozkbuf#af`lnf`lmwqloojmdwkf#sqlaofn`jwjyfmp#leslojwj`jbmpqfb`kfg#wkfbp#fbqoz#bp9mlmf8#lufq?wbaof#`fooubojgjwz#legjqf`woz#wllmnlvpfgltmtkfqf#jw#jptkfm#jw#tbpnfnafqp#le#qfobwjlm#wlb``lnnlgbwfbolmd#tjwk#Jm#wkf#obwfwkf#Fmdojpkgfoj`jlvp!=wkjp#jp#mlwwkf#sqfpfmwje#wkfz#bqfbmg#ejmboozb#nbwwfq#le	\n?,gju=		?,p`qjsw=ebpwfq#wkbmnbilqjwz#lebewfq#tkj`k`lnsbqbwjufwl#nbjmwbjmjnsqluf#wkfbtbqgfg#wkffq!#`obpp>!eqbnfalqgfqqfpwlqbwjlmjm#wkf#pbnfbmbozpjp#lewkfjq#ejqpwGvqjmd#wkf#`lmwjmfmwbopfrvfm`f#leevm`wjlm+*xelmw.pjyf9#tlqh#lm#wkf?,p`qjsw=	?afdjmp#tjwkibubp`qjsw9`lmpwjwvfmwtbp#elvmgfgfrvjojaqjvnbppvnf#wkbwjp#djufm#azmffgp#wl#af`llqgjmbwfpwkf#ubqjlvpbqf#sbqw#lelmoz#jm#wkfpf`wjlmp#lejp#b#`lnnlmwkflqjfp#legjp`lufqjfpbppl`jbwjlmfgdf#le#wkfpwqfmdwk#leslpjwjlm#jmsqfpfmw.gbzvmjufqpboozwl#elqn#wkfavw#jmpwfbg`lqslqbwjlmbwwb`kfg#wljp#`lnnlmozqfbplmp#elq#%rvlw8wkf#`bm#af#nbgftbp#baof#wltkj`k#nfbmpavw#gjg#mlwlmNlvpfLufqbp#slppjaoflsfqbwfg#az`lnjmd#eqlnwkf#sqjnbqzbggjwjlm#leelq#pfufqbowqbmpefqqfgb#sfqjlg#lebqf#baof#wlkltfufq/#jwpklvog#kbufnv`k#obqdfq	\n?,p`qjsw=bglswfg#wkfsqlsfqwz#legjqf`wfg#azfeef`wjufoztbp#aqlvdkw`kjogqfm#leSqldqbnnjmdolmdfq#wkbmnbmvp`qjswptbq#bdbjmpwaz#nfbmp#lebmg#nlpw#lepjnjobq#wl#sqlsqjfwbqzlqjdjmbwjmdsqfpwjdjlvpdqbnnbwj`bof{sfqjfm`f-wl#nbhf#wkfJw#tbp#bopljp#elvmg#jm`lnsfwjwlqpjm#wkf#V-P-qfsob`f#wkfaqlvdkw#wkf`bo`vobwjlmeboo#le#wkfwkf#dfmfqbosqb`wj`boozjm#klmlq#leqfofbpfg#jmqfpjgfmwjbobmg#plnf#lehjmd#le#wkfqfb`wjlm#wl2pw#Fbqo#le`vowvqf#bmgsqjm`jsbooz?,wjwof=	##wkfz#`bm#afab`h#wl#wkfplnf#le#kjpf{slpvqf#wlbqf#pjnjobqelqn#le#wkfbggEbulqjwf`jwjyfmpkjssbqw#jm#wkfsflsof#tjwkjm#sqb`wj`fwl#`lmwjmvf%bns8njmvp8bssqlufg#az#wkf#ejqpw#booltfg#wkfbmg#elq#wkfevm`wjlmjmdsobzjmd#wkfplovwjlm#wlkfjdkw>!3!#jm#kjp#allhnlqf#wkbm#belooltp#wkf`qfbwfg#wkfsqfpfm`f#jm%maps8?,wg=mbwjlmbojpwwkf#jgfb#leb#`kbqb`wfqtfqf#elq`fg#`obpp>!awmgbzp#le#wkfefbwvqfg#jmpkltjmd#wkfjmwfqfpw#jmjm#sob`f#lewvqm#le#wkfwkf#kfbg#leOlqg#le#wkfslojwj`boozkbp#jwp#ltmFgv`bwjlmbobssqlubo#leplnf#le#wkffb`k#lwkfq/afkbujlq#lebmg#af`bvpfbmg#bmlwkfqbssfbqfg#lmqf`lqgfg#jmaob`h%rvlw8nbz#jm`ovgfwkf#tlqog$p`bm#ofbg#wlqfefqp#wl#balqgfq>!3!#dlufqmnfmw#tjmmjmd#wkfqfpvowfg#jm#tkjof#wkf#Tbpkjmdwlm/wkf#pvaif`w`jwz#jm#wkf=?,gju=	\n\nqfeof`w#wkfwl#`lnsofwfaf`bnf#nlqfqbgjlb`wjufqfif`wfg#aztjwklvw#bmzkjp#ebwkfq/tkj`k#`lvog`lsz#le#wkfwl#jmgj`bwfb#slojwj`bob``lvmwp#le`lmpwjwvwfptlqhfg#tjwkfq?,b=?,oj=le#kjp#ojefb``lnsbmjfg`ojfmwTjgwksqfufmw#wkfOfdjpobwjufgjeefqfmwozwldfwkfq#jmkbp#pfufqboelq#bmlwkfqwf{w#le#wkfelvmgfg#wkff#tjwk#wkf#jp#vpfg#elq`kbmdfg#wkfvpvbooz#wkfsob`f#tkfqftkfqfbp#wkf=#?b#kqfe>!!=?b#kqfe>!wkfnpfoufp/bowklvdk#kfwkbw#`bm#afwqbgjwjlmboqlof#le#wkfbp#b#qfpvowqfnluf@kjoggfpjdmfg#aztfpw#le#wkfPlnf#sflsofsqlgv`wjlm/pjgf#le#wkfmftpofwwfqpvpfg#az#wkfgltm#wl#wkfb``fswfg#azojuf#jm#wkfbwwfnswp#wllvwpjgf#wkfeqfrvfm`jfpKltfufq/#jmsqldqbnnfqpbw#ofbpw#jmbssql{jnbwfbowklvdk#jwtbp#sbqw#lebmg#ubqjlvpDlufqmlq#lewkf#bqwj`ofwvqmfg#jmwl=?b#kqfe>!,wkf#f`lmlnzjp#wkf#nlpwnlpw#tjgfoztlvog#obwfqbmg#sfqkbspqjpf#wl#wkfl``vqp#tkfmvmgfq#tkj`k`lmgjwjlmp-wkf#tfpwfqmwkflqz#wkbwjp#sqlgv`fgwkf#`jwz#lejm#tkj`k#kfpffm#jm#wkfwkf#`fmwqboavjogjmd#lenbmz#le#kjpbqfb#le#wkfjp#wkf#lmoznlpw#le#wkfnbmz#le#wkfwkf#TfpwfqmWkfqf#jp#mlf{wfmgfg#wlPwbwjpwj`bo`lopsbm>1#pklqw#pwlqzslppjaof#wlwlsloldj`bo`qjwj`bo#leqfslqwfg#wlb#@kqjpwjbmgf`jpjlm#wljp#frvbo#wlsqlaofnp#leWkjp#`bm#afnfq`kbmgjpfelq#nlpw#leml#fujgfm`ffgjwjlmp#lefofnfmwp#jm%rvlw8-#Wkf`ln,jnbdfp,tkj`k#nbhfpwkf#sql`fppqfnbjmp#wkfojwfqbwvqf/jp#b#nfnafqwkf#slsvobqwkf#bm`jfmwsqlaofnp#jmwjnf#le#wkfgfefbwfg#azalgz#le#wkfb#eft#zfbqpnv`k#le#wkfwkf#tlqh#le@bojelqmjb/pfqufg#bp#bdlufqmnfmw-`lm`fswp#lenlufnfmw#jm\n\n?gju#jg>!jw!#ubovf>!obmdvbdf#lebp#wkfz#bqfsqlgv`fg#jmjp#wkbw#wkff{sobjm#wkfgju=?,gju=	Kltfufq#wkfofbg#wl#wkf\n?b#kqfe>!,tbp#dqbmwfgsflsof#kbuf`lmwjmvbooztbp#pffm#bpbmg#qfobwfgwkf#qlof#lesqlslpfg#azle#wkf#afpwfb`k#lwkfq-@lmpwbmwjmfsflsof#eqlngjbof`wp#lewl#qfujpjlmtbp#qfmbnfgb#plvq`f#lewkf#jmjwjboobvm`kfg#jmsqlujgf#wkfwl#wkf#tfpwtkfqf#wkfqfbmg#pjnjobqafwtffm#wtljp#bopl#wkfFmdojpk#bmg`lmgjwjlmp/wkbw#jw#tbpfmwjwofg#wlwkfnpfoufp-rvbmwjwz#leqbmpsbqfm`zwkf#pbnf#bpwl#iljm#wkf`lvmwqz#bmgwkjp#jp#wkfWkjp#ofg#wlb#pwbwfnfmw`lmwqbpw#wlobpwJmgf{Lewkqlvdk#kjpjp#gfpjdmfgwkf#wfqn#jpjp#sqlujgfgsqlwf`w#wkfmd?,b=?,oj=Wkf#`vqqfmwwkf#pjwf#lepvapwbmwjbof{sfqjfm`f/jm#wkf#Tfpwwkfz#pklvogpolufm(ajmb`lnfmwbqjlpvmjufqpjgbg`lmgj`jlmfpb`wjujgbgfpf{sfqjfm`jbwf`mlold/Absqlgv``j/_msvmwvb`j/_mbsoj`b`j/_m`lmwqbpf/]b`bwfdlq/Abpqfdjpwqbqpfsqlefpjlmbowqbwbnjfmwlqfd/Apwqbwfpf`qfwbq/Absqjm`jsbofpsqlwf``j/_mjnslqwbmwfpjnslqwbm`jbslpjajojgbgjmwfqfpbmwf`qf`jnjfmwlmf`fpjgbgfppvp`qjajqpfbpl`jb`j/_mgjpslmjaofpfubovb`j/_mfpwvgjbmwfpqfpslmpbaofqfplov`j/_mdvbgbobibqbqfdjpwqbglplslqwvmjgbg`lnfq`jbofpelwldqbe/Abbvwlqjgbgfpjmdfmjfq/Abwfofujpj/_m`lnsfwfm`jblsfqb`jlmfpfpwbaof`jglpjnsofnfmwfb`wvbonfmwfmbufdb`j/_m`lmelqnjgbgojmf.kfjdkw9elmw.ebnjoz9!#9#!kwws9,,bssoj`bwjlmpojmh!#kqfe>!psf`jej`booz,,?"X@GBWBX	Lqdbmjybwjlmgjpwqjavwjlm3s{8#kfjdkw9qfobwjlmpkjsgfuj`f.tjgwk?gju#`obpp>!?obafo#elq>!qfdjpwqbwjlm?,mlp`qjsw=	,jmgf{-kwno!tjmglt-lsfm+#"jnslqwbmw8bssoj`bwjlm,jmgfsfmgfm`f,,ttt-dlldoflqdbmjybwjlmbvwl`lnsofwfqfrvjqfnfmwp`lmpfqubwjuf?elqn#mbnf>!jmwfoof`wvbonbqdjm.ofew92;wk#`fmwvqzbm#jnslqwbmwjmpwjwvwjlmpbaaqfujbwjlm?jnd#`obpp>!lqdbmjpbwjlm`jujojybwjlm2:wk#`fmwvqzbq`kjwf`wvqfjm`lqslqbwfg13wk#`fmwvqz.`lmwbjmfq!=nlpw#mlwbaoz,=?,b=?,gju=mlwjej`bwjlm$vmgfejmfg$*Evqwkfqnlqf/afojfuf#wkbwjmmfqKWNO#>#sqjlq#wl#wkfgqbnbwj`boozqfefqqjmd#wlmfdlwjbwjlmpkfbgrvbqwfqpPlvwk#Beqj`bvmpv``fppevoSfmmpzoubmjbBp#b#qfpvow/?kwno#obmd>!%ow8,pvs%dw8gfbojmd#tjwkskjobgfoskjbkjpwlqj`booz*8?,p`qjsw=	sbggjmd.wls9f{sfqjnfmwbodfwBwwqjavwfjmpwqv`wjlmpwf`kmloldjfpsbqw#le#wkf#>evm`wjlm+*xpvap`qjswjlmo-gwg!=	?kwdfldqbskj`bo@lmpwjwvwjlm$/#evm`wjlm+pvsslqwfg#azbdqj`vowvqbo`lmpwqv`wjlmsvaoj`bwjlmpelmw.pjyf9#2b#ubqjfwz#le?gju#pwzof>!Fm`z`olsfgjbjeqbnf#pq`>!gfnlmpwqbwfgb``lnsojpkfgvmjufqpjwjfpGfnldqbskj`p*8?,p`qjsw=?gfgj`bwfg#wlhmltofgdf#lepbwjpeb`wjlmsbqwj`vobqoz?,gju=?,gju=Fmdojpk#+VP*bssfmg@kjog+wqbmpnjppjlmp-#Kltfufq/#jmwfoojdfm`f!#wbajmgf{>!eolbw9qjdkw8@lnnlmtfbowkqbmdjmd#eqlnjm#tkj`k#wkfbw#ofbpw#lmfqfsqlgv`wjlmfm`z`olsfgjb8elmw.pjyf92ivqjpgj`wjlmbw#wkbw#wjnf!=?b#`obpp>!Jm#bggjwjlm/gfp`qjswjlm(`lmufqpbwjlm`lmwb`w#tjwkjp#dfmfqboozq!#`lmwfmw>!qfsqfpfmwjmd%ow8nbwk%dw8sqfpfmwbwjlml``bpjlmbooz?jnd#tjgwk>!mbujdbwjlm!=`lnsfmpbwjlm`kbnsjlmpkjsnfgjb>!boo!#ujlobwjlm#leqfefqfm`f#wlqfwvqm#wqvf8Pwqj`w,,FM!#wqbmpb`wjlmpjmwfqufmwjlmufqjej`bwjlmJmelqnbwjlm#gjeej`vowjfp@kbnsjlmpkjs`bsbajojwjfp?"Xfmgje^..=~	?,p`qjsw=	@kqjpwjbmjwzelq#f{bnsof/Sqlefppjlmboqfpwqj`wjlmppvddfpw#wkbwtbp#qfofbpfg+pv`k#bp#wkfqfnluf@obpp+vmfnsolznfmwwkf#Bnfqj`bmpwqv`wvqf#le,jmgf{-kwno#svaojpkfg#jmpsbm#`obpp>!!=?b#kqfe>!,jmwqlgv`wjlmafolmdjmd#wl`objnfg#wkbw`lmpfrvfm`fp?nfwb#mbnf>!Dvjgf#wl#wkflufqtkfonjmdbdbjmpw#wkf#`lm`fmwqbwfg/	-mlmwlv`k#lapfqubwjlmp?,b=	?,gju=	e#+gl`vnfmw-alqgfq9#2s{#xelmw.pjyf92wqfbwnfmw#le3!#kfjdkw>!2nlgjej`bwjlmJmgfsfmgfm`fgjujgfg#jmwldqfbwfq#wkbmb`kjfufnfmwpfpwbaojpkjmdIbubP`qjsw!#mfufqwkfofpppjdmjej`bm`fAqlbg`bpwjmd=%maps8?,wg=`lmwbjmfq!=	pv`k#bp#wkf#jmeovfm`f#leb#sbqwj`vobqpq`>$kwws9,,mbujdbwjlm!#kboe#le#wkf#pvapwbmwjbo#%maps8?,gju=bgubmwbdf#legjp`lufqz#leevmgbnfmwbo#nfwqlslojwbmwkf#lsslpjwf!#{no9obmd>!gfojafqbwfozbojdm>`fmwfqfulovwjlm#lesqfpfqubwjlmjnsqlufnfmwpafdjmmjmd#jmIfpvp#@kqjpwSvaoj`bwjlmpgjpbdqffnfmwwf{w.bojdm9q/#evm`wjlm+*pjnjobqjwjfpalgz=?,kwno=jp#`vqqfmwozboskbafwj`bojp#plnfwjnfpwzsf>!jnbdf,nbmz#le#wkf#eolt9kjggfm8bubjobaof#jmgfp`qjaf#wkff{jpwfm`f#leboo#lufq#wkfwkf#Jmwfqmfw\n?vo#`obpp>!jmpwboobwjlmmfjdkalqkllgbqnfg#elq`fpqfgv`jmd#wkf`lmwjmvfp#wlMlmfwkfofpp/wfnsfqbwvqfp	\n\n?b#kqfe>!`olpf#wl#wkff{bnsofp#le#jp#balvw#wkf+pff#afolt*-!#jg>!pfbq`ksqlefppjlmbojp#bubjobaofwkf#leej`jbo\n\n?,p`qjsw=		\n\n?gju#jg>!b``fofqbwjlmwkqlvdk#wkf#Kboo#le#Ebnfgfp`qjswjlmpwqbmpobwjlmpjmwfqefqfm`f#wzsf>$wf{w,qf`fmw#zfbqpjm#wkf#tlqogufqz#slsvobqxab`hdqlvmg9wqbgjwjlmbo#plnf#le#wkf#`lmmf`wfg#wlf{soljwbwjlmfnfqdfm`f#le`lmpwjwvwjlmB#Kjpwlqz#lepjdmjej`bmw#nbmveb`wvqfgf{sf`wbwjlmp=?mlp`qjsw=?`bm#af#elvmgaf`bvpf#wkf#kbp#mlw#affmmfjdkalvqjmdtjwklvw#wkf#bggfg#wl#wkf\n?oj#`obpp>!jmpwqvnfmwboPlujfw#Vmjlmb`hmltofgdfgtkj`k#`bm#afmbnf#elq#wkfbwwfmwjlm#wlbwwfnswp#wl#gfufolsnfmwpJm#eb`w/#wkf?oj#`obpp>!bjnsoj`bwjlmppvjwbaof#elqnv`k#le#wkf#`lolmjybwjlmsqfpjgfmwjbo`bm`foAvaaof#Jmelqnbwjlmnlpw#le#wkf#jp#gfp`qjafgqfpw#le#wkf#nlqf#lq#ofppjm#PfswfnafqJmwfoojdfm`fpq`>!kwws9,,s{8#kfjdkw9#bubjobaof#wlnbmveb`wvqfqkvnbm#qjdkwpojmh#kqfe>!,bubjobajojwzsqlslqwjlmbolvwpjgf#wkf#bpwqlmlnj`bokvnbm#afjmdpmbnf#le#wkf#bqf#elvmg#jmbqf#abpfg#lmpnboofq#wkbmb#sfqplm#tklf{sbmpjlm#lebqdvjmd#wkbwmlt#hmltm#bpJm#wkf#fbqozjmwfqnfgjbwfgfqjufg#eqlnP`bmgjmbujbm?,b=?,gju=	`lmpjgfq#wkfbm#fpwjnbwfgwkf#Mbwjlmbo?gju#jg>!sbdqfpvowjmd#jm`lnnjppjlmfgbmboldlvp#wlbqf#qfrvjqfg,vo=	?,gju=	tbp#abpfg#lmbmg#af`bnf#b%maps8%maps8w!#ubovf>!!#tbp#`bswvqfgml#nlqf#wkbmqfpsf`wjufoz`lmwjmvf#wl#=	?kfbg=	?tfqf#`qfbwfgnlqf#dfmfqbojmelqnbwjlm#vpfg#elq#wkfjmgfsfmgfmw#wkf#Jnsfqjbo`lnslmfmw#lewl#wkf#mlqwkjm`ovgf#wkf#@lmpwqv`wjlmpjgf#le#wkf#tlvog#mlw#afelq#jmpwbm`fjmufmwjlm#lenlqf#`lnsof{`loof`wjufozab`hdqlvmg9#wf{w.bojdm9#jwp#lqjdjmbojmwl#b``lvmwwkjp#sql`fppbm#f{wfmpjufkltfufq/#wkfwkfz#bqf#mlwqfif`wfg#wkf`qjwj`jpn#legvqjmd#tkj`ksqlabaoz#wkfwkjp#bqwj`of+evm`wjlm+*xJw#pklvog#afbm#bdqffnfmwb``jgfmwboozgjeefqp#eqlnBq`kjwf`wvqfafwwfq#hmltmbqqbmdfnfmwpjmeovfm`f#lmbwwfmgfg#wkfjgfmwj`bo#wlplvwk#le#wkfsbpp#wkqlvdk{no!#wjwof>!tfjdkw9alog8`qfbwjmd#wkfgjpsobz9mlmfqfsob`fg#wkf?jnd#pq`>!,jkwwsp9,,ttt-Tlqog#Tbq#JJwfpwjnlmjbopelvmg#jm#wkfqfrvjqfg#wl#bmg#wkbw#wkfafwtffm#wkf#tbp#gfpjdmfg`lmpjpwp#le#`lmpjgfqbaozsvaojpkfg#azwkf#obmdvbdf@lmpfqubwjlm`lmpjpwfg#leqfefq#wl#wkfab`h#wl#wkf#`pp!#nfgjb>!Sflsof#eqln#bubjobaof#lmsqlufg#wl#afpvddfpwjlmp!tbp#hmltm#bpubqjfwjfp#leojhfoz#wl#af`lnsqjpfg#lepvsslqw#wkf#kbmgp#le#wkf`lvsofg#tjwk`lmmf`w#bmg#alqgfq9mlmf8sfqelqnbm`fpafelqf#afjmdobwfq#af`bnf`bo`vobwjlmplewfm#`boofgqfpjgfmwp#lenfbmjmd#wkbw=?oj#`obpp>!fujgfm`f#elqf{sobmbwjlmpfmujqlmnfmwp!=?,b=?,gju=tkj`k#booltpJmwqlgv`wjlmgfufolsfg#azb#tjgf#qbmdflm#afkboe#leubojdm>!wls!sqjm`jsof#lebw#wkf#wjnf/?,mlp`qjsw=pbjg#wl#kbufjm#wkf#ejqpwtkjof#lwkfqpkzslwkfwj`boskjolplskfqpsltfq#le#wkf`lmwbjmfg#jmsfqelqnfg#azjmbajojwz#wltfqf#tqjwwfmpsbm#pwzof>!jmsvw#mbnf>!wkf#rvfpwjlmjmwfmgfg#elqqfif`wjlm#lejnsojfp#wkbwjmufmwfg#wkfwkf#pwbmgbqgtbp#sqlabaozojmh#afwtffmsqlefpplq#lejmwfqb`wjlmp`kbmdjmd#wkfJmgjbm#L`fbm#`obpp>!obpwtlqhjmd#tjwk$kwws9,,ttt-zfbqp#afelqfWkjp#tbp#wkfqf`qfbwjlmbofmwfqjmd#wkfnfbpvqfnfmwpbm#f{wqfnfozubovf#le#wkfpwbqw#le#wkf	?,p`qjsw=		bm#feelqw#wljm`qfbpf#wkfwl#wkf#plvwkpsb`jmd>!3!=pveej`jfmwozwkf#Fvqlsfbm`lmufqwfg#wl`ofbqWjnflvwgjg#mlw#kbuf`lmpfrvfmwozelq#wkf#mf{wf{wfmpjlm#lef`lmlnj`#bmgbowklvdk#wkfbqf#sqlgv`fgbmg#tjwk#wkfjmpveej`jfmwdjufm#az#wkfpwbwjmd#wkbwf{sfmgjwvqfp?,psbm=?,b=	wklvdkw#wkbwlm#wkf#abpjp`foosbggjmd>jnbdf#le#wkfqfwvqmjmd#wljmelqnbwjlm/pfsbqbwfg#azbppbppjmbwfgp!#`lmwfmw>!bvwklqjwz#lemlqwktfpwfqm?,gju=	?gju#!=?,gju=	##`lmpvowbwjlm`lnnvmjwz#lewkf#mbwjlmbojw#pklvog#afsbqwj`jsbmwp#bojdm>!ofewwkf#dqfbwfpwpfof`wjlm#lepvsfqmbwvqbogfsfmgfmw#lmjp#nfmwjlmfgbooltjmd#wkftbp#jmufmwfgb``lnsbmzjmdkjp#sfqplmbobubjobaof#bwpwvgz#le#wkflm#wkf#lwkfqf{f`vwjlm#leKvnbm#Qjdkwpwfqnp#le#wkfbppl`jbwjlmpqfpfbq`k#bmgpv``ffgfg#azgfefbwfg#wkfbmg#eqln#wkfavw#wkfz#bqf`lnnbmgfq#lepwbwf#le#wkfzfbqp#le#bdfwkf#pwvgz#le?vo#`obpp>!psob`f#jm#wkftkfqf#kf#tbp?oj#`obpp>!ewkfqf#bqf#mltkj`k#af`bnfkf#svaojpkfgf{sqfppfg#jmwl#tkj`k#wkf`lnnjppjlmfqelmw.tfjdkw9wfqqjwlqz#lef{wfmpjlmp!=Qlnbm#Fnsjqffrvbo#wl#wkfJm#`lmwqbpw/kltfufq/#bmgjp#wzsj`boozbmg#kjp#tjef+bopl#`boofg=?vo#`obpp>!feef`wjufoz#fuloufg#jmwlpffn#wl#kbuftkj`k#jp#wkfwkfqf#tbp#mlbm#f{`foofmwboo#le#wkfpfgfp`qjafg#azJm#sqb`wj`f/aqlbg`bpwjmd`kbqdfg#tjwkqfeof`wfg#jmpvaif`wfg#wlnjojwbqz#bmgwl#wkf#sljmwf`lmlnj`boozpfwWbqdfwjmdbqf#b`wvboozuj`wlqz#lufq+*8?,p`qjsw=`lmwjmvlvpozqfrvjqfg#elqfulovwjlmbqzbm#feef`wjufmlqwk#le#wkf/#tkj`k#tbp#eqlmw#le#wkflq#lwkfqtjpfplnf#elqn#lekbg#mlw#affmdfmfqbwfg#azjmelqnbwjlm-sfqnjwwfg#wljm`ovgfp#wkfgfufolsnfmw/fmwfqfg#jmwlwkf#sqfujlvp`lmpjpwfmwozbqf#hmltm#bpwkf#ejfog#lewkjp#wzsf#ledjufm#wl#wkfwkf#wjwof#le`lmwbjmp#wkfjmpwbm`fp#lejm#wkf#mlqwkgvf#wl#wkfjqbqf#gfpjdmfg`lqslqbwjlmptbp#wkbw#wkflmf#le#wkfpfnlqf#slsvobqpv``ffgfg#jmpvsslqw#eqlnjm#gjeefqfmwglnjmbwfg#azgfpjdmfg#elqltmfqpkjs#lebmg#slppjaozpwbmgbqgjyfgqfpslmpfWf{wtbp#jmwfmgfgqf`fjufg#wkfbppvnfg#wkbwbqfbp#le#wkfsqjnbqjoz#jmwkf#abpjp#lejm#wkf#pfmpfb``lvmwp#elqgfpwqlzfg#azbw#ofbpw#wtltbp#gf`obqfg`lvog#mlw#afPf`qfwbqz#lebssfbq#wl#afnbqdjm.wls92,]_p(_p(\',df*xwkqlt#f~8wkf#pwbqw#lewtl#pfsbqbwfobmdvbdf#bmgtkl#kbg#affmlsfqbwjlm#legfbwk#le#wkfqfbo#mvnafqp\n?ojmh#qfo>!sqlujgfg#wkfwkf#pwlqz#le`lnsfwjwjlmpfmdojpk#+VH*fmdojpk#+VP*<p<R<Q<_<R<W<M=l<S=m<V<T=m=l<S=m<V<T=m=l<S=m<V<R5h4U4]4D5f4E\nAOGx\bTA\nzk\vBl\bQ\bTA\nzk\vUm\bQ\bTA\nzk\npeu|	i@	cT\bVV\n\\}\nxS	VptSk`	[X	[X\vHR\bPv\bTW\bUe\na\bQp\v_W\vWs\nxS\vAz\n_yKhjmelqnb`j/_mkfqqbnjfmwbpfof`wq/_mj`lgfp`qjs`j/_m`obpjej`bglp`lml`jnjfmwlsvaoj`b`j/_mqfob`jlmbgbpjmelqn/Mwj`bqfob`jlmbglpgfsbqwbnfmwlwqbabibglqfpgjqf`wbnfmwfbzvmwbnjfmwlnfq`bglOjaqf`lmw/M`wfmlpkbajwb`jlmfp`vnsojnjfmwlqfpwbvqbmwfpgjpslpj`j/_m`lmpf`vfm`jbfof`wq/_mj`bbsoj`b`jlmfpgfp`lmf`wbgljmpwbob`j/_mqfbojyb`j/_mvwjojyb`j/_mfm`j`olsfgjbfmefqnfgbgfpjmpwqvnfmwlpf{sfqjfm`jbpjmpwjwv`j/_msbqwj`vobqfppva`bwfdlqjb=n<R<W=`<V<R<L<R=m=m<T<T=l<\\<]<R=n=g<]<R<W=`=d<Y<S=l<R=m=n<R<P<R<Z<Y=n<Y<X=l=o<_<T=i=m<W=o=k<\\<Y=m<Y<U=k<\\=m<^=m<Y<_<X<\\<L<R=m=m<T=c<p<R=m<V<^<Y<X=l=o<_<T<Y<_<R=l<R<X<\\<^<R<S=l<R=m<X<\\<Q<Q=g=i<X<R<W<Z<Q=g<T<P<Y<Q<Q<R<p<R=m<V<^=g=l=o<]<W<Y<U<p<R=m<V<^<\\=m=n=l<\\<Q=g<Q<T=k<Y<_<R=l<\\<]<R=n<Y<X<R<W<Z<Y<Q=o=m<W=o<_<T=n<Y<S<Y=l=`<r<X<Q<\\<V<R<S<R=n<R<P=o=l<\\<]<R=n=o<\\<S=l<Y<W=c<^<R<R<]=e<Y<R<X<Q<R<_<R=m<^<R<Y<_<R=m=n<\\=n=`<T<X=l=o<_<R<U=h<R=l=o<P<Y=i<R=l<R=d<R<S=l<R=n<T<^=m=m=g<W<V<\\<V<\\<Z<X=g<U<^<W<\\=m=n<T<_=l=o<S<S=g<^<P<Y=m=n<Y=l<\\<]<R=n<\\=m<V<\\<[<\\<W<S<Y=l<^=g<U<X<Y<W<\\=n=`<X<Y<Q=`<_<T<S<Y=l<T<R<X<]<T<[<Q<Y=m<R=m<Q<R<^<Y<P<R<P<Y<Q=n<V=o<S<T=n=`<X<R<W<Z<Q<\\=l<\\<P<V<\\=i<Q<\\=k<\\<W<R<L<\\<]<R=n<\\<N<R<W=`<V<R=m<R<^=m<Y<P<^=n<R=l<R<U<Q<\\=k<\\<W<\\=m<S<T=m<R<V=m<W=o<Z<]=g=m<T=m=n<Y<P<S<Y=k<\\=n<T<Q<R<^<R<_<R<S<R<P<R=e<T=m<\\<U=n<R<^<S<R=k<Y<P=o<S<R<P<R=e=`<X<R<W<Z<Q<R=m=m=g<W<V<T<]=g=m=n=l<R<X<\\<Q<Q=g<Y<P<Q<R<_<T<Y<S=l<R<Y<V=n<M<Y<U=k<\\=m<P<R<X<Y<W<T=n<\\<V<R<_<R<R<Q<W<\\<U<Q<_<R=l<R<X<Y<^<Y=l=m<T=c=m=n=l<\\<Q<Y=h<T<W=`<P=g=o=l<R<^<Q=c=l<\\<[<Q=g=i<T=m<V<\\=n=`<Q<Y<X<Y<W=b=c<Q<^<\\=l=c<P<Y<Q=`=d<Y<P<Q<R<_<T=i<X<\\<Q<Q<R<U<[<Q<\\=k<T=n<Q<Y<W=`<[=c=h<R=l=o<P<\\<N<Y<S<Y=l=`<P<Y=m=c=j<\\<[<\\=e<T=n=g<w=o=k=d<T<Y\fHD\fHU\fIl\fHn\fHy\fH\\\fHD\fIk\fHi\fHF\fHD\fIk\fHy\fHS\fHC\fHR\fHy\fH\\\fIk\fHn\fHi\fHD\fIa\fHC\fHy\fIa\fHC\fHR\fH{\fHR\fHk\fHM\fH@\fHR\fH\\\fIk\fHy\fHS\fHT\fIl\fHJ\fHS\fHC\fHR\fHF\fHU\fH^\fIk\fHT\fHS\fHn\fHU\fHA\fHR\fH\\\fHH\fHi\fHF\fHD\fIl\fHY\fHR\fH^\fIk\fHT\fIk\fHY\fHR\fHy\fH\\\fHH\fIk\fHB\fIk\fH\\\fIk\fHU\fIg\fHD\fIk\fHT\fHy\fHH\fIk\fH@\fHU\fIm\fHH\fHT\fHR\fHk\fHs\fHU\fIg\fH{\fHR\fHp\fHR\fHD\fIk\fHB\fHS\fHD\fHs\fHy\fH\\\fHH\fHR\fHy\fH\\\fHD\fHR\fHe\fHD\fHy\fIk\fHC\fHU\fHR\fHm\fHT\fH@\fHT\fIk\fHA\fHR\fH[\fHR\fHj\fHF\fHy\fIk\fH^\fHS\fHC\fIk\fHZ\fIm\fH\\\fIn\fHk\fHT\fHy\fIk\fHt\fHn\fHs\fIk\fHB\fIk\fH\\\fIl\fHT\fHy\fHH\fHR\fHB\fIk\fH\\\fHR\fH^\fIk\fHy\fH\\\fHi\fHK\fHS\fHy\fHi\fHF\fHD\fHR\fHT\fHB\fHR\fHp\fHB\fIm\fHq\fIk\fHy\fHR\fH\\\fHO\fHU\fIg\fHH\fHR\fHy\fHM\fHP\fIl\fHC\fHU\fHR\fHn\fHU\fIg\fHs\fH^\fHZ\fH@\fIa\fHJ\fH^\fHS\fHC\fHR\fHp\fIl\fHY\fHD\fHp\fHR\fHH\fHR\fHy\fId\fHT\fIk\fHj\fHF\fHy\fHR\fHY\fHR\fH^\fIl\fHJ\fIk\fHD\fIk\fHF\fIn\fH\\\fIl\fHF\fHR\fHD\fIl\fHe\fHT\fHy\fIk\fHU\fIg\fH{\fIl\fH@\fId\fHL\fHy\fHj\fHF\fHy\fIl\fHY\fH\\\fIa\fH[\fH{\fHR\fHn\fHY\fHj\fHF\fHy\fIg\fHp\fHS\fH^\fHR\fHp\fHR\fHD\fHR\fHT\fHU\fHB\fHH\fHU\fHB\fIk\fHn\fHe\fHD\fHy\fIl\fHC\fHR\fHU\fIn\fHJ\fH\\\fIa\fHp\fHT\fIn\fHv\fIl\fHF\fHT\fHn\fHJ\fHT\fHY\fHR\fH^\fHU\fIg\fHD\fHR\fHU\fIg\fHH\fIl\fHp\fId\fHT\fIk\fHY\fHR\fHF\fHT\fHp\fHD\fHH\fHR\fHD\fIk\fHH\fHR\fHp\fHR\fH\\\fIl\fHt\fHR\fHC\fH^\fHp\fHS\fH^\fIk\fHD\fIl\fHv\fIk\fHp\fHR\fHn\fHv\fHF\fHH\fIa\fH\\\fH{\fIn\fH{\fH^\fHp\fHR\fHH\fIk\fH@\fHR\fHU\fH\\\fHj\fHF\fHD\fIk\fHY\fHR\fHU\fHD\fHk\fHT\fHy\fHR\fHT\fIm\fH@\fHU\fH\\\fHU\fHD\fIk\fHk\fHT\fHT\fIk\fHT\fHU\fHS\fHH\fH@\fHM\fHP\fIk\fHt\fHs\fHD\fHR\fHH\fH^\fHR\fHZ\fHF\fHR\fHn\fHv\fHZ\fIa\fH\\\fIl\fH@\fHM\fHP\fIl\fHU\fIg\fHH\fIk\fHT\fHR\fHd\fHs\fHZ\fHR\fHC\fHJ\fHT\fHy\fHH\fIl\fHp\fHR\fHH\fIl\fHY\fHR\fH^\fHR\fHU\fHp\fHR\fH\\\fHF\fHs\fHD\fHR\fH\\\fHz\fHD\fIk\fHT\fHM\fHP\fHy\fHB\fHS\fH^\fHR\fHe\fHT\fHy\fIl\fHy\fIk\fHY\fH^\fH^\fH{\fHH\fHR\fHz\fHR\fHD\fHR\fHi\fH\\\fIa\fHI\fHp\fHU\fHR\fHn\fHJ\fIk\fHz\fHR\fHF\fHU\fH^\fIl\fHD\fHS\fHC\fHB\fH@\fHS\fHD\fHR\fH@\fId\fHn\fHy\fHy\fHU\fIl\fHn\fHy\fHU\fHD\fHR\fHJ\fIk\fHH\fHR\fHU\fHB\fH^\fIk\fHy\fHR\fHG\fIl\fHp\fH@\fHy\fHS\fHH\fIm\fH\\\fHH\fHB\fHR\fHn\fH{\fHY\fHU\fIl\fHn\fH\\\fIg\fHp\fHP\fHB\fHS\fH^\fIl\fHj\fH\\\fIg\fHF\fHT\fIk\fHD\fHR\fHC\fHR\fHJ\fHY\fH^\fIk\fHD\fIk\fHz\fHR\fHH\fHR\fHy\fH\\\fIl\fH@\fHe\fHD\fHy\fHR\fHp\fHY\fHR\fH@\fHF\fIn\fH\\\fHR\fH@\fHM\fHP\fHR\fHT\fI`\fHJ\fHR\fHZ\fIk\fHC\fH\\\fHy\fHS\fHC\fIk\fHy\fHU\fHR\fHn\fHi\fHy\fHT\fH\\\fH@\fHD\fHR\fHc\fHY\fHU\fHR\fHn\fHT\fIa\fHI\fH^\fHB\fHS\fH^\fIk\fH^\fIk\fHz\fHy\fHY\fHS\fH[\fHC\fHy\fIa\fH\\\fHn\fHT\fHB\fIn\fHU\fHI\fHR\fHD\fHR4F4_4F4[5f4U5i4X4K4]5o4E4D5d4K4_4[4E4K5h4Y5m4A4E5i5d4K4Z5f4U4K5h4B4K4Y4E4K5h5i4^5f4C4K5h4U4K5i4E4K5h5o4K4F4D4K5h4]4C5d4C4D4]5j4K5i4@4K5h4C5d5h4E4K5h4U4K5h5i4K5h5i5d5n4U4K5h4U4]4D5f4K5h4_4]5f4U4K5h4@5d4K5h4K5h4\\5k4K4D4K5h4A5f4K4E4K5h4A5n5d5n4K5h5o4]5f5i4K5h4U4]4K5n5i4A5m5d4T4E4K5h4G4K5j5f5i4X4K5k4C4E4K5h5i4]4O4E4K5h5n4]4N5j4K5h4X4D4K4D4K5h4A5d4K4]4K5h4@4C5f4C4K5h4O4_4]4E4K5h4U5h5d5i5i4@5i5d4U4E4K5h4]4A5i5j4K5h5j5n4K4[5m5h4_4[5f5j4K5h5o5d5f4F4K5h4C5j5f4K4D4]5o4K4F5k4K5h4]5f4K4Z4F4A5f4K4F5f4D4F5d5n5f4F4K5h4O5d5h5e4K5h4D4]5f4C4K5h5o5h4K5i4K5h4]4K4D4[4K5h4X4B4Y5f4_5f4K4]4K4F4K5h4G4K5h4G4K5h4Y5h4K4E4K5h4A4C5f4G4K5h4^5d4K4]4K5h4B5h5f4@4K5h4@5i5f4U4K5h4U4K5i5k4K5h4@5i4K5h4K5h4_4K4U4E5i4X4K5k4C5k4K5h4]4J5f4_4K5h4C4B5d5h4K5h5m5j5f4E4K5h5o4F4K4D4K5h4C5d4]5f4K5h4C4]5d4_4K4_4F4V4]5n4F4Y4K5i5f5i4K5h4D5j4K4F4K5h4U4T5f5ifmwfqwbjmnfmwvmgfqpwbmgjmd#>#evm`wjlm+*-isd!#tjgwk>!`lmejdvqbwjlm-smd!#tjgwk>!?algz#`obpp>!Nbwk-qbmgln+*`lmwfnslqbqz#Vmjwfg#Pwbwfp`jq`vnpwbm`fp-bssfmg@kjog+lqdbmjybwjlmp?psbm#`obpp>!!=?jnd#pq`>!,gjpwjmdvjpkfgwklvpbmgp#le#`lnnvmj`bwjlm`ofbq!=?,gju=jmufpwjdbwjlmebuj`lm-j`l!#nbqdjm.qjdkw9abpfg#lm#wkf#Nbppb`kvpfwwpwbaof#alqgfq>jmwfqmbwjlmbobopl#hmltm#bpsqlmvm`jbwjlmab`hdqlvmg9 esbggjmd.ofew9Elq#f{bnsof/#njp`foobmflvp%ow8,nbwk%dw8spz`kloldj`bojm#sbqwj`vobqfbq`k!#wzsf>!elqn#nfwklg>!bp#lsslpfg#wlPvsqfnf#@lvqwl``bpjlmbooz#Bggjwjlmbooz/Mlqwk#Bnfqj`bs{8ab`hdqlvmglsslqwvmjwjfpFmwfqwbjmnfmw-wlOltfq@bpf+nbmveb`wvqjmdsqlefppjlmbo#`lnajmfg#tjwkElq#jmpwbm`f/`lmpjpwjmd#le!#nb{ofmdwk>!qfwvqm#ebopf8`lmp`jlvpmfppNfgjwfqqbmfbmf{wqblqgjmbqzbppbppjmbwjlmpvapfrvfmwoz#avwwlm#wzsf>!wkf#mvnafq#lewkf#lqjdjmbo#`lnsqfkfmpjufqfefqp#wl#wkf?,vo=	?,gju=	skjolplskj`bool`bwjlm-kqfetbp#svaojpkfgPbm#Eqbm`jp`l+evm`wjlm+*x	?gju#jg>!nbjmplskjpwj`bwfgnbwkfnbwj`bo#,kfbg=	?algzpvddfpwp#wkbwgl`vnfmwbwjlm`lm`fmwqbwjlmqfobwjlmpkjspnbz#kbuf#affm+elq#f{bnsof/Wkjp#bqwj`of#jm#plnf#`bpfpsbqwp#le#wkf#gfejmjwjlm#leDqfbw#Aqjwbjm#`foosbggjmd>frvjubofmw#wlsob`fklogfq>!8#elmw.pjyf9#ivpwjej`bwjlmafojfufg#wkbwpveefqfg#eqlnbwwfnswfg#wl#ofbgfq#le#wkf`qjsw!#pq`>!,+evm`wjlm+*#xbqf#bubjobaof	\n?ojmh#qfo>!#pq`>$kwws9,,jmwfqfpwfg#jm`lmufmwjlmbo#!#bow>!!#,=?,bqf#dfmfqboozkbp#bopl#affmnlpw#slsvobq#`lqqfpslmgjmd`qfgjwfg#tjwkwzof>!alqgfq9?,b=?,psbm=?,-dje!#tjgwk>!?jeqbnf#pq`>!wbaof#`obpp>!jmojmf.aol`h8b``lqgjmd#wl#wldfwkfq#tjwkbssql{jnbwfozsbqojbnfmwbqznlqf#bmg#nlqfgjpsobz9mlmf8wqbgjwjlmboozsqfglnjmbmwoz%maps8%maps8%maps8?,psbm=#`foopsb`jmd>?jmsvw#mbnf>!lq!#`lmwfmw>!`lmwqlufqpjbosqlsfqwz>!ld9,{.pkl`htbuf.gfnlmpwqbwjlmpvqqlvmgfg#azMfufqwkfofpp/tbp#wkf#ejqpw`lmpjgfqbaof#Bowklvdk#wkf#`loobalqbwjlmpklvog#mlw#afsqlslqwjlm#le?psbm#pwzof>!hmltm#bp#wkf#pklqwoz#bewfqelq#jmpwbm`f/gfp`qjafg#bp#,kfbg=	?algz#pwbqwjmd#tjwkjm`qfbpjmdoz#wkf#eb`w#wkbwgjp`vppjlm#lenjggof#le#wkfbm#jmgjujgvbogjeej`vow#wl#sljmw#le#ujftklnlpf{vbojwzb``fswbm`f#le?,psbm=?,gju=nbmveb`wvqfqplqjdjm#le#wkf`lnnlmoz#vpfgjnslqwbm`f#legfmlnjmbwjlmpab`hdqlvmg9# ofmdwk#le#wkfgfwfqnjmbwjlmb#pjdmjej`bmw!#alqgfq>!3!=qfulovwjlmbqzsqjm`jsofp#lejp#`lmpjgfqfgtbp#gfufolsfgJmgl.Fvqlsfbmuvomfqbaof#wlsqlslmfmwp#lebqf#plnfwjnfp`olpfq#wl#wkfMft#Zlqh#@jwz#mbnf>!pfbq`kbwwqjavwfg#wl`lvqpf#le#wkfnbwkfnbwj`jbmaz#wkf#fmg#lebw#wkf#fmg#le!#alqgfq>!3!#wf`kmloldj`bo-qfnluf@obpp+aqbm`k#le#wkffujgfm`f#wkbw"Xfmgje^..=	Jmpwjwvwf#le#jmwl#b#pjmdofqfpsf`wjufoz-bmg#wkfqfelqfsqlsfqwjfp#lejp#ol`bwfg#jmplnf#le#tkj`kWkfqf#jp#bopl`lmwjmvfg#wl#bssfbqbm`f#le#%bns8mgbpk8#gfp`qjafp#wkf`lmpjgfqbwjlmbvwklq#le#wkfjmgfsfmgfmwozfrvjssfg#tjwkglfp#mlw#kbuf?,b=?b#kqfe>!`lmevpfg#tjwk?ojmh#kqfe>!,bw#wkf#bdf#lebssfbq#jm#wkfWkfpf#jm`ovgfqfdbqgofpp#le`lvog#af#vpfg#pwzof>%rvlw8pfufqbo#wjnfpqfsqfpfmw#wkfalgz=	?,kwno=wklvdkw#wl#afslsvobwjlm#leslppjajojwjfpsfq`fmwbdf#leb``fpp#wl#wkfbm#bwwfnsw#wlsqlgv`wjlm#leirvfqz,irvfqzwtl#gjeefqfmwafolmd#wl#wkffpwbaojpknfmwqfsob`jmd#wkfgfp`qjswjlm!#gfwfqnjmf#wkfbubjobaof#elqB``lqgjmd#wl#tjgf#qbmdf#le\n?gju#`obpp>!nlqf#`lnnlmozlqdbmjpbwjlmpevm`wjlmbojwztbp#`lnsofwfg#%bns8ngbpk8#sbqwj`jsbwjlmwkf#`kbqb`wfqbm#bggjwjlmbobssfbqp#wl#afeb`w#wkbw#wkfbm#f{bnsof#lepjdmjej`bmwozlmnlvpflufq>!af`bvpf#wkfz#bpzm`#>#wqvf8sqlaofnp#tjwkpffnp#wl#kbufwkf#qfpvow#le#pq`>!kwws9,,ebnjojbq#tjwkslppfppjlm#leevm`wjlm#+*#xwllh#sob`f#jmbmg#plnfwjnfppvapwbmwjbooz?psbm=?,psbm=jp#lewfm#vpfgjm#bm#bwwfnswdqfbw#gfbo#leFmujqlmnfmwbopv``fppevooz#ujqwvbooz#boo13wk#`fmwvqz/sqlefppjlmbopmf`fppbqz#wl#gfwfqnjmfg#az`lnsbwjajojwzaf`bvpf#jw#jpGj`wjlmbqz#lenlgjej`bwjlmpWkf#elooltjmdnbz#qfefq#wl9@lmpfrvfmwoz/Jmwfqmbwjlmbobowklvdk#plnfwkbw#tlvog#aftlqog$p#ejqpw`obppjejfg#bpalwwln#le#wkf+sbqwj`vobqozbojdm>!ofew!#nlpw#`lnnlmozabpjp#elq#wkfelvmgbwjlm#le`lmwqjavwjlmpslsvobqjwz#le`fmwfq#le#wkfwl#qfgv`f#wkfivqjpgj`wjlmpbssql{jnbwjlm#lmnlvpflvw>!Mft#Wfpwbnfmw`loof`wjlm#le?,psbm=?,b=?,jm#wkf#Vmjwfgejon#gjqf`wlq.pwqj`w-gwg!=kbp#affm#vpfgqfwvqm#wl#wkfbowklvdk#wkjp`kbmdf#jm#wkfpfufqbo#lwkfqavw#wkfqf#bqfvmsqf`fgfmwfgjp#pjnjobq#wlfpsf`jbooz#jmtfjdkw9#alog8jp#`boofg#wkf`lnsvwbwjlmbojmgj`bwf#wkbwqfpwqj`wfg#wl\n?nfwb#mbnf>!bqf#wzsj`booz`lmeoj`w#tjwkKltfufq/#wkf#Bm#f{bnsof#le`lnsbqfg#tjwkrvbmwjwjfp#leqbwkfq#wkbm#b`lmpwfoobwjlmmf`fppbqz#elqqfslqwfg#wkbwpsf`jej`bwjlmslojwj`bo#bmg%maps8%maps8?qfefqfm`fp#wlwkf#pbnf#zfbqDlufqmnfmw#ledfmfqbwjlm#lekbuf#mlw#affmpfufqbo#zfbqp`lnnjwnfmw#wl\n\n?vo#`obpp>!ujpvbojybwjlm2:wk#`fmwvqz/sqb`wjwjlmfqpwkbw#kf#tlvogbmg#`lmwjmvfgl``vsbwjlm#lejp#gfejmfg#bp`fmwqf#le#wkfwkf#bnlvmw#le=?gju#pwzof>!frvjubofmw#legjeefqfmwjbwfaqlvdkw#balvwnbqdjm.ofew9#bvwlnbwj`boozwklvdkw#le#bpPlnf#le#wkfpf	?gju#`obpp>!jmsvw#`obpp>!qfsob`fg#tjwkjp#lmf#le#wkffgv`bwjlm#bmgjmeovfm`fg#azqfsvwbwjlm#bp	?nfwb#mbnf>!b``lnnlgbwjlm?,gju=	?,gju=obqdf#sbqw#leJmpwjwvwf#elqwkf#pl.`boofg#bdbjmpw#wkf#Jm#wkjp#`bpf/tbp#bssljmwfg`objnfg#wl#afKltfufq/#wkjpGfsbqwnfmw#lewkf#qfnbjmjmdfeef`w#lm#wkfsbqwj`vobqoz#gfbo#tjwk#wkf	?gju#pwzof>!bonlpw#botbzpbqf#`vqqfmwozf{sqfppjlm#leskjolplskz#leelq#nlqf#wkbm`jujojybwjlmplm#wkf#jpobmgpfof`wfgJmgf{`bm#qfpvow#jm!#ubovf>!!#,=wkf#pwqv`wvqf#,=?,b=?,gju=Nbmz#le#wkfpf`bvpfg#az#wkfle#wkf#Vmjwfgpsbm#`obpp>!n`bm#af#wqb`fgjp#qfobwfg#wlaf`bnf#lmf#lejp#eqfrvfmwozojujmd#jm#wkfwkflqfwj`boozElooltjmd#wkfQfulovwjlmbqzdlufqmnfmw#jmjp#gfwfqnjmfgwkf#slojwj`bojmwqlgv`fg#jmpveej`jfmw#wlgfp`qjswjlm!=pklqw#pwlqjfppfsbqbwjlm#lebp#wl#tkfwkfqhmltm#elq#jwptbp#jmjwjboozgjpsobz9aol`hjp#bm#f{bnsofwkf#sqjm`jsbo`lmpjpwp#le#bqf`ldmjyfg#bp,algz=?,kwno=b#pvapwbmwjboqf`lmpwqv`wfgkfbg#le#pwbwfqfpjpwbm`f#wlvmgfqdqbgvbwfWkfqf#bqf#wtldqbujwbwjlmbobqf#gfp`qjafgjmwfmwjlmboozpfqufg#bp#wkf`obpp>!kfbgfqlsslpjwjlm#wlevmgbnfmwboozglnjmbwfg#wkfbmg#wkf#lwkfqboojbm`f#tjwktbp#elq`fg#wlqfpsf`wjufoz/bmg#slojwj`bojm#pvsslqw#lesflsof#jm#wkf13wk#`fmwvqz-bmg#svaojpkfgolbg@kbqwafbwwl#vmgfqpwbmgnfnafq#pwbwfpfmujqlmnfmwboejqpw#kboe#le`lvmwqjfp#bmgbq`kjwf`wvqboaf#`lmpjgfqfg`kbqb`wfqjyfg`ofbqJmwfqubobvwklqjwbwjufEfgfqbwjlm#letbp#pv``ffgfgbmg#wkfqf#bqfb#`lmpfrvfm`fwkf#Sqfpjgfmwbopl#jm`ovgfgeqff#plewtbqfpv``fppjlm#legfufolsfg#wkftbp#gfpwqlzfgbtbz#eqln#wkf8	?,p`qjsw=	?bowklvdk#wkfzelooltfg#az#bnlqf#sltfqevoqfpvowfg#jm#bVmjufqpjwz#leKltfufq/#nbmzwkf#sqfpjgfmwKltfufq/#plnfjp#wklvdkw#wlvmwjo#wkf#fmgtbp#bmmlvm`fgbqf#jnslqwbmwbopl#jm`ovgfp=?jmsvw#wzsf>wkf#`fmwfq#le#GL#MLW#BOWFQvpfg#wl#qfefqwkfnfp,<plqw>wkbw#kbg#affmwkf#abpjp#elqkbp#gfufolsfgjm#wkf#pvnnfq`lnsbqbwjufozgfp`qjafg#wkfpv`k#bp#wklpfwkf#qfpvowjmdjp#jnslppjaofubqjlvp#lwkfqPlvwk#Beqj`bmkbuf#wkf#pbnffeef`wjufmfppjm#tkj`k#`bpf8#wf{w.bojdm9pwqv`wvqf#bmg8#ab`hdqlvmg9qfdbqgjmd#wkfpvsslqwfg#wkfjp#bopl#hmltmpwzof>!nbqdjmjm`ovgjmd#wkfabkbpb#Nfobzvmlqph#alhn/Iomlqph#mzmlqphpolufm)M(ajmbjmwfqmb`jlmbo`bojej`b`j/_m`lnvmj`b`j/_m`lmpwqv``j/_m!=?gju#`obpp>!gjpbnajdvbwjlmGlnbjmMbnf$/#$bgnjmjpwqbwjlmpjnvowbmflvpozwqbmpslqwbwjlmJmwfqmbwjlmbo#nbqdjm.alwwln9qfpslmpjajojwz?"Xfmgje^..=	?,=?nfwb#mbnf>!jnsofnfmwbwjlmjmeqbpwqv`wvqfqfsqfpfmwbwjlmalqgfq.alwwln9?,kfbg=	?algz=>kwws&0B&1E&1E?elqn#nfwklg>!nfwklg>!slpw!#,ebuj`lm-j`l!#~*8	?,p`qjsw=	-pfwBwwqjavwf+Bgnjmjpwqbwjlm>#mft#Bqqbz+*8?"Xfmgje^..=	gjpsobz9aol`h8Vmelqwvmbwfoz/!=%maps8?,gju=,ebuj`lm-j`l!=>$pwzofpkffw$#jgfmwjej`bwjlm/#elq#f{bnsof/?oj=?b#kqfe>!,bm#bowfqmbwjufbp#b#qfpvow#lesw!=?,p`qjsw=	wzsf>!pvanjw!#	+evm`wjlm+*#xqf`lnnfmgbwjlmelqn#b`wjlm>!,wqbmpelqnbwjlmqf`lmpwqv`wjlm-pwzof-gjpsobz#B``lqgjmd#wl#kjggfm!#mbnf>!bolmd#tjwk#wkfgl`vnfmw-algz-bssql{jnbwfoz#@lnnvmj`bwjlmpslpw!#b`wjlm>!nfbmjmd#%rvlw8..?"Xfmgje^..=Sqjnf#Njmjpwfq`kbqb`wfqjpwj`?,b=#?b#`obpp>wkf#kjpwlqz#le#lmnlvpflufq>!wkf#dlufqmnfmwkqfe>!kwwsp9,,tbp#lqjdjmbooztbp#jmwqlgv`fg`obppjej`bwjlmqfsqfpfmwbwjufbqf#`lmpjgfqfg?"Xfmgje^..=		gfsfmgp#lm#wkfVmjufqpjwz#le#jm#`lmwqbpw#wl#sob`fklogfq>!jm#wkf#`bpf#lejmwfqmbwjlmbo#`lmpwjwvwjlmbopwzof>!alqgfq.9#evm`wjlm+*#xAf`bvpf#le#wkf.pwqj`w-gwg!=	?wbaof#`obpp>!b``lnsbmjfg#azb``lvmw#le#wkf?p`qjsw#pq`>!,mbwvqf#le#wkf#wkf#sflsof#jm#jm#bggjwjlm#wlp*8#ip-jg#>#jg!#tjgwk>!233&!qfdbqgjmd#wkf#Qlnbm#@bwkloj`bm#jmgfsfmgfmwelooltjmd#wkf#-dje!#tjgwk>!2wkf#elooltjmd#gjp`qjnjmbwjlmbq`kbfloldj`bosqjnf#njmjpwfq-ip!=?,p`qjsw=`lnajmbwjlm#le#nbqdjmtjgwk>!`qfbwfFofnfmw+t-bwwb`kFufmw+?,b=?,wg=?,wq=pq`>!kwwsp9,,bJm#sbqwj`vobq/#bojdm>!ofew!#@yf`k#Qfsvaoj`Vmjwfg#Hjmdgln`lqqfpslmgfm`f`lm`ovgfg#wkbw-kwno!#wjwof>!+evm`wjlm#+*#x`lnfp#eqln#wkfbssoj`bwjlm#le?psbm#`obpp>!pafojfufg#wl#affnfmw+$p`qjsw$?,b=	?,oj=	?ojufqz#gjeefqfmw=?psbm#`obpp>!lswjlm#ubovf>!+bopl#hmltm#bp\n?oj=?b#kqfe>!=?jmsvw#mbnf>!pfsbqbwfg#eqlnqfefqqfg#wl#bp#ubojdm>!wls!=elvmgfq#le#wkfbwwfnswjmd#wl#`bqalm#gjl{jgf		?gju#`obpp>!`obpp>!pfbq`k.,algz=	?,kwno=lsslqwvmjwz#wl`lnnvmj`bwjlmp?,kfbg=	?algz#pwzof>!tjgwk9Wj\rVSmd#Uj\rWkw`kbmdfp#jm#wkfalqgfq.`lolq9 3!#alqgfq>!3!#?,psbm=?,gju=?tbp#gjp`lufqfg!#wzsf>!wf{w!#*8	?,p`qjsw=		Gfsbqwnfmw#le#f``ofpjbpwj`bowkfqf#kbp#affmqfpvowjmd#eqln?,algz=?,kwno=kbp#mfufq#affmwkf#ejqpw#wjnfjm#qfpslmpf#wlbvwlnbwj`booz#?,gju=		?gju#jtbp#`lmpjgfqfgsfq`fmw#le#wkf!#,=?,b=?,gju=`loof`wjlm#le#gfp`fmgfg#eqlnpf`wjlm#le#wkfb``fsw.`kbqpfwwl#af#`lmevpfgnfnafq#le#wkf#sbggjmd.qjdkw9wqbmpobwjlm#lejmwfqsqfwbwjlm#kqfe>$kwws9,,tkfwkfq#lq#mlwWkfqf#bqf#boplwkfqf#bqf#nbmzb#pnboo#mvnafqlwkfq#sbqwp#lejnslppjaof#wl##`obpp>!avwwlmol`bwfg#jm#wkf-#Kltfufq/#wkfbmg#fufmwvboozBw#wkf#fmg#le#af`bvpf#le#jwpqfsqfpfmwp#wkf?elqn#b`wjlm>!#nfwklg>!slpw!jw#jp#slppjaofnlqf#ojhfoz#wlbm#jm`qfbpf#jmkbuf#bopl#affm`lqqfpslmgp#wlbmmlvm`fg#wkbwbojdm>!qjdkw!=nbmz#`lvmwqjfpelq#nbmz#zfbqpfbqojfpw#hmltmaf`bvpf#jw#tbpsw!=?,p`qjsw=#ubojdm>!wls!#jmkbajwbmwp#leelooltjmd#zfbq	?gju#`obpp>!njoojlm#sflsof`lmwqlufqpjbo#`lm`fqmjmd#wkfbqdvf#wkbw#wkfdlufqmnfmw#bmgb#qfefqfm`f#wlwqbmpefqqfg#wlgfp`qjajmd#wkf#pwzof>!`lolq9bowklvdk#wkfqfafpw#hmltm#elqpvanjw!#mbnf>!nvowjsoj`bwjlmnlqf#wkbm#lmf#qf`ldmjwjlm#le@lvm`jo#le#wkffgjwjlm#le#wkf##?nfwb#mbnf>!Fmwfqwbjmnfmw#btbz#eqln#wkf#8nbqdjm.qjdkw9bw#wkf#wjnf#lejmufpwjdbwjlmp`lmmf`wfg#tjwkbmg#nbmz#lwkfqbowklvdk#jw#jpafdjmmjmd#tjwk#?psbm#`obpp>!gfp`fmgbmwp#le?psbm#`obpp>!j#bojdm>!qjdkw!?,kfbg=	?algz#bpsf`wp#le#wkfkbp#pjm`f#affmFvqlsfbm#Vmjlmqfnjmjp`fmw#lenlqf#gjeej`vowUj`f#Sqfpjgfmw`lnslpjwjlm#lesbppfg#wkqlvdknlqf#jnslqwbmwelmw.pjyf922s{f{sobmbwjlm#lewkf#`lm`fsw#letqjwwfm#jm#wkf\n?psbm#`obpp>!jp#lmf#le#wkf#qfpfnaobm`f#wllm#wkf#dqlvmgptkj`k#`lmwbjmpjm`ovgjmd#wkf#gfejmfg#az#wkfsvaoj`bwjlm#lenfbmp#wkbw#wkflvwpjgf#le#wkfpvsslqw#le#wkf?jmsvw#`obpp>!?psbm#`obpp>!w+Nbwk-qbmgln+*nlpw#sqlnjmfmwgfp`qjswjlm#le@lmpwbmwjmlsoftfqf#svaojpkfg?gju#`obpp>!pfbssfbqp#jm#wkf2!#kfjdkw>!2!#nlpw#jnslqwbmwtkj`k#jm`ovgfptkj`k#kbg#affmgfpwqv`wjlm#lewkf#slsvobwjlm	\n?gju#`obpp>!slppjajojwz#leplnfwjnfp#vpfgbssfbq#wl#kbufpv``fpp#le#wkfjmwfmgfg#wl#afsqfpfmw#jm#wkfpwzof>!`ofbq9a	?,p`qjsw=	?tbp#elvmgfg#jmjmwfqujft#tjwk\\jg!#`lmwfmw>!`bsjwbo#le#wkf	?ojmh#qfo>!pqfofbpf#le#wkfsljmw#lvw#wkbw{NOKwwsQfrvfpwbmg#pvapfrvfmwpf`lmg#obqdfpwufqz#jnslqwbmwpsf`jej`bwjlmppvqeb`f#le#wkfbssojfg#wl#wkfelqfjdm#sloj`z\\pfwGlnbjmMbnffpwbaojpkfg#jmjp#afojfufg#wlJm#bggjwjlm#wlnfbmjmd#le#wkfjp#mbnfg#bewfqwl#sqlwf`w#wkfjp#qfsqfpfmwfgGf`obqbwjlm#lenlqf#feej`jfmw@obppjej`bwjlmlwkfq#elqnp#lekf#qfwvqmfg#wl?psbm#`obpp>!`sfqelqnbm`f#le+evm`wjlm+*#xje#bmg#lmoz#jeqfdjlmp#le#wkfofbgjmd#wl#wkfqfobwjlmp#tjwkVmjwfg#Mbwjlmppwzof>!kfjdkw9lwkfq#wkbm#wkfzsf!#`lmwfmw>!Bppl`jbwjlm#le	?,kfbg=	?algzol`bwfg#lm#wkfjp#qfefqqfg#wl+jm`ovgjmd#wkf`lm`fmwqbwjlmpwkf#jmgjujgvbobnlmd#wkf#nlpwwkbm#bmz#lwkfq,=	?ojmh#qfo>!#qfwvqm#ebopf8wkf#svqslpf#lewkf#bajojwz#wl8`lolq9 eee~	-	?psbm#`obpp>!wkf#pvaif`w#legfejmjwjlmp#le=	?ojmh#qfo>!`objn#wkbw#wkfkbuf#gfufolsfg?wbaof#tjgwk>!`fofaqbwjlm#leElooltjmd#wkf#wl#gjpwjmdvjpk?psbm#`obpp>!awbhfp#sob`f#jmvmgfq#wkf#mbnfmlwfg#wkbw#wkf=?"Xfmgje^..=	pwzof>!nbqdjm.jmpwfbg#le#wkfjmwqlgv`fg#wkfwkf#sql`fpp#lejm`qfbpjmd#wkfgjeefqfm`fp#jmfpwjnbwfg#wkbwfpsf`jbooz#wkf,gju=?gju#jg>!tbp#fufmwvboozwkqlvdklvw#kjpwkf#gjeefqfm`fplnfwkjmd#wkbwpsbm=?,psbm=?,pjdmjej`bmwoz#=?,p`qjsw=		fmujqlmnfmwbo#wl#sqfufmw#wkfkbuf#affm#vpfgfpsf`jbooz#elqvmgfqpwbmg#wkfjp#fppfmwjbooztfqf#wkf#ejqpwjp#wkf#obqdfpwkbuf#affm#nbgf!#pq`>!kwws9,,jmwfqsqfwfg#bppf`lmg#kboe#le`qloojmd>!ml!#jp#`lnslpfg#leJJ/#Kloz#Qlnbmjp#f{sf`wfg#wlkbuf#wkfjq#ltmgfejmfg#bp#wkfwqbgjwjlmbooz#kbuf#gjeefqfmwbqf#lewfm#vpfgwl#fmpvqf#wkbwbdqffnfmw#tjwk`lmwbjmjmd#wkfbqf#eqfrvfmwozjmelqnbwjlm#lmf{bnsof#jp#wkfqfpvowjmd#jm#b?,b=?,oj=?,vo=#`obpp>!ellwfqbmg#fpsf`jboozwzsf>!avwwlm!#?,psbm=?,psbm=tkj`k#jm`ovgfg=	?nfwb#mbnf>!`lmpjgfqfg#wkf`bqqjfg#lvw#azKltfufq/#jw#jpaf`bnf#sbqw#lejm#qfobwjlm#wlslsvobq#jm#wkfwkf#`bsjwbo#letbp#leej`jbooztkj`k#kbp#affmwkf#Kjpwlqz#lebowfqmbwjuf#wlgjeefqfmw#eqlnwl#pvsslqw#wkfpvddfpwfg#wkbwjm#wkf#sql`fpp##?gju#`obpp>!wkf#elvmgbwjlmaf`bvpf#le#kjp`lm`fqmfg#tjwkwkf#vmjufqpjwzlsslpfg#wl#wkfwkf#`lmwf{w#le?psbm#`obpp>!swf{w!#mbnf>!r!\n\n?gju#`obpp>!wkf#p`jfmwjej`qfsqfpfmwfg#aznbwkfnbwj`jbmpfof`wfg#az#wkfwkbw#kbuf#affm=?gju#`obpp>!`gju#jg>!kfbgfqjm#sbqwj`vobq/`lmufqwfg#jmwl*8	?,p`qjsw=	?skjolplskj`bo#pqsphlkqubwphjwj\rVSmd#Uj\rWkw<L=o=m=m<V<T<U=l=o=m=m<V<T<Ujmufpwjdb`j/_msbqwj`jsb`j/_m<V<R=n<R=l=g<Y<R<]<W<\\=m=n<T<V<R=n<R=l=g<U=k<Y<W<R<^<Y<V=m<T=m=n<Y<P=g<q<R<^<R=m=n<T<V<R=n<R=l=g=i<R<]<W<\\=m=n=`<^=l<Y<P<Y<Q<T<V<R=n<R=l<\\=c=m<Y<_<R<X<Q=c=m<V<\\=k<\\=n=`<Q<R<^<R=m=n<T<O<V=l<\\<T<Q=g<^<R<S=l<R=m=g<V<R=n<R=l<R<U=m<X<Y<W<\\=n=`<S<R<P<R=e=`=b=m=l<Y<X=m=n<^<R<]=l<\\<[<R<P=m=n<R=l<R<Q=g=o=k<\\=m=n<T<Y=n<Y=k<Y<Q<T<Y<<W<\\<^<Q<\\=c<T=m=n<R=l<T<T=m<T=m=n<Y<P<\\=l<Y=d<Y<Q<T=c<M<V<\\=k<\\=n=`<S<R=a=n<R<P=o=m<W<Y<X=o<Y=n=m<V<\\<[<\\=n=`=n<R<^<\\=l<R<^<V<R<Q<Y=k<Q<R=l<Y=d<Y<Q<T<Y<V<R=n<R=l<R<Y<R=l<_<\\<Q<R<^<V<R=n<R=l<R<P<L<Y<V<W<\\<P<\\4K5h5i5j4F4C5e5i5j4F4C5f4K4F4K5h5i5d4Z5d4U4K5h4D4]4K5i4@4K5h5i5d4K5n4U4K5h4]4_4K4J5h5i4X4K4]5o4K4F4K5h4O4U4Z4K4M4K5h4]5f4K4Z4E4K5h4F4Y5i5f5i4K5h4K4U4Z4K4M4K5h5j4F4K4J4@4K5h4O5h4U4K4D4K5h4F4_4@5f5h4K5h4O5n4_4K5i4K5h4Z4V4[4K4F4K5h5m5f4C5f5d4K5h4F4]4A5f4D4K5h4@4C5f4C4E4K5h4F4U5h5f5i4K5h4O4B4D4K4]4K5h4K5m5h4K5i4K5h4O5m5h4K5i4K5h4F4K4]5f4B4K5h4F5n5j5f4E4K5h4K5h4U4K4D4K5h4B5d4K4[4]4K5h5i4@4F5i4U4K5h4C5f5o5d4]4K5h4_5f4K4A4E4U4D4C4K5h5h5k4K5h4F4]4D5f4E4K5h4]5d4K4D4[4K5h4O4C4D5f4E4K5h4K4B4D4K4]4K5h5i4F4A4C4E4K5h4K4V4K5j5f`vqplq9sljmwfq8?,wjwof=	?nfwb#!#kqfe>!kwws9,,!=?psbm#`obpp>!nfnafqp#le#wkf#tjmglt-ol`bwjlmufqwj`bo.bojdm9,b=##?b#kqfe>!?"gl`wzsf#kwno=nfgjb>!p`qffm!#?lswjlm#ubovf>!ebuj`lm-j`l!#,=	\n\n?gju#`obpp>!`kbqb`wfqjpwj`p!#nfwklg>!dfw!#,algz=	?,kwno=	pklqw`vw#j`lm!#gl`vnfmw-tqjwf+sbggjmd.alwwln9qfsqfpfmwbwjufppvanjw!#ubovf>!bojdm>!`fmwfq!#wkqlvdklvw#wkf#p`jfm`f#ej`wjlm	##?gju#`obpp>!pvanjw!#`obpp>!lmf#le#wkf#nlpw#ubojdm>!wls!=?tbp#fpwbaojpkfg*8	?,p`qjsw=	qfwvqm#ebopf8!=*-pwzof-gjpsobzaf`bvpf#le#wkf#gl`vnfmw-`llhjf?elqn#b`wjlm>!,~algzxnbqdjm938Fm`z`olsfgjb#leufqpjlm#le#wkf#-`qfbwfFofnfmw+mbnf!#`lmwfmw>!?,gju=	?,gju=		bgnjmjpwqbwjuf#?,algz=	?,kwno=kjpwlqz#le#wkf#!=?jmsvw#wzsf>!slqwjlm#le#wkf#bp#sbqw#le#wkf#%maps8?b#kqfe>!lwkfq#`lvmwqjfp!=	?gju#`obpp>!?,psbm=?,psbm=?Jm#lwkfq#tlqgp/gjpsobz9#aol`h8`lmwqlo#le#wkf#jmwqlgv`wjlm#le,=	?nfwb#mbnf>!bp#tfoo#bp#wkf#jm#qf`fmw#zfbqp	\n?gju#`obpp>!?,gju=	\n?,gju=	jmpsjqfg#az#wkfwkf#fmg#le#wkf#`lnsbwjaof#tjwkaf`bnf#hmltm#bp#pwzof>!nbqdjm9-ip!=?,p`qjsw=?#Jmwfqmbwjlmbo#wkfqf#kbuf#affmDfqnbm#obmdvbdf#pwzof>!`lolq9 @lnnvmjpw#Sbqwz`lmpjpwfmw#tjwkalqgfq>!3!#`foo#nbqdjmkfjdkw>!wkf#nbilqjwz#le!#bojdm>!`fmwfqqfobwfg#wl#wkf#nbmz#gjeefqfmw#Lqwklgl{#@kvq`kpjnjobq#wl#wkf#,=	?ojmh#qfo>!ptbp#lmf#le#wkf#vmwjo#kjp#gfbwk~*+*8	?,p`qjsw=lwkfq#obmdvbdfp`lnsbqfg#wl#wkfslqwjlmp#le#wkfwkf#Mfwkfqobmgpwkf#nlpw#`lnnlmab`hdqlvmg9vqo+bqdvfg#wkbw#wkfp`qloojmd>!ml!#jm`ovgfg#jm#wkfMlqwk#Bnfqj`bm#wkf#mbnf#le#wkfjmwfqsqfwbwjlmpwkf#wqbgjwjlmbogfufolsnfmw#le#eqfrvfmwoz#vpfgb#`loof`wjlm#leufqz#pjnjobq#wlpvqqlvmgjmd#wkff{bnsof#le#wkjpbojdm>!`fmwfq!=tlvog#kbuf#affmjnbdf\\`bswjlm#>bwwb`kfg#wl#wkfpvddfpwjmd#wkbwjm#wkf#elqn#le#jmuloufg#jm#wkfjp#gfqjufg#eqlnmbnfg#bewfq#wkfJmwqlgv`wjlm#wlqfpwqj`wjlmp#lm#pwzof>!tjgwk9#`bm#af#vpfg#wl#wkf#`qfbwjlm#lenlpw#jnslqwbmw#jmelqnbwjlm#bmgqfpvowfg#jm#wkf`loobspf#le#wkfWkjp#nfbmp#wkbwfofnfmwp#le#wkftbp#qfsob`fg#azbmbozpjp#le#wkfjmpsjqbwjlm#elqqfdbqgfg#bp#wkfnlpw#pv``fppevohmltm#bp#%rvlw8b#`lnsqfkfmpjufKjpwlqz#le#wkf#tfqf#`lmpjgfqfgqfwvqmfg#wl#wkfbqf#qfefqqfg#wlVmplvq`fg#jnbdf=	\n?gju#`obpp>!`lmpjpwp#le#wkfpwlsSqlsbdbwjlmjmwfqfpw#jm#wkfbubjobajojwz#lebssfbqp#wl#kbuffof`wqlnbdmfwj`fmbaofPfquj`fp+evm`wjlm#le#wkfJw#jp#jnslqwbmw?,p`qjsw=?,gju=evm`wjlm+*xubq#qfobwjuf#wl#wkfbp#b#qfpvow#le#wkf#slpjwjlm#leElq#f{bnsof/#jm#nfwklg>!slpw!#tbp#elooltfg#az%bns8ngbpk8#wkfwkf#bssoj`bwjlmip!=?,p`qjsw=	vo=?,gju=?,gju=bewfq#wkf#gfbwktjwk#qfpsf`w#wlpwzof>!sbggjmd9jp#sbqwj`vobqozgjpsobz9jmojmf8#wzsf>!pvanjw!#jp#gjujgfg#jmwl\bTA\nzk#+\vBl\bQ*qfpslmpbajojgbgbgnjmjpwqb`j/_mjmwfqmb`jlmbofp`lqqfpslmgjfmwf\fHe\fHF\fHC\fIg\fH{\fHF\fIn\fH\\\fIa\fHY\fHU\fHB\fHR\fH\\\fIk\fH^\fIg\fH{\fIg\fHn\fHv\fIm\fHD\fHR\fHY\fH^\fIk\fHy\fHS\fHD\fHT\fH\\\fHy\fHR\fH\\\fHF\fIm\fH^\fHS\fHT\fHz\fIg\fHp\fIk\fHn\fHv\fHR\fHU\fHS\fHc\fHA\fIk\fHp\fIk\fHn\fHZ\fHR\fHB\fHS\fH^\fHU\fHB\fHR\fH\\\fIl\fHp\fHR\fH{\fH\\\fHO\fH@\fHD\fHR\fHD\fIk\fHy\fIm\fHB\fHR\fH\\\fH@\fIa\fH^\fIe\fH{\fHB\fHR\fH^\fHS\fHy\fHB\fHU\fHS\fH^\fHR\fHF\fIo\fH[\fIa\fHL\fH@\fHN\fHP\fHH\fIk\fHA\fHR\fHp\fHF\fHR\fHy\fIa\fH^\fHS\fHy\fHs\fIa\fH\\\fIk\fHD\fHz\fHS\fH^\fHR\fHG\fHJ\fI`\fH\\\fHR\fHD\fHB\fHR\fHB\fH^\fIk\fHB\fHH\fHJ\fHR\fHD\fH@\fHR\fHp\fHR\fH\\\fHY\fHS\fHy\fHR\fHT\fHy\fIa\fHC\fIg\fHn\fHv\fHR\fHU\fHH\fIk\fHF\fHU\fIm\fHm\fHv\fH@\fHH\fHR\fHC\fHR\fHT\fHn\fHY\fHR\fHJ\fHJ\fIk\fHz\fHD\fIk\fHF\fHS\fHw\fH^\fIk\fHY\fHS\fHZ\fIk\fH[\fH\\\fHR\fHp\fIa\fHC\fHe\fHH\fIa\fHH\fH\\\fHB\fIm\fHn\fH@\fHd\fHJ\fIg\fHD\fIg\fHn\fHe\fHF\fHy\fH\\\fHO\fHF\fHN\fHP\fIk\fHn\fHT\fIa\fHI\fHS\fHH\fHG\fHS\fH^\fIa\fHB\fHB\fIm\fHz\fIa\fHC\fHi\fHv\fIa\fHw\fHR\fHw\fIn\fHs\fHH\fIl\fHT\fHn\fH{\fIl\fHH\fHp\fHR\fHc\fH{\fHR\fHY\fHS\fHA\fHR\fH{\fHt\fHO\fIa\fHs\fIk\fHJ\fIn\fHT\fH\\\fIk\fHJ\fHS\fHD\fIg\fHn\fHU\fHH\fIa\fHC\fHR\fHT\fIk\fHy\fIa\fHT\fH{\fHR\fHn\fHK\fIl\fHY\fHS\fHZ\fIa\fHY\fH\\\fHR\fHH\fIk\fHn\fHJ\fId\fHs\fIa\fHT\fHD\fHy\fIa\fHZ\fHR\fHT\fHR\fHB\fHD\fIk\fHi\fHJ\fHR\fH^\fHH\fH@\fHS\fHp\fH^\fIl\fHF\fIm\fH\\\fIn\fH[\fHU\fHS\fHn\fHJ\fIl\fHB\fHS\fHH\fIa\fH\\\fHy\fHY\fHS\fHH\fHR\fH\\\fIm\fHF\fHC\fIk\fHT\fIa\fHI\fHR\fHD\fHy\fH\\\fIg\fHM\fHP\fHB\fIm\fHy\fIa\fHH\fHC\fIg\fHp\fHD\fHR\fHy\fIo\fHF\fHC\fHR\fHF\fIg\fHT\fIa\fHs\fHt\fH\\\fIk\fH^\fIn\fHy\fHR\fH\\\fIa\fHC\fHY\fHS\fHv\fHR\fH\\\fHT\fIn\fHv\fHD\fHR\fHB\fIn\fH^\fIa\fHC\fHJ\fIk\fHz\fIk\fHn\fHU\fHB\fIk\fHZ\fHR\fHT\fIa\fHy\fIn\fH^\fHB\fId\fHn\fHD\fIk\fHH\fId\fHC\fHR\fH\\\fHp\fHS\fHT\fHy\fIkqpp({no!#wjwof>!.wzsf!#`lmwfmw>!wjwof!#`lmwfmw>!bw#wkf#pbnf#wjnf-ip!=?,p`qjsw=	?!#nfwklg>!slpw!#?,psbm=?,b=?,oj=ufqwj`bo.bojdm9w,irvfqz-njm-ip!=-`oj`h+evm`wjlm+#pwzof>!sbggjmd.~*+*8	?,p`qjsw=	?,psbm=?b#kqfe>!?b#kqfe>!kwws9,,*8#qfwvqm#ebopf8wf{w.gf`lqbwjlm9#p`qloojmd>!ml!#alqgfq.`loobspf9bppl`jbwfg#tjwk#Abkbpb#JmglmfpjbFmdojpk#obmdvbdf?wf{w#{no9psb`f>-dje!#alqgfq>!3!?,algz=	?,kwno=	lufqeolt9kjggfm8jnd#pq`>!kwws9,,bggFufmwOjpwfmfqqfpslmpjaof#elq#p-ip!=?,p`qjsw=	,ebuj`lm-j`l!#,=lsfqbwjmd#pzpwfn!#pwzof>!tjgwk92wbqdfw>!\\aobmh!=Pwbwf#Vmjufqpjwzwf{w.bojdm9ofew8	gl`vnfmw-tqjwf+/#jm`ovgjmd#wkf#bqlvmg#wkf#tlqog*8	?,p`qjsw=	?!#pwzof>!kfjdkw98lufqeolt9kjggfmnlqf#jmelqnbwjlmbm#jmwfqmbwjlmbob#nfnafq#le#wkf#lmf#le#wkf#ejqpw`bm#af#elvmg#jm#?,gju=	\n\n?,gju=	gjpsobz9#mlmf8!=!#,=	?ojmh#qfo>!	##+evm`wjlm+*#xwkf#26wk#`fmwvqz-sqfufmwGfebvow+obqdf#mvnafq#le#Azybmwjmf#Fnsjqf-isdwkvnaofewubpw#nbilqjwz#lenbilqjwz#le#wkf##bojdm>!`fmwfq!=Vmjufqpjwz#Sqfppglnjmbwfg#az#wkfPf`lmg#Tlqog#Tbqgjpwqjavwjlm#le#pwzof>!slpjwjlm9wkf#qfpw#le#wkf#`kbqb`wfqjyfg#az#qfo>!mleloolt!=gfqjufp#eqln#wkfqbwkfq#wkbm#wkf#b#`lnajmbwjlm#lepwzof>!tjgwk9233Fmdojpk.psfbhjmd`lnsvwfq#p`jfm`falqgfq>!3!#bow>!wkf#f{jpwfm`f#leGfnl`qbwj`#Sbqwz!#pwzof>!nbqdjm.Elq#wkjp#qfbplm/-ip!=?,p`qjsw=	\npAzWbdMbnf+p*X3^ip!=?,p`qjsw=	?-ip!=?,p`qjsw=	ojmh#qfo>!j`lm!#$#bow>$$#`obpp>$elqnbwjlm#le#wkfufqpjlmp#le#wkf#?,b=?,gju=?,gju=,sbdf=	##?sbdf=	?gju#`obpp>!`lmwaf`bnf#wkf#ejqpwabkbpb#Jmglmfpjbfmdojpk#+pjnsof*"y"W"W"["Q"U"V"@=i=l<^<\\=n=m<V<T<V<R<P<S<\\<Q<T<T=c<^<W=c<Y=n=m=c<x<R<]<\\<^<T=n=`=k<Y<W<R<^<Y<V<\\=l<\\<[<^<T=n<T=c<t<Q=n<Y=l<Q<Y=n<r=n<^<Y=n<T=n=`<Q<\\<S=l<T<P<Y=l<T<Q=n<Y=l<Q<Y=n<V<R=n<R=l<R<_<R=m=n=l<\\<Q<T=j=g<V<\\=k<Y=m=n<^<Y=o=m<W<R<^<T=c=i<S=l<R<]<W<Y<P=g<S<R<W=o=k<T=n=`=c<^<W=c=b=n=m=c<Q<\\<T<]<R<W<Y<Y<V<R<P<S<\\<Q<T=c<^<Q<T<P<\\<Q<T<Y=m=l<Y<X=m=n<^<\\4K5h5i5d4K4Z5f4U4K5h4]4J5f4_5f4E4K5h4K5j4F5n4K5h5i4X4K4]5o4K4F5o4K5h4_5f4K4]4K4F4K5h5i5o4F5d4D4E4K5h4_4U5d4C5f4E4K4A4Y4K4J5f4K4F4K5h4U4K5h5i5f4E4K5h4Y5d4F5f4K4F4K5h4K5j4F4]5j4F4K5h4F4Y4K5i5f5i4K5h4I4_5h4K5i5f4K5h5i4X4K4]5o4E4K5h5i4]4J5f4K4Fqlalwp!#`lmwfmw>!?gju#jg>!ellwfq!=wkf#Vmjwfg#Pwbwfp?jnd#pq`>!kwws9,,-isdqjdkwwkvna-ip!=?,p`qjsw=	?ol`bwjlm-sqlwl`loeqbnfalqgfq>!3!#p!#,=	?nfwb#mbnf>!?,b=?,gju=?,gju=?elmw.tfjdkw9alog8%rvlw8#bmg#%rvlw8gfsfmgjmd#lm#wkf#nbqdjm938sbggjmd9!#qfo>!mleloolt!#Sqfpjgfmw#le#wkf#wtfmwjfwk#`fmwvqzfujpjlm=	##?,sbdfJmwfqmfw#F{solqfqb-bpzm`#>#wqvf8	jmelqnbwjlm#balvw?gju#jg>!kfbgfq!=!#b`wjlm>!kwws9,,?b#kqfe>!kwwsp9,,?gju#jg>!`lmwfmw!?,gju=	?,gju=	?gfqjufg#eqln#wkf#?jnd#pq`>$kwws9,,b``lqgjmd#wl#wkf#	?,algz=	?,kwno=	pwzof>!elmw.pjyf9p`qjsw#obmdvbdf>!Bqjbo/#Kfoufwj`b/?,b=?psbm#`obpp>!?,p`qjsw=?p`qjsw#slojwj`bo#sbqwjfpwg=?,wq=?,wbaof=?kqfe>!kwws9,,ttt-jmwfqsqfwbwjlm#leqfo>!pwzofpkffw!#gl`vnfmw-tqjwf+$?`kbqpfw>!vwe.;!=	afdjmmjmd#le#wkf#qfufbofg#wkbw#wkfwfofujpjlm#pfqjfp!#qfo>!mleloolt!=#wbqdfw>!\\aobmh!=`objnjmd#wkbw#wkfkwws&0B&1E&1Ettt-nbmjefpwbwjlmp#leSqjnf#Njmjpwfq#lejmeovfm`fg#az#wkf`obpp>!`ofbqej{!=,gju=	?,gju=		wkqff.gjnfmpjlmbo@kvq`k#le#Fmdobmgle#Mlqwk#@bqlojmbprvbqf#hjolnfwqfp-bggFufmwOjpwfmfqgjpwjm`w#eqln#wkf`lnnlmoz#hmltm#bpSklmfwj`#Boskbafwgf`obqfg#wkbw#wkf`lmwqloofg#az#wkfAfmibnjm#Eqbmhojmqlof.sobzjmd#dbnfwkf#Vmjufqpjwz#lejm#Tfpwfqm#Fvqlsfsfqplmbo#`lnsvwfqSqlif`w#Dvwfmafqdqfdbqgofpp#le#wkfkbp#affm#sqlslpfgwldfwkfq#tjwk#wkf=?,oj=?oj#`obpp>!jm#plnf#`lvmwqjfpnjm-ip!=?,p`qjsw=le#wkf#slsvobwjlmleej`jbo#obmdvbdf?jnd#pq`>!jnbdfp,jgfmwjejfg#az#wkfmbwvqbo#qfplvq`fp`obppjej`bwjlm#le`bm#af#`lmpjgfqfgrvbmwvn#nf`kbmj`pMfufqwkfofpp/#wkfnjoojlm#zfbqp#bdl?,algz=	?,kwno="y"W"W"["Q"U"V"@	wbhf#bgubmwbdf#lebmg/#b``lqgjmd#wlbwwqjavwfg#wl#wkfNj`qlplew#Tjmgltpwkf#ejqpw#`fmwvqzvmgfq#wkf#`lmwqlogju#`obpp>!kfbgfqpklqwoz#bewfq#wkfmlwbaof#f{`fswjlmwfmp#le#wklvpbmgppfufqbo#gjeefqfmwbqlvmg#wkf#tlqog-qfb`kjmd#njojwbqzjplobwfg#eqln#wkflsslpjwjlm#wl#wkfwkf#Log#WfpwbnfmwBeqj`bm#Bnfqj`bmpjmpfqwfg#jmwl#wkfpfsbqbwf#eqln#wkfnfwqlslojwbm#bqfbnbhfp#jw#slppjaofb`hmltofgdfg#wkbwbqdvbaoz#wkf#nlpwwzsf>!wf{w,`pp!=	wkf#JmwfqmbwjlmboB``lqgjmd#wl#wkf#sf>!wf{w,`pp!#,=	`ljm`jgf#tjwk#wkfwtl.wkjqgp#le#wkfGvqjmd#wkjp#wjnf/gvqjmd#wkf#sfqjlgbmmlvm`fg#wkbw#kfwkf#jmwfqmbwjlmbobmg#nlqf#qf`fmwozafojfufg#wkbw#wkf`lmp`jlvpmfpp#bmgelqnfqoz#hmltm#bppvqqlvmgfg#az#wkfejqpw#bssfbqfg#jml``bpjlmbooz#vpfgslpjwjlm9baplovwf8!#wbqdfw>!\\aobmh!#slpjwjlm9qfobwjuf8wf{w.bojdm9`fmwfq8ib{,ojap,irvfqz,2-ab`hdqlvmg.`lolq9 wzsf>!bssoj`bwjlm,bmdvbdf!#`lmwfmw>!?nfwb#kwws.frvju>!Sqjub`z#Sloj`z?,b=f+!&0@p`qjsw#pq`>$!#wbqdfw>!\\aobmh!=Lm#wkf#lwkfq#kbmg/-isdwkvnaqjdkw1?,gju=?gju#`obpp>!?gju#pwzof>!eolbw9mjmfwffmwk#`fmwvqz?,algz=	?,kwno=	?jnd#pq`>!kwws9,,p8wf{w.bojdm9`fmwfqelmw.tfjdkw9#alog8#B``lqgjmd#wl#wkf#gjeefqfm`f#afwtffm!#eqbnfalqgfq>!3!#!#pwzof>!slpjwjlm9ojmh#kqfe>!kwws9,,kwno7,ollpf-gwg!=	gvqjmd#wkjp#sfqjlg?,wg=?,wq=?,wbaof=`olpfoz#qfobwfg#wlelq#wkf#ejqpw#wjnf8elmw.tfjdkw9alog8jmsvw#wzsf>!wf{w!#?psbm#pwzof>!elmw.lmqfbgzpwbwf`kbmdf\n?gju#`obpp>!`ofbqgl`vnfmw-ol`bwjlm-#Elq#f{bnsof/#wkf#b#tjgf#ubqjfwz#le#?"GL@WZSF#kwno=	?%maps8%maps8%maps8!=?b#kqfe>!kwws9,,pwzof>!eolbw9ofew8`lm`fqmfg#tjwk#wkf>kwws&0B&1E&1Ettt-jm#slsvobq#`vowvqfwzsf>!wf{w,`pp!#,=jw#jp#slppjaof#wl#Kbqubqg#Vmjufqpjwzwzofpkffw!#kqfe>!,wkf#nbjm#`kbqb`wfqL{elqg#Vmjufqpjwz##mbnf>!hfztlqgp!#`pwzof>!wf{w.bojdm9wkf#Vmjwfg#Hjmdglnefgfqbo#dlufqmnfmw?gju#pwzof>!nbqdjm#gfsfmgjmd#lm#wkf#gfp`qjswjlm#le#wkf?gju#`obpp>!kfbgfq-njm-ip!=?,p`qjsw=gfpwqv`wjlm#le#wkfpojdkwoz#gjeefqfmwjm#b``lqgbm`f#tjwkwfof`lnnvmj`bwjlmpjmgj`bwfp#wkbw#wkfpklqwoz#wkfqfbewfqfpsf`jbooz#jm#wkf#Fvqlsfbm#`lvmwqjfpKltfufq/#wkfqf#bqfpq`>!kwws9,,pwbwj`pvddfpwfg#wkbw#wkf!#pq`>!kwws9,,ttt-b#obqdf#mvnafq#le#Wfof`lnnvmj`bwjlmp!#qfo>!mleloolt!#wKloz#Qlnbm#Fnsfqlqbonlpw#f{`ovpjufoz!#alqgfq>!3!#bow>!Pf`qfwbqz#le#Pwbwf`vonjmbwjmd#jm#wkf@JB#Tlqog#Eb`wallhwkf#nlpw#jnslqwbmwbmmjufqpbqz#le#wkfpwzof>!ab`hdqlvmg.?oj=?fn=?b#kqfe>!,wkf#Bwobmwj`#L`fbmpwqj`woz#psfbhjmd/pklqwoz#afelqf#wkfgjeefqfmw#wzsfp#lewkf#Lwwlnbm#Fnsjqf=?jnd#pq`>!kwws9,,Bm#Jmwqlgv`wjlm#wl`lmpfrvfm`f#le#wkfgfsbqwvqf#eqln#wkf@lmefgfqbwf#Pwbwfpjmgjdfmlvp#sflsofpSql`ffgjmdp#le#wkfjmelqnbwjlm#lm#wkfwkflqjfp#kbuf#affmjmuloufnfmw#jm#wkfgjujgfg#jmwl#wkqffbgib`fmw#`lvmwqjfpjp#qfpslmpjaof#elqgjpplovwjlm#le#wkf`loobalqbwjlm#tjwktjgfoz#qfdbqgfg#bpkjp#`lmwfnslqbqjfpelvmgjmd#nfnafq#leGlnjmj`bm#Qfsvaoj`dfmfqbooz#b``fswfgwkf#slppjajojwz#lebqf#bopl#bubjobaofvmgfq#`lmpwqv`wjlmqfpwlqbwjlm#le#wkfwkf#dfmfqbo#svaoj`jp#bonlpw#fmwjqfozsbppfp#wkqlvdk#wkfkbp#affm#pvddfpwfg`lnsvwfq#bmg#ujgflDfqnbmj`#obmdvbdfp#b``lqgjmd#wl#wkf#gjeefqfmw#eqln#wkfpklqwoz#bewfqtbqgpkqfe>!kwwsp9,,ttt-qf`fmw#gfufolsnfmwAlbqg#le#Gjqf`wlqp?gju#`obpp>!pfbq`k#?b#kqfe>!kwws9,,Jm#sbqwj`vobq/#wkfNvowjsof#ellwmlwfplq#lwkfq#pvapwbm`fwklvpbmgp#le#zfbqpwqbmpobwjlm#le#wkf?,gju=	?,gju=		?b#kqfe>!jmgf{-skstbp#fpwbaojpkfg#jmnjm-ip!=?,p`qjsw=	sbqwj`jsbwf#jm#wkfb#pwqlmd#jmeovfm`fpwzof>!nbqdjm.wls9qfsqfpfmwfg#az#wkfdqbgvbwfg#eqln#wkfWqbgjwjlmbooz/#wkfFofnfmw+!p`qjsw!*8Kltfufq/#pjm`f#wkf,gju=	?,gju=	?gju#ofew8#nbqdjm.ofew9sqlwf`wjlm#bdbjmpw38#ufqwj`bo.bojdm9Vmelqwvmbwfoz/#wkfwzsf>!jnbdf,{.j`lm,gju=	?gju#`obpp>!#`obpp>!`ofbqej{!=?gju#`obpp>!ellwfq\n\n?,gju=	\n\n?,gju=	wkf#nlwjlm#sj`wvqf<}=f<W<_<\\=l=m<V<T<]=f<W<_<\\=l=m<V<T<H<Y<X<Y=l<\\=j<T<T<Q<Y=m<V<R<W=`<V<R=m<R<R<]=e<Y<Q<T<Y=m<R<R<]=e<Y<Q<T=c<S=l<R<_=l<\\<P<P=g<r=n<S=l<\\<^<T=n=`<]<Y=m<S<W<\\=n<Q<R<P<\\=n<Y=l<T<\\<W=g<S<R<[<^<R<W=c<Y=n<S<R=m<W<Y<X<Q<T<Y=l<\\<[<W<T=k<Q=g=i<S=l<R<X=o<V=j<T<T<S=l<R<_=l<\\<P<P<\\<S<R<W<Q<R=m=n=`=b<Q<\\=i<R<X<T=n=m=c<T<[<]=l<\\<Q<Q<R<Y<Q<\\=m<Y<W<Y<Q<T=c<T<[<P<Y<Q<Y<Q<T=c<V<\\=n<Y<_<R=l<T<T<|<W<Y<V=m<\\<Q<X=l\fHJ\fIa\fHY\fHR\fH\\\fHR\fHB\fId\fHD\fIm\fHi\fH^\fHF\fIa\fH\\\fHJ\fHR\fHD\fHA\fHR\fH\\\fHH\fIl\fHC\fHi\fHD\fIm\fHJ\fIk\fHZ\fHU\fHS\fHD\fIa\fHJ\fIl\fHk\fHn\fHM\fHS\fHC\fHR\fHJ\fHS\fH^\fIa\fH^\fIl\fHi\fHK\fHS\fHy\fHR\fH\\\fHY\fIl\fHM\fHS\fHC\fIg\fHv\fHS\fHs\fIa\fHL\fIk\fHT\fHB\fHR\fHv\fHR\fH\\\fHp\fHn\fHy\fIa\fHZ\fHD\fHJ\fIm\fHD\fHS\fHC\fHR\fHF\fIa\fH\\\fHC\fIg\fH{\fHi\fHD\fIm\fHT\fHR\fH\\\fH}\fHD\fH^\fHR\fHk\fHD\fHF\fHR\fH\\\fIa\fHs\fIl\fHZ\fH\\\fIa\fHH\fIg\fHn\fH^\fIg\fHy\fHT\fHA\fHR\fHG\fHP\fIa\fH^\fId\fHZ\fHZ\fH\\\fIa\fHH\fIk\fHn\fHF\fIa\fH\\\fHJ\fIk\fHZ\fHF\fIa\fH^\fIk\fHC\fH\\\fHy\fIk\fHn\fHJ\fIa\fH\\\fHT\fIa\fHI\fHS\fHH\fHS\fHe\fHH\fIa\fHF\fHR\fHJ\fHe\fHD\fIa\fHU\fIk\fHn\fHv\fHS\fHs\fIa\fHL\fHR\fHC\fHR\fHH\fIa\fH\\\fHR\fHp\fIa\fHC\fHR\fHJ\fHR\fHF\fIm\fH\\\fHR\fHD\fIk\fHp\fIg\fHM\fHP\fIk\fHn\fHi\fHD\fIm\fHY\fHR\fHJ\fHZ\fIa\fH\\\fIk\fHO\fIl\fHZ\fHS\fHy\fIa\fH[\fHR\fHT\fH\\\fHy\fHR\fH\\\fIl\fHT\fHn\fH{\fIa\fH\\\fHU\fHF\fH\\\fHS\fHO\fHR\fHB\fH@\fIa\fH\\\fHR\fHn\fHM\fH@\fHv\fIa\fHv\fIg\fHn\fHe\fHF\fH^\fH@\fIa\fHK\fHB\fHn\fHH\fIa\fH\\\fIl\fHT\fHn\fHF\fH\\\fIa\fHy\fHe\fHB\fIa\fHB\fIl\fHJ\fHB\fHR\fHK\fIa\fHC\fHB\fHT\fHU\fHR\fHC\fHH\fHR\fHZ\fH@\fIa\fHJ\fIg\fHn\fHB\fIl\fHM\fHS\fHC\fHR\fHj\fHd\fHF\fIl\fHc\fH^\fHB\fIg\fH@\fHR\fHk\fH^\fHT\fHn\fHz\fIa\fHC\fHR\fHj\fHF\fH\\\fIk\fHZ\fHD\fHi\fHD\fIm\fH@\fHn\fHK\fH@\fHR\fHp\fHP\fHR\fH\\\fHD\fHY\fIl\fHD\fHH\fHB\fHF\fIa\fH\\\fHB\fIm\fHz\fHF\fIa\fH\\\fHZ\fIa\fHD\fHF\fH\\\fHS\fHY\fHR\fH\\\fHD\fIm\fHy\fHT\fHR\fHD\fHT\fHB\fH\\\fIa\fHI\fHD\fHj\fHC\fIg\fHp\fHS\fHH\fHT\fIg\fHB\fHY\fHR\fH\\4K5h5i4X4K4]5o4K4F4K5h5i5j4F4C5f4K4F4K5h5o5i4D5f5d4F4]4K5h5i4X4K5k4C4K4F4U4C4C4K5h4^5d4K4]4U4C4C4K5h4]4C5d4C4K5h4I4_5h4K5i5f4E4K5h5m5d4F5d4X5d4D4K5h5i4_4K4D5n4K4F4K5h5i4U5h5d5i4K4F4K5h5i4_5h4_5h4K4F4K5h4@4]4K5m5f5o4_4K5h4K4_5h4K5i5f4E4K5h4K4F4Y4K5h4K4Fhfztlqgp!#`lmwfmw>!t0-lqd,2:::,{kwno!=?b#wbqdfw>!\\aobmh!#wf{w,kwno8#`kbqpfw>!#wbqdfw>!\\aobmh!=?wbaof#`foosbggjmd>!bvwl`lnsofwf>!lee!#wf{w.bojdm9#`fmwfq8wl#obpw#ufqpjlm#az#ab`hdqlvmg.`lolq9# !#kqfe>!kwws9,,ttt-,gju=?,gju=?gju#jg>?b#kqfe>! !#`obpp>!!=?jnd#pq`>!kwws9,,`qjsw!#pq`>!kwws9,,	?p`qjsw#obmdvbdf>!,,FM!#!kwws9,,ttt-tfm`lgfVQJ@lnslmfmw+!#kqfe>!ibubp`qjsw9?gju#`obpp>!`lmwfmwgl`vnfmw-tqjwf+$?p`slpjwjlm9#baplovwf8p`qjsw#pq`>!kwws9,,#pwzof>!nbqdjm.wls9-njm-ip!=?,p`qjsw=	?,gju=	?gju#`obpp>!t0-lqd,2:::,{kwno!#		?,algz=	?,kwno=gjpwjm`wjlm#afwtffm,!#wbqdfw>!\\aobmh!=?ojmh#kqfe>!kwws9,,fm`lgjmd>!vwe.;!<=	t-bggFufmwOjpwfmfq<b`wjlm>!kwws9,,ttt-j`lm!#kqfe>!kwws9,,#pwzof>!ab`hdqlvmg9wzsf>!wf{w,`pp!#,=	nfwb#sqlsfqwz>!ld9w?jmsvw#wzsf>!wf{w!##pwzof>!wf{w.bojdm9wkf#gfufolsnfmw#le#wzofpkffw!#wzsf>!wfkwno8#`kbqpfw>vwe.;jp#`lmpjgfqfg#wl#afwbaof#tjgwk>!233&!#Jm#bggjwjlm#wl#wkf#`lmwqjavwfg#wl#wkf#gjeefqfm`fp#afwtffmgfufolsnfmw#le#wkf#Jw#jp#jnslqwbmw#wl#?,p`qjsw=		?p`qjsw##pwzof>!elmw.pjyf92=?,psbm=?psbm#jg>daOjaqbqz#le#@lmdqfpp?jnd#pq`>!kwws9,,jnFmdojpk#wqbmpobwjlmB`bgfnz#le#P`jfm`fpgju#pwzof>!gjpsobz9`lmpwqv`wjlm#le#wkf-dfwFofnfmwAzJg+jg*jm#`lmivm`wjlm#tjwkFofnfmw+$p`qjsw$*8#?nfwb#sqlsfqwz>!ld9<}=f<W<_<\\=l=m<V<T	#wzsf>!wf{w!#mbnf>!=Sqjub`z#Sloj`z?,b=bgnjmjpwfqfg#az#wkffmbaofPjmdofQfrvfpwpwzof>%rvlw8nbqdjm9?,gju=?,gju=?,gju=?=?jnd#pq`>!kwws9,,j#pwzof>%rvlw8eolbw9qfefqqfg#wl#bp#wkf#wlwbo#slsvobwjlm#lejm#Tbpkjmdwlm/#G-@-#pwzof>!ab`hdqlvmg.bnlmd#lwkfq#wkjmdp/lqdbmjybwjlm#le#wkfsbqwj`jsbwfg#jm#wkfwkf#jmwqlgv`wjlm#lejgfmwjejfg#tjwk#wkfej`wjlmbo#`kbqb`wfq#L{elqg#Vmjufqpjwz#njpvmgfqpwbmgjmd#leWkfqf#bqf/#kltfufq/pwzofpkffw!#kqfe>!,@lovnajb#Vmjufqpjwzf{sbmgfg#wl#jm`ovgfvpvbooz#qfefqqfg#wljmgj`bwjmd#wkbw#wkfkbuf#pvddfpwfg#wkbwbeejojbwfg#tjwk#wkf`lqqfobwjlm#afwtffmmvnafq#le#gjeefqfmw=?,wg=?,wq=?,wbaof=Qfsvaoj`#le#Jqfobmg	?,p`qjsw=	?p`qjsw#vmgfq#wkf#jmeovfm`f`lmwqjavwjlm#wl#wkfLeej`jbo#tfapjwf#lekfbgrvbqwfqp#le#wkf`fmwfqfg#bqlvmg#wkfjnsoj`bwjlmp#le#wkfkbuf#affm#gfufolsfgEfgfqbo#Qfsvaoj`#leaf`bnf#jm`qfbpjmdoz`lmwjmvbwjlm#le#wkfMlwf/#kltfufq/#wkbwpjnjobq#wl#wkbw#le#`bsbajojwjfp#le#wkfb``lqgbm`f#tjwk#wkfsbqwj`jsbmwp#jm#wkfevqwkfq#gfufolsnfmwvmgfq#wkf#gjqf`wjlmjp#lewfm#`lmpjgfqfgkjp#zlvmdfq#aqlwkfq?,wg=?,wq=?,wbaof=?b#kwws.frvju>![.VB.skzpj`bo#sqlsfqwjfple#Aqjwjpk#@lovnajbkbp#affm#`qjwj`jyfg+tjwk#wkf#f{`fswjlmrvfpwjlmp#balvw#wkfsbppjmd#wkqlvdk#wkf3!#`foosbggjmd>!3!#wklvpbmgp#le#sflsofqfgjqf`wp#kfqf-#Elqkbuf#`kjogqfm#vmgfq&0F&0@,p`qjsw&0F!**8?b#kqfe>!kwws9,,ttt-?oj=?b#kqfe>!kwws9,,pjwf\\mbnf!#`lmwfmw>!wf{w.gf`lqbwjlm9mlmfpwzof>!gjpsobz9#mlmf?nfwb#kwws.frvju>![.mft#Gbwf+*-dfwWjnf+*#wzsf>!jnbdf,{.j`lm!?,psbm=?psbm#`obpp>!obmdvbdf>!ibubp`qjswtjmglt-ol`bwjlm-kqfe?b#kqfe>!ibubp`qjsw9..=	?p`qjsw#wzsf>!w?b#kqfe>$kwws9,,ttt-klqw`vw#j`lm!#kqfe>!?,gju=	?gju#`obpp>!?p`qjsw#pq`>!kwws9,,!#qfo>!pwzofpkffw!#w?,gju=	?p`qjsw#wzsf>,b=#?b#kqfe>!kwws9,,#booltWqbmpsbqfm`z>![.VB.@lnsbwjaof!#`lmqfobwjlmpkjs#afwtffm	?,p`qjsw=	?p`qjsw#?,b=?,oj=?,vo=?,gju=bppl`jbwfg#tjwk#wkf#sqldqbnnjmd#obmdvbdf?,b=?b#kqfe>!kwws9,,?,b=?,oj=?oj#`obpp>!elqn#b`wjlm>!kwws9,,?gju#pwzof>!gjpsobz9wzsf>!wf{w!#mbnf>!r!?wbaof#tjgwk>!233&!#ab`hdqlvmg.slpjwjlm9!#alqgfq>!3!#tjgwk>!qfo>!pklqw`vw#j`lm!#k5=?vo=?oj=?b#kqfe>!##?nfwb#kwws.frvju>!`pp!#nfgjb>!p`qffm!#qfpslmpjaof#elq#wkf#!#wzsf>!bssoj`bwjlm,!#pwzof>!ab`hdqlvmg.kwno8#`kbqpfw>vwe.;!#booltwqbmpsbqfm`z>!pwzofpkffw!#wzsf>!wf	?nfwb#kwws.frvju>!=?,psbm=?psbm#`obpp>!3!#`foopsb`jmd>!3!=8	?,p`qjsw=	?p`qjsw#plnfwjnfp#`boofg#wkfglfp#mlw#mf`fppbqjozElq#nlqf#jmelqnbwjlmbw#wkf#afdjmmjmd#le#?"GL@WZSF#kwno=?kwnosbqwj`vobqoz#jm#wkf#wzsf>!kjggfm!#mbnf>!ibubp`qjsw9uljg+3*8!feef`wjufmfpp#le#wkf#bvwl`lnsofwf>!lee!#dfmfqbooz#`lmpjgfqfg=?jmsvw#wzsf>!wf{w!#!=?,p`qjsw=	?p`qjswwkqlvdklvw#wkf#tlqog`lnnlm#njp`lm`fswjlmbppl`jbwjlm#tjwk#wkf?,gju=	?,gju=	?gju#`gvqjmd#kjp#ojefwjnf/`lqqfpslmgjmd#wl#wkfwzsf>!jnbdf,{.j`lm!#bm#jm`qfbpjmd#mvnafqgjsolnbwj`#qfobwjlmpbqf#lewfm#`lmpjgfqfgnfwb#`kbqpfw>!vwe.;!#?jmsvw#wzsf>!wf{w!#f{bnsofp#jm`ovgf#wkf!=?jnd#pq`>!kwws9,,jsbqwj`jsbwjlm#jm#wkfwkf#fpwbaojpknfmw#le	?,gju=	?gju#`obpp>!%bns8maps8%bns8maps8wl#gfwfqnjmf#tkfwkfqrvjwf#gjeefqfmw#eqlnnbqhfg#wkf#afdjmmjmdgjpwbm`f#afwtffm#wkf`lmwqjavwjlmp#wl#wkf`lmeoj`w#afwtffm#wkftjgfoz#`lmpjgfqfg#wltbp#lmf#le#wkf#ejqpwtjwk#ubqzjmd#gfdqffpkbuf#psf`vobwfg#wkbw+gl`vnfmw-dfwFofnfmwsbqwj`jsbwjmd#jm#wkflqjdjmbooz#gfufolsfgfwb#`kbqpfw>!vwe.;!=#wzsf>!wf{w,`pp!#,=	jmwfq`kbmdfbaoz#tjwknlqf#`olpfoz#qfobwfgpl`jbo#bmg#slojwj`bowkbw#tlvog#lwkfqtjpfsfqsfmgj`vobq#wl#wkfpwzof#wzsf>!wf{w,`ppwzsf>!pvanjw!#mbnf>!ebnjojfp#qfpjgjmd#jmgfufolsjmd#`lvmwqjfp`lnsvwfq#sqldqbnnjmdf`lmlnj`#gfufolsnfmwgfwfqnjmbwjlm#le#wkfelq#nlqf#jmelqnbwjlmlm#pfufqbo#l``bpjlmpslqwvdv/Fp#+Fvqlsfv*<O<V=l<\\={<Q=m=`<V<\\=o<V=l<\\={<Q=m=`<V<\\<L<R=m=m<T<U=m<V<R<U<P<\\=n<Y=l<T<\\<W<R<^<T<Q=h<R=l<P<\\=j<T<T=o<S=l<\\<^<W<Y<Q<T=c<Q<Y<R<]=i<R<X<T<P<R<T<Q=h<R=l<P<\\=j<T=c<t<Q=h<R=l<P<\\=j<T=c<L<Y=m<S=o<]<W<T<V<T<V<R<W<T=k<Y=m=n<^<R<T<Q=h<R=l<P<\\=j<T=b=n<Y=l=l<T=n<R=l<T<T<X<R=m=n<\\=n<R=k<Q<R4K5h5i4F5d4K4@4C5d5j4K5h4K4X4F4]4K5o4K4F4K5h4K5n4F4]4K4A4K4Fkwno8#`kbqpfw>VWE.;!#pfwWjnflvw+evm`wjlm+*gjpsobz9jmojmf.aol`h8?jmsvw#wzsf>!pvanjw!#wzsf#>#$wf{w,ibubp`qj?jnd#pq`>!kwws9,,ttt-!#!kwws9,,ttt-t0-lqd,pklqw`vw#j`lm!#kqfe>!!#bvwl`lnsofwf>!lee!#?,b=?,gju=?gju#`obpp>?,b=?,oj=	?oj#`obpp>!`pp!#wzsf>!wf{w,`pp!#?elqn#b`wjlm>!kwws9,,{w,`pp!#kqfe>!kwws9,,ojmh#qfo>!bowfqmbwf!#	?p`qjsw#wzsf>!wf{w,#lm`oj`h>!ibubp`qjsw9+mft#Gbwf*-dfwWjnf+*~kfjdkw>!2!#tjgwk>!2!#Sflsof$p#Qfsvaoj`#le##?b#kqfe>!kwws9,,ttt-wf{w.gf`lqbwjlm9vmgfqwkf#afdjmmjmd#le#wkf#?,gju=	?,gju=	?,gju=	fpwbaojpknfmw#le#wkf#?,gju=?,gju=?,gju=?,g ujftslqwxnjm.kfjdkw9	?p`qjsw#pq`>!kwws9,,lswjlm=?lswjlm#ubovf>lewfm#qfefqqfg#wl#bp#,lswjlm=	?lswjlm#ubov?"GL@WZSF#kwno=	?"..XJmwfqmbwjlmbo#Bjqslqw=	?b#kqfe>!kwws9,,ttt?,b=?b#kqfe>!kwws9,,t\fTL\fT^\fTE\fT^\fUh\fT{\fTN\roI\ro|\roL\ro{\roO\rov\rot\nAOGx\bTA\nzk#+\vUmGx*\fHD\fHS\fH\\\fIa\fHJ\fIk\fHZ\fHM\fHR\fHe\fHD\fH^\fIg\fHM\fHy\fIa\fH[\fIk\fHH\fIa\fH\\\fHp\fHR\fHD\fHy\fHR\fH\\\fIl\fHT\fHn\fH@\fHn\fHK\fHS\fHH\fHT\fIa\fHI\fHR\fHF\fHD\fHR\fHT\fIa\fHY\fIl\fHy\fHR\fH\\\fHT\fHn\fHT\fIa\fHy\fH\\\fHO\fHT\fHR\fHB\fH{\fIa\fH\\\fIl\fHv\fHS\fHs\fIa\fHL\fIg\fHn\fHY\fHS\fHp\fIa\fHr\fHR\fHD\fHi\fHB\fIk\fH\\\fHS\fHy\fHR\fHY\fHS\fHA\fHS\fHD\fIa\fHD\fH{\fHR\fHM\fHS\fHC\fHR\fHm\fHy\fIa\fHC\fIg\fHn\fHy\fHS\fHT\fIm\fH\\\fHy\fIa\fH[\fHR\fHF\fHU\fIm\fHm\fHv\fHH\fIl\fHF\fIa\fH\\\fH@\fHn\fHK\fHD\fHs\fHS\fHF\fIa\fHF\fHO\fIl\fHy\fIa\fH\\\fHS\fHy\fIk\fHs\fHF\fIa\fH\\\fHR\fH\\\fHn\fHA\fHF\fIa\fH\\\fHR\fHF\fIa\fHH\fHB\fHR\fH^\fHS\fHy\fIg\fHn\fH\\\fHG\fHP\fIa\fHH\fHR\fH\\\fHD\fHS\fH\\\fIa\fHB\fHR\fHO\fH^\fHS\fHB\fHS\fHs\fIk\fHMgfp`qjswjlm!#`lmwfmw>!gl`vnfmw-ol`bwjlm-sqlw-dfwFofnfmwpAzWbdMbnf+?"GL@WZSF#kwno=	?kwno#?nfwb#`kbqpfw>!vwe.;!=9vqo!#`lmwfmw>!kwws9,,-`pp!#qfo>!pwzofpkffw!pwzof#wzsf>!wf{w,`pp!=wzsf>!wf{w,`pp!#kqfe>!t0-lqd,2:::,{kwno!#{nowzsf>!wf{w,ibubp`qjsw!#nfwklg>!dfw!#b`wjlm>!ojmh#qfo>!pwzofpkffw!##>#gl`vnfmw-dfwFofnfmwwzsf>!jnbdf,{.j`lm!#,=`foosbggjmd>!3!#`foops-`pp!#wzsf>!wf{w,`pp!#?,b=?,oj=?oj=?b#kqfe>!!#tjgwk>!2!#kfjdkw>!2!!=?b#kqfe>!kwws9,,ttt-pwzof>!gjpsobz9mlmf8!=bowfqmbwf!#wzsf>!bssoj.,,T0@,,GWG#[KWNO#2-3#foopsb`jmd>!3!#`foosbg#wzsf>!kjggfm!#ubovf>!,b=%maps8?psbm#qlof>!p	?jmsvw#wzsf>!kjggfm!#obmdvbdf>!IbubP`qjsw!##gl`vnfmw-dfwFofnfmwpAd>!3!#`foopsb`jmd>!3!#zsf>!wf{w,`pp!#nfgjb>!wzsf>$wf{w,ibubp`qjsw$tjwk#wkf#f{`fswjlm#le#zsf>!wf{w,`pp!#qfo>!pw#kfjdkw>!2!#tjgwk>!2!#>$(fm`lgfVQJ@lnslmfmw+?ojmh#qfo>!bowfqmbwf!#	algz/#wq/#jmsvw/#wf{wnfwb#mbnf>!qlalwp!#`lmnfwklg>!slpw!#b`wjlm>!=	?b#kqfe>!kwws9,,ttt-`pp!#qfo>!pwzofpkffw!#?,gju=?,gju=?gju#`obppobmdvbdf>!ibubp`qjsw!=bqjb.kjggfm>!wqvf!=.[?qjsw!#wzsf>!wf{w,ibubpo>38~*+*8	+evm`wjlm+*xab`hdqlvmg.jnbdf9#vqo+,b=?,oj=?oj=?b#kqfe>!k\n\n?oj=?b#kqfe>!kwws9,,bwlq!#bqjb.kjggfm>!wqv=#?b#kqfe>!kwws9,,ttt-obmdvbdf>!ibubp`qjsw!#,lswjlm=	?lswjlm#ubovf,gju=?,gju=?gju#`obpp>qbwlq!#bqjb.kjggfm>!wqf>+mft#Gbwf*-dfwWjnf+*slqwvdv/Fp#+gl#Aqbpjo*<R=l<_<\\<Q<T<[<\\=j<T<T<^<R<[<P<R<Z<Q<R=m=n=`<R<]=l<\\<[<R<^<\\<Q<T=c=l<Y<_<T=m=n=l<\\=j<T<T<^<R<[<P<R<Z<Q<R=m=n<T<R<]=c<[<\\=n<Y<W=`<Q<\\?"GL@WZSF#kwno#SVAOJ@#!mw.Wzsf!#`lmwfmw>!wf{w,?nfwb#kwws.frvju>!@lmwfqbmpjwjlmbo,,FM!#!kwws9?kwno#{nomp>!kwws9,,ttt.,,T0@,,GWG#[KWNO#2-3#WGWG,{kwno2.wqbmpjwjlmbo,,ttt-t0-lqd,WQ,{kwno2,sf#>#$wf{w,ibubp`qjsw$8?nfwb#mbnf>!gfp`qjswjlmsbqfmwMlgf-jmpfqwAfelqf?jmsvw#wzsf>!kjggfm!#mbip!#wzsf>!wf{w,ibubp`qj+gl`vnfmw*-qfbgz+evm`wjp`qjsw#wzsf>!wf{w,ibubpjnbdf!#`lmwfmw>!kwws9,,VB.@lnsbwjaof!#`lmwfmw>wno8#`kbqpfw>vwe.;!#,=	ojmh#qfo>!pklqw`vw#j`lm?ojmh#qfo>!pwzofpkffw!#?,p`qjsw=	?p`qjsw#wzsf>>#gl`vnfmw-`qfbwfFofnfm?b#wbqdfw>!\\aobmh!#kqfe>#gl`vnfmw-dfwFofnfmwpAjmsvw#wzsf>!wf{w!#mbnf>b-wzsf#>#$wf{w,ibubp`qjmsvw#wzsf>!kjggfm!#mbnfkwno8#`kbqpfw>vwe.;!#,=gwg!=	?kwno#{nomp>!kwws.,,T0@,,GWG#KWNO#7-32#WfmwpAzWbdMbnf+$p`qjsw$*jmsvw#wzsf>!kjggfm!#mbn?p`qjsw#wzsf>!wf{w,ibubp!#pwzof>!gjpsobz9mlmf8!=gl`vnfmw-dfwFofnfmwAzJg+>gl`vnfmw-`qfbwfFofnfmw+$#wzsf>$wf{w,ibubp`qjsw$jmsvw#wzsf>!wf{w!#mbnf>!g-dfwFofnfmwpAzWbdMbnf+pmj`bo!#kqfe>!kwws9,,ttt-@,,GWG#KWNO#7-32#Wqbmpjw?pwzof#wzsf>!wf{w,`pp!=		?pwzof#wzsf>!wf{w,`pp!=jlmbo-gwg!=	?kwno#{nomp>kwws.frvju>!@lmwfmw.Wzsfgjmd>!3!#`foopsb`jmd>!3!kwno8#`kbqpfw>vwe.;!#,=	#pwzof>!gjpsobz9mlmf8!=??oj=?b#kqfe>!kwws9,,ttt-#wzsf>$wf{w,ibubp`qjsw$=<X<Y=c=n<Y<W=`<Q<R=m=n<T=m<R<R=n<^<Y=n=m=n<^<T<T<S=l<R<T<[<^<R<X=m=n<^<\\<]<Y<[<R<S<\\=m<Q<R=m=n<T\fHF\fIm\fHT\fIa\fHH\fHS\fHy\fHR\fHy\fHR\fHn\fH{\fIa\fH\\\fIk\fHT\fHe\fHD\fIa\fHU\fIg\fHn\fHD\fIk\fHY\fHS\fHK\fHR\fHD\fHT\fHA\fHR\fHG\fHS\fHy\fIa\fHT\fHS\fHn\fH{\fHT\fIm\fH\\\fHy\fIa\fH[\fHS\fHH\fHy\fIe\fHF\fIl\fH\\\fHR\fHk\fHs\fHY\fHS\fHp\fIa\fHr\fHR\fHF\fHD\fHy\fHR\fH\\\fIa\fH\\\fHY\fHR\fHd\fHT\fHy\fIa\fH\\\fHS\fHC\fHH\fHR', "۷%ƌ'T%'W%×%O%g%¦&Ɠ%ǥ&>&*&'&^&Ÿా&ƭ&ƒ&)&^&%&'&&P&1&±&3&]&m&u&E&t&C&Ï&V&V&/&>&6&ྲྀ᝼o&p&@&E&M&P&x&@&F&e&Ì&7&:&(&D&0&C&)&.&F&-&1&(&L&F&1ɞ*Ϫ⇳&፲&K&;&)&E&H&P&0&?&9&V&&-&v&a&,&E&)&?&=&'&'&B&മ&ԃ&̖*&*8&%&%&&&%,)&&>&&7&]&F&2&>&J&6&n&2&%&?&&2&6&J&g&-&0&,&*&J&*&O&)&6&(&<&B&N&.&P&@&2&.&W&M&%Լ(,(<&,&Ϛ&ᣇ&-&,(%&(&%&(Ļ0&X&D&&j&'&J&(&.&B&3&Z&R&h&3&E&E&<Æ-͠ỳ&%8?&@&,&Z&@&0&J&,&^&x&_&6&C&6&Cܬ⨥&f&-&-&-&-&,&J&2&8&z&8&C&Y&8&-&d&ṸÌ-&7&1&F&7&t&W&7&I&.&.&^&=ྜ᧓&8(>&/&/&ݻ')'ၥ')'%@/&0&%оী*&*@&CԽהɴ׫4෗ܚӑ6඄&/Ÿ̃Z&*%ɆϿ&Ĵ&1¨ҴŴ", dictionarySizeBits, "AAAAKKLLKKKKKJJIHHIHHGGFF");
    flipBuffer(dictionaryData);
    setData(asReadOnlyBuffer(dictionaryData), dictionarySizeBits);
  }
  function min(a3, b2) {
    return a3 <= b2 ? a3 : b2;
  }
  function copyBytes(dst, target, src, start, end) {
    dst.set(src.slice(start, end), target);
  }
  function readInput(src, dst, offset, length2) {
    if (src == null)
      return -1;
    let end = min(src.offset + length2, src.data.length);
    let bytesRead = end - src.offset;
    dst.set(src.data.subarray(src.offset, end), offset);
    src.offset += bytesRead;
    return bytesRead;
  }
  function closeInput(src) {
    return 0;
  }
  function asReadOnlyBuffer(src) {
    return src;
  }
  function isReadOnly(src) {
    return 1;
  }
  function isDirect(src) {
    return 1;
  }
  function flipBuffer(buffer) {
  }
  function toUsAsciiBytes(src) {
    let n2 = src.length;
    let result = new Int8Array(n2);
    for (let i3 = 0; i3 < n2; ++i3) {
      result[i3] = src.charCodeAt(i3);
    }
    return result;
  }
  function decode12(bytes, options) {
    let s2 = new State();
    initState(s2, new InputStream(bytes));
    if (options) {
      let customDictionary = (
        /** @type {?Int8Array} */
        options["customDictionary"]
      );
      if (customDictionary)
        attachDictionaryChunk(s2, customDictionary);
    }
    let totalOutput = 0;
    let chunks = [];
    while (true) {
      let chunk = new Int8Array(16384);
      chunks.push(chunk);
      s2.output = chunk;
      s2.outputOffset = 0;
      s2.outputLength = 16384;
      s2.outputUsed = 0;
      decompress(s2);
      totalOutput += s2.outputUsed;
      if (s2.outputUsed < 16384)
        break;
    }
    close(s2);
    let result = new Int8Array(totalOutput);
    let offset = 0;
    for (let i3 = 0; i3 < chunks.length; ++i3) {
      let chunk = chunks[i3];
      let end = min(totalOutput, offset + 16384);
      let len = end - offset;
      if (len < 16384) {
        result.set(chunk.subarray(0, len), offset);
      } else {
        result.set(chunk, offset);
      }
      offset += len;
    }
    return result;
  }
  return decode12;
};
var BrotliDecode = makeBrotliDecode();

// node_modules/@loaders.gl/compression/dist/lib/brotli-compression.js
var import_zlib2 = __toESM(require_zlib(), 1);

// node_modules/@loaders.gl/compression/dist/lib/snappy-compression.js
var import_snappyjs = __toESM(require_snappyjs(), 1);

// node_modules/@deck.gl/geo-layers/dist/tile-3d-layer/tile-3d-layer.js
var SINGLE_DATA = [0];
var defaultProps28 = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: Tiles3DLoader,
  onTilesetLoad: { type: "function", value: (tileset3d) => {
  } },
  onTileLoad: { type: "function", value: (tileHeader) => {
  } },
  onTileUnload: { type: "function", value: (tileHeader) => {
  } },
  onTileError: { type: "function", value: (tile, message, url) => {
  } },
  _getMeshColor: { type: "function", value: (tileHeader) => [255, 255, 255] }
};
var _Tile3DLayer = class _Tile3DLayer extends CompositeLayer {
  initializeState() {
    if ("onTileLoadFail" in this.props) {
      log_default.removed("onTileLoadFail", "onTileError")();
    }
    this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var _a, _b;
    return Boolean(((_b = (_a = this.state) == null ? void 0 : _a.tileset3d) == null ? void 0 : _b.isLoaded()) && super.isLoaded);
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ props, oldProps, changeFlags }) {
    if (props.data && props.data !== oldProps.data) {
      this._loadTileset(props.data);
    }
    if (changeFlags.viewportChanged) {
      const { activeViewports } = this.state;
      const viewportsNumber = Object.keys(activeViewports).length;
      if (viewportsNumber) {
        this._updateTileset(activeViewports);
        this.state.lastUpdatedViewports = activeViewports;
        this.state.activeViewports = {};
      }
    }
    if (changeFlags.propsChanged) {
      const { layerMap } = this.state;
      for (const key in layerMap) {
        layerMap[key].needsUpdate = true;
      }
    }
  }
  activateViewport(viewport) {
    const { activeViewports, lastUpdatedViewports } = this.state;
    this.internalState.viewport = viewport;
    activeViewports[viewport.id] = viewport;
    const lastViewport = lastUpdatedViewports == null ? void 0 : lastUpdatedViewports[viewport.id];
    if (!lastViewport || !viewport.equals(lastViewport)) {
      this.setChangeFlags({ viewportChanged: true });
      this.setNeedsUpdate();
    }
  }
  getPickingInfo({ info, sourceLayer }) {
    const sourceTile = sourceLayer && sourceLayer.props.tile;
    if (info.picked) {
      info.object = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  filterSubLayer({ layer, viewport }) {
    const { tile } = layer.props;
    const { id: viewportId } = viewport;
    return tile.selected && tile.viewportIds.includes(viewportId);
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    const layerCache = this.state.layerMap[sourceTile == null ? void 0 : sourceTile.id];
    if (layerCache && layerCache.layer) {
      layerCache.layer.updateAutoHighlight(info);
    }
  }
  async _loadTileset(tilesetUrl) {
    const { loadOptions = {} } = this.props;
    const loaders = this.props.loader || this.props.loaders;
    const loader = Array.isArray(loaders) ? loaders[0] : loaders;
    const options = { loadOptions: { ...loadOptions } };
    let actualTilesetUrl = tilesetUrl;
    if (loader.preload) {
      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
      if (preloadOptions.url) {
        actualTilesetUrl = preloadOptions.url;
      }
      if (preloadOptions.headers) {
        options.loadOptions.fetch = {
          ...options.loadOptions.fetch,
          headers: preloadOptions.headers
        };
      }
      Object.assign(options, preloadOptions);
    }
    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
    const tileset3d = new Tileset3D(tilesetJson, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...options
    });
    this.setState({
      tileset3d,
      layerMap: {}
    });
    this._updateTileset(this.state.activeViewports);
    this.props.onTilesetLoad(tileset3d);
  }
  _onTileLoad(tileHeader) {
    const { lastUpdatedViewports } = this.state;
    this.props.onTileLoad(tileHeader);
    this._updateTileset(lastUpdatedViewports);
    this.setNeedsUpdate();
  }
  _onTileUnload(tileHeader) {
    delete this.state.layerMap[tileHeader.id];
    this.props.onTileUnload(tileHeader);
  }
  _updateTileset(viewports) {
    if (!viewports) {
      return;
    }
    const { tileset3d } = this.state;
    const { timeline } = this.context;
    const viewportsNumber = Object.keys(viewports).length;
    if (!timeline || !viewportsNumber || !tileset3d) {
      return;
    }
    tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (tilesetChanged) {
        this.setState({ frameNumber });
      }
    });
  }
  _getSubLayer(tileHeader, oldLayer) {
    if (!tileHeader.content) {
      return null;
    }
    switch (tileHeader.type) {
      case TILE_TYPE.POINTCLOUD:
        return this._makePointCloudLayer(tileHeader, oldLayer);
      case TILE_TYPE.SCENEGRAPH:
        return this._make3DModelLayer(tileHeader);
      case TILE_TYPE.MESH:
        return this._makeSimpleMeshLayer(tileHeader, oldLayer);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
    }
  }
  _makePointCloudLayer(tileHeader, oldLayer) {
    const { attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const { positions, normals, colors } = attributes;
    if (!positions) {
      return null;
    }
    const data = oldLayer && oldLayer.props.data || {
      header: {
        vertexCount: pointCount
      },
      attributes: {
        POSITION: positions,
        NORMAL: normals,
        COLOR_0: colors
      }
    };
    const { pointSize, getPointColor } = this.props;
    const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
    return new SubLayerClass({
      pointSize
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${tileHeader.id}`,
      tile: tileHeader,
      data,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getColor: constantRGBA || getPointColor,
      _offset: 0
    });
  }
  _make3DModelLayer(tileHeader) {
    const { gltf, instances, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
    return new SubLayerClass({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${tileHeader.id}`,
      tile: tileHeader,
      data: instances || SINGLE_DATA,
      scenegraph: gltf,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getTransformMatrix: (instance) => instance.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(tileHeader, oldLayer) {
    const content = tileHeader.content;
    const { attributes, indices, modelMatrix: modelMatrix2, cartographicOrigin, coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS, material, featureIds } = content;
    const { _getMeshColor } = this.props;
    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
      topology: "triangle-list",
      attributes: getMeshGeometry(attributes),
      indices
    });
    const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${tileHeader.id}`,
      tile: tileHeader,
      mesh: geometry,
      data: SINGLE_DATA,
      getColor: _getMeshColor(tileHeader),
      pbrMaterial: material,
      modelMatrix: modelMatrix2,
      coordinateOrigin: cartographicOrigin,
      coordinateSystem,
      featureIds,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d, layerMap } = this.state;
    if (!tileset3d) {
      return null;
    }
    return tileset3d.tiles.map((tile) => {
      const layerCache = layerMap[tile.id] = layerMap[tile.id] || { tile };
      let { layer } = layerCache;
      if (tile.selected) {
        if (!layer) {
          layer = this._getSubLayer(tile);
        } else if (layerCache.needsUpdate) {
          layer = this._getSubLayer(tile, layer);
          layerCache.needsUpdate = false;
        }
      }
      layerCache.layer = layer;
      return layer;
    }).filter(Boolean);
  }
};
_Tile3DLayer.defaultProps = defaultProps28;
_Tile3DLayer.layerName = "Tile3DLayer";
var Tile3DLayer = _Tile3DLayer;
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}

// node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js
var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([
  ["centerX", Float64Array.BYTES_PER_ELEMENT],
  ["centerY", Float64Array.BYTES_PER_ELEMENT],
  ["centerZ", Float64Array.BYTES_PER_ELEMENT],
  ["minHeight", Float32Array.BYTES_PER_ELEMENT],
  ["maxHeight", Float32Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]
]);
function decodeZigZag(value) {
  return value >> 1 ^ -(value & 1);
}
function decodeHeader(dataView) {
  let position = 0;
  const header = {};
  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
    header[key] = getter.call(dataView, position, true);
    position += bytesCount;
  }
  return { header, headerEndPosition: position };
}
function decodeVertexData(dataView, headerEndPosition) {
  let position = headerEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = dataView.getUint32(position, true);
  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
  const elementArrayLength = vertexCount * bytesPerArrayElement;
  const uArrayStartPosition = position;
  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
  let u = 0;
  let v = 0;
  let height = 0;
  for (let i3 = 0; i3 < vertexCount; i3++) {
    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i3, true));
    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i3, true));
    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i3, true));
    vertexData[i3] = u;
    vertexData[i3 + vertexCount] = v;
    vertexData[i3 + vertexCount * 2] = height;
  }
  position += elementArrayLength * 3;
  return { vertexData, vertexDataEndPosition: position };
}
function decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {
  let indices;
  if (bytesPerIndex === 2) {
    indices = new Uint16Array(buffer, position, indicesCount);
  } else {
    indices = new Uint32Array(buffer, position, indicesCount);
  }
  if (!encoded) {
    return indices;
  }
  let highest = 0;
  for (let i3 = 0; i3 < indices.length; ++i3) {
    const code = indices[i3];
    indices[i3] = highest - code;
    if (code === 0) {
      ++highest;
    }
  }
  return indices;
}
function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
  let position = vertexDataEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  if (position % bytesPerIndex !== 0) {
    position += bytesPerIndex - position % bytesPerIndex;
  }
  const triangleCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const triangleIndicesCount = triangleCount * 3;
  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
  position += triangleIndicesCount * bytesPerIndex;
  return {
    triangleIndicesEndPosition: position,
    triangleIndices
  };
}
function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
  let position = triangleIndicesEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  const westVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
  position += westVertexCount * bytesPerIndex;
  const southVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
  position += southVertexCount * bytesPerIndex;
  const eastVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
  position += eastVertexCount * bytesPerIndex;
  const northVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
  position += northVertexCount * bytesPerIndex;
  return {
    edgeIndicesEndPosition: position,
    westIndices,
    southIndices,
    eastIndices,
    northIndices
  };
}
function decodeVertexNormalsExtension(extensionDataView) {
  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
}
function decodeWaterMaskExtension(extensionDataView) {
  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
}
function decodeExtensions2(dataView, indicesEndPosition) {
  const extensions = {};
  if (dataView.byteLength <= indicesEndPosition) {
    return { extensions, extensionsEndPosition: indicesEndPosition };
  }
  let position = indicesEndPosition;
  while (position < dataView.byteLength) {
    const extensionId = dataView.getUint8(position, true);
    position += Uint8Array.BYTES_PER_ELEMENT;
    const extensionLength = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const extensionView = new DataView(dataView.buffer, position, extensionLength);
    switch (extensionId) {
      case 1: {
        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
        break;
      }
      case 2: {
        extensions.waterMask = decodeWaterMaskExtension(extensionView);
        break;
      }
      default: {
      }
    }
    position += extensionLength;
  }
  return { extensions, extensionsEndPosition: position };
}
var DECODING_STEPS = {
  header: 0,
  vertices: 1,
  triangleIndices: 2,
  edgeIndices: 3,
  extensions: 4
};
var DEFAULT_OPTIONS2 = {
  maxDecodingStep: DECODING_STEPS.extensions
};
function decode11(data, userOptions) {
  const options = Object.assign({}, DEFAULT_OPTIONS2, userOptions);
  const view = new DataView(data);
  const { header, headerEndPosition } = decodeHeader(view);
  if (options.maxDecodingStep < DECODING_STEPS.vertices) {
    return { header };
  }
  const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
    return { header, vertexData };
  }
  const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
    return { header, vertexData, triangleIndices };
  }
  const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.extensions) {
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    };
  }
  const { extensions } = decodeExtensions2(view, edgeIndicesEndPosition);
  return {
    header,
    vertexData,
    triangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices,
    extensions
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js
function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
  const newTriangles = new triangles.constructor(outsideEdges.length * 6);
  for (let i3 = 0; i3 < outsideEdges.length; i3++) {
    const edge = outsideEdges[i3];
    updateAttributesForNewEdge({
      edge,
      edgeIndex: i3,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    });
  }
  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
  return {
    attributes,
    triangles: resultTriangles
  };
}
function getOutsideEdgesFromTriangles(triangles) {
  var _a, _b;
  const edges = [];
  for (let i3 = 0; i3 < triangles.length; i3 += 3) {
    edges.push([triangles[i3], triangles[i3 + 1]]);
    edges.push([triangles[i3 + 1], triangles[i3 + 2]]);
    edges.push([triangles[i3 + 2], triangles[i3]]);
  }
  edges.sort((a3, b2) => Math.min(...a3) - Math.min(...b2) || Math.max(...a3) - Math.max(...b2));
  const outsideEdges = [];
  let index = 0;
  while (index < edges.length) {
    if (edges[index][0] === ((_a = edges[index + 1]) == null ? void 0 : _a[1]) && edges[index][1] === ((_b = edges[index + 1]) == null ? void 0 : _b[0])) {
      index += 2;
    } else {
      outsideEdges.push(edges[index]);
      index++;
    }
  }
  return outsideEdges;
}
function getOutsideEdgesFromIndices(indices, position) {
  indices.westIndices.sort((a3, b2) => position[3 * a3 + 1] - position[3 * b2 + 1]);
  indices.eastIndices.sort((a3, b2) => position[3 * b2 + 1] - position[3 * a3 + 1]);
  indices.southIndices.sort((a3, b2) => position[3 * b2] - position[3 * a3]);
  indices.northIndices.sort((a3, b2) => position[3 * a3] - position[3 * b2]);
  const edges = [];
  for (const index in indices) {
    const indexGroup = indices[index];
    for (let i3 = 0; i3 < indexGroup.length - 1; i3++) {
      edges.push([indexGroup[i3], indexGroup[i3 + 1]]);
    }
  }
  return edges;
}
function updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {
  const positionsLength = attributes.POSITION.value.length;
  const vertex1Offset = edgeIndex * 2;
  const vertex2Offset = edgeIndex * 2 + 1;
  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
  const triangle1Offset = edgeIndex * 2 * 3;
  newTriangles[triangle1Offset] = edge[0];
  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 2] = edge[1];
  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 4] = edge[0];
  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js
function parseQuantizedMesh(arrayBuffer, options = {}) {
  const { bounds } = options;
  const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode11(arrayBuffer, DECODING_STEPS.triangleIndices);
  let triangleIndices = originalTriangleIndices;
  let attributes = getMeshAttributes(vertexData, header, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (options == null ? void 0 : options.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    });
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      // @ts-ignore
      vertexCount: triangleIndices.length,
      boundingBox
    },
    // TODO
    schema: void 0,
    topology: "triangle-list",
    mode: 4,
    // TRIANGLES
    indices: { value: triangleIndices, size: 1 },
    attributes
  };
}
function getMeshAttributes(vertexData, header, bounds) {
  const { minHeight, maxHeight } = header;
  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
  const xScale = maxX - minX;
  const yScale = maxY - minY;
  const zScale = maxHeight - minHeight;
  const nCoords = vertexData.length / 3;
  const positions = new Float32Array(nCoords * 3);
  const texCoords = new Float32Array(nCoords * 2);
  for (let i3 = 0; i3 < nCoords; i3++) {
    const x2 = vertexData[i3] / 32767;
    const y2 = vertexData[i3 + nCoords] / 32767;
    const z = vertexData[i3 + nCoords * 2] / 32767;
    positions[3 * i3 + 0] = x2 * xScale + minX;
    positions[3 * i3 + 1] = y2 * yScale + minY;
    positions[3 * i3 + 2] = z * zScale + minHeight;
    texCoords[2 * i3 + 0] = x2;
    texCoords[2 * i3 + 1] = y2;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // TODO: Parse normals if they exist in the file
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@mapbox/martini/index.js
var Martini = class {
  constructor(gridSize = 257) {
    this.gridSize = gridSize;
    const tileSize = gridSize - 1;
    if (tileSize & tileSize - 1)
      throw new Error(
        `Expected grid size to be 2^n+1, got ${gridSize}.`
      );
    this.numTriangles = tileSize * tileSize * 2 - 2;
    this.numParentTriangles = this.numTriangles - tileSize * tileSize;
    this.indices = new Uint32Array(this.gridSize * this.gridSize);
    this.coords = new Uint16Array(this.numTriangles * 4);
    for (let i3 = 0; i3 < this.numTriangles; i3++) {
      let id = i3 + 2;
      let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
      if (id & 1) {
        bx = by = cx = tileSize;
      } else {
        ax = ay = cy = tileSize;
      }
      while ((id >>= 1) > 1) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (id & 1) {
          bx = ax;
          by = ay;
          ax = cx;
          ay = cy;
        } else {
          ax = bx;
          ay = by;
          bx = cx;
          by = cy;
        }
        cx = mx;
        cy = my;
      }
      const k = i3 * 4;
      this.coords[k + 0] = ax;
      this.coords[k + 1] = ay;
      this.coords[k + 2] = bx;
      this.coords[k + 3] = by;
    }
  }
  createTile(terrain) {
    return new Tile(terrain, this);
  }
};
var Tile = class {
  constructor(terrain, martini) {
    const size = martini.gridSize;
    if (terrain.length !== size * size)
      throw new Error(
        `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
      );
    this.terrain = terrain;
    this.martini = martini;
    this.errors = new Float32Array(terrain.length);
    this.update();
  }
  update() {
    const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
    const { terrain, errors } = this;
    for (let i3 = numTriangles - 1; i3 >= 0; i3--) {
      const k = i3 * 4;
      const ax = coords[k + 0];
      const ay = coords[k + 1];
      const bx = coords[k + 2];
      const by = coords[k + 3];
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      const cx = mx + my - ay;
      const cy = my + ax - mx;
      const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
      const middleIndex = my * size + mx;
      const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
      errors[middleIndex] = Math.max(errors[middleIndex], middleError);
      if (i3 < numParentTriangles) {
        const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
        const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
        errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
      }
    }
  }
  getMesh(maxError = 0) {
    const { gridSize: size, indices } = this.martini;
    const { errors } = this;
    let numVertices = 0;
    let numTriangles = 0;
    const max = size - 1;
    indices.fill(0);
    function countElements(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        countElements(cx, cy, ax, ay, mx, my);
        countElements(bx, by, cx, cy, mx, my);
      } else {
        indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
        indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
        indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
        numTriangles++;
      }
    }
    countElements(0, 0, max, max, max, 0);
    countElements(max, max, 0, 0, 0, max);
    const vertices = new Uint16Array(numVertices * 2);
    const triangles = new Uint32Array(numTriangles * 3);
    let triIndex = 0;
    function processTriangle(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        processTriangle(cx, cy, ax, ay, mx, my);
        processTriangle(bx, by, cx, cy, mx, my);
      } else {
        const a3 = indices[ay * size + ax] - 1;
        const b2 = indices[by * size + bx] - 1;
        const c2 = indices[cy * size + cx] - 1;
        vertices[2 * a3] = ax;
        vertices[2 * a3 + 1] = ay;
        vertices[2 * b2] = bx;
        vertices[2 * b2 + 1] = by;
        vertices[2 * c2] = cx;
        vertices[2 * c2 + 1] = cy;
        triangles[triIndex++] = a3;
        triangles[triIndex++] = b2;
        triangles[triIndex++] = c2;
      }
    }
    processTriangle(0, 0, max, max, max, 0);
    processTriangle(max, max, 0, 0, 0, max);
    return { vertices, triangles };
  }
};

// node_modules/@loaders.gl/terrain/dist/lib/delatin/index.js
var Delatin = class {
  constructor(data, width, height = width) {
    this.data = data;
    this.width = width;
    this.height = height;
    this.coords = [];
    this.triangles = [];
    this._halfedges = [];
    this._candidates = [];
    this._queueIndices = [];
    this._queue = [];
    this._errors = [];
    this._rms = [];
    this._pending = [];
    this._pendingLen = 0;
    this._rmsSum = 0;
    const x1 = width - 1;
    const y1 = height - 1;
    const p0 = this._addPoint(0, 0);
    const p1 = this._addPoint(x1, 0);
    const p2 = this._addPoint(0, y1);
    const p3 = this._addPoint(x1, y1);
    const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
    this._addTriangle(p0, p3, p1, t0, -1, -1);
    this._flush();
  }
  // refine the mesh until its maximum error gets below the given one
  run(maxError = 1) {
    while (this.getMaxError() > maxError) {
      this.refine();
    }
  }
  // refine the mesh with a single point
  refine() {
    this._step();
    this._flush();
  }
  // max error of the current mesh
  getMaxError() {
    return this._errors[0];
  }
  // root-mean-square deviation of the current mesh
  getRMSD() {
    return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
  }
  // height value at a given position
  heightAt(x2, y2) {
    return this.data[this.width * y2 + x2];
  }
  // rasterize and queue all triangles that got added or updated in _step
  _flush() {
    const coords = this.coords;
    for (let i3 = 0; i3 < this._pendingLen; i3++) {
      const t2 = this._pending[i3];
      const a3 = 2 * this.triangles[t2 * 3 + 0];
      const b2 = 2 * this.triangles[t2 * 3 + 1];
      const c2 = 2 * this.triangles[t2 * 3 + 2];
      this._findCandidate(coords[a3], coords[a3 + 1], coords[b2], coords[b2 + 1], coords[c2], coords[c2 + 1], t2);
    }
    this._pendingLen = 0;
  }
  // rasterize a triangle, find its max error, and queue it for processing
  _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t2) {
    const minX = Math.min(p0x, p1x, p2x);
    const minY = Math.min(p0y, p1y, p2y);
    const maxX = Math.max(p0x, p1x, p2x);
    const maxY = Math.max(p0y, p1y, p2y);
    let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
    let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
    let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
    const a01 = p1y - p0y;
    const b01 = p0x - p1x;
    const a12 = p2y - p1y;
    const b12 = p1x - p2x;
    const a20 = p0y - p2y;
    const b20 = p2x - p0x;
    const a3 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
    const z0 = this.heightAt(p0x, p0y) / a3;
    const z1 = this.heightAt(p1x, p1y) / a3;
    const z2 = this.heightAt(p2x, p2y) / a3;
    let maxError = 0;
    let mx = 0;
    let my = 0;
    let rms = 0;
    for (let y2 = minY; y2 <= maxY; y2++) {
      let dx = 0;
      if (w00 < 0 && a12 !== 0) {
        dx = Math.max(dx, Math.floor(-w00 / a12));
      }
      if (w01 < 0 && a20 !== 0) {
        dx = Math.max(dx, Math.floor(-w01 / a20));
      }
      if (w02 < 0 && a01 !== 0) {
        dx = Math.max(dx, Math.floor(-w02 / a01));
      }
      let w0 = w00 + a12 * dx;
      let w1 = w01 + a20 * dx;
      let w2 = w02 + a01 * dx;
      let wasInside = false;
      for (let x2 = minX + dx; x2 <= maxX; x2++) {
        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
          wasInside = true;
          const z = z0 * w0 + z1 * w1 + z2 * w2;
          const dz = Math.abs(z - this.heightAt(x2, y2));
          rms += dz * dz;
          if (dz > maxError) {
            maxError = dz;
            mx = x2;
            my = y2;
          }
        } else if (wasInside) {
          break;
        }
        w0 += a12;
        w1 += a20;
        w2 += a01;
      }
      w00 += b12;
      w01 += b20;
      w02 += b01;
    }
    if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
      maxError = 0;
    }
    this._candidates[2 * t2] = mx;
    this._candidates[2 * t2 + 1] = my;
    this._rms[t2] = rms;
    this._queuePush(t2, maxError, rms);
  }
  // process the next triangle in the queue, splitting it with a new point
  _step() {
    const t2 = this._queuePop();
    const e0 = t2 * 3 + 0;
    const e1 = t2 * 3 + 1;
    const e2 = t2 * 3 + 2;
    const p0 = this.triangles[e0];
    const p1 = this.triangles[e1];
    const p2 = this.triangles[e2];
    const ax = this.coords[2 * p0];
    const ay = this.coords[2 * p0 + 1];
    const bx = this.coords[2 * p1];
    const by = this.coords[2 * p1 + 1];
    const cx = this.coords[2 * p2];
    const cy = this.coords[2 * p2 + 1];
    const px = this._candidates[2 * t2];
    const py = this._candidates[2 * t2 + 1];
    const pn = this._addPoint(px, py);
    if (orient(ax, ay, bx, by, px, py) === 0) {
      this._handleCollinear(pn, e0);
    } else if (orient(bx, by, cx, cy, px, py) === 0) {
      this._handleCollinear(pn, e1);
    } else if (orient(cx, cy, ax, ay, px, py) === 0) {
      this._handleCollinear(pn, e2);
    } else {
      const h0 = this._halfedges[e0];
      const h1 = this._halfedges[e1];
      const h2 = this._halfedges[e2];
      const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
      const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
      const t22 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t22);
    }
  }
  // add coordinates for a new vertex
  _addPoint(x2, y2) {
    const i3 = this.coords.length >> 1;
    this.coords.push(x2, y2);
    return i3;
  }
  // add or update a triangle in the mesh
  _addTriangle(a3, b2, c2, ab, bc, ca, e2 = this.triangles.length) {
    const t2 = e2 / 3;
    this.triangles[e2 + 0] = a3;
    this.triangles[e2 + 1] = b2;
    this.triangles[e2 + 2] = c2;
    this._halfedges[e2 + 0] = ab;
    this._halfedges[e2 + 1] = bc;
    this._halfedges[e2 + 2] = ca;
    if (ab >= 0) {
      this._halfedges[ab] = e2 + 0;
    }
    if (bc >= 0) {
      this._halfedges[bc] = e2 + 1;
    }
    if (ca >= 0) {
      this._halfedges[ca] = e2 + 2;
    }
    this._candidates[2 * t2 + 0] = 0;
    this._candidates[2 * t2 + 1] = 0;
    this._queueIndices[t2] = -1;
    this._rms[t2] = 0;
    this._pending[this._pendingLen++] = t2;
    return e2;
  }
  _legalize(a3) {
    const b2 = this._halfedges[a3];
    if (b2 < 0) {
      return;
    }
    const a0 = a3 - a3 % 3;
    const b0 = b2 - b2 % 3;
    const al = a0 + (a3 + 1) % 3;
    const ar = a0 + (a3 + 2) % 3;
    const bl = b0 + (b2 + 2) % 3;
    const br = b0 + (b2 + 1) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a3];
    const pl = this.triangles[al];
    const p1 = this.triangles[bl];
    const coords = this.coords;
    if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
      return;
    }
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(a0 / 3);
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
    const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
    this._legalize(t0 + 1);
    this._legalize(t1 + 2);
  }
  // handle a case where new vertex is on the edge of a triangle
  _handleCollinear(pn, a3) {
    const a0 = a3 - a3 % 3;
    const al = a0 + (a3 + 1) % 3;
    const ar = a0 + (a3 + 2) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a3];
    const pl = this.triangles[al];
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const b2 = this._halfedges[a3];
    if (b2 < 0) {
      const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
      const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
      this._legalize(t02 + 1);
      this._legalize(t12 + 2);
      return;
    }
    const b0 = b2 - b2 % 3;
    const bl = b0 + (b2 + 2) % 3;
    const br = b0 + (b2 + 1) % 3;
    const p1 = this.triangles[bl];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
    const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
    const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
    const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
    this._legalize(t0);
    this._legalize(t1);
    this._legalize(t2);
    this._legalize(t3);
  }
  // priority queue methods
  _queuePush(t2, error, rms) {
    const i3 = this._queue.length;
    this._queueIndices[t2] = i3;
    this._queue.push(t2);
    this._errors.push(error);
    this._rmsSum += rms;
    this._queueUp(i3);
  }
  _queuePop() {
    const n2 = this._queue.length - 1;
    this._queueSwap(0, n2);
    this._queueDown(0, n2);
    return this._queuePopBack();
  }
  _queuePopBack() {
    const t2 = this._queue.pop();
    this._errors.pop();
    this._rmsSum -= this._rms[t2];
    this._queueIndices[t2] = -1;
    return t2;
  }
  _queueRemove(t2) {
    const i3 = this._queueIndices[t2];
    if (i3 < 0) {
      const it = this._pending.indexOf(t2);
      if (it !== -1) {
        this._pending[it] = this._pending[--this._pendingLen];
      } else {
        throw new Error("Broken triangulation (something went wrong).");
      }
      return;
    }
    const n2 = this._queue.length - 1;
    if (n2 !== i3) {
      this._queueSwap(i3, n2);
      if (!this._queueDown(i3, n2)) {
        this._queueUp(i3);
      }
    }
    this._queuePopBack();
  }
  _queueLess(i3, j) {
    return this._errors[i3] > this._errors[j];
  }
  _queueSwap(i3, j) {
    const pi = this._queue[i3];
    const pj = this._queue[j];
    this._queue[i3] = pj;
    this._queue[j] = pi;
    this._queueIndices[pi] = j;
    this._queueIndices[pj] = i3;
    const e2 = this._errors[i3];
    this._errors[i3] = this._errors[j];
    this._errors[j] = e2;
  }
  _queueUp(j0) {
    let j = j0;
    while (true) {
      const i3 = j - 1 >> 1;
      if (i3 === j || !this._queueLess(j, i3)) {
        break;
      }
      this._queueSwap(i3, j);
      j = i3;
    }
  }
  _queueDown(i0, n2) {
    let i3 = i0;
    while (true) {
      const j1 = 2 * i3 + 1;
      if (j1 >= n2 || j1 < 0) {
        break;
      }
      const j2 = j1 + 1;
      let j = j1;
      if (j2 < n2 && this._queueLess(j2, j1)) {
        j = j2;
      }
      if (!this._queueLess(j, i3)) {
        break;
      }
      this._queueSwap(i3, j);
      i3 = j;
    }
    return i3 > i0;
  }
};
function orient(ax, ay, bx, by, cx, cy) {
  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js
function makeTerrainMeshFromImage(terrainImage, terrainOptions) {
  const { meshMaxError, bounds, elevationDecoder } = terrainOptions;
  const { data, width, height } = terrainImage;
  let terrain;
  let mesh;
  switch (terrainOptions.tesselator) {
    case "martini":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case "delatin":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, "martini");
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  const { vertices } = mesh;
  let { triangles } = mesh;
  let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (terrainOptions.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox
    },
    mode: 4,
    // TRIANGLES
    indices: { value: Uint32Array.from(triangles), size: 1 },
    attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  const gridSize = width + 1;
  const martini = new Martini(gridSize);
  const tile = martini.createTile(terrain);
  const { vertices, triangles } = tile.getMesh(meshMaxError);
  return { vertices, triangles };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  const tin = new Delatin(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  const { coords, triangles } = tin;
  const vertices = coords;
  return { vertices, triangles };
}
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  const { rScaler, bScaler, gScaler, offset } = elevationDecoder;
  const terrain = new Float32Array((width + 1) * (height + 1));
  for (let i3 = 0, y2 = 0; y2 < height; y2++) {
    for (let x2 = 0; x2 < width; x2++, i3++) {
      const k = i3 * 4;
      const r2 = imageData[k + 0];
      const g = imageData[k + 1];
      const b2 = imageData[k + 2];
      terrain[i3 + y2] = r2 * rScaler + g * gScaler + b2 * bScaler + offset;
    }
  }
  if (tesselator === "martini") {
    for (let i3 = (width + 1) * width, x2 = 0; x2 < width; x2++, i3++) {
      terrain[i3] = terrain[i3 - width - 1];
    }
    for (let i3 = height, y2 = 0; y2 < height + 1; y2++, i3 += height + 1) {
      terrain[i3] = terrain[i3 - 1];
    }
  }
  return terrain;
}
function getMeshAttributes2(vertices, terrain, width, height, bounds) {
  const gridSize = width + 1;
  const numOfVerticies = vertices.length / 2;
  const positions = new Float32Array(numOfVerticies * 3);
  const texCoords = new Float32Array(numOfVerticies * 2);
  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
  const xScale = (maxX - minX) / width;
  const yScale = (maxY - minY) / height;
  for (let i3 = 0; i3 < numOfVerticies; i3++) {
    const x2 = vertices[i3 * 2];
    const y2 = vertices[i3 * 2 + 1];
    const pixelIdx = y2 * gridSize + x2;
    positions[3 * i3 + 0] = x2 * xScale + minX;
    positions[3 * i3 + 1] = -y2 * yScale + maxY;
    positions[3 * i3 + 2] = terrain[pixelIdx];
    texCoords[2 * i3 + 0] = x2 / width;
    texCoords[2 * i3 + 1] = y2 / height;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/utils/version.js
var VERSION8 = true ? "4.2.0-beta.2" : "latest";

// node_modules/@loaders.gl/terrain/dist/terrain-loader.js
var TerrainLoader = {
  dataType: null,
  batchType: null,
  name: "Terrain",
  id: "terrain",
  module: "terrain",
  version: VERSION8,
  worker: true,
  extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
  mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
  options: {
    terrain: {
      tesselator: "auto",
      bounds: void 0,
      meshMaxError: 10,
      elevationDecoder: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      },
      skirtHeight: void 0
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/quantized-mesh-loader.js
var QuantizedMeshLoader = {
  dataType: null,
  // Mesh,
  batchType: null,
  name: "Quantized Mesh",
  id: "quantized-mesh",
  module: "terrain",
  version: VERSION8,
  worker: true,
  extensions: ["terrain"],
  mimeTypes: ["application/vnd.quantized-mesh"],
  options: {
    "quantized-mesh": {
      bounds: [0, 0, 1, 1],
      skirtHeight: null
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/index.js
var TerrainLoader2 = {
  ...TerrainLoader,
  parse: parseTerrain
};
async function parseTerrain(arrayBuffer, options, context) {
  const loadImageOptions = {
    ...options,
    mimeType: "application/x.image",
    image: { ...options == null ? void 0 : options.image, type: "data" }
  };
  const image = await parseFromContext(arrayBuffer, [], loadImageOptions, context);
  const terrainOptions = { ...TerrainLoader2.options.terrain, ...options == null ? void 0 : options.terrain };
  return makeTerrainMeshFromImage(image, terrainOptions);
}
var QuantizedMeshLoader2 = {
  ...QuantizedMeshLoader,
  parseSync: (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"]),
  parse: async (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"])
};

// node_modules/@deck.gl/geo-layers/dist/terrain-layer/terrain-layer.js
var DUMMY_DATA = [1];
var defaultProps29 = {
  ...TileLayer.defaultProps,
  // Image url that encodes height data
  elevationData: urlType,
  // Image url to use as texture
  texture: { ...urlType, optional: true },
  // Martini error tolerance in meters, smaller number -> more detailed mesh
  meshMaxError: { type: "number", value: 4 },
  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates
  bounds: { type: "array", value: null, optional: true, compare: true },
  // Color to use if texture is unavailable
  color: { type: "color", value: [255, 255, 255] },
  // Object to decode height data, from (r, g, b) to height in meters
  elevationDecoder: {
    type: "object",
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.
  workerUrl: "",
  // Same as SimpleMeshLayer wireframe
  wireframe: false,
  material: true,
  loaders: [TerrainLoader]
};
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var _TerrainLayer = class _TerrainLayer extends CompositeLayer {
  updateState({ props, oldProps }) {
    const elevationDataChanged = props.elevationData !== oldProps.elevationData;
    if (elevationDataChanged) {
      const { elevationData } = props;
      const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
      this.setState({ isTiled });
    }
    const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
    if (!this.state.isTiled && shouldReload) {
      const terrain = this.loadTerrain(props);
      this.setState({ terrain });
    }
    if (props.workerUrl) {
      log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
    }
  }
  loadTerrain({ elevationData, bounds, elevationDecoder, meshMaxError, signal }) {
    if (!elevationData) {
      return null;
    }
    let loadOptions = this.getLoadOptions();
    loadOptions = {
      ...loadOptions,
      terrain: {
        skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
        ...loadOptions == null ? void 0 : loadOptions.terrain,
        bounds,
        meshMaxError,
        elevationDecoder
      }
    };
    const { fetch: fetch2 } = this.props;
    return fetch2(elevationData, { propName: "elevationData", layer: this, loadOptions, signal });
  }
  getTiledTerrainData(tile) {
    const { elevationData, fetch: fetch2, texture, elevationDecoder, meshMaxError } = this.props;
    const { viewport } = this.context;
    const dataUrl = getURLFromTemplate(elevationData, tile);
    const textureUrl = texture && getURLFromTemplate(texture, tile);
    const { signal } = tile;
    let bottomLeft = [0, 0];
    let topRight = [0, 0];
    if (viewport.isGeospatial) {
      const bbox = tile.bbox;
      bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
      topRight = viewport.projectFlat([bbox.east, bbox.north]);
    } else {
      const bbox = tile.bbox;
      bottomLeft = [bbox.left, bbox.bottom];
      topRight = [bbox.right, bbox.top];
    }
    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
    const terrain = this.loadTerrain({
      elevationData: dataUrl,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    });
    const surface = textureUrl ? (
      // If surface image fails to load, the tile should still be displayed
      fetch2(textureUrl, { propName: "texture", layer: this, loaders: [], signal }).catch((_2) => null)
    ) : Promise.resolve(null);
    return Promise.all([terrain, surface]);
  }
  renderSubLayers(props) {
    const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
    const { color, wireframe, material } = this.props;
    const { data } = props;
    if (!data) {
      return null;
    }
    const [mesh, texture] = data;
    return new SubLayerClass(props, {
      data: DUMMY_DATA,
      mesh,
      texture,
      _instanced: false,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      getPosition: (d) => [0, 0, 0],
      getColor: color,
      wireframe,
      material
    });
  }
  // Update zRange of viewport
  onViewportLoad(tiles) {
    if (!tiles) {
      return;
    }
    const { zRange } = this.state;
    const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
      const bounds = arr[0].header.boundingBox;
      return bounds.map((bound) => bound[2]);
    });
    if (ranges.length === 0) {
      return;
    }
    const minZ = Math.min(...ranges.map((x2) => x2[0]));
    const maxZ = Math.max(...ranges.map((x2) => x2[1]));
    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
      this.setState({ zRange: [minZ, maxZ] });
    }
  }
  renderLayers() {
    const { color, material, elevationData, texture, wireframe, meshMaxError, elevationDecoder, tileSize, maxZoom, minZoom, extent, maxRequests, onTileLoad, onTileUnload, onTileError, maxCacheSize, maxCacheByteSize, refinementStrategy } = this.props;
    if (this.state.isTiled) {
      return new TileLayer(this.getSubLayerProps({
        id: "tiles"
      }), {
        getTileData: this.getTiledTerrainData.bind(this),
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: {
          getTileData: {
            elevationData: urlTemplateToUpdateTrigger(elevationData),
            texture: urlTemplateToUpdateTrigger(texture),
            meshMaxError,
            elevationDecoder
          }
        },
        onViewportLoad: this.onViewportLoad.bind(this),
        zRange: this.state.zRange || null,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      });
    }
    if (!elevationData) {
      return null;
    }
    const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      data: DUMMY_DATA,
      mesh: this.state.terrain,
      texture,
      _instanced: false,
      getPosition: (d) => [0, 0, 0],
      getColor: color,
      material,
      wireframe
    });
  }
};
_TerrainLayer.defaultProps = defaultProps29;
_TerrainLayer.layerName = "TerrainLayer";
var TerrainLayer = _TerrainLayer;

// node_modules/@deck.gl/extensions/dist/brushing/shader-module.js
var vs2 = `
uniform bool brushing_enabled;
uniform int brushing_target;
uniform vec2 brushing_mousePos;
uniform float brushing_radius;
#ifdef NON_INSTANCED_MODEL
in vec2 brushingTargets;
#else
in vec2 instanceBrushingTargets;
#endif
out float brushing_isVisible;
bool brushing_isPointInRange(vec2 position) {
if (!brushing_enabled) {
return true;
}
vec2 source_commonspace = project_position(position);
vec2 target_commonspace = project_position(brushing_mousePos);
float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);
return distance <= brushing_radius;
}
bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
}
void brushing_setVisible(bool visible) {
brushing_isVisible = float(visible);
}
`;
var fs2 = `
uniform bool brushing_enabled;
in float brushing_isVisible;
`;
var TARGET = {
  source: 0,
  target: 1,
  custom: 2,
  source_target: 3
};
var inject = {
  "vs:DECKGL_FILTER_GL_POSITION": `
vec2 brushingTarget;
vec2 brushingSource;
if (brushing_target == 3) {
brushingTarget = geometry.worldPositionAlt.xy;
brushingSource = geometry.worldPosition.xy;
} else if (brushing_target == 0) {
brushingTarget = geometry.worldPosition.xy;
} else if (brushing_target == 1) {
brushingTarget = geometry.worldPositionAlt.xy;
} else {
#ifdef NON_INSTANCED_MODEL
brushingTarget = brushingTargets;
#else
brushingTarget = instanceBrushingTargets;
#endif
}
bool visible;
if (brushing_target == 3) {
visible = brushing_arePointsInRange(brushingSource, brushingTarget);
} else {
visible = brushing_isPointInRange(brushingTarget);
}
brushing_setVisible(visible);
`,
  "fs:DECKGL_FILTER_COLOR": `
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
};
var shader_module_default = {
  name: "brushing",
  dependencies: [project_default],
  vs: vs2,
  fs: fs2,
  inject,
  getUniforms: (opts) => {
    if (!opts || !("viewport" in opts)) {
      return {};
    }
    const { brushingEnabled = true, brushingRadius = 1e4, brushingTarget = "source", mousePosition, viewport } = opts;
    return {
      brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
      brushing_radius: brushingRadius,
      brushing_target: TARGET[brushingTarget] || 0,
      brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
    };
  }
};

// node_modules/@deck.gl/extensions/dist/brushing/brushing-extension.js
var defaultProps30 = {
  getBrushingTarget: { type: "accessor", value: [0, 0] },
  brushingTarget: "source",
  brushingEnabled: true,
  brushingRadius: 1e4
};
var _BrushingExtension = class _BrushingExtension extends LayerExtension {
  getShaders() {
    return {
      modules: [shader_module_default]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        brushingTargets: {
          size: 2,
          accessor: "getBrushingTarget",
          shaderAttributes: {
            brushingTargets: {
              divisor: 0
            },
            instanceBrushingTargets: {
              divisor: 1
            }
          }
        }
      });
    }
    const onMouseMove = () => {
      var _a;
      (_a = this.getCurrentLayer()) == null ? void 0 : _a.setNeedsRedraw();
    };
    this.state.onMouseMove = onMouseMove;
    if (context.deck) {
      context.deck.eventManager.on({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
  finalizeState(context, extension) {
    if (context.deck) {
      const onMouseMove = this.state.onMouseMove;
      context.deck.eventManager.off({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
};
_BrushingExtension.defaultProps = defaultProps30;
_BrushingExtension.extensionName = "BrushingExtension";
var BrushingExtension = _BrushingExtension;

// node_modules/@deck.gl/extensions/dist/data-filter/shader-module.js
var vs3 = `
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;
uniform ivec4 filter_categoryBitMask;
#ifdef NON_INSTANCED_MODEL
#define DATAFILTER_ATTRIB filterValues
#define DATAFILTER_ATTRIB_64LOW filterValues64Low
#define DATACATEGORY_ATTRIB filterCategoryValues
#else
#define DATAFILTER_ATTRIB instanceFilterValues
#define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low
#define DATACATEGORY_ATTRIB instanceFilterCategoryValues
#endif
in DATAFILTER_TYPE DATAFILTER_ATTRIB;
#ifdef DATAFILTER_DOUBLE
in DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;
uniform DATAFILTER_TYPE filter_min64High;
uniform DATAFILTER_TYPE filter_max64High;
#endif
in DATACATEGORY_TYPE DATACATEGORY_ATTRIB;
out float dataFilter_value;
float dataFilter_reduceValue(float value) {
return value;
}
float dataFilter_reduceValue(vec2 value) {
return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
return min(min(value.x, value.y), min(value.z, value.w));
}
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {
if (filter_enabled) {
if (filter_useSoftMargin) {
dataFilter_value = dataFilter_reduceValue(
smoothstep(filter_min, filter_softMin, valueFromMin) *
(1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))
);
} else {
dataFilter_value = dataFilter_reduceValue(
step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
);
}
#if DATACATEGORY_CHANNELS == 1
int dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];
#elif DATACATEGORY_CHANNELS == 2
ivec2 dataFilter_masks = ivec2(
filter_categoryBitMask[int(category.x / 32.0)],
filter_categoryBitMask[int(category.y / 32.0) + 2]
);
#elif DATACATEGORY_CHANNELS == 3
ivec3 dataFilter_masks = filter_categoryBitMask.xyz;
#else
ivec4 dataFilter_masks = filter_categoryBitMask;
#endif
DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));
dataFilter_bits = mod(floor(dataFilter_bits), 2.0);
#if DATACATEGORY_CHANNELS == 1
if(dataFilter_bits == 0.0) dataFilter_value = 0.0;
#else
if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;
#endif
} else {
dataFilter_value = 1.0;
}
}
`;
var fs3 = `
uniform bool filter_transformColor;
in float dataFilter_value;
`;
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const { filterRange = [-1, 1], filterEnabled = true, filterTransformSize = true, filterTransformColor = true } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      filter_min: filterRange[0],
      filter_softMin: filterSoftRange[0],
      filter_softMax: filterSoftRange[1],
      filter_max: filterRange[1]
    } : {
      filter_min: filterRange.map((r2) => r2[0]),
      filter_softMin: filterSoftRange.map((r2) => r2[0]),
      filter_softMax: filterSoftRange.map((r2) => r2[1]),
      filter_max: filterRange.map((r2) => r2[1])
    },
    filter_enabled: filterEnabled,
    filter_useSoftMargin: Boolean(opts.filterSoftRange),
    filter_transformSize: filterEnabled && filterTransformSize,
    filter_transformColor: filterEnabled && filterTransformColor
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.filter_min)) {
    const min64High = Math.fround(uniforms.filter_min);
    uniforms.filter_min -= min64High;
    uniforms.filter_softMin -= min64High;
    uniforms.filter_min64High = min64High;
    const max64High = Math.fround(uniforms.filter_max);
    uniforms.filter_max -= max64High;
    uniforms.filter_softMax -= max64High;
    uniforms.filter_max64High = max64High;
  } else {
    const min64High = uniforms.filter_min.map(Math.fround);
    uniforms.filter_min = uniforms.filter_min.map((x2, i3) => x2 - min64High[i3]);
    uniforms.filter_softMin = uniforms.filter_softMin.map((x2, i3) => x2 - min64High[i3]);
    uniforms.filter_min64High = min64High;
    const max64High = uniforms.filter_max.map(Math.fround);
    uniforms.filter_max = uniforms.filter_max.map((x2, i3) => x2 - max64High[i3]);
    uniforms.filter_softMax = uniforms.filter_softMax.map((x2, i3) => x2 - max64High[i3]);
    uniforms.filter_max64High = max64High;
  }
  return uniforms;
}
var inject2 = {
  "vs:#main-start": `
#ifdef DATAFILTER_DOUBLE
dataFilter_setValue(
DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,
DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,
DATACATEGORY_ATTRIB
);
#else
dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);
#endif
`,
  "vs:#main-end": `
if (dataFilter_value == 0.0) {
gl_Position = vec4(0.);
}
`,
  "vs:DECKGL_FILTER_SIZE": `
if (filter_transformSize) {
size = size * dataFilter_value;
}
`,
  "fs:DECKGL_FILTER_COLOR": `
if (dataFilter_value == 0.0) discard;
if (filter_transformColor) {
color.a *= dataFilter_value;
}
`
};
var shaderModule = {
  name: "data-filter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms
};
var shaderModule64 = {
  name: "data-filter-fp64",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms: getUniforms64
};

// node_modules/@deck.gl/extensions/dist/data-filter/aggregator.js
var AGGREGATE_VS = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
var AGGREGATE_FS = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;
var FLOAT_TARGET_FEATURES = [
  "float32-renderable-webgl",
  // ability to render to float texture
  "texture-blend-float-webgl"
  // ability to blend when rendering to float texture
];
function supportsFloatTarget(device) {
  return FLOAT_TARGET_FEATURES.every((feature2) => device.features.has(feature2));
}
function getFramebuffer(device, useFloatTarget) {
  if (useFloatTarget) {
    return device.createFramebuffer({
      width: 1,
      height: 1,
      colorAttachments: [
        device.createTexture({
          format: "rgba32float",
          type: 5126,
          mipmaps: false
        })
      ]
    });
  }
  return device.createFramebuffer({
    width: 256,
    height: 64,
    colorAttachments: [device.createTexture({ format: "rgba8unorm", type: 5126, mipmaps: false })]
  });
}
function getModel(device, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(device, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    drawMode: 0,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    ...shaderOptions
  });
}
var parameters = {
  blend: true,
  blendFunc: [1, 1, 1, 1],
  blendEquation: [32774, 32774],
  depthTest: false
};

// node_modules/@deck.gl/extensions/dist/data-filter/data-filter-extension.js
var defaultProps31 = {
  getFilterValue: { type: "accessor", value: 0 },
  getFilterCategory: { type: "accessor", value: 0 },
  onFilteredItemsChange: { type: "function", value: null, optional: true },
  filterEnabled: true,
  filterRange: [-1, 1],
  filterSoftRange: null,
  filterCategories: [0],
  filterTransformSize: true,
  filterTransformColor: true
};
var defaultOptions = {
  categorySize: 1,
  filterSize: 1,
  fp64: false,
  countItems: false
};
var DATA_TYPE_FROM_SIZE = {
  1: "float",
  2: "vec2",
  3: "vec3",
  4: "vec4"
};
var _DataFilterExtension = class _DataFilterExtension extends LayerExtension {
  constructor(opts = {}) {
    super({ ...defaultOptions, ...opts });
  }
  getShaders(extension) {
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    return {
      modules: [fp642 ? shaderModule64 : shaderModule],
      defines: {
        DATACATEGORY_TYPE: DATA_TYPE_FROM_SIZE[categorySize],
        DATACATEGORY_CHANNELS: categorySize,
        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
        DATAFILTER_DOUBLE: Boolean(fp642)
      }
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    if (attributeManager) {
      attributeManager.add({
        filterValues: {
          size: filterSize,
          type: fp642 ? "float64" : "float32",
          accessor: "getFilterValue",
          shaderAttributes: {
            filterValues: {
              divisor: 0
            },
            instanceFilterValues: {
              divisor: 1
            }
          }
        },
        filterCategoryValues: {
          size: categorySize,
          accessor: "getFilterCategory",
          transform: categorySize === 1 ? (d) => extension._getCategoryKey.call(this, d, 0) : (d) => d.map((x2, i3) => extension._getCategoryKey.call(this, x2, i3)),
          shaderAttributes: {
            filterCategoryValues: {
              divisor: 0
            },
            instanceFilterCategoryValues: {
              divisor: 1
            }
          }
        }
      });
    }
    const { device } = this.context;
    if (attributeManager && extension.opts.countItems) {
      const useFloatTarget = supportsFloatTarget(device);
      attributeManager.add({
        filterIndices: {
          size: useFloatTarget ? 1 : 2,
          vertexOffset: 1,
          type: "unorm8",
          accessor: (object, { index }) => {
            const i3 = object && object.__source ? object.__source.index : index;
            return useFloatTarget ? (i3 + 1) % 255 : [(i3 + 1) % 255, Math.floor(i3 / 255) % 255];
          },
          shaderAttributes: {
            filterPrevIndices: {
              vertexOffset: 0
            },
            filterIndices: {
              vertexOffset: 1
            }
          }
        }
      });
      const filterFBO = getFramebuffer(device, useFloatTarget);
      const filterModel = getModel(device, extension.getShaders.call(this, extension), useFloatTarget);
      this.setState({ filterFBO, filterModel });
    }
  }
  updateState({ props, oldProps, changeFlags }, extension) {
    var _a;
    const attributeManager = this.getAttributeManager();
    const { categorySize } = extension.opts;
    if (this.state.filterModel) {
      const filterNeedsUpdate = (
        // attributeManager must be defined for filterModel to be set
        attributeManager.attributes.filterValues.needsUpdate() || ((_a = attributeManager.attributes.filterCategoryValues) == null ? void 0 : _a.needsUpdate()) || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories
      );
      if (filterNeedsUpdate) {
        this.setState({ filterNeedsUpdate });
      }
    }
    if (attributeManager == null ? void 0 : attributeManager.attributes.filterCategoryValues) {
      const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual(props.filterCategories, oldProps.filterCategories, 2);
      if (categoryBitMaskNeedsUpdate) {
        this.setState({ categoryBitMaskNeedsUpdate });
      }
      const resetCategories = changeFlags.dataChanged;
      if (resetCategories) {
        this.setState({
          categoryMap: Array(categorySize).fill(0).map(() => ({}))
        });
        attributeManager.attributes.filterCategoryValues.setNeedsUpdate("categoryMap");
      }
    }
  }
  draw(params, extension) {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    const filterNeedsUpdate = this.state.filterNeedsUpdate;
    const categoryBitMaskNeedsUpdate = this.state.categoryBitMaskNeedsUpdate;
    const { onFilteredItemsChange } = this.props;
    if (categoryBitMaskNeedsUpdate) {
      extension._updateCategoryBitMask.call(this, params, extension);
    }
    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
      const { attributes: { filterValues, filterCategoryValues, filterIndices } } = this.getAttributeManager();
      filterModel.setVertexCount(this.getNumInstances());
      this.context.device.clearWebGL({ framebuffer: filterFBO, color: [0, 0, 0, 0] });
      filterModel.updateModuleSettings(params.moduleParameters);
      filterModel.setAttributes({
        ...filterValues.getValue(),
        ...filterCategoryValues == null ? void 0 : filterCategoryValues.getValue(),
        ...filterIndices == null ? void 0 : filterIndices.getValue()
      });
      filterModel.setUniforms(params.uniforms);
      filterModel.device.withParametersWebGL({
        framebuffer: filterFBO,
        // ts-ignore 'readonly' cannot be assigned to the mutable type '[GLBlendEquation, GLBlendEquation]'
        ...parameters,
        viewport: [0, 0, filterFBO.width, filterFBO.height]
      }, () => {
        filterModel.draw(this.context.renderPass);
      });
      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
      let count = 0;
      for (let i3 = 0; i3 < color.length; i3++) {
        count += color[i3];
      }
      onFilteredItemsChange({ id: this.id, count });
      this.state.filterNeedsUpdate = false;
    }
  }
  finalizeState() {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    filterFBO == null ? void 0 : filterFBO.destroy();
    filterModel == null ? void 0 : filterModel.destroy();
  }
  /**
   * Updates the bitmask used on the GPU to perform the filter based on the
   * `filterCategories` prop. The mapping between categories and bit in the bitmask
   * is performed by `_getCategoryKey()`
   */
  _updateCategoryBitMask(params, extension) {
    const { categorySize } = extension.opts;
    const { filterCategories } = this.props;
    const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
    const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;
    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
    for (let c2 = 0; c2 < categoryFilters.length; c2++) {
      const categoryFilter = categoryFilters[c2];
      for (const category of categoryFilter) {
        const key = extension._getCategoryKey.call(this, category, c2);
        if (key < maxCategories) {
          const channel = c2 * (maxCategories / 32) + Math.floor(key / 32);
          categoryBitMask[channel] += Math.pow(2, key % 32);
        } else {
          log_default.warn(`Exceeded maximum number of categories (${maxCategories})`)();
        }
      }
    }
    params.uniforms.filter_categoryBitMask = categoryBitMask;
    this.state.categoryBitMaskNeedsUpdate = false;
  }
  /**
   * Returns an index of bit in the bitmask for a given category. If the category has
   * not yet been assigned a bit, a new one is assigned.
   */
  _getCategoryKey(category, channel) {
    const categoryMap = this.state.categoryMap[channel];
    if (!(category in categoryMap)) {
      categoryMap[category] = Object.keys(categoryMap).length;
    }
    return categoryMap[category];
  }
};
_DataFilterExtension.defaultProps = defaultProps31;
_DataFilterExtension.extensionName = "DataFilterExtension";
var DataFilterExtension = _DataFilterExtension;

// node_modules/@deck.gl/extensions/dist/fp64/project64.glsl.js
var project64_glsl_default = `const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);
uniform vec2 project_uViewProjectionMatrixFP64[16];
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {
#if defined(NVIDIA_FP64_WORKAROUND)
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
out_val[1] = sum_fp64(PI_FP64,
log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
return;
}
void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
vec2 pos_fp64[2];
mercatorProject_fp64(position_fp64, pos_fp64);
out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);
return;
}
void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
vec4 position64xy = vec4(
position.x, position64xyLow.x,
position.y, position64xyLow.y);
project_position_fp64(position64xy, out_val);
}
vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
vec2 vertex_pos_clipspace[4];
mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
vertex_pos_clipspace);
return vec4(
vertex_pos_clipspace[0].x,
vertex_pos_clipspace[1].x,
vertex_pos_clipspace[2].x,
vertex_pos_clipspace[3].x
);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
vec2 offset64[4];
vec4_fp64(vec4(offset, 0.0), offset64);
float z = project_size(position.z);
vec2 projectedPosition64xy[2];
project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);
vec2 commonPosition64[4];
commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
commonPosition64[3] = vec2(1.0, 0.0);
commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);
return project_common_position_to_clipspace_fp64(commonPosition64);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset
) {
vec4 commonPosition;
return project_position_to_clipspace(
position, position64xyLow, offset, commonPosition
);
}
`;

// node_modules/@deck.gl/extensions/dist/fp64/project64.js
var { fp64ify, fp64ifyMatrix4 } = fp64;
var project64_default = {
  name: "project64",
  dependencies: [project_default, fp64],
  vs: project64_glsl_default,
  getUniforms: getUniforms2
};
var getMemoizedUniforms = memoize(calculateUniforms);
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const { viewProjectionMatrix, scale } = opts.viewport;
    return getMemoizedUniforms({ viewProjectionMatrix, scale });
  }
  return {};
}
function calculateUniforms({ viewProjectionMatrix, scale }) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}

// node_modules/@deck.gl/extensions/dist/fp64/fp64-extension.js
var _Fp64Extension = class _Fp64Extension extends LayerExtension {
  getShaders() {
    const { coordinateSystem } = this.props;
    if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
      throw new Error("fp64: coordinateSystem must be LNGLAT");
    }
    return {
      modules: [project64_default]
    };
  }
};
_Fp64Extension.extensionName = "Fp64Extension";
var Fp64Extension = _Fp64Extension;

// node_modules/@deck.gl/extensions/dist/path-style/shaders.glsl.js
var dashShaders = {
  inject: {
    "vs:#decl": `
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,
    "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
    "fs:#decl": `
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
in vec2 vDashArray;
in float vDashOffset;
`,
    // if given position is in the gap part of the dashed line
    // dashArray.x: solid stroke length, relative to width
    // dashArray.y: gap length, relative to width
    // alignMode:
    // 0 - no adjustment
    // o----     ----     ----     ---- o----     -o----     ----     o
    // 1 - stretch to fit, draw half dash at each end for nicer joints
    // o--    ----    ----    ----    --o--      --o--     ----     --o
    "fs:#main-start": `
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (capType <= 0.5) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`
  }
};
var offsetShaders = {
  inject: {
    "vs:#decl": `
in float instanceOffsets;
`,
    "vs:DECKGL_FILTER_SIZE": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,
    "vs:#main-end": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,
    "fs:#main-start": `
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`
  }
};

// node_modules/@deck.gl/extensions/dist/path-style/path-style-extension.js
var defaultProps32 = {
  getDashArray: { type: "accessor", value: [0, 0] },
  getOffset: { type: "accessor", value: 0 },
  dashJustified: false,
  dashGapPickable: false
};
var _PathStyleExtension = class _PathStyleExtension extends LayerExtension {
  constructor({ dash = false, offset = false, highPrecisionDash = false } = {}) {
    super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });
  }
  isEnabled(layer) {
    return "pathTesselator" in layer.state;
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    let result = {};
    if (extension.opts.dash) {
      result = mergeShaders(result, dashShaders);
    }
    if (extension.opts.offset) {
      result = mergeShaders(result, offsetShaders);
    }
    return result;
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager || !extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      attributeManager.addInstanced({
        instanceDashArrays: { size: 2, accessor: "getDashArray" },
        instanceDashOffsets: extension.opts.highPrecisionDash ? {
          size: 1,
          accessor: "getPath",
          transform: extension.getDashOffsets.bind(this)
        } : {
          size: 1,
          update: (attribute) => {
            attribute.constant = true;
            attribute.value = [0];
          }
        }
      });
    }
    if (extension.opts.offset) {
      attributeManager.addInstanced({
        instanceOffsets: { size: 1, accessor: "getOffset" }
      });
    }
  }
  updateState(params, extension) {
    var _a;
    if (!extension.isEnabled(this)) {
      return;
    }
    const uniforms = {};
    if (extension.opts.dash) {
      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
    }
    (_a = this.state.model) == null ? void 0 : _a.setUniforms(uniforms);
  }
  getDashOffsets(path) {
    const result = [0];
    const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
    const isNested2 = Array.isArray(path[0]);
    const geometrySize = isNested2 ? path.length : path.length / positionSize;
    let p2;
    let prevP;
    for (let i3 = 0; i3 < geometrySize - 1; i3++) {
      p2 = isNested2 ? path[i3] : path.slice(i3 * positionSize, i3 * positionSize + positionSize);
      p2 = this.projectPosition(p2);
      if (i3 > 0) {
        result[i3] = result[i3 - 1] + vec3_exports.dist(prevP, p2);
      }
      prevP = p2;
    }
    result[geometrySize - 1] = 0;
    return result;
  }
};
_PathStyleExtension.defaultProps = defaultProps32;
_PathStyleExtension.extensionName = "PathStyleExtension";
var PathStyleExtension = _PathStyleExtension;

// node_modules/@deck.gl/extensions/dist/fill-style/shader-module.js
var patternVs = `
#ifdef NON_INSTANCED_MODEL
#define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames
#define FILL_PATTERN_SCALE_ATTRIB fillPatternScales
#define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets
#else
#define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames
#define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales
#define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets
#endif
in vec4 FILL_PATTERN_FRAME_ATTRIB;
in float FILL_PATTERN_SCALE_ATTRIB;
in vec2 FILL_PATTERN_OFFSET_ATTRIB;
uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;
out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`;
var patternFs = `
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;
in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;
const float FILL_UV_SCALE = 512.0 / 40000000.0;
`;
var inject3 = {
  "vs:DECKGL_FILTER_GL_POSITION": `
fill_uv = geometry.position.xy;
`,
  "vs:DECKGL_FILTER_COLOR": `
if (fill_patternEnabled) {
fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);
fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;
fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;
}
`,
  "fs:DECKGL_FILTER_COLOR": `
if (fill_patternEnabled) {
vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);
vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;
vec4 patternColor = texture(fill_patternTexture, texCoords);
color.a *= patternColor.a;
if (!fill_patternMask) {
color.rgb = patternColor.rgb;
}
}
`
};
function getPatternUniforms(opts, uniforms) {
  if (!opts) {
    return {};
  }
  if ("fillPatternTexture" in opts) {
    const { fillPatternTexture } = opts;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if ("viewport" in opts) {
    const { fillPatternMask = true, fillPatternEnabled = true } = opts;
    const { project_uCommonOrigin: coordinateOriginCommon } = uniforms;
    const coordinateOriginCommon64Low = [
      fp64LowPart(coordinateOriginCommon[0]),
      fp64LowPart(coordinateOriginCommon[1])
    ];
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternShaders = {
  name: "fill-pattern",
  vs: patternVs,
  fs: patternFs,
  inject: inject3,
  dependencies: [project_default],
  getUniforms: getPatternUniforms
};

// node_modules/@deck.gl/extensions/dist/fill-style/fill-style-extension.js
var defaultProps33 = {
  fillPatternEnabled: true,
  fillPatternAtlas: {
    type: "image",
    value: null,
    async: true,
    parameters: { lodMaxClamp: 0 }
  },
  fillPatternMapping: { type: "object", value: {}, async: true },
  fillPatternMask: true,
  getFillPattern: { type: "accessor", value: (d) => d.pattern },
  getFillPatternScale: { type: "accessor", value: 1 },
  getFillPatternOffset: { type: "accessor", value: [0, 0] }
};
var _FillStyleExtension = class _FillStyleExtension extends LayerExtension {
  constructor({ pattern = false } = {}) {
    super({ pattern });
  }
  isEnabled(layer) {
    return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    return {
      modules: [extension.opts.pattern && patternShaders].filter(Boolean)
    };
  }
  initializeState(context, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const attributeManager = this.getAttributeManager();
    if (extension.opts.pattern) {
      attributeManager.add({
        fillPatternFrames: {
          size: 4,
          accessor: "getFillPattern",
          transform: extension.getPatternFrame.bind(this),
          shaderAttributes: {
            fillPatternFrames: {
              divisor: 0
            },
            instanceFillPatternFrames: {
              divisor: 1
            }
          }
        },
        fillPatternScales: {
          size: 1,
          accessor: "getFillPatternScale",
          defaultValue: 1,
          shaderAttributes: {
            fillPatternScales: {
              divisor: 0
            },
            instanceFillPatternScales: {
              divisor: 1
            }
          }
        },
        fillPatternOffsets: {
          size: 2,
          accessor: "getFillPatternOffset",
          shaderAttributes: {
            fillPatternOffsets: {
              divisor: 0
            },
            instanceFillPatternOffsets: {
              divisor: 1
            }
          }
        }
      });
    }
    this.setState({
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState({ props, oldProps }, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
      this.getAttributeManager().invalidate("getFillPattern");
    }
  }
  draw(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const { fillPatternAtlas } = this.props;
    this.setModuleParameters({
      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
    });
  }
  finalizeState() {
    const emptyTexture = this.state.emptyTexture;
    emptyTexture == null ? void 0 : emptyTexture.delete();
  }
  getPatternFrame(name12) {
    const { fillPatternMapping } = this.getCurrentLayer().props;
    const def = fillPatternMapping && fillPatternMapping[name12];
    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
  }
};
_FillStyleExtension.defaultProps = defaultProps33;
_FillStyleExtension.extensionName = "FillStyleExtension";
var FillStyleExtension = _FillStyleExtension;

// node_modules/@deck.gl/extensions/dist/clip/clip-extension.js
var defaultProps34 = {
  clipBounds: [0, 0, 1, 1],
  clipByInstance: void 0
};
var shaderFunction = `
uniform vec4 clip_bounds;
bool clip_isInBounds(vec2 position) {
return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`;
var shaderModuleVs = {
  name: "clip-vs",
  vs: shaderFunction
};
var injectionVs = {
  "vs:#decl": `
out float clip_isVisible;
`,
  "vs:DECKGL_FILTER_GL_POSITION": `
clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,
  "fs:#decl": `
in float clip_isVisible;
`,
  "fs:DECKGL_FILTER_COLOR": `
if (clip_isVisible < 0.5) discard;
`
};
var shaderModuleFs = {
  name: "clip-fs",
  fs: shaderFunction
};
var injectionFs = {
  "vs:#decl": `
out vec2 clip_commonPosition;
`,
  "vs:DECKGL_FILTER_GL_POSITION": `
clip_commonPosition = geometry.position.xy;
`,
  "fs:#decl": `
in vec2 clip_commonPosition;
`,
  "fs:DECKGL_FILTER_COLOR": `
if (!clip_isInBounds(clip_commonPosition)) discard;
`
};
var _ClipExtension = class _ClipExtension extends LayerExtension {
  getShaders() {
    let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.clipByInstance !== void 0) {
      clipByInstance = Boolean(this.props.clipByInstance);
    }
    this.state.clipByInstance = clipByInstance;
    return clipByInstance ? {
      modules: [shaderModuleVs],
      inject: injectionVs
    } : {
      modules: [shaderModuleFs],
      inject: injectionFs
    };
  }
  /* eslint-disable camelcase */
  draw({ uniforms }) {
    const { clipBounds } = this.props;
    if (this.state.clipByInstance) {
      uniforms.clip_bounds = clipBounds;
    } else {
      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
      uniforms.clip_bounds = [
        Math.min(corner0[0], corner1[0]),
        Math.min(corner0[1], corner1[1]),
        Math.max(corner0[0], corner1[0]),
        Math.max(corner0[1], corner1[1])
      ];
    }
  }
};
_ClipExtension.defaultProps = defaultProps34;
_ClipExtension.extensionName = "ClipExtension";
var ClipExtension = _ClipExtension;

// node_modules/@deck.gl/extensions/dist/collision-filter/shader-module.js
var vs4 = `
#ifdef NON_INSTANCED_MODEL
in float collisionPriorities;
#else
in float instanceCollisionPriorities;
#endif
uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;
vec2 collision_getCoords(vec4 position) {
vec4 collision_clipspace = project_common_position_to_clipspace(position);
return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}
float collision_match(vec2 tex, vec3 pickingColor) {
vec4 collision_pickingColor = texture(collision_texture, tex);
float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
float e = 0.001;
return step(delta, e);
}
float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
if (!collision_enabled) {
return 1.0;
}
const int N = 2;
float accumulator = 0.0;
vec2 step = vec2(1.0 / project_uViewportSize);
const float floatN = float(N);
vec2 delta = -floatN * step;
for(int i = -N; i <= N; i++) {
delta.x = -step.x * floatN;
for(int j = -N; j <= N; j++) {
accumulator += collision_match(texCoords + delta, pickingColor);
delta.x += step.x;
}
delta.y += step.y;
}
float W = 2.0 * floatN + 1.0;
return pow(accumulator / (W * W), 2.2);
}
`;
var inject4 = {
  "vs:#decl": `
float collision_fade = 1.0;
`,
  "vs:DECKGL_FILTER_GL_POSITION": `
if (collision_sort) {
#ifdef NON_INSTANCED_MODEL
float collisionPriority = collisionPriorities;
#else
float collisionPriority = instanceCollisionPriorities;
#endif
position.z = -0.001 * collisionPriority * position.w;
}
if (collision_enabled) {
vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
vec2 collision_texCoords = collision_getCoords(collision_common_position);
collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
if (collision_fade < 0.0001) {
position = vec4(0.0, 0.0, 2.0, 1.0);
}
}
`,
  "vs:DECKGL_FILTER_COLOR": `
color.a *= collision_fade;
`
};
var getCollisionUniforms = (opts, uniforms) => {
  if (!opts || !("dummyCollisionMap" in opts)) {
    return {};
  }
  const { collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
  return {
    collision_sort: Boolean(drawToCollisionMap),
    // @ts-ignore (v9 not sure why this isn't allowed now)
    collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
  };
};
var shader_module_default2 = {
  name: "collision",
  dependencies: [project_default],
  vs: vs4,
  inject: inject4,
  getUniforms: getCollisionUniforms
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-pass.js
var CollisionFilterPass = class extends LayersPass {
  renderCollisionMap(target, options) {
    const padding = 1;
    const clearColor = [0, 0, 0, 0];
    const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];
    this.render({ ...options, clearColor, scissorRect, target, pass: "collision" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return { ...layer.props.parameters, blend: false, depthRange: [0, 1], depthTest: true };
  }
  getModuleParameters() {
    return {
      drawToCollisionMap: true,
      picking: {
        isActive: 1,
        isAttribute: false
      },
      lightSources: {}
    };
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-effect.js
var DOWNSCALE = 2;
var CollisionFilterEffect = class {
  constructor() {
    this.id = "collision-filter-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 1;
    this.channels = {};
    this.collisionFBOs = {};
  }
  setup(context) {
    this.context = context;
    const { device } = context;
    this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });
    this.collisionFilterPass = new CollisionFilterPass(device, { id: "default-collision-filter" });
  }
  preRender({ effects: allEffects, layers, layerFilter, viewports, onViewportActive, views, isPicking, preRenderStats = {} }) {
    var _a;
    const { device } = this.context;
    if (isPicking) {
      return;
    }
    const collisionLayers = layers.filter(
      // @ts-ignore
      ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled
    );
    if (collisionLayers.length === 0) {
      this.channels = {};
      return;
    }
    const effects = allEffects == null ? void 0 : allEffects.filter((e2) => e2.useInPicking && preRenderStats[e2.id]);
    const maskEffectRendered = (_a = preRenderStats["mask-effect"]) == null ? void 0 : _a.didRender;
    const channels = this._groupByCollisionGroup(device, collisionLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
    for (const collisionGroup in channels) {
      const collisionFBO = this.collisionFBOs[collisionGroup];
      const renderInfo = channels[collisionGroup];
      const [width, height] = device.canvasContext.getPixelSize();
      collisionFBO.resize({
        width: width / DOWNSCALE,
        height: height / DOWNSCALE
      });
      this._render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }
  _render(renderInfo, { effects, layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    const { collisionGroup } = renderInfo;
    const oldRenderInfo = this.channels[collisionGroup];
    if (!oldRenderInfo) {
      return;
    }
    const needsRender = viewportChanged || // If render info is new
    renderInfo === oldRenderInfo || // If sublayers have changed
    !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || // If a sublayer's bounds have been updated
    renderInfo.layerBounds.some((b2, i3) => !equals(b2, oldRenderInfo.layerBounds[i3])) || // If a sublayer's isLoaded state has been updated
    renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || // Some prop is in transition
    renderInfo.layers.some((layer) => layer.props.transitions);
    this.channels[collisionGroup] = renderInfo;
    if (needsRender) {
      this.lastViewport = viewport;
      const collisionFBO = this.collisionFBOs[collisionGroup];
      this.collisionFilterPass.renderCollisionMap(collisionFBO, {
        pass: "collision-filter",
        isPicking: true,
        layers: renderInfo.layers,
        effects,
        layerFilter,
        viewports: viewport ? [viewport] : [],
        onViewportActive,
        views,
        moduleParameters: {
          // To avoid feedback loop forming between Framebuffer and active Texture.
          dummyCollisionMap: this.dummyCollisionMap,
          // @ts-expect-error TODO - assuming WebGL context
          devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
        }
      });
    }
  }
  /**
   * Group layers by collisionGroup
   * Returns a map from collisionGroup to render info
   */
  _groupByCollisionGroup(device, collisionLayers) {
    const channelMap = {};
    for (const layer of collisionLayers) {
      const { collisionGroup } = layer.props;
      let channelInfo = channelMap[collisionGroup];
      if (!channelInfo) {
        channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };
        channelMap[collisionGroup] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
      if (!layer.isLoaded) {
        channelInfo.allLayersLoaded = false;
      }
    }
    for (const collisionGroup of Object.keys(channelMap)) {
      if (!this.collisionFBOs[collisionGroup]) {
        this.createFBO(device, collisionGroup);
      }
      if (!this.channels[collisionGroup]) {
        this.channels[collisionGroup] = channelMap[collisionGroup];
      }
    }
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      if (!channelMap[collisionGroup]) {
        this.destroyFBO(collisionGroup);
      }
    }
    return channelMap;
  }
  getModuleParameters(layer) {
    const { collisionGroup } = layer.props;
    const { collisionFBOs, dummyCollisionMap } = this;
    return { collisionFBO: collisionFBOs[collisionGroup], dummyCollisionMap };
  }
  cleanup() {
    if (this.dummyCollisionMap) {
      this.dummyCollisionMap.delete();
      this.dummyCollisionMap = void 0;
    }
    this.channels = {};
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      this.destroyFBO(collisionGroup);
    }
    this.collisionFBOs = {};
    this.lastViewport = void 0;
  }
  createFBO(device, collisionGroup) {
    const { width, height } = device.gl.canvas;
    const collisionMap = device.createTexture({
      format: "rgba8unorm",
      width,
      height,
      sampler: {
        minFilter: "nearest",
        magFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    const depthStencilAttachment = device.createTexture({
      format: "depth16unorm",
      width,
      height,
      mipmaps: false,
      // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters
      dataFormat: 6402,
      // gl.DEPTH_COMPONENT
      type: 5125
      // gl.UNSIGNED_INT
    });
    this.collisionFBOs[collisionGroup] = device.createFramebuffer({
      id: `collision-${collisionGroup}`,
      width,
      height,
      colorAttachments: [collisionMap],
      depthStencilAttachment
    });
  }
  destroyFBO(collisionGroup) {
    var _a, _b;
    const fbo = this.collisionFBOs[collisionGroup];
    (_a = fbo.colorAttachments[0]) == null ? void 0 : _a.destroy();
    (_b = fbo.depthStencilAttachment) == null ? void 0 : _b.destroy();
    fbo.destroy();
    delete this.collisionFBOs[collisionGroup];
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js
var defaultProps35 = {
  getCollisionPriority: { type: "accessor", value: 0 },
  collisionEnabled: true,
  collisionGroup: { type: "string", value: "default" },
  collisionTestProps: {}
};
var _CollisionFilterExtension = class _CollisionFilterExtension extends LayerExtension {
  getShaders() {
    return { modules: [shader_module_default2] };
  }
  /* eslint-disable camelcase */
  draw({ uniforms, context, moduleParameters }) {
    const { collisionEnabled } = this.props;
    const { collisionFBO, drawToCollisionMap } = moduleParameters;
    const enabled = collisionEnabled && Boolean(collisionFBO);
    uniforms.collision_enabled = enabled;
    if (drawToCollisionMap) {
      this.props = this.clone(this.props.collisionTestProps).props;
    }
  }
  initializeState(context, extension) {
    var _a;
    if (this.getAttributeManager() === null) {
      return;
    }
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new CollisionFilterEffect());
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      collisionPriorities: {
        size: 1,
        accessor: "getCollisionPriority",
        shaderAttributes: {
          collisionPriorities: { divisor: 0 },
          instanceCollisionPriorities: { divisor: 1 }
        }
      }
    });
  }
  getNeedsPickingBuffer() {
    return this.props.collisionEnabled;
  }
};
_CollisionFilterExtension.defaultProps = defaultProps35;
_CollisionFilterExtension.extensionName = "CollisionFilterExtension";
var CollisionFilterExtension = _CollisionFilterExtension;

// node_modules/@deck.gl/extensions/dist/mask/shader-module.js
var vs5 = `
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`;
var fs4 = `
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
if (!mask_enabled) {
return true;
}
vec4 maskColor = texture(mask_texture, texCoords);
float maskValue = 1.0;
if (mask_channel == 0) {
maskValue = maskColor.r;
} else if (mask_channel == 1) {
maskValue = maskColor.g;
} else if (mask_channel == 2) {
maskValue = maskColor.b;
} else if (mask_channel == 3) {
maskValue = maskColor.a;
}
if (mask_inverted) {
return maskValue >= 0.5;
} else {
return maskValue < 0.5;
}
}
`;
var inject5 = {
  "vs:#decl": `
out vec2 mask_texCoords;
`,
  "vs:#main-end": `
vec4 mask_common_position;
if (mask_maskByInstance) {
mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
} else {
mask_common_position = geometry.position;
}
mask_texCoords = mask_getCoords(mask_common_position);
`,
  "fs:#decl": `
in vec2 mask_texCoords;
`,
  "fs:#main-start": `
if (mask_enabled) {
bool mask = mask_isInBounds(mask_texCoords);
fragColor = texture(mask_texture, mask_texCoords);
if (!mask) discard;
}
`
};
var getMaskUniforms = (opts) => {
  if (opts && "maskMap" in opts) {
    return {
      mask_texture: opts.maskMap
    };
  }
  return {};
};
var shader_module_default3 = {
  name: "mask",
  dependencies: [project_default],
  vs: vs5,
  fs: fs4,
  inject: inject5,
  getUniforms: getMaskUniforms
};

// node_modules/@deck.gl/extensions/dist/mask/mask-pass.js
var MASK_BLENDING = {
  blendColorOperation: "subtract",
  blendColorSrcFactor: "zero",
  blendColorDstFactor: "one",
  blendAlphaOperation: "subtract",
  blendAlphaSrcFactor: "zero",
  blendAlphaDstFactor: "one"
};
var MaskPass = class extends LayersPass {
  constructor(device, props) {
    super(device, props);
    const { mapSize = 2048 } = props;
    this.maskMap = device.createTexture({
      format: "rgba8unorm",
      width: mapSize,
      height: mapSize,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    this.fbo = device.createFramebuffer({
      id: "maskmap",
      width: mapSize,
      height: mapSize,
      colorAttachments: [this.maskMap]
    });
  }
  render(options) {
    const colorMask = 2 ** options.channel;
    const clearColor = [255, 255, 255, 255];
    super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: "mask" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthTest: false,
      ...MASK_BLENDING
    };
  }
  shouldDrawLayer(layer) {
    return layer.props.operation.includes("mask");
  }
  delete() {
    this.fbo.delete();
    this.maskMap.delete();
  }
};

// node_modules/@deck.gl/extensions/dist/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });
      const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
var MAX_VIEWPORT_SIZE = 2048;
function makeViewport(opts) {
  const { bounds, viewport, border = 0 } = opts;
  const { isGeospatial } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([
    (bounds[0] + bounds[2]) / 2,
    (bounds[1] + bounds[3]) / 2,
    0
  ]);
  let { width, height, zoom } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale), 20);
  } else if (!width || !height) {
    const scale = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r2 = maxSize / Math.max(width, height);
      width = Math.round(width * r2);
      height = Math.round(height * r2);
      zoom += Math.log2(r2);
    }
  }
  return isGeospatial ? new WebMercatorViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new OrthographicViewport({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    viewportBoundsWorld = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [
    viewportBottomLeftCommon[0],
    viewportBottomLeftCommon[1],
    viewportTopRightCommon[0],
    viewportTopRightCommon[1]
  ];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [
    Math.max(layerBounds[0], paddedBounds[0]),
    Math.max(layerBounds[1], paddedBounds[1]),
    Math.min(layerBounds[2], paddedBounds[2]),
    Math.min(layerBounds[3], paddedBounds[3])
  ];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}

// node_modules/@deck.gl/extensions/dist/mask/mask-effect.js
var MaskEffect = class {
  constructor() {
    this.id = "mask-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 0;
    this.channels = [];
    this.masks = null;
  }
  setup({ device }) {
    this.dummyMaskMap = device.createTexture({
      width: 1,
      height: 1
    });
    this.maskPass = new MaskPass(device, { id: "default-mask" });
    this.maskMap = this.maskPass.maskMap;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views, isPicking }) {
    let didRender = false;
    if (isPicking) {
      return { didRender };
    }
    const maskLayers = layers.filter((l2) => l2.props.visible && l2.props.operation.includes("mask"));
    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return { didRender };
    }
    this.masks = {};
    const channelMap = this._sortMaskChannels(maskLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
    if (viewport.resolution !== void 0) {
      log_default.warn("MaskExtension is not supported in GlobeView")();
      return { didRender };
    }
    for (const maskId in channelMap) {
      const result = this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
      didRender || (didRender = result);
    }
    return { didRender };
  }
  /* eslint-disable-next-line complexity */
  _renderChannel(channelInfo, { layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    let didRender = false;
    const oldChannelInfo = this.channels[channelInfo.index];
    if (!oldChannelInfo) {
      return didRender;
    }
    const maskChanged = (
      // If a channel is new
      channelInfo === oldChannelInfo || // If sublayers have changed
      channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i3) => (
        // Layer instance is updated
        // Layer props might have changed
        // Undetermined props could have an effect on the output geometry of a mask layer,
        // for example getRadius+updateTriggers, radiusScale, modelMatrix
        layer !== oldChannelInfo.layers[i3] || // Some prop is in transition
        layer.props.transitions
      )) || // If a sublayer's positions have been updated, the cached bounds will change shallowly
      channelInfo.layerBounds.some((b2, i3) => b2 !== oldChannelInfo.layerBounds[i3])
    );
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;
    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
        const { maskPass, maskMap } = this;
        const maskViewport = layerBounds && makeViewport({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height,
          border: 1
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          pass: "mask",
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            devicePixelRatio: 1
          }
        });
        didRender = true;
      }
    }
    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
    return didRender;
  }
  /**
   * Find a channel to render each mask into
   * If a maskId already exists, diff and update the existing channel
   * Otherwise replace a removed mask
   * Otherwise create a new channel
   * Returns a map from mask layer id to channel info
   */
  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;
    for (const layer of maskLayers) {
      const { id } = layer.root;
      let channelInfo = channelMap[id];
      if (!channelInfo) {
        if (++channelCount > 4) {
          log_default.warn("Too many mask layers. The max supported is 4")();
          continue;
        }
        channelInfo = {
          id,
          index: this.channels.findIndex((c2) => (c2 == null ? void 0 : c2.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }
    for (let i3 = 0; i3 < 4; i3++) {
      const channelInfo = this.channels[i3];
      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i3] = null;
      }
    }
    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];
      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex((c2) => !c2);
        this.channels[channelInfo.index] = channelInfo;
      }
    }
    return channelMap;
  }
  getModuleParameters() {
    return {
      maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
      maskChannels: this.masks
    };
  }
  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = void 0;
    }
    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = void 0;
      this.maskMap = void 0;
    }
    this.lastViewport = void 0;
    this.masks = null;
    this.channels.length = 0;
  }
};

// node_modules/@deck.gl/extensions/dist/mask/mask-extension.js
var defaultProps36 = {
  maskId: "",
  maskByInstance: void 0,
  maskInverted: false
};
var _MaskExtension = class _MaskExtension extends LayerExtension {
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new MaskEffect());
  }
  getShaders() {
    let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.maskByInstance !== void 0) {
      maskByInstance = Boolean(this.props.maskByInstance);
    }
    this.state.maskByInstance = maskByInstance;
    return {
      modules: [shader_module_default3]
    };
  }
  /* eslint-disable camelcase */
  draw({ uniforms, context, moduleParameters }) {
    uniforms.mask_maskByInstance = this.state.maskByInstance;
    const { maskId, maskInverted } = this.props;
    const { maskChannels } = moduleParameters;
    const { viewport } = context;
    if (maskChannels && maskChannels[maskId]) {
      const { index, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];
      let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];
      uniforms.mask_enabled = true;
      uniforms.mask_channel = index;
      uniforms.mask_inverted = maskInverted;
      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
      }
      const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };
      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
      uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
    } else {
      if (maskId) {
        log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
      }
      uniforms.mask_enabled = false;
    }
  }
};
_MaskExtension.defaultProps = defaultProps36;
_MaskExtension.extensionName = "MaskExtension";
var MaskExtension = _MaskExtension;

// node_modules/@deck.gl/extensions/dist/terrain/shader-module.js
var TERRAIN_MODE = {
  NONE: 0,
  /** A terrain layer rendering encoded ground elevation into the height map */
  WRITE_HEIGHT_MAP: 1,
  /** An offset layer reading encoded ground elevation from the height map */
  USE_HEIGHT_MAP: 2,
  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */
  USE_COVER: 3,
  /** A terrain layer rendering to screen, using the cover fbo as texture */
  USE_COVER_ONLY: 4,
  /** Draped layer is rendered into a texture, and never to screen */
  SKIP: 5
};
var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
var terrainModule = {
  name: "terrain",
  dependencies: [project_default],
  inject: {
    "vs:#decl": `
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
out vec3 commonPos;
` + TERRAIN_MODE_CONSTANTS,
    "vs:#main-start": `
if (terrain_mode == TERRAIN_MODE_SKIP) {
gl_Position = vec4(0.0);
return;
}
`,
    "vs:DECKGL_FILTER_GL_POSITION": `
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
vec3 anchor = geometry.worldPosition;
anchor.z = 0.0;
vec3 anchorCommon = project_position(anchor);
vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
float terrainZ = texture(terrain_map, texCoords).r;
geometry.position.z += terrainZ;
position = project_common_position_to_clipspace(geometry.position);
}
}
`,
    "fs:#decl": `
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
in vec3 commonPos;
` + TERRAIN_MODE_CONSTANTS,
    "fs:#main-start": `
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
return;
}
`,
    "fs:DECKGL_FILTER_COLOR": `
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
vec4 pixel = texture(terrain_map, texCoords);
if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
color = pixel;
} else {
color = pixel + color * (1.0 - pixel.a);
}
return;
}
`
  },
  // eslint-disable-next-line complexity
  getUniforms: (opts = {}, uniforms) => {
    var _a;
    if ("dummyHeightMap" in opts) {
      const { drawToTerrainHeightMap, heightMap, heightMapBounds, dummyHeightMap, terrainCover, useTerrainHeightMap, terrainSkipRender } = opts;
      const { project_uCommonOrigin } = uniforms;
      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
      let sampler = dummyHeightMap;
      let bounds = null;
      if (drawToTerrainHeightMap) {
        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
        bounds = heightMapBounds;
      } else if (useTerrainHeightMap && heightMap) {
        mode = TERRAIN_MODE.USE_HEIGHT_MAP;
        sampler = heightMap;
        bounds = heightMapBounds;
      } else if (terrainCover) {
        const isPicking = (_a = opts.picking) == null ? void 0 : _a.isActive;
        const fbo = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
        sampler = fbo == null ? void 0 : fbo.colorAttachments[0].texture;
        if (isPicking) {
          mode = TERRAIN_MODE.SKIP;
        }
        if (sampler) {
          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
          bounds = terrainCover.bounds;
        } else {
          sampler = dummyHeightMap;
        }
      }
      return {
        terrain_mode: mode,
        terrain_map: sampler,
        // Convert bounds to the common space, as [minX, minY, width, height]
        terrain_bounds: bounds ? [
          bounds[0] - project_uCommonOrigin[0],
          bounds[1] - project_uCommonOrigin[1],
          bounds[2] - bounds[0],
          bounds[3] - bounds[1]
        ] : [0, 0, 0, 0]
      };
    }
    return null;
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/utils.js
function createRenderTarget(device, opts) {
  return device.createFramebuffer({
    id: opts.id,
    colorAttachments: [
      device.createTexture({
        id: opts.id,
        ...opts.float && {
          format: "rgba32float",
          type: 5126
        },
        mipmaps: false,
        sampler: opts.interpolate === false ? {
          minFilter: "nearest",
          magFilter: "nearest"
        } : {
          minFilter: "linear",
          magFilter: "linear"
        }
      })
    ]
  });
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-cover.js
var TerrainCover = class {
  constructor(targetLayer) {
    this.isDirty = true;
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.targetBounds = null;
    this.targetBoundsCommon = null;
    this.targetLayer = targetLayer;
    this.tile = getTile(targetLayer);
  }
  get id() {
    return this.targetLayer.id;
  }
  /** returns true if the target layer is still in use (i.e. not finalized) */
  get isActive() {
    return Boolean(this.targetLayer.getCurrentLayer());
  }
  shouldUpdate({ targetLayer, viewport, layers, layerNeedsRedraw }) {
    if (targetLayer) {
      this.targetLayer = targetLayer;
    }
    const sizeChanged = viewport ? this._updateViewport(viewport) : false;
    let layersChanged = layers ? this._updateLayers(layers) : false;
    if (layerNeedsRedraw) {
      for (const id of this.layers) {
        if (layerNeedsRedraw[id]) {
          layersChanged = true;
          break;
        }
      }
    }
    return layersChanged || sizeChanged;
  }
  /** Compare layers with the last version. Only rerender if necessary. */
  _updateLayers(layers) {
    let needsRedraw = false;
    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
    if (layers.length !== this.layers.length) {
      needsRedraw = true;
    } else {
      for (let i3 = 0; i3 < layers.length; i3++) {
        const id = layers[i3].id;
        if (id !== this.layers[i3]) {
          needsRedraw = true;
          break;
        }
      }
    }
    if (needsRedraw) {
      this.layers = layers.map((layer) => layer.id);
    }
    return needsRedraw;
  }
  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */
  _updateViewport(viewport) {
    var _a;
    const targetLayer = this.targetLayer;
    let shouldRedraw = false;
    if (this.tile && "boundingBox" in this.tile) {
      if (!this.targetBounds) {
        shouldRedraw = true;
        this.targetBounds = this.tile.boundingBox;
        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
        this.targetBoundsCommon = [
          bottomLeftCommon[0],
          bottomLeftCommon[1],
          topRightCommon[0],
          topRightCommon[1]
        ];
      }
    } else if (this.targetBounds !== targetLayer.getBounds()) {
      shouldRedraw = true;
      this.targetBounds = targetLayer.getBounds();
      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
    }
    if (!this.targetBoundsCommon) {
      return false;
    }
    const newZoom = Math.ceil(viewport.zoom + 0.5);
    if (this.tile) {
      this.bounds = this.targetBoundsCommon;
    } else {
      const oldZoom = (_a = this.renderViewport) == null ? void 0 : _a.zoom;
      shouldRedraw = shouldRedraw || newZoom !== oldZoom;
      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
      const oldBounds = this.bounds;
      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x2, i3) => x2 !== oldBounds[i3]);
      this.bounds = newBounds;
    }
    if (shouldRedraw) {
      this.renderViewport = makeViewport({
        bounds: this.bounds,
        zoom: newZoom,
        viewport
      });
    }
    return shouldRedraw;
  }
  getRenderFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });
    }
    return this.fbo;
  }
  getPickingFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
      return null;
    }
    if (!this.pickingFbo) {
      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {
        id: `${this.id}-picking`,
        interpolate: false
      });
    }
    return this.pickingFbo;
  }
  filterLayers(layers) {
    return layers.filter(({ id }) => this.layers.includes(id));
  }
  delete() {
    const { fbo, pickingFbo } = this;
    if (fbo) {
      fbo.colorAttachments[0].destroy();
      fbo.destroy();
    }
    if (pickingFbo) {
      pickingFbo.colorAttachments[0].destroy();
      pickingFbo.destroy();
    }
  }
};
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect2(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const { tile } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect2(b1, b2) {
  if (b1 && b2) {
    return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
  }
  return false;
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-pass.js
var TERRAIN_BLENDING = {
  blendColorOperation: "max",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaOperation: "max",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one"
};
var TerrainPass = class extends LayersPass {
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
    for (let i3 = 0; i3 < layers.length; i3++) {
      const layer = layers[i3];
      if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
        result.push(layer);
      }
    }
    return result;
  }
  renderHeightMap(heightMap, opts) {
    const target = heightMap.getRenderFramebuffer();
    const viewport = heightMap.renderViewport;
    if (!target || !viewport) {
      return;
    }
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: "terrain-height-map",
      layers: opts.layers,
      viewports: [viewport],
      effects: [],
      clearColor: [0, 0, 0, 0]
    });
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getRenderFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: `terrain-cover-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      clearColor: [0, 0, 0, 0]
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthTest: false,
      ...layer.props.operation.includes("terrain") && TERRAIN_BLENDING
    };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-picking-pass.js
var TerrainPickingPass = class extends PickLayersPass {
  constructor() {
    super(...arguments);
    this.drawParameters = {};
  }
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    this.drawParameters = {};
    this._resetColorEncoder(opts.pickZ);
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
    for (let i3 = 0; i3 < layers.length; i3++) {
      const layer = layers[i3];
      if (!layer.isComposite && drawParamsByIndex[i3].shouldDrawLayer) {
        result.push(layer);
        this.drawParameters[layer.id] = drawParamsByIndex[i3].layerParameters;
      }
    }
    return result;
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getPickingFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    const terrainLayer = terrainCover.targetLayer;
    if (terrainLayer.props.pickable) {
      layers.unshift(terrainLayer);
    }
    target.resize(viewport);
    this.render({
      ...opts,
      pickingFBO: target,
      pass: `terrain-cover-picking-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,
      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`
      cullRect: void 0,
      deviceRect: viewport,
      pickZ: false
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    let parameters2;
    if (this.drawParameters[layer.id]) {
      parameters2 = this.drawParameters[layer.id];
    } else {
      parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
      parameters2.blend = true;
    }
    return { ...parameters2, depthTest: false };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/height-map-builder.js
var MAP_MAX_SIZE = 2048;
var HeightMapBuilder = class {
  static isSupported(device) {
    return device.isTextureFormatRenderable("rgba32float");
  }
  constructor(device) {
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.layersBounds = [];
    this.layersBoundsCommon = null;
    this.lastViewport = null;
    this.device = device;
  }
  /** Returns the height map framebuffer for read/write access.
   * Returns null when the texture is invalid.
   */
  getRenderFramebuffer() {
    if (!this.renderViewport) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.device, { id: "height-map", float: true });
    }
    return this.fbo;
  }
  /** Called every render cycle to check if the framebuffer needs update */
  shouldUpdate({ layers, viewport }) {
    const layersChanged = layers.length !== this.layers.length || layers.some((layer, i3) => (
      // Layer instance is updated
      // Layer props might have changed
      // Undetermined props could have an effect on the output geometry of a terrain source,
      // for example getElevation+updateTriggers, elevationScale, modelMatrix
      layer !== this.layers[i3] || // Some prop is in transition
      layer.props.transitions || // Layer's geometry bounds have changed
      layer.getBounds() !== this.layersBounds[i3]
    ));
    if (layersChanged) {
      this.layers = layers;
      this.layersBounds = layers.map((layer) => layer.getBounds());
      this.layersBoundsCommon = joinLayerBounds(layers, viewport);
    }
    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
    if (!this.layersBoundsCommon) {
      this.renderViewport = null;
    } else if (layersChanged || viewportChanged) {
      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
        this.renderViewport = null;
        return false;
      }
      this.bounds = bounds;
      this.lastViewport = viewport;
      const scale = viewport.scale;
      const pixelWidth = (bounds[2] - bounds[0]) * scale;
      const pixelHeight = (bounds[3] - bounds[1]) * scale;
      this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
        // It's not important whether the geometry is visible in this viewport, because
        // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader
        // However the viewport must have the same center and zoom as the screen viewport
        // So that projection uniforms used for calculating z are the same
        bounds: [
          viewport.center[0] - 1,
          viewport.center[1] - 1,
          viewport.center[0] + 1,
          viewport.center[1] + 1
        ],
        zoom: viewport.zoom,
        width: Math.min(pixelWidth, MAP_MAX_SIZE),
        height: Math.min(pixelHeight, MAP_MAX_SIZE),
        viewport
      }) : null;
      return true;
    }
    return false;
  }
  delete() {
    if (this.fbo) {
      this.fbo.colorAttachments[0].delete();
      this.fbo.delete();
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-effect.js
var TerrainEffect = class {
  constructor() {
    this.id = "terrain-effect";
    this.props = null;
    this.useInPicking = true;
    this.isPicking = false;
    this.isDrapingEnabled = false;
    this.terrainCovers = /* @__PURE__ */ new Map();
  }
  setup({ device, deck }) {
    this.dummyHeightMap = device.createTexture({
      width: 1,
      height: 1,
      data: new Uint8Array([0, 0, 0, 0])
    });
    this.terrainPass = new TerrainPass(device, { id: "terrain" });
    this.terrainPickingPass = new TerrainPickingPass(device, { id: "terrain-picking" });
    if (HeightMapBuilder.isSupported(device)) {
      this.heightMap = new HeightMapBuilder(device);
    } else {
      log_default.warn("Terrain offset mode is not supported by this browser")();
    }
    deck._addDefaultShaderModule(terrainModule);
  }
  preRender(opts) {
    if (opts.pickZ) {
      this.isDrapingEnabled = false;
      return;
    }
    const { viewports } = opts;
    const isPicking = opts.pass.startsWith("picking");
    this.isPicking = isPicking;
    this.isDrapingEnabled = true;
    const viewport = viewports[0];
    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
    const terrainLayers = layers.filter((l2) => l2.props.operation.includes("terrain"));
    if (terrainLayers.length === 0) {
      return;
    }
    if (!isPicking) {
      const offsetLayers = layers.filter((l2) => l2.state.terrainDrawMode === "offset");
      if (offsetLayers.length > 0) {
        this._updateHeightMap(terrainLayers, viewport, opts);
      }
    }
    const drapeLayers = layers.filter((l2) => l2.state.terrainDrawMode === "drape");
    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
  }
  getModuleParameters(layer) {
    var _a, _b, _c;
    const { terrainDrawMode } = layer.state;
    return {
      heightMap: ((_b = (_a = this.heightMap) == null ? void 0 : _a.getRenderFramebuffer()) == null ? void 0 : _b.colorAttachments[0].texture) || null,
      heightMapBounds: (_c = this.heightMap) == null ? void 0 : _c.bounds,
      dummyHeightMap: this.dummyHeightMap,
      terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
      useTerrainHeightMap: terrainDrawMode === "offset",
      terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
    };
  }
  cleanup({ deck }) {
    if (this.dummyHeightMap) {
      this.dummyHeightMap.delete();
      this.dummyHeightMap = void 0;
    }
    if (this.heightMap) {
      this.heightMap.delete();
      this.heightMap = void 0;
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.delete();
    }
    this.terrainCovers.clear();
    deck._removeDefaultShaderModule(terrainModule);
  }
  _updateHeightMap(terrainLayers, viewport, opts) {
    if (!this.heightMap) {
      return;
    }
    const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });
    if (!shouldUpdate) {
      return;
    }
    this.terrainPass.renderHeightMap(this.heightMap, {
      ...opts,
      layers: terrainLayers,
      moduleParameters: {
        heightMapBounds: this.heightMap.bounds,
        dummyHeightMap: this.dummyHeightMap,
        devicePixelRatio: 1,
        drawToTerrainHeightMap: true
      }
    });
  }
  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
    const layerNeedsRedraw = {};
    for (const layer of drapeLayers) {
      if (layer.state.terrainCoverNeedsRedraw) {
        layerNeedsRedraw[layer.id] = true;
        layer.state.terrainCoverNeedsRedraw = false;
      }
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });
    }
    for (const layer of terrainLayers) {
      this._updateTerrainCover(layer, drapeLayers, viewport, opts);
    }
    if (!this.isPicking) {
      this._pruneTerrainCovers();
    }
  }
  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
    let terrainCover = this.terrainCovers.get(terrainLayer.id);
    if (!terrainCover) {
      terrainCover = new TerrainCover(terrainLayer);
      this.terrainCovers.set(terrainLayer.id, terrainCover);
    }
    try {
      const isDirty = terrainCover.shouldUpdate({
        targetLayer: terrainLayer,
        viewport,
        layers: drapeLayers
      });
      if (this.isPicking || terrainCover.isDirty || isDirty) {
        renderPass.renderTerrainCover(terrainCover, {
          ...opts,
          layers: drapeLayers,
          moduleParameters: {
            dummyHeightMap: this.dummyHeightMap,
            terrainSkipRender: false,
            devicePixelRatio: 1
          }
        });
        if (!this.isPicking) {
          terrainCover.isDirty = false;
        }
      }
    } catch (err) {
      terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
    }
  }
  _pruneTerrainCovers() {
    const idsToRemove = [];
    for (const [id, terrainCover] of this.terrainCovers) {
      if (!terrainCover.isActive) {
        idsToRemove.push(id);
      }
    }
    for (const id of idsToRemove) {
      this.terrainCovers.delete(id);
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-extension.js
var defaultProps37 = {
  terrainDrawMode: void 0
};
var _TerrainExtension = class _TerrainExtension extends LayerExtension {
  getShaders() {
    return {
      modules: [terrainModule]
    };
  }
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new TerrainEffect());
  }
  updateState(params) {
    var _a;
    const { props, oldProps } = params;
    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && // @ts-ignore `extruded` may not exist in props
    props.extruded === oldProps.extruded) {
      return;
    }
    let { terrainDrawMode } = props;
    if (!terrainDrawMode) {
      const is3d = this.props.extruded;
      const attributes = (_a = this.getAttributeManager()) == null ? void 0 : _a.attributes;
      const hasAnchor = attributes && "instancePositions" in attributes;
      terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
    }
    this.setState({ terrainDrawMode });
  }
  onNeedsRedraw() {
    const state = this.state;
    if (state.terrainDrawMode === "drape") {
      state.terrainCoverNeedsRedraw = true;
    }
  }
};
_TerrainExtension.defaultProps = defaultProps37;
_TerrainExtension.extensionName = "TerrainExtension";
var TerrainExtension = _TerrainExtension;

// node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
function flatGeojsonToBinary(features, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features) {
  const propArrayTypes = {};
  for (const feature2 of features) {
    if (feature2.properties) {
      for (const key in feature2.properties) {
        const val2 = feature2.properties[key];
        propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features, geometryInfo, options) {
  const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
  const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
  const hasGlobalId = features[0] && "id" in features[0];
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature2 of features) {
    const geometry = feature2.geometry;
    const properties = feature2.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({ id: feature2.id });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({ id: feature2.id });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({ id: feature2.id });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i3 = 0, il = geometry.indices.length; i3 < il; ++i3) {
    const start = geometry.indices[i3];
    const end = i3 === il - 1 ? geometry.data.length : geometry.indices[i3 + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l2 = 0, ll = geometry.indices.length; l2 < ll; ++l2) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l2];
    const indices = geometry.indices[l2];
    const nextIndices = geometry.indices[l2 + 1];
    for (let i3 = 0, il = indices.length; i3 < il; ++i3) {
      const start = indices[i3];
      const end = i3 === il - 1 ? (
        // last line, so either read to:
        nextIndices === void 0 ? geometry.data.length : nextIndices[0]
      ) : indices[i3 + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
  }
}
function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n2) => (n2 - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t2 = 0, tl = triangles.length; t2 < tl; ++t2) {
    polygons.triangles.push(startPosition + triangles[t2]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = { value: obj[key], size };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    shape: "binary-feature-collection",
    points: {
      ...points,
      positions: { value: points.positions, size: coordLength },
      globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
      featureIds: { value: points.featureIds, size: 1 },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: { value: lines.positions, size: coordLength },
      pathIndices: { value: lines.pathIndices, size: 1 },
      globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
      featureIds: { value: lines.featureIds, size: 1 },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: { value: polygons.positions, size: coordLength },
      polygonIndices: { value: polygons.polygonIndices, size: 1 },
      primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
      globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
      featureIds: { value: polygons.featureIds, size: 1 },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
    // triangles not expected
  };
  if (binaryFeatures.polygons && polygons.triangles) {
    binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length2) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length2);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x2, constructor) {
  if (constructor === Array || !Number.isFinite(x2)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x2) !== x2 ? Float64Array : Float32Array;
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
function binaryToGeojson(data, options) {
  const globalFeatureId = options == null ? void 0 : options.globalFeatureId;
  if (globalFeatureId !== void 0) {
    return getSingleFeature(data, globalFeatureId);
  }
  return parseFeatures(data, options == null ? void 0 : options.type);
}
function getSingleFeature(data, globalFeatureId) {
  const dataArray = normalizeInput(data);
  for (const data2 of dataArray) {
    let lastIndex = 0;
    let lastValue = data2.featureIds.value[0];
    for (let i3 = 0; i3 < data2.featureIds.value.length; i3++) {
      const currValue = data2.featureIds.value[i3];
      if (currValue === lastValue) {
        continue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, i3);
      }
      lastIndex = i3;
      lastValue = currValue;
    }
    if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
      return parseFeature(data2, lastIndex, data2.featureIds.value.length);
    }
  }
  throw new Error(`featureId:${globalFeatureId} not found`);
}
function parseFeatures(data, type) {
  const dataArray = normalizeInput(data, type);
  return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case "Point":
      return pointToGeoJson(data, startIndex, endIndex);
    case "LineString":
      return lineStringToGeoJson(data, startIndex, endIndex);
    case "Polygon":
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      const unexpectedInput = data;
      throw new Error(`Unsupported geometry type: ${unexpectedInput == null ? void 0 : unexpectedInput.type}`);
  }
}
function normalizeInput(data, type) {
  const features = [];
  if (data.points) {
    data.points.type = "Point";
    features.push(data.points);
  }
  if (data.lines) {
    data.lines.type = "LineString";
    features.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = "Polygon";
    features.push(data.polygons);
  }
  return features;
}
function parseFeatureCollection(dataArray) {
  const features = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];
    for (let i3 = 0; i3 < data.featureIds.value.length; i3++) {
      const currValue = data.featureIds.value[i3];
      if (currValue === lastValue) {
        continue;
      }
      features.push(parseFeature(data, lastIndex, i3));
      lastIndex = i3;
      lastValue = currValue;
    }
    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features;
}
function parseFeature(data, startIndex, endIndex) {
  const geometry = binaryToGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  const fields = parseFields(data, startIndex, endIndex);
  return { type: "Feature", geometry, properties, ...fields };
}
function parseFields(data, startIndex = 0, endIndex) {
  return data.fields && data.fields[data.featureIds.value[startIndex]];
}
function parseProperties(data, startIndex = 0, endIndex) {
  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}
function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const polygonIndices = data.polygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = polygonIndices.length > 2;
  if (!multi) {
    const coordinates2 = [];
    for (let i3 = 0; i3 < primitivePolygonIndices.length - 1; i3++) {
      const startRingIndex = primitivePolygonIndices[i3];
      const endRingIndex = primitivePolygonIndices[i3 + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates2.push(ringCoordinates);
    }
    return { type: "Polygon", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i3 = 0; i3 < polygonIndices.length - 1; i3++) {
    const startPolygonIndex = polygonIndices[i3];
    const endPolygonIndex = polygonIndices[i3 + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
    coordinates.push(polygonCoordinates);
  }
  return { type: "MultiPolygon", coordinates };
}
function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const pathIndices = data.pathIndices.value.filter((x2) => x2 >= startIndex && x2 <= endIndex);
  const multi = pathIndices.length > 2;
  if (!multi) {
    const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return { type: "LineString", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i3 = 0; i3 < pathIndices.length - 1; i3++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i3], pathIndices[i3 + 1]);
    coordinates.push(ringCoordinates);
  }
  return { type: "MultiLineString", coordinates };
}
function pointToGeoJson(data, startIndex, endIndex) {
  const { positions } = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;
  if (multi) {
    return { type: "MultiPoint", coordinates };
  }
  return { type: "Point", coordinates: coordinates[0] };
}
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    const coord = Array();
    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
      coord.push(Number(positions.value[k]));
    }
    ringCoordinates.push(coord);
  }
  return ringCoordinates;
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
var import_pbf = __toESM(require_pbf(), 1);

// node_modules/@loaders.gl/mvt/dist/helpers/mapbox-util-functions.js
function classifyRings(rings) {
  const len = rings.length;
  if (len <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i3 = 0; i3 < len; i3++) {
    const area2 = signedArea(rings[i3]);
    if (area2 === 0)
      continue;
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i3]];
    } else if (polygon)
      polygon.push(rings[i3]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function signedArea(ring) {
  let sum = 0;
  for (let i3 = 0, j = ring.length - 1, p1, p2; i3 < ring.length; j = i3++) {
    p1 = ring[i3];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function readFeature(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-feature.js
var VectorTileFeature = class _VectorTileFeature {
  constructor(pbf, end, extent, keys, values) {
    __publicField(this, "properties");
    __publicField(this, "extent");
    __publicField(this, "type");
    __publicField(this, "id");
    __publicField(this, "_pbf");
    __publicField(this, "_geometry");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    pbf.readFields(readFeature, this, end);
  }
  static get types() {
    return ["Unknown", "Point", "LineString", "Polygon"];
  }
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    const lines = [];
    let line;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (cmd2 === 1) {
          if (line)
            lines.push(line);
          line = [];
        }
        if (line)
          line.push([x2, y2]);
      } else if (cmd2 === 7) {
        if (line) {
          line.push(line[0].slice());
        }
      } else {
        throw new Error(`unknown command ${cmd2}`);
      }
    }
    if (line)
      lines.push(line);
    return lines;
  }
  // eslint-disable-next-line max-statements
  bbox() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd2 = 1;
    let length2 = 0;
    let x2 = 0;
    let y2 = 0;
    let x1 = Infinity;
    let x22 = -Infinity;
    let y1 = Infinity;
    let y22 = -Infinity;
    while (pbf.pos < end) {
      if (length2 <= 0) {
        const cmdLen2 = pbf.readVarint();
        cmd2 = cmdLen2 & 7;
        length2 = cmdLen2 >> 3;
      }
      length2--;
      if (cmd2 === 1 || cmd2 === 2) {
        x2 += pbf.readSVarint();
        y2 += pbf.readSVarint();
        if (x2 < x1)
          x1 = x2;
        if (x2 > x22)
          x22 = x2;
        if (y2 < y1)
          y1 = y2;
        if (y2 > y22)
          y22 = y2;
      } else if (cmd2 !== 7) {
        throw new Error(`unknown command ${cmd2}`);
      }
    }
    return [x1, y1, x22, y22];
  }
  _toGeoJSON(transform2) {
    let coords = this.loadGeometry();
    let type = _VectorTileFeature.types[this.type];
    let i3;
    let j;
    switch (this.type) {
      case 1:
        const points = [];
        for (i3 = 0; i3 < coords.length; i3++) {
          points[i3] = coords[i3][0];
        }
        coords = points;
        transform2(coords, this);
        break;
      case 2:
        for (i3 = 0; i3 < coords.length; i3++) {
          transform2(coords[i3], this);
        }
        break;
      case 3:
        coords = classifyRings(coords);
        for (i3 = 0; i3 < coords.length; i3++) {
          for (j = 0; j < coords[i3].length; j++) {
            transform2(coords[i3][j], this);
          }
        }
        break;
    }
    if (coords.length === 1) {
      coords = coords[0];
    } else {
      type = `Multi${type}`;
    }
    const result = {
      type: "Feature",
      geometry: {
        type,
        coordinates: coords
      },
      properties: this.properties
    };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toGeoJSON(options) {
    if (typeof options === "function") {
      return this._toGeoJSON(options);
    }
    const { x: x2, y: y2, z } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    function project2(line) {
      for (let j = 0; j < line.length; j++) {
        const p2 = line[j];
        p2[0] = (p2[0] + x0) * 360 / size - 180;
        const y22 = 180 - (p2[1] + y0) * 360 / size;
        p2[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
      }
    }
    return this._toGeoJSON(project2);
  }
};

// node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-layer.js
var VectorTileLayer = class {
  constructor(pbf, end) {
    __publicField(this, "version");
    __publicField(this, "name");
    __publicField(this, "extent");
    __publicField(this, "length");
    __publicField(this, "_pbf");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_features");
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `VectorTileFeature`
   * @param index
   * @returns feature
   */
  feature(i3) {
    if (i3 < 0 || i3 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i3];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  }
};
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile.js
var VectorTile = class {
  constructor(pbf, end) {
    __publicField(this, "layers");
    this.layers = pbf.readFields(readTile, {}, end);
  }
};
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/helpers/binary-util-functions.js
function classifyRings2(geom) {
  const len = geom.indices.length;
  const type = "Polygon";
  if (len <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[getPolygonSignedArea(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i3 = 0, startIndex; i3 < len; i3++) {
    startIndex = geom.indices[i3] - offset;
    endIndex = geom.indices[i3 + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area2 = getPolygonSignedArea(shape);
    if (area2 === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area2 < 0;
    if (ccw === area2 < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area2];
    } else {
      ringAreas.push(area2);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return { type, areas, indices: polygons, data: geom.data };
}
function project(data, x0, y0, size) {
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function readFeature2(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag2(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag2(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-feature.js
var endPos;
var cmd;
var cmdLen;
var length;
var x;
var y;
var i2;
var BinaryVectorTileFeature = class {
  // eslint-disable-next-line max-params
  constructor(pbf, end, extent, keys, values, geometryInfo) {
    __publicField(this, "properties");
    __publicField(this, "extent");
    __publicField(this, "type");
    __publicField(this, "id");
    __publicField(this, "_pbf");
    __publicField(this, "_geometry");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_geometryInfo");
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    this._geometryInfo = geometryInfo;
    pbf.readFields(readFeature2, this, end);
  }
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    endPos = pbf.readVarint() + pbf.pos;
    cmd = 1;
    length = 0;
    x = 0;
    y = 0;
    i2 = 0;
    const indices = [];
    const data = [];
    while (pbf.pos < endPos) {
      if (length <= 0) {
        cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length = cmdLen >> 3;
      }
      length--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          indices.push(i2);
        }
        data.push(x, y);
        i2 += 2;
      } else if (cmd === 7) {
        if (i2 > 0) {
          const start = indices[indices.length - 1];
          data.push(data[start], data[start + 1]);
          i2 += 2;
        }
      } else {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return { data, indices };
  }
  /**
   *
   * @param transform
   * @returns result
   */
  _toBinaryCoordinates(transform2) {
    const geom = this.loadGeometry();
    let geometry;
    transform2(geom.data, this);
    const coordLength = 2;
    switch (this.type) {
      case 1:
        this._geometryInfo.pointFeaturesCount++;
        this._geometryInfo.pointPositionsCount += geom.indices.length;
        geometry = { type: "Point", ...geom };
        break;
      case 2:
        this._geometryInfo.lineFeaturesCount++;
        this._geometryInfo.linePathsCount += geom.indices.length;
        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
        geometry = { type: "LineString", ...geom };
        break;
      case 3:
        geometry = classifyRings2(geom);
        this._geometryInfo.polygonFeaturesCount++;
        this._geometryInfo.polygonObjectsCount += geometry.indices.length;
        for (const indices of geometry.indices) {
          this._geometryInfo.polygonRingsCount += indices.length;
        }
        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
        break;
      default:
        throw new Error(`Invalid geometry type: ${this.type}`);
    }
    const result = { type: "Feature", geometry, properties: this.properties };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  toBinaryCoordinates(options) {
    if (typeof options === "function") {
      return this._toBinaryCoordinates(options);
    }
    const { x: x2, y: y2, z } = options;
    const size = this.extent * Math.pow(2, z);
    const x0 = this.extent * x2;
    const y0 = this.extent * y2;
    return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
  }
};

// node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-layer.js
var BinaryVectorTileLayer = class {
  constructor(pbf, end) {
    __publicField(this, "version");
    __publicField(this, "name");
    __publicField(this, "extent");
    __publicField(this, "length");
    __publicField(this, "_pbf");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_features");
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer2, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `BinaryVectorTileFeature`
   *
   * @param index
   * @param geometryInfo
   * @returns {BinaryVectorTileFeature}
   */
  feature(i3, geometryInfo) {
    if (i3 < 0 || i3 >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i3];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new BinaryVectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
  }
};
function readLayer2(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage2(pbf));
  }
}
function readValueMessage2(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile.js
var BinaryVectorTile = class {
  constructor(pbf, end) {
    __publicField(this, "layers");
    this.layers = pbf.readFields(readTile2, {}, end);
  }
};
function readTile2(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new BinaryVectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _a, _b;
  const mvtOptions = normalizeOptions(options);
  const shape = ((_a = options == null ? void 0 : options.gis) == null ? void 0 : _a.format) || ((_b = options == null ? void 0 : options.mvt) == null ? void 0 : _b.shape) || (options == null ? void 0 : options.shape);
  switch (shape) {
    case "columnar-table":
      return { shape: "columnar-table", data: parseToBinary(arrayBuffer, mvtOptions) };
    case "geojson-table": {
      const table = {
        shape: "geojson-table",
        type: "FeatureCollection",
        features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape || "undefined shape");
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features, geometryInfo];
  }
  const tile = new BinaryVectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
      const vectorTileFeature = vectorTileLayer.feature(i3, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return [features, geometryInfo];
}
function parseToGeojsonFeatures(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i3 = 0; i3 < vectorTileLayer.length; i3++) {
      const vectorTileFeature = vectorTileLayer.feature(i3);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features.push(decodedFeature);
    }
  });
  return features;
}
function normalizeOptions(options) {
  var _a;
  if (!(options == null ? void 0 : options.mvt)) {
    throw new Error("mvt options required");
  }
  const wgs84Coordinates = ((_a = options.mvt) == null ? void 0 : _a.coordinates) === "wgs84";
  const { tileIndex } = options.mvt;
  const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
  if (wgs84Coordinates && !hasTileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  return options.mvt;
}
function getDecodedFeature(feature2, options, layerName) {
  const decodedFeature = feature2.toGeoJSON(
    // @ts-expect-error What is going on here?
    options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates
  );
  if (options.layerProperty) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature2, options, layerName) {
  const decodedFeature = feature2.toBinaryCoordinates(
    // @ts-expect-error
    options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary
  );
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function transformToLocalCoordinates(line, feature2) {
  const { extent } = feature2;
  for (let i3 = 0; i3 < line.length; i3++) {
    const p2 = line[i3];
    p2[0] /= extent;
    p2[1] /= extent;
  }
}
function transformToLocalCoordinatesBinary(data, feature2) {
  const { extent } = feature2;
  for (let i3 = 0, il = data.length; i3 < il; ++i3) {
    data[i3] /= extent;
  }
}

// node_modules/@loaders.gl/mvt/dist/mvt-loader.js
var VERSION9 = true ? "4.2.0-beta.2" : "latest";
var MVTWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: VERSION9,
  // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
  extensions: ["mvt", "pbf"],
  mimeTypes: [
    // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
    "application/vnd.mapbox-vector-tile",
    "application/x-protobuf"
    // 'application/octet-stream'
  ],
  worker: true,
  category: "geometry",
  options: {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: null
    }
  }
};
var MVTLoader = {
  ...MVTWorkerLoader,
  parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
  parseSync: parseMVT,
  binary: true
};

// node_modules/@loaders.gl/mvt/dist/mvt-source.js
var xRegex = new RegExp("{x}", "g");
var yRegex = new RegExp("{y}", "g");
var zRegex = new RegExp("{z}", "g");

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/coordinate-transform.js
var availableTransformations = {
  Point,
  MultiPoint,
  LineString,
  MultiLineString,
  Polygon: Polygon2,
  MultiPolygon
};
function Point([pointX, pointY], [nw, se], viewport) {
  const x2 = lerp(nw[0], se[0], pointX);
  const y2 = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x2, y2]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString2) => LineString(lineString2, bbox, viewport));
}
function Polygon2(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/find-index-binary.js
var GEOM_TYPES = ["points", "lines", "polygons"];
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x2, i3) => x2 === featureId && featureIds[i3] >= startFeatureIndex && featureIds[i3] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const { properties } = geomData;
    for (let i3 = 0; i3 < properties.length; i3++) {
      const { layerName: key } = properties[i3];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i3;
      } else {
        layerNames[key] = [i3, i3];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i3 = 0; i3 < featureIds.length; i3++) {
      result[featureIds[i3]] = globalFeatureIds[i3];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i3 = startIndex; i3 < endIndex; i3++) {
    if (predicate(array[i3], i3)) {
      return i3;
    }
  }
  return -1;
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js
var WORLD_SIZE = 512;
var defaultProps38 = {
  ...GeoJsonLayer.defaultProps,
  data: urlType,
  onDataLoad: { type: "function", value: null, optional: true, compare: false },
  uniqueIdProperty: "",
  highlightedFeatureId: null,
  loaders: [MVTWorkerLoader],
  binary: true
};
var _MVTLayer = class _MVTLayer extends TileLayer {
  initializeState() {
    super.initializeState();
    const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
    this.setState({
      binary,
      data: null,
      tileJSON: null,
      hoveredFeatureId: null,
      hoveredFeatureLayerName: null
    });
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.data) && super.isLoaded);
  }
  updateState({ props, oldProps, context, changeFlags }) {
    var _a;
    if (changeFlags.dataChanged) {
      this._updateTileData();
    }
    if ((_a = this.state) == null ? void 0 : _a.data) {
      super.updateState({ props, oldProps, context, changeFlags });
      this._setWGS84PropertyForTiles();
    }
    const { highlightColor } = props;
    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
      this.setState({ highlightColor });
    }
  }
  /* eslint-disable complexity */
  async _updateTileData() {
    let data = this.props.data;
    let tileJSON = null;
    if (typeof data === "string" && !isURLTemplate(data)) {
      const { onDataLoad, fetch: fetch2 } = this.props;
      this.setState({ data: null, tileJSON: null });
      try {
        tileJSON = await fetch2(data, { propName: "data", layer: this, loaders: [] });
      } catch (error) {
        this.raiseError(error, "loading TileJSON");
        data = null;
      }
      if (onDataLoad) {
        onDataLoad(tileJSON, { propName: "data", layer: this });
      }
    } else if (data && typeof data === "object" && "tilejson" in data) {
      tileJSON = data;
    }
    if (tileJSON) {
      data = tileJSON.tiles;
    }
    this.setState({ data, tileJSON });
  }
  _getTilesetOptions() {
    const opts = super._getTilesetOptions();
    const tileJSON = this.state.tileJSON;
    const { minZoom, maxZoom } = this.props;
    if (tileJSON) {
      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
        opts.minZoom = tileJSON.minzoom;
      }
      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
        opts.maxZoom = tileJSON.maxzoom;
      }
    }
    return opts;
  }
  /* eslint-disable complexity */
  renderLayers() {
    var _a;
    if (!((_a = this.state) == null ? void 0 : _a.data))
      return null;
    return super.renderLayers();
  }
  getTileData(loadProps) {
    const { data, binary } = this.state;
    const { index, signal } = loadProps;
    const url = getURLFromTemplate(data, loadProps);
    if (!url) {
      return Promise.reject("Invalid URL");
    }
    let loadOptions = this.getLoadOptions();
    const { fetch: fetch2 } = this.props;
    loadOptions = {
      ...loadOptions,
      mimeType: "application/x-protobuf",
      mvt: {
        ...loadOptions == null ? void 0 : loadOptions.mvt,
        coordinates: this.context.viewport.resolution ? "wgs84" : "local",
        tileIndex: index
        // Local worker debug
        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`
        // Set worker to null to skip web workers
        // workerUrl: null
      },
      gis: binary ? { format: "binary" } : {}
    };
    return fetch2(url, { propName: "data", layer: this, loadOptions, signal });
  }
  renderSubLayers(props) {
    const { x: x2, y: y2, z } = props.tile.index;
    const worldScale = Math.pow(2, z);
    const xScale = WORLD_SIZE / worldScale;
    const yScale = -xScale;
    const xOffset = WORLD_SIZE * x2 / worldScale;
    const yOffset = WORLD_SIZE * (1 - y2 / worldScale);
    const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
    props.autoHighlight = false;
    if (!this.context.viewport.resolution) {
      props.modelMatrix = modelMatrix2;
      props.coordinateOrigin = [xOffset, yOffset, 0];
      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
      props.extensions = [...props.extensions || [], new ClipExtension()];
    }
    const subLayers = super.renderSubLayers(props);
    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
      log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
    }
    return subLayers;
  }
  _updateAutoHighlight(info) {
    const { uniqueIdProperty } = this.props;
    const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
    const hoveredFeature = info.object;
    let newHoveredFeatureId = null;
    let newHoveredFeatureLayerName = null;
    if (hoveredFeature) {
      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
    }
    let { highlightColor } = this.props;
    if (typeof highlightColor === "function") {
      highlightColor = highlightColor(info);
    }
    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
      this.setState({
        highlightColor,
        hoveredFeatureId: newHoveredFeatureId,
        hoveredFeatureLayerName: newHoveredFeatureLayerName
      });
    }
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    const isWGS842 = Boolean(this.context.viewport.resolution);
    if (this.state.binary && info.index !== -1) {
      const { data } = params.sourceLayer.props;
      info.object = binaryToGeojson(data, {
        globalFeatureId: info.index
      });
    }
    if (info.object && !isWGS842) {
      info.object = transformTileCoordsToWGS84(
        info.object,
        info.tile.bbox,
        // eslint-disable-line
        this.context.viewport
      );
    }
    return info;
  }
  getSubLayerPropsByTile(tile) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(tile) {
    const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
    const { uniqueIdProperty, highlightedFeatureId } = this.props;
    const data = tile.content;
    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
    if (!isFeatureIdPresent) {
      return -1;
    }
    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
    if (Array.isArray(data)) {
      return data.findIndex((feature2) => {
        const isMatchingId = getFeatureUniqueId(feature2, uniqueIdProperty) === featureIdToHighlight;
        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature2) === hoveredFeatureLayerName;
        return isMatchingId && isMatchingLayer;
      });
    } else if (data && binary) {
      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
    }
    return -1;
  }
  _pickObjects(maxObjects) {
    const { deck, viewport } = this.context;
    const width = viewport.width;
    const height = viewport.height;
    const x2 = viewport.x;
    const y2 = viewport.y;
    const layerIds = [this.id];
    return deck.pickObjects({ x: x2, y: y2, width, height, layerIds, maxObjects });
  }
  /** Get the rendered features in the current viewport. */
  getRenderedFeatures(maxFeatures = null) {
    const features = this._pickObjects(maxFeatures);
    const featureCache = /* @__PURE__ */ new Set();
    const renderedFeatures = [];
    for (const f2 of features) {
      const featureId = getFeatureUniqueId(f2.object, this.props.uniqueIdProperty);
      if (featureId === void 0) {
        renderedFeatures.push(f2.object);
      } else if (!featureCache.has(featureId)) {
        featureCache.add(featureId);
        renderedFeatures.push(f2.object);
      }
    }
    return renderedFeatures;
  }
  _setWGS84PropertyForTiles() {
    const propName = "dataInWGS84";
    const tileset = this.state.tileset;
    tileset.selectedTiles.forEach((tile) => {
      if (!tile.hasOwnProperty(propName)) {
        Object.defineProperty(tile, propName, {
          get: () => {
            if (!tile.content) {
              return null;
            }
            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
              return [];
            }
            const { bbox } = tile;
            if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
              tile._contentWGS84 = content.map((feature2) => transformTileCoordsToWGS84(feature2, bbox, this.context.viewport));
            }
            return tile._contentWGS84;
          }
        });
      }
    });
  }
};
_MVTLayer.layerName = "MVTLayer";
_MVTLayer.defaultProps = defaultProps38;
var MVTLayer = _MVTLayer;
function getFeatureUniqueId(feature2, uniqueIdProperty) {
  if (feature2.properties && uniqueIdProperty) {
    return feature2.properties[uniqueIdProperty];
  }
  if ("id" in feature2) {
    return feature2.id;
  }
  return void 0;
}
function getFeatureLayerName(feature2) {
  var _a;
  return ((_a = feature2.properties) == null ? void 0 : _a.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature2 = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature2.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature2;
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-utils.js
var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
var BASE32_CODES_DICT = {};
for (let i3 = 0; i3 < BASE32_CODES.length; i3++) {
  BASE32_CODES_DICT[BASE32_CODES.charAt(i3)] = i3;
}
var MIN_LAT = -90;
var MAX_LAT = 90;
var MIN_LON = -180;
var MAX_LON = 180;
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i3 = 0, l2 = geohash.length; i3 < l2; i3++) {
    const code = geohash[i3].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s2, w, n2, e2] = getGeohashBounds(geohash);
  return [e2, n2, e2, s2, w, s2, w, n2, e2, n2];
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-layer.js
var defaultProps39 = {
  getGeohash: { type: "accessor", value: (d) => d.geohash }
};
var _GeohashLayer = class _GeohashLayer extends GeoCellLayer {
  indexToBounds() {
    const { data, getGeohash } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x2, objectInfo) => getGeohashPolygon(getGeohash(x2, objectInfo))
    };
  }
};
_GeohashLayer.layerName = "GeohashLayer";
_GeohashLayer.defaultProps = defaultProps39;
var GeohashLayer = _GeohashLayer;
export {
  GeohashLayer,
  GreatCircleLayer,
  H3ClusterLayer,
  H3HexagonLayer,
  MVTLayer,
  QuadkeyLayer,
  S2Layer,
  TerrainLayer,
  Tile3DLayer,
  TileLayer,
  TripsLayer,
  GeoCellLayer as _GeoCellLayer,
  Tile2DHeader as _Tile2DHeader,
  Tileset2D as _Tileset2D,
  WMSLayer as _WMSLayer,
  getURLFromTemplate as _getURLFromTemplate
};
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@deck__gl_geo-layers.js.map
