(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name13 in all)
      __defProp(target, name13, { get: all[name13], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../../node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "../../node_modules/hammerjs/hammer.js"(exports, module) {
      (function(window2, document2, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round6 = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator, context) {
          var i5;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined2) {
            i5 = 0;
            while (i5 < obj.length) {
              iterator.call(context, obj[i5], i5, obj);
              i5++;
            }
          } else {
            for (i5 in obj) {
              obj.hasOwnProperty(i5) && iterator.call(context, obj[i5], i5, obj);
            }
          }
        }
        function deprecate(method, name13, message2) {
          var deprecationMessage = "DEPRECATED METHOD: " + name13 + "\n" + message2 + " AT \n";
          return function() {
            var e3 = new Error("get-stack-trace");
            var stack2 = e3 && e3.stack ? e3.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log3 = window2.console && (window2.console.warn || window2.console.log);
            if (log3) {
              log3.call(window2.console, deprecationMessage, stack2);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined2 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index2 = 1; index2 < arguments.length; index2++) {
              var source = arguments[index2];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend = deprecate(function extend2(dest, src, merge2) {
          var keys = Object.keys(src);
          var i5 = 0;
          while (i5 < keys.length) {
            if (!merge2 || merge2 && dest[keys[i5]] === undefined2) {
              dest[keys[i5]] = src[keys[i5]];
            }
            i5++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src) {
          return extend(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val2, args) {
          if (typeof val2 == TYPE_FUNCTION) {
            return val2.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val2;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node2, parent) {
          while (node2) {
            if (node2 == parent) {
              return true;
            }
            node2 = node2.parentNode;
          }
          return false;
        }
        function inStr(str5, find) {
          return str5.indexOf(find) > -1;
        }
        function splitStr(str5) {
          return str5.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i5 = 0;
            while (i5 < src.length) {
              if (findByKey && src[i5][findByKey] == find || !findByKey && src[i5] === find) {
                return i5;
              }
              i5++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i5 = 0;
          while (i5 < src.length) {
            var val2 = key ? src[i5][key] : src[i5];
            if (inArray(values, val2) < 0) {
              results.push(src[i5]);
            }
            values[i5] = val2;
            i5++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a3, b2) {
                return a3[key] > b2[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i5 = 0;
          while (i5 < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i5];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i5++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window2;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window2;
        var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START2 = 1;
        var INPUT_MOVE2 = 2;
        var INPUT_END2 = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input2(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input2.prototype = {
          handler: function() {
          },
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type2;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type2 = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type2 = PointerEventInput2;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type2 = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type2 = MouseInput2;
          } else {
            Type2 = TouchMouseInput;
          }
          return new Type2(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale3(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation2(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v2 = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v2.x;
            velocityY = v2.y;
            velocity = abs(v2.x) > abs(v2.y) ? v2.x : v2.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i5 = 0;
          while (i5 < input.pointers.length) {
            pointers[i5] = {
              clientX: round6(input.pointers[i5].clientX),
              clientY: round6(input.pointers[i5].clientY)
            };
            i5++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round6(pointers[0].clientX),
              y: round6(pointers[0].clientY)
            };
          }
          var x3 = 0, y3 = 0, i5 = 0;
          while (i5 < pointersLength) {
            x3 += pointers[i5].clientX;
            y3 += pointers[i5].clientY;
            i5++;
          }
          return {
            x: round6(x3 / pointersLength),
            y: round6(y3 / pointersLength)
          };
        }
        function getVelocity(deltaTime, x3, y3) {
          return {
            x: x3 / deltaTime || 0,
            y: y3 / deltaTime || 0
          };
        }
        function getDirection(x3, y3) {
          if (x3 === y3) {
            return DIRECTION_NONE;
          }
          if (abs(x3) >= abs(y3)) {
            return x3 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y3 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p22, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x3 = p22[props[0]] - p1[props[0]], y3 = p22[props[1]] - p1[props[1]];
          return Math.sqrt(x3 * x3 + y3 * y3);
        }
        function getAngle(p1, p22, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x3 = p22[props[0]] - p1[props[0]], y3 = p22[props[1]] - p1[props[1]];
          return Math.atan2(y3, x3) * 180 / Math.PI;
        }
        function getRotation2(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        function getScale3(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP2 = {
          mousedown: INPUT_START2,
          mousemove: INPUT_MOVE2,
          mouseup: INPUT_END2
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput2() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input2.apply(this, arguments);
        }
        inherit(MouseInput2, Input2, {
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP2[ev.type];
            if (eventType & INPUT_START2 && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE2 && ev.which !== 1) {
              eventType = INPUT_END2;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END2) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START2,
          pointermove: INPUT_MOVE2,
          pointerup: INPUT_END2,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window2.MSPointerEvent && !window2.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput2() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input2.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput2, Input2, {
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input2.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input2, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START2) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input2.apply(this, arguments);
        }
        inherit(TouchInput, Input2, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i5, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START2) {
            i5 = 0;
            while (i5 < targetTouches.length) {
              targetIds[targetTouches[i5].identifier] = true;
              i5++;
            }
          }
          i5 = 0;
          while (i5 < changedTouches.length) {
            if (targetIds[changedTouches[i5].identifier]) {
              changedTargetTouches.push(changedTouches[i5]);
            }
            if (type & (INPUT_END2 | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i5].identifier];
            }
            i5++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input2.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput2(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input2, {
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START2) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i5 = lts.indexOf(lastTouch);
              if (i5 > -1) {
                lts.splice(i5, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x3 = eventData.srcEvent.clientX, y3 = eventData.srcEvent.clientY;
          for (var i5 = 0; i5 < this.lastTouches.length; i5++) {
            var t3 = this.lastTouches[i5];
            var dx = Math.abs(x3 - t3.x), dy = Math.abs(y3 - t3.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }
        TouchAction.prototype = {
          set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          },
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window2.CSS && window2.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val2) {
            touchMap[val2] = cssSupports ? window2.CSS.supports("touch-action", val2) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          defaults: {},
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index2 = inArray(this.requireFail, otherRecognizer);
            if (index2 > -1) {
              this.requireFail.splice(index2, 1);
            }
            return this;
          },
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          canEmit: function() {
            var i5 = 0;
            while (i5 < this.requireFail.length) {
              if (!(this.requireFail[i5].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i5++;
            }
            return true;
          },
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          process: function(inputData) {
          },
          getTouchAction: function() {
          },
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          defaults: {
            pointers: 1
          },
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END2) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance5 = input.distance;
            var direction = input.direction;
            var x3 = input.deltaX;
            var y3 = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x3 === 0 ? DIRECTION_NONE : x3 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x3 != this.pX;
                distance5 = Math.abs(input.deltaX);
              } else {
                direction = y3 === 0 ? DIRECTION_NONE : y3 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y3 != this.pY;
                distance5 = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance5 > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START2) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END2) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END2) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START2 && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END2) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager3(element, options);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          domEvents: false,
          touchAction: TOUCH_ACTION_COMPUTE,
          enable: true,
          inputTarget: null,
          inputClass: null,
          preset: [
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager3(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager3.prototype = {
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i5 = 0;
            while (i5 < recognizers.length) {
              recognizer = recognizers[i5];
              if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i5++;
            }
          },
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i5 = 0; i5 < recognizers.length; i5++) {
              if (recognizers[i5].options.event == recognizer) {
                return recognizers[i5];
              }
            }
            return null;
          },
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index2 = inArray(recognizers, recognizer);
              if (index2 !== -1) {
                recognizers.splice(index2, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i5 = 0;
            while (i5 < handlers.length) {
              handlers[i5](data);
              i5++;
            }
          },
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add8) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value, name13) {
            prop = prefixed(element.style, name13);
            if (add8) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add8) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
          INPUT_START: INPUT_START2,
          INPUT_MOVE: INPUT_MOVE2,
          INPUT_END: INPUT_END2,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager: Manager3,
          Input: Input2,
          TouchAction,
          TouchInput,
          MouseInput: MouseInput2,
          PointerEventInput: PointerEventInput2,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (undefined2 === "function" && define.amd) {
          define(function() {
            return Hammer;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = Hammer;
        } else {
          window2[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    }
  });

  // ../../node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../../node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut3;
      module.exports.default = earcut3;
      function earcut3(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList2(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x3, y3, invSize;
        if (hasHoles)
          outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i5 = dim; i5 < outerLen; i5 += dim) {
            x3 = data[i5];
            y3 = data[i5 + 1];
            if (x3 < minX)
              minX = x3;
            if (y3 < minY)
              minY = y3;
            if (x3 > maxX)
              maxX = x3;
            if (y3 > maxY)
              maxY = y3;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked2(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList2(data, start, end, dim, clockwise) {
        var i5, last;
        if (clockwise === signedArea2(data, start, end, dim) > 0) {
          for (i5 = start; i5 < end; i5 += dim)
            last = insertNode2(i5, data[i5], data[i5 + 1], last);
        } else {
          for (i5 = end - dim; i5 >= start; i5 -= dim)
            last = insertNode2(i5, data[i5], data[i5 + 1], last);
        }
        if (last && equals8(last, last.next)) {
          removeNode2(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints2(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p3 = start, again;
        do {
          again = false;
          if (!p3.steiner && (equals8(p3, p3.next) || area2(p3.prev, p3, p3.next) === 0)) {
            removeNode2(p3);
            p3 = end = p3.prev;
            if (p3 === p3.next)
              break;
            again = true;
          } else {
            p3 = p3.next;
          }
        } while (again || p3 !== end);
        return end;
      }
      function earcutLinked2(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve2(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode2(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
              earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut2(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar2(ear) {
        var a3 = ear.prev, b2 = ear, c2 = ear.next;
        if (area2(a3, b2, c2) >= 0)
          return false;
        var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p3 = c2.next;
        while (p3 !== a3) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.next;
        }
        return true;
      }
      function isEarHashed2(ear, minX, minY, invSize) {
        var a3 = ear.prev, b2 = ear, c2 = ear.next;
        if (area2(a3, b2, c2) >= 0)
          return false;
        var ax = a3.x, bx = b2.x, cx = c2.x, ay = a3.y, by = b2.y, cy = c2.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder2(x0, y0, minX, minY, invSize), maxZ = zOrder2(x1, y1, minX, minY, invSize);
        var p3 = ear.prevZ, n3 = ear.nextZ;
        while (p3 && p3.z >= minZ && n3 && n3.z <= maxZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
          if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area2(n3.prev, n3, n3.next) >= 0)
            return false;
          n3 = n3.nextZ;
        }
        while (p3 && p3.z >= minZ) {
          if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area2(p3.prev, p3, p3.next) >= 0)
            return false;
          p3 = p3.prevZ;
        }
        while (n3 && n3.z <= maxZ) {
          if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle2(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area2(n3.prev, n3, n3.next) >= 0)
            return false;
          n3 = n3.nextZ;
        }
        return true;
      }
      function cureLocalIntersections2(start, triangles, dim) {
        var p3 = start;
        do {
          var a3 = p3.prev, b2 = p3.next.next;
          if (!equals8(a3, b2) && intersects2(a3, p3, p3.next, b2) && locallyInside2(a3, b2) && locallyInside2(b2, a3)) {
            triangles.push(a3.i / dim | 0);
            triangles.push(p3.i / dim | 0);
            triangles.push(b2.i / dim | 0);
            removeNode2(p3);
            removeNode2(p3.next);
            p3 = start = b2;
          }
          p3 = p3.next;
        } while (p3 !== start);
        return filterPoints2(p3);
      }
      function splitEarcut2(start, triangles, dim, minX, minY, invSize) {
        var a3 = start;
        do {
          var b2 = a3.next.next;
          while (b2 !== a3.prev) {
            if (a3.i !== b2.i && isValidDiagonal2(a3, b2)) {
              var c2 = splitPolygon2(a3, b2);
              a3 = filterPoints2(a3, a3.next);
              c2 = filterPoints2(c2, c2.next);
              earcutLinked2(a3, triangles, dim, minX, minY, invSize, 0);
              earcutLinked2(c2, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b2 = b2.next;
          }
          a3 = a3.next;
        } while (a3 !== start);
      }
      function eliminateHoles2(data, holeIndices, outerNode, dim) {
        var queue = [], i5, len4, start, end, list;
        for (i5 = 0, len4 = holeIndices.length; i5 < len4; i5++) {
          start = holeIndices[i5] * dim;
          end = i5 < len4 - 1 ? holeIndices[i5 + 1] * dim : data.length;
          list = linkedList2(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost2(list));
        }
        queue.sort(compareX2);
        for (i5 = 0; i5 < queue.length; i5++) {
          outerNode = eliminateHole2(queue[i5], outerNode);
        }
        return outerNode;
      }
      function compareX2(a3, b2) {
        return a3.x - b2.x;
      }
      function eliminateHole2(hole, outerNode) {
        var bridge = findHoleBridge2(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon2(bridge, hole);
        filterPoints2(bridgeReverse, bridgeReverse.next);
        return filterPoints2(bridge, bridge.next);
      }
      function findHoleBridge2(hole, outerNode) {
        var p3 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
        do {
          if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
            var x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
            if (x3 <= hx && x3 > qx) {
              qx = x3;
              m2 = p3.x < p3.next.x ? p3 : p3.next;
              if (x3 === hx)
                return m2;
            }
          }
          p3 = p3.next;
        } while (p3 !== outerNode);
        if (!m2)
          return null;
        var stop = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
        p3 = m2;
        do {
          if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
            tan2 = Math.abs(hy - p3.y) / (hx - p3.x);
            if (locallyInside2(p3, hole) && (tan2 < tanMin || tan2 === tanMin && (p3.x > m2.x || p3.x === m2.x && sectorContainsSector2(m2, p3)))) {
              m2 = p3;
              tanMin = tan2;
            }
          }
          p3 = p3.next;
        } while (p3 !== stop);
        return m2;
      }
      function sectorContainsSector2(m2, p3) {
        return area2(m2.prev, m2, p3.prev) < 0 && area2(p3.next, m2, m2.next) < 0;
      }
      function indexCurve2(start, minX, minY, invSize) {
        var p3 = start;
        do {
          if (p3.z === 0)
            p3.z = zOrder2(p3.x, p3.y, minX, minY, invSize);
          p3.prevZ = p3.prev;
          p3.nextZ = p3.next;
          p3 = p3.next;
        } while (p3 !== start);
        p3.prevZ.nextZ = null;
        p3.prevZ = null;
        sortLinked2(p3);
      }
      function sortLinked2(list) {
        var i5, p3, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p3 = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p3) {
            numMerges++;
            q2 = p3;
            pSize = 0;
            for (i5 = 0; i5 < inSize; i5++) {
              pSize++;
              q2 = q2.nextZ;
              if (!q2)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q2) {
              if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
                e3 = p3;
                p3 = p3.nextZ;
                pSize--;
              } else {
                e3 = q2;
                q2 = q2.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e3;
              else
                list = e3;
              e3.prevZ = tail;
              tail = e3;
            }
            p3 = q2;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder2(x3, y3, minX, minY, invSize) {
        x3 = (x3 - minX) * invSize | 0;
        y3 = (y3 - minY) * invSize | 0;
        x3 = (x3 | x3 << 8) & 16711935;
        x3 = (x3 | x3 << 4) & 252645135;
        x3 = (x3 | x3 << 2) & 858993459;
        x3 = (x3 | x3 << 1) & 1431655765;
        y3 = (y3 | y3 << 8) & 16711935;
        y3 = (y3 | y3 << 4) & 252645135;
        y3 = (y3 | y3 << 2) & 858993459;
        y3 = (y3 | y3 << 1) & 1431655765;
        return x3 | y3 << 1;
      }
      function getLeftmost2(start) {
        var p3 = start, leftmost = start;
        do {
          if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
            leftmost = p3;
          p3 = p3.next;
        } while (p3 !== start);
        return leftmost;
      }
      function pointInTriangle2(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal2(a3, b2) {
        return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon2(a3, b2) && (locallyInside2(a3, b2) && locallyInside2(b2, a3) && middleInside2(a3, b2) && (area2(a3.prev, a3, b2.prev) || area2(a3, b2.prev, b2)) || equals8(a3, b2) && area2(a3.prev, a3, a3.next) > 0 && area2(b2.prev, b2, b2.next) > 0);
      }
      function area2(p3, q2, r3) {
        return (q2.y - p3.y) * (r3.x - q2.x) - (q2.x - p3.x) * (r3.y - q2.y);
      }
      function equals8(p1, p22) {
        return p1.x === p22.x && p1.y === p22.y;
      }
      function intersects2(p1, q1, p22, q2) {
        var o1 = sign2(area2(p1, q1, p22));
        var o22 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p22, q2, p1));
        var o4 = sign2(area2(p22, q2, q1));
        if (o1 !== o22 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment2(p1, p22, q1))
          return true;
        if (o22 === 0 && onSegment2(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment2(p22, p1, q2))
          return true;
        if (o4 === 0 && onSegment2(p22, q1, q2))
          return true;
        return false;
      }
      function onSegment2(p3, q2, r3) {
        return q2.x <= Math.max(p3.x, r3.x) && q2.x >= Math.min(p3.x, r3.x) && q2.y <= Math.max(p3.y, r3.y) && q2.y >= Math.min(p3.y, r3.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon2(a3, b2) {
        var p3 = a3;
        do {
          if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects2(p3, p3.next, a3, b2))
            return true;
          p3 = p3.next;
        } while (p3 !== a3);
        return false;
      }
      function locallyInside2(a3, b2) {
        return area2(a3.prev, a3, a3.next) < 0 ? area2(a3, b2, a3.next) >= 0 && area2(a3, a3.prev, b2) >= 0 : area2(a3, b2, a3.prev) < 0 || area2(a3, a3.next, b2) < 0;
      }
      function middleInside2(a3, b2) {
        var p3 = a3, inside = false, px = (a3.x + b2.x) / 2, py = (a3.y + b2.y) / 2;
        do {
          if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
            inside = !inside;
          p3 = p3.next;
        } while (p3 !== a3);
        return inside;
      }
      function splitPolygon2(a3, b2) {
        var a22 = new Node2(a3.i, a3.x, a3.y), b22 = new Node2(b2.i, b2.x, b2.y), an = a3.next, bp = b2.prev;
        a3.next = b2;
        b2.prev = a3;
        a22.next = an;
        an.prev = a22;
        b22.next = a22;
        a22.prev = b22;
        bp.next = b22;
        b22.prev = bp;
        return b22;
      }
      function insertNode2(i5, x3, y3, last) {
        var p3 = new Node2(i5, x3, y3);
        if (!last) {
          p3.prev = p3;
          p3.next = p3;
        } else {
          p3.next = last.next;
          p3.prev = last;
          last.next.prev = p3;
          last.next = p3;
        }
        return p3;
      }
      function removeNode2(p3) {
        p3.next.prev = p3.prev;
        p3.prev.next = p3.next;
        if (p3.prevZ)
          p3.prevZ.nextZ = p3.nextZ;
        if (p3.nextZ)
          p3.nextZ.prevZ = p3.prevZ;
      }
      function Node2(i5, x3, y3) {
        this.i = i5;
        this.x = x3;
        this.y = y3;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut3.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea2(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i5 = 0, len4 = holeIndices.length; i5 < len4; i5++) {
            var start = holeIndices[i5] * dim;
            var end = i5 < len4 - 1 ? holeIndices[i5 + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea2(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i5 = 0; i5 < triangles.length; i5 += 3) {
          var a3 = triangles[i5] * dim;
          var b2 = triangles[i5 + 1] * dim;
          var c2 = triangles[i5 + 2] * dim;
          trianglesArea += Math.abs(
            (data[a3] - data[c2]) * (data[b2 + 1] - data[a3 + 1]) - (data[a3] - data[b2]) * (data[c2 + 1] - data[a3 + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea2(data, start, end, dim) {
        var sum = 0;
        for (var i5 = start, j2 = end - dim; i5 < end; i5 += dim) {
          sum += (data[j2] - data[i5]) * (data[i5 + 1] + data[j2 + 1]);
          j2 = i5;
        }
        return sum;
      }
      earcut3.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i5 = 0; i5 < data.length; i5++) {
          for (var j2 = 0; j2 < data[i5].length; j2++) {
            for (var d2 = 0; d2 < dim; d2++)
              result.vertices.push(data[i5][j2][d2]);
          }
          if (i5 > 0) {
            holeIndex += data[i5 - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // ../../node_modules/fast-xml-parser/src/util.js
  var require_util = __commonJS({
    "../../node_modules/fast-xml-parser/src/util.js"(exports) {
      "use strict";
      var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
      var regexName = new RegExp("^" + nameRegexp + "$");
      var getAllMatches = function(string, regex) {
        const matches3 = [];
        let match = regex.exec(string);
        while (match) {
          const allmatches = [];
          allmatches.startIndex = regex.lastIndex - match[0].length;
          const len4 = match.length;
          for (let index2 = 0; index2 < len4; index2++) {
            allmatches.push(match[index2]);
          }
          matches3.push(allmatches);
          match = regex.exec(string);
        }
        return matches3;
      };
      var isName = function(string) {
        const match = regexName.exec(string);
        return !(match === null || typeof match === "undefined");
      };
      exports.isExist = function(v2) {
        return typeof v2 !== "undefined";
      };
      exports.isEmptyObject = function(obj) {
        return Object.keys(obj).length === 0;
      };
      exports.merge = function(target, a3, arrayMode) {
        if (a3) {
          const keys = Object.keys(a3);
          const len4 = keys.length;
          for (let i5 = 0; i5 < len4; i5++) {
            if (arrayMode === "strict") {
              target[keys[i5]] = [a3[keys[i5]]];
            } else {
              target[keys[i5]] = a3[keys[i5]];
            }
          }
        }
      };
      exports.getValue = function(v2) {
        if (exports.isExist(v2)) {
          return v2;
        } else {
          return "";
        }
      };
      exports.isName = isName;
      exports.getAllMatches = getAllMatches;
      exports.nameRegexp = nameRegexp;
    }
  });

  // ../../node_modules/fast-xml-parser/src/validator.js
  var require_validator = __commonJS({
    "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
      "use strict";
      var util = require_util();
      var defaultOptions2 = {
        allowBooleanAttributes: false,
        unpairedTags: []
      };
      exports.validate = function(xmlData, options) {
        options = Object.assign({}, defaultOptions2, options);
        const tags = [];
        let tagFound = false;
        let reachedRoot = false;
        if (xmlData[0] === "\uFEFF") {
          xmlData = xmlData.substr(1);
        }
        for (let i5 = 0; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === "<" && xmlData[i5 + 1] === "?") {
            i5 += 2;
            i5 = readPI(xmlData, i5);
            if (i5.err)
              return i5;
          } else if (xmlData[i5] === "<") {
            let tagStartPos = i5;
            i5++;
            if (xmlData[i5] === "!") {
              i5 = readCommentAndCDATA(xmlData, i5);
              continue;
            } else {
              let closingTag = false;
              if (xmlData[i5] === "/") {
                closingTag = true;
                i5++;
              }
              let tagName = "";
              for (; i5 < xmlData.length && xmlData[i5] !== ">" && xmlData[i5] !== " " && xmlData[i5] !== "	" && xmlData[i5] !== "\n" && xmlData[i5] !== "\r"; i5++) {
                tagName += xmlData[i5];
              }
              tagName = tagName.trim();
              if (tagName[tagName.length - 1] === "/") {
                tagName = tagName.substring(0, tagName.length - 1);
                i5--;
              }
              if (!validateTagName(tagName)) {
                let msg;
                if (tagName.trim().length === 0) {
                  msg = "Invalid space after '<'.";
                } else {
                  msg = "Tag '" + tagName + "' is an invalid name.";
                }
                return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i5));
              }
              const result = readAttributeStr(xmlData, i5);
              if (result === false) {
                return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i5));
              }
              let attrStr = result.value;
              i5 = result.index;
              if (attrStr[attrStr.length - 1] === "/") {
                const attrStrStart = i5 - attrStr.length;
                attrStr = attrStr.substring(0, attrStr.length - 1);
                const isValid = validateAttributeString(attrStr, options);
                if (isValid === true) {
                  tagFound = true;
                } else {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
                }
              } else if (closingTag) {
                if (!result.tagClosed) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i5));
                } else if (attrStr.trim().length > 0) {
                  return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
                } else {
                  const otg = tags.pop();
                  if (tagName !== otg.tagName) {
                    let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                    return getErrorObject(
                      "InvalidTag",
                      "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                      getLineNumberForPosition(xmlData, tagStartPos)
                    );
                  }
                  if (tags.length == 0) {
                    reachedRoot = true;
                  }
                }
              } else {
                const isValid = validateAttributeString(attrStr, options);
                if (isValid !== true) {
                  return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i5 - attrStr.length + isValid.err.line));
                }
                if (reachedRoot === true) {
                  return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i5));
                } else if (options.unpairedTags.indexOf(tagName) !== -1) {
                } else {
                  tags.push({ tagName, tagStartPos });
                }
                tagFound = true;
              }
              for (i5++; i5 < xmlData.length; i5++) {
                if (xmlData[i5] === "<") {
                  if (xmlData[i5 + 1] === "!") {
                    i5++;
                    i5 = readCommentAndCDATA(xmlData, i5);
                    continue;
                  } else if (xmlData[i5 + 1] === "?") {
                    i5 = readPI(xmlData, ++i5);
                    if (i5.err)
                      return i5;
                  } else {
                    break;
                  }
                } else if (xmlData[i5] === "&") {
                  const afterAmp = validateAmpersand(xmlData, i5);
                  if (afterAmp == -1)
                    return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i5));
                  i5 = afterAmp;
                } else {
                  if (reachedRoot === true && !isWhiteSpace(xmlData[i5])) {
                    return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i5));
                  }
                }
              }
              if (xmlData[i5] === "<") {
                i5--;
              }
            }
          } else {
            if (isWhiteSpace(xmlData[i5])) {
              continue;
            }
            return getErrorObject("InvalidChar", "char '" + xmlData[i5] + "' is not expected.", getLineNumberForPosition(xmlData, i5));
          }
        }
        if (!tagFound) {
          return getErrorObject("InvalidXml", "Start tag expected.", 1);
        } else if (tags.length == 1) {
          return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
        } else if (tags.length > 0) {
          return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
        }
        return true;
      };
      function isWhiteSpace(char) {
        return char === " " || char === "	" || char === "\n" || char === "\r";
      }
      function readPI(xmlData, i5) {
        const start = i5;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] == "?" || xmlData[i5] == " ") {
            const tagname = xmlData.substr(start, i5 - start);
            if (i5 > 5 && tagname === "xml") {
              return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i5));
            } else if (xmlData[i5] == "?" && xmlData[i5 + 1] == ">") {
              i5++;
              break;
            } else {
              continue;
            }
          }
        }
        return i5;
      }
      function readCommentAndCDATA(xmlData, i5) {
        if (xmlData.length > i5 + 5 && xmlData[i5 + 1] === "-" && xmlData[i5 + 2] === "-") {
          for (i5 += 3; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "-" && xmlData[i5 + 1] === "-" && xmlData[i5 + 2] === ">") {
              i5 += 2;
              break;
            }
          }
        } else if (xmlData.length > i5 + 8 && xmlData[i5 + 1] === "D" && xmlData[i5 + 2] === "O" && xmlData[i5 + 3] === "C" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "Y" && xmlData[i5 + 6] === "P" && xmlData[i5 + 7] === "E") {
          let angleBracketsCount = 1;
          for (i5 += 8; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "<") {
              angleBracketsCount++;
            } else if (xmlData[i5] === ">") {
              angleBracketsCount--;
              if (angleBracketsCount === 0) {
                break;
              }
            }
          }
        } else if (xmlData.length > i5 + 9 && xmlData[i5 + 1] === "[" && xmlData[i5 + 2] === "C" && xmlData[i5 + 3] === "D" && xmlData[i5 + 4] === "A" && xmlData[i5 + 5] === "T" && xmlData[i5 + 6] === "A" && xmlData[i5 + 7] === "[") {
          for (i5 += 8; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "]" && xmlData[i5 + 1] === "]" && xmlData[i5 + 2] === ">") {
              i5 += 2;
              break;
            }
          }
        }
        return i5;
      }
      var doubleQuote = '"';
      var singleQuote = "'";
      function readAttributeStr(xmlData, i5) {
        let attrStr = "";
        let startChar = "";
        let tagClosed = false;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === doubleQuote || xmlData[i5] === singleQuote) {
            if (startChar === "") {
              startChar = xmlData[i5];
            } else if (startChar !== xmlData[i5]) {
            } else {
              startChar = "";
            }
          } else if (xmlData[i5] === ">") {
            if (startChar === "") {
              tagClosed = true;
              break;
            }
          }
          attrStr += xmlData[i5];
        }
        if (startChar !== "") {
          return false;
        }
        return {
          value: attrStr,
          index: i5,
          tagClosed
        };
      }
      var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function validateAttributeString(attrStr, options) {
        const matches3 = util.getAllMatches(attrStr, validAttrStrRegxp);
        const attrNames = {};
        for (let i5 = 0; i5 < matches3.length; i5++) {
          if (matches3[i5][1].length === 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i5][2] + "' has no space in starting.", getPositionFromMatch(matches3[i5]));
          } else if (matches3[i5][3] !== void 0 && matches3[i5][4] === void 0) {
            return getErrorObject("InvalidAttr", "Attribute '" + matches3[i5][2] + "' is without value.", getPositionFromMatch(matches3[i5]));
          } else if (matches3[i5][3] === void 0 && !options.allowBooleanAttributes) {
            return getErrorObject("InvalidAttr", "boolean attribute '" + matches3[i5][2] + "' is not allowed.", getPositionFromMatch(matches3[i5]));
          }
          const attrName = matches3[i5][2];
          if (!validateAttrName(attrName)) {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches3[i5]));
          }
          if (!attrNames.hasOwnProperty(attrName)) {
            attrNames[attrName] = 1;
          } else {
            return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches3[i5]));
          }
        }
        return true;
      }
      function validateNumberAmpersand(xmlData, i5) {
        let re = /\d/;
        if (xmlData[i5] === "x") {
          i5++;
          re = /[\da-fA-F]/;
        }
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === ";")
            return i5;
          if (!xmlData[i5].match(re))
            break;
        }
        return -1;
      }
      function validateAmpersand(xmlData, i5) {
        i5++;
        if (xmlData[i5] === ";")
          return -1;
        if (xmlData[i5] === "#") {
          i5++;
          return validateNumberAmpersand(xmlData, i5);
        }
        let count2 = 0;
        for (; i5 < xmlData.length; i5++, count2++) {
          if (xmlData[i5].match(/\w/) && count2 < 20)
            continue;
          if (xmlData[i5] === ";")
            break;
          return -1;
        }
        return i5;
      }
      function getErrorObject(code, message2, lineNumber) {
        return {
          err: {
            code,
            msg: message2,
            line: lineNumber.line || lineNumber,
            col: lineNumber.col
          }
        };
      }
      function validateAttrName(attrName) {
        return util.isName(attrName);
      }
      function validateTagName(tagname) {
        return util.isName(tagname);
      }
      function getLineNumberForPosition(xmlData, index2) {
        const lines = xmlData.substring(0, index2).split(/\r?\n/);
        return {
          line: lines.length,
          col: lines[lines.length - 1].length + 1
        };
      }
      function getPositionFromMatch(match) {
        return match.startIndex + match[1].length;
      }
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
  var require_OptionsBuilder = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
      var defaultOptions2 = {
        preserveOrder: false,
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        removeNSPrefix: false,
        allowBooleanAttributes: false,
        parseTagValue: true,
        parseAttributeValue: false,
        trimValues: true,
        cdataPropName: false,
        numberParseOptions: {
          hex: true,
          leadingZeros: true,
          eNotation: true
        },
        tagValueProcessor: function(tagName, val2) {
          return val2;
        },
        attributeValueProcessor: function(attrName, val2) {
          return val2;
        },
        stopNodes: [],
        alwaysCreateTextNode: false,
        isArray: () => false,
        commentPropName: false,
        unpairedTags: [],
        processEntities: true,
        htmlEntities: false,
        ignoreDeclaration: false,
        ignorePiTags: false,
        transformTagName: false,
        transformAttributeName: false,
        updateTag: function(tagName, jPath, attrs) {
          return tagName;
        }
      };
      var buildOptions = function(options) {
        return Object.assign({}, defaultOptions2, options);
      };
      exports.buildOptions = buildOptions;
      exports.defaultOptions = defaultOptions2;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
  var require_xmlNode = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
      "use strict";
      var XmlNode = class {
        constructor(tagname) {
          this.tagname = tagname;
          this.child = [];
          this[":@"] = {};
        }
        add(key, val2) {
          if (key === "__proto__")
            key = "#__proto__";
          this.child.push({ [key]: val2 });
        }
        addChild(node2) {
          if (node2.tagname === "__proto__")
            node2.tagname = "#__proto__";
          if (node2[":@"] && Object.keys(node2[":@"]).length > 0) {
            this.child.push({ [node2.tagname]: node2.child, [":@"]: node2[":@"] });
          } else {
            this.child.push({ [node2.tagname]: node2.child });
          }
        }
      };
      module.exports = XmlNode;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
  var require_DocTypeReader = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
      var util = require_util();
      function readDocType(xmlData, i5) {
        const entities = {};
        if (xmlData[i5 + 3] === "O" && xmlData[i5 + 4] === "C" && xmlData[i5 + 5] === "T" && xmlData[i5 + 6] === "Y" && xmlData[i5 + 7] === "P" && xmlData[i5 + 8] === "E") {
          i5 = i5 + 9;
          let angleBracketsCount = 1;
          let hasBody = false, comment = false;
          let exp = "";
          for (; i5 < xmlData.length; i5++) {
            if (xmlData[i5] === "<" && !comment) {
              if (hasBody && isEntity(xmlData, i5)) {
                i5 += 7;
                [entityName, val, i5] = readEntityExp(xmlData, i5 + 1);
                if (val.indexOf("&") === -1)
                  entities[validateEntityName(entityName)] = {
                    regx: RegExp(`&${entityName};`, "g"),
                    val
                  };
              } else if (hasBody && isElement(xmlData, i5))
                i5 += 8;
              else if (hasBody && isAttlist(xmlData, i5))
                i5 += 8;
              else if (hasBody && isNotation(xmlData, i5))
                i5 += 9;
              else if (isComment)
                comment = true;
              else
                throw new Error("Invalid DOCTYPE");
              angleBracketsCount++;
              exp = "";
            } else if (xmlData[i5] === ">") {
              if (comment) {
                if (xmlData[i5 - 1] === "-" && xmlData[i5 - 2] === "-") {
                  comment = false;
                  angleBracketsCount--;
                }
              } else {
                angleBracketsCount--;
              }
              if (angleBracketsCount === 0) {
                break;
              }
            } else if (xmlData[i5] === "[") {
              hasBody = true;
            } else {
              exp += xmlData[i5];
            }
          }
          if (angleBracketsCount !== 0) {
            throw new Error(`Unclosed DOCTYPE`);
          }
        } else {
          throw new Error(`Invalid Tag instead of DOCTYPE`);
        }
        return { entities, i: i5 };
      }
      function readEntityExp(xmlData, i5) {
        let entityName2 = "";
        for (; i5 < xmlData.length && (xmlData[i5] !== "'" && xmlData[i5] !== '"'); i5++) {
          entityName2 += xmlData[i5];
        }
        entityName2 = entityName2.trim();
        if (entityName2.indexOf(" ") !== -1)
          throw new Error("External entites are not supported");
        const startChar = xmlData[i5++];
        let val2 = "";
        for (; i5 < xmlData.length && xmlData[i5] !== startChar; i5++) {
          val2 += xmlData[i5];
        }
        return [entityName2, val2, i5];
      }
      function isComment(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "-" && xmlData[i5 + 3] === "-")
          return true;
        return false;
      }
      function isEntity(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "E" && xmlData[i5 + 3] === "N" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "I" && xmlData[i5 + 6] === "T" && xmlData[i5 + 7] === "Y")
          return true;
        return false;
      }
      function isElement(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "E" && xmlData[i5 + 3] === "L" && xmlData[i5 + 4] === "E" && xmlData[i5 + 5] === "M" && xmlData[i5 + 6] === "E" && xmlData[i5 + 7] === "N" && xmlData[i5 + 8] === "T")
          return true;
        return false;
      }
      function isAttlist(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "A" && xmlData[i5 + 3] === "T" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "L" && xmlData[i5 + 6] === "I" && xmlData[i5 + 7] === "S" && xmlData[i5 + 8] === "T")
          return true;
        return false;
      }
      function isNotation(xmlData, i5) {
        if (xmlData[i5 + 1] === "!" && xmlData[i5 + 2] === "N" && xmlData[i5 + 3] === "O" && xmlData[i5 + 4] === "T" && xmlData[i5 + 5] === "A" && xmlData[i5 + 6] === "T" && xmlData[i5 + 7] === "I" && xmlData[i5 + 8] === "O" && xmlData[i5 + 9] === "N")
          return true;
        return false;
      }
      function validateEntityName(name13) {
        if (util.isName(name13))
          return name13;
        else
          throw new Error(`Invalid entity name ${name13}`);
      }
      module.exports = readDocType;
    }
  });

  // ../../node_modules/strnum/strnum.js
  var require_strnum = __commonJS({
    "../../node_modules/strnum/strnum.js"(exports, module) {
      var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
      var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
      if (!Number.parseInt && window.parseInt) {
        Number.parseInt = window.parseInt;
      }
      if (!Number.parseFloat && window.parseFloat) {
        Number.parseFloat = window.parseFloat;
      }
      var consider = {
        hex: true,
        leadingZeros: true,
        decimalPoint: ".",
        eNotation: true
      };
      function toNumber2(str5, options = {}) {
        options = Object.assign({}, consider, options);
        if (!str5 || typeof str5 !== "string")
          return str5;
        let trimmedStr = str5.trim();
        if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
          return str5;
        else if (options.hex && hexRegex.test(trimmedStr)) {
          return Number.parseInt(trimmedStr, 16);
        } else {
          const match = numRegex.exec(trimmedStr);
          if (match) {
            const sign2 = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]);
            const eNotation = match[4] || match[6];
            if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
              return str5;
            else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
              return str5;
            else {
              const num = Number(trimmedStr);
              const numStr = "" + num;
              if (numStr.search(/[eE]/) !== -1) {
                if (options.eNotation)
                  return num;
                else
                  return str5;
              } else if (eNotation) {
                if (options.eNotation)
                  return num;
                else
                  return str5;
              } else if (trimmedStr.indexOf(".") !== -1) {
                if (numStr === "0" && numTrimmedByZeros === "")
                  return num;
                else if (numStr === numTrimmedByZeros)
                  return num;
                else if (sign2 && numStr === "-" + numTrimmedByZeros)
                  return num;
                else
                  return str5;
              }
              if (leadingZeros) {
                if (numTrimmedByZeros === numStr)
                  return num;
                else if (sign2 + numTrimmedByZeros === numStr)
                  return num;
                else
                  return str5;
              }
              if (trimmedStr === numStr)
                return num;
              else if (trimmedStr === sign2 + numStr)
                return num;
              return str5;
            }
          } else {
            return str5;
          }
        }
      }
      function trimZeros(numStr) {
        if (numStr && numStr.indexOf(".") !== -1) {
          numStr = numStr.replace(/0+$/, "");
          if (numStr === ".")
            numStr = "0";
          else if (numStr[0] === ".")
            numStr = "0" + numStr;
          else if (numStr[numStr.length - 1] === ".")
            numStr = numStr.substr(0, numStr.length - 1);
          return numStr;
        }
        return numStr;
      }
      module.exports = toNumber2;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
  var require_OrderedObjParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
      "use strict";
      var util = require_util();
      var xmlNode = require_xmlNode();
      var readDocType = require_DocTypeReader();
      var toNumber2 = require_strnum();
      var OrderedObjParser = class {
        constructor(options) {
          this.options = options;
          this.currentNode = null;
          this.tagsNodeStack = [];
          this.docTypeEntities = {};
          this.lastEntities = {
            "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
            "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
            "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
            "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
          };
          this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
          this.htmlEntities = {
            "space": { regex: /&(nbsp|#160);/g, val: " " },
            "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
            "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
            "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
            "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
            "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
            "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
            "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" },
            "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 10)) },
            "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 16)) }
          };
          this.addExternalEntities = addExternalEntities;
          this.parseXml = parseXml;
          this.parseTextData = parseTextData;
          this.resolveNameSpace = resolveNameSpace;
          this.buildAttributesMap = buildAttributesMap;
          this.isItStopNode = isItStopNode;
          this.replaceEntitiesValue = replaceEntitiesValue;
          this.readStopNodeData = readStopNodeData;
          this.saveTextToParentTag = saveTextToParentTag;
          this.addChild = addChild;
        }
      };
      function addExternalEntities(externalEntities) {
        const entKeys = Object.keys(externalEntities);
        for (let i5 = 0; i5 < entKeys.length; i5++) {
          const ent = entKeys[i5];
          this.lastEntities[ent] = {
            regex: new RegExp("&" + ent + ";", "g"),
            val: externalEntities[ent]
          };
        }
      }
      function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
        if (val2 !== void 0) {
          if (this.options.trimValues && !dontTrim) {
            val2 = val2.trim();
          }
          if (val2.length > 0) {
            if (!escapeEntities)
              val2 = this.replaceEntitiesValue(val2);
            const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
            if (newval === null || newval === void 0) {
              return val2;
            } else if (typeof newval !== typeof val2 || newval !== val2) {
              return newval;
            } else if (this.options.trimValues) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              const trimmedVal = val2.trim();
              if (trimmedVal === val2) {
                return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
              } else {
                return val2;
              }
            }
          }
        }
      }
      function resolveNameSpace(tagname) {
        if (this.options.removeNSPrefix) {
          const tags = tagname.split(":");
          const prefix = tagname.charAt(0) === "/" ? "/" : "";
          if (tags[0] === "xmlns") {
            return "";
          }
          if (tags.length === 2) {
            tagname = prefix + tags[1];
          }
        }
        return tagname;
      }
      var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function buildAttributesMap(attrStr, jPath, tagName) {
        if (!this.options.ignoreAttributes && typeof attrStr === "string") {
          const matches3 = util.getAllMatches(attrStr, attrsRegx);
          const len4 = matches3.length;
          const attrs = {};
          for (let i5 = 0; i5 < len4; i5++) {
            const attrName = this.resolveNameSpace(matches3[i5][1]);
            let oldVal = matches3[i5][4];
            let aName = this.options.attributeNamePrefix + attrName;
            if (attrName.length) {
              if (this.options.transformAttributeName) {
                aName = this.options.transformAttributeName(aName);
              }
              if (aName === "__proto__")
                aName = "#__proto__";
              if (oldVal !== void 0) {
                if (this.options.trimValues) {
                  oldVal = oldVal.trim();
                }
                oldVal = this.replaceEntitiesValue(oldVal);
                const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
                if (newVal === null || newVal === void 0) {
                  attrs[aName] = oldVal;
                } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                  attrs[aName] = newVal;
                } else {
                  attrs[aName] = parseValue(
                    oldVal,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions
                  );
                }
              } else if (this.options.allowBooleanAttributes) {
                attrs[aName] = true;
              }
            }
          }
          if (!Object.keys(attrs).length) {
            return;
          }
          if (this.options.attributesGroupName) {
            const attrCollection = {};
            attrCollection[this.options.attributesGroupName] = attrs;
            return attrCollection;
          }
          return attrs;
        }
      }
      var parseXml = function(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new xmlNode("!xml");
        let currentNode = xmlObj;
        let textData = "";
        let jPath = "";
        for (let i5 = 0; i5 < xmlData.length; i5++) {
          const ch = xmlData[i5];
          if (ch === "<") {
            if (xmlData[i5 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i5, "Closing Tag is not closed.");
              let tagName = xmlData.substring(i5 + 2, closeIndex).trim();
              if (this.options.removeNSPrefix) {
                const colonIndex = tagName.indexOf(":");
                if (colonIndex !== -1) {
                  tagName = tagName.substr(colonIndex + 1);
                }
              }
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode) {
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
              }
              const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
              if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
                throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
              }
              let propIndex = 0;
              if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
                propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
                this.tagsNodeStack.pop();
              } else {
                propIndex = jPath.lastIndexOf(".");
              }
              jPath = jPath.substring(0, propIndex);
              currentNode = this.tagsNodeStack.pop();
              textData = "";
              i5 = closeIndex;
            } else if (xmlData[i5 + 1] === "?") {
              let tagData = readTagExp(xmlData, i5, false, "?>");
              if (!tagData)
                throw new Error("Pi Tag is not closed.");
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
              } else {
                const childNode = new xmlNode(tagData.tagName);
                childNode.add(this.options.textNodeName, "");
                if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
                }
                this.addChild(currentNode, childNode, jPath);
              }
              i5 = tagData.closeIndex + 1;
            } else if (xmlData.substr(i5 + 1, 3) === "!--") {
              const endIndex = findClosingIndex(xmlData, "-->", i5 + 4, "Comment is not closed.");
              if (this.options.commentPropName) {
                const comment = xmlData.substring(i5 + 4, endIndex - 2);
                textData = this.saveTextToParentTag(textData, currentNode, jPath);
                currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
              }
              i5 = endIndex;
            } else if (xmlData.substr(i5 + 1, 2) === "!D") {
              const result = readDocType(xmlData, i5);
              this.docTypeEntities = result.entities;
              i5 = result.i;
            } else if (xmlData.substr(i5 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i5, "CDATA is not closed.") - 2;
              const tagExp = xmlData.substring(i5 + 9, closeIndex);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
              if (val2 == void 0)
                val2 = "";
              if (this.options.cdataPropName) {
                currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
              } else {
                currentNode.add(this.options.textNodeName, val2);
              }
              i5 = closeIndex + 2;
            } else {
              let result = readTagExp(xmlData, i5, this.options.removeNSPrefix);
              let tagName = result.tagName;
              const rawTagName = result.rawTagName;
              let tagExp = result.tagExp;
              let attrExpPresent = result.attrExpPresent;
              let closeIndex = result.closeIndex;
              if (this.options.transformTagName) {
                tagName = this.options.transformTagName(tagName);
              }
              if (currentNode && textData) {
                if (currentNode.tagname !== "!xml") {
                  textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
                }
              }
              const lastTag = currentNode;
              if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
                currentNode = this.tagsNodeStack.pop();
                jPath = jPath.substring(0, jPath.lastIndexOf("."));
              }
              if (tagName !== xmlObj.tagname) {
                jPath += jPath ? "." + tagName : tagName;
              }
              if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
                let tagContent = "";
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  i5 = result.closeIndex;
                } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                  i5 = result.closeIndex;
                } else {
                  const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                  if (!result2)
                    throw new Error(`Unexpected end of ${rawTagName}`);
                  i5 = result2.i;
                  tagContent = result2.tagContent;
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                if (tagContent) {
                  tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
                }
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
                childNode.add(this.options.textNodeName, tagContent);
                this.addChild(currentNode, childNode, jPath);
              } else {
                if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                  if (tagName[tagName.length - 1] === "/") {
                    tagName = tagName.substr(0, tagName.length - 1);
                    jPath = jPath.substr(0, jPath.length - 1);
                    tagExp = tagName;
                  } else {
                    tagExp = tagExp.substr(0, tagExp.length - 1);
                  }
                  if (this.options.transformTagName) {
                    tagName = this.options.transformTagName(tagName);
                  }
                  const childNode = new xmlNode(tagName);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  jPath = jPath.substr(0, jPath.lastIndexOf("."));
                } else {
                  const childNode = new xmlNode(tagName);
                  this.tagsNodeStack.push(currentNode);
                  if (tagName !== tagExp && attrExpPresent) {
                    childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                  }
                  this.addChild(currentNode, childNode, jPath);
                  currentNode = childNode;
                }
                textData = "";
                i5 = closeIndex;
              }
            }
          } else {
            textData += xmlData[i5];
          }
        }
        return xmlObj.child;
      };
      function addChild(currentNode, childNode, jPath) {
        const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
        if (result === false) {
        } else if (typeof result === "string") {
          childNode.tagname = result;
          currentNode.addChild(childNode);
        } else {
          currentNode.addChild(childNode);
        }
      }
      var replaceEntitiesValue = function(val2) {
        if (this.options.processEntities) {
          for (let entityName2 in this.docTypeEntities) {
            const entity = this.docTypeEntities[entityName2];
            val2 = val2.replace(entity.regx, entity.val);
          }
          for (let entityName2 in this.lastEntities) {
            const entity = this.lastEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
          if (this.options.htmlEntities) {
            for (let entityName2 in this.htmlEntities) {
              const entity = this.htmlEntities[entityName2];
              val2 = val2.replace(entity.regex, entity.val);
            }
          }
          val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return val2;
      };
      function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
        if (textData) {
          if (isLeafNode === void 0)
            isLeafNode = Object.keys(currentNode.child).length === 0;
          textData = this.parseTextData(
            textData,
            currentNode.tagname,
            jPath,
            false,
            currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
            isLeafNode
          );
          if (textData !== void 0 && textData !== "")
            currentNode.add(this.options.textNodeName, textData);
          textData = "";
        }
        return textData;
      }
      function isItStopNode(stopNodes, jPath, currentTagName) {
        const allNodesExp = "*." + currentTagName;
        for (const stopNodePath in stopNodes) {
          const stopNodeExp = stopNodes[stopNodePath];
          if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
            return true;
        }
        return false;
      }
      function tagExpWithClosingIndex(xmlData, i5, closingChar = ">") {
        let attrBoundary;
        let tagExp = "";
        for (let index2 = i5; index2 < xmlData.length; index2++) {
          let ch = xmlData[index2];
          if (attrBoundary) {
            if (ch === attrBoundary)
              attrBoundary = "";
          } else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
          } else if (ch === closingChar[0]) {
            if (closingChar[1]) {
              if (xmlData[index2 + 1] === closingChar[1]) {
                return {
                  data: tagExp,
                  index: index2
                };
              }
            } else {
              return {
                data: tagExp,
                index: index2
              };
            }
          } else if (ch === "	") {
            ch = " ";
          }
          tagExp += ch;
        }
      }
      function findClosingIndex(xmlData, str5, i5, errMsg) {
        const closingIndex = xmlData.indexOf(str5, i5);
        if (closingIndex === -1) {
          throw new Error(errMsg);
        } else {
          return closingIndex + str5.length - 1;
        }
      }
      function readTagExp(xmlData, i5, removeNSPrefix, closingChar = ">") {
        const result = tagExpWithClosingIndex(xmlData, i5 + 1, closingChar);
        if (!result)
          return;
        let tagExp = result.data;
        const closeIndex = result.index;
        const separatorIndex = tagExp.search(/\s/);
        let tagName = tagExp;
        let attrExpPresent = true;
        if (separatorIndex !== -1) {
          tagName = tagExp.substring(0, separatorIndex);
          tagExp = tagExp.substring(separatorIndex + 1).trimStart();
        }
        const rawTagName = tagName;
        if (removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
          }
        }
        return {
          tagName,
          tagExp,
          closeIndex,
          attrExpPresent,
          rawTagName
        };
      }
      function readStopNodeData(xmlData, tagName, i5) {
        const startIndex = i5;
        let openTagCount = 1;
        for (; i5 < xmlData.length; i5++) {
          if (xmlData[i5] === "<") {
            if (xmlData[i5 + 1] === "/") {
              const closeIndex = findClosingIndex(xmlData, ">", i5, `${tagName} is not closed`);
              let closeTagName = xmlData.substring(i5 + 2, closeIndex).trim();
              if (closeTagName === tagName) {
                openTagCount--;
                if (openTagCount === 0) {
                  return {
                    tagContent: xmlData.substring(startIndex, i5),
                    i: closeIndex
                  };
                }
              }
              i5 = closeIndex;
            } else if (xmlData[i5 + 1] === "?") {
              const closeIndex = findClosingIndex(xmlData, "?>", i5 + 1, "StopNode is not closed.");
              i5 = closeIndex;
            } else if (xmlData.substr(i5 + 1, 3) === "!--") {
              const closeIndex = findClosingIndex(xmlData, "-->", i5 + 3, "StopNode is not closed.");
              i5 = closeIndex;
            } else if (xmlData.substr(i5 + 1, 2) === "![") {
              const closeIndex = findClosingIndex(xmlData, "]]>", i5, "StopNode is not closed.") - 2;
              i5 = closeIndex;
            } else {
              const tagData = readTagExp(xmlData, i5, ">");
              if (tagData) {
                const openTagName = tagData && tagData.tagName;
                if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                  openTagCount++;
                }
                i5 = tagData.closeIndex;
              }
            }
          }
        }
      }
      function parseValue(val2, shouldParse, options) {
        if (shouldParse && typeof val2 === "string") {
          const newval = val2.trim();
          if (newval === "true")
            return true;
          else if (newval === "false")
            return false;
          else
            return toNumber2(val2, options);
        } else {
          if (util.isExist(val2)) {
            return val2;
          } else {
            return "";
          }
        }
      }
      module.exports = OrderedObjParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
  var require_node2json = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
      "use strict";
      function prettify(node2, options) {
        return compress(node2, options);
      }
      function compress(arr, options, jPath) {
        let text;
        const compressedObj = {};
        for (let i5 = 0; i5 < arr.length; i5++) {
          const tagObj = arr[i5];
          const property = propName(tagObj);
          let newJpath = "";
          if (jPath === void 0)
            newJpath = property;
          else
            newJpath = jPath + "." + property;
          if (property === options.textNodeName) {
            if (text === void 0)
              text = tagObj[property];
            else
              text += "" + tagObj[property];
          } else if (property === void 0) {
            continue;
          } else if (tagObj[property]) {
            let val2 = compress(tagObj[property], options, newJpath);
            const isLeaf = isLeafTag(val2, options);
            if (tagObj[":@"]) {
              assignAttributes(val2, tagObj[":@"], newJpath, options);
            } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
              val2 = val2[options.textNodeName];
            } else if (Object.keys(val2).length === 0) {
              if (options.alwaysCreateTextNode)
                val2[options.textNodeName] = "";
              else
                val2 = "";
            }
            if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
              if (!Array.isArray(compressedObj[property])) {
                compressedObj[property] = [compressedObj[property]];
              }
              compressedObj[property].push(val2);
            } else {
              if (options.isArray(property, newJpath, isLeaf)) {
                compressedObj[property] = [val2];
              } else {
                compressedObj[property] = val2;
              }
            }
          }
        }
        if (typeof text === "string") {
          if (text.length > 0)
            compressedObj[options.textNodeName] = text;
        } else if (text !== void 0)
          compressedObj[options.textNodeName] = text;
        return compressedObj;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i5 = 0; i5 < keys.length; i5++) {
          const key = keys[i5];
          if (key !== ":@")
            return key;
        }
      }
      function assignAttributes(obj, attrMap, jpath, options) {
        if (attrMap) {
          const keys = Object.keys(attrMap);
          const len4 = keys.length;
          for (let i5 = 0; i5 < len4; i5++) {
            const atrrName = keys[i5];
            if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
              obj[atrrName] = [attrMap[atrrName]];
            } else {
              obj[atrrName] = attrMap[atrrName];
            }
          }
        }
      }
      function isLeafTag(obj, options) {
        const { textNodeName } = options;
        const propCount = Object.keys(obj).length;
        if (propCount === 0) {
          return true;
        }
        if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
          return true;
        }
        return false;
      }
      exports.prettify = prettify;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
  var require_XMLParser = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
      var { buildOptions } = require_OptionsBuilder();
      var OrderedObjParser = require_OrderedObjParser();
      var { prettify } = require_node2json();
      var validator = require_validator();
      var XMLParser = class {
        constructor(options) {
          this.externalEntities = {};
          this.options = buildOptions(options);
        }
        parse(xmlData, validationOption) {
          if (typeof xmlData === "string") {
          } else if (xmlData.toString) {
            xmlData = xmlData.toString();
          } else {
            throw new Error("XML data is accepted in String or Bytes[] form.");
          }
          if (validationOption) {
            if (validationOption === true)
              validationOption = {};
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
            }
          }
          const orderedObjParser = new OrderedObjParser(this.options);
          orderedObjParser.addExternalEntities(this.externalEntities);
          const orderedResult = orderedObjParser.parseXml(xmlData);
          if (this.options.preserveOrder || orderedResult === void 0)
            return orderedResult;
          else
            return prettify(orderedResult, this.options);
        }
        addEntity(key, value) {
          if (value.indexOf("&") !== -1) {
            throw new Error("Entity value can't have '&'");
          } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          } else if (value === "&") {
            throw new Error("An entity with value '&' is not permitted");
          } else {
            this.externalEntities[key] = value;
          }
        }
      };
      module.exports = XMLParser;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
  var require_orderedJs2Xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
      var EOL = "\n";
      function toXml(jArray, options) {
        let indentation = "";
        if (options.format && options.indentBy.length > 0) {
          indentation = EOL;
        }
        return arrToStr(jArray, options, "", indentation);
      }
      function arrToStr(arr, options, jPath, indentation) {
        let xmlStr = "";
        let isPreviousElementTag = false;
        for (let i5 = 0; i5 < arr.length; i5++) {
          const tagObj = arr[i5];
          const tagName = propName(tagObj);
          if (tagName === void 0)
            continue;
          let newJPath = "";
          if (jPath.length === 0)
            newJPath = tagName;
          else
            newJPath = `${jPath}.${tagName}`;
          if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
              tagText = options.tagValueProcessor(tagName, tagText);
              tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
              xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
          } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
          } else if (tagName[0] === "?") {
            const attStr2 = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
            isPreviousElementTag = true;
            continue;
          }
          let newIdentation = indentation;
          if (newIdentation !== "") {
            newIdentation += options.indentBy;
          }
          const attStr = attr_to_str(tagObj[":@"], options);
          const tagStart = indentation + `<${tagName}${attStr}`;
          const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
          if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode)
              xmlStr += tagStart + ">";
            else
              xmlStr += tagStart + "/>";
          } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
          } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
          } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
              xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
              xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
          }
          isPreviousElementTag = true;
        }
        return xmlStr;
      }
      function propName(obj) {
        const keys = Object.keys(obj);
        for (let i5 = 0; i5 < keys.length; i5++) {
          const key = keys[i5];
          if (!obj.hasOwnProperty(key))
            continue;
          if (key !== ":@")
            return key;
        }
      }
      function attr_to_str(attrMap, options) {
        let attrStr = "";
        if (attrMap && !options.ignoreAttributes) {
          for (let attr in attrMap) {
            if (!attrMap.hasOwnProperty(attr))
              continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
              attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
          }
        }
        return attrStr;
      }
      function isStopNode(jPath, options) {
        jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
        let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
        for (let index2 in options.stopNodes) {
          if (options.stopNodes[index2] === jPath || options.stopNodes[index2] === "*." + tagName)
            return true;
        }
        return false;
      }
      function replaceEntitiesValue(textValue, options) {
        if (textValue && textValue.length > 0 && options.processEntities) {
          for (let i5 = 0; i5 < options.entities.length; i5++) {
            const entity = options.entities[i5];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      }
      module.exports = toXml;
    }
  });

  // ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
  var require_json2xml = __commonJS({
    "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
      "use strict";
      var buildFromOrderedJs = require_orderedJs2Xml();
      var defaultOptions2 = {
        attributeNamePrefix: "@_",
        attributesGroupName: false,
        textNodeName: "#text",
        ignoreAttributes: true,
        cdataPropName: false,
        format: false,
        indentBy: "  ",
        suppressEmptyNode: false,
        suppressUnpairedNode: true,
        suppressBooleanAttributes: true,
        tagValueProcessor: function(key, a3) {
          return a3;
        },
        attributeValueProcessor: function(attrName, a3) {
          return a3;
        },
        preserveOrder: false,
        commentPropName: false,
        unpairedTags: [],
        entities: [
          { regex: new RegExp("&", "g"), val: "&amp;" },
          { regex: new RegExp(">", "g"), val: "&gt;" },
          { regex: new RegExp("<", "g"), val: "&lt;" },
          { regex: new RegExp("'", "g"), val: "&apos;" },
          { regex: new RegExp('"', "g"), val: "&quot;" }
        ],
        processEntities: true,
        stopNodes: [],
        oneListGroup: false
      };
      function Builder(options) {
        this.options = Object.assign({}, defaultOptions2, options);
        if (this.options.ignoreAttributes || this.options.attributesGroupName) {
          this.isAttribute = function() {
            return false;
          };
        } else {
          this.attrPrefixLen = this.options.attributeNamePrefix.length;
          this.isAttribute = isAttribute;
        }
        this.processTextOrObjNode = processTextOrObjNode;
        if (this.options.format) {
          this.indentate = indentate;
          this.tagEndChar = ">\n";
          this.newLine = "\n";
        } else {
          this.indentate = function() {
            return "";
          };
          this.tagEndChar = ">";
          this.newLine = "";
        }
      }
      Builder.prototype.build = function(jObj) {
        if (this.options.preserveOrder) {
          return buildFromOrderedJs(jObj, this.options);
        } else {
          if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
            jObj = {
              [this.options.arrayNodeName]: jObj
            };
          }
          return this.j2x(jObj, 0).val;
        }
      };
      Builder.prototype.j2x = function(jObj, level) {
        let attrStr = "";
        let val2 = "";
        for (let key in jObj) {
          if (!Object.prototype.hasOwnProperty.call(jObj, key))
            continue;
          if (typeof jObj[key] === "undefined") {
            if (this.isAttribute(key)) {
              val2 += "";
            }
          } else if (jObj[key] === null) {
            if (this.isAttribute(key)) {
              val2 += "";
            } else if (key[0] === "?") {
              val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
            } else {
              val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            }
          } else if (jObj[key] instanceof Date) {
            val2 += this.buildTextValNode(jObj[key], key, "", level);
          } else if (typeof jObj[key] !== "object") {
            const attr = this.isAttribute(key);
            if (attr) {
              attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
            } else {
              if (key === this.options.textNodeName) {
                let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
                val2 += this.replaceEntitiesValue(newval);
              } else {
                val2 += this.buildTextValNode(jObj[key], key, "", level);
              }
            }
          } else if (Array.isArray(jObj[key])) {
            const arrLen = jObj[key].length;
            let listTagVal = "";
            for (let j2 = 0; j2 < arrLen; j2++) {
              const item = jObj[key][j2];
              if (typeof item === "undefined") {
              } else if (item === null) {
                if (key[0] === "?")
                  val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
                else
                  val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                if (this.options.oneListGroup) {
                  listTagVal += this.j2x(item, level + 1).val;
                } else {
                  listTagVal += this.processTextOrObjNode(item, key, level);
                }
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
            if (this.options.oneListGroup) {
              listTagVal = this.buildObjectNode(listTagVal, key, "", level);
            }
            val2 += listTagVal;
          } else {
            if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
              const Ks = Object.keys(jObj[key]);
              const L2 = Ks.length;
              for (let j2 = 0; j2 < L2; j2++) {
                attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
              }
            } else {
              val2 += this.processTextOrObjNode(jObj[key], key, level);
            }
          }
        }
        return { attrStr, val: val2 };
      };
      Builder.prototype.buildAttrPairStr = function(attrName, val2) {
        val2 = this.options.attributeValueProcessor(attrName, "" + val2);
        val2 = this.replaceEntitiesValue(val2);
        if (this.options.suppressBooleanAttributes && val2 === "true") {
          return " " + attrName;
        } else
          return " " + attrName + '="' + val2 + '"';
      };
      function processTextOrObjNode(object, key, level) {
        const result = this.j2x(object, level + 1);
        if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
          return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
        } else {
          return this.buildObjectNode(result.val, key, result.attrStr, level);
        }
      }
      Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
        if (val2 === "") {
          if (key[0] === "?")
            return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
          else {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          }
        } else {
          let tagEndExp = "</" + key + this.tagEndChar;
          let piClosingChar = "";
          if (key[0] === "?") {
            piClosingChar = "?";
            tagEndExp = "";
          }
          if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
          } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
            return this.indentate(level) + `<!--${val2}-->` + this.newLine;
          } else {
            return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
          }
        }
      };
      Builder.prototype.closeTag = function(key) {
        let closeTag = "";
        if (this.options.unpairedTags.indexOf(key) !== -1) {
          if (!this.options.suppressUnpairedNode)
            closeTag = "/";
        } else if (this.options.suppressEmptyNode) {
          closeTag = "/";
        } else {
          closeTag = `></${key}`;
        }
        return closeTag;
      };
      Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
        if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
          return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else if (key[0] === "?") {
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        } else {
          let textValue = this.options.tagValueProcessor(key, val2);
          textValue = this.replaceEntitiesValue(textValue);
          if (textValue === "") {
            return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
          } else {
            return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
          }
        }
      };
      Builder.prototype.replaceEntitiesValue = function(textValue) {
        if (textValue && textValue.length > 0 && this.options.processEntities) {
          for (let i5 = 0; i5 < this.options.entities.length; i5++) {
            const entity = this.options.entities[i5];
            textValue = textValue.replace(entity.regex, entity.val);
          }
        }
        return textValue;
      };
      function indentate(level) {
        return this.options.indentBy.repeat(level);
      }
      function isAttribute(name13) {
        if (name13.startsWith(this.options.attributeNamePrefix) && name13 !== this.options.textNodeName) {
          return name13.substr(this.attrPrefixLen);
        } else {
          return false;
        }
      }
      module.exports = Builder;
    }
  });

  // ../../node_modules/fast-xml-parser/src/fxp.js
  var require_fxp = __commonJS({
    "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
      "use strict";
      var validator = require_validator();
      var XMLParser = require_XMLParser();
      var XMLBuilder = require_json2xml();
      module.exports = {
        XMLParser,
        XMLValidator: validator,
        XMLBuilder
      };
    }
  });

  // ../../node_modules/long/dist/long.js
  var require_long = __commonJS({
    "../../node_modules/long/dist/long.js"(exports, module) {
      (function(global2, factory) {
        if (typeof define === "function" && define["amd"])
          define([], factory);
        else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
          module["exports"] = factory();
        else
          (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
      })(exports, function() {
        "use strict";
        function Long4(low, high, unsigned) {
          this.low = low | 0;
          this.high = high | 0;
          this.unsigned = !!unsigned;
        }
        Long4.prototype.__isLong__;
        Object.defineProperty(Long4.prototype, "__isLong__", {
          value: true,
          enumerable: false,
          configurable: false
        });
        function isLong2(obj) {
          return (obj && obj["__isLong__"]) === true;
        }
        Long4.isLong = isLong2;
        var INT_CACHE2 = {};
        var UINT_CACHE2 = {};
        function fromInt2(value, unsigned) {
          var obj, cachedObj, cache3;
          if (unsigned) {
            value >>>= 0;
            if (cache3 = 0 <= value && value < 256) {
              cachedObj = UINT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache3)
              UINT_CACHE2[value] = obj;
            return obj;
          } else {
            value |= 0;
            if (cache3 = -128 <= value && value < 128) {
              cachedObj = INT_CACHE2[value];
              if (cachedObj)
                return cachedObj;
            }
            obj = fromBits2(value, value < 0 ? -1 : 0, false);
            if (cache3)
              INT_CACHE2[value] = obj;
            return obj;
          }
        }
        Long4.fromInt = fromInt2;
        function fromNumber2(value, unsigned) {
          if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO2 : ZERO5;
          if (unsigned) {
            if (value < 0)
              return UZERO2;
            if (value >= TWO_PWR_64_DBL2)
              return MAX_UNSIGNED_VALUE2;
          } else {
            if (value <= -TWO_PWR_63_DBL2)
              return MIN_VALUE2;
            if (value + 1 >= TWO_PWR_63_DBL2)
              return MAX_VALUE2;
          }
          if (value < 0)
            return fromNumber2(-value, unsigned).neg();
          return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
        }
        Long4.fromNumber = fromNumber2;
        function fromBits2(lowBits, highBits, unsigned) {
          return new Long4(lowBits, highBits, unsigned);
        }
        Long4.fromBits = fromBits2;
        var pow_dbl2 = Math.pow;
        function fromString2(str5, unsigned, radix) {
          if (str5.length === 0)
            throw Error("empty string");
          if (str5 === "NaN" || str5 === "Infinity" || str5 === "+Infinity" || str5 === "-Infinity")
            return ZERO5;
          if (typeof unsigned === "number") {
            radix = unsigned, unsigned = false;
          } else {
            unsigned = !!unsigned;
          }
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          var p3;
          if ((p3 = str5.indexOf("-")) > 0)
            throw Error("interior hyphen");
          else if (p3 === 0) {
            return fromString2(str5.substring(1), unsigned, radix).neg();
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 8));
          var result = ZERO5;
          for (var i5 = 0; i5 < str5.length; i5 += 8) {
            var size = Math.min(8, str5.length - i5), value = parseInt(str5.substring(i5, i5 + size), radix);
            if (size < 8) {
              var power = fromNumber2(pow_dbl2(radix, size));
              result = result.mul(power).add(fromNumber2(value));
            } else {
              result = result.mul(radixToPower);
              result = result.add(fromNumber2(value));
            }
          }
          result.unsigned = unsigned;
          return result;
        }
        Long4.fromString = fromString2;
        function fromValue2(val2) {
          if (val2 instanceof Long4)
            return val2;
          if (typeof val2 === "number")
            return fromNumber2(val2);
          if (typeof val2 === "string")
            return fromString2(val2);
          return fromBits2(val2.low, val2.high, val2.unsigned);
        }
        Long4.fromValue = fromValue2;
        var TWO_PWR_16_DBL2 = 1 << 16;
        var TWO_PWR_24_DBL2 = 1 << 24;
        var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
        var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
        var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
        var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
        var ZERO5 = fromInt2(0);
        Long4.ZERO = ZERO5;
        var UZERO2 = fromInt2(0, true);
        Long4.UZERO = UZERO2;
        var ONE2 = fromInt2(1);
        Long4.ONE = ONE2;
        var UONE2 = fromInt2(1, true);
        Long4.UONE = UONE2;
        var NEG_ONE2 = fromInt2(-1);
        Long4.NEG_ONE = NEG_ONE2;
        var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
        Long4.MAX_VALUE = MAX_VALUE2;
        var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
        Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
        var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
        Long4.MIN_VALUE = MIN_VALUE2;
        var LongPrototype2 = Long4.prototype;
        LongPrototype2.toInt = function toInt2() {
          return this.unsigned ? this.low >>> 0 : this.low;
        };
        LongPrototype2.toNumber = function toNumber2() {
          if (this.unsigned)
            return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
          return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
        };
        LongPrototype2.toString = function toString2(radix) {
          radix = radix || 10;
          if (radix < 2 || 36 < radix)
            throw RangeError("radix");
          if (this.isZero())
            return "0";
          if (this.isNegative()) {
            if (this.eq(MIN_VALUE2)) {
              var radixLong = fromNumber2(radix), div4 = this.div(radixLong), rem1 = div4.mul(radixLong).sub(this);
              return div4.toString(radix) + rem1.toInt().toString(radix);
            } else
              return "-" + this.neg().toString(radix);
          }
          var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
          var result = "";
          while (true) {
            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
              return digits + result;
            else {
              while (digits.length < 6)
                digits = "0" + digits;
              result = "" + digits + result;
            }
          }
        };
        LongPrototype2.getHighBits = function getHighBits2() {
          return this.high;
        };
        LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
          return this.high >>> 0;
        };
        LongPrototype2.getLowBits = function getLowBits2() {
          return this.low;
        };
        LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
          return this.low >>> 0;
        };
        LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
          if (this.isNegative())
            return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
          var val2 = this.high != 0 ? this.high : this.low;
          for (var bit = 31; bit > 0; bit--)
            if ((val2 & 1 << bit) != 0)
              break;
          return this.high != 0 ? bit + 33 : bit + 1;
        };
        LongPrototype2.isZero = function isZero2() {
          return this.high === 0 && this.low === 0;
        };
        LongPrototype2.isNegative = function isNegative2() {
          return !this.unsigned && this.high < 0;
        };
        LongPrototype2.isPositive = function isPositive2() {
          return this.unsigned || this.high >= 0;
        };
        LongPrototype2.isOdd = function isOdd2() {
          return (this.low & 1) === 1;
        };
        LongPrototype2.isEven = function isEven2() {
          return (this.low & 1) === 0;
        };
        LongPrototype2.equals = function equals8(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
            return false;
          return this.high === other.high && this.low === other.low;
        };
        LongPrototype2.eq = LongPrototype2.equals;
        LongPrototype2.notEquals = function notEquals2(other) {
          return !this.eq(other);
        };
        LongPrototype2.neq = LongPrototype2.notEquals;
        LongPrototype2.lessThan = function lessThan2(other) {
          return this.comp(other) < 0;
        };
        LongPrototype2.lt = LongPrototype2.lessThan;
        LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
          return this.comp(other) <= 0;
        };
        LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
        LongPrototype2.greaterThan = function greaterThan2(other) {
          return this.comp(other) > 0;
        };
        LongPrototype2.gt = LongPrototype2.greaterThan;
        LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
          return this.comp(other) >= 0;
        };
        LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
        LongPrototype2.compare = function compare2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          if (this.eq(other))
            return 0;
          var thisNeg = this.isNegative(), otherNeg = other.isNegative();
          if (thisNeg && !otherNeg)
            return -1;
          if (!thisNeg && otherNeg)
            return 1;
          if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
          return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
        };
        LongPrototype2.comp = LongPrototype2.compare;
        LongPrototype2.negate = function negate5() {
          if (!this.unsigned && this.eq(MIN_VALUE2))
            return MIN_VALUE2;
          return this.not().add(ONE2);
        };
        LongPrototype2.neg = LongPrototype2.negate;
        LongPrototype2.add = function add8(addend) {
          if (!isLong2(addend))
            addend = fromValue2(addend);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = addend.high >>> 16;
          var b32 = addend.high & 65535;
          var b16 = addend.low >>> 16;
          var b00 = addend.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 + b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 + b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 + b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 + b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.subtract = function subtract6(subtrahend) {
          if (!isLong2(subtrahend))
            subtrahend = fromValue2(subtrahend);
          return this.add(subtrahend.neg());
        };
        LongPrototype2.sub = LongPrototype2.subtract;
        LongPrototype2.multiply = function multiply8(multiplier) {
          if (this.isZero())
            return ZERO5;
          if (!isLong2(multiplier))
            multiplier = fromValue2(multiplier);
          if (multiplier.isZero())
            return ZERO5;
          if (this.eq(MIN_VALUE2))
            return multiplier.isOdd() ? MIN_VALUE2 : ZERO5;
          if (multiplier.eq(MIN_VALUE2))
            return this.isOdd() ? MIN_VALUE2 : ZERO5;
          if (this.isNegative()) {
            if (multiplier.isNegative())
              return this.neg().mul(multiplier.neg());
            else
              return this.neg().mul(multiplier).neg();
          } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();
          if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
            return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
          var a48 = this.high >>> 16;
          var a32 = this.high & 65535;
          var a16 = this.low >>> 16;
          var a00 = this.low & 65535;
          var b48 = multiplier.high >>> 16;
          var b32 = multiplier.high & 65535;
          var b16 = multiplier.low >>> 16;
          var b00 = multiplier.low & 65535;
          var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
          c00 += a00 * b00;
          c16 += c00 >>> 16;
          c00 &= 65535;
          c16 += a16 * b00;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c16 += a00 * b16;
          c32 += c16 >>> 16;
          c16 &= 65535;
          c32 += a32 * b00;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a16 * b16;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c32 += a00 * b32;
          c48 += c32 >>> 16;
          c32 &= 65535;
          c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
          c48 &= 65535;
          return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
        };
        LongPrototype2.mul = LongPrototype2.multiply;
        LongPrototype2.divide = function divide5(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          if (divisor.isZero())
            throw Error("division by zero");
          if (this.isZero())
            return this.unsigned ? UZERO2 : ZERO5;
          var approx, rem, res;
          if (!this.unsigned) {
            if (this.eq(MIN_VALUE2)) {
              if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
                return MIN_VALUE2;
              else if (divisor.eq(MIN_VALUE2))
                return ONE2;
              else {
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO5)) {
                  return divisor.isNegative() ? ONE2 : NEG_ONE2;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
            } else if (divisor.eq(MIN_VALUE2))
              return this.unsigned ? UZERO2 : ZERO5;
            if (this.isNegative()) {
              if (divisor.isNegative())
                return this.neg().div(divisor.neg());
              return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
              return this.div(divisor.neg()).neg();
            res = ZERO5;
          } else {
            if (!divisor.unsigned)
              divisor = divisor.toUnsigned();
            if (divisor.gt(this))
              return UZERO2;
            if (divisor.gt(this.shru(1)))
              return UONE2;
            res = UZERO2;
          }
          rem = this;
          while (rem.gte(divisor)) {
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
            var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl2(2, log23 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
              approx -= delta;
              approxRes = fromNumber2(approx, this.unsigned);
              approxRem = approxRes.mul(divisor);
            }
            if (approxRes.isZero())
              approxRes = ONE2;
            res = res.add(approxRes);
            rem = rem.sub(approxRem);
          }
          return res;
        };
        LongPrototype2.div = LongPrototype2.divide;
        LongPrototype2.modulo = function modulo2(divisor) {
          if (!isLong2(divisor))
            divisor = fromValue2(divisor);
          return this.sub(this.div(divisor).mul(divisor));
        };
        LongPrototype2.mod = LongPrototype2.modulo;
        LongPrototype2.not = function not2() {
          return fromBits2(~this.low, ~this.high, this.unsigned);
        };
        LongPrototype2.and = function and2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
        };
        LongPrototype2.or = function or2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
        };
        LongPrototype2.xor = function xor2(other) {
          if (!isLong2(other))
            other = fromValue2(other);
          return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
        };
        LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
          else
            return fromBits2(0, this.low << numBits - 32, this.unsigned);
        };
        LongPrototype2.shl = LongPrototype2.shiftLeft;
        LongPrototype2.shiftRight = function shiftRight2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          if ((numBits &= 63) === 0)
            return this;
          else if (numBits < 32)
            return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
          else
            return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
        };
        LongPrototype2.shr = LongPrototype2.shiftRight;
        LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
          if (isLong2(numBits))
            numBits = numBits.toInt();
          numBits &= 63;
          if (numBits === 0)
            return this;
          else {
            var high = this.high;
            if (numBits < 32) {
              var low = this.low;
              return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
            } else if (numBits === 32)
              return fromBits2(high, 0, this.unsigned);
            else
              return fromBits2(high >>> numBits - 32, 0, this.unsigned);
          }
        };
        LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
        LongPrototype2.toSigned = function toSigned2() {
          if (!this.unsigned)
            return this;
          return fromBits2(this.low, this.high, false);
        };
        LongPrototype2.toUnsigned = function toUnsigned2() {
          if (this.unsigned)
            return this;
          return fromBits2(this.low, this.high, true);
        };
        LongPrototype2.toBytes = function(le) {
          return le ? this.toBytesLE() : this.toBytesBE();
        };
        LongPrototype2.toBytesLE = function() {
          var hi = this.high, lo = this.low;
          return [
            lo & 255,
            lo >>> 8 & 255,
            lo >>> 16 & 255,
            lo >>> 24 & 255,
            hi & 255,
            hi >>> 8 & 255,
            hi >>> 16 & 255,
            hi >>> 24 & 255
          ];
        };
        LongPrototype2.toBytesBE = function() {
          var hi = this.high, lo = this.low;
          return [
            hi >>> 24 & 255,
            hi >>> 16 & 255,
            hi >>> 8 & 255,
            hi & 255,
            lo >>> 24 & 255,
            lo >>> 16 & 255,
            lo >>> 8 & 255,
            lo & 255
          ];
        };
        return Long4;
      });
    }
  });

  // external-global-plugin:h3-js
  var require_h3_js = __commonJS({
    "external-global-plugin:h3-js"(exports, module) {
      module.exports = globalThis.h3 || {};
    }
  });

  // ../../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e3, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i5 = isLE ? nBytes - 1 : 0;
        var d2 = isLE ? -1 : 1;
        var s3 = buffer[offset + i5];
        i5 += d2;
        e3 = s3 & (1 << -nBits) - 1;
        s3 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e3 = e3 * 256 + buffer[offset + i5], i5 += d2, nBits -= 8) {
        }
        m2 = e3 & (1 << -nBits) - 1;
        e3 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i5], i5 += d2, nBits -= 8) {
        }
        if (e3 === 0) {
          e3 = 1 - eBias;
        } else if (e3 === eMax) {
          return m2 ? NaN : (s3 ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e3 = e3 - eBias;
        }
        return (s3 ? -1 : 1) * m2 * Math.pow(2, e3 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e3, m2, c2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i5 = isLE ? 0 : nBytes - 1;
        var d2 = isLE ? 1 : -1;
        var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m2 = isNaN(value) ? 1 : 0;
          e3 = eMax;
        } else {
          e3 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c2 = Math.pow(2, -e3)) < 1) {
            e3--;
            c2 *= 2;
          }
          if (e3 + eBias >= 1) {
            value += rt / c2;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c2 >= 2) {
            e3++;
            c2 /= 2;
          }
          if (e3 + eBias >= eMax) {
            m2 = 0;
            e3 = eMax;
          } else if (e3 + eBias >= 1) {
            m2 = (value * c2 - 1) * Math.pow(2, mLen);
            e3 = e3 + eBias;
          } else {
            m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e3 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i5] = m2 & 255, i5 += d2, m2 /= 256, mLen -= 8) {
        }
        e3 = e3 << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i5] = e3 & 255, i5 += d2, e3 /= 256, eLen -= 8) {
        }
        buffer[offset + i5 - d2] |= s3 * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val2 = this.readVarint(), tag = val2 >> 3, startPos = this.pos;
            this.type = val2 & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val2);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val2 = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        readSFixed32: function() {
          var val2 = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val2;
        },
        readFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readSFixed64: function() {
          var val2 = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val2;
        },
        readFloat: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val2;
        },
        readDouble: function() {
          var val2 = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val2;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val2, b2;
          b2 = buf[this.pos++];
          val2 = b2 & 127;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 7;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 14;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos++];
          val2 |= (b2 & 127) << 21;
          if (b2 < 128)
            return val2;
          b2 = buf[this.pos];
          val2 |= (b2 & 15) << 28;
          return readVarintRemainder(val2, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val2) {
          var type = val2 & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min4) {
          var length6 = this.length || 16;
          while (length6 < this.pos + min4)
            length6 *= 2;
          if (length6 !== this.length) {
            var buf = new Uint8Array(length6);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length6;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val2) {
          this.realloc(4);
          writeInt32(this.buf, val2, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val2) {
          this.realloc(8);
          writeInt32(this.buf, val2 & -1, this.pos);
          writeInt32(this.buf, Math.floor(val2 * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val2) {
          val2 = +val2 || 0;
          if (val2 > 268435455 || val2 < 0) {
            writeBigVarint(val2, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val2 & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = (val2 >>>= 7) & 127 | (val2 > 127 ? 128 : 0);
          if (val2 <= 127)
            return;
          this.buf[this.pos++] = val2 >>> 7 & 127;
        },
        writeSVarint: function(val2) {
          this.writeVarint(val2 < 0 ? -val2 * 2 - 1 : val2 * 2);
        },
        writeBoolean: function(val2) {
          this.writeVarint(Boolean(val2));
        },
        writeString: function(str5) {
          str5 = String(str5);
          this.realloc(str5.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str5, this.pos);
          var len4 = this.pos - startPos;
          if (len4 >= 128)
            makeRoomForExtraLength(startPos, len4, this);
          this.pos = startPos - 1;
          this.writeVarint(len4);
          this.pos += len4;
        },
        writeFloat: function(val2) {
          this.realloc(4);
          ieee754.write(this.buf, val2, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val2) {
          this.realloc(8);
          ieee754.write(this.buf, val2, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len4 = buffer.length;
          this.writeVarint(len4);
          this.realloc(len4);
          for (var i5 = 0; i5 < len4; i5++)
            this.buf[this.pos++] = buffer[i5];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len4 = this.pos - startPos;
          if (len4 >= 128)
            makeRoomForExtraLength(startPos, len4, this);
          this.pos = startPos - 1;
          this.writeVarint(len4);
          this.pos += len4;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val2);
        },
        writeSFixed32Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val2);
        },
        writeFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val2);
        },
        writeSFixed64Field: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val2);
        },
        writeVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val2);
        },
        writeSVarintField: function(tag, val2) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val2);
        },
        writeStringField: function(tag, str5) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str5);
        },
        writeFloatField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val2);
        },
        writeDoubleField: function(tag, val2) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val2);
        },
        writeBooleanField: function(tag, val2) {
          this.writeVarintField(tag, Boolean(val2));
        }
      };
      function readVarintRemainder(l3, s3, p3) {
        var buf = p3.buf, h2, b2;
        b2 = buf[p3.pos++];
        h2 = (b2 & 112) >> 4;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        b2 = buf[p3.pos++];
        h2 |= (b2 & 127) << 3;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        b2 = buf[p3.pos++];
        h2 |= (b2 & 127) << 10;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        b2 = buf[p3.pos++];
        h2 |= (b2 & 127) << 17;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        b2 = buf[p3.pos++];
        h2 |= (b2 & 127) << 24;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        b2 = buf[p3.pos++];
        h2 |= (b2 & 1) << 31;
        if (b2 < 128)
          return toNum(l3, h2, s3);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val2, pbf) {
        var low, high;
        if (val2 >= 0) {
          low = val2 % 4294967296 | 0;
          high = val2 / 4294967296 | 0;
        } else {
          low = ~(-val2 % 4294967296);
          high = ~(-val2 / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val2 >= 18446744073709552e3 || val2 < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb2 = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb2 | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len4, pbf) {
        var extraLen = len4 <= 16383 ? 1 : len4 <= 2097151 ? 2 : len4 <= 268435455 ? 3 : Math.floor(Math.log(len4) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i5 = pbf.pos - 1; i5 >= startPos; i5--)
          pbf.buf[i5 + extraLen] = pbf.buf[i5];
      }
      function writePackedVarint(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeVarint(arr[i5]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSVarint(arr[i5]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFloat(arr[i5]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeDouble(arr[i5]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeBoolean(arr[i5]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFixed32(arr[i5]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSFixed32(arr[i5]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeFixed64(arr[i5]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i5 = 0; i5 < arr.length; i5++)
          pbf.writeSFixed64(arr[i5]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val2, pos) {
        buf[pos] = val2;
        buf[pos + 1] = val2 >>> 8;
        buf[pos + 2] = val2 >>> 16;
        buf[pos + 3] = val2 >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str5 = "";
        var i5 = pos;
        while (i5 < end) {
          var b0 = buf[i5];
          var c2 = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i5 + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c2 = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i5 + 1];
            if ((b1 & 192) === 128) {
              c2 = (b0 & 31) << 6 | b1 & 63;
              if (c2 <= 127) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i5 + 1];
            b2 = buf[i5 + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
                c2 = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i5 + 1];
            b2 = buf[i5 + 2];
            b3 = buf[i5 + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c2 <= 65535 || c2 >= 1114112) {
                c2 = null;
              }
            }
          }
          if (c2 === null) {
            c2 = 65533;
            bytesPerSequence = 1;
          } else if (c2 > 65535) {
            c2 -= 65536;
            str5 += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
            c2 = 56320 | c2 & 1023;
          }
          str5 += String.fromCharCode(c2);
          i5 += bytesPerSequence;
        }
        return str5;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str5, pos) {
        for (var i5 = 0, c2, lead; i5 < str5.length; i5++) {
          c2 = str5.charCodeAt(i5);
          if (c2 > 55295 && c2 < 57344) {
            if (lead) {
              if (c2 < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c2;
                continue;
              } else {
                c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c2 > 56319 || i5 + 1 === str5.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c2;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c2 < 128) {
            buf[pos++] = c2;
          } else {
            if (c2 < 2048) {
              buf[pos++] = c2 >> 6 | 192;
            } else {
              if (c2 < 65536) {
                buf[pos++] = c2 >> 12 | 224;
              } else {
                buf[pos++] = c2 >> 18 | 240;
                buf[pos++] = c2 >> 12 & 63 | 128;
              }
              buf[pos++] = c2 >> 6 & 63 | 128;
            }
            buf[pos++] = c2 & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    AGGREGATION_OPERATION: () => AGGREGATION_OPERATION,
    AmbientLight: () => AmbientLight,
    ArcLayer: () => ArcLayer,
    Attribute: () => Attribute2,
    AttributeManager: () => AttributeManager,
    BitmapLayer: () => BitmapLayer,
    BrushingExtension: () => BrushingExtension,
    COORDINATE_SYSTEM: () => COORDINATE_SYSTEM,
    CPUGridLayer: () => CPUGridLayer,
    ClipExtension: () => ClipExtension,
    CollisionFilterExtension: () => CollisionFilterExtension,
    ColumnLayer: () => ColumnLayer,
    CompassWidget: () => CompassWidget,
    CompositeLayer: () => CompositeLayer,
    ContourLayer: () => ContourLayer,
    Controller: () => Controller,
    DarkGlassTheme: () => DarkGlassTheme,
    DarkTheme: () => DarkTheme,
    DataFilterExtension: () => DataFilterExtension,
    Deck: () => Deck,
    DeckGL: () => DeckGL,
    DeckRenderer: () => DeckRenderer,
    DirectionalLight: () => DirectionalLight,
    FillStyleExtension: () => FillStyleExtension,
    FirstPersonController: () => FirstPersonController,
    FirstPersonView: () => FirstPersonView,
    FirstPersonViewport: () => FirstPersonViewport,
    FlyToInterpolator: () => FlyToInterpolator,
    Fp64Extension: () => Fp64Extension,
    FullscreenWidget: () => FullscreenWidget,
    GPUGridLayer: () => GPUGridLayer,
    GeoJsonLayer: () => GeoJsonLayer,
    GeohashLayer: () => GeohashLayer,
    GoogleMapsOverlay: () => GoogleMapsOverlay,
    GreatCircleLayer: () => GreatCircleLayer,
    GridCellLayer: () => GridCellLayer,
    GridLayer: () => GridLayer,
    H3ClusterLayer: () => H3ClusterLayer,
    H3HexagonLayer: () => H3HexagonLayer,
    HeatmapLayer: () => HeatmapLayer,
    HexagonLayer: () => HexagonLayer,
    IconLayer: () => IconLayer,
    Layer: () => Layer,
    LayerExtension: () => LayerExtension,
    LayerManager: () => LayerManager,
    LightGlassTheme: () => LightGlassTheme,
    LightTheme: () => LightTheme,
    LightingEffect: () => LightingEffect,
    LineLayer: () => LineLayer,
    LinearInterpolator: () => LinearInterpolator,
    MVTLayer: () => MVTLayer,
    MapController: () => MapController,
    MapView: () => MapView,
    MapboxOverlay: () => MapboxOverlay,
    MaskExtension: () => MaskExtension,
    OPERATION: () => OPERATION,
    OrbitController: () => OrbitController,
    OrbitView: () => OrbitView,
    OrbitViewport: () => OrbitViewport,
    OrthographicController: () => OrthographicController,
    OrthographicView: () => OrthographicView,
    OrthographicViewport: () => OrthographicViewport,
    PathLayer: () => PathLayer,
    PathStyleExtension: () => PathStyleExtension,
    PointCloudLayer: () => PointCloudLayer,
    PointLight: () => PointLight,
    PolygonLayer: () => PolygonLayer,
    PostProcessEffect: () => PostProcessEffect,
    QuadkeyLayer: () => QuadkeyLayer,
    S2Layer: () => S2Layer,
    ScatterplotLayer: () => ScatterplotLayer,
    ScenegraphLayer: () => ScenegraphLayer,
    ScreenGridLayer: () => ScreenGridLayer,
    SimpleMeshLayer: () => SimpleMeshLayer,
    SolidPolygonLayer: () => SolidPolygonLayer,
    TRANSITION_EVENTS: () => TRANSITION_EVENTS,
    TerrainLayer: () => TerrainLayer,
    Tesselator: () => Tesselator,
    TextLayer: () => TextLayer,
    Tile3DLayer: () => Tile3DLayer,
    TileLayer: () => TileLayer,
    TransitionInterpolator: () => TransitionInterpolator,
    TripsLayer: () => TripsLayer,
    UNIT: () => UNIT,
    VERSION: () => VERSION4,
    View: () => View,
    Viewport: () => Viewport,
    WebMercatorViewport: () => WebMercatorViewport2,
    ZoomWidget: () => ZoomWidget,
    _AggregationLayer: () => AggregationLayer,
    _BinSorter: () => BinSorter,
    _CPUAggregator: () => CPUAggregator,
    _CameraLight: () => CameraLight,
    _Component: () => Component,
    _ComponentState: () => ComponentState,
    _GPUGridAggregator: () => GPUGridAggregator,
    _GeoCellLayer: () => GeoCellLayer,
    _GlobeController: () => GlobeController,
    _GlobeView: () => GlobeView,
    _GlobeViewport: () => GlobeViewport,
    _LayersPass: () => LayersPass,
    _MultiIconLayer: () => MultiIconLayer,
    _PickLayersPass: () => PickLayersPass,
    _SunLight: () => SunLight,
    _TerrainExtension: () => TerrainExtension,
    _TextBackgroundLayer: () => TextBackgroundLayer,
    _Tile2DHeader: () => Tile2DHeader,
    _Tileset2D: () => Tileset2D,
    _WMSLayer: () => WMSLayer,
    _compareProps: () => compareProps,
    _count: () => count,
    _deepEqual: () => deepEqual2,
    _fillArray: () => fillArray2,
    _flatten: () => flatten,
    _getURLFromTemplate: () => getURLFromTemplate,
    _memoize: () => memoize,
    _mergeShaders: () => mergeShaders,
    _registerLoggers: () => register,
    assert: () => assert9,
    createIterable: () => createIterable,
    fp64LowPart: () => fp64LowPart2,
    getShaderAssembler: () => getShaderAssembler,
    gouraudLighting: () => gouraudLighting,
    log: () => log_default,
    phongLighting: () => phongLighting,
    picking: () => picking_default,
    project: () => project_default,
    project32: () => project32_default,
    project64: () => project64_default,
    shadow: () => shadow_default
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/loader-types.js
  async function parseFromContext(data, loaders, options, context) {
    return context._parse(data, loaders, options, context);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
  function assert2(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loader assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
  function mergeLoaderOptions(baseOptions, newOptions) {
    return mergeOptionsRecursively(baseOptions || {}, newOptions);
  }
  function mergeOptionsRecursively(baseOptions, newOptions) {
    let level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (level > 3) {
      return newOptions;
    }
    const options = {
      ...baseOptions
    };
    for (const [key, newValue] of Object.entries(newOptions)) {
      if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
        options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
      } else {
        options[key] = newOptions[key];
      }
    }
    return options;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
  var NPM_TAG = "latest";
  function getVersion() {
    var _globalThis$_loadersg;
    if (!((_globalThis$_loadersg = globalThis._loadersgl_) !== null && _globalThis$_loadersg !== void 0 && _globalThis$_loadersg.version)) {
      globalThis._loadersgl_ = globalThis._loadersgl_ || {};
      if (false) {
        console.warn("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
        globalThis._loadersgl_.version = NPM_TAG;
      } else {
        globalThis._loadersgl_.version = "4.1.4";
      }
    }
    return globalThis._loadersgl_.version;
  }
  var VERSION = getVersion();

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
  function assert3(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loaders.gl assertion failed.");
    }
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isWorker = typeof importScripts === "function";
  var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
  var WorkerJob = class {
    constructor(jobName, workerThread) {
      this.name = void 0;
      this.workerThread = void 0;
      this.isRunning = true;
      this.result = void 0;
      this._resolve = () => {
      };
      this._reject = () => {
      };
      this.name = jobName;
      this.workerThread = workerThread;
      this.result = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    postMessage(type, payload) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        type,
        payload
      });
    }
    done(value) {
      assert3(this.isRunning);
      this.isRunning = false;
      this._resolve(value);
    }
    error(error) {
      assert3(this.isRunning);
      this.isRunning = false;
      this._reject(error);
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
  var NodeWorker = class {
    terminate() {
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
  var workerURLCache = /* @__PURE__ */ new Map();
  function getLoadableWorkerURL(props) {
    assert3(props.source && !props.url || !props.source && props.url);
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
      if (props.url) {
        workerURL = getLoadableWorkerURLFromURL(props.url);
        workerURLCache.set(props.url, workerURL);
      }
      if (props.source) {
        workerURL = getLoadableWorkerURLFromSource(props.source);
        workerURLCache.set(props.source, workerURL);
      }
    }
    assert3(workerURL);
    return workerURL;
  }
  function getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) {
      return url;
    }
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
  }
  function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    return URL.createObjectURL(blob);
  }
  function buildScriptSource(workerUrl) {
    return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
  function getTransferList(object) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let transfers = arguments.length > 2 ? arguments[2] : void 0;
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
  var NOOP = () => {
  };
  var WorkerThread = class {
    static isSupported() {
      return typeof Worker !== "undefined" && isBrowser2 || typeof NodeWorker !== "undefined" && !isBrowser2;
    }
    constructor(props) {
      this.name = void 0;
      this.source = void 0;
      this.url = void 0;
      this.terminated = false;
      this.worker = void 0;
      this.onMessage = void 0;
      this.onError = void 0;
      this._loadableURL = "";
      const {
        name: name13,
        source,
        url
      } = props;
      assert3(source || url);
      this.name = name13;
      this.source = source;
      this.url = url;
      this.onMessage = NOOP;
      this.onError = (error) => console.log(error);
      this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
      transferList = transferList || getTransferList(data);
      this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
      let message2 = "Failed to load ";
      message2 += `worker ${this.name} from ${this.url}. `;
      if (event.message) {
        message2 += `${event.message} in `;
      }
      if (event.lineno) {
        message2 += `:${event.lineno}:${event.colno}`;
      }
      return new Error(message2);
    }
    _createBrowserWorker() {
      this._loadableURL = getLoadableWorkerURL({
        source: this.source,
        url: this.url
      });
      const worker = new Worker(this._loadableURL, {
        name: this.name
      });
      worker.onmessage = (event) => {
        if (!event.data) {
          this.onError(new Error("No data received"));
        } else {
          this.onMessage(event.data);
        }
      };
      worker.onerror = (error) => {
        this.onError(this._getErrorFromErrorEvent(error));
        this.terminated = true;
      };
      worker.onmessageerror = (event) => console.error(event);
      return worker;
    }
    _createNodeWorker() {
      let worker;
      if (this.url) {
        const absolute = this.url.includes(":/") || this.url.startsWith("/");
        const url = absolute ? this.url : `./${this.url}`;
        worker = new NodeWorker(url, {
          eval: false
        });
      } else if (this.source) {
        worker = new NodeWorker(this.source, {
          eval: true
        });
      } else {
        throw new Error("no worker");
      }
      worker.on("message", (data) => {
        this.onMessage(data);
      });
      worker.on("error", (error) => {
        this.onError(error);
      });
      worker.on("exit", (code) => {
      });
      return worker;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
  var WorkerPool = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    constructor(props) {
      this.name = "unnamed";
      this.source = void 0;
      this.url = void 0;
      this.maxConcurrency = 1;
      this.maxMobileConcurrency = 1;
      this.onDebug = () => {
      };
      this.reuseWorkers = true;
      this.props = {};
      this.jobQueue = [];
      this.idleQueue = [];
      this.count = 0;
      this.isDestroyed = false;
      this.source = props.source;
      this.url = props.url;
      this.setProps(props);
    }
    destroy() {
      this.idleQueue.forEach((worker) => worker.destroy());
      this.isDestroyed = true;
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      if (props.name !== void 0) {
        this.name = props.name;
      }
      if (props.maxConcurrency !== void 0) {
        this.maxConcurrency = props.maxConcurrency;
      }
      if (props.maxMobileConcurrency !== void 0) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }
      if (props.reuseWorkers !== void 0) {
        this.reuseWorkers = props.reuseWorkers;
      }
      if (props.onDebug !== void 0) {
        this.onDebug = props.onDebug;
      }
    }
    async startJob(name13) {
      let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
      let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error) => job.error(error);
      const startPromise = new Promise((onStart) => {
        this.jobQueue.push({
          name: name13,
          onMessage: onMessage2,
          onError,
          onStart
        });
        return this;
      });
      this._startQueuedJob();
      return await startPromise;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length) {
        return;
      }
      const workerThread = this._getAvailableWorker();
      if (!workerThread) {
        return;
      }
      const queuedJob = this.jobQueue.shift();
      if (queuedJob) {
        this.onDebug({
          message: "Starting job",
          name: queuedJob.name,
          workerThread,
          backlog: this.jobQueue.length
        });
        const job = new WorkerJob(queuedJob.name, workerThread);
        workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
        workerThread.onError = (error) => queuedJob.onError(job, error);
        queuedJob.onStart(job);
        try {
          await job.result;
        } catch (error) {
          console.error(`Worker exception: ${error}`);
        } finally {
          this.returnWorkerToQueue(workerThread);
        }
      }
    }
    returnWorkerToQueue(worker) {
      const shouldDestroyWorker = !isBrowser2 || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }
      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const name13 = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
        return new WorkerThread({
          name: name13,
          source: this.source,
          url: this.url
        });
      }
      return null;
    }
    _getMaxConcurrency() {
      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
  var DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  var WorkerFarm = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    static getWorkerFarm() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
      WorkerFarm._workerFarm.setProps(props);
      return WorkerFarm._workerFarm;
    }
    constructor(props) {
      this.props = void 0;
      this.workerPools = /* @__PURE__ */ new Map();
      this.props = {
        ...DEFAULT_PROPS
      };
      this.setProps(props);
      this.workerPools = /* @__PURE__ */ new Map();
    }
    destroy() {
      for (const workerPool of this.workerPools.values()) {
        workerPool.destroy();
      }
      this.workerPools = /* @__PURE__ */ new Map();
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      for (const workerPool of this.workerPools.values()) {
        workerPool.setProps(this._getWorkerPoolProps());
      }
    }
    getWorkerPool(options) {
      const {
        name: name13,
        source,
        url
      } = options;
      let workerPool = this.workerPools.get(name13);
      if (!workerPool) {
        workerPool = new WorkerPool({
          name: name13,
          source,
          url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name13, workerPool);
      }
      return workerPool;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  WorkerFarm._workerFarm = void 0;

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
  function getWorkerURL(worker) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const workerOptions = options[worker.id] || {};
    const workerFile = isBrowser2 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") {
      url = options.workerUrl;
    }
    if (options._workerType === "test") {
      if (isBrowser2) {
        url = `modules/${worker.module}/dist/${workerFile}`;
      } else {
        url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
      }
    }
    if (!url) {
      let version = worker.version;
      if (version === "latest") {
        version = NPM_TAG;
      }
      const versionTag = version ? `@${version}` : "";
      url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
    }
    assert3(url);
    return url;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
  function validateWorkerVersion(worker) {
    let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
    assert3(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js
  var loadLibraryPromises = {};
  async function loadLibrary(libraryUrl) {
    let moduleName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let libraryName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (moduleName) {
      libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);
    }
    loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
    return await loadLibraryPromises[libraryUrl];
  }
  function getLibraryUrl(library, moduleName) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let libraryName = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (!options.useLocalLibraries && library.startsWith("http")) {
      return library;
    }
    libraryName = libraryName || library;
    const modules = options.modules || {};
    if (modules[libraryName]) {
      return modules[libraryName];
    }
    if (!isBrowser2) {
      return `modules/${moduleName}/dist/libs/${libraryName}`;
    }
    if (options.CDN) {
      assert3(options.CDN.startsWith("http"));
      return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${libraryName}`;
    }
    if (isWorker) {
      return `../src/libs/${libraryName}`;
    }
    return `modules/${moduleName}/src/libs/${libraryName}`;
  }
  async function loadLibraryFromFile(libraryUrl) {
    if (libraryUrl.endsWith("wasm")) {
      return await loadAsArrayBuffer(libraryUrl);
    }
    if (!isBrowser2) {
      try {
        return node && node.requireFromFile && await node.requireFromFile(libraryUrl);
      } catch (error) {
        console.error(error);
        return null;
      }
    }
    if (isWorker) {
      return importScripts(libraryUrl);
    }
    const scriptSource = await loadAsText(libraryUrl);
    return loadLibraryFromString(scriptSource, libraryUrl);
  }
  function loadLibraryFromString(scriptSource, id) {
    if (!isBrowser2) {
      return node.requireFromString && node.requireFromString(scriptSource, id);
    }
    if (isWorker) {
      eval.call(globalThis, scriptSource);
      return null;
    }
    const script = document.createElement("script");
    script.id = id;
    try {
      script.appendChild(document.createTextNode(scriptSource));
    } catch (e3) {
      script.text = scriptSource;
    }
    document.body.appendChild(script);
    return null;
  }
  async function loadAsArrayBuffer(url) {
    if (isBrowser2 || !node.readFileAsArrayBuffer || url.startsWith("http")) {
      const response = await fetch(url);
      return await response.arrayBuffer();
    }
    return await node.readFileAsArrayBuffer(url);
  }
  async function loadAsText(url) {
    if (isBrowser2 || !node.readFileAsText || url.startsWith("http")) {
      const response = await fetch(url);
      return await response.text();
    }
    return await node.readFileAsText(url);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
  function canParseWithWorker(loader, options) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    if (!isBrowser2 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
      return false;
    }
    return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
  }
  async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name13 = loader.id;
    const url = getWorkerURL(loader, options);
    const workerFarm = WorkerFarm.getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
      name: name13,
      url
    });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
      input: data,
      options,
      context
    });
    const result = await job.result;
    return await result.result;
  }
  async function onMessage(parseOnMainThread, job, type, payload) {
    switch (type) {
      case "done":
        job.done(payload);
        break;
      case "error":
        job.error(new Error(payload.error));
        break;
      case "process":
        const {
          id,
          input,
          options
        } = payload;
        try {
          const result = await parseOnMainThread(input, options);
          job.postMessage("done", {
            id,
            result
          });
        } catch (error) {
          const message2 = error instanceof Error ? error.message : "unknown error";
          job.postMessage("error", {
            id,
            error: message2
          });
        }
        break;
      default:
        console.warn(`parse-with-worker unknown message ${type}`);
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js
  function getFirstCharacters(data) {
    let length6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length6);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length6);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length6);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length6) {
    if (arrayBuffer2.byteLength <= byteOffset + length6) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i5 = 0; i5 < length6; i5++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i5));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/parser-utils/parse-json.js
  function parseJSON(string) {
    try {
      return JSON.parse(string);
    } catch (_) {
      throw new Error(`Failed to parse JSON from data starting with "${getFirstCharacters(string)}"`);
    }
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    const array1 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for (let i5 = 0; i5 < array1.length; ++i5) {
      if (array1[i5] !== array2[i5]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    return concatenateArrayBuffersFromArray(sources);
  }
  function concatenateArrayBuffersFromArray(sources) {
    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length6, typedArray) => length6 + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }
  function concatenateTypedArrays() {
    for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      typedArrays[_key2] = arguments[_key2];
    }
    const arrays = typedArrays;
    const TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;
    if (!TypedArrayConstructor) {
      throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');
    }
    const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);
    const result = new TypedArrayConstructor(sumLength);
    let offset = 0;
    for (const array of arrays) {
      result.set(array, offset);
      offset += array.length;
    }
    return result;
  }
  function sliceArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    const subArray = byteLength !== void 0 ? new Uint8Array(arrayBuffer2).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer2).subarray(byteOffset);
    const arrayCopy2 = new Uint8Array(subArray);
    return arrayCopy2.buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js
  function padToNBytes(byteLength, padding) {
    assert2(byteLength >= 0);
    assert2(padding > 0);
    return byteLength + (padding - 1) & ~(padding - 1);
  }
  function copyToArray(source, target, targetOffset) {
    let sourceArray;
    if (source instanceof ArrayBuffer) {
      sourceArray = new Uint8Array(source);
    } else {
      const srcByteOffset = source.byteOffset;
      const srcByteLength = source.byteLength;
      sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
    }
    target.set(sourceArray, targetOffset);
    return targetOffset + padToNBytes(sourceArray.byteLength, 4);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // ../../node_modules/@probe.gl/stats/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/stats/dist/lib/stat.js
  var Stat = class {
    constructor(name13, type) {
      this.sampleSize = 1;
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      this.name = name13;
      this.type = type;
      this.reset();
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // ../../node_modules/@probe.gl/stats/dist/lib/stats.js
  var Stats = class {
    constructor(options) {
      this.stats = {};
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name13, type = "count") {
      return this._getOrCreate({ name: name13, type });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const stat of Object.values(this.stats)) {
        stat.reset();
      }
      return this;
    }
    forEach(fn) {
      for (const stat of Object.values(this.stats)) {
        fn(stat);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats(stats = []) {
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      const { name: name13, type } = stat;
      let result = this.stats[name13];
      if (!result) {
        if (stat instanceof Stat) {
          result = stat;
        } else {
          result = new Stat(name13, type);
        }
        this.stats[name13] = result;
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/request-utils/request-scheduler.js
  var STAT_QUEUED_REQUESTS = "Queued Requests";
  var STAT_ACTIVE_REQUESTS = "Active Requests";
  var STAT_CANCELLED_REQUESTS = "Cancelled Requests";
  var STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
  var STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
  var DEFAULT_PROPS2 = {
    id: "request-scheduler",
    throttleRequests: true,
    maxRequests: 6,
    debounceTime: 0
  };
  var RequestScheduler = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.props = void 0;
      this.stats = void 0;
      this.activeRequestCount = 0;
      this.requestQueue = [];
      this.requestMap = /* @__PURE__ */ new Map();
      this.updateTimer = null;
      this.props = {
        ...DEFAULT_PROPS2,
        ...props
      };
      this.stats = new Stats({
        id: this.props.id
      });
      this.stats.get(STAT_QUEUED_REQUESTS);
      this.stats.get(STAT_ACTIVE_REQUESTS);
      this.stats.get(STAT_CANCELLED_REQUESTS);
      this.stats.get(STAT_QUEUED_REQUESTS_EVER);
      this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
    }
    scheduleRequest(handle) {
      let getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
      if (!this.props.throttleRequests) {
        return Promise.resolve({
          done: () => {
          }
        });
      }
      if (this.requestMap.has(handle)) {
        return this.requestMap.get(handle);
      }
      const request = {
        handle,
        priority: 0,
        getPriority
      };
      const promise = new Promise((resolve2) => {
        request.resolve = resolve2;
        return request;
      });
      this.requestQueue.push(request);
      this.requestMap.set(handle, promise);
      this._issueNewRequests();
      return promise;
    }
    _issueRequest(request) {
      const {
        handle,
        resolve: resolve2
      } = request;
      let isDone = false;
      const done = () => {
        if (!isDone) {
          isDone = true;
          this.requestMap.delete(handle);
          this.activeRequestCount--;
          this._issueNewRequests();
        }
      };
      this.activeRequestCount++;
      return resolve2 ? resolve2({
        done
      }) : Promise.resolve({
        done
      });
    }
    _issueNewRequests() {
      if (this.updateTimer !== null) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
    }
    _issueNewRequestsAsync() {
      if (this.updateTimer !== null) {
        clearTimeout(this.updateTimer);
      }
      this.updateTimer = null;
      const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
      if (freeSlots === 0) {
        return;
      }
      this._updateAllRequests();
      for (let i5 = 0; i5 < freeSlots; ++i5) {
        const request = this.requestQueue.shift();
        if (request) {
          this._issueRequest(request);
        }
      }
    }
    _updateAllRequests() {
      const requestQueue = this.requestQueue;
      for (let i5 = 0; i5 < requestQueue.length; ++i5) {
        const request = requestQueue[i5];
        if (!this._updateRequest(request)) {
          requestQueue.splice(i5, 1);
          this.requestMap.delete(request.handle);
          i5--;
        }
      }
      requestQueue.sort((a3, b2) => a3.priority - b2.priority);
    }
    _updateRequest(request) {
      request.priority = request.getPriority(request.handle);
      if (request.priority < 0) {
        request.resolve(null);
        return false;
      }
      return true;
    }
  };

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename2) {
    for (const alias in fileAliases) {
      if (filename2.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename2 = filename2.replace(alias, replacement);
      }
    }
    if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
      filename2 = `${pathPrefix}${filename2}`;
    }
    return filename2;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value) {
    return value && typeof value === "object" && value.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text = data;
      const uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join,
    resolve: () => resolve
  });

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
  function getCWD() {
    var _window$location;
    if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
      return process.cwd();
    }
    const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
    return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
  function filename(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join() {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }
    const separator = "/";
    parts = parts.map((part, index2) => {
      if (index2) {
        part = part.replace(new RegExp(`^${separator}`), "");
      }
      if (index2 !== parts.length - 1) {
        part = part.replace(new RegExp(`${separator}$`), "");
      }
      return part;
    });
    return parts.join(separator);
  }
  function resolve() {
    const paths = [];
    for (let _i = 0; _i < arguments.length; _i++) {
      paths[_i] = _i < 0 || arguments.length <= _i ? void 0 : arguments[_i];
    }
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i5 = paths.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
      let path;
      if (i5 >= 0) {
        path = paths[i5];
      } else {
        if (cwd === void 0) {
          cwd = getCWD();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    }
    return ".";
  }
  var SLASH = 47;
  var DOT = 46;
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for (let i5 = 0; i5 <= path.length; ++i5) {
      if (i5 < path.length) {
        code = path.charCodeAt(i5);
      } else if (code === SLASH) {
        break;
      } else {
        code = SLASH;
      }
      if (code === SLASH) {
        if (lastSlash === i5 - 1 || dots === 1) {
        } else if (lastSlash !== i5 - 1 && dots === 2) {
          if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
            if (res.length > 2) {
              const start = res.length - 1;
              let j2 = start;
              for (; j2 >= 0; --j2) {
                if (res.charCodeAt(j2) === SLASH) {
                  break;
                }
              }
              if (j2 !== start) {
                res = j2 === -1 ? "" : res.slice(0, j2);
                lastSlash = i5;
                dots = 0;
                isAboveRoot = false;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSlash = i5;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            isAboveRoot = true;
          }
        } else {
          const slice = path.slice(lastSlash + 1, i5);
          if (res.length > 0) {
            res += `/${slice}`;
          } else {
            res = slice;
          }
          isAboveRoot = false;
        }
        lastSlash = i5;
        dots = 0;
      } else if (code === DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/sources/data-source.js
  var DataSource = class {
    constructor(props) {
      this.data = void 0;
      this.fetch = void 0;
      this.loadOptions = void 0;
      this._needsRefresh = true;
      this.props = void 0;
      this.props = {
        ...props
      };
      this.loadOptions = {
        ...props.loadOptions
      };
      this.fetch = getFetchFunction(this.loadOptions);
    }
    setProps(props) {
      this.props = Object.assign(this.props, props);
      this.setNeedsRefresh();
    }
    setNeedsRefresh() {
      this._needsRefresh = true;
    }
    getNeedsRefresh() {
      let clear2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const needsRefresh = this._needsRefresh;
      if (clear2) {
        this._needsRefresh = false;
      }
      return needsRefresh;
    }
  };
  function getFetchFunction(options) {
    const fetchFunction = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchFunction && typeof fetchFunction === "function") {
      return (url, fetchOptions2) => fetchFunction(url, fetchOptions2);
    }
    const fetchOptions = options === null || options === void 0 ? void 0 : options.fetch;
    if (fetchOptions && typeof fetchOptions !== "function") {
      return (url) => fetch(url, fetchOptions);
    }
    return (url) => fetch(url);
  }

  // ../../node_modules/@loaders.gl/loader-utils/dist/lib/sources/image-source.js
  var ImageSource = class extends DataSource {
  };
  ImageSource.type = "template";
  ImageSource.testURL = (url) => false;

  // ../../node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
  var isBoolean = (x3) => typeof x3 === "boolean";
  var isFunction = (x3) => typeof x3 === "function";
  var isObject = (x3) => x3 !== null && typeof x3 === "object";
  var isPureObject = (x3) => isObject(x3) && x3.constructor === {}.constructor;
  var isIterable = (x3) => Boolean(x3) && typeof x3[Symbol.iterator] === "function";
  var isAsyncIterable = (x3) => x3 && typeof x3[Symbol.asyncIterator] === "function";
  var isResponse = (x3) => typeof Response !== "undefined" && x3 instanceof Response || x3 && x3.arrayBuffer && x3.text && x3.json;
  var isBlob = (x3) => typeof Blob !== "undefined" && x3 instanceof Blob;
  var isBuffer2 = (x3) => x3 && typeof x3 === "object" && x3.isBuffer;
  var isReadableDOMStream = (x3) => typeof ReadableStream !== "undefined" && x3 instanceof ReadableStream || isObject(x3) && isFunction(x3.tee) && isFunction(x3.cancel) && isFunction(x3.getReader);
  var isReadableNodeStream = (x3) => isObject(x3) && isFunction(x3.read) && isFunction(x3.pipe) && isBoolean(x3.readable);
  var isReadableStream = (x3) => isReadableDOMStream(x3) || isReadableNodeStream(x3);

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function parseMIMEType(mimeString) {
    const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(url) {
    const matches3 = DATA_URL_PATTERN.exec(url);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function extractQueryString(url) {
    const matches3 = url.match(QUERY_STRING_PATTERN);
    return matches3 && matches3[0];
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
  function getResourceUrl(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.url;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.name || "";
    }
    if (typeof resource === "string") {
      return resource;
    }
    return "";
  }
  function getResourceMIMEType(resource) {
    if (isResponse(resource)) {
      const response = resource;
      const contentTypeHeader = response.headers.get("content-type") || "";
      const noQueryUrl = stripQueryString(response.url);
      return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.type || "";
    }
    if (typeof resource === "string") {
      return parseMIMETypeFromURL(resource);
    }
    return "";
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
  async function makeResponse(resource) {
    if (isResponse(resource)) {
      return resource;
    }
    const headers = {};
    const contentLength = getResourceContentLength(resource);
    if (contentLength >= 0) {
      headers["content-length"] = String(contentLength);
    }
    const url = getResourceUrl(resource);
    const type = getResourceMIMEType(resource);
    if (type) {
      headers["content-type"] = type;
    }
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
      headers["x-first-bytes"] = initialDataUrl;
    }
    if (typeof resource === "string") {
      resource = new TextEncoder().encode(resource);
    }
    const response = new Response(resource, {
      headers
    });
    Object.defineProperty(response, "url", {
      value: url
    });
    return response;
  }
  async function checkResponse(response) {
    if (!response.ok) {
      const message2 = await getResponseError(response);
      throw new Error(message2);
    }
  }
  async function getResponseError(response) {
    let message2 = `Failed to fetch resource ${response.url} (${response.status}): `;
    try {
      const contentType = response.headers.get("Content-Type");
      let text = response.statusText;
      if (contentType !== null && contentType !== void 0 && contentType.includes("application/json")) {
        text += ` ${await response.text()}`;
      }
      message2 += text;
      message2 = message2.length > 60 ? `${message2.slice(0, 60)}...` : message2;
    } catch (error) {
    }
    return message2;
  }
  async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") {
      return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
    }
    if (resource instanceof Blob) {
      const blobSlice = resource.slice(0, 5);
      return await new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          var _event$target;
          return resolve2(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
        };
        reader.readAsDataURL(blobSlice);
      });
    }
    if (resource instanceof ArrayBuffer) {
      const slice = resource.slice(0, INITIAL_DATA_LENGTH);
      const base64 = arrayBufferToBase64(slice);
      return `data:base64,${base64}`;
    }
    return null;
  }
  function arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i5 = 0; i5 < bytes.byteLength; i5++) {
      binary += String.fromCharCode(bytes[i5]);
    }
    return btoa(binary);
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
  function isNodePath(url) {
    return !isRequestURL(url) && !isDataURL(url);
  }
  function isRequestURL(url) {
    return url.startsWith("http:") || url.startsWith("https:");
  }
  function isDataURL(url) {
    return url.startsWith("data:");
  }
  async function fetchFile(urlOrData, fetchOptions) {
    if (typeof urlOrData === "string") {
      const url = resolvePath(urlOrData);
      if (isNodePath(url)) {
        var _globalThis$loaders2;
        if ((_globalThis$loaders2 = globalThis.loaders) !== null && _globalThis$loaders2 !== void 0 && _globalThis$loaders2.fetchNode) {
          var _globalThis$loaders22;
          return (_globalThis$loaders22 = globalThis.loaders) === null || _globalThis$loaders22 === void 0 ? void 0 : _globalThis$loaders22.fetchNode(url, fetchOptions);
        }
      }
      return await fetch(url, fetchOptions);
    }
    return await makeResponse(urlOrData);
  }

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var window_3 = globalThis;
  var document_3 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && window.process?.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    return Boolean(userAgent2 && userAgent2.indexOf("Electron") >= 0);
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser3() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process?.browser;
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/get-browser.js
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser3()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const userAgent2 = mockUserAgent || navigator_.userAgent || "";
    if (userAgent2.indexOf("Edge") > -1) {
      return "Edge";
    }
    if (globalThis.chrome) {
      return "Chrome";
    }
    if (globalThis.safari) {
      return "Safari";
    }
    if (globalThis.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // ../../node_modules/@probe.gl/env/dist/index.js
  var VERSION2 = true ? "4.0.7" : "untranspiled source";

  // ../../node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x3 = "__storage_test__";
      storage.setItem(x3, x3);
      storage.removeItem(x3);
      return storage;
    } catch (e3) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig, type = "sessionStorage") {
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // ../../node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
      formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1e3) {
      formatted = `${ms.toFixed(0)}ms`;
    } else {
      formatted = `${(ms / 1e3).toFixed(2)}s`;
    }
    return formatted;
  }
  function leftPad(string, length6 = 8) {
    const padLength = Math.max(length6 - string.length, 0);
    return `${" ".repeat(padLength)}${string}`;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR2) {
    COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
    COLOR2[COLOR2["RED"] = 31] = "RED";
    COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
    COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
    COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
    COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
    COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
    COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
    COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser3 && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = `\x1B[${colorCode}m${string}\x1B[39m`;
      }
      if (background) {
        const colorCode = getColor(background);
        string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
      }
    }
    return string;
  }

  // ../../node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj, predefined = ["constructor"]) {
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name13) => key === name13)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/assert.js
  function assert4(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }

  // ../../node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (isBrowser3() && window_3.performance) {
      timestamp = window_3?.performance?.now?.();
    } else if ("hrtime" in process_) {
      const timeParts = process_?.hrtime?.();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // ../../node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser3() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = { once: true };
  var Log = class {
    constructor({ id } = { id: "" }) {
      this.VERSION = VERSION2;
      this._startTs = getHiResTimestamp2();
      this._deltaTs = getHiResTimestamp2();
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
      this.timeStamp(`${this.id} started`);
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable(enabled = true) {
      this._storage.setConfiguration({ enabled });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({ level });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({ [setting]: value });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message2) {
      if (!condition) {
        throw new Error(message2 || "Assertion failed");
      }
    }
    warn(message2) {
      return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
    }
    error(message2) {
      return this._getLogFunction(0, message2, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
    }
    removed(oldUsage, newUsage) {
      return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
    }
    info(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.info, arguments);
    }
    once(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    time(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
    }
    group(logLevel, message2, opts = { collapsed: false }) {
      const options = normalizeArguments({ logLevel, message: message2, opts });
      const { collapsed } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message2, opts = {}) {
      return this.group(logLevel, message2, Object.assign({}, opts, { collapsed: true }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message2, func) {
      this.group(logLevel, message2)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message2, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({ logLevel, message: message2, args, opts });
        method = method || opts.method;
        assert4(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp2();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp2();
          } else {
            return noop;
          }
        }
        message2 = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message2, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION2;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const { logLevel, message: message2 } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message2) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message2 !== void 0) {
          args.unshift(message2);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert4(messageType === "string" || messageType === "object");
    return Object.assign(opts, { args }, opts.opts);
  }
  function decorateMessage(id, message2, opts) {
    if (typeof message2 === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message2 = opts.time ? `${id}: ${time}  ${message2}` : `${id}: ${message2}`;
      message2 = addColor(message2, opts.color, opts.background);
    }
    return message2;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // ../../node_modules/@probe.gl/log/dist/init.js
  globalThis.probe = {};

  // ../../node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({ id: "@probe.gl/log" });

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
  var probeLog = new Log({
    id: "loaders.gl"
  });
  var NullLog = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var ConsoleLog = class {
    constructor() {
      this.console = void 0;
      this.console = console;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.console.log.bind(this.console, ...args);
    }
    info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.console.info.bind(this.console, ...args);
    }
    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.console.warn.bind(this.console, ...args);
    }
    error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.console.error.bind(this.console, ...args);
    }
  };

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
  var DEFAULT_LOADER_OPTIONS = {
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new ConsoleLog(),
    useLocalLibraries: false,
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: isBrowser,
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
  };
  var REMOVED_LOADER_OPTIONS = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
  function getGlobalLoaderState() {
    globalThis.loaders = globalThis.loaders || {};
    const {
      loaders
    } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
  }
  function getGlobalLoaderOptions() {
    const state = getGlobalLoaderState();
    state.globalOptions = state.globalOptions || {
      ...DEFAULT_LOADER_OPTIONS
    };
    return state.globalOptions;
  }
  function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
  }
  function validateOptions(options, loaders) {
    validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
    for (const loader of loaders) {
      const idOptions = options && options[loader.id] || {};
      const loaderOptions = loader.options && loader.options[loader.id] || {};
      const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  }
  function validateOptionsObject(options, id, defaultOptions2, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? `${id}.` : "";
    for (const key in options) {
      const isSubOptions = !id && isObject(options[key]);
      const isBaseUriOption = key === "baseUri" && !id;
      const isWorkerUrlOption = key === "workerUrl" && id;
      if (!(key in defaultOptions2) && !isBaseUriOption && !isWorkerUrlOption) {
        if (key in deprecatedOptions) {
          probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
        } else if (!isSubOptions) {
          const suggestion = findSimilarOption(key, loaders);
          probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders) {
      for (const key in loader.options) {
        if (optionKey === key) {
          return `Did you mean '${loader.id}.${key}'?`;
        }
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
        }
      }
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
      ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options) {
    for (const key in options) {
      if (key in options) {
        const value = options[key];
        if (isPureObject(value) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
          };
        } else {
          mergedOptions[key] = options[key];
        }
      }
    }
  }
  function addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) {
      options.baseUri = url;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
  function isLoaderObject(loader) {
    var _loader;
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
  }
  function normalizeLoader(loader) {
    var _loader2, _loader3;
    assert2(loader, "null loader");
    assert2(isLoaderObject(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
      options = loader[1];
      loader = loader[0];
      loader = {
        ...loader,
        options: {
          ...loader.options,
          ...options
        }
      };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
  var getGlobalLoaderRegistry = () => {
    const state = getGlobalLoaderState();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
  };
  function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    for (const loader of loaders) {
      const normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
        loaderRegistry.unshift(normalizedLoader);
      }
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/utils/log.js
  var log = new Log({
    id: "loaders.gl"
  });

  // ../../node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
  var EXT_PATTERN = /\.([^.]+)$/;
  async function selectLoader(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    let loader = selectLoaderSync(data, loaders, {
      ...options,
      nothrow: true
    }, context);
    if (loader) {
      return loader;
    }
    if (isBlob(data)) {
      data = await data.slice(0, 10).arrayBuffer();
      loader = selectLoaderSync(data, loaders, options, context);
    }
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderSync(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    let candidateLoaders = [];
    if (loaders) {
      candidateLoaders = candidateLoaders.concat(loaders);
    }
    if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
      candidateLoaders.push(...getRegisteredLoaders());
    }
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderInternal(data, loaders, options, context) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    const testUrl = stripQueryString(url) || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options !== null && options !== void 0 && options.mimeType) {
      loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
      reason = `match forced by supplied MIME type ${options === null || options === void 0 ? void 0 : options.mimeType}`;
    }
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? `matched url ${testUrl}` : "");
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? `matched MIME type ${type}` : "");
    loader = loader || findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? `matched initial data ${getFirstCharacters2(data)}` : "");
    if (options !== null && options !== void 0 && options.fallbackMimeType) {
      loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
      reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
    }
    if (reason) {
      var _loader;
      log.log(1, `selectLoader selected ${(_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name}: ${reason}.`);
    }
    return loader;
  }
  function validHTTPResponse(data) {
    if (data instanceof Response) {
      if (data.status === 204) {
        return false;
      }
    }
    return true;
  }
  function getNoValidLoaderMessage(data) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    let message2 = "No valid loader found (";
    message2 += url ? `${path_exports.filename(url)}, ` : "no url provided, ";
    message2 += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
    const firstCharacters = data ? getFirstCharacters2(data) : "";
    message2 += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
    message2 += ")";
    return message2;
  }
  function normalizeLoaders(loaders) {
    for (const loader of loaders) {
      normalizeLoader(loader);
    }
  }
  function findLoaderByUrl(loaders, url) {
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders) {
      for (const loaderExtension of loader.extensions) {
        if (loaderExtension.toLowerCase() === extension) {
          return loader;
        }
      }
    }
    return null;
  }
  function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders) {
      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }
      if (mimeType === `application/x.${loader.id}`) {
        return loader;
      }
    }
    return null;
  }
  function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
      return null;
    }
    for (const loader of loaders) {
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    if (loader.testText) {
      return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => data.startsWith(test));
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => testBinary(data, byteOffset, loader, test));
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (typeof test) {
      case "function":
        return test(data);
      case "string":
        const magic = getMagicString2(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters2(data) {
    let length6 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length6);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString2(data.buffer, data.byteOffset, length6);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString2(data, byteOffset, length6);
    }
    return "";
  }
  function getMagicString2(arrayBuffer2, byteOffset, length6) {
    if (arrayBuffer2.byteLength < byteOffset + length6) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i5 = 0; i5 < length6; i5++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i5));
    }
    return magic;
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
  var DEFAULT_CHUNK_SIZE = 256 * 1024;
  function* makeStringIterator(string, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while (offset < string.length) {
      const chunkLength = Math.min(string.length - offset, chunkSize);
      const chunk = string.slice(offset, offset + chunkLength);
      offset += chunkLength;
      yield textEncoder.encode(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
  var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  function makeArrayBufferIterator(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      const {
        chunkSize = DEFAULT_CHUNK_SIZE2
      } = options;
      let byteOffset = 0;
      while (byteOffset < arrayBuffer2.byteLength) {
        const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
      }
    }();
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
  var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  async function* makeBlobIterator(blob, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
    let offset = 0;
    while (offset < blob.size) {
      const end = offset + chunkSize;
      const chunk = await blob.slice(offset, end).arrayBuffer();
      offset = end;
      yield chunk;
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
  function makeStreamIterator(stream, options) {
    return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
  }
  async function* makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
      while (true) {
        const currentBatchPromise = nextBatchPromise || reader.read();
        if (options !== null && options !== void 0 && options._streamReadAhead) {
          nextBatchPromise = reader.read();
        }
        const {
          done,
          value
        } = await currentBatchPromise;
        if (done) {
          return;
        }
        yield toArrayBuffer2(value);
      }
    } catch (error) {
      reader.releaseLock();
    }
  }
  async function* makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream) {
      yield toArrayBuffer2(chunk);
    }
  }

  // ../../node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
  function makeIterator(data, options) {
    if (typeof data === "string") {
      return makeStringIterator(data, options);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data, options);
    }
    if (isResponse(data)) {
      const response = data;
      return makeStreamIterator(response.body, options);
    }
    throw new Error("makeIterator");
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (isBuffer2(data)) {
      data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
      const arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data)) {
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(data);
      }
      let arrayBuffer2 = data.buffer;
      const byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
        arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return arrayBuffer2;
    }
    throw new Error(ERR_DATA);
  }
  async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) {
      return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    if (isBlob(data)) {
      data = await makeResponse(data);
    }
    if (isResponse(data)) {
      const response = data;
      await checkResponse(response);
      return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if (isReadableStream(data)) {
      data = makeIterator(data, options);
    }
    if (isIterable(data) || isAsyncIterable(data)) {
      return concatenateArrayBuffersAsync(data);
    }
    throw new Error(ERR_DATA);
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
  function getFetchFunction2(options, context) {
    const globalOptions = getGlobalLoaderOptions();
    const loaderOptions = options || globalOptions;
    if (typeof loaderOptions.fetch === "function") {
      return loaderOptions.fetch;
    }
    if (isObject(loaderOptions.fetch)) {
      return (url) => fetchFile(url, loaderOptions.fetch);
    }
    if (context !== null && context !== void 0 && context.fetch) {
      return context === null || context === void 0 ? void 0 : context.fetch;
    }
    return fetchFile;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
  function getLoaderContext(context, options, parentContext) {
    if (parentContext) {
      return parentContext;
    }
    const newContext = {
      fetch: getFetchFunction2(options, context),
      ...context
    };
    if (newContext.url) {
      const baseUrl = stripQueryString(newContext.url);
      newContext.baseUrl = baseUrl;
      newContext.queryString = extractQueryString(newContext.url);
      newContext.filename = path_exports.filename(baseUrl);
      newContext.baseUrl = path_exports.dirname(baseUrl);
    }
    if (!Array.isArray(newContext.loaders)) {
      newContext.loaders = null;
    }
    return newContext;
  }
  function getLoadersFromContext(loaders, context) {
    if (loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    let candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : void 0;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/parse.js
  async function parse(data, loaders, options, context) {
    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    data = await data;
    options = options || {};
    const url = getResourceUrl(data);
    const typedLoaders = loaders;
    const candidateLoaders = getLoadersFromContext(typedLoaders, context);
    const loader = await selectLoader(data, candidateLoaders, options);
    if (!loader) {
      return null;
    }
    options = normalizeOptions(options, loader, candidateLoaders, url);
    context = getLoaderContext({
      url,
      _parse: parse,
      loaders: candidateLoaders
    }, options, context || null);
    return await parseWithLoader(loader, data, options, context);
  }
  async function parseWithLoader(loader, data, options, context) {
    validateWorkerVersion(loader);
    options = mergeLoaderOptions(loader.options, options);
    if (isResponse(data)) {
      const response = data;
      const {
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      } = response;
      const headers = Object.fromEntries(response.headers.entries());
      context.response = {
        headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      };
    }
    data = await getArrayBufferOrStringFromData(data, loader, options);
    const loaderWithParser = loader;
    if (loaderWithParser.parseTextSync && typeof data === "string") {
      return loaderWithParser.parseTextSync(data, options, context);
    }
    if (canParseWithWorker(loader, options)) {
      return await parseWithWorker(loader, data, options, context, parse);
    }
    if (loaderWithParser.parseText && typeof data === "string") {
      return await loaderWithParser.parseText(data, options, context);
    }
    if (loaderWithParser.parse) {
      return await loaderWithParser.parse(data, options, context);
    }
    assert3(!loaderWithParser.parseSync);
    throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
  function getDataTypeFromTypedArray(array) {
    switch (array.constructor) {
      case Int8Array:
        return "int8";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int16Array:
        return "int16";
      case Uint16Array:
        return "uint16";
      case Int32Array:
        return "int32";
      case Uint32Array:
        return "uint32";
      case Float32Array:
        return "float32";
      case Float64Array:
        return "float64";
      default:
        return "null";
    }
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/mesh/mesh-utils.js
  function getMeshBoundingBox(attributes) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    const positions = attributes.POSITION ? attributes.POSITION.value : [];
    const len4 = positions && positions.length;
    for (let i5 = 0; i5 < len4; i5 += 3) {
      const x3 = positions[i5];
      const y3 = positions[i5 + 1];
      const z2 = positions[i5 + 2];
      minX = x3 < minX ? x3 : minX;
      minY = y3 < minY ? y3 : minY;
      minZ = z2 < minZ ? z2 : minZ;
      maxX = x3 > maxX ? x3 : maxX;
      maxY = y3 > maxY ? y3 : maxY;
      maxZ = z2 > maxZ ? z2 : maxZ;
    }
    return [[minX, minY, minZ], [maxX, maxY, maxZ]];
  }

  // ../../node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js
  function deduceMeshField(name13, attribute, optionalMetadata) {
    const type = getDataTypeFromTypedArray(attribute.value);
    const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
    return {
      name: name13,
      type: {
        type: "fixed-size-list",
        listSize: attribute.size,
        children: [{
          name: "value",
          type
        }]
      },
      nullable: false,
      metadata
    };
  }
  function makeMeshAttributeMetadata(attribute) {
    const result = {};
    if ("byteOffset" in attribute) {
      result.byteOffset = attribute.byteOffset.toString(10);
    }
    if ("byteStride" in attribute) {
      result.byteStride = attribute.byteStride.toString(10);
    }
    if ("normalized" in attribute) {
      result.normalized = attribute.normalized.toString();
    }
    return result;
  }

  // ../../node_modules/@loaders.gl/core/dist/lib/api/load.js
  async function load(url, loaders, options, context) {
    let resolvedLoaders;
    let resolvedOptions;
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      resolvedLoaders = [];
      resolvedOptions = loaders;
      context = void 0;
    } else {
      resolvedLoaders = loaders;
      resolvedOptions = options;
    }
    const fetch2 = getFetchFunction2(resolvedOptions);
    let data = url;
    if (typeof url === "string") {
      data = await fetch2(url);
    }
    if (isBlob(url)) {
      data = await fetch2(url);
    }
    return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/utils/version.js
  var VERSION3 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
  var _globalThis$loaders;
  var parseImageNode = (_globalThis$loaders = globalThis.loaders) === null || _globalThis$loaders === void 0 ? void 0 : _globalThis$loaders.parseImageNode;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas2 = document.createElement("canvas");
        const context = canvas2.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas2.width = image.width;
        canvas2.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error) {
        throw new Error(error.message);
      }
      const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve2, reject) => {
      try {
        image.onload = () => resolve2(image);
        image.onerror = (error) => {
          const message2 = error instanceof Error ? error.message : "error";
          reject(new Error(message2));
        };
      } catch (error) {
        reject(error);
      }
    });
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error) {
        console.warn(error);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return {
          extension: "avif",
          mimeType: "image/avif"
        };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header) {
    let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const headerBytes = stringToBytes(header);
    for (let i5 = 0; i5 < headerBytes.length; ++i5) {
      if (headerBytes[i5] !== buffer[i5 + offset]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i5 = 2;
    while (i5 + 9 < dataView.byteLength) {
      const marker2 = dataView.getUint16(i5, BIG_ENDIAN);
      if (sofMarkers.has(marker2)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i5 + 5, BIG_ENDIAN),
          width: dataView.getUint16(i5 + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker2)) {
        return null;
      }
      i5 += 2;
      i5 += dataView.getUint16(i5, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i5 = 65504; i5 < 65520; ++i5) {
      tableMarkers.add(i5);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options) {
    var _globalThis$loaders2;
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer2) || {};
    const parseImageNode2 = (_globalThis$loaders2 = globalThis.loaders) === null || _globalThis$loaders2 === void 0 ? void 0 : _globalThis$loaders2.parseImageNode;
    assert2(parseImageNode2);
    return await parseImageNode2(arrayBuffer2, mimeType);
  }

  // ../../node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options);
        break;
      default:
        assert2(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // ../../node_modules/@loaders.gl/images/dist/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // ../../node_modules/@loaders.gl/images/dist/lib/category-api/image-format.js
  var mimeTypeSupportedSync = {};
  function isImageFormatSupported(mimeType) {
    if (mimeTypeSupportedSync[mimeType] === void 0) {
      const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
      mimeTypeSupportedSync[mimeType] = supported;
    }
    return mimeTypeSupportedSync[mimeType];
  }
  function checkNodeImageFormatSupport(mimeType) {
    var _globalThis$loaders2, _globalThis$loaders22;
    const NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
    const imageFormatsNode = ((_globalThis$loaders2 = globalThis.loaders) === null || _globalThis$loaders2 === void 0 ? void 0 : _globalThis$loaders2.imageFormatsNode) || NODE_FORMAT_SUPPORT;
    const parseImageNode2 = (_globalThis$loaders22 = globalThis.loaders) === null || _globalThis$loaders22 === void 0 ? void 0 : _globalThis$loaders22.parseImageNode;
    return Boolean(parseImageNode2) && imageFormatsNode.includes(mimeType);
  }
  function checkBrowserImageFormatSupport(mimeType) {
    switch (mimeType) {
      case "image/avif":
      case "image/webp":
        return testBrowserImageFormatSupport(mimeType);
      default:
        return true;
    }
  }
  function testBrowserImageFormatSupport(mimeType) {
    try {
      const element = document.createElement("canvas");
      const dataURL = element.toDataURL(mimeType);
      return dataURL.indexOf(`data:${mimeType}`) === 0;
    } catch {
      return false;
    }
  }

  // ../core/src/utils/log.ts
  var defaultLogger = new Log({ id: "deck" });
  var log_default = defaultLogger;

  // ../core/src/debug/loggers.ts
  var logState = {
    attributeUpdateStart: -1,
    attributeManagerUpdateStart: -1,
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = (log3) => ({
    "layer.changeFlag": (layer, key, flags) => {
      log3.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();
    },
    "layer.initialize": (layer) => {
      log3.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();
    },
    "layer.update": (layer, needsUpdate) => {
      if (needsUpdate) {
        const flags = layer.getChangeFlags();
        log3.log(
          LOG_LEVEL_MINOR_UPDATE,
          `Updating ${layer} because: ${Object.keys(flags).filter((key) => flags[key]).join(", ")}`
        )();
      } else {
        log3.log(LOG_LEVEL_INFO, `${layer} does not need update`)();
      }
    },
    "layer.matched": (layer, changed) => {
      if (changed) {
        log3.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();
      }
    },
    "layer.finalize": (layer) => {
      log3.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();
    },
    "compositeLayer.renderLayers": (layer, updated, subLayers) => {
      if (updated) {
        log3.log(
          LOG_LEVEL_MINOR_UPDATE,
          `Composite layer rendered new subLayers ${layer}`,
          subLayers
        )();
      } else {
        log3.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();
      }
    },
    "layerManager.setLayers": (layerManager, updated, layers) => {
      if (updated) {
        log3.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();
      }
    },
    "layerManager.activateViewport": (layerManager, viewport) => {
      log3.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
    },
    "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
      log3.log(
        LOG_LEVEL_MAJOR_UPDATE,
        attributeNames ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}` : `invalidated all attributes for ${attributeManager.id}`
      )();
    },
    "attributeManager.updateStart": (attributeManager) => {
      logState.attributeUpdateMessages.length = 0;
      logState.attributeManagerUpdateStart = Date.now();
    },
    "attributeManager.updateEnd": (attributeManager, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
      log3.groupCollapsed(
        LOG_LEVEL_MINOR_UPDATE,
        `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`
      )();
      for (const updateMessage of logState.attributeUpdateMessages) {
        log3.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
      }
      log3.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
    },
    "attribute.updateStart": (attribute) => {
      logState.attributeUpdateStart = Date.now();
    },
    "attribute.allocate": (attribute, numInstances) => {
      const message2 = `${attribute.id} allocated ${numInstances}`;
      logState.attributeUpdateMessages.push(message2);
    },
    "attribute.updateEnd": (attribute, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
      const message2 = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;
      logState.attributeUpdateMessages.push(message2);
    },
    "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
      const { pass, redrawReason, stats } = opts;
      for (const status of renderStats) {
        const { totalCount, visibleCount, compositeCount, pickableCount } = status;
        const primitiveCount = totalCount - compositeCount;
        const hiddenCount = primitiveCount - visibleCount;
        log3.log(
          LOG_LEVEL_DRAW,
          `RENDER #${deckRenderer.renderCount}   ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason}   (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`
        )();
        if (stats) {
          stats.get("Redraw Layers").add(visibleCount);
        }
      }
    }
  });

  // ../core/src/debug/index.ts
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType, arg1, arg2, arg3) {
    if (log_default.level > 0 && loggers[eventType]) {
      loggers[eventType].call(null, arg1, arg2, arg3);
    }
  }

  // ../core/src/utils/json-loader.ts
  function isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // ../core/src/lib/init.ts
  function checkVersion() {
    const version = typeof __VERSION__ !== "undefined" ? __VERSION__ : globalThis.DECK_VERSION || "untranspiled source";
    const existingVersion = globalThis.deck && globalThis.deck.VERSION;
    if (existingVersion && existingVersion !== version) {
      throw new Error(`deck.gl - multiple versions detected: ${existingVersion} vs ${version}`);
    }
    if (!existingVersion) {
      log_default.log(1, `deck.gl ${version}`)();
      globalThis.deck = {
        ...globalThis.deck,
        VERSION: version,
        version,
        log: log_default,
        _registerLoggers: register
      };
      registerLoaders([
        json_loader_default,
        [ImageLoader, { imagebitmap: { premultiplyAlpha: "none" } }]
      ]);
    }
    return version;
  }
  var VERSION4 = checkVersion();

  // ../../node_modules/@luma.gl/shadertools/dist/lib/utils/assert.js
  function assert5(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "shadertools: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/filters/prop-types.js
  var DEFAULT_PROP_VALIDATORS = {
    number: {
      type: "number",
      validate(value, propType) {
        return Number.isFinite(value) && typeof propType === "object" && (propType.max === void 0 || value <= propType.max) && (propType.min === void 0 || value >= propType.min);
      }
    },
    array: {
      type: "array",
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function makePropValidators(propTypes) {
    const propValidators = {};
    for (const [name13, propType] of Object.entries(propTypes)) {
      propValidators[name13] = makePropValidator(propType);
    }
    return propValidators;
  }
  function getValidatedProperties(properties, propValidators, errorMessage) {
    const validated = {};
    for (const [key, propsValidator] of Object.entries(propValidators)) {
      if (properties && key in properties && !propsValidator.private) {
        if (propsValidator.validate) {
          assert5(propsValidator.validate(properties[key], propsValidator), `${errorMessage}: invalid ${key}`);
        }
        validated[key] = properties[key];
      } else {
        validated[key] = propsValidator.value;
      }
    }
    return validated;
  }
  function makePropValidator(propType) {
    let type = getTypeOf(propType);
    if (type !== "object") {
      return { value: propType, ...DEFAULT_PROP_VALIDATORS[type], type };
    }
    if (typeof propType === "object") {
      if (!propType) {
        return { type: "object", value: null };
      }
      if (propType.type !== void 0) {
        return { ...propType, ...DEFAULT_PROP_VALIDATORS[propType.type], type: propType.type };
      }
      if (propType.value === void 0) {
        return { type: "object", value: propType };
      }
      type = getTypeOf(propType.value);
      return { ...propType, ...DEFAULT_PROP_VALIDATORS[type], type };
    }
    throw new Error("props");
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/module-injectors.js
  var MODULE_INJECTORS_VS = `#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`;
  var MODULE_INJECTORS_FS = `#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`;

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js
  var MODULE_INJECTORS = {
    vertex: MODULE_INJECTORS_VS,
    fragment: MODULE_INJECTORS_FS
  };
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  function normalizeInjections(injections) {
    const result = { vertex: {}, fragment: {} };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = getHookStage(hook);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }
  function getHookStage(hook) {
    const type = hook.slice(0, 2);
    switch (type) {
      case "vs":
        return "vertex";
      case "fs":
        return "fragment";
      default:
        throw new Error(type);
    }
  }
  function injectShader(source, stage, inject6, injectStandardStubs = false) {
    const isVertex = stage === "vertex";
    for (const key in inject6) {
      const fragmentData = inject6[key];
      fragmentData.sort((a3, b2) => a3.order - b2.order);
      fragments.length = fragmentData.length;
      for (let i5 = 0, len4 = fragmentData.length; i5 < len4; ++i5) {
        fragments[i5] = fragmentData[i5].injection;
      }
      const fragmentString = `${fragments.join("\n")}
`;
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[stage]);
    }
    return source;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-module/shader-module-instance.js
  var index = 1;
  var ShaderModuleInstance = class {
    name;
    vs;
    fs;
    getModuleUniforms;
    dependencies;
    deprecations;
    defines;
    injections;
    uniforms = {};
    uniformTypes = {};
    static instantiateModules(modules) {
      return modules.map((module) => {
        if (module instanceof ShaderModuleInstance) {
          return module;
        }
        assert5(typeof module !== "string", `Shader module use by name is deprecated. Import shader module '${JSON.stringify(module)}' and use it directly.`);
        if (!module.name) {
          console.warn("shader module has no name");
          module.name = `shader-module-${index++}`;
        }
        const moduleObject = new ShaderModuleInstance(module);
        moduleObject.dependencies = ShaderModuleInstance.instantiateModules(module.dependencies || []);
        return moduleObject;
      });
    }
    constructor(props) {
      const { name: name13, vs: vs13, fs: fs10, dependencies = [], uniformPropTypes = {}, getUniforms: getUniforms8, deprecations = [], defines: defines2 = {}, inject: inject6 = {} } = props;
      assert5(typeof name13 === "string");
      this.name = name13;
      this.vs = vs13;
      this.fs = fs10;
      this.getModuleUniforms = getUniforms8;
      this.dependencies = ShaderModuleInstance.instantiateModules(dependencies);
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines2;
      this.injections = normalizeInjections(inject6);
      if (uniformPropTypes) {
        this.uniforms = makePropValidators(uniformPropTypes);
      }
    }
    getModuleSource(stage) {
      let moduleSource;
      switch (stage) {
        case "vertex":
          moduleSource = this.vs || "";
          break;
        case "fragment":
          moduleSource = this.fs || "";
          break;
        default:
          assert5(false);
      }
      const moduleName = this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
      return `// ----- MODULE ${this.name} ---------------

#define MODULE_${moduleName}
${moduleSource}

`;
    }
    getUniforms(userProps, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(userProps, uniforms);
      }
      return getValidatedProperties(userProps, this.uniforms, this.name);
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log3) {
      this.deprecations.forEach((def) => {
        if (def.regex?.test(shaderSource)) {
          if (def.deprecated) {
            log3.deprecated(def.old, def.new)();
          } else {
            log3.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp(`\\b${def.old}\\(`);
            break;
          default:
            def.regex = new RegExp(`${def.type} ${def.old};`);
        }
      });
      return deprecations;
    }
    _defaultGetUniforms(opts = {}) {
      const uniforms = {};
      const propTypes = this.uniforms;
      for (const key in propTypes) {
        const propDef = propTypes[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert5(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/select-shaders.js
  function selectShaders(props) {
    if (props.source && props.platformInfo.type === "webgpu") {
      const propsCopy = { ...props, vs: void 0, fs: void 0 };
      return propsCopy;
    }
    if (!props.vs) {
      throw new Error("no vertex shader");
    }
    const vs13 = getShaderSource(props.platformInfo, props.vs);
    let fs10;
    if (props.fs) {
      fs10 = getShaderSource(props.platformInfo, props.fs);
    }
    return { ...props, vs: vs13, fs: fs10 };
  }
  function getShaderSource(platformInfo, shader) {
    if (typeof shader === "string") {
      return shader;
    }
    switch (platformInfo.type) {
      case "webgpu":
        if (shader?.wgsl) {
          return shader.wgsl;
        }
        throw new Error("WebGPU does not support GLSL shaders");
      default:
        if (shader?.glsl) {
          return shader.glsl;
        }
        throw new Error("WebGL does not support WGSL shaders");
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/resolve-modules.js
  function resolveModules(modules) {
    const instances = ShaderModuleInstance.instantiateModules(modules);
    return getShaderDependencies(instances);
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({ modules, level: 0, moduleMap, moduleDepth });
    return Object.keys(moduleDepth).sort((a3, b2) => moduleDepth[b2] - moduleDepth[a3]).map((name13) => moduleMap[name13]);
  }
  function getDependencyGraph(options) {
    const { modules, level, moduleMap, moduleDepth } = options;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module of modules) {
      moduleMap[module.name] = module;
      if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
    for (const module of modules) {
      if (module.dependencies) {
        getDependencyGraph({ modules: module.dependencies, level: level + 1, moduleMap, moduleDepth });
      }
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js
  function getPlatformShaderDefines(platformInfo) {
    switch (platformInfo?.gpu.toLowerCase()) {
      case "apple":
        return `#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "nvidia":
        return `#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
      case "intel":
        return `#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "amd":
        return `#define AMD_GPU
`;
      default:
        return `#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js
  function transpileGLSLShader(source, stage) {
    const sourceGLSLVersion = Number(source.match(/^#version[ \t]+(\d+)/m)?.[1] || 100);
    if (sourceGLSLVersion !== 300) {
      throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
    }
    switch (stage) {
      case "vertex":
        source = convertShader(source, ES300_VERTEX_REPLACEMENTS);
        return source;
      case "fragment":
        source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
        return source;
      default:
        throw new Error(stage);
    }
  }
  var ES300_REPLACEMENTS = [
    [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"],
    [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
    [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
  ];
  var ES300_VERTEX_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    [makeVariableTextRegExp("attribute"), "in $1"],
    [makeVariableTextRegExp("varying"), "out $1"]
  ];
  var ES300_FRAGMENT_REPLACEMENTS = [
    ...ES300_REPLACEMENTS,
    [makeVariableTextRegExp("varying"), "in $1"]
  ];
  function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements) {
      source = source.replace(pattern, replacement);
    }
    return source;
  }
  function makeVariableTextRegExp(qualifier) {
    return new RegExp(`\\b${qualifier}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js
  function getShaderHooks(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += `void ${hookFunction.signature} {
`;
      if (hookFunction.header) {
        result += `  ${hookFunction.header}`;
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a3, b2) => a3.order - b2.order);
        for (const injection of injections) {
          result += `  ${injection.injection}
`;
        }
      }
      if (hookFunction.footer) {
        result += `  ${hookFunction.footer}`;
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeShaderHooks(hookFunctions) {
    const result = { vertex: {}, fragment: {} };
    for (const hookFunction of hookFunctions) {
      let opts;
      let hook;
      if (typeof hookFunction !== "string") {
        opts = hookFunction;
        hook = opts.hook;
      } else {
        opts = {};
        hook = hookFunction;
      }
      hook = hook.trim();
      const [shaderStage, signature] = hook.split(":");
      const name13 = hook.replace(/\(.+/, "");
      const normalizedHook = Object.assign(opts, { signature });
      switch (shaderStage) {
        case "vs":
          result.vertex[name13] = normalizedHook;
          break;
        case "fs":
          result.fragment[name13] = normalizedHook;
          break;
        default:
          throw new Error(shaderStage);
      }
    }
    return result;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/get-shader-info.js
  function getShaderInfo(source, defaultName) {
    return {
      name: getShaderName(source, defaultName),
      language: "glsl",
      version: getShaderVersion(source)
    };
  }
  function getShaderName(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const parsedVersion = parseInt(words[1], 10);
      if (Number.isFinite(parsedVersion)) {
        version = parsedVersion;
      }
    }
    if (version !== 100 && version !== 300) {
      throw new Error(`Invalid GLSL version ${version}`);
    }
    return version;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = `

${DECLARATION_INJECT_MARKER}
`;
  var FRAGMENT_SHADER_PROLOGUE = `precision highp float;
`;
  function assembleShaderWGSL(options) {
    const modules = resolveModules(options.modules || []);
    return {
      source: assembleWGSLShader(options.platformInfo, {
        ...options,
        source: options.source,
        stage: "vertex",
        modules
      }),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShaderPairWGSL(options) {
    const modules = resolveModules(options.modules || []);
    return {
      vs: assembleWGSLShader(options.platformInfo, {
        ...options,
        source: options.vs,
        stage: "vertex",
        modules
      }),
      fs: assembleWGSLShader(options.platformInfo, {
        ...options,
        source: options.fs,
        stage: "fragment",
        modules
      }),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShaderPairGLSL(options) {
    const { vs: vs13, fs: fs10 } = options;
    const modules = resolveModules(options.modules || []);
    return {
      vs: assembleGLSLShader(options.platformInfo, {
        ...options,
        source: vs13,
        stage: "vertex",
        modules
      }),
      fs: assembleGLSLShader(options.platformInfo, {
        ...options,
        source: fs10,
        stage: "fragment",
        modules
      }),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleWGSLShader(platformInfo, options) {
    const {
      source,
      stage,
      modules,
      hookFunctions = [],
      inject: inject6 = {},
      log: log3
    } = options;
    assert5(typeof source === "string", "shader source must be a string");
    const coreSource = source;
    let assembledSource = "";
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject6) {
      const injection = typeof inject6[key] === "string" ? { injection: inject6[key], order: 0 } : inject6[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name13 = match[3];
        if (hash) {
          if (name13 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    const modulesToInject = platformInfo.type !== "webgpu" ? modules : [];
    for (const module of modulesToInject) {
      if (log3) {
        module.checkDeprecations(coreSource, log3);
      }
      const moduleSource = module.getModuleSource(stage, "wgsl");
      assembledSource += moduleSource;
      const injections = module.injections[stage];
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name13 = match[2];
          const injectionType = name13 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    return assembledSource;
  }
  function assembleGLSLShader(platformInfo, options) {
    const { id, source, stage, language = "glsl", modules, defines: defines2 = {}, hookFunctions = [], inject: inject6 = {}, prologue = true, log: log3 } = options;
    assert5(typeof source === "string", "shader source must be a string");
    const sourceVersion = language === "glsl" ? getShaderInfo(source).version : -1;
    const targetVersion = platformInfo.shaderLanguageVersion;
    const sourceVersionDirective = sourceVersion === 100 ? "#version 100" : "#version 300 es";
    const sourceLines = source.split("\n");
    const coreSource = sourceLines.slice(1).join("\n");
    const allDefines = {};
    modules.forEach((module) => {
      Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines2);
    let assembledSource = "";
    switch (language) {
      case "wgsl":
        break;
      case "glsl":
        assembledSource = prologue ? `${sourceVersionDirective}

// ----- PROLOGUE -------------------------
${getShaderNameDefine({ id, source, stage })}
${`#define SHADER_TYPE_${stage.toUpperCase()}`}
${getPlatformShaderDefines(platformInfo)}
${stage === "fragment" ? FRAGMENT_SHADER_PROLOGUE : ""}

// ----- APPLICATION DEFINES -------------------------

${getApplicationDefines(allDefines)}

` : `${sourceVersionDirective}
`;
        break;
    }
    const hookFunctionMap = normalizeShaderHooks(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject6) {
      const injection = typeof inject6[key] === "string" ? { injection: inject6[key], order: 0 } : inject6[key];
      const match = /^(v|f)s:(#)?([\w-]+)$/.exec(key);
      if (match) {
        const hash = match[2];
        const name13 = match[3];
        if (hash) {
          if (name13 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module of modules) {
      if (log3) {
        module.checkDeprecations(coreSource, log3);
      }
      const moduleSource = module.getModuleSource(stage);
      assembledSource += moduleSource;
      const injections = module.injections[stage];
      for (const key in injections) {
        const match = /^(v|f)s:#([\w-]+)$/.exec(key);
        if (match) {
          const name13 = match[2];
          const injectionType = name13 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += "// ----- MAIN SHADER SOURCE -------------------------";
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, stage, declInjections);
    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, stage, mainInjections);
    if (language === "glsl" && sourceVersion !== targetVersion) {
      assembledSource = transpileGLSLShader(assembledSource, stage);
    }
    return assembledSource.trim();
  }
  function assembleGetUniforms(modules) {
    return function getUniforms8(opts) {
      const uniforms = {};
      for (const module of modules) {
        const moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderNameDefine(options) {
    const { id, source, stage } = options;
    const injectShaderName = id && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? `
#define SHADER_NAME ${id}_${stage}

` : "";
  }
  function getApplicationDefines(defines2 = {}) {
    let sourceText = "";
    for (const define2 in defines2) {
      const value = defines2[define2];
      if (value || Number.isFinite(value)) {
        sourceText += `#define ${define2.toUpperCase()} ${defines2[define2]}
`;
      }
    }
    return sourceText;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js
  var _ShaderAssembler = class {
    _hookFunctions = [];
    _defaultModules = [];
    static getDefaultShaderAssembler() {
      _ShaderAssembler.defaultShaderAssembler = _ShaderAssembler.defaultShaderAssembler || new _ShaderAssembler();
      return _ShaderAssembler.defaultShaderAssembler;
    }
    addDefaultModule(module) {
      if (!this._defaultModules.find((m2) => m2.name === (typeof module === "string" ? module : module.name))) {
        this._defaultModules.push(module);
      }
    }
    removeDefaultModule(module) {
      const moduleName = typeof module === "string" ? module : module.name;
      this._defaultModules = this._defaultModules.filter((m2) => m2.name !== moduleName);
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, { hook });
      }
      this._hookFunctions.push(hook);
    }
    assembleShader(props) {
      const modules = this._getModuleList(props.modules);
      const hookFunctions = this._hookFunctions;
      const options = selectShaders(props);
      const assembled = assembleShaderWGSL({
        platformInfo: props.platformInfo,
        ...options,
        modules,
        hookFunctions
      });
      return { ...assembled, modules };
    }
    assembleShaderPair(props) {
      const options = selectShaders(props);
      const modules = this._getModuleList(props.modules);
      const hookFunctions = this._hookFunctions;
      const { platformInfo } = props;
      const isWGSL = props.platformInfo.shaderLanguage === "wgsl";
      const assembled = isWGSL ? assembleShaderPairWGSL({ platformInfo, ...options, modules, hookFunctions }) : assembleShaderPairGLSL({ platformInfo, ...options, modules, hookFunctions });
      return { ...assembled, modules };
    }
    _getModuleList(appModules = []) {
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count2 = 0;
      for (let i5 = 0, len4 = this._defaultModules.length; i5 < len4; ++i5) {
        const module = this._defaultModules[i5];
        const name13 = module.name;
        modules[count2++] = module;
        seen[name13] = true;
      }
      for (let i5 = 0, len4 = appModules.length; i5 < len4; ++i5) {
        const module = appModules[i5];
        const name13 = module.name;
        if (!seen[name13]) {
          modules[count2++] = module;
          seen[name13] = true;
        }
      }
      modules.length = count2;
      return ShaderModuleInstance.instantiateModules(modules);
    }
  };
  var ShaderAssembler = _ShaderAssembler;
  __publicField(ShaderAssembler, "defaultShaderAssembler");

  // ../../node_modules/@luma.gl/shadertools/dist/lib/shader-module/normalize-shader-module.js
  function normalizeShaderModule(module) {
    if (!module.normalized) {
      module.normalized = true;
      if (module.uniformPropTypes && !module.getUniforms) {
        const shaderModule2 = new ShaderModuleInstance(module);
        module.getUniforms = shaderModule2.getUniforms.bind(shaderModule2);
      }
    }
    return module;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js
  var FS_GLES = `out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`;
  var FS300 = `#version 300 es
${FS_GLES}`;
  function getPassthroughFS(options) {
    const { input, inputChannels, output } = options || {};
    if (!input) {
      return FS300;
    }
    if (!inputChannels) {
      throw new Error("inputChannels");
    }
    const inputType = channelCountToType(inputChannels);
    const outputValue = convertToVec4(input, inputChannels);
    return `#version 300 es
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
  }
  function channelCountToType(channels) {
    switch (channels) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }
  function convertToVec4(variable, channels) {
    switch (channels) {
      case 1:
        return `vec4(${variable}, 0.0, 0.0, 1.0)`;
      case 2:
        return `vec4(${variable}, 0.0, 1.0)`;
      case 3:
        return `vec4(${variable}, 1.0)`;
      case 4:
        return variable;
      default:
        throw new Error(`invalid channels: ${channels}`);
    }
  }

  // ../../node_modules/@luma.gl/core/dist/utils/log.js
  var log2 = new Log({ id: "luma.gl" });

  // ../../node_modules/@luma.gl/core/dist/utils/stats-manager.js
  var StatsManager = class {
    stats = /* @__PURE__ */ new Map();
    getStats(name13) {
      return this.get(name13);
    }
    get(name13) {
      if (!this.stats.has(name13)) {
        this.stats.set(name13, new Stats({ id: name13 }));
      }
      return this.stats.get(name13);
    }
  };
  var lumaStats = new StatsManager();

  // ../../node_modules/@luma.gl/core/dist/init.js
  function initializeLuma() {
    const VERSION15 = true ? "9.0.9" : "running from source";
    const STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION15) {
      throw new Error(`luma.gl - multiple VERSIONs detected: ${globalThis.luma.VERSION} vs ${VERSION15}`);
    }
    if (!globalThis.luma) {
      if (isBrowser3()) {
        log2.log(1, `${VERSION15} - ${STARTUP_MESSAGE}`)();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION15,
        version: VERSION15,
        log: log2,
        stats: lumaStats
      };
    }
    return VERSION15;
  }
  var VERSION5 = initializeLuma();

  // ../../node_modules/@luma.gl/core/dist/utils/is-array.js
  function isTypedArray(value) {
    return ArrayBuffer.isView(value) && !(value instanceof DataView) ? value : null;
  }
  function isNumberArray(value) {
    if (Array.isArray(value)) {
      return value.length === 0 || typeof value[0] === "number" ? value : null;
    }
    return isTypedArray(value);
  }

  // ../../node_modules/@luma.gl/core/dist/utils/utils.js
  var uidCounters = {};
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count2 = uidCounters[id]++;
    return `${id}-${count2}`;
  }
  function isObjectEmpty(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/resource.js
  var Resource = class {
    id;
    props;
    userData = {};
    _device;
    destroyed = false;
    allocatedBytes = 0;
    _attachedResources = /* @__PURE__ */ new Set();
    constructor(device, props, defaultProps53) {
      if (!device) {
        throw new Error("no device");
      }
      this._device = device;
      this.props = selectivelyMerge(props, defaultProps53);
      const id = this.props.id !== "undefined" ? this.props.id : uid(this[Symbol.toStringTag]);
      this.props.id = id;
      this.id = id;
      this.userData = this.props.userData || {};
      this.addStats();
    }
    destroy() {
      this.destroyResource();
    }
    delete() {
      this.destroy();
      return this;
    }
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}(${this.id})`;
    }
    getProps() {
      return this.props;
    }
    attachResource(resource) {
      this._attachedResources.add(resource);
    }
    detachResource(resource) {
      this._attachedResources.delete(resource);
    }
    destroyAttachedResource(resource) {
      if (this._attachedResources.delete(resource)) {
        resource.destroy();
      }
    }
    destroyAttachedResources() {
      for (const resource of Object.values(this._attachedResources)) {
        resource.destroy();
      }
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    destroyResource() {
      this.destroyAttachedResources();
      this.removeStats();
      this.destroyed = true;
    }
    removeStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name13 = this[Symbol.toStringTag];
      stats.get(`${name13}s Active`).decrementCount();
    }
    trackAllocatedMemory(bytes, name13 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").addCount(bytes);
      stats.get(`${name13} Memory`).addCount(bytes);
      this.allocatedBytes = bytes;
    }
    trackDeallocatedMemory(name13 = this[Symbol.toStringTag]) {
      const stats = this._device.statsManager.getStats("Resource Counts");
      stats.get("GPU Memory").subtractCount(this.allocatedBytes);
      stats.get(`${name13} Memory`).subtractCount(this.allocatedBytes);
      this.allocatedBytes = 0;
    }
    addStats() {
      const stats = this._device.statsManager.getStats("Resource Counts");
      const name13 = this[Symbol.toStringTag];
      stats.get("Resources Created").incrementCount();
      stats.get(`${name13}s Created`).incrementCount();
      stats.get(`${name13}s Active`).incrementCount();
    }
  };
  __publicField(Resource, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  });
  function selectivelyMerge(props, defaultProps53) {
    const mergedProps = { ...defaultProps53 };
    for (const key in props) {
      if (props[key] !== void 0) {
        mergedProps[key] = props[key];
      }
    }
    return mergedProps;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/buffer.js
  var _Buffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    usage;
    indexType;
    updateTimestamp;
    constructor(device, props) {
      const deducedProps = { ...props };
      if ((props.usage || 0) & _Buffer.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          deducedProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          deducedProps.indexType = "uint16";
        }
      }
      super(device, deducedProps, _Buffer.defaultProps);
      this.usage = props.usage || 0;
      this.indexType = deducedProps.indexType;
      this.updateTimestamp = device.incrementTimestamp();
    }
    readSyncWebGL(byteOffset, byteLength) {
      throw new Error("not implemented");
    }
    debugData = new ArrayBuffer(0);
    _setDebugData(data, byteOffset, byteLength) {
      const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
      const debugDataLength = Math.min(data ? data.byteLength : byteLength, _Buffer.DEBUG_DATA_MAX_LENGTH);
      if (data === null) {
        this.debugData = new ArrayBuffer(debugDataLength);
      } else if (byteOffset === 0 && byteLength === data.byteLength) {
        this.debugData = buffer.slice(0, debugDataLength);
      } else {
        this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
      }
    }
  };
  var Buffer2 = _Buffer;
  __publicField(Buffer2, "defaultProps", {
    ...Resource.defaultProps,
    usage: 0,
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  __publicField(Buffer2, "MAP_READ", 1);
  __publicField(Buffer2, "MAP_WRITE", 2);
  __publicField(Buffer2, "COPY_SRC", 4);
  __publicField(Buffer2, "COPY_DST", 8);
  __publicField(Buffer2, "INDEX", 16);
  __publicField(Buffer2, "VERTEX", 32);
  __publicField(Buffer2, "UNIFORM", 64);
  __publicField(Buffer2, "STORAGE", 128);
  __publicField(Buffer2, "INDIRECT", 256);
  __publicField(Buffer2, "QUERY_RESOLVE", 512);
  __publicField(Buffer2, "DEBUG_DATA_MAX_LENGTH", 32);

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-data-type.js
  function decodeVertexType(type) {
    const dataType = TYPE_MAP[type];
    const bytes = getDataTypeBytes(dataType);
    const normalized = type.includes("norm");
    const integer = !normalized && !type.startsWith("float");
    const signed = type.startsWith("s");
    return {
      dataType: TYPE_MAP[type],
      byteLength: bytes,
      integer,
      signed,
      normalized
    };
  }
  function getDataTypeBytes(type) {
    const bytes = TYPE_SIZES[type];
    return bytes;
  }
  var TYPE_MAP = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  };
  var TYPE_SIZES = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  };

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-texture-format.js
  var COMPRESSED_TEXTURE_FORMAT_PREFIXES = [
    "bc1",
    "bc2",
    "bc3",
    "bc4",
    "bc5",
    "bc6",
    "bc7",
    "etc1",
    "etc2",
    "eac",
    "atc",
    "astc",
    "pvrtc"
  ];
  var REGEX = /^(rg?b?a?)([0-9]*)([a-z]*)(-srgb)?(-webgl|-unsized)?$/;
  function isTextureFormatCompressed(textureFormat) {
    return COMPRESSED_TEXTURE_FORMAT_PREFIXES.some((prefix) => textureFormat.startsWith(prefix));
  }
  function decodeTextureFormat(format) {
    const matches3 = REGEX.exec(format);
    if (matches3) {
      const [, format2, length6, type, srgb, suffix] = matches3;
      if (format2) {
        const dataType = `${type}${length6}`;
        const decodedType = decodeVertexType(dataType);
        return {
          format: format2,
          components: format2.length,
          srgb: srgb === "-srgb",
          unsized: suffix === "-unsized",
          webgl: suffix === "-webgl",
          ...decodedType
        };
      }
    }
    return decodeNonStandardFormat(format);
  }
  var EXCEPTIONS = {
    "rgba4unorm-webgl": { format: "rgba", bpp: 2 },
    "rgb565unorm-webgl": { format: "rgb", bpp: 2 },
    "rgb5a1unorm-webgl": { format: "rgba", bbp: 2 },
    rgb9e5ufloat: { format: "rgb", bbp: 4 },
    rg11b10ufloat: { format: "rgb", bbp: 4 },
    rgb10a2unorm: { format: "rgba", bbp: 4 },
    "rgb10a2uint-webgl": { format: "rgba", bbp: 4 },
    stencil8: { components: 1, bpp: 1, a: "stencil" },
    depth16unorm: { components: 1, bpp: 2, a: "depth" },
    depth24plus: { components: 1, bpp: 3, a: "depth" },
    depth32float: { components: 1, bpp: 4, a: "depth" },
    "depth24plus-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
    "depth24unorm-stencil8": { components: 2, bpp: 4, a: "depth-stencil" },
    "depth32float-stencil8": { components: 2, bpp: 4, a: "depth-stencil" }
  };
  function decodeNonStandardFormat(format) {
    const data = EXCEPTIONS[format];
    if (!data) {
      throw new Error(`Unknown format ${format}`);
    }
    return {
      format: data.format || "",
      components: data.components || data.format?.length || 1,
      byteLength: data.bpp || 1,
      srgb: false,
      unsized: false
    };
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/device.js
  var DeviceLimits = class {
  };
  var DeviceFeatures = class {
    features;
    disabledFeatures;
    constructor(features = [], disabledFeatures) {
      this.features = new Set(features);
      this.disabledFeatures = disabledFeatures || {};
    }
    *[Symbol.iterator]() {
      yield* this.features;
    }
    has(feature) {
      return !this.disabledFeatures[feature] && this.features.has(feature);
    }
  };
  var _Device = class {
    get [Symbol.toStringTag]() {
      return "Device";
    }
    constructor(props) {
      this.props = { ..._Device.defaultProps, ...props };
      this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    id;
    props;
    userData = {};
    statsManager = lumaStats;
    _lumaData = {};
    isTextureFormatCompressed(format) {
      return isTextureFormatCompressed(format);
    }
    loseDevice() {
      return false;
    }
    getCanvasContext() {
      if (!this.canvasContext) {
        throw new Error("Device has no CanvasContext");
      }
      return this.canvasContext;
    }
    createTexture(props) {
      if (props instanceof Promise || typeof props === "string") {
        props = { data: props };
      }
      return this._createTexture(props);
    }
    createCommandEncoder(props = {}) {
      throw new Error("not implemented");
    }
    readPixelsToArrayWebGL(source, options) {
      throw new Error("not implemented");
    }
    readPixelsToBufferWebGL(source, options) {
      throw new Error("not implemented");
    }
    setParametersWebGL(parameters2) {
      throw new Error("not implemented");
    }
    getParametersWebGL(parameters2) {
      throw new Error("not implemented");
    }
    withParametersWebGL(parameters2, func) {
      throw new Error("not implemented");
    }
    clearWebGL(options) {
      throw new Error("not implemented");
    }
    resetWebGL() {
      throw new Error("not implemented");
    }
    timestamp = 0;
    incrementTimestamp() {
      return this.timestamp++;
    }
    onError(error) {
      this.props.onError(error);
    }
    _getBufferProps(props) {
      if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
        props = { data: props };
      }
      const newProps = { ...props };
      if ((props.usage || 0) & Buffer2.INDEX && !props.indexType) {
        if (props.data instanceof Uint32Array) {
          newProps.indexType = "uint32";
        } else if (props.data instanceof Uint16Array) {
          newProps.indexType = "uint16";
        } else {
          log2.warn("indices buffer content must be of integer type")();
        }
      }
      return newProps;
    }
  };
  var Device = _Device;
  __publicField(Device, "defaultProps", {
    id: null,
    canvas: null,
    container: null,
    manageState: true,
    width: 800,
    height: 600,
    requestMaxLimits: true,
    debug: Boolean(log2.get("debug")),
    spector: Boolean(log2.get("spector")),
    break: [],
    initalizeFeatures: true,
    disabledFeatures: {
      "compilation-status-async-webgl": true
    },
    gl: null,
    onError: (error) => log2.error(error.message)
  });
  __publicField(Device, "VERSION", VERSION5);

  // ../../node_modules/@luma.gl/core/dist/utils/assert.js
  function assert6(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "luma.gl: assertion failed.");
    }
  }

  // ../../node_modules/@luma.gl/core/dist/lib/luma.js
  var deviceMap = /* @__PURE__ */ new Map();
  var luma = class {
    static registerDevices(deviceClasses) {
      for (const deviceClass of deviceClasses) {
        assert6(deviceClass.type && deviceClass.isSupported && deviceClass.create);
        deviceMap.set(deviceClass.type, deviceClass);
      }
    }
    static getAvailableDevices() {
      return Array.from(deviceMap).map((Device3) => Device3.type);
    }
    static getSupportedDevices() {
      return Array.from(deviceMap).filter((Device3) => Device3.isSupported()).map((Device3) => Device3.type);
    }
    static setDefaultDeviceProps(props) {
      Object.assign(Device.defaultProps, props);
    }
    static async attachDevice(props) {
      const devices = getDeviceMap(props.devices) || deviceMap;
      if (props.handle instanceof WebGL2RenderingContext) {
        const WebGLDevice2 = devices.get("webgl");
        if (WebGLDevice2) {
          return await WebGLDevice2.attach(props.handle);
        }
      }
      if (props.handle === null) {
        const UnknownDevice = devices.get("unknown");
        if (UnknownDevice) {
          return await UnknownDevice.attach(null);
        }
      }
      throw new Error("Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
    }
    static async createDevice(props = {}) {
      props = { ...Device.defaultProps, ...props };
      if (props.gl) {
        props.type = "webgl";
      }
      const devices = getDeviceMap(props.devices) || deviceMap;
      switch (props.type) {
        case "webgpu":
          let WebGPUDevice = devices.get("webgpu");
          if (WebGPUDevice) {
            return await WebGPUDevice.create(props);
          }
          break;
        case "webgl":
          let WebGLDevice2 = devices.get("webgl");
          if (WebGLDevice2) {
            return await WebGLDevice2.create(props);
          }
          break;
        case "unknown":
          const UnknownDevice = devices.get("unknown");
          if (UnknownDevice) {
            return await UnknownDevice.create(props);
          }
          break;
        case "best-available":
          WebGPUDevice = devices.get("webgpu");
          if (WebGPUDevice?.isSupported?.()) {
            return await WebGPUDevice.create(props);
          }
          WebGLDevice2 = devices.get("webgl");
          if (WebGLDevice2?.isSupported?.()) {
            return await WebGLDevice2.create(props);
          }
          break;
      }
      throw new Error("No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.");
    }
  };
  __publicField(luma, "defaultProps", {
    ...Device.defaultProps,
    type: "best-available",
    devices: void 0
  });
  __publicField(luma, "stats", lumaStats);
  __publicField(luma, "log", log2);
  function getDeviceMap(deviceClasses) {
    if (!deviceClasses || deviceClasses?.length === 0) {
      return null;
    }
    const map3 = /* @__PURE__ */ new Map();
    for (const deviceClass of deviceClasses) {
      map3.set(deviceClass.type, deviceClass);
    }
    return map3;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/canvas-context.js
  var isPage = isBrowser3() && typeof document !== "undefined";
  var isPageLoaded = () => isPage && document.readyState === "complete";
  var DEFAULT_CANVAS_CONTEXT_PROPS = {
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: true,
    autoResize: true,
    container: null,
    visible: true,
    colorSpace: "srgb",
    alphaMode: "opaque"
  };
  var CanvasContext = class {
    id;
    props;
    canvas;
    htmlCanvas;
    offscreenCanvas;
    type;
    width = 1;
    height = 1;
    resizeObserver;
    _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
    static get isPageLoaded() {
      return isPageLoaded();
    }
    constructor(props) {
      this.props = { ...DEFAULT_CANVAS_CONTEXT_PROPS, ...props };
      props = this.props;
      if (!isBrowser3()) {
        this.id = "node-canvas-context";
        this.type = "node";
        this.width = this.props.width;
        this.height = this.props.height;
        this.canvas = null;
        return;
      }
      if (!props.canvas) {
        const canvas2 = createCanvas(props);
        const container = getContainer(props?.container || null);
        container.insertBefore(canvas2, container.firstChild);
        this.canvas = canvas2;
        if (!props?.visible) {
          this.canvas.style.visibility = "hidden";
        }
      } else if (typeof props.canvas === "string") {
        this.canvas = getCanvasFromDOM(props.canvas);
      } else {
        this.canvas = props.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement) {
        this.id = this.canvas.id;
        this.type = "html-canvas";
        this.htmlCanvas = this.canvas;
      } else {
        this.id = "offscreen-canvas";
        this.type = "offscreen-canvas";
        this.offscreenCanvas = this.canvas;
      }
      if (this.canvas instanceof HTMLCanvasElement && props.autoResize) {
        this.resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvas) {
              this.update();
            }
          }
        });
        this.resizeObserver.observe(this.canvas);
      }
    }
    getDevicePixelRatio(useDevicePixels) {
      if (typeof OffscreenCanvas !== "undefined" && this.canvas instanceof OffscreenCanvas) {
        return 1;
      }
      useDevicePixels = useDevicePixels === void 0 ? this.props.useDevicePixels : useDevicePixels;
      if (!useDevicePixels || useDevicePixels <= 0) {
        return 1;
      }
      if (useDevicePixels === true) {
        const dpr = typeof window !== "undefined" && window.devicePixelRatio;
        return dpr || 1;
      }
      return useDevicePixels;
    }
    getPixelSize() {
      switch (this.type) {
        case "node":
          return [this.width, this.height];
        case "offscreen-canvas":
          return [this.canvas.width, this.canvas.height];
        case "html-canvas":
          const dpr = this.getDevicePixelRatio();
          const canvas2 = this.canvas;
          return canvas2.parentElement ? [canvas2.clientWidth * dpr, canvas2.clientHeight * dpr] : [this.canvas.width, this.canvas.height];
        default:
          throw new Error(this.type);
      }
    }
    getAspect() {
      const [width, height] = this.getPixelSize();
      return width / height;
    }
    cssToDeviceRatio() {
      try {
        const [drawingBufferWidth] = this.getDrawingBufferSize();
        const { clientWidth } = this._canvasSizeInfo;
        return clientWidth ? drawingBufferWidth / clientWidth : 1;
      } catch {
        return 1;
      }
    }
    cssToDevicePixels(cssPixel, yInvert = true) {
      const ratio = this.cssToDeviceRatio();
      const [width, height] = this.getDrawingBufferSize();
      return scalePixels(cssPixel, ratio, width, height, yInvert);
    }
    setDevicePixelRatio(devicePixelRatio, options = {}) {
      if (!this.htmlCanvas) {
        return;
      }
      let clientWidth = "width" in options ? options.width : this.htmlCanvas.clientWidth;
      let clientHeight = "height" in options ? options.height : this.htmlCanvas.clientHeight;
      if (!clientWidth || !clientHeight) {
        log2.log(1, "Canvas clientWidth/clientHeight is 0")();
        devicePixelRatio = 1;
        clientWidth = this.htmlCanvas.width || 1;
        clientHeight = this.htmlCanvas.height || 1;
      }
      const cachedSize = this._canvasSizeInfo;
      if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
        let clampedPixelRatio = devicePixelRatio;
        const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
        const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
        this.htmlCanvas.width = canvasWidth;
        this.htmlCanvas.height = canvasHeight;
        const [drawingBufferWidth, drawingBufferHeight] = this.getDrawingBufferSize();
        if (drawingBufferWidth !== canvasWidth || drawingBufferHeight !== canvasHeight) {
          clampedPixelRatio = Math.min(drawingBufferWidth / clientWidth, drawingBufferHeight / clientHeight);
          this.htmlCanvas.width = Math.floor(clientWidth * clampedPixelRatio);
          this.htmlCanvas.height = Math.floor(clientHeight * clampedPixelRatio);
          log2.warn("Device pixel ratio clamped")();
        }
        this._canvasSizeInfo.clientWidth = clientWidth;
        this._canvasSizeInfo.clientHeight = clientHeight;
        this._canvasSizeInfo.devicePixelRatio = devicePixelRatio;
      }
    }
    getDrawingBufferSize() {
      const gl = this.device.gl;
      if (!gl) {
        throw new Error("canvas size");
      }
      return [gl.drawingBufferWidth, gl.drawingBufferHeight];
    }
    _setAutoCreatedCanvasId(id) {
      if (this.htmlCanvas?.id === "lumagl-auto-created-canvas") {
        this.htmlCanvas.id = id;
      }
    }
  };
  __publicField(CanvasContext, "pageLoaded", getPageLoadPromise());
  function getPageLoadPromise() {
    if (isPageLoaded() || typeof window === "undefined") {
      return Promise.resolve();
    }
    return new Promise((resolve2) => {
      window.addEventListener("load", () => resolve2());
    });
  }
  function getContainer(container) {
    if (typeof container === "string") {
      const element = document.getElementById(container);
      if (!element && !isPageLoaded()) {
        throw new Error(`Accessing '${container}' before page was loaded`);
      }
      if (!element) {
        throw new Error(`${container} is not an HTML element`);
      }
      return element;
    } else if (container) {
      return container;
    }
    return document.body;
  }
  function getCanvasFromDOM(canvasId) {
    const canvas2 = document.getElementById(canvasId);
    if (!canvas2 && !isPageLoaded()) {
      throw new Error(`Accessing '${canvasId}' before page was loaded`);
    }
    if (!(canvas2 instanceof HTMLCanvasElement)) {
      throw new Error("Object is not a canvas element");
    }
    return canvas2;
  }
  function createCanvas(props) {
    const { width, height } = props;
    const targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-auto-created-canvas";
    targetCanvas.width = width || 1;
    targetCanvas.height = height || 1;
    targetCanvas.style.width = Number.isFinite(width) ? `${width}px` : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? `${height}px` : "100%";
    return targetCanvas;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const point = pixel;
    const x3 = scaleX(point[0], ratio, width);
    let y3 = scaleY(point[1], ratio, height, yInvert);
    let t3 = scaleX(point[0] + 1, ratio, width);
    const xHigh = t3 === width - 1 ? t3 : t3 - 1;
    t3 = scaleY(point[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t3 = t3 === 0 ? t3 : t3 + 1;
      yHigh = y3;
      y3 = t3;
    } else {
      yHigh = t3 === height - 1 ? t3 : t3 - 1;
    }
    return {
      x: x3,
      y: y3,
      width: Math.max(xHigh - x3 + 1, 1),
      height: Math.max(yHigh - y3 + 1, 1)
    };
  }
  function scaleX(x3, ratio, width) {
    const r3 = Math.min(Math.round(x3 * ratio), width - 1);
    return r3;
  }
  function scaleY(y3, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y3 * ratio)) : Math.min(Math.round(y3 * ratio), height - 1);
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/texture.js
  var _Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    dimension;
    format;
    width;
    height;
    depth;
    updateTimestamp;
    constructor(device, props, defaultProps53 = _Texture.defaultProps) {
      super(device, props, defaultProps53);
      this.dimension = this.props.dimension;
      this.format = this.props.format;
      this.width = this.props.width;
      this.height = this.props.height;
      this.depth = this.props.depth;
      this.updateTimestamp = device.incrementTimestamp();
    }
  };
  var Texture = _Texture;
  __publicField(Texture, "defaultProps", {
    ...Resource.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: true,
    compressed: false,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    type: void 0,
    sampler: {},
    view: void 0
  });
  __publicField(Texture, "COPY_SRC", 1);
  __publicField(Texture, "COPY_DST", 2);
  __publicField(Texture, "TEXTURE_BINDING", 4);
  __publicField(Texture, "STORAGE_BINDING", 8);
  __publicField(Texture, "RENDER_ATTACHMENT", 16);

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/texture-view.js
  var _TextureView = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TextureView";
    }
    constructor(device, props) {
      super(device, props, _TextureView.defaultProps);
    }
  };
  var TextureView = _TextureView;
  __publicField(TextureView, "defaultProps", {
    ...Resource.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/lib/compiler-log/format-compiler-log.js
  function formatCompilerLog(shaderLog, source, options) {
    let formattedLog = "";
    const lines = source.split(/\r?\n/);
    const log3 = shaderLog.slice().sort((a3, b2) => a3.lineNum - b2.lineNum);
    switch (options?.showSourceCode || "no") {
      case "all":
        let currentMessage = 0;
        for (let lineNum = 1; lineNum <= lines.length; lineNum++) {
          formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);
          while (log3.length > currentMessage && log3[currentMessage].lineNum === lineNum) {
            const message2 = log3[currentMessage++];
            formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
              ...options,
              inlineSource: false
            });
          }
        }
        return formattedLog;
      case "issues":
      case "no":
        for (const message2 of shaderLog) {
          formattedLog += formatCompilerMessage(message2, lines, message2.lineNum, {
            inlineSource: options?.showSourceCode !== "no"
          });
        }
        return formattedLog;
    }
  }
  function formatCompilerMessage(message2, lines, lineNum, options) {
    if (options?.inlineSource) {
      const numberedLines = getNumberedLines(lines, lineNum);
      const positionIndicator = message2.linePos > 0 ? `${" ".repeat(message2.linePos + 5)}^^^
` : "";
      return `
${numberedLines}${positionIndicator}${message2.type.toUpperCase()}: ${message2.message}

`;
    }
    return options?.html ? `<div class='luma-compiler-log-error' style="color:red;"><b> ${message2.type.toUpperCase()}: ${message2.message}</b></div>` : `${message2.type.toUpperCase()}: ${message2.message}`;
  }
  function getNumberedLines(lines, lineNum, options) {
    let numberedLines = "";
    for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {
      const sourceLine = lines[lineIndex - 1];
      if (sourceLine !== void 0) {
        numberedLines += getNumberedLine(sourceLine, lineNum, options);
      }
    }
    return numberedLines;
  }
  function getNumberedLine(line, lineNum, options) {
    const escapedLine = options?.html ? escapeHTML(line) : line;
    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? "<br/>" : "\n"}`;
  }
  function padLeft(string, paddedLength) {
    let result = "";
    for (let i5 = string.length; i5 < paddedLength; ++i5) {
      result += " ";
    }
    return result + string;
  }
  function escapeHTML(unsafe) {
    return unsafe.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }

  // ../../node_modules/@luma.gl/core/dist/lib/compiler-log/get-shader-info.js
  function getShaderInfo2(source, defaultName) {
    return {
      name: getShaderName2(source, defaultName),
      language: "glsl",
      version: getShaderVersion2(source)
    };
  }
  function getShaderName2(shader, defaultName = "unnamed") {
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = SHADER_NAME_REGEXP.exec(shader);
    return match ? match[1] : defaultName;
  }
  function getShaderVersion2(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words && words.length >= 2 && words[0] === "#version") {
      const v2 = parseInt(words[1], 10);
      if (Number.isFinite(v2)) {
        version = v2;
      }
    }
    return version;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/shader.js
  var _Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    stage;
    source;
    compilationStatus = "pending";
    constructor(device, props) {
      super(device, { id: getShaderIdFromProps(props), ...props }, _Shader.defaultProps);
      this.stage = this.props.stage;
      this.source = this.props.source;
    }
    getCompilationInfoSync() {
      return null;
    }
    getTranslatedSource() {
      return null;
    }
    async debugShader(trigger = this.props.debug) {
      switch (trigger) {
        case "never":
          return;
        case "errors":
          if (this.compilationStatus === "success") {
            return;
          }
          break;
        case "warnings":
        case "always":
          break;
      }
      const messages = await this.getCompilationInfo();
      if (this.props.debug === "warnings" && messages?.length === 0) {
        return;
      }
      this._displayShaderLog(messages);
    }
    _displayShaderLog(messages) {
      if (typeof document === "undefined" || !document?.createElement) {
        return;
      }
      const shaderName = getShaderInfo2(this.source).name;
      const shaderTitle = `${this.stage} ${shaderName}`;
      let htmlLog = formatCompilerLog(messages, this.source, { showSourceCode: "all", html: true });
      const translatedSource = this.getTranslatedSource();
      if (translatedSource) {
        htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${translatedSource}</pre></code>`;
      }
      const button = document.createElement("Button");
      button.innerHTML = `
<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />
<code style="user-select:text;"><pre>
${htmlLog}
</pre></code>`;
      button.style.top = "10px";
      button.style.left = "10px";
      button.style.position = "absolute";
      button.style.zIndex = "9999";
      button.style.width = "100%";
      button.style.textAlign = "left";
      document.body.appendChild(button);
      const errors = document.getElementsByClassName("luma-compiler-log-error");
      if (errors[0]?.scrollIntoView) {
        errors[0].scrollIntoView();
      }
      button.onclick = () => {
        const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;
        navigator.clipboard.writeText(dataURI);
      };
    }
  };
  var Shader = _Shader;
  __publicField(Shader, "defaultProps", {
    ...Resource.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debug: "errors"
  });
  function getShaderIdFromProps(props) {
    return getShaderInfo2(props.source).name || props.id || uid(`unnamed ${props.stage}-shader`);
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/sampler.js
  var _Sampler = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Sampler";
    }
    constructor(device, props) {
      super(device, props, _Sampler.defaultProps);
    }
  };
  var Sampler = _Sampler;
  __publicField(Sampler, "defaultProps", {
    ...Resource.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "nearest",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    compare: "less-equal",
    maxAnisotropy: 1
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/framebuffer.js
  var _Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    width;
    height;
    colorAttachments = [];
    depthStencilAttachment = null;
    constructor(device, props = {}) {
      super(device, props, _Framebuffer.defaultProps);
      this.width = this.props.width;
      this.height = this.props.height;
    }
    resize(size) {
      let updateSize = !size;
      if (size) {
        const [width, height] = Array.isArray(size) ? size : [size.width, size.height];
        updateSize = updateSize || height !== this.height || width !== this.width;
        this.width = width;
        this.height = height;
      }
      if (updateSize) {
        log2.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)();
        this.resizeAttachments(this.width, this.height);
      }
    }
    autoCreateAttachmentTextures() {
      if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) {
        throw new Error("Framebuffer has noattachments");
      }
      this.colorAttachments = this.props.colorAttachments.map((attachment2) => {
        if (typeof attachment2 === "string") {
          const texture = this.createColorTexture(attachment2);
          this.attachResource(texture);
          return texture.view;
        }
        if (attachment2 instanceof Texture) {
          return attachment2.view;
        }
        return attachment2;
      });
      const attachment = this.props.depthStencilAttachment;
      if (attachment) {
        if (typeof attachment === "string") {
          const texture = this.createDepthStencilTexture(attachment);
          this.attachResource(texture);
          this.depthStencilAttachment = texture.view;
        } else if (attachment instanceof Texture) {
          this.depthStencilAttachment = attachment.view;
        } else {
          this.depthStencilAttachment = attachment;
        }
      }
    }
    createColorTexture(format) {
      return this.device.createTexture({
        id: "color-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    createDepthStencilTexture(format) {
      return this.device.createTexture({
        id: "depth-stencil-attachment",
        usage: Texture.RENDER_ATTACHMENT,
        format,
        width: this.width,
        height: this.height
      });
    }
    resizeAttachments(width, height) {
      for (let i5 = 0; i5 < this.colorAttachments.length; ++i5) {
        if (this.colorAttachments[i5]) {
          const resizedTexture = this.device._createTexture({
            ...this.colorAttachments[i5].props,
            width,
            height
          });
          this.destroyAttachedResource(this.colorAttachments[i5]);
          this.colorAttachments[i5] = resizedTexture.view;
          this.attachResource(resizedTexture.view);
        }
      }
      if (this.depthStencilAttachment) {
        const resizedTexture = this.device._createTexture({
          ...this.depthStencilAttachment.props,
          width,
          height
        });
        this.destroyAttachedResource(this.depthStencilAttachment);
        this.depthStencilAttachment = resizedTexture.view;
        this.attachResource(resizedTexture);
      }
    }
  };
  var Framebuffer = _Framebuffer;
  __publicField(Framebuffer, "defaultProps", {
    ...Resource.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    depthStencilAttachment: null
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/render-pipeline.js
  var _RenderPipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    shaderLayout;
    bufferLayout;
    linkStatus = "pending";
    hash = "";
    constructor(device, props) {
      super(device, props, _RenderPipeline.defaultProps);
      this.shaderLayout = this.props.shaderLayout;
      this.bufferLayout = this.props.bufferLayout || [];
    }
    setUniformsWebGL(uniforms) {
      throw new Error("Use uniform blocks");
    }
  };
  var RenderPipeline = _RenderPipeline;
  __publicField(RenderPipeline, "defaultProps", {
    ...Resource.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    vertexCount: 0,
    instanceCount: 0,
    bindings: {},
    uniforms: {}
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/render-pass.js
  var _RenderPass = class extends Resource {
    get [Symbol.toStringTag]() {
      return "RenderPass";
    }
    constructor(device, props) {
      super(device, props, _RenderPass.defaultProps);
    }
  };
  var RenderPass = _RenderPass;
  __publicField(RenderPass, "defaultProps", {
    ...Resource.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: [0, 0, 0, 0],
    clearDepth: 1,
    clearStencil: 0,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/compute-pipeline.js
  var _ComputePipeline = class extends Resource {
    get [Symbol.toStringTag]() {
      return "ComputePipeline";
    }
    hash = "";
    constructor(device, props) {
      super(device, props, _ComputePipeline.defaultProps);
    }
  };
  var ComputePipeline = _ComputePipeline;
  __publicField(ComputePipeline, "defaultProps", {
    ...Resource.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/command-encoder.js
  var _CommandEncoder = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandEncoder";
    }
    constructor(device, props) {
      super(device, props, _CommandEncoder.defaultProps);
    }
  };
  var CommandEncoder = _CommandEncoder;
  __publicField(CommandEncoder, "defaultProps", {
    ...Resource.defaultProps,
    measureExecutionTime: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/command-buffer.js
  var _CommandBuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "CommandBuffer";
    }
    constructor(device, props) {
      super(device, props, _CommandBuffer.defaultProps);
    }
  };
  var CommandBuffer = _CommandBuffer;
  __publicField(CommandBuffer, "defaultProps", {
    ...Resource.defaultProps
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-attribute-type.js
  function decodeShaderAttributeType(attributeType) {
    const [dataType, components] = TYPE_INFO[attributeType];
    const integer = dataType === "i32" || dataType === "u32";
    const signed = dataType !== "u32";
    const byteLength = TYPE_SIZES2[dataType] * components;
    const defaultVertexFormat = getCompatibleVertexFormat(dataType, components);
    return {
      dataType,
      components,
      defaultVertexFormat,
      byteLength,
      integer,
      signed
    };
  }
  function getCompatibleVertexFormat(dataType, components) {
    let vertexType;
    switch (dataType) {
      case "f32":
        vertexType = "float32";
        break;
      case "i32":
        vertexType = "sint32";
        break;
      case "u32":
        vertexType = "uint32";
        break;
      case "f16":
        return components <= 2 ? "float16x2" : "float16x4";
    }
    if (components === 1) {
      return vertexType;
    }
    return `${vertexType}x${components}`;
  }
  var TYPE_INFO = {
    f32: ["f32", 1],
    "vec2<f32>": ["f32", 2],
    "vec3<f32>": ["f32", 3],
    "vec4<f32>": ["f32", 4],
    f16: ["f16", 1],
    "vec2<f16>": ["f16", 2],
    "vec3<f16>": ["f16", 3],
    "vec4<f16>": ["f16", 4],
    i32: ["i32", 1],
    "vec2<i32>": ["i32", 2],
    "vec3<i32>": ["i32", 3],
    "vec4<i32>": ["i32", 4],
    u32: ["u32", 1],
    "vec2<u32>": ["u32", 2],
    "vec3<u32>": ["u32", 3],
    "vec4<u32>": ["u32", 4]
  };
  var TYPE_SIZES2 = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
  };

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-vertex-format.js
  function decodeVertexFormat(format) {
    let webglOnly;
    if (format.endsWith("-webgl")) {
      format.replace("-webgl", "");
      webglOnly = true;
    }
    const [type_, count2] = format.split("x");
    const type = type_;
    const components = count2 ? parseInt(count2) : 1;
    const decodedType = decodeVertexType(type);
    const result = {
      type,
      components,
      byteLength: decodedType.byteLength * components,
      integer: decodedType.integer,
      signed: decodedType.signed,
      normalized: decodedType.normalized
    };
    if (webglOnly) {
      result.webglOnly = true;
    }
    return result;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/attribute-utils/get-attribute-from-layouts.js
  function getAttributeInfosFromLayouts(shaderLayout, bufferLayout) {
    const attributeInfos = {};
    for (const attribute of shaderLayout.attributes) {
      attributeInfos[attribute.name] = getAttributeInfoFromLayouts(shaderLayout, bufferLayout, attribute.name);
    }
    return attributeInfos;
  }
  function getAttributeInfosByLocation(shaderLayout, bufferLayout, maxVertexAttributes = 16) {
    const attributeInfos = getAttributeInfosFromLayouts(shaderLayout, bufferLayout);
    const locationInfos = new Array(maxVertexAttributes).fill(null);
    for (const attributeInfo of Object.values(attributeInfos)) {
      locationInfos[attributeInfo.location] = attributeInfo;
    }
    return locationInfos;
  }
  function getAttributeInfoFromLayouts(shaderLayout, bufferLayout, name13) {
    const shaderDeclaration = getAttributeFromShaderLayout(shaderLayout, name13);
    const bufferMapping = getAttributeFromBufferLayout(bufferLayout, name13);
    if (!shaderDeclaration) {
      return null;
    }
    const attributeTypeInfo = decodeShaderAttributeType(shaderDeclaration.type);
    const vertexFormat = bufferMapping?.vertexFormat || attributeTypeInfo.defaultVertexFormat;
    const vertexFormatInfo = decodeVertexFormat(vertexFormat);
    return {
      attributeName: bufferMapping?.attributeName || shaderDeclaration.name,
      bufferName: bufferMapping?.bufferName || shaderDeclaration.name,
      location: shaderDeclaration.location,
      shaderType: shaderDeclaration.type,
      shaderDataType: attributeTypeInfo.dataType,
      shaderComponents: attributeTypeInfo.components,
      vertexFormat,
      bufferDataType: vertexFormatInfo.type,
      bufferComponents: vertexFormatInfo.components,
      normalized: vertexFormatInfo.normalized,
      integer: attributeTypeInfo.integer,
      stepMode: bufferMapping?.stepMode || shaderDeclaration.stepMode,
      byteOffset: bufferMapping?.byteOffset || 0,
      byteStride: bufferMapping?.byteStride || 0
    };
  }
  function getAttributeFromShaderLayout(shaderLayout, name13) {
    const attribute = shaderLayout.attributes.find((attr) => attr.name === name13);
    if (!attribute) {
      log2.warn(`shader layout attribute "${name13}" not present in shader`);
    }
    return attribute || null;
  }
  function getAttributeFromBufferLayout(bufferLayouts, name13) {
    checkBufferLayouts(bufferLayouts);
    let bufferLayoutInfo = getAttributeFromShortHand(bufferLayouts, name13);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    bufferLayoutInfo = getAttributeFromAttributesList(bufferLayouts, name13);
    if (bufferLayoutInfo) {
      return bufferLayoutInfo;
    }
    log2.warn(`layout for attribute "${name13}" not present in buffer layout`);
    return null;
  }
  function checkBufferLayouts(bufferLayouts) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.attributes && bufferLayout.format || !bufferLayout.attributes && !bufferLayout.format) {
        log2.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
      }
    }
  }
  function getAttributeFromShortHand(bufferLayouts, name13) {
    for (const bufferLayout of bufferLayouts) {
      if (bufferLayout.format && bufferLayout.name === name13) {
        return {
          attributeName: bufferLayout.name,
          bufferName: name13,
          stepMode: bufferLayout.stepMode,
          vertexFormat: bufferLayout.format,
          byteOffset: 0,
          byteStride: bufferLayout.byteStride || 0
        };
      }
    }
    return null;
  }
  function getAttributeFromAttributesList(bufferLayouts, name13) {
    for (const bufferLayout of bufferLayouts) {
      let byteStride = bufferLayout.byteStride;
      if (typeof bufferLayout.byteStride !== "number") {
        for (const attributeMapping2 of bufferLayout.attributes || []) {
          const info = decodeVertexFormat(attributeMapping2.format);
          byteStride += info.byteLength;
        }
      }
      const attributeMapping = bufferLayout.attributes?.find((mapping) => mapping.attribute === name13);
      if (attributeMapping) {
        return {
          attributeName: attributeMapping.attribute,
          bufferName: bufferLayout.name,
          stepMode: bufferLayout.stepMode,
          vertexFormat: attributeMapping.format,
          byteOffset: attributeMapping.byteOffset,
          byteStride
        };
      }
    }
    return null;
  }
  function mergeShaderLayout(baseLayout, overrideLayout) {
    const mergedLayout = {
      ...baseLayout,
      attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
    };
    for (const attribute of overrideLayout?.attributes || []) {
      const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
      if (!baseAttribute) {
        log2.warn(`shader layout attribute ${attribute.name} not present in shader`);
      } else {
        baseAttribute.type = attribute.type || baseAttribute.type;
        baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
      }
    }
    return mergedLayout;
  }

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/vertex-array.js
  var _VertexArray = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    maxVertexAttributes;
    attributeInfos;
    indexBuffer = null;
    attributes;
    constructor(device, props) {
      super(device, props, _VertexArray.defaultProps);
      this.maxVertexAttributes = device.limits.maxVertexAttributes;
      this.attributes = new Array(this.maxVertexAttributes).fill(null);
      this.attributeInfos = getAttributeInfosByLocation(props.renderPipeline.shaderLayout, props.renderPipeline.bufferLayout, this.maxVertexAttributes);
    }
    setConstantWebGL(location, value) {
      throw new Error("constant attributes not supported");
    }
  };
  var VertexArray = _VertexArray;
  __publicField(VertexArray, "defaultProps", {
    ...Resource.defaultProps,
    renderPipeline: null
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/transform-feedback.js
  var _TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    constructor(device, props) {
      super(device, props, _TransformFeedback.defaultProps);
    }
  };
  var TransformFeedback = _TransformFeedback;
  __publicField(TransformFeedback, "defaultProps", {
    ...Resource.defaultProps,
    layout: void 0,
    buffers: {}
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/resources/query-set.js
  var _QuerySet = class extends Resource {
    get [Symbol.toStringTag]() {
      return "QuerySet";
    }
    constructor(device, props) {
      super(device, props, _QuerySet.defaultProps);
    }
  };
  var QuerySet = _QuerySet;
  __publicField(QuerySet, "defaultProps", {
    ...Resource.defaultProps,
    type: void 0,
    count: void 0
  });

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/decode-shader-types.js
  var UNIFORM_FORMATS = {
    f32: { type: "f32", components: 1 },
    i32: { type: "i32", components: 1 },
    u32: { type: "u32", components: 1 },
    "vec2<f32>": { type: "f32", components: 2 },
    "vec3<f32>": { type: "f32", components: 3 },
    "vec4<f32>": { type: "f32", components: 4 },
    "vec2<i32>": { type: "i32", components: 2 },
    "vec3<i32>": { type: "i32", components: 3 },
    "vec4<i32>": { type: "i32", components: 4 },
    "vec2<u32>": { type: "u32", components: 2 },
    "vec3<u32>": { type: "u32", components: 3 },
    "vec4<u32>": { type: "u32", components: 4 },
    "mat2x2<f32>": { type: "f32", components: 4 },
    "mat2x3<f32>": { type: "f32", components: 6 },
    "mat2x4<f32>": { type: "f32", components: 8 },
    "mat3x2<f32>": { type: "f32", components: 6 },
    "mat3x3<f32>": { type: "f32", components: 9 },
    "mat3x4<f32>": { type: "f32", components: 12 },
    "mat4x2<f32>": { type: "f32", components: 8 },
    "mat4x3<f32>": { type: "f32", components: 12 },
    "mat4x4<f32>": { type: "f32", components: 16 }
  };
  function decodeShaderUniformType(format) {
    const decoded = UNIFORM_FORMATS[format];
    assert6(format);
    return decoded;
  }
  function alignTo(size, count2) {
    switch (count2) {
      case 1:
        return size;
      case 2:
        return size + size % 2;
      default:
        return size + (4 - size % 4) % 4;
    }
  }

  // ../../node_modules/@luma.gl/core/dist/utils/array-utils-flat.js
  var arrayBuffer;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type2, length6) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type2.BYTES_PER_ELEMENT * length6);
    return new Type2(scratchArrayBuffer, 0, length6);
  }
  function fillArray(options) {
    const { target, source, start = 0, count: count2 = 1 } = options;
    const length6 = source.length;
    const total = count2 * length6;
    let copied = 0;
    for (let i5 = start; copied < length6; copied++) {
      target[i5++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return options.target;
  }

  // ../../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-buffer-layout.js
  var minBufferSize = 1024;
  var UniformBufferLayout = class {
    layout = {};
    byteLength;
    constructor(uniformTypes) {
      let size = 0;
      for (const [key, uniformType] of Object.entries(uniformTypes)) {
        const typeAndComponents = decodeShaderUniformType(uniformType);
        const { type, components: count2 } = typeAndComponents;
        size = alignTo(size, count2);
        const offset = size;
        size += count2;
        this.layout[key] = { type, size: count2, offset };
      }
      size += (4 - size % 4) % 4;
      const actualByteLength = size * 4;
      this.byteLength = Math.max(actualByteLength, minBufferSize);
    }
    getData(uniformValues) {
      const bufferSize = Math.max(this.byteLength, minBufferSize);
      const arrayBuffer2 = getScratchArrayBuffer(bufferSize);
      const typedArrays = {
        i32: new Int32Array(arrayBuffer2),
        u32: new Uint32Array(arrayBuffer2),
        f32: new Float32Array(arrayBuffer2),
        f16: new Uint16Array(arrayBuffer2)
      };
      for (const [name13, value] of Object.entries(uniformValues)) {
        const uniformLayout = this.layout[name13];
        if (!uniformLayout) {
          log2.warn(`Supplied uniform value ${name13} not present in uniform block layout`)();
          continue;
        }
        const { type, size, offset } = uniformLayout;
        const typedArray = typedArrays[type];
        if (size === 1) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            log2.warn(`Supplied value for single component uniform ${name13} is not a number: ${value}`)();
            continue;
          }
          typedArray[offset] = Number(value);
        } else {
          const numericArray = isNumberArray(value);
          if (!numericArray) {
            log2.warn(`Supplied value for multi component / array uniform ${name13} is not a numeric array: ${value}`)();
            continue;
          }
          typedArray.set(numericArray, offset);
        }
      }
      return new Uint8Array(arrayBuffer2);
    }
    has(name13) {
      return Boolean(this.layout[name13]);
    }
    get(name13) {
      const layout = this.layout[name13];
      return layout;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/utils/array-equal.js
  function arrayEqual(a3, b2, limit = 16) {
    if (a3 !== b2) {
      return false;
    }
    const arrayA = isNumberArray(a3);
    if (!arrayA) {
      return false;
    }
    const arrayB = isNumberArray(b2);
    if (arrayB && arrayA.length === arrayB.length) {
      for (let i5 = 0; i5 < arrayA.length; ++i5) {
        if (arrayB[i5] !== arrayA[i5]) {
          return false;
        }
      }
    }
    return true;
  }
  function arrayCopy(a3) {
    const numberArray = isNumberArray(a3);
    if (numberArray) {
      return numberArray.slice();
    }
    return a3;
  }

  // ../../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-block.js
  var UniformBlock = class {
    name;
    uniforms = {};
    modifiedUniforms = {};
    modified = true;
    bindingLayout = {};
    needsRedraw = "initialized";
    constructor(props) {
      this.name = props?.name;
      if (props?.name && props?.shaderLayout) {
        const binding = props?.shaderLayout.bindings?.find((binding2) => binding2.type === "uniform" && binding2.name === props?.name);
        if (!binding) {
          throw new Error(props?.name);
        }
        const uniformBlock = binding;
        for (const uniform of uniformBlock.uniforms || []) {
          this.bindingLayout[uniform.name] = uniform;
        }
      }
    }
    setUniforms(uniforms) {
      for (const [key, value] of Object.entries(uniforms)) {
        this._setUniform(key, value);
        if (!this.needsRedraw) {
          this.setNeedsRedraw(`${this.name}.${key}=${value}`);
        }
      }
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
    }
    getAllUniforms() {
      this.modifiedUniforms = {};
      this.needsRedraw = false;
      return this.uniforms || {};
    }
    _setUniform(key, value) {
      if (arrayEqual(this.uniforms[key], value)) {
        return;
      }
      this.uniforms[key] = arrayCopy(value);
      this.modifiedUniforms[key] = true;
      this.modified = true;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/lib/uniforms/uniform-store.js
  var UniformStore = class {
    uniformBlocks = /* @__PURE__ */ new Map();
    uniformBufferLayouts = /* @__PURE__ */ new Map();
    uniformBuffers = /* @__PURE__ */ new Map();
    constructor(blocks) {
      for (const [bufferName, block] of Object.entries(blocks)) {
        const uniformBufferName = bufferName;
        const uniformBufferLayout = new UniformBufferLayout(block.uniformTypes || {});
        this.uniformBufferLayouts.set(uniformBufferName, uniformBufferLayout);
        const uniformBlock = new UniformBlock({ name: bufferName });
        uniformBlock.setUniforms(block.defaultUniforms || {});
        this.uniformBlocks.set(uniformBufferName, uniformBlock);
      }
    }
    destroy() {
      for (const uniformBuffer of this.uniformBuffers.values()) {
        uniformBuffer.destroy();
      }
    }
    setUniforms(uniforms) {
      for (const [blockName, uniformValues] of Object.entries(uniforms)) {
        this.uniformBlocks.get(blockName).setUniforms(uniformValues);
      }
      this.updateUniformBuffers();
    }
    getUniformBufferByteLength(uniformBufferName) {
      return this.uniformBufferLayouts.get(uniformBufferName).byteLength;
    }
    getUniformBufferData(uniformBufferName) {
      const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
      return this.uniformBufferLayouts.get(uniformBufferName).getData(uniformValues);
    }
    createUniformBuffer(device, uniformBufferName, uniforms) {
      if (uniforms) {
        this.setUniforms(uniforms);
      }
      const byteLength = this.getUniformBufferByteLength(uniformBufferName);
      const uniformBuffer = device.createBuffer({
        usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
        byteLength
      });
      const uniformBufferData = this.getUniformBufferData(uniformBufferName);
      uniformBuffer.write(uniformBufferData);
      return uniformBuffer;
    }
    getManagedUniformBuffer(device, uniformBufferName) {
      if (!this.uniformBuffers.get(uniformBufferName)) {
        const byteLength = this.getUniformBufferByteLength(uniformBufferName);
        const uniformBuffer = device.createBuffer({
          usage: Buffer2.UNIFORM | Buffer2.COPY_DST,
          byteLength
        });
        this.uniformBuffers.set(uniformBufferName, uniformBuffer);
      }
      return this.uniformBuffers.get(uniformBufferName);
    }
    updateUniformBuffers() {
      let reason = false;
      for (const uniformBufferName of this.uniformBlocks.keys()) {
        const bufferReason = this.updateUniformBuffer(uniformBufferName);
        reason ||= bufferReason;
      }
      if (reason) {
        log2.log(3, `UniformStore.updateUniformBuffers(): ${reason}`)();
      }
      return reason;
    }
    updateUniformBuffer(uniformBufferName) {
      const uniformBlock = this.uniformBlocks.get(uniformBufferName);
      const uniformBuffer = this.uniformBuffers.get(uniformBufferName);
      let reason = false;
      if (uniformBuffer && uniformBlock.needsRedraw) {
        reason ||= uniformBlock.needsRedraw;
        const uniformBufferData = this.getUniformBufferData(uniformBufferName);
        const uniformBuffer2 = this.uniformBuffers.get(uniformBufferName);
        uniformBuffer2.write(uniformBufferData);
        const uniformValues = this.uniformBlocks.get(uniformBufferName).getAllUniforms();
        log2.log(4, `Writing to uniform buffer ${String(uniformBufferName)}`, uniformBufferData, uniformValues)();
      }
      return reason;
    }
  };

  // ../../node_modules/@luma.gl/core/dist/adapter/type-utils/vertex-format-from-attribute.js
  function getDataTypeFromTypedArray2(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return "float32";
      case Uint16Array:
        return "uint16";
      case Uint32Array:
        return "uint32";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int8Array:
        return "sint8";
      case Int16Array:
        return "sint16";
      case Int32Array:
        return "sint32";
      default:
        throw new Error(type.constructor.name);
    }
  }
  function getTypedArrayFromDataType(dataType) {
    switch (dataType) {
      case "float32":
        return Float32Array;
      case "uint32":
        return Uint32Array;
      case "sint32":
        return Int32Array;
      case "uint16":
      case "unorm16":
        return Uint16Array;
      case "sint16":
      case "snorm16":
        return Int16Array;
      case "uint8":
      case "unorm8":
        return Uint8Array;
      case "sint8":
      case "snorm8":
        return Int8Array;
      default:
        throw new Error(dataType);
    }
  }
  function getVertexFormatFromAttribute(typedArray, size, normalized) {
    if (!size || size > 4) {
      throw new Error(`size ${size}`);
    }
    const components = size;
    let dataType = getDataTypeFromTypedArray2(typedArray);
    if (dataType === "uint8" || dataType === "sint8") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (dataType === "uint16" || dataType === "sint16") {
      if (components === 1 || components === 3) {
        throw new Error(`size: ${size}`);
      }
      if (normalized) {
        dataType = dataType.replace("int", "norm");
      }
      return `${dataType}x${components}`;
    }
    if (components === 1) {
      return dataType;
    }
    return `${dataType}x${components}`;
  }

  // ../../node_modules/@luma.gl/core/dist/utils/cast.js
  function cast(value) {
    return value;
  }

  // ../../node_modules/@luma.gl/core/dist/lib/uniforms/uniform.js
  function isUniformValue(value) {
    return isNumberArray(value) !== null || typeof value === "number" || typeof value === "boolean";
  }
  function splitUniformsAndBindings(uniforms) {
    const result = { bindings: {}, uniforms: {} };
    Object.keys(uniforms).forEach((name13) => {
      const uniform = uniforms[name13];
      if (isUniformValue(uniform)) {
        result.uniforms[name13] = uniform;
      } else {
        result.bindings[name13] = uniform;
      }
    });
    return result;
  }

  // ../../node_modules/@luma.gl/core/dist/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const { removedProps = {}, deprecatedProps = {}, replacedProps = {} } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? `${className}.${removedProps[propName]}` : "N/A";
        log2.removed(`${className}.${propName}`, replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log2.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
      }
    }
    let newProps = null;
    for (const [propName, replacementProp] of Object.entries(replacedProps)) {
      if (propName in props) {
        log2.deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // ../../node_modules/@luma.gl/core/dist/utils/load-file.js
  var pathPrefix2 = "";
  async function loadImage(url, opts) {
    return await new Promise((resolve2, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve2(image);
        image.onerror = () => reject(new Error(`Could not load image ${url}.`));
        image.crossOrigin = opts?.crossOrigin || "anonymous";
        image.src = url.startsWith("http") ? url : pathPrefix2 + url;
      } catch (error) {
        reject(error);
      }
    });
  }
  async function loadScript(scriptUrl, scriptId) {
    const head = document.getElementsByTagName("head")[0];
    if (!head) {
      throw new Error("loadScript");
    }
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    return new Promise((resolve2, reject) => {
      script.onload = resolve2;
      script.onerror = (error) => reject(new Error(`Unable to load script '${scriptUrl}': ${error}`));
      head.appendChild(script);
    });
  }

  // ../../node_modules/@luma.gl/core/dist/utils/deep-equal.js
  function deepEqual(a3, b2, depth) {
    if (a3 === b2) {
      return true;
    }
    if (!depth || !a3 || !b2) {
      return false;
    }
    if (Array.isArray(a3)) {
      if (!Array.isArray(b2) || a3.length !== b2.length) {
        return false;
      }
      for (let i5 = 0; i5 < a3.length; i5++) {
        if (!deepEqual(a3[i5], b2[i5], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b2)) {
      return false;
    }
    if (typeof a3 === "object" && typeof b2 === "object") {
      const aKeys = Object.keys(a3);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b2.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a3[key], b2[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/core/dist/utils/request-animation-frame.js
  function requestAnimationFrame2(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // ../../node_modules/@luma.gl/shadertools/dist/libs/wgsl-reflect/wgsl_reflect.module.js
  var ParseContext = class {
    constructor() {
      this.constants = /* @__PURE__ */ new Map();
      this.aliases = /* @__PURE__ */ new Map();
      this.structs = /* @__PURE__ */ new Map();
    }
  };
  var Node = class {
    constructor() {
    }
    get isAstNode() {
      return true;
    }
    get astNodeType() {
      return "";
    }
    evaluate(context) {
      throw new Error("Cannot evaluate node");
    }
    evaluateString(context) {
      return this.evaluate(context).toString();
    }
  };
  var Statement = class extends Node {
    constructor() {
      super();
    }
  };
  var Function = class extends Statement {
    constructor(name13, args, returnType, body) {
      super();
      this.name = name13;
      this.args = args;
      this.returnType = returnType;
      this.body = body;
    }
    get astNodeType() {
      return "function";
    }
  };
  var StaticAssert = class extends Statement {
    constructor(expression) {
      super();
      this.expression = expression;
    }
    get astNodeType() {
      return "staticAssert";
    }
  };
  var While = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "while";
    }
  };
  var Continuing = class extends Statement {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "continuing";
    }
  };
  var For = class extends Statement {
    constructor(init, condition, increment, body) {
      super();
      this.init = init;
      this.condition = condition;
      this.increment = increment;
      this.body = body;
    }
    get astNodeType() {
      return "for";
    }
  };
  var Var = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "var";
    }
  };
  var Override = class extends Statement {
    constructor(name13, type, value) {
      super();
      this.name = name13;
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "override";
    }
  };
  var Let = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "let";
    }
  };
  var Const = class extends Statement {
    constructor(name13, type, storage, access, value) {
      super();
      this.name = name13;
      this.type = type;
      this.storage = storage;
      this.access = access;
      this.value = value;
    }
    get astNodeType() {
      return "const";
    }
    evaluate(context) {
      return this.value.evaluate(context);
    }
  };
  var IncrementOperator;
  (function(IncrementOperator2) {
    IncrementOperator2["increment"] = "++";
    IncrementOperator2["decrement"] = "--";
  })(IncrementOperator || (IncrementOperator = {}));
  (function(IncrementOperator2) {
    function parse5(val2) {
      const key = val2;
      if (key == "parse")
        throw new Error("Invalid value for IncrementOperator");
      return IncrementOperator2[key];
    }
    IncrementOperator2.parse = parse5;
  })(IncrementOperator || (IncrementOperator = {}));
  var Increment = class extends Statement {
    constructor(operator, variable) {
      super();
      this.operator = operator;
      this.variable = variable;
    }
    get astNodeType() {
      return "increment";
    }
  };
  var AssignOperator;
  (function(AssignOperator2) {
    AssignOperator2["assign"] = "=";
    AssignOperator2["addAssign"] = "+=";
    AssignOperator2["subtractAssin"] = "-=";
    AssignOperator2["multiplyAssign"] = "*=";
    AssignOperator2["divideAssign"] = "/=";
    AssignOperator2["moduloAssign"] = "%=";
    AssignOperator2["andAssign"] = "&=";
    AssignOperator2["orAssign"] = "|=";
    AssignOperator2["xorAssign"] = "^=";
    AssignOperator2["shiftLeftAssign"] = "<<=";
    AssignOperator2["shiftRightAssign"] = ">>=";
  })(AssignOperator || (AssignOperator = {}));
  (function(AssignOperator2) {
    function parse5(val2) {
      const key = val2;
      if (key == "parse")
        throw new Error("Invalid value for AssignOperator");
      return AssignOperator2[key];
    }
    AssignOperator2.parse = parse5;
  })(AssignOperator || (AssignOperator = {}));
  var Assign = class extends Statement {
    constructor(operator, variable, value) {
      super();
      this.operator = operator;
      this.variable = variable;
      this.value = value;
    }
    get astNodeType() {
      return "assign";
    }
  };
  var Call = class extends Statement {
    constructor(name13, args) {
      super();
      this.name = name13;
      this.args = args;
    }
    get astNodeType() {
      return "call";
    }
  };
  var Loop = class extends Statement {
    constructor(body, continuing) {
      super();
      this.body = body;
      this.continuing = continuing;
    }
    get astNodeType() {
      return "loop";
    }
  };
  var Switch = class extends Statement {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "body";
    }
  };
  var If = class extends Statement {
    constructor(condition, body, elseif, _else) {
      super();
      this.condition = condition;
      this.body = body;
      this.elseif = elseif;
      this.else = _else;
    }
    get astNodeType() {
      return "if";
    }
  };
  var Return = class extends Statement {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "return";
    }
  };
  var Enable = class extends Statement {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "enable";
    }
  };
  var Alias = class extends Statement {
    constructor(name13, type) {
      super();
      this.name = name13;
      this.type = type;
    }
    get astNodeType() {
      return "alias";
    }
  };
  var Discard = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "discard";
    }
  };
  var Break = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "break";
    }
  };
  var Continue = class extends Statement {
    constructor() {
      super();
    }
    get astNodeType() {
      return "continue";
    }
  };
  var Type = class extends Statement {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "type";
    }
    get isStruct() {
      return false;
    }
    get isArray() {
      return false;
    }
  };
  var Struct = class extends Type {
    constructor(name13, members) {
      super(name13);
      this.members = members;
    }
    get astNodeType() {
      return "struct";
    }
    get isStruct() {
      return true;
    }
    getMemberIndex(name13) {
      for (let i5 = 0; i5 < this.members.length; i5++) {
        if (this.members[i5].name == name13)
          return i5;
      }
      return -1;
    }
  };
  var TemplateType = class extends Type {
    constructor(name13, format, access) {
      super(name13);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "template";
    }
  };
  var PointerType = class extends Type {
    constructor(name13, storage, type, access) {
      super(name13);
      this.storage = storage;
      this.type = type;
      this.access = access;
    }
    get astNodeType() {
      return "pointer";
    }
  };
  var ArrayType = class extends Type {
    constructor(name13, attributes, format, count2) {
      super(name13);
      this.attributes = attributes;
      this.format = format;
      this.count = count2;
    }
    get astNodeType() {
      return "array";
    }
    get isArray() {
      return true;
    }
  };
  var SamplerType = class extends Type {
    constructor(name13, format, access) {
      super(name13);
      this.format = format;
      this.access = access;
    }
    get astNodeType() {
      return "sampler";
    }
  };
  var Expression = class extends Node {
    constructor() {
      super();
    }
  };
  var StringExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "stringExpr";
    }
    toString() {
      return this.value;
    }
    evaluateString() {
      return this.value;
    }
  };
  var CreateExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "createExpr";
    }
  };
  var CallExpr = class extends Expression {
    constructor(name13, args) {
      super();
      this.name = name13;
      this.args = args;
    }
    get astNodeType() {
      return "callExpr";
    }
    evaluate(context) {
      switch (this.name) {
        case "abs":
          return Math.abs(this.args[0].evaluate(context));
        case "acos":
          return Math.acos(this.args[0].evaluate(context));
        case "acosh":
          return Math.acosh(this.args[0].evaluate(context));
        case "asin":
          return Math.asin(this.args[0].evaluate(context));
        case "asinh":
          return Math.asinh(this.args[0].evaluate(context));
        case "atan":
          return Math.atan(this.args[0].evaluate(context));
        case "atan2":
          return Math.atan2(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "atanh":
          return Math.atanh(this.args[0].evaluate(context));
        case "ceil":
          return Math.ceil(this.args[0].evaluate(context));
        case "clamp":
          return Math.min(Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context)), this.args[2].evaluate(context));
        case "cos":
          return Math.cos(this.args[0].evaluate(context));
        case "degrees":
          return this.args[0].evaluate(context) * 180 / Math.PI;
        case "distance":
          return Math.sqrt(Math.pow(this.args[0].evaluate(context) - this.args[1].evaluate(context), 2));
        case "dot":
        case "exp":
          return Math.exp(this.args[0].evaluate(context));
        case "exp2":
          return Math.pow(2, this.args[0].evaluate(context));
        case "floor":
          return Math.floor(this.args[0].evaluate(context));
        case "fma":
          return this.args[0].evaluate(context) * this.args[1].evaluate(context) + this.args[2].evaluate(context);
        case "fract":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "inverseSqrt":
          return 1 / Math.sqrt(this.args[0].evaluate(context));
        case "log":
          return Math.log(this.args[0].evaluate(context));
        case "log2":
          return Math.log2(this.args[0].evaluate(context));
        case "max":
          return Math.max(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "min":
          return Math.min(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "mix":
          return this.args[0].evaluate(context) * (1 - this.args[2].evaluate(context)) + this.args[1].evaluate(context) * this.args[2].evaluate(context);
        case "modf":
          return this.args[0].evaluate(context) - Math.floor(this.args[0].evaluate(context));
        case "pow":
          return Math.pow(this.args[0].evaluate(context), this.args[1].evaluate(context));
        case "radians":
          return this.args[0].evaluate(context) * Math.PI / 180;
        case "round":
          return Math.round(this.args[0].evaluate(context));
        case "sign":
          return Math.sign(this.args[0].evaluate(context));
        case "sin":
          return Math.sin(this.args[0].evaluate(context));
        case "sinh":
          return Math.sinh(this.args[0].evaluate(context));
        case "saturate":
          return Math.min(Math.max(this.args[0].evaluate(context), 0), 1);
        case "smoothstep":
          return this.args[0].evaluate(context) * this.args[0].evaluate(context) * (3 - 2 * this.args[0].evaluate(context));
        case "sqrt":
          return Math.sqrt(this.args[0].evaluate(context));
        case "step":
          return this.args[0].evaluate(context) < this.args[1].evaluate(context) ? 0 : 1;
        case "tan":
          return Math.tan(this.args[0].evaluate(context));
        case "tanh":
          return Math.tanh(this.args[0].evaluate(context));
        case "trunc":
          return Math.trunc(this.args[0].evaluate(context));
        default:
          throw new Error("Non const function: " + this.name);
      }
    }
  };
  var VariableExpr = class extends Expression {
    constructor(name13) {
      super();
      this.name = name13;
    }
    get astNodeType() {
      return "varExpr";
    }
  };
  var ConstExpr = class extends Expression {
    constructor(name13, initializer) {
      super();
      this.name = name13;
      this.initializer = initializer;
    }
    get astNodeType() {
      return "constExpr";
    }
    evaluate(context) {
      var _a2, _b;
      if (this.initializer instanceof CreateExpr) {
        const property = (_a2 = this.postfix) === null || _a2 === void 0 ? void 0 : _a2.evaluateString(context);
        const type = (_b = this.initializer.type) === null || _b === void 0 ? void 0 : _b.name;
        const struct = context.structs.get(type);
        const memberIndex = struct === null || struct === void 0 ? void 0 : struct.getMemberIndex(property);
        if (memberIndex != -1) {
          const value = this.initializer.args[memberIndex].evaluate(context);
          return value;
        }
        console.log(memberIndex);
      }
      return this.initializer.evaluate(context);
    }
  };
  var LiteralExpr = class extends Expression {
    constructor(value) {
      super();
      this.value = value;
    }
    get astNodeType() {
      return "literalExpr";
    }
    evaluate() {
      return this.value;
    }
  };
  var BitcastExpr = class extends Expression {
    constructor(type, value) {
      super();
      this.type = type;
      this.value = value;
    }
    get astNodeType() {
      return "bitcastExpr";
    }
  };
  var TypecastExpr = class extends Expression {
    constructor(type, args) {
      super();
      this.type = type;
      this.args = args;
    }
    get astNodeType() {
      return "typecastExpr";
    }
    evaluate(context) {
      return this.args[0].evaluate(context);
    }
  };
  var GroupingExpr = class extends Expression {
    constructor(contents) {
      super();
      this.contents = contents;
    }
    get astNodeType() {
      return "groupExpr";
    }
    evaluate(context) {
      return this.contents[0].evaluate(context);
    }
  };
  var Operator = class extends Expression {
    constructor() {
      super();
    }
  };
  var UnaryOperator = class extends Operator {
    constructor(operator, right) {
      super();
      this.operator = operator;
      this.right = right;
    }
    get astNodeType() {
      return "unaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.right.evaluate(context);
        case "-":
          return -this.right.evaluate(context);
        case "!":
          return this.right.evaluate(context) ? 0 : 1;
        case "~":
          return ~this.right.evaluate(context);
        default:
          throw new Error("Unknown unary operator: " + this.operator);
      }
    }
  };
  var BinaryOperator = class extends Operator {
    constructor(operator, left, right) {
      super();
      this.operator = operator;
      this.left = left;
      this.right = right;
    }
    get astNodeType() {
      return "binaryOp";
    }
    evaluate(context) {
      switch (this.operator) {
        case "+":
          return this.left.evaluate(context) + this.right.evaluate(context);
        case "-":
          return this.left.evaluate(context) - this.right.evaluate(context);
        case "*":
          return this.left.evaluate(context) * this.right.evaluate(context);
        case "/":
          return this.left.evaluate(context) / this.right.evaluate(context);
        case "%":
          return this.left.evaluate(context) % this.right.evaluate(context);
        case "==":
          return this.left.evaluate(context) == this.right.evaluate(context) ? 1 : 0;
        case "!=":
          return this.left.evaluate(context) != this.right.evaluate(context) ? 1 : 0;
        case "<":
          return this.left.evaluate(context) < this.right.evaluate(context) ? 1 : 0;
        case ">":
          return this.left.evaluate(context) > this.right.evaluate(context) ? 1 : 0;
        case "<=":
          return this.left.evaluate(context) <= this.right.evaluate(context) ? 1 : 0;
        case ">=":
          return this.left.evaluate(context) >= this.right.evaluate(context) ? 1 : 0;
        case "&&":
          return this.left.evaluate(context) && this.right.evaluate(context) ? 1 : 0;
        case "||":
          return this.left.evaluate(context) || this.right.evaluate(context) ? 1 : 0;
        default:
          throw new Error(`Unknown operator ${this.operator}`);
      }
    }
  };
  var SwitchCase = class extends Node {
    constructor() {
      super();
    }
  };
  var Case = class extends SwitchCase {
    constructor(selector, body) {
      super();
      this.selector = selector;
      this.body = body;
    }
    get astNodeType() {
      return "case";
    }
  };
  var Default = class extends SwitchCase {
    constructor(body) {
      super();
      this.body = body;
    }
    get astNodeType() {
      return "default";
    }
  };
  var Argument = class extends Node {
    constructor(name13, type, attributes) {
      super();
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "argument";
    }
  };
  var ElseIf = class extends Node {
    constructor(condition, body) {
      super();
      this.condition = condition;
      this.body = body;
    }
    get astNodeType() {
      return "elseif";
    }
  };
  var Member = class extends Node {
    constructor(name13, type, attributes) {
      super();
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
    }
    get astNodeType() {
      return "member";
    }
  };
  var Attribute = class extends Node {
    constructor(name13, value) {
      super();
      this.name = name13;
      this.value = value;
    }
    get astNodeType() {
      return "attribute";
    }
  };
  var _a;
  var TokenClass;
  (function(TokenClass2) {
    TokenClass2[TokenClass2["token"] = 0] = "token";
    TokenClass2[TokenClass2["keyword"] = 1] = "keyword";
    TokenClass2[TokenClass2["reserved"] = 2] = "reserved";
  })(TokenClass || (TokenClass = {}));
  var TokenType = class {
    constructor(name13, type, rule) {
      this.name = name13;
      this.type = type;
      this.rule = rule;
    }
    toString() {
      return this.name;
    }
  };
  var TokenTypes = class {
  };
  _a = TokenTypes;
  TokenTypes.none = new TokenType("", TokenClass.reserved, "");
  TokenTypes.eof = new TokenType("EOF", TokenClass.token, "");
  TokenTypes.reserved = {
    asm: new TokenType("asm", TokenClass.reserved, "asm"),
    bf16: new TokenType("bf16", TokenClass.reserved, "bf16"),
    do: new TokenType("do", TokenClass.reserved, "do"),
    enum: new TokenType("enum", TokenClass.reserved, "enum"),
    f16: new TokenType("f16", TokenClass.reserved, "f16"),
    f64: new TokenType("f64", TokenClass.reserved, "f64"),
    handle: new TokenType("handle", TokenClass.reserved, "handle"),
    i8: new TokenType("i8", TokenClass.reserved, "i8"),
    i16: new TokenType("i16", TokenClass.reserved, "i16"),
    i64: new TokenType("i64", TokenClass.reserved, "i64"),
    mat: new TokenType("mat", TokenClass.reserved, "mat"),
    premerge: new TokenType("premerge", TokenClass.reserved, "premerge"),
    regardless: new TokenType("regardless", TokenClass.reserved, "regardless"),
    typedef: new TokenType("typedef", TokenClass.reserved, "typedef"),
    u8: new TokenType("u8", TokenClass.reserved, "u8"),
    u16: new TokenType("u16", TokenClass.reserved, "u16"),
    u64: new TokenType("u64", TokenClass.reserved, "u64"),
    unless: new TokenType("unless", TokenClass.reserved, "unless"),
    using: new TokenType("using", TokenClass.reserved, "using"),
    vec: new TokenType("vec", TokenClass.reserved, "vec"),
    void: new TokenType("void", TokenClass.reserved, "void")
  };
  TokenTypes.keywords = {
    array: new TokenType("array", TokenClass.keyword, "array"),
    atomic: new TokenType("atomic", TokenClass.keyword, "atomic"),
    bool: new TokenType("bool", TokenClass.keyword, "bool"),
    f32: new TokenType("f32", TokenClass.keyword, "f32"),
    i32: new TokenType("i32", TokenClass.keyword, "i32"),
    mat2x2: new TokenType("mat2x2", TokenClass.keyword, "mat2x2"),
    mat2x3: new TokenType("mat2x3", TokenClass.keyword, "mat2x3"),
    mat2x4: new TokenType("mat2x4", TokenClass.keyword, "mat2x4"),
    mat3x2: new TokenType("mat3x2", TokenClass.keyword, "mat3x2"),
    mat3x3: new TokenType("mat3x3", TokenClass.keyword, "mat3x3"),
    mat3x4: new TokenType("mat3x4", TokenClass.keyword, "mat3x4"),
    mat4x2: new TokenType("mat4x2", TokenClass.keyword, "mat4x2"),
    mat4x3: new TokenType("mat4x3", TokenClass.keyword, "mat4x3"),
    mat4x4: new TokenType("mat4x4", TokenClass.keyword, "mat4x4"),
    ptr: new TokenType("ptr", TokenClass.keyword, "ptr"),
    sampler: new TokenType("sampler", TokenClass.keyword, "sampler"),
    sampler_comparison: new TokenType("sampler_comparison", TokenClass.keyword, "sampler_comparison"),
    struct: new TokenType("struct", TokenClass.keyword, "struct"),
    texture_1d: new TokenType("texture_1d", TokenClass.keyword, "texture_1d"),
    texture_2d: new TokenType("texture_2d", TokenClass.keyword, "texture_2d"),
    texture_2d_array: new TokenType("texture_2d_array", TokenClass.keyword, "texture_2d_array"),
    texture_3d: new TokenType("texture_3d", TokenClass.keyword, "texture_3d"),
    texture_cube: new TokenType("texture_cube", TokenClass.keyword, "texture_cube"),
    texture_cube_array: new TokenType("texture_cube_array", TokenClass.keyword, "texture_cube_array"),
    texture_multisampled_2d: new TokenType("texture_multisampled_2d", TokenClass.keyword, "texture_multisampled_2d"),
    texture_storage_1d: new TokenType("texture_storage_1d", TokenClass.keyword, "texture_storage_1d"),
    texture_storage_2d: new TokenType("texture_storage_2d", TokenClass.keyword, "texture_storage_2d"),
    texture_storage_2d_array: new TokenType("texture_storage_2d_array", TokenClass.keyword, "texture_storage_2d_array"),
    texture_storage_3d: new TokenType("texture_storage_3d", TokenClass.keyword, "texture_storage_3d"),
    texture_depth_2d: new TokenType("texture_depth_2d", TokenClass.keyword, "texture_depth_2d"),
    texture_depth_2d_array: new TokenType("texture_depth_2d_array", TokenClass.keyword, "texture_depth_2d_array"),
    texture_depth_cube: new TokenType("texture_depth_cube", TokenClass.keyword, "texture_depth_cube"),
    texture_depth_cube_array: new TokenType("texture_depth_cube_array", TokenClass.keyword, "texture_depth_cube_array"),
    texture_depth_multisampled_2d: new TokenType("texture_depth_multisampled_2d", TokenClass.keyword, "texture_depth_multisampled_2d"),
    texture_external: new TokenType("texture_external", TokenClass.keyword, "texture_external"),
    u32: new TokenType("u32", TokenClass.keyword, "u32"),
    vec2: new TokenType("vec2", TokenClass.keyword, "vec2"),
    vec3: new TokenType("vec3", TokenClass.keyword, "vec3"),
    vec4: new TokenType("vec4", TokenClass.keyword, "vec4"),
    bitcast: new TokenType("bitcast", TokenClass.keyword, "bitcast"),
    block: new TokenType("block", TokenClass.keyword, "block"),
    break: new TokenType("break", TokenClass.keyword, "break"),
    case: new TokenType("case", TokenClass.keyword, "case"),
    continue: new TokenType("continue", TokenClass.keyword, "continue"),
    continuing: new TokenType("continuing", TokenClass.keyword, "continuing"),
    default: new TokenType("default", TokenClass.keyword, "default"),
    discard: new TokenType("discard", TokenClass.keyword, "discard"),
    else: new TokenType("else", TokenClass.keyword, "else"),
    enable: new TokenType("enable", TokenClass.keyword, "enable"),
    fallthrough: new TokenType("fallthrough", TokenClass.keyword, "fallthrough"),
    false: new TokenType("false", TokenClass.keyword, "false"),
    fn: new TokenType("fn", TokenClass.keyword, "fn"),
    for: new TokenType("for", TokenClass.keyword, "for"),
    function: new TokenType("function", TokenClass.keyword, "function"),
    if: new TokenType("if", TokenClass.keyword, "if"),
    let: new TokenType("let", TokenClass.keyword, "let"),
    const: new TokenType("const", TokenClass.keyword, "const"),
    loop: new TokenType("loop", TokenClass.keyword, "loop"),
    while: new TokenType("while", TokenClass.keyword, "while"),
    private: new TokenType("private", TokenClass.keyword, "private"),
    read: new TokenType("read", TokenClass.keyword, "read"),
    read_write: new TokenType("read_write", TokenClass.keyword, "read_write"),
    return: new TokenType("return", TokenClass.keyword, "return"),
    storage: new TokenType("storage", TokenClass.keyword, "storage"),
    switch: new TokenType("switch", TokenClass.keyword, "switch"),
    true: new TokenType("true", TokenClass.keyword, "true"),
    alias: new TokenType("alias", TokenClass.keyword, "alias"),
    type: new TokenType("type", TokenClass.keyword, "type"),
    uniform: new TokenType("uniform", TokenClass.keyword, "uniform"),
    var: new TokenType("var", TokenClass.keyword, "var"),
    override: new TokenType("override", TokenClass.keyword, "override"),
    workgroup: new TokenType("workgroup", TokenClass.keyword, "workgroup"),
    write: new TokenType("write", TokenClass.keyword, "write"),
    r8unorm: new TokenType("r8unorm", TokenClass.keyword, "r8unorm"),
    r8snorm: new TokenType("r8snorm", TokenClass.keyword, "r8snorm"),
    r8uint: new TokenType("r8uint", TokenClass.keyword, "r8uint"),
    r8sint: new TokenType("r8sint", TokenClass.keyword, "r8sint"),
    r16uint: new TokenType("r16uint", TokenClass.keyword, "r16uint"),
    r16sint: new TokenType("r16sint", TokenClass.keyword, "r16sint"),
    r16float: new TokenType("r16float", TokenClass.keyword, "r16float"),
    rg8unorm: new TokenType("rg8unorm", TokenClass.keyword, "rg8unorm"),
    rg8snorm: new TokenType("rg8snorm", TokenClass.keyword, "rg8snorm"),
    rg8uint: new TokenType("rg8uint", TokenClass.keyword, "rg8uint"),
    rg8sint: new TokenType("rg8sint", TokenClass.keyword, "rg8sint"),
    r32uint: new TokenType("r32uint", TokenClass.keyword, "r32uint"),
    r32sint: new TokenType("r32sint", TokenClass.keyword, "r32sint"),
    r32float: new TokenType("r32float", TokenClass.keyword, "r32float"),
    rg16uint: new TokenType("rg16uint", TokenClass.keyword, "rg16uint"),
    rg16sint: new TokenType("rg16sint", TokenClass.keyword, "rg16sint"),
    rg16float: new TokenType("rg16float", TokenClass.keyword, "rg16float"),
    rgba8unorm: new TokenType("rgba8unorm", TokenClass.keyword, "rgba8unorm"),
    rgba8unorm_srgb: new TokenType("rgba8unorm_srgb", TokenClass.keyword, "rgba8unorm_srgb"),
    rgba8snorm: new TokenType("rgba8snorm", TokenClass.keyword, "rgba8snorm"),
    rgba8uint: new TokenType("rgba8uint", TokenClass.keyword, "rgba8uint"),
    rgba8sint: new TokenType("rgba8sint", TokenClass.keyword, "rgba8sint"),
    bgra8unorm: new TokenType("bgra8unorm", TokenClass.keyword, "bgra8unorm"),
    bgra8unorm_srgb: new TokenType("bgra8unorm_srgb", TokenClass.keyword, "bgra8unorm_srgb"),
    rgb10a2unorm: new TokenType("rgb10a2unorm", TokenClass.keyword, "rgb10a2unorm"),
    rg11b10float: new TokenType("rg11b10float", TokenClass.keyword, "rg11b10float"),
    rg32uint: new TokenType("rg32uint", TokenClass.keyword, "rg32uint"),
    rg32sint: new TokenType("rg32sint", TokenClass.keyword, "rg32sint"),
    rg32float: new TokenType("rg32float", TokenClass.keyword, "rg32float"),
    rgba16uint: new TokenType("rgba16uint", TokenClass.keyword, "rgba16uint"),
    rgba16sint: new TokenType("rgba16sint", TokenClass.keyword, "rgba16sint"),
    rgba16float: new TokenType("rgba16float", TokenClass.keyword, "rgba16float"),
    rgba32uint: new TokenType("rgba32uint", TokenClass.keyword, "rgba32uint"),
    rgba32sint: new TokenType("rgba32sint", TokenClass.keyword, "rgba32sint"),
    rgba32float: new TokenType("rgba32float", TokenClass.keyword, "rgba32float"),
    static_assert: new TokenType("static_assert", TokenClass.keyword, "static_assert")
  };
  TokenTypes.tokens = {
    decimal_float_literal: new TokenType("decimal_float_literal", TokenClass.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),
    hex_float_literal: new TokenType("hex_float_literal", TokenClass.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),
    int_literal: new TokenType("int_literal", TokenClass.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
    uint_literal: new TokenType("uint_literal", TokenClass.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
    ident: new TokenType("ident", TokenClass.token, /[a-zA-Z][0-9a-zA-Z_]*/),
    and: new TokenType("and", TokenClass.token, "&"),
    and_and: new TokenType("and_and", TokenClass.token, "&&"),
    arrow: new TokenType("arrow ", TokenClass.token, "->"),
    attr: new TokenType("attr", TokenClass.token, "@"),
    attr_left: new TokenType("attr_left", TokenClass.token, "[["),
    attr_right: new TokenType("attr_right", TokenClass.token, "]]"),
    forward_slash: new TokenType("forward_slash", TokenClass.token, "/"),
    bang: new TokenType("bang", TokenClass.token, "!"),
    bracket_left: new TokenType("bracket_left", TokenClass.token, "["),
    bracket_right: new TokenType("bracket_right", TokenClass.token, "]"),
    brace_left: new TokenType("brace_left", TokenClass.token, "{"),
    brace_right: new TokenType("brace_right", TokenClass.token, "}"),
    colon: new TokenType("colon", TokenClass.token, ":"),
    comma: new TokenType("comma", TokenClass.token, ","),
    equal: new TokenType("equal", TokenClass.token, "="),
    equal_equal: new TokenType("equal_equal", TokenClass.token, "=="),
    not_equal: new TokenType("not_equal", TokenClass.token, "!="),
    greater_than: new TokenType("greater_than", TokenClass.token, ">"),
    greater_than_equal: new TokenType("greater_than_equal", TokenClass.token, ">="),
    shift_right: new TokenType("shift_right", TokenClass.token, ">>"),
    less_than: new TokenType("less_than", TokenClass.token, "<"),
    less_than_equal: new TokenType("less_than_equal", TokenClass.token, "<="),
    shift_left: new TokenType("shift_left", TokenClass.token, "<<"),
    modulo: new TokenType("modulo", TokenClass.token, "%"),
    minus: new TokenType("minus", TokenClass.token, "-"),
    minus_minus: new TokenType("minus_minus", TokenClass.token, "--"),
    period: new TokenType("period", TokenClass.token, "."),
    plus: new TokenType("plus", TokenClass.token, "+"),
    plus_plus: new TokenType("plus_plus", TokenClass.token, "++"),
    or: new TokenType("or", TokenClass.token, "|"),
    or_or: new TokenType("or_or", TokenClass.token, "||"),
    paren_left: new TokenType("paren_left", TokenClass.token, "("),
    paren_right: new TokenType("paren_right", TokenClass.token, ")"),
    semicolon: new TokenType("semicolon", TokenClass.token, ";"),
    star: new TokenType("star", TokenClass.token, "*"),
    tilde: new TokenType("tilde", TokenClass.token, "~"),
    underscore: new TokenType("underscore", TokenClass.token, "_"),
    xor: new TokenType("xor", TokenClass.token, "^"),
    plus_equal: new TokenType("plus_equal", TokenClass.token, "+="),
    minus_equal: new TokenType("minus_equal", TokenClass.token, "-="),
    times_equal: new TokenType("times_equal", TokenClass.token, "*="),
    division_equal: new TokenType("division_equal", TokenClass.token, "/="),
    modulo_equal: new TokenType("modulo_equal", TokenClass.token, "%="),
    and_equal: new TokenType("and_equal", TokenClass.token, "&="),
    or_equal: new TokenType("or_equal", TokenClass.token, "|="),
    xor_equal: new TokenType("xor_equal", TokenClass.token, "^="),
    shift_right_equal: new TokenType("shift_right_equal", TokenClass.token, ">>="),
    shift_left_equal: new TokenType("shift_left_equal", TokenClass.token, "<<=")
  };
  TokenTypes.storage_class = [
    _a.keywords.function,
    _a.keywords.private,
    _a.keywords.workgroup,
    _a.keywords.uniform,
    _a.keywords.storage
  ];
  TokenTypes.access_mode = [
    _a.keywords.read,
    _a.keywords.write,
    _a.keywords.read_write
  ];
  TokenTypes.sampler_type = [
    _a.keywords.sampler,
    _a.keywords.sampler_comparison
  ];
  TokenTypes.sampled_texture_type = [
    _a.keywords.texture_1d,
    _a.keywords.texture_2d,
    _a.keywords.texture_2d_array,
    _a.keywords.texture_3d,
    _a.keywords.texture_cube,
    _a.keywords.texture_cube_array
  ];
  TokenTypes.multisampled_texture_type = [
    _a.keywords.texture_multisampled_2d
  ];
  TokenTypes.storage_texture_type = [
    _a.keywords.texture_storage_1d,
    _a.keywords.texture_storage_2d,
    _a.keywords.texture_storage_2d_array,
    _a.keywords.texture_storage_3d
  ];
  TokenTypes.depth_texture_type = [
    _a.keywords.texture_depth_2d,
    _a.keywords.texture_depth_2d_array,
    _a.keywords.texture_depth_cube,
    _a.keywords.texture_depth_cube_array,
    _a.keywords.texture_depth_multisampled_2d
  ];
  TokenTypes.texture_external_type = [_a.keywords.texture_external];
  TokenTypes.any_texture_type = [
    ..._a.sampled_texture_type,
    ..._a.multisampled_texture_type,
    ..._a.storage_texture_type,
    ..._a.depth_texture_type,
    ..._a.texture_external_type
  ];
  TokenTypes.texel_format = [
    _a.keywords.r8unorm,
    _a.keywords.r8snorm,
    _a.keywords.r8uint,
    _a.keywords.r8sint,
    _a.keywords.r16uint,
    _a.keywords.r16sint,
    _a.keywords.r16float,
    _a.keywords.rg8unorm,
    _a.keywords.rg8snorm,
    _a.keywords.rg8uint,
    _a.keywords.rg8sint,
    _a.keywords.r32uint,
    _a.keywords.r32sint,
    _a.keywords.r32float,
    _a.keywords.rg16uint,
    _a.keywords.rg16sint,
    _a.keywords.rg16float,
    _a.keywords.rgba8unorm,
    _a.keywords.rgba8unorm_srgb,
    _a.keywords.rgba8snorm,
    _a.keywords.rgba8uint,
    _a.keywords.rgba8sint,
    _a.keywords.bgra8unorm,
    _a.keywords.bgra8unorm_srgb,
    _a.keywords.rgb10a2unorm,
    _a.keywords.rg11b10float,
    _a.keywords.rg32uint,
    _a.keywords.rg32sint,
    _a.keywords.rg32float,
    _a.keywords.rgba16uint,
    _a.keywords.rgba16sint,
    _a.keywords.rgba16float,
    _a.keywords.rgba32uint,
    _a.keywords.rgba32sint,
    _a.keywords.rgba32float
  ];
  TokenTypes.const_literal = [
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.decimal_float_literal,
    _a.tokens.hex_float_literal,
    _a.keywords.true,
    _a.keywords.false
  ];
  TokenTypes.literal_or_ident = [
    _a.tokens.ident,
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.decimal_float_literal,
    _a.tokens.hex_float_literal
  ];
  TokenTypes.element_count_expression = [
    _a.tokens.int_literal,
    _a.tokens.uint_literal,
    _a.tokens.ident
  ];
  TokenTypes.template_types = [
    _a.keywords.vec2,
    _a.keywords.vec3,
    _a.keywords.vec4,
    _a.keywords.mat2x2,
    _a.keywords.mat2x3,
    _a.keywords.mat2x4,
    _a.keywords.mat3x2,
    _a.keywords.mat3x3,
    _a.keywords.mat3x4,
    _a.keywords.mat4x2,
    _a.keywords.mat4x3,
    _a.keywords.mat4x4,
    _a.keywords.atomic,
    _a.keywords.bitcast,
    ..._a.any_texture_type
  ];
  TokenTypes.attribute_name = [_a.tokens.ident, _a.keywords.block];
  TokenTypes.assignment_operators = [
    _a.tokens.equal,
    _a.tokens.plus_equal,
    _a.tokens.minus_equal,
    _a.tokens.times_equal,
    _a.tokens.division_equal,
    _a.tokens.modulo_equal,
    _a.tokens.and_equal,
    _a.tokens.or_equal,
    _a.tokens.xor_equal,
    _a.tokens.shift_right_equal,
    _a.tokens.shift_left_equal
  ];
  TokenTypes.increment_operators = [
    _a.tokens.plus_plus,
    _a.tokens.minus_minus
  ];
  var Token = class {
    constructor(type, lexeme, line) {
      this.type = type;
      this.lexeme = lexeme;
      this.line = line;
    }
    toString() {
      return this.lexeme;
    }
    isTemplateType() {
      return TokenTypes.template_types.indexOf(this.type) != -1;
    }
    isArrayType() {
      return this.type == TokenTypes.keywords.array;
    }
    isArrayOrTemplateType() {
      return this.isArrayType() || this.isTemplateType();
    }
  };
  var WgslScanner = class {
    constructor(source) {
      this._tokens = [];
      this._start = 0;
      this._current = 0;
      this._line = 1;
      this._source = source !== null && source !== void 0 ? source : "";
    }
    scanTokens() {
      while (!this._isAtEnd()) {
        this._start = this._current;
        if (!this.scanToken())
          throw `Invalid syntax at line ${this._line}`;
      }
      this._tokens.push(new Token(TokenTypes.eof, "", this._line));
      return this._tokens;
    }
    scanToken() {
      let lexeme = this._advance();
      if (lexeme == "\n") {
        this._line++;
        return true;
      }
      if (this._isWhitespace(lexeme)) {
        return true;
      }
      if (lexeme == "/") {
        if (this._peekAhead() == "/") {
          while (lexeme != "\n") {
            if (this._isAtEnd())
              return true;
            lexeme = this._advance();
          }
          this._line++;
          return true;
        } else if (this._peekAhead() == "*") {
          this._advance();
          let commentLevel = 1;
          while (commentLevel > 0) {
            if (this._isAtEnd())
              return true;
            lexeme = this._advance();
            if (lexeme == "\n") {
              this._line++;
            } else if (lexeme == "*") {
              if (this._peekAhead() == "/") {
                this._advance();
                commentLevel--;
                if (commentLevel == 0) {
                  return true;
                }
              }
            } else if (lexeme == "/") {
              if (this._peekAhead() == "*") {
                this._advance();
                commentLevel++;
              }
            }
          }
          return true;
        }
      }
      let matchType = TokenTypes.none;
      for (; ; ) {
        let matchedType = this._findType(lexeme);
        const nextLexeme = this._peekAhead();
        if (lexeme == ">" && (nextLexeme == ">" || nextLexeme == "=")) {
          let foundLessThan = false;
          let ti = this._tokens.length - 1;
          for (let count2 = 0; count2 < 5 && ti >= 0; ++count2, --ti) {
            if (this._tokens[ti].type === TokenTypes.tokens.less_than) {
              if (ti > 0 && this._tokens[ti - 1].isArrayOrTemplateType()) {
                foundLessThan = true;
              }
              break;
            }
          }
          if (foundLessThan) {
            this._addToken(matchedType);
            return true;
          }
        }
        if (matchedType === TokenTypes.none) {
          let lookAheadLexeme = lexeme;
          let lookAhead = 0;
          const maxLookAhead = 2;
          for (let li = 0; li < maxLookAhead; ++li) {
            lookAheadLexeme += this._peekAhead(li);
            matchedType = this._findType(lookAheadLexeme);
            if (matchedType !== TokenTypes.none) {
              lookAhead = li;
              break;
            }
          }
          if (matchedType === TokenTypes.none) {
            if (matchType === TokenTypes.none)
              return false;
            this._current--;
            this._addToken(matchType);
            return true;
          }
          lexeme = lookAheadLexeme;
          this._current += lookAhead + 1;
        }
        matchType = matchedType;
        if (this._isAtEnd())
          break;
        lexeme += this._advance();
      }
      if (matchType === TokenTypes.none)
        return false;
      this._addToken(matchType);
      return true;
    }
    _findType(lexeme) {
      for (const name13 in TokenTypes.keywords) {
        const type = TokenTypes.keywords[name13];
        if (this._match(lexeme, type.rule)) {
          return type;
        }
      }
      for (const name13 in TokenTypes.tokens) {
        const type = TokenTypes.tokens[name13];
        if (this._match(lexeme, type.rule)) {
          return type;
        }
      }
      return TokenTypes.none;
    }
    _match(lexeme, rule) {
      if (typeof rule === "string") {
        if (rule == lexeme) {
          return true;
        }
      } else {
        const match = rule.exec(lexeme);
        if (match && match.index == 0 && match[0] == lexeme)
          return true;
      }
      return false;
    }
    _isAtEnd() {
      return this._current >= this._source.length;
    }
    _isWhitespace(c2) {
      return c2 == " " || c2 == "	" || c2 == "\r";
    }
    _advance(amount = 0) {
      let c2 = this._source[this._current];
      amount = amount || 0;
      amount++;
      this._current += amount;
      return c2;
    }
    _peekAhead(offset = 0) {
      offset = offset || 0;
      if (this._current + offset >= this._source.length)
        return "\0";
      return this._source[this._current + offset];
    }
    _addToken(type) {
      const text = this._source.substring(this._start, this._current);
      this._tokens.push(new Token(type, text, this._line));
    }
  };
  var WgslParser = class {
    constructor() {
      this._tokens = [];
      this._current = 0;
      this._context = new ParseContext();
    }
    parse(tokensOrCode) {
      this._initialize(tokensOrCode);
      let statements = [];
      while (!this._isAtEnd()) {
        const statement = this._global_decl_or_directive();
        if (!statement)
          break;
        statements.push(statement);
      }
      return statements;
    }
    _initialize(tokensOrCode) {
      if (tokensOrCode) {
        if (typeof tokensOrCode == "string") {
          const scanner = new WgslScanner(tokensOrCode);
          this._tokens = scanner.scanTokens();
        } else {
          this._tokens = tokensOrCode;
        }
      } else {
        this._tokens = [];
      }
      this._current = 0;
    }
    _error(token, message2) {
      console.error(token, message2);
      return {
        token,
        message: message2,
        toString: function() {
          return `${message2}`;
        }
      };
    }
    _isAtEnd() {
      return this._current >= this._tokens.length || this._peek().type == TokenTypes.eof;
    }
    _match(types) {
      if (types instanceof TokenType) {
        if (this._check(types)) {
          this._advance();
          return true;
        }
        return false;
      }
      for (let i5 = 0, l3 = types.length; i5 < l3; ++i5) {
        const type = types[i5];
        if (this._check(type)) {
          this._advance();
          return true;
        }
      }
      return false;
    }
    _consume(types, message2) {
      if (this._check(types))
        return this._advance();
      throw this._error(this._peek(), message2);
    }
    _check(types) {
      if (this._isAtEnd())
        return false;
      const tk = this._peek();
      if (types instanceof Array) {
        let t3 = tk.type;
        let index2 = types.indexOf(t3);
        return index2 != -1;
      }
      return tk.type == types;
    }
    _advance() {
      if (!this._isAtEnd())
        this._current++;
      return this._previous();
    }
    _peek() {
      return this._tokens[this._current];
    }
    _previous() {
      return this._tokens[this._current - 1];
    }
    _global_decl_or_directive() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._match(TokenTypes.keywords.alias)) {
        const type = this._type_alias();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return type;
      }
      if (this._match(TokenTypes.keywords.enable)) {
        const enable2 = this._enable_directive();
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return enable2;
      }
      const attrs = this._attribute();
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._global_variable_decl();
        if (_var != null)
          _var.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _var;
      }
      if (this._check(TokenTypes.keywords.override)) {
        const _override = this._override_variable_decl();
        if (_override != null)
          _override.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _override;
      }
      if (this._check(TokenTypes.keywords.let)) {
        const _let = this._global_let_decl();
        if (_let != null)
          _let.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _let;
      }
      if (this._check(TokenTypes.keywords.const)) {
        const _const = this._global_const_decl();
        if (_const != null)
          _const.attributes = attrs;
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
        return _const;
      }
      if (this._check(TokenTypes.keywords.struct)) {
        const _struct = this._struct_decl();
        if (_struct != null)
          _struct.attributes = attrs;
        return _struct;
      }
      if (this._check(TokenTypes.keywords.fn)) {
        const _fn = this._function_decl();
        if (_fn != null)
          _fn.attributes = attrs;
        return _fn;
      }
      return null;
    }
    _function_decl() {
      if (!this._match(TokenTypes.keywords.fn))
        return null;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected function name.").toString();
      this._consume(TokenTypes.tokens.paren_left, "Expected '(' for function arguments.");
      const args = [];
      if (!this._check(TokenTypes.tokens.paren_right)) {
        do {
          if (this._check(TokenTypes.tokens.paren_right))
            break;
          const argAttrs = this._attribute();
          const name14 = this._consume(TokenTypes.tokens.ident, "Expected argument name.").toString();
          this._consume(TokenTypes.tokens.colon, "Expected ':' for argument type.");
          const typeAttrs = this._attribute();
          const type = this._type_decl();
          if (type != null) {
            type.attributes = typeAttrs;
            args.push(new Argument(name14, type, argAttrs));
          }
        } while (this._match(TokenTypes.tokens.comma));
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' after function arguments.");
      let _return = null;
      if (this._match(TokenTypes.tokens.arrow)) {
        const attrs = this._attribute();
        _return = this._type_decl();
        if (_return != null)
          _return.attributes = attrs;
      }
      const body = this._compound_statement();
      return new Function(name13, args, _return, body);
    }
    _compound_statement() {
      const statements = [];
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for block.");
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const statement = this._statement();
        if (statement !== null)
          statements.push(statement);
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for block.");
      return statements;
    }
    _statement() {
      while (this._match(TokenTypes.tokens.semicolon) && !this._isAtEnd())
        ;
      if (this._check(TokenTypes.keywords.if))
        return this._if_statement();
      if (this._check(TokenTypes.keywords.switch))
        return this._switch_statement();
      if (this._check(TokenTypes.keywords.loop))
        return this._loop_statement();
      if (this._check(TokenTypes.keywords.for))
        return this._for_statement();
      if (this._check(TokenTypes.keywords.while))
        return this._while_statement();
      if (this._check(TokenTypes.keywords.continuing))
        return this._continuing_statement();
      if (this._check(TokenTypes.keywords.static_assert))
        return this._static_assert_statement();
      if (this._check(TokenTypes.tokens.brace_left))
        return this._compound_statement();
      let result = null;
      if (this._check(TokenTypes.keywords.return))
        result = this._return_statement();
      else if (this._check([
        TokenTypes.keywords.var,
        TokenTypes.keywords.let,
        TokenTypes.keywords.const
      ]))
        result = this._variable_statement();
      else if (this._match(TokenTypes.keywords.discard))
        result = new Discard();
      else if (this._match(TokenTypes.keywords.break))
        result = new Break();
      else if (this._match(TokenTypes.keywords.continue))
        result = new Continue();
      else
        result = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
      if (result != null)
        this._consume(TokenTypes.tokens.semicolon, "Expected ';' after statement.");
      return result;
    }
    _static_assert_statement() {
      if (!this._match(TokenTypes.keywords.static_assert))
        return null;
      let expression = this._optional_paren_expression();
      return new StaticAssert(expression);
    }
    _while_statement() {
      if (!this._match(TokenTypes.keywords.while))
        return null;
      let condition = this._optional_paren_expression();
      const block = this._compound_statement();
      return new While(condition, block);
    }
    _continuing_statement() {
      if (!this._match(TokenTypes.keywords.continuing))
        return null;
      const block = this._compound_statement();
      return new Continuing(block);
    }
    _for_statement() {
      if (!this._match(TokenTypes.keywords.for))
        return null;
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const init = !this._check(TokenTypes.tokens.semicolon) ? this._for_init() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const condition = !this._check(TokenTypes.tokens.semicolon) ? this._short_circuit_or_expression() : null;
      this._consume(TokenTypes.tokens.semicolon, "Expected ';'.");
      const increment = !this._check(TokenTypes.tokens.paren_right) ? this._for_increment() : null;
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      const body = this._compound_statement();
      return new For(init, condition, increment, body);
    }
    _for_init() {
      return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
    }
    _for_increment() {
      return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
    }
    _variable_statement() {
      if (this._check(TokenTypes.keywords.var)) {
        const _var = this._variable_decl();
        if (_var === null)
          throw this._error(this._peek(), "Variable declaration expected.");
        let value = null;
        if (this._match(TokenTypes.tokens.equal))
          value = this._short_circuit_or_expression();
        return new Var(_var.name, _var.type, _var.storage, _var.access, value);
      }
      if (this._match(TokenTypes.keywords.let)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for let.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null)
            type.attributes = typeAttrs;
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for let.");
        const value = this._short_circuit_or_expression();
        return new Let(name13, type, null, null, value);
      }
      if (this._match(TokenTypes.keywords.const)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for const.").toString();
        let type = null;
        if (this._match(TokenTypes.tokens.colon)) {
          const typeAttrs = this._attribute();
          type = this._type_decl();
          if (type != null)
            type.attributes = typeAttrs;
        }
        this._consume(TokenTypes.tokens.equal, "Expected '=' for const.");
        const value = this._short_circuit_or_expression();
        return new Const(name13, type, null, null, value);
      }
      return null;
    }
    _increment_decrement_statement() {
      const savedPos = this._current;
      const _var = this._unary_expression();
      if (_var == null)
        return null;
      if (!this._check(TokenTypes.increment_operators)) {
        this._current = savedPos;
        return null;
      }
      const token = this._consume(TokenTypes.increment_operators, "Expected increment operator");
      return new Increment(token.type === TokenTypes.tokens.plus_plus ? IncrementOperator.increment : IncrementOperator.decrement, _var);
    }
    _assignment_statement() {
      let _var = null;
      if (this._check(TokenTypes.tokens.brace_right))
        return null;
      let isUnderscore = this._match(TokenTypes.tokens.underscore);
      if (!isUnderscore)
        _var = this._unary_expression();
      if (!isUnderscore && _var == null)
        return null;
      const type = this._consume(TokenTypes.assignment_operators, "Expected assignment operator.");
      const value = this._short_circuit_or_expression();
      return new Assign(AssignOperator.parse(type.lexeme), _var, value);
    }
    _func_call_statement() {
      if (!this._check(TokenTypes.tokens.ident))
        return null;
      const savedPos = this._current;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected function name.");
      const args = this._argument_expression_list();
      if (args === null) {
        this._current = savedPos;
        return null;
      }
      return new Call(name13.lexeme, args);
    }
    _loop_statement() {
      if (!this._match(TokenTypes.keywords.loop))
        return null;
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for loop.");
      const statements = [];
      let statement = this._statement();
      while (statement !== null) {
        if (Array.isArray(statement)) {
          for (let s3 of statement) {
            statements.push(s3);
          }
        } else {
          statements.push(statement);
        }
        statement = this._statement();
      }
      let continuing = null;
      if (this._match(TokenTypes.keywords.continuing))
        continuing = this._compound_statement();
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for loop.");
      return new Loop(statements, continuing);
    }
    _switch_statement() {
      if (!this._match(TokenTypes.keywords.switch))
        return null;
      const condition = this._optional_paren_expression();
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for switch.");
      const body = this._switch_body();
      if (body == null || body.length == 0)
        throw this._error(this._previous(), "Expected 'case' or 'default'.");
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' for switch.");
      return new Switch(condition, body);
    }
    _switch_body() {
      const cases = [];
      if (this._match(TokenTypes.keywords.case)) {
        const selector = this._case_selectors();
        this._match(TokenTypes.tokens.colon);
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch case.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch case.");
        cases.push(new Case(selector, body));
      }
      if (this._match(TokenTypes.keywords.default)) {
        this._match(TokenTypes.tokens.colon);
        this._consume(TokenTypes.tokens.brace_left, "Exected '{' for switch default.");
        const body = this._case_body();
        this._consume(TokenTypes.tokens.brace_right, "Exected '}' for switch default.");
        cases.push(new Default(body));
      }
      if (this._check([TokenTypes.keywords.default, TokenTypes.keywords.case])) {
        const _cases = this._switch_body();
        cases.push(_cases[0]);
      }
      return cases;
    }
    _case_selectors() {
      var _a2, _b, _c, _d;
      const selectors = [
        (_b = (_a2 = this._shift_expression()) === null || _a2 === void 0 ? void 0 : _a2.evaluate(this._context).toString()) !== null && _b !== void 0 ? _b : ""
      ];
      while (this._match(TokenTypes.tokens.comma)) {
        selectors.push((_d = (_c = this._shift_expression()) === null || _c === void 0 ? void 0 : _c.evaluate(this._context).toString()) !== null && _d !== void 0 ? _d : "");
      }
      return selectors;
    }
    _case_body() {
      if (this._match(TokenTypes.keywords.fallthrough)) {
        this._consume(TokenTypes.tokens.semicolon, "Expected ';'");
        return [];
      }
      let statement = this._statement();
      if (statement == null)
        return [];
      if (!(statement instanceof Array)) {
        statement = [statement];
      }
      const nextStatement = this._case_body();
      if (nextStatement.length == 0)
        return statement;
      return [...statement, nextStatement[0]];
    }
    _if_statement() {
      if (!this._match(TokenTypes.keywords.if))
        return null;
      const condition = this._optional_paren_expression();
      const block = this._compound_statement();
      let elseif = [];
      if (this._match_elseif()) {
        elseif = this._elseif_statement(elseif);
      }
      let _else = null;
      if (this._match(TokenTypes.keywords.else))
        _else = this._compound_statement();
      return new If(condition, block, elseif, _else);
    }
    _match_elseif() {
      if (this._tokens[this._current].type === TokenTypes.keywords.else && this._tokens[this._current + 1].type === TokenTypes.keywords.if) {
        this._advance();
        this._advance();
        return true;
      }
      return false;
    }
    _elseif_statement(elseif = []) {
      const condition = this._optional_paren_expression();
      const block = this._compound_statement();
      elseif.push(new ElseIf(condition, block));
      if (this._match_elseif()) {
        this._elseif_statement(elseif);
      }
      return elseif;
    }
    _return_statement() {
      if (!this._match(TokenTypes.keywords.return))
        return null;
      const value = this._short_circuit_or_expression();
      return new Return(value);
    }
    _short_circuit_or_expression() {
      let expr = this._short_circuit_and_expr();
      while (this._match(TokenTypes.tokens.or_or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._short_circuit_and_expr());
      }
      return expr;
    }
    _short_circuit_and_expr() {
      let expr = this._inclusive_or_expression();
      while (this._match(TokenTypes.tokens.and_and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._inclusive_or_expression());
      }
      return expr;
    }
    _inclusive_or_expression() {
      let expr = this._exclusive_or_expression();
      while (this._match(TokenTypes.tokens.or)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._exclusive_or_expression());
      }
      return expr;
    }
    _exclusive_or_expression() {
      let expr = this._and_expression();
      while (this._match(TokenTypes.tokens.xor)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._and_expression());
      }
      return expr;
    }
    _and_expression() {
      let expr = this._equality_expression();
      while (this._match(TokenTypes.tokens.and)) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._equality_expression());
      }
      return expr;
    }
    _equality_expression() {
      const expr = this._relational_expression();
      if (this._match([TokenTypes.tokens.equal_equal, TokenTypes.tokens.not_equal])) {
        return new BinaryOperator(this._previous().toString(), expr, this._relational_expression());
      }
      return expr;
    }
    _relational_expression() {
      let expr = this._shift_expression();
      while (this._match([
        TokenTypes.tokens.less_than,
        TokenTypes.tokens.greater_than,
        TokenTypes.tokens.less_than_equal,
        TokenTypes.tokens.greater_than_equal
      ])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._shift_expression());
      }
      return expr;
    }
    _shift_expression() {
      let expr = this._additive_expression();
      while (this._match([TokenTypes.tokens.shift_left, TokenTypes.tokens.shift_right])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._additive_expression());
      }
      return expr;
    }
    _additive_expression() {
      let expr = this._multiplicative_expression();
      while (this._match([TokenTypes.tokens.plus, TokenTypes.tokens.minus])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._multiplicative_expression());
      }
      return expr;
    }
    _multiplicative_expression() {
      let expr = this._unary_expression();
      while (this._match([
        TokenTypes.tokens.star,
        TokenTypes.tokens.forward_slash,
        TokenTypes.tokens.modulo
      ])) {
        expr = new BinaryOperator(this._previous().toString(), expr, this._unary_expression());
      }
      return expr;
    }
    _unary_expression() {
      if (this._match([
        TokenTypes.tokens.minus,
        TokenTypes.tokens.bang,
        TokenTypes.tokens.tilde,
        TokenTypes.tokens.star,
        TokenTypes.tokens.and
      ])) {
        return new UnaryOperator(this._previous().toString(), this._unary_expression());
      }
      return this._singular_expression();
    }
    _singular_expression() {
      const expr = this._primary_expression();
      const p3 = this._postfix_expression();
      if (p3)
        expr.postfix = p3;
      return expr;
    }
    _postfix_expression() {
      if (this._match(TokenTypes.tokens.bracket_left)) {
        const expr = this._short_circuit_or_expression();
        this._consume(TokenTypes.tokens.bracket_right, "Expected ']'.");
        const p3 = this._postfix_expression();
        if (p3)
          expr.postfix = p3;
        return expr;
      }
      if (this._match(TokenTypes.tokens.period)) {
        const name13 = this._consume(TokenTypes.tokens.ident, "Expected member name.");
        const p3 = this._postfix_expression();
        const expr = new StringExpr(name13.lexeme);
        if (p3)
          expr.postfix = p3;
        return expr;
      }
      return null;
    }
    _getStruct(name13) {
      if (this._context.aliases.has(name13)) {
        const alias = this._context.aliases.get(name13).type;
        return alias;
      }
      if (this._context.structs.has(name13)) {
        const struct = this._context.structs.get(name13);
        return struct;
      }
      return null;
    }
    _primary_expression() {
      if (this._match(TokenTypes.tokens.ident)) {
        const name13 = this._previous().toString();
        if (this._check(TokenTypes.tokens.paren_left)) {
          const args2 = this._argument_expression_list();
          const struct = this._getStruct(name13);
          if (struct != null) {
            return new CreateExpr(struct, args2);
          }
          return new CallExpr(name13, args2);
        }
        if (this._context.constants.has(name13)) {
          const c2 = this._context.constants.get(name13);
          return new ConstExpr(name13, c2.value);
        }
        return new VariableExpr(name13);
      }
      if (this._match(TokenTypes.const_literal)) {
        return new LiteralExpr(parseFloat(this._previous().toString()));
      }
      if (this._check(TokenTypes.tokens.paren_left)) {
        return this._paren_expression();
      }
      if (this._match(TokenTypes.keywords.bitcast)) {
        this._consume(TokenTypes.tokens.less_than, "Expected '<'.");
        const type2 = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
        const value = this._paren_expression();
        return new BitcastExpr(type2, value);
      }
      const type = this._type_decl();
      const args = this._argument_expression_list();
      return new TypecastExpr(type, args);
    }
    _argument_expression_list() {
      if (!this._match(TokenTypes.tokens.paren_left))
        return null;
      const args = [];
      do {
        if (this._check(TokenTypes.tokens.paren_right))
          break;
        const arg = this._short_circuit_or_expression();
        args.push(arg);
      } while (this._match(TokenTypes.tokens.comma));
      this._consume(TokenTypes.tokens.paren_right, "Expected ')' for agument list");
      return args;
    }
    _optional_paren_expression() {
      this._match(TokenTypes.tokens.paren_left);
      const expr = this._short_circuit_or_expression();
      this._match(TokenTypes.tokens.paren_right);
      return new GroupingExpr([expr]);
    }
    _paren_expression() {
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      const expr = this._short_circuit_or_expression();
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new GroupingExpr([expr]);
    }
    _struct_decl() {
      if (!this._match(TokenTypes.keywords.struct))
        return null;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected name for struct.").toString();
      this._consume(TokenTypes.tokens.brace_left, "Expected '{' for struct body.");
      const members = [];
      while (!this._check(TokenTypes.tokens.brace_right)) {
        const memberAttrs = this._attribute();
        const memberName = this._consume(TokenTypes.tokens.ident, "Expected variable name.").toString();
        this._consume(TokenTypes.tokens.colon, "Expected ':' for struct member type.");
        const typeAttrs = this._attribute();
        const memberType = this._type_decl();
        if (memberType != null)
          memberType.attributes = typeAttrs;
        if (!this._check(TokenTypes.tokens.brace_right))
          this._consume(TokenTypes.tokens.comma, "Expected ',' for struct member.");
        else
          this._match(TokenTypes.tokens.comma);
        members.push(new Member(memberName, memberType, memberAttrs));
      }
      this._consume(TokenTypes.tokens.brace_right, "Expected '}' after struct body.");
      const structNode = new Struct(name13, members);
      this._context.structs.set(name13, structNode);
      return structNode;
    }
    _global_variable_decl() {
      const _var = this._variable_decl();
      if (_var && this._match(TokenTypes.tokens.equal))
        _var.value = this._const_expression();
      return _var;
    }
    _override_variable_decl() {
      const _override = this._override_decl();
      if (_override && this._match(TokenTypes.tokens.equal))
        _override.value = this._const_expression();
      return _override;
    }
    _global_const_decl() {
      if (!this._match(TokenTypes.keywords.const))
        return null;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        const valueExpr = this._short_circuit_or_expression();
        if (valueExpr instanceof CreateExpr) {
          value = valueExpr;
        } else if (valueExpr instanceof ConstExpr && valueExpr.initializer instanceof CreateExpr) {
          value = valueExpr.initializer;
        } else {
          try {
            const constValue = valueExpr.evaluate(this._context);
            value = new LiteralExpr(constValue);
          } catch (_a2) {
            value = valueExpr;
          }
        }
      }
      const c2 = new Const(name13.toString(), type, "", "", value);
      this._context.constants.set(c2.name, c2);
      return c2;
    }
    _global_let_decl() {
      if (!this._match(TokenTypes.keywords.let))
        return null;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      let value = null;
      if (this._match(TokenTypes.tokens.equal)) {
        value = this._const_expression();
      }
      return new Let(name13.toString(), type, "", "", value);
    }
    _const_expression() {
      if (this._match(TokenTypes.const_literal))
        return new StringExpr(this._previous().toString());
      const type = this._type_decl();
      this._consume(TokenTypes.tokens.paren_left, "Expected '('.");
      let args = [];
      while (!this._check(TokenTypes.tokens.paren_right)) {
        args.push(this._const_expression());
        if (!this._check(TokenTypes.tokens.comma))
          break;
        this._advance();
      }
      this._consume(TokenTypes.tokens.paren_right, "Expected ')'.");
      return new CreateExpr(type, args);
    }
    _variable_decl() {
      if (!this._match(TokenTypes.keywords.var))
        return null;
      let storage = "";
      let access = "";
      if (this._match(TokenTypes.tokens.less_than)) {
        storage = this._consume(TokenTypes.storage_class, "Expected storage_class.").toString();
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>'.");
      }
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      return new Var(name13.toString(), type, storage, access, null);
    }
    _override_decl() {
      if (!this._match(TokenTypes.keywords.override))
        return null;
      const name13 = this._consume(TokenTypes.tokens.ident, "Expected variable name");
      let type = null;
      if (this._match(TokenTypes.tokens.colon)) {
        const attrs = this._attribute();
        type = this._type_decl();
        if (type != null)
          type.attributes = attrs;
      }
      return new Override(name13.toString(), type, null);
    }
    _enable_directive() {
      const name13 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      return new Enable(name13.toString());
    }
    _type_alias() {
      const name13 = this._consume(TokenTypes.tokens.ident, "identity expected.");
      this._consume(TokenTypes.tokens.equal, "Expected '=' for type alias.");
      let aliasType = this._type_decl();
      if (aliasType === null) {
        throw this._error(this._peek(), "Expected Type for Alias.");
      }
      if (this._context.aliases.has(aliasType.name)) {
        aliasType = this._context.aliases.get(aliasType.name).type;
      }
      const aliasNode = new Alias(name13.toString(), aliasType);
      this._context.aliases.set(aliasNode.name, aliasNode);
      return aliasNode;
    }
    _type_decl() {
      if (this._check([
        TokenTypes.tokens.ident,
        ...TokenTypes.texel_format,
        TokenTypes.keywords.bool,
        TokenTypes.keywords.f32,
        TokenTypes.keywords.i32,
        TokenTypes.keywords.u32
      ])) {
        const type2 = this._advance();
        const typeName = type2.toString();
        if (this._context.structs.has(typeName)) {
          return this._context.structs.get(typeName);
        }
        if (this._context.aliases.has(typeName)) {
          return this._context.aliases.get(typeName).type;
        }
        return new Type(type2.toString());
      }
      let type = this._texture_sampler_types();
      if (type)
        return type;
      if (this._check(TokenTypes.template_types)) {
        let type2 = this._advance().toString();
        let format = null;
        let access = null;
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          access = null;
          if (this._match(TokenTypes.tokens.comma))
            access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for type.");
        }
        return new TemplateType(type2, format, access);
      }
      if (this._match(TokenTypes.keywords.ptr)) {
        let pointer = this._previous().toString();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for pointer.");
        const storage = this._consume(TokenTypes.storage_class, "Expected storage_class for pointer");
        this._consume(TokenTypes.tokens.comma, "Expected ',' for pointer.");
        const decl = this._type_decl();
        let access = null;
        if (this._match(TokenTypes.tokens.comma))
          access = this._consume(TokenTypes.access_mode, "Expected access_mode for pointer").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for pointer.");
        return new PointerType(pointer, storage.toString(), decl, access);
      }
      const attrs = this._attribute();
      if (this._match(TokenTypes.keywords.array)) {
        let format = null;
        let countInt = -1;
        const array = this._previous();
        if (this._match(TokenTypes.tokens.less_than)) {
          format = this._type_decl();
          if (this._context.aliases.has(format.name)) {
            format = this._context.aliases.get(format.name).type;
          }
          let count2 = "";
          if (this._match(TokenTypes.tokens.comma)) {
            let c2 = this._shift_expression();
            count2 = c2.evaluate(this._context).toString();
          }
          this._consume(TokenTypes.tokens.greater_than, "Expected '>' for array.");
          countInt = count2 ? parseInt(count2) : 0;
        }
        return new ArrayType(array.toString(), attrs, format, countInt);
      }
      return null;
    }
    _texture_sampler_types() {
      if (this._match(TokenTypes.sampler_type))
        return new SamplerType(this._previous().toString(), null, null);
      if (this._match(TokenTypes.depth_texture_type))
        return new SamplerType(this._previous().toString(), null, null);
      if (this._match(TokenTypes.sampled_texture_type) || this._match(TokenTypes.multisampled_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._type_decl();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, null);
      }
      if (this._match(TokenTypes.storage_texture_type)) {
        const sampler = this._previous();
        this._consume(TokenTypes.tokens.less_than, "Expected '<' for sampler type.");
        const format = this._consume(TokenTypes.texel_format, "Invalid texel format.").toString();
        this._consume(TokenTypes.tokens.comma, "Expected ',' after texel format.");
        const access = this._consume(TokenTypes.access_mode, "Expected access mode for storage texture type.").toString();
        this._consume(TokenTypes.tokens.greater_than, "Expected '>' for sampler type.");
        return new SamplerType(sampler.toString(), format, access);
      }
      return null;
    }
    _attribute() {
      let attributes = [];
      while (this._match(TokenTypes.tokens.attr)) {
        const name13 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
        const attr = new Attribute(name13.toString(), null);
        if (this._match(TokenTypes.tokens.paren_left)) {
          attr.value = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
          if (this._check(TokenTypes.tokens.comma)) {
            this._advance();
            do {
              const v2 = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
              if (!(attr.value instanceof Array)) {
                attr.value = [attr.value];
              }
              attr.value.push(v2);
            } while (this._match(TokenTypes.tokens.comma));
          }
          this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
        }
        attributes.push(attr);
      }
      while (this._match(TokenTypes.tokens.attr_left)) {
        if (!this._check(TokenTypes.tokens.attr_right)) {
          do {
            const name13 = this._consume(TokenTypes.attribute_name, "Expected attribute name");
            const attr = new Attribute(name13.toString(), null);
            if (this._match(TokenTypes.tokens.paren_left)) {
              attr.value = [
                this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString()
              ];
              if (this._check(TokenTypes.tokens.comma)) {
                this._advance();
                do {
                  const v2 = this._consume(TokenTypes.literal_or_ident, "Expected attribute value").toString();
                  attr.value.push(v2);
                } while (this._match(TokenTypes.tokens.comma));
              }
              this._consume(TokenTypes.tokens.paren_right, "Expected ')'");
            }
            attributes.push(attr);
          } while (this._match(TokenTypes.tokens.comma));
        }
        this._consume(TokenTypes.tokens.attr_right, "Expected ']]' after attribute declarations");
      }
      if (attributes.length == 0)
        return null;
      return attributes;
    }
  };
  var TypeInfo = class {
    constructor(name13, attributes) {
      this.name = name13;
      this.attributes = attributes;
      this.size = 0;
    }
    get isArray() {
      return false;
    }
    get isStruct() {
      return false;
    }
    get isTemplate() {
      return false;
    }
  };
  var MemberInfo = class {
    constructor(name13, type, attributes) {
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
      this.offset = 0;
      this.size = 0;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var StructInfo = class extends TypeInfo {
    constructor(name13, attributes) {
      super(name13, attributes);
      this.members = [];
      this.align = 0;
    }
    get isStruct() {
      return true;
    }
  };
  var ArrayInfo = class extends TypeInfo {
    constructor(name13, attributes) {
      super(name13, attributes);
      this.count = 0;
      this.stride = 0;
    }
    get isArray() {
      return true;
    }
  };
  var TemplateInfo = class extends TypeInfo {
    constructor(name13, format, attributes, access) {
      super(name13, attributes);
      this.format = format;
      this.access = access;
    }
    get isTemplate() {
      return true;
    }
  };
  var ResourceType;
  (function(ResourceType2) {
    ResourceType2[ResourceType2["Uniform"] = 0] = "Uniform";
    ResourceType2[ResourceType2["Storage"] = 1] = "Storage";
    ResourceType2[ResourceType2["Texture"] = 2] = "Texture";
    ResourceType2[ResourceType2["Sampler"] = 3] = "Sampler";
    ResourceType2[ResourceType2["StorageTexture"] = 4] = "StorageTexture";
  })(ResourceType || (ResourceType = {}));
  var VariableInfo = class {
    constructor(name13, type, group, binding, attributes, resourceType, access) {
      this.name = name13;
      this.type = type;
      this.group = group;
      this.binding = binding;
      this.attributes = attributes;
      this.resourceType = resourceType;
      this.access = access;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get size() {
      return this.type.size;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray ? this.type.format : this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  };
  var AliasInfo = class {
    constructor(name13, type) {
      this.name = name13;
      this.type = type;
    }
  };
  var _TypeSize = class {
    constructor(align, size) {
      this.align = align;
      this.size = size;
    }
  };
  var InputInfo = class {
    constructor(name13, type, locationType, location) {
      this.name = name13;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
      this.interpolation = null;
    }
  };
  var OutputInfo = class {
    constructor(name13, type, locationType, location) {
      this.name = name13;
      this.type = type;
      this.locationType = locationType;
      this.location = location;
    }
  };
  var FunctionInfo = class {
    constructor(name13, stage = null) {
      this.stage = null;
      this.inputs = [];
      this.outputs = [];
      this.name = name13;
      this.stage = stage;
    }
  };
  var EntryFunctions = class {
    constructor() {
      this.vertex = [];
      this.fragment = [];
      this.compute = [];
    }
  };
  var OverrideInfo = class {
    constructor(name13, type, attributes, id) {
      this.name = name13;
      this.type = type;
      this.attributes = attributes;
      this.id = id;
    }
  };
  var WgslReflect = class {
    constructor(code) {
      this.uniforms = [];
      this.storage = [];
      this.textures = [];
      this.samplers = [];
      this.aliases = [];
      this.overrides = [];
      this.structs = [];
      this.entry = new EntryFunctions();
      this._types = /* @__PURE__ */ new Map();
      if (code) {
        this.update(code);
      }
    }
    _isStorageTexture(type) {
      return type.name == "texture_storage_1d" || type.name == "texture_storage_2d" || type.name == "texture_storage_2d_array" || type.name == "texture_storage_3d";
    }
    update(code) {
      const parser = new WgslParser();
      const ast = parser.parse(code);
      for (const node2 of ast) {
        if (node2 instanceof Struct) {
          const info = this._getTypeInfo(node2, null);
          if (info instanceof StructInfo) {
            this.structs.push(info);
          }
          continue;
        }
        if (node2 instanceof Alias) {
          this.aliases.push(this._getAliasInfo(node2));
          continue;
        }
        if (node2 instanceof Override) {
          const v2 = node2;
          const id = this._getAttributeNum(v2.attributes, "id", 0);
          const type = v2.type != null ? this._getTypeInfo(v2.type, v2.attributes) : null;
          this.overrides.push(new OverrideInfo(v2.name, type, v2.attributes, id));
          continue;
        }
        if (this._isUniformVar(node2)) {
          const v2 = node2;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, ResourceType.Uniform, v2.access);
          this.uniforms.push(varInfo);
          continue;
        }
        if (this._isStorageVar(node2)) {
          const v2 = node2;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Storage, v2.access);
          this.storage.push(varInfo);
          continue;
        }
        if (this._isTextureVar(node2)) {
          const v2 = node2;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const isStorageTexture = this._isStorageTexture(type);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, isStorageTexture ? ResourceType.StorageTexture : ResourceType.Texture, v2.access);
          if (isStorageTexture) {
            this.storage.push(varInfo);
          } else {
            this.textures.push(varInfo);
          }
          continue;
        }
        if (this._isSamplerVar(node2)) {
          const v2 = node2;
          const g2 = this._getAttributeNum(v2.attributes, "group", 0);
          const b2 = this._getAttributeNum(v2.attributes, "binding", 0);
          const type = this._getTypeInfo(v2.type, v2.attributes);
          const varInfo = new VariableInfo(v2.name, type, g2, b2, v2.attributes, ResourceType.Sampler, v2.access);
          this.samplers.push(varInfo);
          continue;
        }
        if (node2 instanceof Function) {
          const vertexStage = this._getAttribute(node2, "vertex");
          const fragmentStage = this._getAttribute(node2, "fragment");
          const computeStage = this._getAttribute(node2, "compute");
          const stage = vertexStage || fragmentStage || computeStage;
          if (stage) {
            const fn = new FunctionInfo(node2.name, stage.name);
            fn.inputs = this._getInputs(node2.args);
            fn.outputs = this._getOutputs(node2.returnType);
            this.entry[stage.name].push(fn);
          }
          continue;
        }
      }
    }
    getBindGroups() {
      const groups = [];
      function _makeRoom(group, binding) {
        if (group >= groups.length)
          groups.length = group + 1;
        if (groups[group] === void 0)
          groups[group] = [];
        if (binding >= groups[group].length)
          groups[group].length = binding + 1;
      }
      for (const u3 of this.uniforms) {
        _makeRoom(u3.group, u3.binding);
        const group = groups[u3.group];
        group[u3.binding] = u3;
      }
      for (const u3 of this.storage) {
        _makeRoom(u3.group, u3.binding);
        const group = groups[u3.group];
        group[u3.binding] = u3;
      }
      for (const t3 of this.textures) {
        _makeRoom(t3.group, t3.binding);
        const group = groups[t3.group];
        group[t3.binding] = t3;
      }
      for (const t3 of this.samplers) {
        _makeRoom(t3.group, t3.binding);
        const group = groups[t3.group];
        group[t3.binding] = t3;
      }
      return groups;
    }
    _getOutputs(type, outputs = void 0) {
      if (outputs === void 0)
        outputs = [];
      if (type instanceof Struct) {
        this._getStructOutputs(type, outputs);
      } else {
        const output = this._getOutputInfo(type);
        if (output !== null)
          outputs.push(output);
      }
      return outputs;
    }
    _getStructOutputs(struct, outputs) {
      for (const m2 of struct.members) {
        if (m2.type instanceof Struct) {
          this._getStructOutputs(m2.type, outputs);
        } else {
          const location = this._getAttribute(m2, "location") || this._getAttribute(m2, "builtin");
          if (location !== null) {
            const typeInfo = this._getTypeInfo(m2.type, m2.type.attributes);
            const locationValue = this._parseInt(location.value);
            const info = new OutputInfo(m2.name, typeInfo, location.name, locationValue);
            outputs.push(info);
          }
        }
      }
    }
    _getOutputInfo(type) {
      const location = this._getAttribute(type, "location") || this._getAttribute(type, "builtin");
      if (location !== null) {
        const typeInfo = this._getTypeInfo(type, type.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new OutputInfo("", typeInfo, location.name, locationValue);
        return info;
      }
      return null;
    }
    _getInputs(args, inputs = void 0) {
      if (inputs === void 0)
        inputs = [];
      for (const arg of args) {
        if (arg.type instanceof Struct) {
          this._getStructInputs(arg.type, inputs);
        } else {
          const input = this._getInputInfo(arg);
          if (input !== null)
            inputs.push(input);
        }
      }
      return inputs;
    }
    _getStructInputs(struct, inputs) {
      for (const m2 of struct.members) {
        if (m2.type instanceof Struct) {
          this._getStructInputs(m2.type, inputs);
        } else {
          const input = this._getInputInfo(m2);
          if (input !== null)
            inputs.push(input);
        }
      }
    }
    _getInputInfo(node2) {
      const location = this._getAttribute(node2, "location") || this._getAttribute(node2, "builtin");
      if (location !== null) {
        const interpolation = this._getAttribute(node2, "interpolation");
        const type = this._getTypeInfo(node2.type, node2.attributes);
        const locationValue = this._parseInt(location.value);
        const info = new InputInfo(node2.name, type, location.name, locationValue);
        if (interpolation !== null) {
          info.interpolation = this._parseString(interpolation.value);
        }
        return info;
      }
      return null;
    }
    _parseString(s3) {
      if (s3 instanceof Array) {
        s3 = s3[0];
      }
      return s3;
    }
    _parseInt(s3) {
      if (s3 instanceof Array) {
        s3 = s3[0];
      }
      const n3 = parseInt(s3);
      return isNaN(n3) ? s3 : n3;
    }
    _getAlias(name13) {
      for (const a3 of this.aliases) {
        if (a3.name == name13)
          return a3.type;
      }
      return null;
    }
    _getAliasInfo(node2) {
      return new AliasInfo(node2.name, this._getTypeInfo(node2.type, null));
    }
    _getTypeInfo(type, attributes) {
      if (this._types.has(type)) {
        return this._types.get(type);
      }
      if (type instanceof ArrayType) {
        const a3 = type;
        const t3 = this._getTypeInfo(a3.format, a3.attributes);
        const info2 = new ArrayInfo(a3.name, attributes);
        info2.format = t3;
        info2.count = a3.count;
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof Struct) {
        const s3 = type;
        const info2 = new StructInfo(s3.name, attributes);
        for (const m2 of s3.members) {
          const t3 = this._getTypeInfo(m2.type, m2.attributes);
          info2.members.push(new MemberInfo(m2.name, t3, m2.attributes));
        }
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof SamplerType) {
        const s3 = type;
        const formatIsType = s3.format instanceof Type;
        const format = s3.format ? formatIsType ? this._getTypeInfo(s3.format, null) : new TypeInfo(s3.format, null) : null;
        const info2 = new TemplateInfo(s3.name, format, attributes, s3.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      if (type instanceof TemplateType) {
        const t3 = type;
        const format = t3.format ? this._getTypeInfo(t3.format, null) : null;
        const info2 = new TemplateInfo(t3.name, format, attributes, t3.access);
        this._types.set(type, info2);
        this._updateTypeInfo(info2);
        return info2;
      }
      const info = new TypeInfo(type.name, attributes);
      this._types.set(type, info);
      this._updateTypeInfo(info);
      return info;
    }
    _updateTypeInfo(type) {
      var _a2, _b;
      const typeSize = this._getTypeSize(type);
      type.size = (_a2 = typeSize === null || typeSize === void 0 ? void 0 : typeSize.size) !== null && _a2 !== void 0 ? _a2 : 0;
      if (type instanceof ArrayInfo) {
        const formatInfo = this._getTypeSize(type["format"]);
        type.stride = (_b = formatInfo === null || formatInfo === void 0 ? void 0 : formatInfo.size) !== null && _b !== void 0 ? _b : 0;
        this._updateTypeInfo(type["format"]);
      }
      if (type instanceof StructInfo) {
        this._updateStructInfo(type);
      }
    }
    _updateStructInfo(struct) {
      var _a2;
      let offset = 0;
      let lastSize = 0;
      let lastOffset = 0;
      let structAlign = 0;
      for (let mi = 0, ml = struct.members.length; mi < ml; ++mi) {
        const member = struct.members[mi];
        const sizeInfo = this._getTypeSize(member);
        if (!sizeInfo)
          continue;
        (_a2 = this._getAlias(member.type.name)) !== null && _a2 !== void 0 ? _a2 : member.type;
        const align = sizeInfo.align;
        const size = sizeInfo.size;
        offset = this._roundUp(align, offset + lastSize);
        lastSize = size;
        lastOffset = offset;
        structAlign = Math.max(structAlign, align);
        member.offset = offset;
        member.size = size;
        this._updateTypeInfo(member.type);
      }
      struct.size = this._roundUp(structAlign, lastOffset + lastSize);
      struct.align = structAlign;
    }
    _getTypeSize(type) {
      var _a2;
      if (type === null || type === void 0)
        return null;
      const explicitSize = this._getAttributeNum(type.attributes, "size", 0);
      const explicitAlign = this._getAttributeNum(type.attributes, "align", 0);
      if (type instanceof MemberInfo)
        type = type.type;
      if (type instanceof TypeInfo) {
        const alias = this._getAlias(type.name);
        if (alias !== null) {
          type = alias;
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name];
        if (info !== void 0) {
          const divisor = type["format"] === "f16" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      {
        const info = WgslReflect._typeInfo[type.name.substring(0, type.name.length - 1)];
        if (info) {
          const divisor = type.name[type.name.length - 1] === "h" ? 2 : 1;
          return new _TypeSize(Math.max(explicitAlign, info.align / divisor), Math.max(explicitSize, info.size / divisor));
        }
      }
      if (type instanceof ArrayInfo) {
        let arrayType = type;
        let align = 8;
        let size = 8;
        const E = this._getTypeSize(arrayType.format);
        if (E !== null) {
          size = E.size;
          align = E.align;
        }
        const N2 = arrayType.count;
        const stride = this._getAttributeNum((_a2 = type === null || type === void 0 ? void 0 : type.attributes) !== null && _a2 !== void 0 ? _a2 : null, "stride", this._roundUp(align, size));
        size = N2 * stride;
        if (explicitSize)
          size = explicitSize;
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      if (type instanceof StructInfo) {
        let align = 0;
        let size = 0;
        let offset = 0;
        let lastSize = 0;
        let lastOffset = 0;
        for (const m2 of type.members) {
          const mi = this._getTypeSize(m2.type);
          if (mi !== null) {
            align = Math.max(mi.align, align);
            offset = this._roundUp(mi.align, offset + lastSize);
            lastSize = mi.size;
            lastOffset = offset;
          }
        }
        size = this._roundUp(align, lastOffset + lastSize);
        return new _TypeSize(Math.max(explicitAlign, align), Math.max(explicitSize, size));
      }
      return null;
    }
    _isUniformVar(node2) {
      return node2 instanceof Var && node2.storage == "uniform";
    }
    _isStorageVar(node2) {
      return node2 instanceof Var && node2.storage == "storage";
    }
    _isTextureVar(node2) {
      return node2 instanceof Var && node2.type !== null && WgslReflect._textureTypes.indexOf(node2.type.name) != -1;
    }
    _isSamplerVar(node2) {
      return node2 instanceof Var && node2.type !== null && WgslReflect._samplerTypes.indexOf(node2.type.name) != -1;
    }
    _getAttribute(node2, name13) {
      const obj = node2;
      if (!obj || !obj["attributes"])
        return null;
      const attrs = obj["attributes"];
      for (let a3 of attrs) {
        if (a3.name == name13)
          return a3;
      }
      return null;
    }
    _getAttributeNum(attributes, name13, defaultValue2) {
      if (attributes === null)
        return defaultValue2;
      for (let a3 of attributes) {
        if (a3.name == name13) {
          let v2 = a3 !== null && a3.value !== null ? a3.value : defaultValue2;
          if (v2 instanceof Array) {
            v2 = v2[0];
          }
          if (typeof v2 === "number") {
            return v2;
          }
          if (typeof v2 === "string") {
            return parseInt(v2);
          }
          return defaultValue2;
        }
      }
      return defaultValue2;
    }
    _roundUp(k2, n3) {
      return Math.ceil(n3 / k2) * k2;
    }
  };
  WgslReflect._typeInfo = {
    f16: { align: 2, size: 2 },
    i32: { align: 4, size: 4 },
    u32: { align: 4, size: 4 },
    f32: { align: 4, size: 4 },
    atomic: { align: 4, size: 4 },
    vec2: { align: 8, size: 8 },
    vec3: { align: 16, size: 12 },
    vec4: { align: 16, size: 16 },
    mat2x2: { align: 8, size: 16 },
    mat3x2: { align: 8, size: 24 },
    mat4x2: { align: 8, size: 32 },
    mat2x3: { align: 16, size: 32 },
    mat3x3: { align: 16, size: 48 },
    mat4x3: { align: 16, size: 64 },
    mat2x4: { align: 16, size: 32 },
    mat3x4: { align: 16, size: 48 },
    mat4x4: { align: 16, size: 64 }
  };
  WgslReflect._textureTypes = TokenTypes.any_texture_type.map((t3) => {
    return t3.name;
  });
  WgslReflect._samplerTypes = TokenTypes.sampler_type.map((t3) => {
    return t3.name;
  });

  // ../../node_modules/@luma.gl/shadertools/dist/lib/wgsl/get-shader-layout-wgsl.js
  function getShaderLayoutFromWGSL(source) {
    const shaderLayout = { attributes: [], bindings: [] };
    let parsedWGSL;
    try {
      parsedWGSL = parseWGSL(source);
    } catch (error) {
      log2.error(error.message)();
      return shaderLayout;
    }
    for (const uniform of parsedWGSL.uniforms) {
      const members = [];
      for (const member of uniform.type.members) {
        members.push({
          name: member.name,
          type: getType(member.type)
        });
      }
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniform.name,
        location: uniform.binding,
        group: uniform.group,
        members
      });
    }
    const vertex = parsedWGSL.entry.vertex[0];
    const attributeCount = vertex?.inputs.length || 0;
    for (let i5 = 0; i5 < attributeCount; i5++) {
      const wgslAttribute = vertex.inputs[i5];
      if (wgslAttribute.locationType === "location") {
        const type = getType(wgslAttribute.type);
        shaderLayout.attributes.push({
          name: wgslAttribute.name,
          location: wgslAttribute.location,
          type
        });
      }
    }
    return shaderLayout;
  }
  function getType(type) {
    return type.format ? `${type.name}<${type.format.name}>` : type.name;
  }
  function parseWGSL(source) {
    try {
      return new WgslReflect(source);
    } catch (error) {
      if (error instanceof Error) {
        throw error;
      }
      let message2 = "WGSL parse error";
      if (typeof error === "object" && error?.message) {
        message2 += `: ${error.message} `;
      }
      if (typeof error === "object" && error?.token) {
        message2 += error.token.line || "";
      }
      throw new Error(message2, { cause: error });
    }
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js
  var fp32shader = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`;
  var fp32 = {
    name: "fp32",
    vs: fp32shader
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = new Float32Array([0, 1, 1, 1]);
  var vs = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`;
  var fs = `uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`;
  var picking = {
    name: "picking",
    vs,
    fs,
    uniformTypes: {
      isActive: "f32",
      isAttribute: "f32",
      isHighlightActive: "f32",
      useFloatColors: "f32",
      highlightedObjectColor: "vec3<f32>",
      highlightColor: "vec4<f32>"
    },
    defaultUniforms: {
      isActive: false,
      isAttribute: false,
      isHighlightActive: false,
      useFloatColors: true,
      highlightedObjectColor: new Float32Array([0, 0, 0]),
      highlightColor: DEFAULT_HIGHLIGHT_COLOR
    },
    getUniforms
  };
  function getUniforms(opts = {}, prevUniforms) {
    const uniforms = {};
    if (opts.highlightedObjectColor === void 0) {
    } else if (opts.highlightedObjectColor === null) {
      uniforms.isHighlightActive = false;
    } else {
      uniforms.isHighlightActive = true;
      const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);
      uniforms.highlightedObjectColor = highlightedObjectColor;
    }
    if (opts.highlightColor) {
      const color = Array.from(opts.highlightColor, (x3) => x3 / 255);
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.highlightColor = color;
    }
    if (opts.isActive !== void 0) {
      uniforms.isActive = Boolean(opts.isActive);
      uniforms.isAttribute = Boolean(opts.isAttribute);
    }
    if (opts.useFloatColors !== void 0) {
      uniforms.useFloatColors = Boolean(opts.useFloatColors);
    }
    return uniforms;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64-utils.js
  function fp64ify(a3, out = [], startIndex = 0) {
    const hiPart = Math.fround(a3);
    const loPart = a3 - hiPart;
    out[startIndex] = hiPart;
    out[startIndex + 1] = loPart;
    return out;
  }
  function fp64LowPart(a3) {
    return a3 - Math.fround(a3);
  }
  function fp64ifyMatrix4(matrix) {
    const matrixFP64 = new Float32Array(32);
    for (let i5 = 0; i5 < 4; ++i5) {
      for (let j2 = 0; j2 < 4; ++j2) {
        const index2 = i5 * 4 + j2;
        fp64ify(matrix[j2 * 4 + i5], matrixFP64, index2 * 2);
      }
    }
    return matrixFP64;
  }

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64-arithmetic-glsl.js
  var fp64arithmeticShader = `uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64-functions-glsl.js
  var fp64functionShader = `const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);
const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);
const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);
const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);
float nint(float d) {
if (d == floor(d)) return d;
return floor(d + 0.5);
}
vec2 nint_fp64(vec2 a) {
float hi = nint(a.x);
float lo;
vec2 tmp;
if (hi == a.x) {
lo = nint(a.y);
tmp = quickTwoSum(hi, lo);
} else {
lo = 0.0;
if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
hi -= 1.0;
}
tmp = vec2(hi, lo);
}
return tmp;
}
vec2 exp_fp64(vec2 a) {
const int k_power = 4;
const float k = 16.0;
const float inv_k = 1.0 / k;
if (a.x <= -88.0) return vec2(0.0, 0.0);
if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
if (a.x == 1.0 && a.y == 0.0) return E_FP64;
float m = floor(a.x / LOG2_FP64.x + 0.5);
vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
vec2 s, t, p;
p = mul_fp64(r, r);
s = sum_fp64(r, p * 0.5);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
for (int i = 0; i < k_power; i++) {
s = sum_fp64(s * 2.0, mul_fp64(s, s));
}
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = sum_fp64(s, vec2(ONE, 0.0));
#else
s = sum_fp64(s, vec2(1.0, 0.0));
#endif
return s * pow(2.0, m);
}
vec2 log_fp64(vec2 a)
{
if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
vec2 x = vec2(log(a.x), 0.0);
vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = vec2(ONE, 0.0);
#else
s = vec2(1.0, 0.0);
#endif
x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
return x;
}
vec2 sin_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
x = -mul_fp64(a, a);
s = a;
r = a;
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
return s;
}
vec2 cos_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
x = -mul_fp64(a, a);
r = x;
s = sum_fp64(vec2(1.0, 0.0), r * 0.5);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
s = sum_fp64(s, t);
return s;
}
void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
if (a.x == 0.0 && a.y == 0.0) {
sin_t = vec2(0.0, 0.0);
cos_t = vec2(1.0, 0.0);
}
sin_t = sin_taylor_fp64(a);
cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}
vec2 sin_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return sin_taylor_fp64(t);
} else if (j == 1) {
return cos_taylor_fp64(t);
} else if (j == -1) {
return -cos_taylor_fp64(t);
} else {
return -sin_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else if (j == 1) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
}
} else {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
}
return result;
}
vec2 cos_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return cos_taylor_fp64(t);
} else if (j == 1) {
return -sin_taylor_fp64(t);
} else if (j == -1) {
return sin_taylor_fp64(t);
} else {
return -cos_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == 1) {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
return result;
}
vec2 tan_fp64(vec2 a) {
vec2 sin_a;
vec2 cos_a;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
vec2 sin_t, cos_t;
vec2 s, c;
sincos_taylor_fp64(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
if (k > 0) {
s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return div_fp64(sin_a, cos_a);
}
vec2 radians_fp64(vec2 degree) {
return mul_fp64(degree, PI_180_FP64);
}
vec2 mix_fp64(vec2 a, vec2 b, float x) {
vec2 range = sub_fp64(b, a);
return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sum_fp64(a[0], b[0]);
out_val[1] = sum_fp64(a[1], b[1]);
}
void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sub_fp64(a[0], b[0]);
out_val[1] = sub_fp64(a[1], b[1]);
}
void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = mul_fp64(a[0], b[0]);
out_val[1] = mul_fp64(a[1], b[1]);
}
void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = div_fp64(a[0], b[0]);
out_val[1] = div_fp64(a[1], b[1]);
}
void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
vec2 range[2];
vec2_sub_fp64(y, x, range);
vec2 portion[2];
portion[0] = range[0] * a;
portion[1] = range[1] * a;
vec2_sum_fp64(x, portion, out_val);
}
vec2 vec2_length_fp64(vec2 x[2]) {
return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}
void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
vec2 length = vec2_length_fp64(x);
vec2 length_vec2[2];
length_vec2[0] = length;
length_vec2[1] = length;
vec2_div_fp64(x, length_vec2, out_val);
}
vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
vec2 diff[2];
vec2_sub_fp64(x, y, diff);
return vec2_length_fp64(diff);
}
vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
vec2 v[2];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
vec2 vec3_length_fp64(vec2 x[3]) {
return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
mul_fp64(x[2], x[2])));
}
vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
vec2 diff[3];
vec3_sub_fp64(x, y, diff);
return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
out_val[0].x = a[0];
out_val[0].y = 0.0;
out_val[1].x = a[1];
out_val[1].y = 0.0;
out_val[2].x = a[2];
out_val[2].y = 0.0;
out_val[3].x = a[3];
out_val[3].y = 0.0;
}
void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
out_val[0] = mul_fp64(a[0], b);
out_val[1] = mul_fp64(a[1], b);
out_val[2] = mul_fp64(a[2], b);
out_val[3] = mul_fp64(a[3], b);
}
void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
for (int i = 0; i < 4; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
vec2 v[4];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
v[2] = mul_fp64(a[2], b[2]);
v[3] = mul_fp64(a[3], b[3]);
out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}
void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
vec2 tmp[4];
for (int i = 0; i < 4; i++)
{
for (int j = 0; j < 4; j++)
{
tmp[j] = b[j + i * 4];
}
vec4_dot_fp64(a, tmp, out_val[i]);
}
}
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/math/fp64/fp64.js
  var CONST_UNIFORMS = {
    ONE: 1
  };
  function getUniforms2() {
    return CONST_UNIFORMS;
  }
  var fp64arithmetic = {
    name: "fp64-arithmetic",
    vs: fp64arithmeticShader,
    getUniforms: getUniforms2,
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };
  var fp64 = {
    name: "fp64",
    vs: fp64functionShader,
    dependencies: [fp64arithmetic],
    fp64ify,
    fp64LowPart,
    fp64ifyMatrix4
  };

  // ../../node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
  var config = globalThis.mathgl.config;
  function formatValue(value, { precision = config.precision } = {}) {
    value = round(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function toRadians(degrees2) {
    return radians(degrees2);
  }
  function toDegrees(radians2) {
    return degrees(radians2);
  }
  function radians(degrees2, result) {
    return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS, result);
  }
  function degrees(radians2, result) {
    return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES, result);
  }
  function clamp(value, min4, max4) {
    return map(value, (value2) => Math.max(min4, Math.min(max4, value2)));
  }
  function lerp(a3, b2, t3) {
    if (isArray(a3)) {
      return a3.map((ai, i5) => lerp(ai, b2[i5], t3));
    }
    return t3 * b2 + (1 - t3) * a3;
  }
  function equals(a3, b2, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a3 === b2) {
        return true;
      }
      if (isArray(a3) && isArray(b2)) {
        if (a3.length !== b2.length) {
          return false;
        }
        for (let i5 = 0; i5 < a3.length; ++i5) {
          if (!equals(a3[i5], b2[i5])) {
            return false;
          }
        }
        return true;
      }
      if (a3 && a3.equals) {
        return a3.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a3);
      }
      if (typeof a3 === "number" && typeof b2 === "number") {
        return Math.abs(a3 - b2) <= config.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b2));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value, func, result) {
    if (isArray(value)) {
      const array = value;
      result = result || duplicateArray(array);
      for (let i5 = 0; i5 < result.length && i5 < array.length; ++i5) {
        const val2 = typeof value === "number" ? value : value[i5];
        result[i5] = func(val2, i5, result);
      }
      return result;
    }
    return func(value);
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray = class extends Array {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = array[i5 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        targetArray[offset + i5] = this[i5];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        string += (i5 > 0 ? ", " : "") + formatValue(this[i5], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (!equals(this[i5], array[i5])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        if (this[i5] !== array[i5]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = -this[i5];
      }
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const ai = a3[i5];
        const endValue = typeof b2 === "number" ? b2 : b2[i5];
        this[i5] = ai + t3 * (endValue - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(vector[i5], this[i5]);
      }
      return this.check();
    }
    max(vector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.max(vector[i5], this[i5]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], minVector[i5]), maxVector[i5]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] += vector[i5];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] -= vector[i5];
        }
      }
      return this.check();
    }
    scale(scale7) {
      if (typeof scale7 === "number") {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= scale7;
        }
      } else {
        for (let i5 = 0; i5 < this.ELEMENTS && i5 < scale7.length; ++i5) {
          this[i5] *= scale7[i5];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        valid = valid && Number.isFinite(this[i5]);
      }
      return valid;
    }
    sub(a3) {
      return this.subtract(a3);
    }
    setScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = a3;
      }
      return this.check();
    }
    addScalar(a3) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] += a3;
      }
      return this.check();
    }
    subScalar(a3) {
      return this.addScalar(-a3);
    }
    multiplyScalar(scalar) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] *= scalar;
      }
      return this.check();
    }
    divideScalar(a3) {
      return this.multiplyByScalar(1 / a3);
    }
    clampScalar(min4, max4) {
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        this[i5] = Math.min(Math.max(this[i5], min4), max4);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector(v2, length6) {
    if (v2.length !== length6) {
      return false;
    }
    for (let i5 = 0; i5 < v2.length; ++i5) {
      if (!Number.isFinite(v2[i5])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector(v2, length6, callerName = "") {
    if (config.debug && !validateVector(v2, length6)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v2;
  }

  // ../../node_modules/@math.gl/core/dist/lib/assert.js
  function assert7(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length6 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        length6 += this[i5] * this[i5];
      }
      return length6;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length6 = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        const dist4 = this[i5] - mathArray[i5];
        length6 += dist4 * dist4;
      }
      return checkNumber(length6);
    }
    dot(mathArray) {
      let product = 0;
      for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
        product += this[i5] * mathArray[i5];
      }
      return checkNumber(product);
    }
    normalize() {
      const length6 = this.magnitude();
      if (length6 !== 0) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= length6;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] *= vector[i5];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          this[i5] /= vector[i5];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i5) {
      assert7(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i5]);
    }
    setComponent(i5, value) {
      assert7(i5 >= 0 && i5 < this.ELEMENTS, "index is out of range");
      this[i5] = value;
      return this.check();
    }
    addVectors(a3, b2) {
      return this.copy(a3).add(b2);
    }
    subVectors(a3, b2) {
      return this.copy(a3).subtract(b2);
    }
    multiplyVectors(a3, b2) {
      return this.copy(a3).multiply(b2);
    }
    addScaledVector(a3, b2) {
      return this.add(new this.constructor(a3).multiplyScalar(b2));
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add,
    angle: () => angle,
    ceil: () => ceil,
    clone: () => clone,
    copy: () => copy,
    create: () => create,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals2,
    exactEquals: () => exactEquals,
    floor: () => floor,
    forEach: () => forEach2,
    fromValues: () => fromValues,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp2,
    max: () => max,
    min: () => min,
    mul: () => mul,
    multiply: () => multiply,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotate: () => rotate,
    round: () => round3,
    scale: () => scale,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    zero: () => zero
  });

  // ../../node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  function round2(a3) {
    if (a3 >= 0)
      return Math.round(a3);
    return a3 % 0.5 === 0 ? Math.floor(a3) : Math.round(a3);
  }
  var degree = Math.PI / 180;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create() {
    const out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone(a3) {
    const out = new ARRAY_TYPE(2);
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function fromValues(x3, y3) {
    const out = new ARRAY_TYPE(2);
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function copy(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function set(out, x3, y3) {
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function add(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    return out;
  }
  function subtract(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    return out;
  }
  function multiply(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    return out;
  }
  function divide(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    return out;
  }
  function ceil(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    return out;
  }
  function floor(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    return out;
  }
  function min(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    return out;
  }
  function max(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    return out;
  }
  function round3(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    return out;
  }
  function scale(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    return out;
  }
  function scaleAndAdd(out, a3, b2, scale7) {
    out[0] = a3[0] + b2[0] * scale7;
    out[1] = a3[1] + b2[1] * scale7;
    return out;
  }
  function distance(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    return Math.sqrt(x3 * x3 + y3 * y3);
  }
  function squaredDistance(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    return x3 * x3 + y3 * y3;
  }
  function length(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    return Math.sqrt(x3 * x3 + y3 * y3);
  }
  function squaredLength(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    return x3 * x3 + y3 * y3;
  }
  function negate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    return out;
  }
  function inverse(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    return out;
  }
  function normalize(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    let len4 = x3 * x3 + y3 * y3;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = a3[0] * len4;
    out[1] = a3[1] * len4;
    return out;
  }
  function dot(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1];
  }
  function cross(out, a3, b2) {
    const z2 = a3[0] * b2[1] - a3[1] * b2[0];
    out[0] = out[1] = 0;
    out[2] = z2;
    return out;
  }
  function lerp2(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    return out;
  }
  function random(out, scale7) {
    scale7 = scale7 === void 0 ? 1 : scale7;
    const r3 = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r3) * scale7;
    out[1] = Math.sin(r3) * scale7;
    return out;
  }
  function transformMat2(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[2] * y3;
    out[1] = m2[1] * x3 + m2[3] * y3;
    return out;
  }
  function transformMat2d(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[2] * y3 + m2[4];
    out[1] = m2[1] * x3 + m2[3] * y3 + m2[5];
    return out;
  }
  function transformMat3(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[3] * y3 + m2[6];
    out[1] = m2[1] * x3 + m2[4] * y3 + m2[7];
    return out;
  }
  function transformMat4(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[4] * y3 + m2[12];
    out[1] = m2[1] * x3 + m2[5] * y3 + m2[13];
    return out;
  }
  function rotate(out, a3, b2, rad) {
    const p0 = a3[0] - b2[0];
    const p1 = a3[1] - b2[1];
    const sinC = Math.sin(rad);
    const cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b2[0];
    out[1] = p0 * sinC + p1 * cosC + b2[1];
    return out;
  }
  function angle(a3, b2) {
    const x1 = a3[0];
    const y1 = a3[1];
    const x22 = b2[0];
    const y22 = b2[1];
    const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x22 * x22 + y22 * y22));
    const cosine = mag && (x1 * x22 + y1 * y22) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str(a3) {
    return `vec2(${a3[0]}, ${a3[1]})`;
  }
  function exactEquals(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1];
  }
  function equals2(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const b0 = b2[0];
    const b1 = b2[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  var len = length;
  var sub = subtract;
  var mul = multiply;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var sqrLen = squaredLength;
  var forEach2 = function() {
    const vec = create();
    return function(a3, stride, offset, count2, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l3 = Math.min(count2 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const w2 = m2[3] * x3 + m2[7] * y3 || 1;
    out[0] = (m2[0] * x3 + m2[4] * y3) / w2;
    out[1] = (m2[1] * x3 + m2[5] * y3) / w2;
    return out;
  }
  function vec3_transformMat4AsVector(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = m2[3] * x3 + m2[7] * y3 + m2[11] * z2 || 1;
    out[0] = (m2[0] * x3 + m2[4] * y3 + m2[8] * z2) / w2;
    out[1] = (m2[1] * x3 + m2[5] * y3 + m2[9] * z2) / w2;
    out[2] = (m2[2] * x3 + m2[6] * y3 + m2[10] * z2) / w2;
    return out;
  }
  function vec3_transformMat2(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[2] * y3;
    out[1] = m2[1] * x3 + m2[3] * y3;
    out[2] = a3[2];
    return out;
  }
  function vec4_transformMat2(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    out[0] = m2[0] * x3 + m2[2] * y3;
    out[1] = m2[1] * x3 + m2[3] * y3;
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function vec4_transformMat3(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = m2[0] * x3 + m2[3] * y3 + m2[6] * z2;
    out[1] = m2[1] * x3 + m2[4] * y3 + m2[7] * z2;
    out[2] = m2[2] * x3 + m2[5] * y3 + m2[8] * z2;
    out[3] = a3[3];
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/classes/vector2.js
  var Vector2 = class extends Vector {
    constructor(x3 = 0, y3 = 0) {
      super(2);
      if (isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
        }
        this[0] = x3;
        this[1] = y3;
      }
    }
    set(x3, y3) {
      this[0] = x3;
      this[1] = y3;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    get ELEMENTS() {
      return 2;
    }
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat4(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat2(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add2,
    angle: () => angle2,
    bezier: () => bezier,
    ceil: () => ceil2,
    clone: () => clone2,
    copy: () => copy2,
    create: () => create2,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals3,
    exactEquals: () => exactEquals2,
    floor: () => floor2,
    forEach: () => forEach3,
    fromValues: () => fromValues2,
    hermite: () => hermite,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp3,
    max: () => max2,
    min: () => min2,
    mul: () => mul2,
    multiply: () => multiply2,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    round: () => round4,
    scale: () => scale2,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set2,
    slerp: () => slerp,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat,
    zero: () => zero2
  });
  function create2() {
    const out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone2(a3) {
    const out = new ARRAY_TYPE(3);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function length2(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function fromValues2(x3, y3, z2) {
    const out = new ARRAY_TYPE(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function copy2(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function set2(out, x3, y3, z2) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    return out;
  }
  function add2(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    return out;
  }
  function subtract2(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    return out;
  }
  function multiply2(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    out[2] = a3[2] * b2[2];
    return out;
  }
  function divide2(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    out[2] = a3[2] / b2[2];
    return out;
  }
  function ceil2(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    return out;
  }
  function floor2(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    return out;
  }
  function min2(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    out[2] = Math.min(a3[2], b2[2]);
    return out;
  }
  function max2(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    out[2] = Math.max(a3[2], b2[2]);
    return out;
  }
  function round4(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    out[2] = round2(a3[2]);
    return out;
  }
  function scale2(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    return out;
  }
  function scaleAndAdd2(out, a3, b2, scale7) {
    out[0] = a3[0] + b2[0] * scale7;
    out[1] = a3[1] + b2[1] * scale7;
    out[2] = a3[2] + b2[2] * scale7;
    return out;
  }
  function distance2(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
  }
  function squaredDistance2(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function squaredLength2(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    return x3 * x3 + y3 * y3 + z2 * z2;
  }
  function negate2(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    return out;
  }
  function inverse2(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    return out;
  }
  function normalize2(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let len4 = x3 * x3 + y3 * y3 + z2 * z2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = a3[0] * len4;
    out[1] = a3[1] * len4;
    out[2] = a3[2] * len4;
    return out;
  }
  function dot2(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2];
  }
  function cross2(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp3(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    return out;
  }
  function slerp(out, a3, b2, t3) {
    const angle3 = Math.acos(Math.min(Math.max(dot2(a3, b2), -1), 1));
    const sinTotal = Math.sin(angle3);
    const ratioA = Math.sin((1 - t3) * angle3) / sinTotal;
    const ratioB = Math.sin(t3 * angle3) / sinTotal;
    out[0] = ratioA * a3[0] + ratioB * b2[0];
    out[1] = ratioA * a3[1] + ratioB * b2[1];
    out[2] = ratioA * a3[2] + ratioB * b2[2];
    return out;
  }
  function hermite(out, a3, b2, c2, d2, t3) {
    const factorTimes2 = t3 * t3;
    const factor1 = factorTimes2 * (2 * t3 - 3) + 1;
    const factor2 = factorTimes2 * (t3 - 2) + t3;
    const factor3 = factorTimes2 * (t3 - 1);
    const factor4 = factorTimes2 * (3 - 2 * t3);
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function bezier(out, a3, b2, c2, d2, t3) {
    const inverseFactor = 1 - t3;
    const inverseFactorTimesTwo = inverseFactor * inverseFactor;
    const factorTimes2 = t3 * t3;
    const factor1 = inverseFactorTimesTwo * inverseFactor;
    const factor2 = 3 * t3 * inverseFactorTimesTwo;
    const factor3 = 3 * factorTimes2 * inverseFactor;
    const factor4 = factorTimes2 * t3;
    out[0] = a3[0] * factor1 + b2[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b2[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b2[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function random2(out, scale7) {
    scale7 = scale7 === void 0 ? 1 : scale7;
    const r3 = RANDOM() * 2 * Math.PI;
    const z2 = RANDOM() * 2 - 1;
    const zScale = Math.sqrt(1 - z2 * z2) * scale7;
    out[0] = Math.cos(r3) * zScale;
    out[1] = Math.sin(r3) * zScale;
    out[2] = z2 * scale7;
    return out;
  }
  function transformMat42(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let w2 = m2[3] * x3 + m2[7] * y3 + m2[11] * z2 + m2[15];
    w2 = w2 || 1;
    out[0] = (m2[0] * x3 + m2[4] * y3 + m2[8] * z2 + m2[12]) / w2;
    out[1] = (m2[1] * x3 + m2[5] * y3 + m2[9] * z2 + m2[13]) / w2;
    out[2] = (m2[2] * x3 + m2[6] * y3 + m2[10] * z2 + m2[14]) / w2;
    return out;
  }
  function transformMat32(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3 * m2[0] + y3 * m2[3] + z2 * m2[6];
    out[1] = x3 * m2[1] + y3 * m2[4] + z2 * m2[7];
    out[2] = x3 * m2[2] + y3 * m2[5] + z2 * m2[8];
    return out;
  }
  function transformQuat(out, a3, q2) {
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    let uvx = qy * z2 - qz * y3;
    let uvy = qz * x3 - qx * z2;
    let uvz = qx * y3 - qy * x3;
    let uuvx = qy * uvz - qz * uvy;
    let uuvy = qz * uvx - qx * uvz;
    let uuvz = qx * uvy - qy * uvx;
    const w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z2 + uvz + uuvz;
    return out;
  }
  function rotateX(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0];
    r3[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r3[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateY(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r3[1] = p3[1];
    r3[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function rotateZ(out, a3, b2, rad) {
    const p3 = [];
    const r3 = [];
    p3[0] = a3[0] - b2[0];
    p3[1] = a3[1] - b2[1];
    p3[2] = a3[2] - b2[2];
    r3[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r3[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r3[2] = p3[2];
    out[0] = r3[0] + b2[0];
    out[1] = r3[1] + b2[1];
    out[2] = r3[2] + b2[2];
    return out;
  }
  function angle2(a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine = mag && dot2(a3, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str2(a3) {
    return `vec3(${a3[0]}, ${a3[1]}, ${a3[2]})`;
  }
  function exactEquals2(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2];
  }
  function equals3(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
  }
  var sub2 = subtract2;
  var mul2 = multiply2;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach3 = function() {
    const vec = create2();
    return function(a3, stride, offset, count2, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l3 = Math.min(count2 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray(x3)) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
          checkNumber(z2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
      }
    }
    set(x3, y3, z2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle2(this, vector);
    }
    cross(vector) {
      cross2(this, this, vector);
      return this.check();
    }
    rotateX({ radians: radians2, origin = ORIGIN }) {
      rotateX(this, this, origin, radians2);
      return this.check();
    }
    rotateY({ radians: radians2, origin = ORIGIN }) {
      rotateY(this, this, origin, radians2);
      return this.check();
    }
    rotateZ({ radians: radians2, origin = ORIGIN }) {
      rotateZ(this, this, origin, radians2);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat32(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/vector4.js
  var ZERO2;
  var Vector4 = class extends Vector {
    static get ZERO() {
      if (!ZERO2) {
        ZERO2 = new Vector4(0, 0, 0, 0);
        Object.freeze(ZERO2);
      }
      return ZERO2;
    }
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 0) {
      super(-0, -0, -0, -0);
      if (isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        if (config.debug) {
          checkNumber(x3);
          checkNumber(y3);
          checkNumber(z2);
          checkNumber(w2);
        }
        this[0] = x3;
        this[1] = y3;
        this[2] = z2;
        this[3] = w2;
      }
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
        checkNumber(object.w);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
    get ELEMENTS() {
      return 4;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    transform(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      vec4_transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec4_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion2) {
      transformQuat(this, this, quaternion2);
      return this.check();
    }
    applyMatrix4(m2) {
      m2.transform(this, this);
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i5 = 0; i5 < this.ELEMENTS; ++i5) {
          string += ` ${this[i5]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        result[i5] = this[firstIndex + i5];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i5 = 0; i5 < this.RANK; ++i5) {
        this[firstIndex + i5] = columnVector[i5];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat3.js
  function create3() {
    const out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function transpose(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function determinant(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply3(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const b00 = b2[0];
    const b01 = b2[1];
    const b02 = b2[2];
    const b10 = b2[3];
    const b11 = b2[4];
    const b12 = b2[5];
    const b20 = b2[6];
    const b21 = b2[7];
    const b22 = b2[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a3, v2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate2(out, a3, rad) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a10 = a3[3];
    const a11 = a3[4];
    const a12 = a3[5];
    const a20 = a3[6];
    const a21 = a3[7];
    const a22 = a3[8];
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2 * a00 + s3 * a10;
    out[1] = c2 * a01 + s3 * a11;
    out[2] = c2 * a02 + s3 * a12;
    out[3] = c2 * a10 - s3 * a00;
    out[4] = c2 * a11 - s3 * a01;
    out[5] = c2 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale3(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromQuat(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/classes/matrix3.js
  var INDICES;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
    INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
  })(INDICES || (INDICES = {}));
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  var Matrix3 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 9;
    }
    get RANK() {
      return 3;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array, ...args) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else if (args.length > 0) {
        this.copy([array, ...args]);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(q2) {
      fromQuat(this, q2);
      return this.check();
    }
    set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply3(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply3(this, this, a3);
      return this.check();
    }
    rotate(radians2) {
      rotate2(this, this, radians2);
      return this.check();
    }
    scale(factor) {
      if (Array.isArray(factor)) {
        scale3(this, this, factor);
      } else {
        scale3(this, this, [factor, factor]);
      }
      return this.check();
    }
    translate(vec) {
      translate(this, this, vec);
      return this.check();
    }
    transform(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = transformMat3(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat32(result || [-0, -0, -0], vector, this);
          break;
        case 4:
          out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformVector(vector, result) {
      return this.transform(vector, result);
    }
    transformVector2(vector, result) {
      return this.transform(vector, result);
    }
    transformVector3(vector, result) {
      return this.transform(vector, result);
    }
  };
  var ZERO_MATRIX3;
  var IDENTITY_MATRIX3 = null;
  function getZeroMatrix() {
    if (!ZERO_MATRIX3) {
      ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO_MATRIX3);
    }
    return ZERO_MATRIX3;
  }
  function getIdentityMatrix() {
    if (!IDENTITY_MATRIX3) {
      IDENTITY_MATRIX3 = new Matrix3();
      Object.freeze(IDENTITY_MATRIX3);
    }
    return IDENTITY_MATRIX3;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add3,
    adjoint: () => adjoint,
    clone: () => clone3,
    copy: () => copy3,
    create: () => create4,
    decompose: () => decompose,
    determinant: () => determinant2,
    equals: () => equals4,
    exactEquals: () => exactEquals3,
    frob: () => frob,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues3,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul3,
    multiply: () => multiply4,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate3,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    scale: () => scale4,
    set: () => set3,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create4() {
    const out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone3(a3) {
    const out = new ARRAY_TYPE(16);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function copy3(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function fromValues3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    const out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a3) {
    if (out === a3) {
      const a01 = a3[1];
      const a02 = a3[2];
      const a03 = a3[3];
      const a12 = a3[6];
      const a13 = a3[7];
      const a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert2(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint(out, a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    out[0] = a11 * b11 - a12 * b10 + a13 * b09;
    out[1] = a02 * b10 - a01 * b11 - a03 * b09;
    out[2] = a31 * b05 - a32 * b04 + a33 * b03;
    out[3] = a22 * b04 - a21 * b05 - a23 * b03;
    out[4] = a12 * b08 - a10 * b11 - a13 * b07;
    out[5] = a00 * b11 - a02 * b08 + a03 * b07;
    out[6] = a32 * b02 - a30 * b05 - a33 * b01;
    out[7] = a20 * b05 - a22 * b02 + a23 * b01;
    out[8] = a10 * b10 - a11 * b08 + a13 * b06;
    out[9] = a01 * b08 - a00 * b10 - a03 * b06;
    out[10] = a30 * b04 - a31 * b02 + a33 * b00;
    out[11] = a21 * b02 - a20 * b04 - a23 * b00;
    out[12] = a11 * b07 - a10 * b09 - a12 * b06;
    out[13] = a00 * b09 - a01 * b07 + a02 * b06;
    out[14] = a31 * b01 - a30 * b03 - a32 * b00;
    out[15] = a20 * b03 - a21 * b01 + a22 * b00;
    return out;
  }
  function determinant2(a3) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply4(out, a3, b2) {
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    const a30 = a3[12];
    const a31 = a3[13];
    const a32 = a3[14];
    const a33 = a3[15];
    let b0 = b2[0];
    let b1 = b2[1];
    let b22 = b2[2];
    let b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z2 + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z2 + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z2 + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z2 + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z2 + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z2 + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z2 + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z2 + a3[15];
    }
    return out;
  }
  function scale4(out, a3, v2) {
    const x3 = v2[0];
    const y3 = v2[1];
    const z2 = v2[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z2;
    out[9] = a3[9] * z2;
    out[10] = a3[10] * z2;
    out[11] = a3[11] * z2;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate3(out, a3, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len4 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x3 *= len4;
    y3 *= len4;
    z2 *= len4;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t3 + c2;
    b01 = y3 * x3 * t3 + z2 * s3;
    b02 = z2 * x3 * t3 - y3 * s3;
    b10 = x3 * y3 * t3 - z2 * s3;
    b11 = y3 * y3 * t3 + c2;
    b12 = z2 * y3 * t3 + x3 * s3;
    b20 = x3 * z2 * t3 + y3 * s3;
    b21 = y3 * z2 * t3 - x3 * s3;
    b22 = z2 * z2 * t3 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c2 + a20 * s3;
    out[5] = a11 * c2 + a21 * s3;
    out[6] = a12 * c2 + a22 * s3;
    out[7] = a13 * c2 + a23 * s3;
    out[8] = a20 * c2 - a10 * s3;
    out[9] = a21 * c2 - a11 * s3;
    out[10] = a22 * c2 - a12 * s3;
    out[11] = a23 * c2 - a13 * s3;
    return out;
  }
  function rotateY2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a20 = a3[8];
    const a21 = a3[9];
    const a22 = a3[10];
    const a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 - a20 * s3;
    out[1] = a01 * c2 - a21 * s3;
    out[2] = a02 * c2 - a22 * s3;
    out[3] = a03 * c2 - a23 * s3;
    out[8] = a00 * s3 + a20 * c2;
    out[9] = a01 * s3 + a21 * c2;
    out[10] = a02 * s3 + a22 * c2;
    out[11] = a03 * s3 + a23 * c2;
    return out;
  }
  function rotateZ2(out, a3, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    const a00 = a3[0];
    const a01 = a3[1];
    const a02 = a3[2];
    const a03 = a3[3];
    const a10 = a3[4];
    const a11 = a3[5];
    const a12 = a3[6];
    const a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c2 + a10 * s3;
    out[1] = a01 * c2 + a11 * s3;
    out[2] = a02 * c2 + a12 * s3;
    out[3] = a03 * c2 + a13 * s3;
    out[4] = a10 * c2 - a00 * s3;
    out[5] = a11 * c2 - a01 * s3;
    out[6] = a12 * c2 - a02 * s3;
    out[7] = a13 * c2 - a03 * s3;
    return out;
  }
  function fromTranslation(out, v2) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromScaling(out, v2) {
    out[0] = v2[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v2[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v2[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation(out, rad, axis) {
    let x3 = axis[0];
    let y3 = axis[1];
    let z2 = axis[2];
    let len4 = Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2);
    let c2;
    let s3;
    let t3;
    if (len4 < EPSILON) {
      return null;
    }
    len4 = 1 / len4;
    x3 *= len4;
    y3 *= len4;
    z2 *= len4;
    s3 = Math.sin(rad);
    c2 = Math.cos(rad);
    t3 = 1 - c2;
    out[0] = x3 * x3 * t3 + c2;
    out[1] = y3 * x3 * t3 + z2 * s3;
    out[2] = z2 * x3 * t3 - y3 * s3;
    out[3] = 0;
    out[4] = x3 * y3 * t3 - z2 * s3;
    out[5] = y3 * y3 * t3 + c2;
    out[6] = z2 * y3 * t3 + x3 * s3;
    out[7] = 0;
    out[8] = x3 * z2 * t3 + y3 * s3;
    out[9] = y3 * z2 * t3 - x3 * s3;
    out[10] = z2 * z2 * t3 + c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c2;
    out[6] = s3;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s3;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = 0;
    out[2] = -s3;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s3;
    out[9] = 0;
    out[10] = c2;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    const s3 = Math.sin(rad);
    const c2 = Math.cos(rad);
    out[0] = c2;
    out[1] = s3;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s3;
    out[5] = c2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q2, v2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a3) {
    const translation = new ARRAY_TYPE(3);
    const bx = -a3[0];
    const by = -a3[1];
    const bz = -a3[2];
    const bw = a3[3];
    const ax = a3[4];
    const ay = a3[5];
    const az = a3[6];
    const aw = a3[7];
    const magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a3, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  function getRotation(out, mat) {
    const scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    const is1 = 1 / scaling[0];
    const is2 = 1 / scaling[1];
    const is3 = 1 / scaling[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S2;
      out[0] = (sm23 - sm32) / S2;
      out[1] = (sm31 - sm13) / S2;
      out[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S2;
      out[0] = 0.25 * S2;
      out[1] = (sm12 + sm21) / S2;
      out[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S2;
      out[0] = (sm12 + sm21) / S2;
      out[1] = 0.25 * S2;
      out[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S2;
      out[0] = (sm31 + sm13) / S2;
      out[1] = (sm23 + sm32) / S2;
      out[2] = 0.25 * S2;
    }
    return out;
  }
  function decompose(out_r, out_t, out_s, mat) {
    out_t[0] = mat[12];
    out_t[1] = mat[13];
    out_t[2] = mat[14];
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    const is1 = 1 / out_s[0];
    const is2 = 1 / out_s[1];
    const is3 = 1 / out_s[2];
    const sm11 = m11 * is1;
    const sm12 = m12 * is2;
    const sm13 = m13 * is3;
    const sm21 = m21 * is1;
    const sm22 = m22 * is2;
    const sm23 = m23 * is3;
    const sm31 = m31 * is1;
    const sm32 = m32 * is2;
    const sm33 = m33 * is3;
    const trace = sm11 + sm22 + sm33;
    let S2 = 0;
    if (trace > 0) {
      S2 = Math.sqrt(trace + 1) * 2;
      out_r[3] = 0.25 * S2;
      out_r[0] = (sm23 - sm32) / S2;
      out_r[1] = (sm31 - sm13) / S2;
      out_r[2] = (sm12 - sm21) / S2;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out_r[3] = (sm23 - sm32) / S2;
      out_r[0] = 0.25 * S2;
      out_r[1] = (sm12 + sm21) / S2;
      out_r[2] = (sm31 + sm13) / S2;
    } else if (sm22 > sm33) {
      S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out_r[3] = (sm31 - sm13) / S2;
      out_r[0] = (sm12 + sm21) / S2;
      out_r[1] = 0.25 * S2;
      out_r[2] = (sm23 + sm32) / S2;
    } else {
      S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out_r[3] = (sm12 - sm21) / S2;
      out_r[0] = (sm31 + sm13) / S2;
      out_r[1] = (sm23 + sm32) / S2;
      out_r[2] = 0.25 * S2;
    }
    return out_r;
  }
  function fromRotationTranslationScale(out, q2, v2, s3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v2[0];
    out[13] = v2[1];
    out[14] = v2[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q2, v2, s3, o3) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const xy = x3 * y22;
    const xz = x3 * z22;
    const yy = y3 * y22;
    const yz = y3 * z22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    const sx = s3[0];
    const sy = s3[1];
    const sz = s3[2];
    const ox = o3[0];
    const oy = o3[1];
    const oz = o3[2];
    const out0 = (1 - (yy + zz)) * sx;
    const out1 = (xy + wz) * sx;
    const out2 = (xz - wy) * sx;
    const out4 = (xy - wz) * sy;
    const out5 = (1 - (xx + zz)) * sy;
    const out6 = (yz + wx) * sy;
    const out8 = (xz + wy) * sz;
    const out9 = (yz - wx) * sz;
    const out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q2) {
    const x3 = q2[0];
    const y3 = q2[1];
    const z2 = q2[2];
    const w2 = q2[3];
    const x22 = x3 + x3;
    const y22 = y3 + y3;
    const z22 = z2 + z2;
    const xx = x3 * x22;
    const yx = y3 * x22;
    const yy = y3 * y22;
    const zx = z2 * x22;
    const zy = z2 * y22;
    const zz = z2 * z22;
    const wx = w2 * x22;
    const wy = w2 * y22;
    const wz = w2 * z22;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function perspectiveZO(out, fovy, aspect, near, far) {
    const f4 = 1 / Math.tan(fovy / 2);
    out[0] = f4 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f4;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function orthoZO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center, up) {
    let len4;
    let x0;
    let x1;
    let x22;
    let y0;
    let y1;
    let y22;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len4 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len4 = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
    if (!len4) {
      x0 = 0;
      x1 = 0;
      x22 = 0;
    } else {
      len4 = 1 / len4;
      x0 *= len4;
      x1 *= len4;
      x22 *= len4;
    }
    y0 = z1 * x22 - z2 * x1;
    y1 = z2 * x0 - z0 * x22;
    y22 = z0 * x1 - z1 * x0;
    len4 = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
    if (!len4) {
      y0 = 0;
      y1 = 0;
      y22 = 0;
    } else {
      len4 = 1 / len4;
      y0 *= len4;
      y1 *= len4;
      y22 *= len4;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    let z0 = eyex - target[0];
    let z1 = eyey - target[1];
    let z2 = eyez - target[2];
    let len4 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      z0 *= len4;
      z1 *= len4;
      z2 *= len4;
    }
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x22 = upx * z1 - upy * z0;
    len4 = x0 * x0 + x1 * x1 + x22 * x22;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
      x0 *= len4;
      x1 *= len4;
      x22 *= len4;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z2 * x1;
    out[5] = z2 * x0 - z0 * x22;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str3(a3) {
    return `mat4(${a3[0]}, ${a3[1]}, ${a3[2]}, ${a3[3]}, ${a3[4]}, ${a3[5]}, ${a3[6]}, ${a3[7]}, ${a3[8]}, ${a3[9]}, ${a3[10]}, ${a3[11]}, ${a3[12]}, ${a3[13]}, ${a3[14]}, ${a3[15]})`;
  }
  function frob(a3) {
    return Math.sqrt(a3[0] * a3[0] + a3[1] * a3[1] + a3[2] * a3[2] + a3[3] * a3[3] + a3[4] * a3[4] + a3[5] * a3[5] + a3[6] * a3[6] + a3[7] * a3[7] + a3[8] * a3[8] + a3[9] * a3[9] + a3[10] * a3[10] + a3[11] * a3[11] + a3[12] * a3[12] + a3[13] * a3[13] + a3[14] * a3[14] + a3[15] * a3[15]);
  }
  function add3(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    out[4] = a3[4] + b2[4];
    out[5] = a3[5] + b2[5];
    out[6] = a3[6] + b2[6];
    out[7] = a3[7] + b2[7];
    out[8] = a3[8] + b2[8];
    out[9] = a3[9] + b2[9];
    out[10] = a3[10] + b2[10];
    out[11] = a3[11] + b2[11];
    out[12] = a3[12] + b2[12];
    out[13] = a3[13] + b2[13];
    out[14] = a3[14] + b2[14];
    out[15] = a3[15] + b2[15];
    return out;
  }
  function subtract3(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    out[3] = a3[3] - b2[3];
    out[4] = a3[4] - b2[4];
    out[5] = a3[5] - b2[5];
    out[6] = a3[6] - b2[6];
    out[7] = a3[7] - b2[7];
    out[8] = a3[8] - b2[8];
    out[9] = a3[9] - b2[9];
    out[10] = a3[10] - b2[10];
    out[11] = a3[11] - b2[11];
    out[12] = a3[12] - b2[12];
    out[13] = a3[13] - b2[13];
    out[14] = a3[14] - b2[14];
    out[15] = a3[15] - b2[15];
    return out;
  }
  function multiplyScalar(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    out[4] = a3[4] * b2;
    out[5] = a3[5] * b2;
    out[6] = a3[6] * b2;
    out[7] = a3[7] * b2;
    out[8] = a3[8] * b2;
    out[9] = a3[9] * b2;
    out[10] = a3[10] * b2;
    out[11] = a3[11] * b2;
    out[12] = a3[12] * b2;
    out[13] = a3[13] * b2;
    out[14] = a3[14] * b2;
    out[15] = a3[15] * b2;
    return out;
  }
  function multiplyScalarAndAdd(out, a3, b2, scale7) {
    out[0] = a3[0] + b2[0] * scale7;
    out[1] = a3[1] + b2[1] * scale7;
    out[2] = a3[2] + b2[2] * scale7;
    out[3] = a3[3] + b2[3] * scale7;
    out[4] = a3[4] + b2[4] * scale7;
    out[5] = a3[5] + b2[5] * scale7;
    out[6] = a3[6] + b2[6] * scale7;
    out[7] = a3[7] + b2[7] * scale7;
    out[8] = a3[8] + b2[8] * scale7;
    out[9] = a3[9] + b2[9] * scale7;
    out[10] = a3[10] + b2[10] * scale7;
    out[11] = a3[11] + b2[11] * scale7;
    out[12] = a3[12] + b2[12] * scale7;
    out[13] = a3[13] + b2[13] * scale7;
    out[14] = a3[14] + b2[14] * scale7;
    out[15] = a3[15] + b2[15] * scale7;
    return out;
  }
  function exactEquals3(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2] && a3[3] === b2[3] && a3[4] === b2[4] && a3[5] === b2[5] && a3[6] === b2[6] && a3[7] === b2[7] && a3[8] === b2[8] && a3[9] === b2[9] && a3[10] === b2[10] && a3[11] === b2[11] && a3[12] === b2[12] && a3[13] === b2[13] && a3[14] === b2[14] && a3[15] === b2[15];
  }
  function equals4(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const a4 = a3[4];
    const a5 = a3[5];
    const a6 = a3[6];
    const a7 = a3[7];
    const a8 = a3[8];
    const a9 = a3[9];
    const a10 = a3[10];
    const a11 = a3[11];
    const a12 = a3[12];
    const a13 = a3[13];
    const a14 = a3[14];
    const a15 = a3[15];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    const b3 = b2[3];
    const b4 = b2[4];
    const b5 = b2[5];
    const b6 = b2[6];
    const b7 = b2[7];
    const b8 = b2[8];
    const b9 = b2[9];
    const b10 = b2[10];
    const b11 = b2[11];
    const b12 = b2[12];
    const b13 = b2[13];
    const b14 = b2[14];
    const b15 = b2[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul3 = multiply4;
  var sub3 = subtract3;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add4,
    ceil: () => ceil3,
    clone: () => clone4,
    copy: () => copy4,
    create: () => create5,
    cross: () => cross3,
    dist: () => dist3,
    distance: () => distance3,
    div: () => div3,
    divide: () => divide3,
    dot: () => dot3,
    equals: () => equals5,
    exactEquals: () => exactEquals4,
    floor: () => floor3,
    forEach: () => forEach4,
    fromValues: () => fromValues4,
    inverse: () => inverse3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp4,
    max: () => max3,
    min: () => min3,
    mul: () => mul4,
    multiply: () => multiply5,
    negate: () => negate3,
    normalize: () => normalize3,
    random: () => random3,
    round: () => round5,
    scale: () => scale5,
    scaleAndAdd: () => scaleAndAdd3,
    set: () => set4,
    sqrDist: () => sqrDist3,
    sqrLen: () => sqrLen3,
    squaredDistance: () => squaredDistance3,
    squaredLength: () => squaredLength3,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat43,
    transformQuat: () => transformQuat2,
    zero: () => zero3
  });
  function create5() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone4(a3) {
    const out = new ARRAY_TYPE(4);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromValues4(x3, y3, z2, w2) {
    const out = new ARRAY_TYPE(4);
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = w2;
    return out;
  }
  function copy4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function set4(out, x3, y3, z2, w2) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = w2;
    return out;
  }
  function add4(out, a3, b2) {
    out[0] = a3[0] + b2[0];
    out[1] = a3[1] + b2[1];
    out[2] = a3[2] + b2[2];
    out[3] = a3[3] + b2[3];
    return out;
  }
  function subtract4(out, a3, b2) {
    out[0] = a3[0] - b2[0];
    out[1] = a3[1] - b2[1];
    out[2] = a3[2] - b2[2];
    out[3] = a3[3] - b2[3];
    return out;
  }
  function multiply5(out, a3, b2) {
    out[0] = a3[0] * b2[0];
    out[1] = a3[1] * b2[1];
    out[2] = a3[2] * b2[2];
    out[3] = a3[3] * b2[3];
    return out;
  }
  function divide3(out, a3, b2) {
    out[0] = a3[0] / b2[0];
    out[1] = a3[1] / b2[1];
    out[2] = a3[2] / b2[2];
    out[3] = a3[3] / b2[3];
    return out;
  }
  function ceil3(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    out[3] = Math.ceil(a3[3]);
    return out;
  }
  function floor3(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    out[3] = Math.floor(a3[3]);
    return out;
  }
  function min3(out, a3, b2) {
    out[0] = Math.min(a3[0], b2[0]);
    out[1] = Math.min(a3[1], b2[1]);
    out[2] = Math.min(a3[2], b2[2]);
    out[3] = Math.min(a3[3], b2[3]);
    return out;
  }
  function max3(out, a3, b2) {
    out[0] = Math.max(a3[0], b2[0]);
    out[1] = Math.max(a3[1], b2[1]);
    out[2] = Math.max(a3[2], b2[2]);
    out[3] = Math.max(a3[3], b2[3]);
    return out;
  }
  function round5(out, a3) {
    out[0] = round2(a3[0]);
    out[1] = round2(a3[1]);
    out[2] = round2(a3[2]);
    out[3] = round2(a3[3]);
    return out;
  }
  function scale5(out, a3, b2) {
    out[0] = a3[0] * b2;
    out[1] = a3[1] * b2;
    out[2] = a3[2] * b2;
    out[3] = a3[3] * b2;
    return out;
  }
  function scaleAndAdd3(out, a3, b2, scale7) {
    out[0] = a3[0] + b2[0] * scale7;
    out[1] = a3[1] + b2[1] * scale7;
    out[2] = a3[2] + b2[2] * scale7;
    out[3] = a3[3] + b2[3] * scale7;
    return out;
  }
  function distance3(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    const w2 = b2[3] - a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredDistance3(a3, b2) {
    const x3 = b2[0] - a3[0];
    const y3 = b2[1] - a3[1];
    const z2 = b2[2] - a3[2];
    const w2 = b2[3] - a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function length3(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return Math.sqrt(x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2);
  }
  function squaredLength3(a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    return x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
  }
  function negate3(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = -a3[3];
    return out;
  }
  function inverse3(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    out[3] = 1 / a3[3];
    return out;
  }
  function normalize3(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    let len4 = x3 * x3 + y3 * y3 + z2 * z2 + w2 * w2;
    if (len4 > 0) {
      len4 = 1 / Math.sqrt(len4);
    }
    out[0] = x3 * len4;
    out[1] = y3 * len4;
    out[2] = z2 * len4;
    out[3] = w2 * len4;
    return out;
  }
  function dot3(a3, b2) {
    return a3[0] * b2[0] + a3[1] * b2[1] + a3[2] * b2[2] + a3[3] * b2[3];
  }
  function cross3(out, u3, v2, w2) {
    const A2 = v2[0] * w2[1] - v2[1] * w2[0];
    const B = v2[0] * w2[2] - v2[2] * w2[0];
    const C2 = v2[0] * w2[3] - v2[3] * w2[0];
    const D2 = v2[1] * w2[2] - v2[2] * w2[1];
    const E = v2[1] * w2[3] - v2[3] * w2[1];
    const F = v2[2] * w2[3] - v2[3] * w2[2];
    const G = u3[0];
    const H2 = u3[1];
    const I2 = u3[2];
    const J = u3[3];
    out[0] = H2 * F - I2 * E + J * D2;
    out[1] = -(G * F) + I2 * C2 - J * B;
    out[2] = G * E - H2 * C2 + J * A2;
    out[3] = -(G * D2) + H2 * B - I2 * A2;
    return out;
  }
  function lerp4(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    out[0] = ax + t3 * (b2[0] - ax);
    out[1] = ay + t3 * (b2[1] - ay);
    out[2] = az + t3 * (b2[2] - az);
    out[3] = aw + t3 * (b2[3] - aw);
    return out;
  }
  function random3(out, scale7) {
    scale7 = scale7 === void 0 ? 1 : scale7;
    let v1;
    let v2;
    let v3;
    let v4;
    let s1;
    let s22;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s22 = v3 * v3 + v4 * v4;
    } while (s22 >= 1);
    const d2 = Math.sqrt((1 - s1) / s22);
    out[0] = scale7 * v1;
    out[1] = scale7 * v2;
    out[2] = scale7 * v3 * d2;
    out[3] = scale7 * v4 * d2;
    return out;
  }
  function transformMat43(out, a3, m2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const w2 = a3[3];
    out[0] = m2[0] * x3 + m2[4] * y3 + m2[8] * z2 + m2[12] * w2;
    out[1] = m2[1] * x3 + m2[5] * y3 + m2[9] * z2 + m2[13] * w2;
    out[2] = m2[2] * x3 + m2[6] * y3 + m2[10] * z2 + m2[14] * w2;
    out[3] = m2[3] * x3 + m2[7] * y3 + m2[11] * z2 + m2[15] * w2;
    return out;
  }
  function transformQuat2(out, a3, q2) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    const qx = q2[0];
    const qy = q2[1];
    const qz = q2[2];
    const qw = q2[3];
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  function zero3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a3) {
    return `vec4(${a3[0]}, ${a3[1]}, ${a3[2]}, ${a3[3]})`;
  }
  function exactEquals4(a3, b2) {
    return a3[0] === b2[0] && a3[1] === b2[1] && a3[2] === b2[2] && a3[3] === b2[3];
  }
  function equals5(a3, b2) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const b0 = b2[0];
    const b1 = b2[1];
    const b22 = b2[2];
    const b3 = b2[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply5;
  var div3 = divide3;
  var dist3 = distance3;
  var sqrDist3 = squaredDistance3;
  var len3 = length3;
  var sqrLen3 = squaredLength3;
  var forEach4 = function() {
    const vec = create5();
    return function(a3, stride, offset, count2, fn, arg) {
      let i5;
      let l3;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l3 = Math.min(count2 * stride + offset, a3.length);
      } else {
        l3 = a3.length;
      }
      for (i5 = offset; i5 < l3; i5 += stride) {
        vec[0] = a3[i5];
        vec[1] = a3[i5 + 1];
        vec[2] = a3[i5 + 2];
        vec[3] = a3[i5 + 3];
        fn(vec, vec, arg);
        a3[i5] = vec[0];
        a3[i5 + 1] = vec[1];
        a3[i5 + 2] = vec[2];
        a3[i5 + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES2;
  (function(INDICES3) {
    INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES2 || (INDICES2 = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix2();
    }
    static get ZERO() {
      return getZeroMatrix2();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES2;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX2);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion2) {
      fromQuat3(this, quaternion2);
      return this.check();
    }
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant2(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale7 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale7[0];
      const inverseScale1 = 1 / scale7[1];
      const inverseScale2 = 1 / scale7[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale7 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale7[0];
      const inverseScale1 = 1 / scale7[1];
      const inverseScale2 = 1 / scale7[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose2(this, this);
      return this.check();
    }
    invert() {
      invert2(this, this);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply4(this, a3, this);
      return this.check();
    }
    multiplyRight(a3) {
      multiply4(this, this, a3);
      return this.check();
    }
    rotateX(radians2) {
      rotateX2(this, this, radians2);
      return this.check();
    }
    rotateY(radians2) {
      rotateY2(this, this, radians2);
      return this.check();
    }
    rotateZ(radians2) {
      rotateZ2(this, this, radians2);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians2, axis) {
      rotate3(this, this, radians2, axis);
      return this.check();
    }
    scale(factor) {
      scale4(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate2(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const { length: length6 } = vector;
      let out;
      switch (length6) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians2) {
      return this.identity().rotateX(radians2);
    }
    makeTranslation(x3, y3, z2) {
      return this.identity().translate([x3, y3, z2]);
    }
  };
  var ZERO3;
  var IDENTITY;
  function getZeroMatrix2() {
    if (!ZERO3) {
      ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO3);
    }
    return ZERO3;
  }
  function getIdentityMatrix2() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/quat.js
  function create6() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    const s3 = Math.sin(rad);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function multiply6(out, a3, b2) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = b2[0];
    const by = b2[1];
    const bz = b2[2];
    const bw = b2[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bx = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const by = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a3, rad) {
    rad *= 0.5;
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    const bz = Math.sin(rad);
    const bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a3) {
    const x3 = a3[0];
    const y3 = a3[1];
    const z2 = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z2;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z2 * z2));
    return out;
  }
  function slerp2(out, a3, b2, t3) {
    const ax = a3[0];
    const ay = a3[1];
    const az = a3[2];
    const aw = a3[3];
    let bx = b2[0];
    let by = b2[1];
    let bz = b2[2];
    let bw = b2[3];
    let cosom;
    let omega;
    let scale0;
    let scale1;
    let sinom;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t3) * omega) / sinom;
      scale1 = Math.sin(t3 * omega) / sinom;
    } else {
      scale0 = 1 - t3;
      scale1 = t3;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function invert3(out, a3) {
    const a0 = a3[0];
    const a1 = a3[1];
    const a22 = a3[2];
    const a32 = a3[3];
    const dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    const invDot = dot5 ? 1 / dot5 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat3(out, m2) {
    const fTrace = m2[0] + m2[4] + m2[8];
    let fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m2[5] - m2[7]) * fRoot;
      out[1] = (m2[6] - m2[2]) * fRoot;
      out[2] = (m2[1] - m2[3]) * fRoot;
    } else {
      let i5 = 0;
      if (m2[4] > m2[0])
        i5 = 1;
      if (m2[8] > m2[i5 * 3 + i5])
        i5 = 2;
      const j2 = (i5 + 1) % 3;
      const k2 = (i5 + 2) % 3;
      fRoot = Math.sqrt(m2[i5 * 3 + i5] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
      out[i5] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
      out[j2] = (m2[j2 * 3 + i5] + m2[i5 * 3 + j2]) * fRoot;
      out[k2] = (m2[k2 * 3 + i5] + m2[i5 * 3 + k2]) * fRoot;
    }
    return out;
  }
  var add5 = add4;
  var scale6 = scale5;
  var dot4 = dot3;
  var lerp5 = lerp4;
  var length4 = length3;
  var squaredLength4 = squaredLength3;
  var normalize4 = normalize3;
  var rotationTo = function() {
    const tmpvec3 = create2();
    const xUnitVec3 = fromValues2(1, 0, 0);
    const yUnitVec3 = fromValues2(0, 1, 0);
    return function(out, a3, b2) {
      const dot5 = dot2(a3, b2);
      if (dot5 < -0.999999) {
        cross2(tmpvec3, xUnitVec3, a3);
        if (len2(tmpvec3) < 1e-6)
          cross2(tmpvec3, yUnitVec3, a3);
        normalize2(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot5 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      cross2(tmpvec3, a3, b2);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize4(out, out);
    };
  }();
  var sqlerp = function() {
    const temp1 = create6();
    const temp2 = create6();
    return function(out, a3, b2, c2, d2, t3) {
      slerp2(temp1, a3, d2, t3);
      slerp2(temp2, b2, c2, t3);
      slerp2(out, temp1, temp2, 2 * t3 * (1 - t3));
      return out;
    };
  }();
  var setAxes = function() {
    const matr = create3();
    return function(out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize4(out, fromMat3(out, matr));
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/quaternion.js
  var IDENTITY_QUATERNION = [0, 0, 0, 1];
  var Quaternion = class extends MathArray {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1) {
      super(-0, -0, -0, -0);
      if (Array.isArray(x3) && arguments.length === 1) {
        this.copy(x3);
      } else {
        this.set(x3, y3, z2, w2);
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
    set(x3, y3, z2, w2) {
      this[0] = x3;
      this[1] = y3;
      this[2] = z2;
      this[3] = w2;
      return this.check();
    }
    fromObject(object) {
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this.check();
    }
    fromMatrix3(m2) {
      fromMat3(this, m2);
      return this.check();
    }
    fromAxisRotation(axis, rad) {
      setAxisAngle(this, axis, rad);
      return this.check();
    }
    identity() {
      identity2(this);
      return this.check();
    }
    setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
    get ELEMENTS() {
      return 4;
    }
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    get w() {
      return this[3];
    }
    set w(value) {
      this[3] = checkNumber(value);
    }
    len() {
      return length4(this);
    }
    lengthSquared() {
      return squaredLength4(this);
    }
    dot(a3) {
      return dot4(this, a3);
    }
    rotationTo(vectorA, vectorB) {
      rotationTo(this, vectorA, vectorB);
      return this.check();
    }
    add(a3) {
      add5(this, this, a3);
      return this.check();
    }
    calculateW() {
      calculateW(this, this);
      return this.check();
    }
    conjugate() {
      conjugate(this, this);
      return this.check();
    }
    invert() {
      invert3(this, this);
      return this.check();
    }
    lerp(a3, b2, t3) {
      if (t3 === void 0) {
        return this.lerp(this, a3, b2);
      }
      lerp5(this, a3, b2, t3);
      return this.check();
    }
    multiplyRight(a3) {
      multiply6(this, this, a3);
      return this.check();
    }
    multiplyLeft(a3) {
      multiply6(this, a3, this);
      return this.check();
    }
    normalize() {
      const length6 = this.len();
      const l3 = length6 > 0 ? 1 / length6 : 0;
      this[0] = this[0] * l3;
      this[1] = this[1] * l3;
      this[2] = this[2] * l3;
      this[3] = this[3] * l3;
      if (length6 === 0) {
        this[3] = 1;
      }
      return this.check();
    }
    rotateX(rad) {
      rotateX3(this, this, rad);
      return this.check();
    }
    rotateY(rad) {
      rotateY3(this, this, rad);
      return this.check();
    }
    rotateZ(rad) {
      rotateZ3(this, this, rad);
      return this.check();
    }
    scale(b2) {
      scale6(this, this, b2);
      return this.check();
    }
    slerp(arg0, arg1, arg2) {
      let start;
      let target;
      let ratio;
      switch (arguments.length) {
        case 1:
          ({
            start = IDENTITY_QUATERNION,
            target,
            ratio
          } = arg0);
          break;
        case 2:
          start = this;
          target = arg0;
          ratio = arg1;
          break;
        default:
          start = arg0;
          target = arg1;
          ratio = arg2;
      }
      slerp2(this, start, target, ratio);
      return this.check();
    }
    transformVector4(vector, result = new Vector4()) {
      transformQuat2(result, vector, this);
      return checkVector(result, 4);
    }
    lengthSq() {
      return this.lengthSquared();
    }
    setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
    premultiply(a3) {
      return this.multiplyLeft(a3);
    }
    multiply(a3) {
      return this.multiplyRight(a3);
    }
  };

  // ../../node_modules/@math.gl/core/dist/classes/spherical-coordinates.js
  var EPSILON2 = 1e-6;
  var EARTH_RADIUS_METERS = 6371e3;
  var SphericalCoordinates = class {
    constructor({ phi = 0, theta = 0, radius = 1, bearing, pitch, altitude, radiusScale = EARTH_RADIUS_METERS } = {}) {
      this.phi = phi;
      this.theta = theta;
      this.radius = radius || altitude || 1;
      this.radiusScale = radiusScale || 1;
      if (bearing !== void 0) {
        this.bearing = bearing;
      }
      if (pitch !== void 0) {
        this.pitch = pitch;
      }
      this.check();
    }
    toString() {
      return this.formatString(config);
    }
    formatString({ printTypes = false }) {
      const f4 = formatValue;
      return `${printTypes ? "Spherical" : ""}[rho:${f4(this.radius)},theta:${f4(this.theta)},phi:${f4(this.phi)}]`;
    }
    equals(other) {
      return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
    }
    exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
    get bearing() {
      return 180 - degrees(this.phi);
    }
    set bearing(v2) {
      this.phi = Math.PI - radians(v2);
    }
    get pitch() {
      return degrees(this.theta);
    }
    set pitch(v2) {
      this.theta = radians(v2);
    }
    get longitude() {
      return degrees(this.phi);
    }
    get latitude() {
      return degrees(this.theta);
    }
    get lng() {
      return degrees(this.phi);
    }
    get lat() {
      return degrees(this.theta);
    }
    get z() {
      return (this.radius - 1) * this.radiusScale;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
    clone() {
      return new SphericalCoordinates().copy(this);
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
    fromLngLatZ([lng, lat, z2]) {
      this.radius = 1 + z2 / this.radiusScale;
      this.phi = radians(lat);
      this.theta = radians(lng);
      return this.check();
    }
    fromVector3(v2) {
      this.radius = length2(v2);
      if (this.radius > 0) {
        this.theta = Math.atan2(v2[0], v2[1]);
        this.phi = Math.acos(clamp(v2[2] / this.radius, -1, 1));
      }
      return this.check();
    }
    toVector3() {
      return new Vector3(0, 0, this.radius).rotateX({ radians: this.theta }).rotateZ({ radians: this.phi });
    }
    makeSafe() {
      this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
      return this;
    }
    check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error("SphericalCoordinates: some fields set to invalid numbers");
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/math-utils.js
  var math_utils_exports = {};
  __export(math_utils_exports, {
    EPSILON1: () => EPSILON1,
    EPSILON10: () => EPSILON10,
    EPSILON11: () => EPSILON11,
    EPSILON12: () => EPSILON12,
    EPSILON13: () => EPSILON13,
    EPSILON14: () => EPSILON14,
    EPSILON15: () => EPSILON15,
    EPSILON16: () => EPSILON16,
    EPSILON17: () => EPSILON17,
    EPSILON18: () => EPSILON18,
    EPSILON19: () => EPSILON19,
    EPSILON2: () => EPSILON22,
    EPSILON20: () => EPSILON20,
    EPSILON3: () => EPSILON3,
    EPSILON4: () => EPSILON4,
    EPSILON5: () => EPSILON5,
    EPSILON6: () => EPSILON6,
    EPSILON7: () => EPSILON7,
    EPSILON8: () => EPSILON8,
    EPSILON9: () => EPSILON9,
    PI_OVER_FOUR: () => PI_OVER_FOUR,
    PI_OVER_SIX: () => PI_OVER_SIX,
    PI_OVER_TWO: () => PI_OVER_TWO,
    TWO_PI: () => TWO_PI
  });
  var EPSILON1 = 0.1;
  var EPSILON22 = 0.01;
  var EPSILON3 = 1e-3;
  var EPSILON4 = 1e-4;
  var EPSILON5 = 1e-5;
  var EPSILON6 = 1e-6;
  var EPSILON7 = 1e-7;
  var EPSILON8 = 1e-8;
  var EPSILON9 = 1e-9;
  var EPSILON10 = 1e-10;
  var EPSILON11 = 1e-11;
  var EPSILON12 = 1e-12;
  var EPSILON13 = 1e-13;
  var EPSILON14 = 1e-14;
  var EPSILON15 = 1e-15;
  var EPSILON16 = 1e-16;
  var EPSILON17 = 1e-17;
  var EPSILON18 = 1e-18;
  var EPSILON19 = 1e-19;
  var EPSILON20 = 1e-20;
  var PI_OVER_TWO = Math.PI / 2;
  var PI_OVER_FOUR = Math.PI / 4;
  var PI_OVER_SIX = Math.PI / 6;
  var TWO_PI = Math.PI * 2;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/lights/lights-glsl.js
  var lightingShader = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/lights/lights.js
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor(colorDef = {}) {
    const { color = [0, 0, 0], intensity = 1 } = colorDef;
    return color.map((component) => component * intensity / 255);
  }
  function getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {
    const lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach((pointLight, index2) => {
      lightSourceUniforms[`lighting_uPointLight[${index2}].color`] = convertColor(pointLight);
      lightSourceUniforms[`lighting_uPointLight[${index2}].position`] = pointLight.position;
      lightSourceUniforms[`lighting_uPointLight[${index2}].attenuation`] = pointLight.attenuation || [
        1,
        0,
        0
      ];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach((directionalLight, index2) => {
      lightSourceUniforms[`lighting_uDirectionalLight[${index2}].color`] = convertColor(directionalLight);
      lightSourceUniforms[`lighting_uDirectionalLight[${index2}].direction`] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms3(opts = INITIAL_MODULE_OPTIONS) {
    if ("lightSources" in opts) {
      const { ambientLight, pointLights, directionalLights } = opts.lightSources || {};
      const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return { lighting_uEnabled: false };
      }
      return Object.assign({}, getLightSourceUniforms({ ambientLight, pointLights, directionalLights }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      const lightSources = { pointLights: [], directionalLights: [] };
      for (const light of opts.lights || []) {
        switch (light.type) {
          case "ambient":
            lightSources.ambientLight = light;
            break;
          case "directional":
            lightSources.directionalLights?.push(light);
            break;
          case "point":
            lightSources.pointLights?.push(light);
            break;
          default:
        }
      }
      return getUniforms3({ lightSources });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lightingShader,
    fs: lightingShader,
    getUniforms: getUniforms3,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/phong-lighting/phong-lighting-glsl.js
  var lightingShader2 = `uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/phong-lighting/phong-lighting.js
  var INITIAL_MODULE_OPTIONS2 = {};
  function getMaterialUniforms(material) {
    const { ambient = 0.35, diffuse = 0.6, shininess = 32, specularColor = [30, 30, 30] } = material;
    return {
      lighting_uAmbient: ambient,
      lighting_uDiffuse: diffuse,
      lighting_uShininess: shininess,
      lighting_uSpecularColor: specularColor.map((x3) => x3 / 255)
    };
  }
  function getUniforms4(opts = INITIAL_MODULE_OPTIONS2) {
    if (!("material" in opts)) {
      return {};
    }
    const { material } = opts;
    if (!material) {
      return { lighting_uEnabled: false };
    }
    return getMaterialUniforms(material);
  }
  var gouraudLighting = {
    name: "gouraud-lighting",
    dependencies: [lights],
    vs: lightingShader2,
    defines: {
      LIGHTING_VERTEX: 1
    },
    getUniforms: getUniforms4
  };
  var phongLighting = {
    name: "phong-lighting",
    dependencies: [lights],
    fs: lightingShader2,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    getUniforms: getUniforms4
  };

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/pbr/pbr-vertex-glsl.js
  var vs2 = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/pbr/pbr-fragment-glsl.js
  var fs2 = `precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;

  // ../../node_modules/@luma.gl/shadertools/dist/modules-webgl1/lighting/pbr/pbr.js
  var pbr = {
    name: "pbr",
    vs: vs2,
    fs: fs2,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    dependencies: [lights]
  };

  // ../core/src/shaderlib/misc/geometry.ts
  var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
  var vs3 = `
${defines}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`;
  var fs3 = `
${defines}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`;
  var geometry_default = { name: "geometry", vs: vs3, fs: fs3 };

  // ../core/src/lib/constants.ts
  var COORDINATE_SYSTEM = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: () => {
      log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
      return 0;
    }
  });
  var PROJECTION_MODE = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  };
  var UNIT = {
    common: 0,
    meters: 1,
    pixels: 2
  };
  var EVENTS = {
    click: { handler: "onClick" },
    panstart: { handler: "onDragStart" },
    panmove: { handler: "onDrag" },
    panend: { handler: "onDragEnd" }
  };
  var OPERATION = {
    DRAW: "draw",
    MASK: "mask",
    TERRAIN: "terrain"
  };

  // ../core/src/shaderlib/project/project.glsl.ts
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`).join("");
  var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`).join("");
  var project_glsl_default = `${COORDINATE_SYSTEM_GLSL_CONSTANTS}
${PROJECTION_MODE_GLSL_CONSTANTS}
${UNIT_GLSL_CONSTANTS}

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0; // meters
const float GLOBE_RADIUS = 256.0;

// returns an adjustment factor for uCommonUnitsPerMeter
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project_uPseudoMeters == false) {

    // uCommonUnitsPerMeter in low-zoom Web Mercator is non-linear
    // Adjust by 1 / cos(latitude)
    // If geometry.position (vertex in common space) is populated, use it
    // Otherwise use geometry.worldPosition (anchor in world space)
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }

    // latitude from common y: 2.0 * (atan(exp(y / TILE_SIZE * 2.0 * PI - PI)) - PI / 4.0)
    // Taylor series of 1 / cos(latitude)
    // Max error < 0.003
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}

//
// Scaling offsets - scales meters to "world distance"
// Note the scalar version of project_size is for scaling the z component only
//
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}

// Get rotation matrix that aligns the z axis with the given up vector
// Find 3 unit vectors ux, uy, uz that are perpendicular to each other and uz == up
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  // Tangent on XY plane
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}

//
// Projecting normal - transform deltas from current coordinate system to
// normals in the worldspace
//
vec3 project_normal(vec3 vector) {
  // Apply model matrix
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

//
// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]
//
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

//
// Projects positions (defined by project_uCoordinateSystem) to common space (defined by project_uProjectionMode)
//
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;

  // Work around for a Mac+NVIDIA bug https://github.com/visgl/deck.gl/issues/4145
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
        // Too far from the projection center for offset mode to be accurate
        // Only use high parts
        return vec4(
          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    // Subtract high part of 64 bit value. Convert remainder to float32, preserving precision.
    position_world.xyz -= project_uCoordinateOrigin;
  }

  // Translation is already added to the high parts
  return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}

//
// Projects from common space coordinates to clip space.
// Uses project_uViewProjectionMatrix
//
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}

// Returns a clip space offset that corresponds to a given number of screen pixels
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project_uScale;
  // UNIT_PIXELS
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
`;

  // ../core/src/utils/memoize.ts
  function isEqual(a3, b2) {
    if (a3 === b2) {
      return true;
    }
    if (Array.isArray(a3)) {
      const len4 = a3.length;
      if (!b2 || b2.length !== len4) {
        return false;
      }
      for (let i5 = 0; i5 < len4; i5++) {
        if (a3[i5] !== b2[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // ../core/src/shaderlib/project/viewport-uniforms.ts
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) {
      coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
    }
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
    }
    switch (viewport.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          geospatialOrigin = [0, 0, 0];
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [
            Math.fround(viewport.center[0]),
            Math.fround(viewport.center[1]),
            0
          ];
          geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport.position.map(Math.fround);
        shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    return { geospatialOrigin, shaderCoordinateOrigin, offsetMode };
  }
  function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const { viewMatrixUncentered, projectionMatrix } = viewport;
    let { viewMatrix: viewMatrix2, viewProjectionMatrix } = viewport;
    let projectionCenter = ZERO_VECTOR;
    let originCommon = ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const { geospatialOrigin, shaderCoordinateOrigin, offsetMode } = getOffsetOrigin(
      viewport,
      coordinateSystem,
      coordinateOrigin
    );
    if (offsetMode) {
      originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [
        cameraPosCommon[0] - originCommon[0],
        cameraPosCommon[1] - originCommon[1],
        cameraPosCommon[2] - originCommon[2]
      ];
      originCommon[3] = 1;
      projectionCenter = vec4_exports.transformMat4([], originCommon, viewProjectionMatrix);
      viewMatrix2 = viewMatrixUncentered || viewMatrix2;
      viewProjectionMatrix = mat4_exports.multiply([], projectionMatrix, viewMatrix2);
      viewProjectionMatrix = mat4_exports.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix: viewMatrix2,
      viewProjectionMatrix,
      projectionCenter,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport({
    viewport,
    devicePixelRatio = 1,
    modelMatrix: modelMatrix2 = null,
    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    autoWrapLongitude = false
  }) {
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    const uniforms = getMemoizedViewportUniforms({
      viewport,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix2 || IDENTITY_MATRIX4;
    return uniforms;
  }
  function calculateViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  }) {
    const {
      projectionCenter,
      viewProjectionMatrix,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [
      viewport.width * devicePixelRatio,
      viewport.height * devicePixelRatio
    ];
    const focalDistance = vec4_exports.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
      project_uCoordinateSystem: coordinateSystem,
      project_uProjectionMode: viewport.projectionMode,
      project_uCoordinateOrigin: shaderCoordinateOrigin,
      project_uCommonOrigin: originCommon.slice(0, 3),
      project_uCenter: projectionCenter,
      project_uPseudoMeters: Boolean(viewport._pseudoMeters),
      project_uViewportSize: viewportSize,
      project_uDevicePixelRatio: devicePixelRatio,
      project_uFocalDistance: focalDistance,
      project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      project_uScale: viewport.scale,
      project_uWrapLongitude: false,
      project_uViewProjectionMatrix: viewProjectionMatrix,
      project_uModelMatrix: IDENTITY_MATRIX4,
      project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          if (!viewport._pseudoMeters) {
            uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
          }
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.project_uCommonUnitsPerWorldUnit2 = [
            0,
            0,
            distanceScalesAtOrigin.unitsPerMeter2[2]
          ];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // ../core/src/shaderlib/project/project.ts
  var INITIAL_MODULE_OPTIONS3 = {};
  function getUniforms5(opts = INITIAL_MODULE_OPTIONS3) {
    if ("viewport" in opts) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32, geometry_default],
    vs: project_glsl_default,
    getUniforms: getUniforms5
  };

  // ../core/src/shaderlib/project32/project32.ts
  var vs4 = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`;
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    vs: vs4
  };

  // ../../node_modules/@math.gl/web-mercator/dist/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    const result = vec4_exports.transformMat4([], vector, matrix);
    vec4_exports.scale(result, result, 1 / result[3]);
    return result;
  }
  function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function lerp6(start, end, step) {
    return step * end + (1 - step) * start;
  }
  function clamp2(x3, min4, max4) {
    return x3 < min4 ? min4 : x3 > max4 ? max4 : x3;
  }
  function ieLog2(x3) {
    return Math.log(x3) * Math.LOG2E;
  }
  var log22 = Math.log2 || ieLog2;

  // ../../node_modules/@math.gl/web-mercator/dist/assert.js
  function assert8(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // ../../node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var MAX_LATITUDE = 85.051129;
  var DEFAULT_ALTITUDE = 1.5;
  function zoomToScale(zoom) {
    return Math.pow(2, zoom);
  }
  function scaleToZoom(scale7) {
    return log22(scale7);
  }
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert8(Number.isFinite(lng));
    assert8(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS2;
    const phi2 = lat * DEGREES_TO_RADIANS2;
    const x3 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y3 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x3, y3];
  }
  function worldToLngLat(xy) {
    const [x3, y3] = xy;
    const lambda2 = x3 / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y3 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(options) {
    const { latitude } = options;
    assert8(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }
  function getDistanceScales(options) {
    const { latitude, longitude, highPrecision = false } = options;
    assert8(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    const result = {
      unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
      metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
      unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
      degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
    };
    if (highPrecision) {
      const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x3, y3, z2] = xyz;
    const { unitsPerMeter: unitsPerMeter2, unitsPerMeter2: unitsPerMeter22 } = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x3 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y3);
    worldspace[1] += y3 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y3);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z2 || 0);
    return Number.isFinite(z0) || Number.isFinite(z2) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(options) {
    const {
      height,
      pitch,
      bearing,
      altitude,
      scale: scale7,
      center
    } = options;
    const vm = createMat4();
    mat4_exports.translate(vm, vm, [0, 0, -altitude]);
    mat4_exports.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    mat4_exports.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS2);
    const relativeScale = scale7 / height;
    mat4_exports.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
    if (center) {
      mat4_exports.translate(vm, vm, vec3_exports.negate([], center));
    }
    return vm;
  }
  function getProjectionParameters(options) {
    const { width, height, altitude, pitch = 0, offset, center, scale: scale7, nearZMultiplier = 1, farZMultiplier = 1 } = options;
    let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;
    if (altitude !== void 0) {
      fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS2;
    const pitchRadians = pitch * DEGREES_TO_RADIANS2;
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
      cameraToSeaLevelDistance += center[2] * scale7 / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
      fov: fovRadians,
      aspect: width / height,
      focalDistance,
      near: nearZMultiplier,
      far: farZ
    };
  }
  function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
  }
  function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x3, y3, z2 = 0] = xyz;
    assert8(Number.isFinite(x3) && Number.isFinite(y3) && Number.isFinite(z2));
    return transformVector(pixelProjectionMatrix, [x3, y3, z2, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x3, y3, z2] = xyz;
    assert8(Number.isFinite(x3) && Number.isFinite(y3), "invalid pixel coordinate");
    if (Number.isFinite(z2)) {
      const coord = transformVector(pixelUnprojectionMatrix, [x3, y3, z2, 1]);
      return coord;
    }
    const coord0 = transformVector(pixelUnprojectionMatrix, [x3, y3, 0, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x3, y3, 1, 1]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t3 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return vec2_exports.lerp([], coord0, coord1, t3);
  }

  // ../../node_modules/@math.gl/web-mercator/dist/fit-bounds.js
  function fitBounds(options) {
    const {
      width,
      height,
      bounds,
      minExtent = 0,
      maxZoom = 24,
      offset = [0, 0]
    } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
    const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
    const size = [
      Math.max(Math.abs(se[0] - nw[0]), minExtent),
      Math.max(Math.abs(se[1] - nw[1]), minExtent)
    ];
    const targetSize = [
      width - padding.left - padding.right - Math.abs(offset[0]) * 2,
      height - padding.top - padding.bottom - Math.abs(offset[1]) * 2
    ];
    assert8(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX2 = targetSize[0] / size[0];
    const scaleY2 = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX2;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    const centerLngLat = worldToLngLat(center);
    const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
    assert8(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }
  function getPaddingObject(padding = 0) {
    if (typeof padding === "number") {
      return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
      };
    }
    assert8(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport, z2 = 0) {
    const { width, height, unproject } = viewport;
    const unprojectOps = { targetZ: z2 };
    const bottomLeft = unproject([0, height], unprojectOps);
    const bottomRight = unproject([width, height], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport, 0, z2);
      topRight = unprojectOnFarPlane(viewport, width, z2);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport, x3, targetZ) {
    const { pixelUnprojectionMatrix } = viewport;
    const coord0 = transformVector(pixelUnprojectionMatrix, [x3, 0, 1, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x3, viewport.height, 1, 1]);
    const z2 = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t3 = (z2 - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = vec2_exports.lerp([], coord0, coord1, t3);
    const result = worldToLngLat(coord);
    result.push(targetZ);
    return result;
  }

  // ../../node_modules/@math.gl/web-mercator/dist/normalize-viewport-props.js
  var TILE_SIZE2 = 512;
  function normalizeViewportProps(props) {
    const { width, height, pitch = 0 } = props;
    let { longitude, latitude, zoom, bearing = 0 } = props;
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod(bearing + 180, 360) - 180;
    }
    const minZoom = log22(height / TILE_SIZE2);
    if (zoom <= minZoom) {
      zoom = minZoom;
      latitude = 0;
    } else {
      const halfHeightPixels = height / 2 / Math.pow(2, zoom);
      const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
      if (latitude < minLatitude) {
        latitude = minLatitude;
      } else {
        const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
        if (latitude > maxLatitude) {
          latitude = maxLatitude;
        }
      }
    }
    return { width, height, longitude, latitude, zoom, pitch, bearing };
  }

  // ../../node_modules/@math.gl/web-mercator/dist/fly-to-viewport.js
  var EPSILON21 = 0.01;
  var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
  var DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
  };
  function flyToViewport(startProps, endProps, t3, options) {
    const { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);
    if (u1 < EPSILON21) {
      const viewport = {};
      for (const key of VIEWPORT_TRANSITION_PROPS) {
        const startValue = startProps[key];
        const endValue = endProps[key];
        viewport[key] = lerp6(startValue, endValue, t3);
      }
      return viewport;
    }
    const s3 = t3 * S2;
    const w2 = Math.cosh(r0) / Math.cosh(r0 + rho * s3);
    const u3 = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s3) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w2;
    const newZoom = startZoom + scaleToZoom(scaleIncrement);
    const newCenterWorld = vec2_exports.scale([], uDelta, u3);
    vec2_exports.add(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = worldToLngLat(newCenterWorld);
    return {
      longitude: newCenter[0],
      latitude: newCenter[1],
      zoom: newZoom
    };
  }
  function getFlyToDuration(startProps, endProps, options) {
    const opts = { ...DEFAULT_OPTS, ...options };
    const { screenSpeed, speed, maxDuration } = opts;
    const { S: S2, rho } = getFlyToTransitionParams(startProps, endProps, opts);
    const length6 = 1e3 * S2;
    let duration;
    if (Number.isFinite(screenSpeed)) {
      duration = length6 / (screenSpeed / rho);
    } else {
      duration = length6 / speed;
    }
    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
  }
  function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [startProps.longitude, startProps.latitude];
    const startScale = zoomToScale(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [endProps.longitude, endProps.latitude];
    const scale7 = zoomToScale(endZoom - startZoom);
    const startCenterXY = lngLatToWorld(startCenter);
    const endCenterXY = lngLatToWorld(endCenter);
    const uDelta = vec2_exports.sub([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale7;
    const u1 = vec2_exports.length(uDelta) * startScale;
    const _u1 = Math.max(u1, EPSILON21);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S2 = (r1 - r0) / rho;
    return { startZoom, startCenterXY, uDelta, w0, u1, S: S2, rho, rho2, r0, r1 };
  }

  // ../core/src/shaderlib/shadow/shadow.ts
  var vs5 = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`;
  var fs4 = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`;
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x3, y3, z2] = xyz;
    const coord = pixelsToWorld([x3, y3, z2], pixelUnprojectionMatrix);
    if (Number.isFinite(z2)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition({
    viewport,
    center
  }) {
    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices({
    viewport,
    shadowMatrices
  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? void 0 : 1;
    const corners = [
      [0, 0, farZ],
      [viewport.width, 0, farZ],
      [0, viewport.height, farZ],
      [viewport.width, viewport.height, farZ],
      [0, 0, -1],
      [viewport.width, 0, -1],
      [0, viewport.height, -1],
      [viewport.width, viewport.height, -1]
    ].map(
      (pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix)
    );
    for (const shadowMatrix of shadowMatrices) {
      const viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      const positions = corners.map((corner) => viewMatrix2.transform(corner));
      const projectionMatrix = new Matrix4().ortho({
        left: Math.min(...positions.map((position) => position[0])),
        right: Math.max(...positions.map((position) => position[0])),
        bottom: Math.min(...positions.map((position) => position[1])),
        top: Math.max(...positions.map((position) => position[1])),
        near: Math.min(...positions.map((position) => -position[2])),
        far: Math.max(...positions.map((position) => -position[2]))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
  }
  function createShadowUniforms(opts, context) {
    const { shadowEnabled = true } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
      return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false,
        shadow_uShadowMap0: opts.dummyShadowMap,
        shadow_uShadowMap1: opts.dummyShadowMap
      };
    }
    const uniforms = {
      shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
      shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      shadow_uLightId: opts.shadowLightId || 0,
      shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = getMemoizedViewportCenterPosition({
      viewport: opts.viewport,
      center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: opts.viewport
    }).slice();
    for (let i5 = 0; i5 < opts.shadowMatrices.length; i5++) {
      const viewProjectionMatrix = viewProjectionMatrices[i5];
      const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
      if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i5] = viewProjectionMatrixCentered;
        projectCenters[i5] = center;
      } else {
        viewProjectionMatrices[i5] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i5] = viewProjectionMatrixCentered.transform(center);
      }
    }
    for (let i5 = 0; i5 < viewProjectionMatrices.length; i5++) {
      uniforms[`shadow_uViewProjectionMatrices[${i5}]`] = viewProjectionMatrices[i5];
      uniforms[`shadow_uProjectCenters[${i5}]`] = projectCenters[i5];
    }
    for (let i5 = 0; i5 < 2; i5++) {
      uniforms[`shadow_uShadowMap${i5}`] = opts.shadowMaps && opts.shadowMaps[i5] || opts.dummyShadowMap;
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs5,
    fs: fs4,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
      "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
    },
    getUniforms: (opts = {}, context = {}) => {
      if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
        return createShadowUniforms(opts, context);
      }
      return {};
    }
  };

  // ../core/src/shaderlib/picking/picking.ts
  var picking_default = {
    ...picking,
    defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
      "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
      }
    }
  };

  // ../core/src/shaderlib/index.ts
  var DEFAULT_MODULES = [project_default];
  var SHADER_HOOKS = [
    "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
    "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
  ];
  function getShaderAssembler() {
    const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();
    for (const shaderModule2 of DEFAULT_MODULES) {
      shaderAssembler.addDefaultModule(shaderModule2);
    }
    for (const shaderHook of SHADER_HOOKS) {
      shaderAssembler.addShaderHook(shaderHook);
    }
    return shaderAssembler;
  }

  // ../core/src/effects/lighting/ambient-light.ts
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = class {
    constructor(props = {}) {
      this.type = "ambient";
      const { color = DEFAULT_LIGHT_COLOR } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY } = props;
      this.id = props.id || `ambient-${idCount++}`;
      this.color = color;
      this.intensity = intensity;
    }
  };

  // ../core/src/effects/lighting/directional-light.ts
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = class {
    constructor(props = {}) {
      this.type = "directional";
      const { color = DEFAULT_LIGHT_COLOR2 } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY2 } = props;
      const { direction = DEFAULT_LIGHT_DIRECTION } = props;
      const { _shadow = false } = props;
      this.id = props.id || `directional-${idCount2++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    getProjectedLight(opts) {
      return this;
    }
  };

  // ../core/src/passes/pass.ts
  var Pass = class {
    constructor(device, props = { id: "pass" }) {
      const { id } = props;
      this.id = id;
      this.device = device;
      this.props = { ...props };
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    render(params) {
    }
    cleanup() {
    }
  };

  // ../core/src/passes/layers-pass.ts
  var LayersPass = class extends Pass {
    constructor() {
      super(...arguments);
      this._lastRenderIndex = -1;
    }
    render(options) {
      const [width, height] = this.device.canvasContext.getDrawingBufferSize();
      const clearCanvas = options.clearCanvas ?? true;
      const clearColor = options.clearColor ?? (clearCanvas ? [0, 0, 0, 0] : false);
      const clearDepth = clearCanvas ? 1 : false;
      const colorMask = options.colorMask ?? 15;
      const parameters2 = { viewport: [0, 0, width, height] };
      if (options.colorMask) {
        parameters2.colorMask = colorMask;
      }
      if (options.scissorRect) {
        parameters2.scissorRect = options.scissorRect;
      }
      const renderPass = this.device.beginRenderPass({
        framebuffer: options.target,
        parameters: parameters2,
        clearColor,
        clearDepth
      });
      try {
        return this._drawLayers(renderPass, options);
      } finally {
        renderPass.end();
      }
    }
    _drawLayers(renderPass, options) {
      const {
        target,
        moduleParameters,
        viewports,
        views,
        onViewportActive,
        clearStack = true
      } = options;
      options.pass = options.pass || "unknown";
      if (clearStack) {
        this._lastRenderIndex = -1;
      }
      const renderStats = [];
      for (const viewport of viewports) {
        const view = views && views[viewport.id];
        onViewportActive?.(viewport);
        const drawLayerParams = this._getDrawLayerParams(viewport, options);
        const subViewports = viewport.subViewports || [viewport];
        for (const subViewport of subViewports) {
          const stats = this._drawLayersInViewport(
            renderPass,
            {
              target,
              moduleParameters,
              viewport: subViewport,
              view,
              pass: options.pass,
              layers: options.layers
            },
            drawLayerParams
          );
          renderStats.push(stats);
        }
      }
      return renderStats;
    }
    _getDrawLayerParams(viewport, {
      layers,
      pass,
      isPicking = false,
      layerFilter,
      cullRect,
      effects,
      moduleParameters
    }, evaluateShouldDrawOnly = false) {
      const drawLayerParams = [];
      const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
      const drawContext = {
        layer: layers[0],
        viewport,
        isPicking,
        renderPass: pass,
        cullRect
      };
      const layerFilterCache = {};
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const shouldDrawLayer = this._shouldDrawLayer(
          layer,
          drawContext,
          layerFilter,
          layerFilterCache
        );
        const layerParam = {
          shouldDrawLayer
        };
        if (shouldDrawLayer && !evaluateShouldDrawOnly) {
          layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          layerParam.moduleParameters = this._getModuleParameters(
            layer,
            effects,
            pass,
            moduleParameters
          );
          layerParam.layerParameters = {
            ...layer.context.deck?.props.parameters,
            ...this.getLayerParameters(layer, layerIndex, viewport)
          };
        }
        drawLayerParams[layerIndex] = layerParam;
      }
      return drawLayerParams;
    }
    _drawLayersInViewport(renderPass, { layers, moduleParameters: globalModuleParameters, pass, target, viewport, view }, drawLayerParams) {
      const glViewport = getGLViewport(this.device, {
        moduleParameters: globalModuleParameters,
        target,
        viewport
      });
      if (view && view.props.clear) {
        const clearOpts = view.props.clear === true ? { color: true, depth: true } : view.props.clear;
        this.device.withParametersWebGL(
          {
            scissorTest: true,
            scissor: glViewport
          },
          () => this.device.clearWebGL(clearOpts)
        );
      }
      const renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      renderPass.setParameters({ viewport: glViewport });
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const { shouldDrawLayer, layerRenderIndex, moduleParameters, layerParameters } = drawLayerParams[layerIndex];
        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }
        if (layer.isComposite) {
          renderStatus.compositeCount++;
        } else if (shouldDrawLayer) {
          renderStatus.visibleCount++;
          this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
          moduleParameters.viewport = viewport;
          layer.context.renderPass = renderPass;
          try {
            layer._drawLayer({
              renderPass,
              moduleParameters,
              uniforms: { layerIndex: layerRenderIndex },
              parameters: layerParameters
            });
          } catch (err) {
            layer.raiseError(err, `drawing ${layer} to ${pass}`);
          }
        }
      }
      return renderStatus;
    }
    shouldDrawLayer(layer) {
      return true;
    }
    getModuleParameters(layer, effects) {
      return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
      const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
      if (!shouldDrawLayer) {
        return false;
      }
      drawContext.layer = layer;
      let parent = layer.parent;
      while (parent) {
        if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
          return false;
        }
        drawContext.layer = parent;
        parent = parent.parent;
      }
      if (layerFilter) {
        const rootLayerId = drawContext.layer.id;
        if (!(rootLayerId in layerFilterCache)) {
          layerFilterCache[rootLayerId] = layerFilter(drawContext);
        }
        if (!layerFilterCache[rootLayerId]) {
          return false;
        }
      }
      layer.activateViewport(drawContext.viewport);
      return true;
    }
    _getModuleParameters(layer, effects, pass, overrides) {
      const devicePixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const moduleParameters = Object.assign(
        Object.create(layer.internalState?.propsInTransition || layer.props),
        {
          autoWrapLongitude: layer.wrapLongitude,
          viewport: layer.context.viewport,
          mousePosition: layer.context.mousePosition,
          picking: {
            isActive: 0
          },
          devicePixelRatio
        }
      );
      if (effects) {
        for (const effect of effects) {
          Object.assign(moduleParameters, effect.getModuleParameters?.(layer));
        }
      }
      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
  };
  function layerIndexResolver(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn) => {
      const indexOverride = layer.props._offset;
      const layerId = layer.id;
      const parentId = layer.parent && layer.parent.id;
      let index2;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex(layer.parent, false);
      }
      if (parentId in resolvers) {
        const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index2 = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index2 = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index2 = startIndex;
      }
      if (isDrawn && index2 >= startIndex) {
        startIndex = index2 + 1;
      }
      layerIndices[layerId] = index2;
      return index2;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(device, {
    moduleParameters,
    target,
    viewport
  }) {
    const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || device.canvasContext.cssToDeviceRatio();
    const [, drawingBufferHeight] = device.canvasContext.getDrawingBufferSize();
    const height = target ? target.height : drawingBufferHeight;
    const dimensions = viewport;
    return [
      dimensions.x * pixelRatio,
      height - (dimensions.y + dimensions.height) * pixelRatio,
      dimensions.width * pixelRatio,
      dimensions.height * pixelRatio
    ];
  }

  // ../core/src/passes/shadow-pass.ts
  var ShadowPass = class extends LayersPass {
    constructor(device, props) {
      super(device, props);
      this.shadowMap = device.createTexture({
        width: 1,
        height: 1,
        sampler: {
          minFilter: "linear",
          magFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      });
      this.depthBuffer = device.createTexture({
        format: "depth16unorm",
        width: 1,
        height: 1,
        mipmaps: false,
        dataFormat: 6402,
        type: 5125
      });
      this.fbo = device.createFramebuffer({
        id: "shadowmap",
        width: 1,
        height: 1,
        colorAttachments: [this.shadowMap],
        depthStencilAttachment: this.depthBuffer
      });
    }
    render(params) {
      const target = this.fbo;
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const viewport = params.viewports[0];
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;
      const clearColor = [1, 1, 1, 1];
      if (width !== target.width || height !== target.height) {
        target.resize({ width, height });
      }
      super.render({ ...params, clearColor, target, pass: "shadow" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return { ...layer.props.parameters, blend: false, depthRange: [0, 1], depthTest: true };
    }
    shouldDrawLayer(layer) {
      return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
      return {
        drawToShadowMap: true
      };
    }
    delete() {
      if (this.fbo) {
        this.fbo.destroy();
        this.fbo = null;
      }
      if (this.shadowMap) {
        this.shadowMap.destroy();
        this.shadowMap = null;
      }
      if (this.depthBuffer) {
        this.depthBuffer.destroy();
        this.depthBuffer = null;
      }
    }
  };

  // ../core/src/effects/lighting/lighting-effect.ts
  var DEFAULT_AMBIENT_LIGHT_PROPS = { color: [255, 255, 255], intensity: 1 };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [
    {
      color: [255, 255, 255],
      intensity: 1,
      direction: [-1, 3, -1]
    },
    {
      color: [255, 255, 255],
      intensity: 0.9,
      direction: [1, -8, -2.5]
    }
  ];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = class {
    constructor(props = {}) {
      this.id = "lighting-effect";
      this.shadowColor = DEFAULT_SHADOW_COLOR2;
      this.shadow = false;
      this.ambientLight = null;
      this.directionalLights = [];
      this.pointLights = [];
      this.shadowPasses = [];
      this.shadowMaps = [];
      this.dummyShadowMap = null;
      this.setProps(props);
    }
    setup(context) {
      this.context = context;
      const { device, deck } = context;
      if (this.shadow && !this.dummyShadowMap) {
        this._createShadowPasses(device);
        deck._addDefaultShaderModule(shadow_default);
        this.dummyShadowMap = device.createTexture({
          width: 1,
          height: 1
        });
      }
    }
    setProps(props) {
      this.ambientLight = null;
      this.directionalLights = [];
      this.pointLights = [];
      for (const key in props) {
        const lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            this.ambientLight = lightSource;
            break;
          case "directional":
            this.directionalLights.push(lightSource);
            break;
          case "point":
            this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      this._applyDefaultLights();
      this.shadow = this.directionalLights.some((light) => light.shadow);
      if (this.context) {
        this.setup(this.context);
      }
      this.props = props;
    }
    preRender({ layers, layerFilter, viewports, onViewportActive, views }) {
      if (!this.shadow)
        return;
      this.shadowMatrices = this._calculateMatrices();
      for (let i5 = 0; i5 < this.shadowPasses.length; i5++) {
        const shadowPass = this.shadowPasses[i5];
        shadowPass.render({
          layers,
          layerFilter,
          viewports,
          onViewportActive,
          views,
          moduleParameters: {
            shadowLightId: i5,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
      }
    }
    getModuleParameters(layer) {
      const parameters2 = this.shadow ? {
        shadowMaps: this.shadowMaps,
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {};
      parameters2.lightSources = {
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map(
          (directionalLight) => directionalLight.getProjectedLight({ layer })
        ),
        pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({ layer }))
      };
      return parameters2;
    }
    cleanup(context) {
      for (const shadowPass of this.shadowPasses) {
        shadowPass.delete();
      }
      this.shadowPasses.length = 0;
      this.shadowMaps.length = 0;
      if (this.dummyShadowMap) {
        this.dummyShadowMap.destroy();
        this.dummyShadowMap = null;
        context.deck._removeDefaultShaderModule(shadow_default);
      }
    }
    _calculateMatrices() {
      const lightMatrices = [];
      for (const light of this.directionalLights) {
        const viewMatrix2 = new Matrix4().lookAt({
          eye: new Vector3(light.direction).negate()
        });
        lightMatrices.push(viewMatrix2);
      }
      return lightMatrices;
    }
    _createShadowPasses(device) {
      for (let i5 = 0; i5 < this.directionalLights.length; i5++) {
        const shadowPass = new ShadowPass(device);
        this.shadowPasses[i5] = shadowPass;
        this.shadowMaps[i5] = shadowPass.shadowMap;
      }
    }
    _applyDefaultLights() {
      const { ambientLight, pointLights, directionalLights } = this;
      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(
          new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]),
          new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1])
        );
      }
    }
  };

  // ../core/src/utils/typed-array-manager.ts
  var TypedArrayManager = class {
    constructor(options = {}) {
      this._pool = [];
      this.opts = { overAlloc: 2, poolSize: 100 };
      this.setOptions(options);
    }
    setOptions(options) {
      Object.assign(this.opts, options);
    }
    allocate(typedArray, count2, {
      size = 1,
      type,
      padding = 0,
      copy: copy6 = false,
      initialize = false,
      maxCount
    }) {
      const Type2 = type || typedArray && typedArray.constructor || Float32Array;
      const newSize = count2 * size + padding;
      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }
        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type2(typedArray.buffer, 0, newSize);
        }
      }
      let maxSize = Infinity;
      if (maxCount) {
        maxSize = maxCount * size + padding;
      }
      const newArray = this._allocate(Type2, newSize, initialize, maxSize);
      if (typedArray && copy6) {
        newArray.set(typedArray);
      } else if (!initialize) {
        newArray.fill(0, 0, 4);
      }
      this._release(typedArray);
      return newArray;
    }
    release(typedArray) {
      this._release(typedArray);
    }
    _allocate(Type2, size, initialize, maxSize) {
      let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
      if (sizeToAllocate > maxSize) {
        sizeToAllocate = maxSize;
      }
      const pool = this._pool;
      const byteLength = Type2.BYTES_PER_ELEMENT * sizeToAllocate;
      const i5 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i5 >= 0) {
        const array = new Type2(pool.splice(i5, 1)[0], 0, sizeToAllocate);
        if (initialize) {
          array.fill(0);
        }
        return array;
      }
      return new Type2(sizeToAllocate);
    }
    _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }
      const pool = this._pool;
      const { buffer } = typedArray;
      const { byteLength } = buffer;
      const i5 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i5 < 0) {
        pool.push(buffer);
      } else if (i5 > 0 || pool.length < this.opts.poolSize) {
        pool.splice(i5, 0, buffer);
      }
      if (pool.length > this.opts.poolSize) {
        pool.shift();
      }
    }
  };
  var typed_array_manager_default = new TypedArrayManager();

  // ../core/src/utils/math-utils.ts
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function mod2(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    return {
      left: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[0],
        viewProjectionMatrix[7] + viewProjectionMatrix[4],
        viewProjectionMatrix[11] + viewProjectionMatrix[8],
        viewProjectionMatrix[15] + viewProjectionMatrix[12]
      ),
      right: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[0],
        viewProjectionMatrix[7] - viewProjectionMatrix[4],
        viewProjectionMatrix[11] - viewProjectionMatrix[8],
        viewProjectionMatrix[15] - viewProjectionMatrix[12]
      ),
      bottom: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[1],
        viewProjectionMatrix[7] + viewProjectionMatrix[5],
        viewProjectionMatrix[11] + viewProjectionMatrix[9],
        viewProjectionMatrix[15] + viewProjectionMatrix[13]
      ),
      top: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[1],
        viewProjectionMatrix[7] - viewProjectionMatrix[5],
        viewProjectionMatrix[11] - viewProjectionMatrix[9],
        viewProjectionMatrix[15] - viewProjectionMatrix[13]
      ),
      near: getFrustumPlane(
        viewProjectionMatrix[3] + viewProjectionMatrix[2],
        viewProjectionMatrix[7] + viewProjectionMatrix[6],
        viewProjectionMatrix[11] + viewProjectionMatrix[10],
        viewProjectionMatrix[15] + viewProjectionMatrix[14]
      ),
      far: getFrustumPlane(
        viewProjectionMatrix[3] - viewProjectionMatrix[2],
        viewProjectionMatrix[7] - viewProjectionMatrix[6],
        viewProjectionMatrix[11] - viewProjectionMatrix[10],
        viewProjectionMatrix[15] - viewProjectionMatrix[14]
      )
    };
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a3, b2, c2, d2) {
    scratchVector.set(a3, b2, c2);
    const L2 = scratchVector.len();
    return { distance: d2 / L2, normal: new Vector3(-a3 / L2, -b2 / L2, -c2 / L2) };
  }
  function fp64LowPart2(x3) {
    return x3 - Math.fround(x3);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, options) {
    const { size = 1, startIndex = 0 } = options;
    const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
    const count2 = (endIndex - startIndex) / size;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
      type: Float32Array,
      size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (let j2 = 0; j2 < size; j2++) {
        const value = typedArray[sourceIndex++];
        scratchArray[targetIndex + j2] = value;
        scratchArray[targetIndex + j2 + size] = fp64LowPart2(value);
      }
      targetIndex += size * 2;
    }
    return scratchArray.subarray(0, count2 * size * 2);
  }
  function mergeBounds(boundsList) {
    let mergedBounds = null;
    let isMerged = false;
    for (const bounds of boundsList) {
      if (!bounds)
        continue;
      if (!mergedBounds) {
        mergedBounds = bounds;
      } else {
        if (!isMerged) {
          mergedBounds = [
            [mergedBounds[0][0], mergedBounds[0][1]],
            [mergedBounds[1][0], mergedBounds[1][1]]
          ];
          isMerged = true;
        }
        mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
        mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
        mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
        mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
      }
    }
    return mergedBounds;
  }

  // ../core/src/viewports/viewport.ts
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY2 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  function createProjectionMatrix({
    width,
    height,
    orthographic,
    fovyRadians,
    focalDistance,
    padding,
    near,
    far
  }) {
    const aspect = width / height;
    const matrix = orthographic ? new Matrix4().orthographic({ fovy: fovyRadians, aspect, focalDistance, near, far }) : new Matrix4().perspective({ fovy: fovyRadians, aspect, near, far });
    if (padding) {
      const { left = 0, right = 0, top = 0, bottom = 0 } = padding;
      const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
      const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
      matrix[8] -= offsetX * 2 / width;
      matrix[9] += offsetY * 2 / height;
    }
    return matrix;
  }
  var _Viewport = class {
    constructor(opts = {}) {
      this._frustumPlanes = {};
      this.id = opts.id || this.constructor.displayName || "viewport";
      this.x = opts.x || 0;
      this.y = opts.y || 0;
      this.width = opts.width || 1;
      this.height = opts.height || 1;
      this.zoom = opts.zoom || 0;
      this.padding = opts.padding;
      this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = opts.focalDistance || 1;
      this.position = opts.position || ZERO_VECTOR2;
      this.modelMatrix = opts.modelMatrix || null;
      const { longitude, latitude } = opts;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this._initProps(opts);
      this._initMatrices(opts);
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      if (this.isGeospatial) {
        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
      }
      return PROJECTION_MODE.IDENTITY;
    }
    equals(viewport) {
      if (!(viewport instanceof _Viewport)) {
        return false;
      }
      if (this === viewport) {
        return true;
      }
      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, { topLeft = true } = {}) {
      const worldPosition = this.projectPosition(xyz);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x3, y3] = coord;
      const y22 = topLeft ? y3 : this.height - y3;
      return xyz.length === 2 ? [x3, y22] : [x3, y22, coord[2]];
    }
    unproject(xyz, { topLeft = true, targetZ } = {}) {
      const [x3, y3, z2] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x3, y22, z2], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z2)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    }
    projectFlat(xyz) {
      if (this.isGeospatial) {
        const result = lngLatToWorld(xyz);
        result[1] = clamp(result[1], -318, 830);
        return result;
      }
      return xyz;
    }
    unprojectFlat(xyz) {
      if (this.isGeospatial) {
        return worldToLngLat(xyz);
      }
      return xyz;
    }
    getBounds(options = {}) {
      const unprojectOption = { targetZ: options.z || 0 };
      const topLeft = this.unproject([0, 0], unprojectOption);
      const topRight = this.unproject([this.width, 0], unprojectOption);
      const bottomLeft = this.unproject([0, this.height], unprojectOption);
      const bottomRight = this.unproject([this.width, this.height], unprojectOption);
      return [
        Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
        Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
      ];
    }
    getDistanceScales(coordinateOrigin) {
      if (coordinateOrigin) {
        return getDistanceScales({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
    containsPixel({
      x: x3,
      y: y3,
      width = 1,
      height = 1
    }) {
      return x3 < this.x + this.width && this.x < x3 + width && y3 < this.y + this.height && this.y < y3 + height;
    }
    getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }
      Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
      return this._frustumPlanes;
    }
    panByPosition(coords, pixel) {
      return null;
    }
    _initProps(opts) {
      const longitude = opts.longitude;
      const latitude = opts.latitude;
      if (this.isGeospatial) {
        if (!Number.isFinite(opts.zoom)) {
          this.zoom = getMeterZoom({ latitude }) + Math.log2(this.focalDistance);
        }
        this.distanceScales = opts.distanceScales || getDistanceScales({ latitude, longitude });
      }
      const scale7 = Math.pow(2, this.zoom);
      this.scale = scale7;
      const { position, modelMatrix: modelMatrix2 } = opts;
      let meterOffset = ZERO_VECTOR2;
      if (position) {
        meterOffset = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(position, []) : position;
      }
      if (this.isGeospatial) {
        const center = this.projectPosition([longitude, latitude, 0]);
        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
      } else {
        this.center = this.projectPosition(meterOffset);
      }
    }
    _initMatrices(opts) {
      const {
        viewMatrix: viewMatrix2 = IDENTITY2,
        projectionMatrix = null,
        orthographic = false,
        fovyRadians,
        fovy = 75,
        near = 0.1,
        far = 1e3,
        padding = null,
        focalDistance = 1
      } = opts;
      this.viewMatrixUncentered = viewMatrix2;
      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix2).translate(new Vector3(this.center).negate());
      this.projectionMatrix = projectionMatrix || createProjectionMatrix({
        width: this.width,
        height: this.height,
        orthographic,
        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
        focalDistance,
        padding,
        near,
        far
      });
      const vpm = createMat42();
      mat4_exports.multiply(vpm, vpm, this.projectionMatrix);
      mat4_exports.multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = mat4_exports.invert([], this.viewMatrix) || this.viewMatrix;
      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
      const viewportMatrix = createMat42();
      const pixelProjectionMatrix = createMat42();
      mat4_exports.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      mat4_exports.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      mat4_exports.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.pixelUnprojectionMatrix = mat4_exports.invert(createMat42(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log_default.warn("Pixel project matrix not invertible")();
      }
    }
  };
  var Viewport = _Viewport;
  Viewport.displayName = "Viewport";

  // ../core/src/viewports/web-mercator-viewport.ts
  var _WebMercatorViewport = class extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 1.01,
        nearZ,
        farZ,
        orthographic = false,
        projectionMatrix,
        repeat = false,
        worldOffset = 0,
        position,
        padding,
        legacyMeterSizes = false
      } = opts;
      let { width, height, altitude = 1.5 } = opts;
      const scale7 = Math.pow(2, zoom);
      width = width || 1;
      height = height || 1;
      let fovy;
      let projectionParameters = null;
      if (projectionMatrix) {
        altitude = projectionMatrix[5] / 2;
        fovy = altitudeToFovy(altitude);
      } else {
        if (opts.fovy) {
          fovy = opts.fovy;
          altitude = fovyToAltitude(fovy);
        } else {
          fovy = altitudeToFovy(altitude);
        }
        let offset;
        if (padding) {
          const { top = 0, bottom = 0 } = padding;
          offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
        }
        projectionParameters = getProjectionParameters({
          width,
          height,
          scale: scale7,
          center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
          offset,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
        if (Number.isFinite(nearZ)) {
          projectionParameters.near = nearZ;
        }
        if (Number.isFinite(farZ)) {
          projectionParameters.far = farZ;
        }
      }
      let viewMatrixUncentered = getViewMatrix({
        height,
        pitch,
        bearing,
        scale: scale7,
        altitude
      });
      if (worldOffset) {
        const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      super({
        ...opts,
        width,
        height,
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        ...projectionParameters,
        fovy,
        focalDistance: altitude
      });
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.orthographic = orthographic;
      this._subViewports = repeat ? [] : null;
      this._pseudoMeters = legacyMeterSizes;
      Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const bounds = this.getBounds();
        const minOffset = Math.floor((bounds[0] + 180) / 360);
        const maxOffset = Math.ceil((bounds[2] - 180) / 360);
        for (let x3 = minOffset; x3 <= maxOffset; x3++) {
          const offsetViewport = x3 ? new _WebMercatorViewport({
            ...this,
            worldOffset: x3
          }) : this;
          this._subViewports.push(offsetViewport);
        }
      }
      return this._subViewports;
    }
    projectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.projectPosition(xyz);
      }
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.unprojectPosition(xyz);
      }
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) / unitsPerMeter(Y);
      return [X, Y, Z];
    }
    addMetersToLngLat(lngLatZ, xyz) {
      return addMetersToLngLat(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
      const newCenter = vec2_exports.add([], this.center, translate3);
      const [longitude, latitude] = this.unprojectFlat(newCenter);
      return { longitude, latitude };
    }
    getBounds(options = {}) {
      const corners = getBounds(this, options.z || 0);
      return [
        Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
        Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]),
        Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]),
        Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])
      ];
    }
    fitBounds(bounds, options = {}) {
      const { width, height } = this;
      const { longitude, latitude, zoom } = fitBounds({ width, height, bounds, ...options });
      return new _WebMercatorViewport({ width, height, longitude, latitude, zoom });
    }
  };
  var WebMercatorViewport2 = _WebMercatorViewport;
  WebMercatorViewport2.displayName = "WebMercatorViewport";

  // ../core/src/shaderlib/project/project-functions.ts
  var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p3 = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof WebMercatorViewport2) {
      const [longitude, latitude, z2 = 0] = lngLatZ;
      const distanceScales = viewport.getDistanceScales([longitude, latitude]);
      p3[2] = z2 * distanceScales.unitsPerMeter[2];
    }
    return p3;
  }
  function normalizeParameters(opts) {
    const { viewport, modelMatrix: modelMatrix2, coordinateOrigin } = opts;
    let { coordinateSystem, fromCoordinateSystem, fromCoordinateOrigin } = opts;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      fromCoordinateOrigin = coordinateOrigin;
    }
    return {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    };
  }
  function getWorldPosition(position, {
    viewport,
    modelMatrix: modelMatrix2,
    coordinateSystem,
    coordinateOrigin,
    offsetMode
  }) {
    let [x3, y3, z2 = 0] = position;
    if (modelMatrix2) {
      [x3, y3, z2] = vec4_exports.transformMat4([], [x3, y3, z2, 1], modelMatrix2);
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x3, y3, z2], viewport, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition(
          [x3 + coordinateOrigin[0], y3 + coordinateOrigin[1], z2 + (coordinateOrigin[2] || 0)],
          viewport,
          offsetMode
        );
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(
          addMetersToLngLat(coordinateOrigin, [x3, y3, z2]),
          viewport,
          offsetMode
        );
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport.isGeospatial ? [x3 + coordinateOrigin[0], y3 + coordinateOrigin[1], z2 + coordinateOrigin[2]] : viewport.projectPosition([x3, y3, z2]);
    }
  }
  function projectPosition(position, params) {
    const {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix: modelMatrix2,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = normalizeParameters(params);
    const { autoOffset = true } = params;
    const {
      geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
      shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
      offsetMode = false
    } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
    const worldPosition = getWorldPosition(position, {
      viewport,
      modelMatrix: modelMatrix2,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      const positionCommonSpace = viewport.projectPosition(
        geospatialOrigin || shaderCoordinateOrigin
      );
      vec3_exports.sub(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // ../core/src/effects/lighting/point-light.ts
  var DEFAULT_LIGHT_COLOR3 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY3 = 1;
  var DEFAULT_ATTENUATION = [0, 0, 1];
  var DEFAULT_LIGHT_POSITION = [0, 0, 1];
  var idCount3 = 0;
  var PointLight = class {
    constructor(props = {}) {
      this.type = "point";
      const { color = DEFAULT_LIGHT_COLOR3 } = props;
      const { intensity = DEFAULT_LIGHT_INTENSITY3 } = props;
      const { position = DEFAULT_LIGHT_POSITION } = props;
      this.id = props.id || `point-${idCount3++}`;
      this.color = color;
      this.intensity = intensity;
      this.type = "point";
      this.position = position;
      this.attenuation = getAttenuation(props);
      this.projectedLight = { ...this };
    }
    getProjectedLight({ layer }) {
      const { projectedLight } = this;
      const viewport = layer.context.viewport;
      const { coordinateSystem, coordinateOrigin } = layer.props;
      const position = projectPosition(this.position, {
        viewport,
        coordinateSystem,
        coordinateOrigin,
        fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        fromCoordinateOrigin: [0, 0, 0]
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = position;
      return projectedLight;
    }
  };
  function getAttenuation(props) {
    if (props.attenuation) {
      return props.attenuation;
    }
    if ("intensity" in props) {
      return [0, 0, props.intensity || 0];
    }
    return DEFAULT_ATTENUATION;
  }

  // ../core/src/effects/lighting/camera-light.ts
  var CameraLight = class extends PointLight {
    getProjectedLight({ layer }) {
      const { projectedLight } = this;
      const viewport = layer.context.viewport;
      const { coordinateSystem, coordinateOrigin, modelMatrix: modelMatrix2 } = layer.props;
      const { project_uCameraPosition } = getUniformsFromViewport({
        viewport,
        modelMatrix: modelMatrix2,
        coordinateSystem,
        coordinateOrigin
      });
      projectedLight.color = this.color;
      projectedLight.intensity = this.intensity;
      projectedLight.position = project_uCameraPosition;
      return projectedLight;
    }
  };

  // ../../node_modules/@math.gl/sun/dist/suncalc.js
  var DEGREES_TO_RADIANS5 = Math.PI / 180;
  var DAY_IN_MS = 1e3 * 60 * 60 * 24;
  var JD1970 = 2440588;
  var JD2000 = 2451545;
  var e = DEGREES_TO_RADIANS5 * 23.4397;
  var M0 = 357.5291;
  var M1 = 0.98560028;
  var THETA0 = 280.147;
  var THETA1 = 360.9856235;
  function getSunPosition(timestamp, latitude, longitude) {
    const longitudeWestInRadians = DEGREES_TO_RADIANS5 * -longitude;
    const phi = DEGREES_TO_RADIANS5 * latitude;
    const d2 = toDays(timestamp);
    const c2 = getSunCoords(d2);
    const H2 = getSiderealTime(d2, longitudeWestInRadians) - c2.rightAscension;
    return {
      azimuth: getAzimuth(H2, phi, c2.declination),
      altitude: getAltitude(H2, phi, c2.declination)
    };
  }
  function getSunDirection(timestamp, latitude, longitude) {
    const { azimuth, altitude } = getSunPosition(timestamp, latitude, longitude);
    return [
      Math.sin(azimuth) * Math.cos(altitude),
      Math.cos(azimuth) * Math.cos(altitude),
      -Math.sin(altitude)
    ];
  }
  function toJulianDay(timestamp) {
    const ts = typeof timestamp === "number" ? timestamp : timestamp.getTime();
    return ts / DAY_IN_MS - 0.5 + JD1970;
  }
  function toDays(timestamp) {
    return toJulianDay(timestamp) - JD2000;
  }
  function getRightAscension(eclipticLongitude, b2) {
    const lambda = eclipticLongitude;
    return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b2) * Math.sin(e), Math.cos(lambda));
  }
  function getDeclination(eclipticLongitude, b2) {
    const lambda = eclipticLongitude;
    return Math.asin(Math.sin(b2) * Math.cos(e) + Math.cos(b2) * Math.sin(e) * Math.sin(lambda));
  }
  function getAzimuth(hourAngle, latitudeInRadians, declination) {
    const H2 = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.atan2(Math.sin(H2), Math.cos(H2) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
  }
  function getAltitude(hourAngle, latitudeInRadians, declination) {
    const H2 = hourAngle;
    const phi = latitudeInRadians;
    const delta = declination;
    return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H2));
  }
  function getSiderealTime(dates, longitudeWestInRadians) {
    return DEGREES_TO_RADIANS5 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
  }
  function getSolarMeanAnomaly(days) {
    return DEGREES_TO_RADIANS5 * (M0 + M1 * days);
  }
  function getEclipticLongitude(meanAnomaly) {
    const M2 = meanAnomaly;
    const C2 = DEGREES_TO_RADIANS5 * (1.9148 * Math.sin(M2) + 0.02 * Math.sin(2 * M2) + 3e-4 * Math.sin(3 * M2));
    const P2 = DEGREES_TO_RADIANS5 * 102.9372;
    return M2 + C2 + P2 + Math.PI;
  }
  function getSunCoords(dates) {
    const M2 = getSolarMeanAnomaly(dates);
    const L2 = getEclipticLongitude(M2);
    return {
      declination: getDeclination(L2, 0),
      rightAscension: getRightAscension(L2, 0)
    };
  }

  // ../core/src/effects/lighting/sun-light.ts
  var SunLight = class extends DirectionalLight {
    constructor(opts) {
      super(opts);
      this.timestamp = opts.timestamp;
    }
    getProjectedLight({ layer }) {
      const { viewport } = layer.context;
      const isGlobe = viewport.resolution && viewport.resolution > 0;
      if (isGlobe) {
        const [x3, y3, z2] = getSunDirection(this.timestamp, 0, 0);
        this.direction = [x3, -z2, y3];
      } else {
        const { latitude, longitude } = viewport;
        this.direction = getSunDirection(this.timestamp, latitude, longitude);
      }
      return this;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/animation/timeline.js
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    time = 0;
    channels = /* @__PURE__ */ new Map();
    animations = /* @__PURE__ */ new Map();
    playing = false;
    lastEngineTime = -1;
    constructor() {
    }
    addChannel(props) {
      const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;
      const channelId = channelHandles++;
      const channel = {
        time: 0,
        delay,
        duration,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(channelId, channel);
      return channelId;
    }
    removeChannel(channelId) {
      this.channels.delete(channelId);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === channelId) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(channelId) {
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(channelId) {
      if (channelId === void 0) {
        return this.time;
      }
      const channel = this.channels.get(channelId);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const { animation, channel } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(channelId) {
      this.animations.delete(channelId);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/animation-loop/animation-loop.js
  var statIdCounter = 0;
  var DEFAULT_ANIMATION_LOOP_PROPS = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => {
      return null;
    },
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (error) => console.error(error),
    stats: luma.stats.get(`animation-loop-${statIdCounter++}`),
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
  };
  var AnimationLoop = class {
    device = null;
    canvas = null;
    props;
    animationProps = null;
    timeline = null;
    stats;
    cpuTime;
    gpuTime;
    frameRate;
    display;
    needsRedraw = "initialized";
    _initialized = false;
    _running = false;
    _animationFrameId = null;
    _nextFramePromise = null;
    _resolveNextFrame = null;
    _cpuStartTime = 0;
    constructor(props) {
      this.props = { ...DEFAULT_ANIMATION_LOOP_PROPS, ...props };
      props = this.props;
      if (!props.device) {
        throw new Error("No device provided");
      }
      const { useDevicePixels = true } = this.props;
      this.stats = props.stats || new Stats({ id: "animation-loop-stats" });
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this.setProps({
        autoResizeViewport: props.autoResizeViewport,
        autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
      this.stop();
      this._setDisplay(null);
    }
    delete() {
      this.destroy();
    }
    setNeedsRedraw(reason) {
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.props.autoResizeViewport = props.autoResizeViewport || false;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;
      }
      if ("useDevicePixels" in props) {
        this.props.useDevicePixels = props.useDevicePixels || false;
      }
      return this;
    }
    async start() {
      if (this._running) {
        return this;
      }
      this._running = true;
      try {
        let appContext;
        if (!this._initialized) {
          this._initialized = true;
          await this._initDevice();
          this._initialize();
          await this.props.onInitialize(this._getAnimationProps());
        }
        if (!this._running) {
          return null;
        }
        if (appContext !== false) {
          this._cancelAnimationFrame();
          this._requestAnimationFrame();
        }
        return this;
      } catch (err) {
        const error = err instanceof Error ? err : new Error("Unknown error");
        this.props.onError(error);
        throw error;
      }
    }
    stop() {
      if (this._running) {
        if (this.animationProps) {
          this.props.onFinalize(this.animationProps);
        }
        this._cancelAnimationFrame();
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._running = false;
      }
      return this;
    }
    redraw() {
      if (this.device?.isLost) {
        return this;
      }
      this._beginFrameTimers();
      this._setupFrame();
      this._updateAnimationProps();
      this._renderFrame(this._getAnimationProps());
      this._clearNeedsRedraw();
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endFrameTimers();
      return this;
    }
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve2) => {
          this._resolveNextFrame = resolve2;
        });
      }
      return this._nextFramePromise;
    }
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      if (this.canvas instanceof HTMLCanvasElement) {
        return this.canvas.toDataURL();
      }
      throw new Error("OffscreenCanvas");
    }
    _initialize() {
      this._startEventHandling();
      this._initializeAnimationProps();
      this._updateAnimationProps();
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.destroy();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _requestAnimationFrame() {
      if (!this._running) {
        return;
      }
      this._animationFrameId = requestAnimationFrame2(this._animationFrame.bind(this));
    }
    _cancelAnimationFrame() {
      if (this._animationFrameId === null) {
        return;
      }
      cancelAnimationFrame(this._animationFrameId);
      this._animationFrameId = null;
    }
    _animationFrame() {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._requestAnimationFrame();
    }
    _renderFrame(animationProps) {
      if (this.display) {
        this.display._renderFrame(animationProps);
        return;
      }
      this.props.onRender(this._getAnimationProps());
      this.device.submit();
    }
    _clearNeedsRedraw() {
      this.needsRedraw = false;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
    }
    _initializeAnimationProps() {
      if (!this.device) {
        throw new Error("loop");
      }
      this.animationProps = {
        animationLoop: this,
        device: this.device,
        canvas: this.device?.canvasContext?.canvas,
        timeline: this.timeline,
        useDevicePixels: this.props.useDevicePixels,
        needsRedraw: false,
        width: 1,
        height: 1,
        aspect: 1,
        time: 0,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        _mousePosition: null
      };
    }
    _getAnimationProps() {
      if (!this.animationProps) {
        throw new Error("animationProps");
      }
      return this.animationProps;
    }
    _updateAnimationProps() {
      if (!this.animationProps) {
        return;
      }
      const { width, height, aspect } = this._getSizeAndAspect();
      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    async _initDevice() {
      this.device = await this.props.device;
      if (!this.device) {
        throw new Error("No device provided");
      }
      this.canvas = this.device.canvasContext?.canvas || null;
    }
    _createInfoDiv() {
      if (this.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div4 = document.createElement("div");
        div4.style.position = "absolute";
        div4.style.left = "10px";
        div4.style.bottom = "10px";
        div4.style.width = "300px";
        div4.style.background = "white";
        if (this.canvas instanceof HTMLCanvasElement) {
          wrapperDiv.appendChild(this.canvas);
        }
        wrapperDiv.appendChild(div4);
        const html = this.props.onAddHTML(div4);
        if (html) {
          div4.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      if (!this.device) {
        return { width: 1, height: 1, aspect: 1 };
      }
      const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];
      let aspect = 1;
      const canvas2 = this.device?.canvasContext?.canvas;
      if (canvas2 && canvas2.clientHeight) {
        aspect = canvas2.clientWidth / canvas2.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }
      return { width, height, aspect };
    }
    _resizeViewport() {
      if (this.props.autoResizeViewport && this.device.gl) {
        this.device.gl.viewport(
          0,
          0,
          this.device.gl.drawingBufferWidth,
          this.device.gl.drawingBufferHeight
        );
      }
    }
    _resizeCanvasDrawingBuffer() {
      if (this.props.autoResizeDrawingBuffer) {
        this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });
      }
    }
    _beginFrameTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      this.cpuTime.timeStart();
    }
    _endFrameTimers() {
      this.cpuTime.timeEnd();
    }
    _startEventHandling() {
      if (this.canvas) {
        this.canvas.addEventListener("mousemove", this._onMousemove.bind(this));
        this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this));
      }
    }
    _onMousemove(event) {
      if (event instanceof MouseEvent) {
        this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];
      }
    }
    _onMouseleave(event) {
      this._getAnimationProps()._mousePosition = null;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometry/gpu-geometry.js
  var GPUGeometry = class {
    id;
    userData = {};
    topology;
    bufferLayout = [];
    vertexCount;
    indices;
    attributes;
    constructor(props) {
      this.id = props.id || uid("geometry");
      this.topology = props.topology;
      this.indices = props.indices || null;
      this.attributes = props.attributes;
      this.vertexCount = props.vertexCount;
      this.bufferLayout = props.bufferLayout || [];
      if (this.indices) {
        assert6(this.indices.usage === Buffer2.INDEX);
      }
    }
    destroy() {
      this.indices?.destroy();
      for (const attribute of Object.values(this.attributes)) {
        attribute.destroy();
      }
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getIndexes() {
      return this.indices;
    }
    _calculateVertexCount(positions) {
      const vertexCount = positions.byteLength / 12;
      return vertexCount;
    }
  };
  function makeGPUGeometry(device, geometry) {
    if (geometry instanceof GPUGeometry) {
      return geometry;
    }
    const indices = getIndexBufferFromGeometry(device, geometry);
    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);
    return new GPUGeometry({
      topology: geometry.topology || "triangle-list",
      bufferLayout,
      vertexCount: geometry.vertexCount,
      indices,
      attributes
    });
  }
  function getIndexBufferFromGeometry(device, geometry) {
    if (!geometry.indices) {
      return void 0;
    }
    const data = geometry.indices.value;
    return device.createBuffer({ usage: Buffer2.INDEX, data });
  }
  function getAttributeBuffersFromGeometry(device, geometry) {
    const bufferLayout = [];
    const attributes = {};
    for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {
      let name13 = attributeName;
      switch (attributeName) {
        case "POSITION":
          name13 = "positions";
          break;
        case "NORMAL":
          name13 = "normals";
          break;
        case "TEXCOORD_0":
          name13 = "texCoords";
          break;
        case "COLOR_0":
          name13 = "colors";
          break;
      }
      attributes[name13] = device.createBuffer({ data: attribute.value, id: `${attributeName}-buffer` });
      const { value, size, normalized } = attribute;
      bufferLayout.push({ name: name13, format: getVertexFormatFromAttribute(value, size, normalized) });
    }
    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);
    return { attributes, bufferLayout, vertexCount };
  }

  // ../../node_modules/@luma.gl/engine/dist/shader-inputs.js
  var ShaderInputs = class {
    modules;
    moduleUniforms;
    moduleBindings;
    moduleUniformsChanged;
    constructor(modules) {
      const allModules = resolveModules(Object.values(modules));
      log2.log(1, "Creating ShaderInputs with modules", allModules.map((m2) => m2.name))();
      this.modules = modules;
      this.moduleUniforms = {};
      this.moduleBindings = {};
      for (const [name13, module] of Object.entries(modules)) {
        const moduleName = name13;
        this.moduleUniforms[moduleName] = module.defaultUniforms || {};
        this.moduleBindings[moduleName] = {};
      }
    }
    destroy() {
    }
    setProps(props) {
      for (const name13 of Object.keys(props)) {
        const moduleName = name13;
        const moduleProps = props[moduleName];
        const module = this.modules[moduleName];
        if (!module) {
          log2.warn(`Module ${name13} not found`)();
          continue;
        }
        const oldUniforms = this.moduleUniforms[moduleName];
        const uniforms = module.getUniforms?.(moduleProps, this.moduleUniforms[moduleName]) || moduleProps;
        this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };
      }
    }
    getModules() {
      return Object.values(this.modules);
    }
    getUniformValues() {
      return this.moduleUniforms;
    }
    getBindings() {
      const bindings = {};
      for (const moduleBindings of Object.values(this.moduleBindings)) {
        Object.assign(bindings, moduleBindings);
      }
      return bindings;
    }
    getDebugTable() {
      const table = {};
      for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {
        for (const [key, value] of Object.entries(module)) {
          table[`${moduleName}.${key}`] = {
            type: this.modules[moduleName].uniformTypes?.[key],
            value: String(value)
          };
        }
      }
      return table;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/lib/pipeline-factory.js
  var _PipelineFactory = class {
    device;
    _hashCounter = 0;
    _hashes = {};
    _renderPipelineCache = {};
    _computePipelineCache = {};
    static getDefaultPipelineFactory(device) {
      device._lumaData.defaultPipelineFactory = device._lumaData.defaultPipelineFactory || new _PipelineFactory(device);
      return device._lumaData.defaultPipelineFactory;
    }
    constructor(device) {
      this.device = device;
    }
    createRenderPipeline(props) {
      const allProps = { ...RenderPipeline.defaultProps, ...props };
      const hash = this._hashRenderPipeline(allProps);
      if (!this._renderPipelineCache[hash]) {
        const pipeline = this.device.createRenderPipeline({
          ...allProps,
          id: allProps.id ? `${allProps.id}-cached` : void 0
        });
        pipeline.hash = hash;
        this._renderPipelineCache[hash] = { pipeline, useCount: 0 };
      }
      this._renderPipelineCache[hash].useCount++;
      return this._renderPipelineCache[hash].pipeline;
    }
    createComputePipeline(props) {
      const allProps = { ...ComputePipeline.defaultProps, ...props };
      const hash = this._hashComputePipeline(allProps);
      if (!this._computePipelineCache[hash]) {
        const pipeline = this.device.createComputePipeline({
          ...allProps,
          id: allProps.id ? `${allProps.id}-cached` : void 0
        });
        pipeline.hash = hash;
        this._computePipelineCache[hash] = { pipeline, useCount: 0 };
      }
      this._computePipelineCache[hash].useCount++;
      return this._computePipelineCache[hash].pipeline;
    }
    release(pipeline) {
      const hash = pipeline.hash;
      const cache3 = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;
      cache3[hash].useCount--;
      if (cache3[hash].useCount === 0) {
        cache3[hash].pipeline.destroy();
        delete cache3[hash];
      }
    }
    _hashComputePipeline(props) {
      const shaderHash = this._getHash(props.shader.source);
      return `${shaderHash}`;
    }
    _hashRenderPipeline(props) {
      const vsHash = this._getHash(props.vs.source);
      const fsHash = props.fs ? this._getHash(props.fs.source) : 0;
      const varyingHash = "-";
      const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));
      switch (this.device.type) {
        case "webgl":
          return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;
        default:
          const parameterHash = this._getHash(JSON.stringify(props.parameters));
          return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
  };
  var PipelineFactory = _PipelineFactory;
  __publicField(PipelineFactory, "defaultProps", { ...RenderPipeline.defaultProps });

  // ../../node_modules/@luma.gl/engine/dist/lib/shader-factory.js
  var _ShaderFactory = class {
    device;
    _cache = {};
    static getDefaultShaderFactory(device) {
      device._lumaData.defaultShaderFactory ||= new _ShaderFactory(device);
      return device._lumaData.defaultShaderFactory;
    }
    constructor(device) {
      this.device = device;
    }
    createShader(props) {
      const key = this._hashShader(props);
      let cacheEntry = this._cache[key];
      if (!cacheEntry) {
        const shader = this.device.createShader({
          ...props,
          id: props.id ? `${props.id}-cached` : void 0
        });
        this._cache[key] = cacheEntry = { shader, useCount: 0 };
      }
      cacheEntry.useCount++;
      return cacheEntry.shader;
    }
    release(shader) {
      const key = this._hashShader(shader);
      const cacheEntry = this._cache[key];
      if (cacheEntry) {
        cacheEntry.useCount--;
        if (cacheEntry.useCount === 0) {
          delete this._cache[key];
          cacheEntry.shader.destroy();
        }
      }
    }
    _hashShader(value) {
      return `${value.stage}:${value.source}`;
    }
  };
  var ShaderFactory = _ShaderFactory;
  __publicField(ShaderFactory, "defaultProps", { ...Shader.defaultProps });

  // ../../node_modules/@luma.gl/engine/dist/debug/debug-shader-layout.js
  function getDebugTableForShaderLayout(layout, name13) {
    const table = {};
    const header = "Values";
    if (layout.attributes.length === 0 && !layout.varyings?.length) {
      return { "No attributes or varyings": { [header]: "N/A" } };
    }
    for (const attributeDeclaration of layout.attributes) {
      if (attributeDeclaration) {
        const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;
        table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || "vertex" };
      }
    }
    for (const varyingDeclaration of layout.varyings || []) {
      const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;
      table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration.accessor) };
    }
    return table;
  }

  // ../../node_modules/@luma.gl/engine/dist/debug/debug-framebuffer.js
  var canvas = null;
  var ctx = null;
  function debugFramebuffer(fbo, { id, minimap, opaque, top = "0", left = "0", rgbaScale = 1 }) {
    if (!canvas) {
      canvas = document.createElement("canvas");
      canvas.id = id;
      canvas.title = id;
      canvas.style.zIndex = "100";
      canvas.style.position = "absolute";
      canvas.style.top = top;
      canvas.style.left = left;
      canvas.style.border = "blue 1px solid";
      canvas.style.transform = "scaleY(-1)";
      document.body.appendChild(canvas);
      ctx = canvas.getContext("2d");
    }
    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {
      canvas.width = fbo.width / 2;
      canvas.height = fbo.height / 2;
      canvas.style.width = "400px";
      canvas.style.height = "400px";
    }
    const color = fbo.device.readPixelsToArrayWebGL(fbo);
    const imageData = ctx.createImageData(fbo.width, fbo.height);
    const offset = 0;
    for (let i5 = 0; i5 < color.length; i5 += 4) {
      imageData.data[offset + i5 + 0] = color[i5 + 0] * rgbaScale;
      imageData.data[offset + i5 + 1] = color[i5 + 1] * rgbaScale;
      imageData.data[offset + i5 + 2] = color[i5 + 2] * rgbaScale;
      imageData.data[offset + i5 + 3] = opaque ? 255 : color[i5 + 3] * rgbaScale;
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // ../../node_modules/@luma.gl/engine/dist/model/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var _Model = class {
    device;
    id;
    source;
    vs;
    fs;
    pipelineFactory;
    shaderFactory;
    userData = {};
    parameters;
    topology;
    bufferLayout;
    vertexCount;
    instanceCount = 0;
    indexBuffer = null;
    bufferAttributes = {};
    constantAttributes = {};
    bindings = {};
    uniforms = {};
    vertexArray;
    transformFeedback = null;
    pipeline;
    shaderInputs;
    _uniformStore;
    _attributeInfos = {};
    _gpuGeometry = null;
    _getModuleUniforms;
    props;
    _pipelineNeedsUpdate = "newly created";
    _needsRedraw = "initializing";
    _destroyed = false;
    _lastDrawTimestamp = -1;
    constructor(device, props) {
      this.props = { ..._Model.defaultProps, ...props };
      props = this.props;
      this.id = props.id || uid("model");
      this.device = device;
      Object.assign(this.userData, props.userData);
      const moduleMap = Object.fromEntries(this.props.modules?.map((module) => [module.name, module]) || []);
      this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));
      const platformInfo = getPlatformInfo(device);
      const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
      const isWebGPU = this.device.type === "webgpu";
      if (isWebGPU && this.props.source) {
        this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);
        const { source, getUniforms: getUniforms8 } = this.props.shaderAssembler.assembleShader({
          platformInfo,
          ...this.props,
          modules
        });
        this.source = source;
        this._getModuleUniforms = getUniforms8;
      } else {
        const { vs: vs13, fs: fs10, getUniforms: getUniforms8 } = this.props.shaderAssembler.assembleShaderPair({
          platformInfo,
          ...this.props,
          modules
        });
        this.vs = vs13;
        this.fs = fs10;
        this._getModuleUniforms = getUniforms8;
      }
      this.vertexCount = this.props.vertexCount;
      this.instanceCount = this.props.instanceCount;
      this.topology = this.props.topology;
      this.bufferLayout = this.props.bufferLayout;
      this.parameters = this.props.parameters;
      if (props.geometry) {
        this.setGeometry(props.geometry);
      }
      this.pipelineFactory = props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);
      this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);
      this.pipeline = this._updatePipeline();
      this.vertexArray = device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
      if (props.vertexCount) {
        this.setVertexCount(props.vertexCount);
      }
      if (props.instanceCount) {
        this.setInstanceCount(props.instanceCount);
      }
      if (props.indexBuffer) {
        this.setIndexBuffer(props.indexBuffer);
      }
      if (props.attributes) {
        this.setAttributes(props.attributes);
      }
      if (props.constantAttributes) {
        this.setConstantAttributes(props.constantAttributes);
      }
      if (props.bindings) {
        this.setBindings(props.bindings);
      }
      if (props.uniforms) {
        this.setUniforms(props.uniforms);
      }
      if (props.moduleSettings) {
        this.updateModuleSettings(props.moduleSettings);
      }
      if (props.transformFeedback) {
        this.transformFeedback = props.transformFeedback;
      }
      Object.seal(this);
    }
    destroy() {
      if (this._destroyed)
        return;
      this.pipelineFactory.release(this.pipeline);
      this.shaderFactory.release(this.pipeline.vs);
      if (this.pipeline.fs) {
        this.shaderFactory.release(this.pipeline.fs);
      }
      this._uniformStore.destroy();
      this._gpuGeometry?.destroy();
      this._destroyed = true;
    }
    needsRedraw() {
      if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {
        this.setNeedsRedraw("contents of bound textures or buffers updated");
      }
      const needsRedraw = this._needsRedraw;
      this._needsRedraw = false;
      return needsRedraw;
    }
    setNeedsRedraw(reason) {
      this._needsRedraw ||= reason;
    }
    predraw() {
      this.updateShaderInputs();
      this.pipeline = this._updatePipeline();
    }
    draw(renderPass) {
      this.predraw();
      let drawSuccess;
      try {
        this._logDrawCallStart();
        this.pipeline = this._updatePipeline();
        this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings });
        if (!isObjectEmpty(this.uniforms)) {
          this.pipeline.setUniformsWebGL(this.uniforms);
        }
        const { indexBuffer } = this.vertexArray;
        const indexCount = indexBuffer ? indexBuffer.byteLength / (indexBuffer.indexType === "uint32" ? 4 : 2) : void 0;
        drawSuccess = this.pipeline.draw({
          renderPass,
          vertexArray: this.vertexArray,
          vertexCount: this.vertexCount,
          instanceCount: this.instanceCount,
          indexCount,
          transformFeedback: this.transformFeedback || void 0,
          parameters: this.parameters,
          topology: this.topology
        });
      } finally {
        this._logDrawCallEnd();
      }
      this._logFramebuffer(renderPass);
      if (drawSuccess) {
        this._lastDrawTimestamp = this.device.timestamp;
        this._needsRedraw = false;
      } else {
        this._needsRedraw = "waiting for resource initialization";
      }
      return drawSuccess;
    }
    setGeometry(geometry) {
      this._gpuGeometry?.destroy();
      const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);
      if (gpuGeometry) {
        this.setTopology(gpuGeometry.topology || "triangle-list");
        this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);
        if (this.vertexArray) {
          this._setGeometryAttributes(gpuGeometry);
        }
      }
      this._gpuGeometry = gpuGeometry;
    }
    setTopology(topology) {
      if (topology !== this.topology) {
        this.topology = topology;
        this._setPipelineNeedsUpdate("topology");
      }
    }
    setBufferLayout(bufferLayout) {
      this.bufferLayout = this._gpuGeometry ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout) : bufferLayout;
      this._setPipelineNeedsUpdate("bufferLayout");
      this.pipeline = this._updatePipeline();
      this.vertexArray = this.device.createVertexArray({
        renderPipeline: this.pipeline
      });
      if (this._gpuGeometry) {
        this._setGeometryAttributes(this._gpuGeometry);
      }
    }
    setParameters(parameters2) {
      if (!deepEqual(parameters2, this.parameters, 2)) {
        this.parameters = parameters2;
        this._setPipelineNeedsUpdate("parameters");
      }
    }
    setVertexCount(vertexCount) {
      this.vertexCount = vertexCount;
      this.setNeedsRedraw("vertexCount");
    }
    setInstanceCount(instanceCount) {
      this.instanceCount = instanceCount;
      this.setNeedsRedraw("instanceCount");
    }
    setShaderInputs(shaderInputs) {
      this.shaderInputs = shaderInputs;
      this._uniformStore = new UniformStore(this.shaderInputs.modules);
      for (const moduleName of Object.keys(this.shaderInputs.modules)) {
        const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);
        this.bindings[`${moduleName}Uniforms`] = uniformBuffer;
      }
      this.setNeedsRedraw("shaderInputs");
    }
    updateShaderInputs() {
      this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());
      this.setNeedsRedraw("shaderInputs");
    }
    setBindings(bindings) {
      Object.assign(this.bindings, bindings);
      this.setNeedsRedraw("bindings");
    }
    setTransformFeedback(transformFeedback) {
      this.transformFeedback = transformFeedback;
      this.setNeedsRedraw("transformFeedback");
    }
    setIndexBuffer(indexBuffer) {
      this.vertexArray.setIndexBuffer(indexBuffer);
      this.setNeedsRedraw("indexBuffer");
    }
    setAttributes(buffers, options) {
      if (buffers.indices) {
        log2.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
      }
      for (const [bufferName, buffer] of Object.entries(buffers)) {
        const bufferLayout = this.bufferLayout.find((layout) => getAttributeNames(layout).includes(bufferName));
        if (!bufferLayout) {
          log2.warn(`Model(${this.id}): Missing layout for buffer "${bufferName}".`)();
          continue;
        }
        const attributeNames = getAttributeNames(bufferLayout);
        let set5 = false;
        for (const attributeName of attributeNames) {
          const attributeInfo = this._attributeInfos[attributeName];
          if (attributeInfo) {
            this.vertexArray.setBuffer(attributeInfo.location, buffer);
            set5 = true;
          }
        }
        if (!set5 && !(options?.disableWarnings ?? this.props.disableWarnings)) {
          log2.warn(`Model(${this.id}): Ignoring buffer "${buffer.id}" for unknown attribute "${bufferName}"`)();
        }
      }
      this.setNeedsRedraw("attributes");
    }
    setConstantAttributes(attributes, options) {
      for (const [attributeName, value] of Object.entries(attributes)) {
        const attributeInfo = this._attributeInfos[attributeName];
        if (attributeInfo) {
          this.vertexArray.setConstantWebGL(attributeInfo.location, value);
        } else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {
          log2.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${attributeName}"`)();
        }
      }
      this.setNeedsRedraw("constants");
    }
    setUniforms(uniforms) {
      if (!isObjectEmpty(uniforms)) {
        this.pipeline.setUniformsWebGL(uniforms);
        Object.assign(this.uniforms, uniforms);
      }
      this.setNeedsRedraw("uniforms");
    }
    updateModuleSettings(props) {
      const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));
      Object.assign(this.bindings, bindings);
      Object.assign(this.uniforms, uniforms);
      this.setNeedsRedraw("moduleSettings");
    }
    _getBindingsUpdateTimestamp() {
      let timestamp = 0;
      for (const binding of Object.values(this.bindings)) {
        if (binding instanceof TextureView) {
          timestamp = Math.max(timestamp, binding.texture.updateTimestamp);
        } else if (binding instanceof Buffer2 || binding instanceof Texture) {
          timestamp = Math.max(timestamp, binding.updateTimestamp);
        } else if (!(binding instanceof Sampler)) {
          timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);
        }
      }
      return timestamp;
    }
    _setGeometryAttributes(gpuGeometry) {
      const attributes = { ...gpuGeometry.attributes };
      for (const [attributeName] of Object.entries(attributes)) {
        if (!this.pipeline.shaderLayout.attributes.find((layout) => layout.name === attributeName) && attributeName !== "positions") {
          delete attributes[attributeName];
        }
      }
      this.vertexCount = gpuGeometry.vertexCount;
      this.setIndexBuffer(gpuGeometry.indices || null);
      this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });
      this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });
      this.setNeedsRedraw("geometry attributes");
    }
    _setPipelineNeedsUpdate(reason) {
      this._pipelineNeedsUpdate ||= reason;
      this.setNeedsRedraw(reason);
    }
    _updatePipeline() {
      if (this._pipelineNeedsUpdate) {
        let prevShaderVs = null;
        let prevShaderFs = null;
        if (this.pipeline) {
          log2.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)();
          prevShaderVs = this.pipeline.vs;
          prevShaderFs = this.pipeline.fs;
        }
        this._pipelineNeedsUpdate = false;
        const vs13 = this.shaderFactory.createShader({
          id: `${this.id}-vertex`,
          stage: "vertex",
          source: this.source || this.vs,
          debug: this.props.debugShaders
        });
        let fs10 = null;
        if (this.source) {
          fs10 = vs13;
        } else if (this.fs) {
          fs10 = this.shaderFactory.createShader({
            id: `${this.id}-fragment`,
            stage: "fragment",
            source: this.source || this.fs,
            debug: this.props.debugShaders
          });
        }
        this.pipeline = this.pipelineFactory.createRenderPipeline({
          ...this.props,
          bufferLayout: this.bufferLayout,
          topology: this.topology,
          parameters: this.parameters,
          vs: vs13,
          fs: fs10
        });
        this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);
        if (prevShaderVs)
          this.shaderFactory.release(prevShaderVs);
        if (prevShaderFs)
          this.shaderFactory.release(prevShaderFs);
      }
      return this.pipeline;
    }
    _lastLogTime = 0;
    _logOpen = false;
    _logDrawCallStart() {
      const logDrawTimeout = log2.level > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (log2.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {
        return;
      }
      this._lastLogTime = Date.now();
      this._logOpen = true;
      log2.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log2.level <= 2 })();
    }
    _logDrawCallEnd() {
      if (this._logOpen) {
        const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);
        log2.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();
        const uniformTable = this.shaderInputs.getDebugTable();
        for (const [name13, value] of Object.entries(this.uniforms)) {
          uniformTable[name13] = { value };
        }
        log2.table(LOG_DRAW_PRIORITY, uniformTable)();
        const attributeTable = this._getAttributeDebugTable();
        log2.table(LOG_DRAW_PRIORITY, this._attributeInfos)();
        log2.table(LOG_DRAW_PRIORITY, attributeTable)();
        log2.groupEnd(LOG_DRAW_PRIORITY)();
        this._logOpen = false;
      }
    }
    _drawCount = 0;
    _logFramebuffer(renderPass) {
      const debugFramebuffers = log2.get("framebuffer");
      this._drawCount++;
      if (!debugFramebuffers || this._drawCount++ > 3 && this._drawCount % 60) {
        return;
      }
      const framebuffer = renderPass.props.framebuffer;
      if (framebuffer) {
        debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });
      }
    }
    _getAttributeDebugTable() {
      const table = {};
      for (const [name13, attributeInfo] of Object.entries(this._attributeInfos)) {
        table[attributeInfo.location] = {
          name: name13,
          type: attributeInfo.shaderType,
          values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)
        };
      }
      if (this.vertexArray.indexBuffer) {
        const { indexBuffer } = this.vertexArray;
        const values = indexBuffer.indexType === "uint32" ? new Uint32Array(indexBuffer.debugData) : new Uint16Array(indexBuffer.debugData);
        table.indices = {
          name: "indices",
          type: indexBuffer.indexType,
          values: values.toString()
        };
      }
      return table;
    }
    _getBufferOrConstantValues(attribute, dataType) {
      const TypedArrayConstructor = getTypedArrayFromDataType(dataType);
      const typedArray = attribute instanceof Buffer2 ? new TypedArrayConstructor(attribute.debugData) : attribute;
      return typedArray.toString();
    }
  };
  var Model = _Model;
  __publicField(Model, "defaultProps", {
    ...RenderPipeline.defaultProps,
    source: null,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  });
  function mergeBufferLayouts(layouts1, layouts2) {
    const layouts = [...layouts1];
    for (const attribute of layouts2) {
      const index2 = layouts.findIndex((attribute2) => attribute2.name === attribute.name);
      if (index2 < 0) {
        layouts.push(attribute);
      } else {
        layouts[index2] = attribute;
      }
    }
    return layouts;
  }
  function getPlatformInfo(device) {
    return {
      type: device.type,
      shaderLanguage: device.info.shadingLanguage,
      shaderLanguageVersion: device.info.shadingLanguageVersion,
      gpu: device.info.gpu,
      features: device.features
    };
  }
  function getAttributeNames(bufferLayout) {
    return bufferLayout.attributes ? bufferLayout.attributes?.map((layout) => layout.attribute) : [bufferLayout.name];
  }

  // ../../node_modules/@luma.gl/engine/dist/transform/buffer-transform.js
  var BufferTransform = class {
    device;
    model;
    transformFeedback;
    static isSupported(device) {
      return device?.info?.type === "webgl";
    }
    constructor(device, props = Model.defaultProps) {
      assert6(BufferTransform.isSupported(device), "BufferTransform not yet implemented on WebGPU");
      this.device = device;
      this.model = new Model(this.device, {
        id: props.id || "buffer-transform-model",
        fs: props.fs || getPassthroughFS(),
        topology: props.topology || "point-list",
        ...props
      });
      this.transformFeedback = this.device.createTransformFeedback({
        layout: this.model.pipeline.shaderLayout,
        buffers: props.feedbackBuffers
      });
      this.model.setTransformFeedback(this.transformFeedback);
      Object.seal(this);
    }
    destroy() {
      if (this.model) {
        this.model.destroy();
      }
    }
    delete() {
      this.destroy();
    }
    run(options) {
      const renderPass = this.device.beginRenderPass(options);
      this.model.draw(renderPass);
      renderPass.end();
    }
    update(...args) {
      console.warn("TextureTransform#update() not implemented");
    }
    getBuffer(varyingName) {
      return this.transformFeedback.getBuffer(varyingName);
    }
    readAsync(varyingName) {
      const result = this.getBuffer(varyingName);
      if (result instanceof Buffer2) {
        return result.readAsync();
      }
      const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
      return buffer.readAsync(byteOffset, byteLength);
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/transform/texture-transform.js
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    device;
    model;
    sampler;
    currentIndex = 0;
    samplerTextureMap = null;
    bindings = [];
    resources = {};
    constructor(device, props) {
      this.device = device;
      this.sampler = device.createSampler({
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
        minFilter: "nearest",
        magFilter: "nearest",
        mipmapFilter: "nearest"
      });
      this.model = new Model(this.device, {
        id: props.id || "texture-transform-model",
        fs: props.fs || getPassthroughFS({
          input: props.targetTextureVarying,
          inputChannels: props.targetTextureChannels,
          output: FS_OUTPUT_VARIABLE
        }),
        vertexCount: props.vertexCount,
        ...props
      });
      this._initialize(props);
      Object.seal(this);
    }
    destroy() {
    }
    delete() {
      this.destroy();
    }
    run(options) {
      const { framebuffer } = this.bindings[this.currentIndex];
      const renderPass = this.device.beginRenderPass({ framebuffer, ...options });
      this.model.draw(renderPass);
      renderPass.end();
    }
    update(...args) {
      console.warn("TextureTransform#update() not implemented");
    }
    getData({ packed = false } = {}) {
      throw new Error("getData() not implemented");
    }
    getTargetTexture() {
      const { targetTexture } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    _initialize(props) {
      this._updateBindings(props);
    }
    _updateBindings(props) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);
    }
    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const { width, height } = targetTexture;
        if (binding.framebuffer) {
          binding.framebuffer.destroy();
        }
        binding.framebuffer = this.device.createFramebuffer({
          id: "transform-framebuffer",
          width,
          height,
          colorAttachments: [targetTexture]
        });
        binding.framebuffer.resize({ width, height });
      }
      return binding;
    }
    _setSourceTextureParameters() {
      const index2 = this.currentIndex;
      const { sourceTextures } = this.bindings[index2];
      for (const name13 in sourceTextures) {
        sourceTextures[name13].sampler = this.sampler;
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometry/geometry.js
  var Geometry = class {
    id;
    topology;
    vertexCount;
    indices;
    attributes;
    userData = {};
    constructor(props) {
      const { attributes = {}, indices = null, vertexCount = null } = props;
      this.id = props.id || uid("geometry");
      this.topology = props.topology;
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;
      }
      this.attributes = {};
      for (const [attributeName, attributeValue] of Object.entries(attributes)) {
        const attribute = ArrayBuffer.isView(attributeValue) ? { value: attributeValue } : attributeValue;
        assert6(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          assert6(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;
    }
    _print(attributeName) {
      return `Geometry ${this.id} attribute ${attributeName}`;
    }
    _setAttributes(attributes, indices) {
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attribute of Object.values(attributes)) {
        const { value, size, constant } = attribute;
        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }
      assert6(Number.isFinite(vertexCount));
      return vertexCount;
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/lib/clip-space.js
  var CLIPSPACE_VERTEX_SHADER = `#version 300 es
in vec2 aClipSpacePosition;
in vec2 aTexCoord;
in vec2 aCoordinate;
out vec2 position;
out vec2 coordinate;
out vec2 uv;
void main(void) {
gl_Position = vec4(aClipSpacePosition, 0., 1.);
position = aClipSpacePosition;
coordinate = aCoordinate;
uv = aTexCoord;
}
`;
  var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
  var ClipSpace = class extends Model {
    constructor(device, opts) {
      const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
      super(device, {
        ...opts,
        vs: CLIPSPACE_VERTEX_SHADER,
        vertexCount: 4,
        geometry: new Geometry({
          topology: "triangle-strip",
          vertexCount: 4,
          attributes: {
            aClipSpacePosition: { size: 2, value: new Float32Array(POSITIONS) },
            aTexCoord: { size: 2, value: new Float32Array(TEX_COORDS) },
            aCoordinate: { size: 2, value: new Float32Array(TEX_COORDS) }
          }
        })
      });
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/scenegraph-node.js
  var ScenegraphNode = class {
    id;
    matrix = new Matrix4();
    display = true;
    position = new Vector3();
    rotation = new Vector3();
    scale = new Vector3(1, 1, 1);
    userData = {};
    props = {};
    constructor(props = {}) {
      const { id } = props;
      this.id = id || uid(this.constructor.name);
      this._setScenegraphNodeProps(props);
    }
    getBounds() {
      return null;
    }
    destroy() {
    }
    delete() {
      this.destroy();
    }
    setProps(props) {
      this._setScenegraphNodeProps(props);
      return this;
    }
    toString() {
      return `{type: ScenegraphNode, id: ${this.id})}`;
    }
    setPosition(position) {
      assert6(position.length === 3, "setPosition requires vector argument");
      this.position = position;
      return this;
    }
    setRotation(rotation) {
      assert6(rotation.length === 3, "setRotation requires vector argument");
      this.rotation = rotation;
      return this;
    }
    setScale(scale7) {
      assert6(scale7.length === 3, "setScale requires vector argument");
      this.scale = scale7;
      return this;
    }
    setMatrix(matrix, copyMatrix = true) {
      if (copyMatrix) {
        this.matrix.copy(matrix);
      } else {
        this.matrix = matrix;
      }
    }
    setMatrixComponents(components) {
      const { position, rotation, scale: scale7, update = true } = components;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale7) {
        this.setScale(scale7);
      }
      if (update) {
        this.updateMatrix();
      }
      return this;
    }
    updateMatrix() {
      const pos = this.position;
      const rot = this.rotation;
      const scale7 = this.scale;
      this.matrix.identity();
      this.matrix.translate(pos);
      this.matrix.rotateXYZ(rot);
      this.matrix.scale(scale7);
      return this;
    }
    update(options = {}) {
      const { position, rotation, scale: scale7 } = options;
      if (position) {
        this.setPosition(position);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (scale7) {
        this.setScale(scale7);
      }
      this.updateMatrix();
      return this;
    }
    getCoordinateUniforms(viewMatrix2, modelMatrix2) {
      assert6(viewMatrix2);
      modelMatrix2 = modelMatrix2 || this.matrix;
      const worldMatrix = new Matrix4(viewMatrix2).multiplyRight(modelMatrix2);
      const worldInverse = worldMatrix.invert();
      const worldInverseTranspose = worldInverse.transpose();
      return {
        viewMatrix: viewMatrix2,
        modelMatrix: modelMatrix2,
        objectMatrix: modelMatrix2,
        worldMatrix,
        worldInverseMatrix: worldInverse,
        worldInverseTransposeMatrix: worldInverseTranspose
      };
    }
    _setScenegraphNodeProps(props) {
      if ("display" in props) {
        this.display = props.display;
      }
      if ("position" in props) {
        this.setPosition(props.position);
      }
      if ("rotation" in props) {
        this.setRotation(props.rotation);
      }
      if ("scale" in props) {
        this.setScale(props.scale);
      }
      if ("matrix" in props) {
        this.setMatrix(props.matrix);
      }
      Object.assign(this.props, props);
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/group-node.js
  var GroupNode = class extends ScenegraphNode {
    children;
    constructor(props = {}) {
      props = Array.isArray(props) ? { children: props } : props;
      const { children = [] } = props;
      log2.assert(children.every((child) => child instanceof ScenegraphNode), "every child must an instance of ScenegraphNode");
      super(props);
      this.children = children;
    }
    getBounds() {
      const result = [
        [Infinity, Infinity, Infinity],
        [-Infinity, -Infinity, -Infinity]
      ];
      this.traverse((node2, { worldMatrix }) => {
        const bounds = node2.getBounds();
        if (!bounds) {
          return;
        }
        const [min4, max4] = bounds;
        const center = new Vector3(min4).add(max4).divide([2, 2, 2]);
        worldMatrix.transformAsPoint(center, center);
        const halfSize = new Vector3(max4).subtract(min4).divide([2, 2, 2]);
        worldMatrix.transformAsVector(halfSize, halfSize);
        for (let v2 = 0; v2 < 8; v2++) {
          const position = new Vector3(v2 & 1 ? -1 : 1, v2 & 2 ? -1 : 1, v2 & 4 ? -1 : 1).multiply(halfSize).add(center);
          for (let i5 = 0; i5 < 3; i5++) {
            result[0][i5] = Math.min(result[0][i5], position[i5]);
            result[1][i5] = Math.max(result[1][i5], position[i5]);
          }
        }
      });
      if (!Number.isFinite(result[0][0])) {
        return null;
      }
      return result;
    }
    destroy() {
      this.children.forEach((child) => child.destroy());
      this.removeAll();
      super.destroy();
    }
    add(...children) {
      for (const child of children) {
        if (Array.isArray(child)) {
          this.add(...child);
        } else {
          this.children.push(child);
        }
      }
      return this;
    }
    remove(child) {
      const children = this.children;
      const indexOf = children.indexOf(child);
      if (indexOf > -1) {
        children.splice(indexOf, 1);
      }
      return this;
    }
    removeAll() {
      this.children = [];
      return this;
    }
    traverse(visitor, { worldMatrix = new Matrix4() } = {}) {
      const modelMatrix2 = new Matrix4(worldMatrix).multiplyRight(this.matrix);
      for (const child of this.children) {
        if (child instanceof GroupNode) {
          child.traverse(visitor, { worldMatrix: modelMatrix2 });
        } else {
          visitor(child, { worldMatrix: modelMatrix2 });
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/scenegraph/model-node.js
  var ModelNode = class extends ScenegraphNode {
    model;
    bounds = null;
    managedResources;
    constructor(props) {
      super(props);
      this.model = props.model;
      this.managedResources = props.managedResources || [];
      this.bounds = props.bounds || null;
      this.setProps(props);
    }
    getBounds() {
      return this.bounds;
    }
    destroy() {
      if (this.model) {
        this.model.destroy();
        this.model = null;
      }
      this.managedResources.forEach((resource) => resource.destroy());
      this.managedResources = [];
    }
    draw(renderPass) {
      return this.model.draw(renderPass);
    }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometries/cube-geometry.js
  var CubeGeometry = class extends Geometry {
    constructor(props = {}) {
      const { id = uid("cube-geometry"), indices = true } = props;
      super(indices ? {
        ...props,
        id,
        topology: "triangle-list",
        indices: { size: 1, value: CUBE_INDICES },
        attributes: { ...ATTRIBUTES, ...props.attributes }
      } : {
        ...props,
        id,
        topology: "triangle-list",
        indices: void 0,
        attributes: { ...NON_INDEXED_ATTRIBUTES, ...props.attributes }
      });
    }
  };
  var CUBE_INDICES = new Uint16Array([
    0,
    1,
    2,
    0,
    2,
    3,
    4,
    5,
    6,
    4,
    6,
    7,
    8,
    9,
    10,
    8,
    10,
    11,
    12,
    13,
    14,
    12,
    14,
    15,
    16,
    17,
    18,
    16,
    18,
    19,
    20,
    21,
    22,
    20,
    22,
    23
  ]);
  var CUBE_POSITIONS = new Float32Array([
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1
  ]);
  var CUBE_NORMALS = new Float32Array([
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0
  ]);
  var CUBE_TEX_COORDS = new Float32Array([
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1
  ]);
  var CUBE_NON_INDEXED_POSITIONS = new Float32Array([
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    1,
    -1
  ]);
  var CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    0
  ]);
  var CUBE_NON_INDEXED_COLORS = new Float32Array([
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    0,
    1
  ]);
  var ATTRIBUTES = {
    POSITION: { size: 3, value: CUBE_POSITIONS },
    NORMAL: { size: 3, value: CUBE_NORMALS },
    TEXCOORD_0: { size: 2, value: CUBE_TEX_COORDS }
  };
  var NON_INDEXED_ATTRIBUTES = {
    POSITION: { size: 3, value: CUBE_NON_INDEXED_POSITIONS },
    TEXCOORD_0: { size: 2, value: CUBE_NON_INDEXED_TEX_COORDS },
    COLOR_0: { size: 3, value: CUBE_NON_INDEXED_COLORS }
  };

  // ../../node_modules/@luma.gl/engine/dist/geometries/sphere-geometry.js
  var SphereGeometry = class extends Geometry {
    constructor(props = {}) {
      const { id = uid("sphere-geometry") } = props;
      const { indices, attributes } = tesselateSphere(props);
      super({
        ...props,
        id,
        topology: "triangle-list",
        indices,
        attributes: { ...attributes, ...props.attributes }
      });
    }
  };
  function tesselateSphere(props) {
    const { nlat = 10, nlong = 10 } = props;
    const startLat = 0;
    const endLat = Math.PI;
    const latRange = endLat - startLat;
    const startLong = 0;
    const endLong = 2 * Math.PI;
    const longRange = endLong - startLong;
    const numVertices = (nlat + 1) * (nlong + 1);
    const radius = (n1, n22, n3, u3, v2) => props.radius || 1;
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    const texCoords = new Float32Array(numVertices * 2);
    const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
    const indices = new IndexType(nlat * nlong * 6);
    for (let y3 = 0; y3 <= nlat; y3++) {
      for (let x3 = 0; x3 <= nlong; x3++) {
        const u3 = x3 / nlong;
        const v2 = y3 / nlat;
        const index2 = x3 + y3 * (nlong + 1);
        const i22 = index2 * 2;
        const i32 = index2 * 3;
        const theta = longRange * u3;
        const phi = latRange * v2;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const sinPhi = Math.sin(phi);
        const cosPhi = Math.cos(phi);
        const ux = cosTheta * sinPhi;
        const uy = cosPhi;
        const uz = sinTheta * sinPhi;
        const r3 = radius(ux, uy, uz, u3, v2);
        positions[i32 + 0] = r3 * ux;
        positions[i32 + 1] = r3 * uy;
        positions[i32 + 2] = r3 * uz;
        normals[i32 + 0] = ux;
        normals[i32 + 1] = uy;
        normals[i32 + 2] = uz;
        texCoords[i22 + 0] = u3;
        texCoords[i22 + 1] = 1 - v2;
      }
    }
    const numVertsAround = nlong + 1;
    for (let x3 = 0; x3 < nlong; x3++) {
      for (let y3 = 0; y3 < nlat; y3++) {
        const index2 = (x3 * nlat + y3) * 6;
        indices[index2 + 0] = y3 * numVertsAround + x3;
        indices[index2 + 1] = y3 * numVertsAround + x3 + 1;
        indices[index2 + 2] = (y3 + 1) * numVertsAround + x3;
        indices[index2 + 3] = (y3 + 1) * numVertsAround + x3;
        indices[index2 + 4] = y3 * numVertsAround + x3 + 1;
        indices[index2 + 5] = (y3 + 1) * numVertsAround + x3 + 1;
      }
    }
    return {
      indices: { size: 1, value: indices },
      attributes: {
        POSITION: { size: 3, value: positions },
        NORMAL: { size: 3, value: normals },
        TEXCOORD_0: { size: 2, value: texCoords }
      }
    };
  }

  // ../core/src/passes/screen-pass.ts
  var ScreenPass = class extends Pass {
    constructor(device, props) {
      super(device, props);
      const { module, fs: fs10, id } = props;
      const parameters2 = { depthWriteEnabled: false, depthCompare: "always" };
      this.model = new ClipSpace(device, { id, fs: fs10, modules: [module], parameters: parameters2 });
    }
    render(params) {
      this._renderPass(this.device, params);
    }
    delete() {
      this.model.destroy();
      this.model = null;
    }
    _renderPass(device, options) {
      const { clearCanvas, inputBuffer, outputBuffer } = options;
      const texSize = [inputBuffer.width, inputBuffer.height];
      this.model.shaderInputs.setProps(options.moduleSettings);
      this.model.setBindings({ texSrc: inputBuffer.colorAttachments[0] });
      this.model.setUniforms({ texSize });
      const renderPass = this.device.beginRenderPass({
        framebuffer: outputBuffer,
        parameters: { viewport: [0, 0, ...texSize] },
        clearColor: clearCanvas ? [0, 0, 0, 0] : false,
        clearDepth: 1
      });
      this.model.draw(renderPass);
      renderPass.end();
    }
  };

  // ../core/src/effects/post-process-effect.ts
  var PostProcessEffect = class {
    constructor(module, props) {
      this.id = `${module.name}-pass`;
      this.props = props;
      normalizeShaderModule(module);
      this.module = module;
    }
    setup({ device }) {
      this.passes = createPasses(device, this.module, this.id);
    }
    setProps(props) {
      this.props = props;
    }
    preRender() {
    }
    postRender(params) {
      const passes = this.passes;
      const { target } = params;
      let inputBuffer = params.inputBuffer;
      let outputBuffer = params.swapBuffer;
      for (let index2 = 0; index2 < passes.length; index2++) {
        const isLastPass = index2 === passes.length - 1;
        const renderToTarget = target !== void 0 && isLastPass;
        if (renderToTarget) {
          outputBuffer = target;
        }
        const clearCanvas = !renderToTarget || Boolean(params.clearCanvas);
        const moduleSettings = {};
        moduleSettings[this.module.name] = this.props;
        passes[index2].render({ clearCanvas, inputBuffer, outputBuffer, moduleSettings });
        const switchBuffer = outputBuffer;
        outputBuffer = inputBuffer;
        inputBuffer = switchBuffer;
      }
      return inputBuffer;
    }
    cleanup() {
      if (this.passes) {
        for (const pass of this.passes) {
          pass.delete();
        }
        this.passes = void 0;
      }
    }
  };
  function createPasses(device, module, id) {
    return module.passes.map((pass, index2) => {
      const fs10 = getFragmentShaderForRenderPass(module, pass);
      const idn = `${id}-${index2}`;
      return new ScreenPass(device, { id: idn, module, fs: fs10 });
    });
  }
  var FS_TEMPLATE_INPUTS = `#version 300 es
uniform sampler2D texSrc;
uniform vec2 texSize;

in vec2 position;
in vec2 coordinate;
in vec2 uv;

out vec4 fragColor;
`;
  var FILTER_FS_TEMPLATE = (func) => `${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = texture(texSrc, coordinate);
  fragColor = ${func}(fragColor, texSize, coordinate);
}
`;
  var SAMPLER_FS_TEMPLATE = (func) => `${FS_TEMPLATE_INPUTS}
void main() {
  fragColor = ${func}(texSrc, texSize, coordinate);
}
`;
  function getFragmentShaderForRenderPass(module, pass) {
    if (pass.filter) {
      const func = typeof pass.filter === "string" ? pass.filter : `${module.name}_filterColor`;
      return FILTER_FS_TEMPLATE(func);
    }
    if (pass.sampler) {
      const func = typeof pass.sampler === "string" ? pass.sampler : `${module.name}_sampleColor`;
      return SAMPLER_FS_TEMPLATE(func);
    }
    return "";
  }

  // ../core/src/passes/pick-layers-pass.ts
  var PICKING_BLENDING = {
    blendColorOperation: "add",
    blendColorSrcFactor: "one",
    blendColorDstFactor: "zero",
    blendAlphaOperation: "add",
    blendAlphaSrcFactor: "constant-alpha",
    blendAlphaDstFactor: "zero"
  };
  var PickLayersPass = class extends LayersPass {
    constructor() {
      super(...arguments);
      this._colorEncoderState = null;
    }
    render(props) {
      if ("pickingFBO" in props) {
        return this._drawPickingBuffer(props);
      }
      return super.render(props);
    }
    _drawPickingBuffer({
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect: { x: x3, y: y3, width, height },
      cullRect,
      effects,
      pass = "picking",
      pickZ,
      moduleParameters
    }) {
      this.pickZ = pickZ;
      const colorEncoderState = this._resetColorEncoder(pickZ);
      const scissorRect = [x3, y3, width, height];
      const renderStatus = super.render({
        target: pickingFBO,
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        cullRect,
        effects: effects?.filter((e3) => e3.useInPicking),
        pass,
        isPicking: true,
        moduleParameters,
        clearColor: [0, 0, 0, 0],
        colorMask: 15,
        scissorRect
      });
      this._colorEncoderState = null;
      const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
      return { decodePickingColor, stats: renderStatus };
    }
    shouldDrawLayer(layer) {
      const { pickable, operation } = layer.props;
      return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
    }
    getModuleParameters() {
      return {
        picking: {
          isActive: 1,
          isAttribute: this.pickZ
        },
        lightSources: {}
      };
    }
    getLayerParameters(layer, layerIndex, viewport) {
      const pickParameters = {
        depthMask: true,
        depthTest: true,
        depthRange: [0, 1],
        ...layer.props.parameters
      };
      const { pickable, operation } = layer.props;
      if (!this._colorEncoderState || operation.includes("terrain")) {
        pickParameters.blend = false;
      } else if (pickable && operation.includes("draw")) {
        Object.assign(pickParameters, PICKING_BLENDING);
        pickParameters.blend = true;
        pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
      }
      return pickParameters;
    }
    _resetColorEncoder(pickZ) {
      this._colorEncoderState = pickZ ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      };
      return this._colorEncoderState;
    }
  };
  function encodeColor(encoded, layer, viewport) {
    const { byLayer, byAlpha } = encoded;
    let a3;
    let entry = byLayer.get(layer);
    if (entry) {
      entry.viewports.push(viewport);
      a3 = entry.a;
    } else {
      a3 = byLayer.size + 1;
      if (a3 <= 255) {
        entry = { a: a3, layer, viewports: [viewport] };
        byLayer.set(layer, entry);
        byAlpha[a3] = entry;
      } else {
        log_default.warn("Too many pickable layers, only picking the first 255")();
        a3 = 0;
      }
    }
    return [0, 0, 0, a3 / 255];
  }
  function decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
      pickedLayer: entry.layer,
      pickedViewports: entry.viewports,
      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
  }

  // ../core/src/lifecycle/constants.ts
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var COMPONENT_SYMBOL = Symbol.for("component");
  var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
  var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
  var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
  var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
  var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

  // ../core/src/utils/flatten.ts
  function flatten(array, filter = () => true) {
    if (!Array.isArray(array)) {
      return filter(array) ? [array] : [];
    }
    return flattenArray(array, filter, []);
  }
  function flattenArray(array, filter, result) {
    let index2 = -1;
    while (++index2 < array.length) {
      const value = array[index2];
      if (Array.isArray(value)) {
        flattenArray(value, filter, result);
      } else if (filter(value)) {
        result.push(value);
      }
    }
    return result;
  }
  function fillArray2({ target, source, start = 0, count: count2 = 1 }) {
    const length6 = source.length;
    const total = count2 * length6;
    let copied = 0;
    for (let i5 = start; copied < length6; copied++) {
      target[i5++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // ../core/src/lib/resource/resource.ts
  var Resource2 = class {
    constructor(id, data, context) {
      this._loadCount = 0;
      this._subscribers = /* @__PURE__ */ new Set();
      this.id = id;
      this.context = context;
      this.setData(data);
    }
    subscribe(consumer) {
      this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
      this._subscribers.delete(consumer);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(data, forceUpdate) {
      if (data === this._data && !forceUpdate) {
        return;
      }
      this._data = data;
      const loadCount = ++this._loadCount;
      let loader = data;
      if (typeof data === "string") {
        loader = load(data);
      }
      if (loader instanceof Promise) {
        this.isLoaded = false;
        this._loader = loader.then((result) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = void 0;
            this._content = result;
          }
        }).catch((error) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = error || true;
          }
        });
      } else {
        this.isLoaded = true;
        this._error = void 0;
        this._content = data;
      }
      for (const subscriber of this._subscribers) {
        subscriber.onChange(this.getData());
      }
    }
  };

  // ../core/src/lib/resource/resource-manager.ts
  var ResourceManager = class {
    constructor(props) {
      this.protocol = props.protocol || "resource://";
      this._context = {
        device: props.device,
        gl: props.device?.gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    contains(resourceId) {
      if (resourceId.startsWith(this.protocol)) {
        return true;
      }
      return resourceId in this._resources;
    }
    add({
      resourceId,
      data,
      forceUpdate = false,
      persistent = true
    }) {
      let res = this._resources[resourceId];
      if (res) {
        res.setData(data, forceUpdate);
      } else {
        res = new Resource2(resourceId, data, this._context);
        this._resources[resourceId] = res;
      }
      res.persistent = persistent;
    }
    remove(resourceId) {
      const res = this._resources[resourceId];
      if (res) {
        res.delete();
        delete this._resources[resourceId];
      }
    }
    unsubscribe({ consumerId }) {
      const consumer = this._consumers[consumerId];
      if (consumer) {
        for (const requestId in consumer) {
          const request = consumer[requestId];
          const resource = this._resources[request.resourceId];
          if (resource) {
            resource.unsubscribe(request);
          }
        }
        delete this._consumers[consumerId];
        this.prune();
      }
    }
    subscribe({
      resourceId,
      onChange,
      consumerId,
      requestId = "default"
    }) {
      const { _resources: resources, protocol } = this;
      if (resourceId.startsWith(protocol)) {
        resourceId = resourceId.replace(protocol, "");
        if (!resources[resourceId]) {
          this.add({ resourceId, data: null, persistent: false });
        }
      }
      const res = resources[resourceId];
      this._track(consumerId, requestId, res, onChange);
      if (res) {
        return res.getData();
      }
      return void 0;
    }
    prune() {
      if (!this._pruneRequest) {
        this._pruneRequest = setTimeout(() => this._prune(), 0);
      }
    }
    finalize() {
      for (const key in this._resources) {
        this._resources[key].delete();
      }
    }
    _track(consumerId, requestId, resource, onChange) {
      const consumers = this._consumers;
      const consumer = consumers[consumerId] = consumers[consumerId] || {};
      let request = consumer[requestId];
      const oldResource = request && request.resourceId && this._resources[request.resourceId];
      if (oldResource) {
        oldResource.unsubscribe(request);
        this.prune();
      }
      if (resource) {
        if (request) {
          request.onChange = onChange;
          request.resourceId = resource.id;
        } else {
          request = {
            onChange,
            resourceId: resource.id
          };
        }
        consumer[requestId] = request;
        resource.subscribe(request);
      }
    }
    _prune() {
      this._pruneRequest = null;
      for (const key of Object.keys(this._resources)) {
        const res = this._resources[key];
        if (!res.persistent && !res.inUse()) {
          res.delete();
          delete this._resources[key];
        }
      }
    }
  };

  // ../core/src/lib/layer-manager.ts
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var LayerManager = class {
    constructor(device, props) {
      this._lastRenderedLayers = [];
      this._needsRedraw = false;
      this._needsUpdate = false;
      this._nextLayers = null;
      this._debug = false;
      this._defaultShaderModulesChanged = false;
      this.activateViewport = (viewport) => {
        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
        if (viewport) {
          this.context.viewport = viewport;
        }
      };
      const { deck, stats, viewport, timeline } = props || {};
      this.layers = [];
      this.resourceManager = new ResourceManager({ device, protocol: "deck://" });
      this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        device,
        gl: device?.gl,
        deck,
        shaderAssembler: getShaderAssembler(),
        defaultShaderModules: [],
        renderPass: void 0,
        stats: stats || new Stats({ id: "deck.gl" }),
        viewport: viewport || new Viewport({ id: "DEFAULT-INITIAL-VIEWPORT" }),
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager,
        onError: void 0
      };
      Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (const layer of this.layers) {
        this._finalizeLayer(layer);
      }
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      for (const layer of this.layers) {
        const layerNeedsRedraw = layer.getNeedsRedraw(opts);
        redraw = redraw || layerNeedsRedraw;
      }
      return redraw;
    }
    needsUpdate() {
      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
        return "layers changed";
      }
      if (this._defaultShaderModulesChanged) {
        return "shader modules changed";
      }
      return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({ layerIds } = {}) {
      return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
      if ("debug" in props) {
        this._debug = props.debug;
      }
      if ("userData" in props) {
        this.context.userData = props.userData;
      }
      if ("layers" in props) {
        this._nextLayers = props.layers;
      }
      if ("onError" in props) {
        this.context.onError = props.onError;
      }
    }
    setLayers(newLayers, reason) {
      debug(TRACE_SET_LAYERS, this, reason, newLayers);
      this._lastRenderedLayers = newLayers;
      const flatLayers = flatten(newLayers, Boolean);
      for (const layer of flatLayers) {
        layer.context = this.context;
      }
      this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
      const reason = this.needsUpdate();
      if (reason) {
        this.setNeedsRedraw(`updating layers: ${reason}`);
        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
      }
      this._nextLayers = null;
    }
    addDefaultShaderModule(module) {
      const { defaultShaderModules } = this.context;
      if (!defaultShaderModules.find((m2) => m2.name === module.name)) {
        defaultShaderModules.push(module);
        this._defaultShaderModulesChanged = true;
      }
    }
    removeDefaultShaderModule(module) {
      const { defaultShaderModules } = this.context;
      const i5 = defaultShaderModules.findIndex((m2) => m2.name === module.name);
      if (i5 >= 0) {
        defaultShaderModules.splice(i5, 1);
        this._defaultShaderModulesChanged = true;
      }
    }
    _handleError(stage, error, layer) {
      layer.raiseError(error, `${stage} of ${layer}`);
    }
    _updateLayers(oldLayers, newLayers) {
      const oldLayerMap = {};
      for (const oldLayer of oldLayers) {
        if (oldLayerMap[oldLayer.id]) {
          log_default.warn(`Multiple old layers with same id ${oldLayer.id}`)();
        } else {
          oldLayerMap[oldLayer.id] = oldLayer;
        }
      }
      if (this._defaultShaderModulesChanged) {
        for (const layer of oldLayers) {
          layer.setNeedsUpdate();
          layer.setChangeFlags({ extensionsChanged: true });
        }
        this._defaultShaderModulesChanged = false;
      }
      const generatedLayers = [];
      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
      this._finalizeOldLayers(oldLayerMap);
      let needsUpdate = false;
      for (const layer of generatedLayers) {
        if (layer.hasUniformTransition()) {
          needsUpdate = `Uniform transition in ${layer}`;
          break;
        }
      }
      this._needsUpdate = needsUpdate;
      this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
      for (const newLayer of newLayers) {
        newLayer.context = this.context;
        const oldLayer = oldLayerMap[newLayer.id];
        if (oldLayer === null) {
          log_default.warn(`Multiple new layers with same id ${newLayer.id}`)();
        }
        oldLayerMap[newLayer.id] = null;
        let sublayers = null;
        try {
          if (this._debug && oldLayer !== newLayer) {
            newLayer.validateProps();
          }
          if (!oldLayer) {
            this._initializeLayer(newLayer);
          } else {
            this._transferLayerState(oldLayer, newLayer);
            this._updateLayer(newLayer);
          }
          generatedLayers.push(newLayer);
          sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
        } catch (err) {
          this._handleError("matching", err, newLayer);
        }
        if (sublayers) {
          this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
      }
    }
    _finalizeOldLayers(oldLayerMap) {
      for (const layerId in oldLayerMap) {
        const layer = oldLayerMap[layerId];
        if (layer) {
          this._finalizeLayer(layer);
        }
      }
    }
    _initializeLayer(layer) {
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        this._handleError("initialization", err, layer);
      }
    }
    _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      if (newLayer !== oldLayer) {
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      }
    }
    _updateLayer(layer) {
      try {
        layer._update();
      } catch (err) {
        this._handleError("update", err, layer);
      }
    }
    _finalizeLayer(layer) {
      this._needsRedraw = this._needsRedraw || `finalized ${layer}`;
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      try {
        layer._finalize();
        layer.lifecycle = LIFECYCLE.FINALIZED;
      } catch (err) {
        this._handleError("finalization", err, layer);
      }
    }
  };

  // ../core/src/utils/deep-equal.ts
  function deepEqual2(a3, b2, depth) {
    if (a3 === b2) {
      return true;
    }
    if (!depth || !a3 || !b2) {
      return false;
    }
    if (Array.isArray(a3)) {
      if (!Array.isArray(b2) || a3.length !== b2.length) {
        return false;
      }
      for (let i5 = 0; i5 < a3.length; i5++) {
        if (!deepEqual2(a3[i5], b2[i5], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b2)) {
      return false;
    }
    if (typeof a3 === "object" && typeof b2 === "object") {
      const aKeys = Object.keys(a3);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b2.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual2(a3[key], b2[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../core/src/lib/view-manager.ts
  var ViewManager = class {
    constructor(props) {
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "First render";
      this._needsUpdate = "Initialize";
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    finalize() {
      for (const key in this.controllers) {
        const controller = this.controllers[key];
        if (controller) {
          controller.finalize();
        }
      }
      this.controllers = {};
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
      for (const viewId in this.controllers) {
        const controller = this.controllers[viewId];
        if (controller) {
          controller.updateTransition();
        }
      }
    }
    getViewports(rect) {
      if (rect) {
        return this._viewports.filter((viewport) => viewport.containsPixel(rect));
      }
      return this._viewports;
    }
    getViews() {
      const viewMap = {};
      this.views.forEach((view) => {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
    getView(viewId) {
      return this.views.find((view) => view.id === viewId);
    }
    getViewState(viewOrViewId) {
      const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
      const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
      const viewports = this.getViewports();
      const pixel = { x: xyz[0], y: xyz[1] };
      for (let i5 = viewports.length - 1; i5 >= 0; --i5) {
        const viewport = viewports[i5];
        if (viewport.containsPixel(pixel)) {
          const p3 = xyz.slice();
          p3[0] -= viewport.x;
          p3[1] -= viewport.y;
          return viewport.unproject(p3, opts);
        }
      }
      return null;
    }
    setProps(props) {
      if (props.views) {
        this._setViews(props.views);
      }
      if (props.viewState) {
        this._setViewState(props.viewState);
      }
      if ("width" in props || "height" in props) {
        this._setSize(props.width, props.height);
      }
      if (!this._isUpdating) {
        this._update();
      }
    }
    _update() {
      this._isUpdating = true;
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      this._isUpdating = false;
    }
    _setSize(width, height) {
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate("Size changed");
      }
    }
    _setViews(views) {
      views = flatten(views, Boolean);
      const viewsChanged = this._diffViews(views, this.views);
      if (viewsChanged) {
        this.setNeedsUpdate("views changed");
      }
      this.views = views;
    }
    _setViewState(viewState) {
      if (viewState) {
        const viewStateChanged = !deepEqual2(viewState, this.viewState, 3);
        if (viewStateChanged) {
          this.setNeedsUpdate("viewState changed");
        }
        this.viewState = viewState;
      } else {
        log_default.warn("missing `viewState` or `initialViewState`")();
      }
    }
    _createController(view, props) {
      const Controller2 = props.type;
      const controller = new Controller2({
        timeline: this.timeline,
        eventManager: this._eventManager,
        onViewStateChange: this._eventCallbacks.onViewStateChange,
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (viewState) => this.getView(view.id)?.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        })
      });
      return controller;
    }
    _updateController(view, viewState, viewport, controller) {
      const controllerProps = view.controller;
      if (controllerProps && viewport) {
        const resolvedProps = {
          ...viewState,
          ...controllerProps,
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        };
        if (!controller || controller.constructor !== controllerProps.type) {
          controller = this._createController(view, resolvedProps);
        }
        if (controller) {
          controller.setProps(resolvedProps);
        }
        return controller;
      }
      return null;
    }
    _rebuildViewports() {
      const { views } = this;
      const oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};
      let invalidateControllers = false;
      for (let i5 = views.length; i5--; ) {
        const view = views[i5];
        const viewState = this.getViewState(view);
        const viewport = view.makeViewport({ viewState, width: this.width, height: this.height });
        let oldController = oldControllers[view.id];
        const hasController = Boolean(view.controller);
        if (hasController && !oldController) {
          invalidateControllers = true;
        }
        if ((invalidateControllers || !hasController) && oldController) {
          oldController.finalize();
          oldController = null;
        }
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
        if (viewport) {
          this._viewports.unshift(viewport);
        }
      }
      for (const id in oldControllers) {
        const oldController = oldControllers[id];
        if (oldController && !this.controllers[id]) {
          oldController.finalize();
        }
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {};
      this._viewports.forEach((viewport) => {
        if (viewport.id) {
          this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        }
      });
    }
    _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }
      return newViews.some((_, i5) => !newViews[i5].equals(oldViews[i5]));
    }
  };

  // ../core/src/utils/positions.ts
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value) {
    switch (typeof value) {
      case "number":
        return {
          position: value,
          relative: false
        };
      case "string":
        const match = PERCENT_OR_PIXELS_REGEX.exec(value);
        if (match && match.length >= 3) {
          const relative = match[2] === "%";
          const position = parseFloat(match[1]);
          return {
            position: relative ? position / 100 : position,
            relative
          };
        }
      default:
        throw new Error(`Could not parse position string ${value}`);
    }
  }
  function getPosition(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
  }

  // ../core/src/views/view.ts
  var View = class {
    constructor(props) {
      const { id, x: x3 = 0, y: y3 = 0, width = "100%", height = "100%", padding = null } = props;
      this.id = id || this.constructor.displayName || "view";
      this.props = { ...props, id: this.id };
      this._x = parsePosition(x3);
      this._y = parsePosition(y3);
      this._width = parsePosition(width);
      this._height = parsePosition(height);
      this._padding = padding && {
        left: parsePosition(padding.left || 0),
        right: parsePosition(padding.right || 0),
        top: parsePosition(padding.top || 0),
        bottom: parsePosition(padding.bottom || 0)
      };
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    equals(view) {
      if (this === view) {
        return true;
      }
      return this.ViewportType === view.ViewportType && deepEqual2(this.props, view.props, 2);
    }
    makeViewport({ width, height, viewState }) {
      viewState = this.filterViewState(viewState);
      const viewportDimensions = this.getDimensions({ width, height });
      if (!viewportDimensions.height || !viewportDimensions.width) {
        return null;
      }
      return new this.ViewportType({ ...viewState, ...this.props, ...viewportDimensions });
    }
    getViewStateId() {
      const { viewState } = this.props;
      if (typeof viewState === "string") {
        return viewState;
      }
      return viewState?.id || this.id;
    }
    filterViewState(viewState) {
      if (this.props.viewState && typeof this.props.viewState === "object") {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }
        const newViewState = { ...viewState };
        for (const key in this.props.viewState) {
          if (key !== "id") {
            newViewState[key] = this.props.viewState[key];
          }
        }
        return newViewState;
      }
      return viewState;
    }
    getDimensions({ width, height }) {
      const dimensions = {
        x: getPosition(this._x, width),
        y: getPosition(this._y, height),
        width: getPosition(this._width, width),
        height: getPosition(this._height, height)
      };
      if (this._padding) {
        dimensions.padding = {
          left: getPosition(this._padding.left, width),
          top: getPosition(this._padding.top, height),
          right: getPosition(this._padding.right, width),
          bottom: getPosition(this._padding.bottom, height)
        };
      }
      return dimensions;
    }
    get controller() {
      const opts = this.props.controller;
      if (!opts) {
        return null;
      }
      if (opts === true) {
        return { type: this.ControllerType };
      }
      if (typeof opts === "function") {
        return { type: opts };
      }
      return { type: this.ControllerType, ...opts };
    }
  };

  // ../core/src/transitions/transition.ts
  var Transition = class {
    constructor(timeline) {
      this._inProgress = false;
      this._handle = null;
      this.time = 0;
      this.settings = {
        duration: 0
      };
      this._timeline = timeline;
    }
    get inProgress() {
      return this._inProgress;
    }
    start(settings) {
      this.cancel();
      this.settings = settings;
      this._inProgress = true;
      this.settings.onStart?.(this);
    }
    end() {
      if (this._inProgress) {
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
        this.settings.onEnd?.(this);
      }
    }
    cancel() {
      if (this._inProgress) {
        this.settings.onInterrupt?.(this);
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
      }
    }
    update() {
      if (!this._inProgress) {
        return false;
      }
      if (this._handle === null) {
        const { _timeline: timeline, settings } = this;
        this._handle = timeline.addChannel({
          delay: timeline.getTime(),
          duration: settings.duration
        });
      }
      this.time = this._timeline.getTime(this._handle);
      this._onUpdate();
      this.settings.onUpdate?.(this);
      if (this._timeline.isFinished(this._handle)) {
        this.end();
      }
      return true;
    }
    _onUpdate() {
    }
  };

  // ../core/src/controllers/transition-manager.ts
  var noop2 = () => {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_EASING = (t3) => t3;
  var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
  var TransitionManager = class {
    constructor(opts) {
      this._onTransitionUpdate = (transition) => {
        const {
          time,
          settings: { interpolator, startProps, endProps, duration, easing }
        } = transition;
        const t3 = easing(time / duration);
        const viewport = interpolator.interpolateProps(startProps, endProps, t3);
        this.propsInTransition = this.getControllerState({
          ...this.props,
          ...viewport
        }).getViewportProps();
        this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      };
      this.getControllerState = opts.getControllerState;
      this.propsInTransition = null;
      this.transition = new Transition(opts.timeline);
      this.onViewStateChange = opts.onViewStateChange || noop2;
      this.onStateChange = opts.onStateChange || noop2;
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
      let transitionTriggered = false;
      const currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        let startProps = currentProps;
        if (this.transition.inProgress) {
          const { interruption, endProps } = this.transition.settings;
          startProps = {
            ...currentProps,
            ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
          };
        }
        this._triggerTransition(startProps, nextProps);
        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }
      return transitionTriggered;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(props) {
      const { transitionDuration, transitionInterpolator } = props;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress && this.propsInTransition) {
        return this.transition.settings.interpolator.arePropsEqual(
          props,
          this.propsInTransition
        );
      }
      return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        const transitionSettings = this.transition.settings;
        return transitionSettings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(
          currentProps,
          nextProps
        );
      }
      return true;
    }
    _triggerTransition(startProps, endProps) {
      const startViewstate = this.getControllerState(startProps);
      const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
      const transitionInterpolator = endProps.transitionInterpolator;
      const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration === 0) {
        return;
      }
      const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      const transitionSettings = {
        duration,
        easing: endProps.transitionEasing || DEFAULT_EASING,
        interpolator: transitionInterpolator,
        interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      };
      this.transition.start(transitionSettings);
      this.onStateChange({ inTransition: true });
      this.updateTransition();
    }
    _onTransitionEnd(callback) {
      return (transition) => {
        this.propsInTransition = null;
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
        callback?.(transition);
      };
    }
  };

  // ../core/src/utils/assert.ts
  function assert9(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "deck.gl: assertion failed.");
    }
  }

  // ../core/src/transitions/transition-interpolator.ts
  var TransitionInterpolator = class {
    constructor(opts) {
      const { compare: compare2, extract, required } = opts;
      this._propsToCompare = compare2;
      this._propsToExtract = extract || compare2;
      this._requiredProps = required;
    }
    arePropsEqual(currentProps, nextProps) {
      for (const key of this._propsToCompare) {
        if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    initializeProps(startProps, endProps) {
      const startViewStateProps = {};
      const endViewStateProps = {};
      for (const key of this._propsToExtract) {
        if (key in startProps || key in endProps) {
          startViewStateProps[key] = startProps[key];
          endViewStateProps[key] = endProps[key];
        }
      }
      this._checkRequiredProps(startViewStateProps);
      this._checkRequiredProps(endViewStateProps);
      return { start: startViewStateProps, end: endViewStateProps };
    }
    getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }
      this._requiredProps.forEach((propName) => {
        const value = props[propName];
        assert9(
          Number.isFinite(value) || Array.isArray(value),
          `${propName} is required for transition`
        );
      });
    }
  };

  // ../core/src/transitions/linear-interpolator.ts
  var DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      const normalizedOpts = Array.isArray(opts) ? {} : opts;
      normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
        compare: transitionProps,
        required: transitionProps
      } : transitionProps || {
        compare: DEFAULT_PROPS3,
        required: DEFAULT_REQUIRED_PROPS
      };
      super(normalizedOpts.transitionProps);
      this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
      const result = super.initializeProps(startProps, endProps);
      const { makeViewport: makeViewport2, around } = this.opts;
      if (makeViewport2 && around) {
        const startViewport = makeViewport2(startProps);
        const endViewport = makeViewport2(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
      return result;
    }
    interpolateProps(startProps, endProps, t3) {
      const propsInTransition = {};
      for (const key of this._propsToExtract) {
        propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t3);
      }
      if (endProps.aroundPosition && this.opts.makeViewport) {
        const viewport = this.opts.makeViewport({ ...endProps, ...propsInTransition });
        Object.assign(
          propsInTransition,
          viewport.panByPosition(
            endProps.aroundPosition,
            lerp(startProps.around, endProps.around, t3)
          )
        );
      }
      return propsInTransition;
    }
  };

  // ../core/src/controllers/controller.ts
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = (t3) => 1 - (1 - t3) * (1 - t3);
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var pinchEventWorkaround = {};
  var Controller = class {
    constructor(opts) {
      this.state = {};
      this._events = {};
      this._interactionState = {
        isDragging: false
      };
      this._customEvents = [];
      this._eventStartBlocked = null;
      this._panMove = false;
      this.invertPan = false;
      this.dragMode = "rotate";
      this.inertia = 0;
      this.scrollZoom = true;
      this.dragPan = true;
      this.dragRotate = true;
      this.doubleClickZoom = true;
      this.touchZoom = true;
      this.touchRotate = false;
      this.keyboard = true;
      this.transitionManager = new TransitionManager({
        ...opts,
        getControllerState: (props) => new this.ControllerState(props),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      });
      this.handleEvent = this.handleEvent.bind(this);
      this.eventManager = opts.eventManager;
      this.onViewStateChange = opts.onViewStateChange || (() => {
      });
      this.onStateChange = opts.onStateChange || (() => {
      });
      this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
      this.toggleEvents(this._customEvents, false);
      this.toggleEvents(customEvents, true);
      this._customEvents = customEvents;
      if (this.props) {
        this.setProps(this.props);
      }
    }
    finalize() {
      for (const eventName in this._events) {
        if (this._events[eventName]) {
          this.eventManager?.off(eventName, this.handleEvent);
        }
      }
      this.transitionManager.finalize();
    }
    handleEvent(event) {
      this._controllerState = void 0;
      const eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "tripanstart":
          return eventStartBlocked ? false : this._onTriplePanStart(event);
        case "tripanmove":
          return this._onTriplePan(event);
        case "tripanend":
          return this._onTriplePanEnd(event);
        case "doubletap":
          return this._onDoubleTap(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
    get controllerState() {
      this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      });
      return this._controllerState;
    }
    getCenter(event) {
      const { x: x3, y: y3 } = this.props;
      const { offsetCenter } = event;
      return [offsetCenter.x - x3, offsetCenter.y - y3];
    }
    isPointInBounds(pos, event) {
      const { width, height } = this.props;
      if (event && event.handled) {
        return false;
      }
      const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
      if (inside && event) {
        event.stopPropagation();
      }
      return inside;
    }
    isFunctionKeyPressed(event) {
      const { srcEvent } = event;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
      const timer = setTimeout(() => {
        if (this._eventStartBlocked === timer) {
          this._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
    setProps(props) {
      if (props.dragMode) {
        this.dragMode = props.dragMode;
      }
      this.props = props;
      if (!("transitionInterpolator" in props)) {
        props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
      }
      this.transitionManager.processViewStateChange(props);
      const { inertia } = props;
      this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
      const {
        scrollZoom = true,
        dragPan = true,
        dragRotate = true,
        doubleClickZoom = true,
        touchZoom = true,
        touchRotate = false,
        keyboard = true
      } = props;
      const isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
      if (this.eventManager) {
        eventNames.forEach((eventName) => {
          if (this._events[eventName] !== enabled) {
            this._events[eventName] = enabled;
            if (enabled) {
              this.eventManager.on(eventName, this.handleEvent);
            } else {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
        });
      }
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
      const viewState = { ...newControllerState.getViewportProps(), ...extraProps };
      const changed = this.controllerState !== newControllerState;
      this.state = newControllerState.getState();
      this._setInteractionState(interactionState);
      if (changed) {
        const oldViewState = this.controllerState && this.controllerState.getViewportProps();
        if (this.onViewStateChange) {
          this.onViewStateChange({ viewState, interactionState: this._interactionState, oldViewState, viewId: this.props.id });
        }
      }
    }
    _onTransition(params) {
      this.onViewStateChange({ ...params, interactionState: this._interactionState, viewId: this.props.id });
    }
    _setInteractionState(newStates) {
      Object.assign(this._interactionState, newStates);
      this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
      if (this.invertPan || this.dragMode === "pan") {
        alternateMode = !alternateMode;
      }
      const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
        pos
      });
      this._panMove = alternateMode;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.pan({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
    _onPanMoveEnd(event) {
      const { inertia } = this;
      if (this.dragPan && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [
          pos[0] + event.velocityX * inertia / 2,
          pos[1] + event.velocityY * inertia / 2
        ];
        const newControllerState = this.controllerState.pan({ pos: endPos2 }).panEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isPanning: true
          }
        );
      } else {
        const newControllerState = this.controllerState.panEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.rotate({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onPanRotateEnd(event) {
      const { inertia } = this;
      if (this.dragRotate && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos2 = [
          pos[0] + event.velocityX * inertia / 2,
          pos[1] + event.velocityY * inertia / 2
        ];
        const newControllerState = this.controllerState.rotate({ pos: endPos2 }).rotateEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isRotating: true
          }
        );
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      event.srcEvent.preventDefault();
      const { speed = 0.01, smooth = false } = this.scrollZoom === true ? {} : this.scrollZoom;
      const { delta } = event;
      let scale7 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale7 !== 0) {
        scale7 = 1 / scale7;
      }
      const newControllerState = this.controllerState.zoom({ pos, scale: scale7 });
      this.updateViewport(
        newControllerState,
        { ...this._getTransitionProps({ around: pos }), transitionDuration: smooth ? 250 : 1 },
        {
          isZooming: true,
          isPanning: true
        }
      );
      return true;
    }
    _onTriplePanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.rotateStart({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    _onTriplePan(event) {
      if (!this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      const pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      const newControllerState = this.controllerState.rotate({ pos });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onTriplePanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const { inertia } = this;
      if (this.touchRotate && inertia && event.velocityY) {
        const pos = this.getCenter(event);
        const endPos2 = [pos[0], pos[1] += event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({ pos: endPos2 });
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps(),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isRotating: true
          }
        );
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onPinchStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.zoomStart({ pos }).rotateStart({ pos });
      pinchEventWorkaround._startPinchRotation = event.rotation;
      pinchEventWorkaround._lastPinchEvent = event;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, { isDragging: true });
      return true;
    }
    _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      let newControllerState = this.controllerState;
      if (this.touchZoom) {
        const { scale: scale7 } = event;
        const pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({ pos, scale: scale7 });
      }
      if (this.touchRotate) {
        const { rotation } = event;
        newControllerState = newControllerState.rotate({
          deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
        });
      }
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      pinchEventWorkaround._lastPinchEvent = event;
      return true;
    }
    _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const { inertia } = this;
      const { _lastPinchEvent } = pinchEventWorkaround;
      if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
        const pos = this.getCenter(event);
        let newControllerState = this.controllerState.rotateEnd();
        const z2 = Math.log2(event.scale);
        const velocityZ = (z2 - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
        const endScale = Math.pow(2, z2 + velocityZ * inertia / 2);
        newControllerState = newControllerState.zoom({ pos, scale: endScale }).zoomEnd();
        this.updateViewport(
          newControllerState,
          {
            ...this._getTransitionProps({ around: pos }),
            transitionDuration: inertia,
            transitionEasing: INERTIA_EASING
          },
          {
            isDragging: false,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: false
          }
        );
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      pinchEventWorkaround._startPinchRotation = null;
      pinchEventWorkaround._lastPinchEvent = null;
      return true;
    }
    _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const isZoomOut = this.isFunctionKeyPressed(event);
      const newControllerState = this.controllerState.zoom({ pos, scale: isZoomOut ? 0.5 : 2 });
      this.updateViewport(newControllerState, this._getTransitionProps({ around: pos }), {
        isZooming: true,
        isPanning: true
      });
      this.blockEvents(100);
      return true;
    }
    _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      const funcKey = this.isFunctionKeyPressed(event);
      const { zoomSpeed, moveSpeed, rotateSpeedX, rotateSpeedY } = this.keyboard === true ? {} : this.keyboard;
      const { controllerState } = this;
      let newControllerState;
      const interactionState = {};
      switch (event.srcEvent.code) {
        case "Minus":
          newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "Equal":
          newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "ArrowLeft":
          if (funcKey) {
            newControllerState = controllerState.rotateLeft(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowRight":
          if (funcKey) {
            newControllerState = controllerState.rotateRight(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowUp":
          if (funcKey) {
            newControllerState = controllerState.rotateUp(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowDown":
          if (funcKey) {
            newControllerState = controllerState.rotateDown(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        default:
          return false;
      }
      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
    _getTransitionProps(opts) {
      const { transition } = this;
      if (!transition || !transition.transitionInterpolator) {
        return NO_TRANSITION_PROPS;
      }
      return opts ? {
        ...transition,
        transitionInterpolator: new LinearInterpolator({
          ...opts,
          ...transition.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : transition;
    }
  };

  // ../core/src/controllers/view-state.ts
  var ViewState = class {
    constructor(props, state) {
      this._viewportProps = this.applyConstraints(props);
      this._state = state;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  };

  // ../core/src/controllers/map-controller.ts
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var MapState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing = 0,
        pitch = 0,
        altitude = 1.5,
        position = [0, 0, 0],
        maxZoom = 20,
        minZoom = 0,
        maxPitch = 60,
        minPitch = 0,
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom,
        normalize: normalize6 = true
      } = options;
      assert9(Number.isFinite(longitude));
      assert9(Number.isFinite(latitude));
      assert9(Number.isFinite(zoom));
      super(
        {
          width,
          height,
          latitude,
          longitude,
          zoom,
          bearing,
          pitch,
          altitude,
          maxZoom,
          minZoom,
          maxPitch,
          minPitch,
          normalize: normalize6,
          position
        },
        {
          startPanLngLat,
          startZoomLngLat,
          startRotatePos,
          startBearing,
          startPitch,
          startZoom
        }
      );
      this.makeViewport = options.makeViewport;
    }
    panStart({ pos }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
    pan({ pos, startPos }) {
      const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanLngLat, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startBearing, startPitch } = this.getState();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart({ pos }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale7
    }) {
      let { startZoom, startZoomLngLat } = this.getState();
      if (!startZoomLngLat) {
        startZoom = this.getViewportProps().zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomLngLat) {
        return this;
      }
      const { maxZoom, minZoom } = this.getViewportProps();
      let zoom = startZoom + Math.log2(scale7);
      zoom = clamp(zoom, minZoom, maxZoom);
      const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom });
      return this._getUpdatedState({
        zoom,
        ...zoomedViewport.panByPosition(startZoomLngLat, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
      return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
      return this._panFromCenter([speed, 0]);
    }
    moveRight(speed = 100) {
      return this._panFromCenter([-speed, 0]);
    }
    moveUp(speed = 100) {
      return this._panFromCenter([0, speed]);
    }
    moveDown(speed = 100) {
      return this._panFromCenter([0, -speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { bearing, longitude } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const { maxPitch, minPitch, pitch } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      const { normalize: normalize6 = true } = props;
      if (normalize6) {
        Object.assign(props, normalizeViewportProps(props));
      }
      return props;
    }
    _zoomFromCenter(scale7) {
      const { width, height } = this.getViewportProps();
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale7
      });
    }
    _panFromCenter(offset) {
      const { width, height } = this.getViewportProps();
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
      const deltaX = pos[0] - startPos[0];
      const deltaY = pos[1] - startPos[1];
      const centerY = pos[1];
      const startY = startPos[1];
      const { width, height } = this.getViewportProps();
      const deltaScaleX = deltaX / width;
      let deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = clamp(deltaScaleY, -1, 1);
      const { minPitch, maxPitch } = this.getViewportProps();
      const bearing = startBearing + 180 * deltaScaleX;
      let pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  };
  var MapController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = MapState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
            required: ["longitude", "latitude", "zoom"]
          }
        })
      };
      this.dragMode = "pan";
    }
    setProps(props) {
      props.position = props.position || [0, 0, 0];
      const oldProps = this.props;
      super.setProps(props);
      const dimensionChanged = !oldProps || oldProps.height !== props.height;
      if (dimensionChanged) {
        this.updateViewport(
          new this.ControllerState({
            makeViewport: this.makeViewport,
            ...props,
            ...this.state
          })
        );
      }
    }
  };

  // ../core/src/views/map-view.ts
  var MapView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    get ViewportType() {
      return WebMercatorViewport2;
    }
    get ControllerType() {
      return MapController;
    }
  };
  MapView.displayName = "MapView";

  // ../core/src/lib/effect-manager.ts
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  function compareEffects(e1, e22) {
    const o1 = e1.order ?? Infinity;
    const o22 = e22.order ?? Infinity;
    return o1 - o22;
  }
  var EffectManager = class {
    constructor(context) {
      this._resolvedEffects = [];
      this._defaultEffects = [];
      this.effects = [];
      this._context = context;
      this._needsRedraw = "Initial render";
      this._setEffects([]);
    }
    addDefaultEffect(effect) {
      const defaultEffects = this._defaultEffects;
      if (!defaultEffects.find((e3) => e3.id === effect.id)) {
        const index2 = defaultEffects.findIndex((e3) => compareEffects(e3, effect) > 0);
        if (index2 < 0) {
          defaultEffects.push(effect);
        } else {
          defaultEffects.splice(index2, 0, effect);
        }
        effect.setup(this._context);
        this._setEffects(this.effects);
      }
    }
    setProps(props) {
      if ("effects" in props) {
        if (!deepEqual2(props.effects, this.effects, 1)) {
          this._setEffects(props.effects);
        }
      }
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(effects) {
      const oldEffectsMap = {};
      for (const effect of this.effects) {
        oldEffectsMap[effect.id] = effect;
      }
      const nextEffects = [];
      for (const effect of effects) {
        const oldEffect = oldEffectsMap[effect.id];
        let effectToAdd = effect;
        if (oldEffect && oldEffect !== effect) {
          if (oldEffect.setProps) {
            oldEffect.setProps(effect.props);
            effectToAdd = oldEffect;
          } else {
            oldEffect.cleanup(this._context);
          }
        } else if (!oldEffect) {
          effect.setup(this._context);
        }
        nextEffects.push(effectToAdd);
        delete oldEffectsMap[effect.id];
      }
      for (const removedEffectId in oldEffectsMap) {
        oldEffectsMap[removedEffectId].cleanup(this._context);
      }
      this.effects = nextEffects;
      this._resolvedEffects = nextEffects.concat(this._defaultEffects);
      if (!effects.some((effect) => effect instanceof LightingEffect)) {
        this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
      this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const effect of this._resolvedEffects) {
        effect.cleanup(this._context);
      }
      this.effects.length = 0;
      this._resolvedEffects.length = 0;
      this._defaultEffects.length = 0;
    }
  };

  // ../core/src/passes/draw-layers-pass.ts
  var DrawLayersPass = class extends LayersPass {
    shouldDrawLayer(layer) {
      const { operation } = layer.props;
      return operation.includes("draw") || operation.includes("terrain");
    }
  };

  // ../core/src/lib/deck-renderer.ts
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = class {
    constructor(device) {
      this.device = device;
      this.gl = device.gl;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(device);
      this.pickLayersPass = new PickLayersPass(device);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
    }
    setProps(props) {
      if (this.layerFilter !== props.layerFilter) {
        this.layerFilter = props.layerFilter;
        this._needsRedraw = "layerFilter changed";
      }
      if (this.drawPickingColors !== props.drawPickingColors) {
        this.drawPickingColors = props.drawPickingColors;
        this._needsRedraw = "drawPickingColors changed";
      }
    }
    renderLayers(opts) {
      if (!opts.viewports.length) {
        return;
      }
      const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      const renderOpts = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...opts
      };
      if (renderOpts.effects) {
        this._preRender(renderOpts.effects, renderOpts);
      }
      const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
      if (this.lastPostProcessEffect) {
        renderOpts.clearColor = [0, 0, 0, 0];
        renderOpts.clearCanvas = true;
      }
      const renderStats = layerPass.render({ ...renderOpts, target: outputBuffer });
      if (renderOpts.effects) {
        this._postRender(renderOpts.effects, renderOpts);
      }
      this.renderCount++;
      debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    finalize() {
      const { renderBuffers } = this;
      for (const buffer of renderBuffers) {
        buffer.delete();
      }
      renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
      this.lastPostProcessEffect = null;
      opts.preRenderStats = opts.preRenderStats || {};
      for (const effect of effects) {
        opts.preRenderStats[effect.id] = effect.preRender(opts);
        if (effect.postRender) {
          this.lastPostProcessEffect = effect.id;
        }
      }
      if (this.lastPostProcessEffect) {
        this._resizeRenderBuffers();
      }
    }
    _resizeRenderBuffers() {
      const { renderBuffers } = this;
      const size = this.device.canvasContext.getDrawingBufferSize();
      if (renderBuffers.length === 0) {
        [0, 1].map((i5) => {
          const texture = this.device.createTexture({
            sampler: { minFilter: "linear", magFilter: "linear" }
          });
          renderBuffers.push(
            this.device.createFramebuffer({
              id: `deck-renderbuffer-${i5}`,
              colorAttachments: [texture]
            })
          );
        });
      }
      for (const buffer of renderBuffers) {
        buffer.resize(size);
      }
    }
    _postRender(effects, opts) {
      const { renderBuffers } = this;
      const params = {
        ...opts,
        inputBuffer: renderBuffers[0],
        swapBuffer: renderBuffers[1]
      };
      for (const effect of effects) {
        if (effect.postRender) {
          params.target = effect.id === this.lastPostProcessEffect ? opts.target : void 0;
          const buffer = effect.postRender(params);
          params.inputBuffer = buffer;
          params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
      }
    }
  };

  // ../core/src/lib/picking/query-object.ts
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function getClosestObject({
    pickedColors,
    decodePickingColor,
    deviceX,
    deviceY,
    deviceRadius,
    deviceRect
  }) {
    const { x: x3, y: y3, width, height } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i5 = 0;
    for (let row = 0; row < height; row++) {
      const dy = row + y3 - deviceY;
      const dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i5 += 4 * width;
      } else {
        for (let col = 0; col < width; col++) {
          const pickedLayerIndex = pickedColors[i5 + 3] - 1;
          if (pickedLayerIndex >= 0) {
            const dx = col + x3 - deviceX;
            const d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i5;
            }
          }
          i5 += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);
      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width);
        const dx = closestPixelIndex / 4 - dy * width;
        return {
          ...pickedObject,
          pickedColor,
          pickedX: x3 + dx,
          pickedY: y3 + dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects({
    pickedColors,
    decodePickingColor
  }) {
    const uniqueColors = /* @__PURE__ */ new Map();
    if (pickedColors) {
      for (let i5 = 0; i5 < pickedColors.length; i5 += 4) {
        const pickedLayerIndex = pickedColors[i5 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const pickedColor = pickedColors.slice(i5, i5 + 4);
          const colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            const pickedObject = decodePickingColor(pickedColor);
            if (pickedObject) {
              uniqueColors.set(colorKey, {
                ...pickedObject,
                color: pickedColor
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // ../core/src/lib/picking/pick-info.ts
  function getEmptyPickingInfo({
    pickInfo,
    viewports,
    pixelRatio,
    x: x3,
    y: y3,
    z: z2
  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) {
      pickedViewport = getViewportFromCoordinates(pickInfo?.pickedViewports || viewports, { x: x3, y: y3 });
    }
    let coordinate;
    if (pickedViewport) {
      const point = [x3 - pickedViewport.x, y3 - pickedViewport.y];
      if (z2 !== void 0) {
        point[2] = z2;
      }
      coordinate = pickedViewport.unproject(point);
    }
    return {
      color: null,
      layer: null,
      viewport: pickedViewport,
      index: -1,
      picked: false,
      x: x3,
      y: y3,
      pixel: [x3, y3],
      coordinate,
      devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
      pixelRatio
    };
  }
  function processPickInfo(opts) {
    const { pickInfo, lastPickedInfo, mode, layers } = opts;
    const { pickedColor, pickedLayer, pickedObjectIndex } = pickInfo;
    const affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      const lastPickedPixelIndex = lastPickedInfo.index;
      const lastPickedLayerId = lastPickedInfo.layerId;
      const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    const baseInfo = getEmptyPickingInfo(opts);
    const infos = /* @__PURE__ */ new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer) => {
      let info = { ...baseInfo };
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({ layer, info, mode });
      const rootLayer = info.layer;
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      infos.set(rootLayer.id, info);
      if (mode === "hover") {
        rootLayer.updateAutoHighlight(info);
      }
    });
    return infos;
  }
  function getLayerPickingInfo({
    layer,
    info,
    mode
  }) {
    while (layer && info) {
      const sourceLayer = info.layer || null;
      info.sourceLayer = sourceLayer;
      info.layer = layer;
      info = layer.getPickingInfo({ info, mode, sourceLayer });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel) {
    for (let i5 = viewports.length - 1; i5 >= 0; i5--) {
      const viewport = viewports[i5];
      if (viewport.containsPixel(pixel)) {
        return viewport;
      }
    }
    return viewports[0];
  }

  // ../core/src/lib/deck-picker.ts
  var DeckPicker = class {
    constructor(device) {
      this._pickable = true;
      this.device = device;
      this.pickLayersPass = new PickLayersPass(device);
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(props) {
      if ("layerFilter" in props) {
        this.layerFilter = props.layerFilter;
      }
      if ("_pickable" in props) {
        this._pickable = props._pickable;
      }
    }
    finalize() {
      if (this.pickingFBO) {
        this.pickingFBO.destroy();
      }
      if (this.depthFBO) {
        this.depthFBO.destroy();
      }
    }
    pickObject(opts) {
      return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
      return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({ x: x3, y: y3, layers, viewports }, lastPickedInfo = this.lastPickedInfo.info) {
      const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
      const layer = lastPickedLayerId ? layers.find((l3) => l3.id === lastPickedLayerId) : null;
      const viewport = lastPickedViewportId && viewports.find((v2) => v2.id === lastPickedViewportId) || viewports[0];
      const coordinate = viewport && viewport.unproject([x3 - viewport.x, y3 - viewport.y]);
      const info = {
        x: x3,
        y: y3,
        viewport,
        coordinate,
        layer
      };
      return { ...lastPickedInfo, ...info };
    }
    _resizeBuffer() {
      if (!this.pickingFBO) {
        this.pickingFBO = this.device.createFramebuffer({
          colorAttachments: ["rgba8unorm"],
          depthStencilAttachment: "depth16unorm"
        });
        if (this.device.isTextureFormatRenderable("rgba32float")) {
          const depthFBO = this.device.createFramebuffer({
            colorAttachments: ["rgba32float"],
            depthStencilAttachment: "depth16unorm"
          });
          this.depthFBO = depthFBO;
        }
      }
      const gl = this.device.gl;
      this.pickingFBO?.resize({ width: gl.canvas.width, height: gl.canvas.height });
      this.depthFBO?.resize({ width: gl.canvas.width, height: gl.canvas.height });
    }
    _getPickable(layers) {
      if (this._pickable === false) {
        return null;
      }
      const pickableLayers = layers.filter(
        (layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite
      );
      return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({
      layers,
      views,
      viewports,
      x: x3,
      y: y3,
      radius = 0,
      depth = 1,
      mode = "query",
      unproject3D,
      onViewportActive,
      effects
    }) {
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers || viewports.length === 0) {
        return {
          result: [],
          emptyInfo: getEmptyPickingInfo({ viewports, x: x3, y: y3, pixelRatio })
        };
      }
      this._resizeBuffer();
      const devicePixelRange = this.device.canvasContext.cssToDevicePixels([x3, y3], true);
      const devicePixel = [
        devicePixelRange.x + Math.floor(devicePixelRange.width / 2),
        devicePixelRange.y + Math.floor(devicePixelRange.height / 2)
      ];
      const deviceRadius = Math.round(radius * pixelRatio);
      const { width, height } = this.pickingFBO;
      const deviceRect = this._getPickingRect({
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      const cullRect = {
        x: x3 - radius,
        y: y3 - radius,
        width: radius * 2 + 1,
        height: radius * 2 + 1
      };
      let infos;
      const result = [];
      const affectedLayers = /* @__PURE__ */ new Set();
      for (let i5 = 0; i5 < depth; i5++) {
        let pickInfo;
        if (deviceRect) {
          const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            cullRect,
            effects,
            pass: `picking:${mode}`
          });
          pickInfo = getClosestObject({
            ...pickedResult,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
        } else {
          pickInfo = {
            pickedColor: null,
            pickedObjectIndex: -1
          };
        }
        let z2;
        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
          const { pickedColors: pickedColors2 } = this._drawAndSample(
            {
              layers: [pickInfo.pickedLayer],
              views,
              viewports,
              onViewportActive,
              deviceRect: {
                x: pickInfo.pickedX,
                y: pickInfo.pickedY,
                width: 1,
                height: 1
              },
              cullRect,
              effects,
              pass: `picking:${mode}:z`
            },
            true
          );
          if (pickedColors2[3]) {
            z2 = pickedColors2[0];
          }
        }
        if (pickInfo.pickedLayer && i5 + 1 < depth) {
          affectedLayers.add(pickInfo.pickedLayer);
          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
        }
        infos = processPickInfo({
          pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode,
          layers: pickableLayers,
          viewports,
          x: x3,
          y: y3,
          z: z2,
          pixelRatio
        });
        for (const info of infos.values()) {
          if (info.layer) {
            result.push(info);
          }
        }
        if (!pickInfo.pickedColor) {
          break;
        }
      }
      for (const layer of affectedLayers) {
        layer.restorePickingColors();
      }
      return { result, emptyInfo: infos.get(null) };
    }
    _pickVisibleObjects({
      layers,
      views,
      viewports,
      x: x3,
      y: y3,
      width = 1,
      height = 1,
      mode = "query",
      maxObjects = null,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers || viewports.length === 0) {
        return [];
      }
      this._resizeBuffer();
      const pixelRatio = this.device.canvasContext.cssToDeviceRatio();
      const leftTop = this.device.canvasContext.cssToDevicePixels([x3, y3], true);
      const deviceLeft = leftTop.x;
      const deviceTop = leftTop.y + leftTop.height;
      const rightBottom = this.device.canvasContext.cssToDevicePixels([x3 + width, y3 + height], true);
      const deviceRight = rightBottom.x + rightBottom.width;
      const deviceBottom = rightBottom.y;
      const deviceRect = {
        x: deviceLeft,
        y: deviceBottom,
        width: deviceRight - deviceLeft,
        height: deviceTop - deviceBottom
      };
      const pickedResult = this._drawAndSample({
        layers: pickableLayers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect: { x: x3, y: y3, width, height },
        effects,
        pass: `picking:${mode}`
      });
      const pickInfos = getUniqueObjects(pickedResult);
      const uniquePickedObjects = /* @__PURE__ */ new Map();
      const uniqueInfos = [];
      const limitMaxObjects = Number.isFinite(maxObjects);
      for (let i5 = 0; i5 < pickInfos.length; i5++) {
        if (limitMaxObjects && uniqueInfos.length >= maxObjects) {
          break;
        }
        const pickInfo = pickInfos[i5];
        let info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x3,
          y: y3,
          pixelRatio
        };
        info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info, mode });
        const pickedLayerId = info.layer.id;
        if (!uniquePickedObjects.has(pickedLayerId)) {
          uniquePickedObjects.set(pickedLayerId, /* @__PURE__ */ new Set());
        }
        const uniqueObjectsInLayer = uniquePickedObjects.get(pickedLayerId);
        const pickedObjectKey = info.object ?? info.index;
        if (!uniqueObjectsInLayer.has(pickedObjectKey)) {
          uniqueObjectsInLayer.add(pickedObjectKey);
          uniqueInfos.push(info);
        }
      }
      return uniqueInfos;
    }
    _drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect,
      effects,
      pass
    }, pickZ = false) {
      const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
      const opts = {
        layers,
        layerFilter: this.layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect,
        cullRect,
        effects,
        pass,
        pickZ,
        preRenderStats: {}
      };
      for (const effect of effects) {
        if (effect.useInPicking) {
          opts.preRenderStats[effect.id] = effect.preRender(opts);
        }
      }
      const { decodePickingColor } = this.pickLayersPass.render(opts);
      const { x: x3, y: y3, width, height } = deviceRect;
      const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
      this.device.readPixelsToArrayWebGL(pickingFBO, {
        sourceX: x3,
        sourceY: y3,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return { pickedColors, decodePickingColor };
    }
    _getPickingRect({
      deviceX,
      deviceY,
      deviceRadius,
      deviceWidth,
      deviceHeight
    }) {
      const x3 = Math.max(0, deviceX - deviceRadius);
      const y3 = Math.max(0, deviceY - deviceRadius);
      const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x3;
      const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y3;
      if (width <= 0 || height <= 0) {
        return null;
      }
      return { x: x3, y: y3, width, height };
    }
  };

  // ../core/src/lib/widget-manager.ts
  var PLACEMENTS = {
    "top-left": { top: 0, left: 0 },
    "top-right": { top: 0, right: 0 },
    "bottom-left": { bottom: 0, left: 0 },
    "bottom-right": { bottom: 0, right: 0 },
    fill: { top: 0, left: 0, bottom: 0, right: 0 }
  };
  var DEFAULT_PLACEMENT = "top-left";
  var ROOT_CONTAINER_ID = "__root";
  var WidgetManager = class {
    constructor({ deck, parentElement }) {
      this.defaultWidgets = [];
      this.widgets = [];
      this.resolvedWidgets = [];
      this.containers = {};
      this.lastViewports = {};
      this.deck = deck;
      this.parentElement = parentElement;
    }
    getWidgets() {
      return this.resolvedWidgets;
    }
    setProps(props) {
      if (props.widgets && !deepEqual2(props.widgets, this.widgets, 1)) {
        this._setWidgets(props.widgets);
      }
    }
    finalize() {
      for (const widget of this.getWidgets()) {
        this._remove(widget);
      }
      this.defaultWidgets.length = 0;
      this.resolvedWidgets.length = 0;
      for (const id in this.containers) {
        this.containers[id].remove();
      }
    }
    addDefault(widget) {
      if (!this.defaultWidgets.find((w2) => w2.id === widget.id)) {
        this._add(widget);
        this.defaultWidgets.push(widget);
        this._setWidgets(this.widgets);
      }
    }
    _setWidgets(nextWidgets) {
      const oldWidgetMap = {};
      for (const widget of this.resolvedWidgets) {
        oldWidgetMap[widget.id] = widget;
      }
      this.resolvedWidgets.length = 0;
      for (const widget of this.defaultWidgets) {
        oldWidgetMap[widget.id] = null;
        this.resolvedWidgets.push(widget);
      }
      for (let widget of nextWidgets) {
        const oldWidget = oldWidgetMap[widget.id];
        if (!oldWidget) {
          this._add(widget);
        } else if (oldWidget.viewId !== widget.viewId || oldWidget.placement !== widget.placement) {
          this._remove(oldWidget);
          this._add(widget);
        } else if (widget !== oldWidget) {
          oldWidget.setProps(widget.props);
          widget = oldWidget;
        }
        oldWidgetMap[widget.id] = null;
        this.resolvedWidgets.push(widget);
      }
      for (const id in oldWidgetMap) {
        const oldWidget = oldWidgetMap[id];
        if (oldWidget) {
          this._remove(oldWidget);
        }
      }
      this.widgets = nextWidgets;
    }
    _add(widget) {
      const { viewId = null, placement = DEFAULT_PLACEMENT } = widget;
      const element = widget.onAdd({ deck: this.deck, viewId });
      if (element) {
        this._getContainer(viewId, placement).append(element);
      }
      widget._element = element;
    }
    _remove(widget) {
      widget.onRemove();
      if (widget._element) {
        widget._element.remove();
      }
      widget._element = void 0;
    }
    _getContainer(viewId, placement) {
      const containerId = viewId || ROOT_CONTAINER_ID;
      let viewContainer = this.containers[containerId];
      if (!viewContainer) {
        viewContainer = document.createElement("div");
        viewContainer.style.pointerEvents = "none";
        viewContainer.style.position = "absolute";
        viewContainer.style.overflow = "hidden";
        this.parentElement?.append(viewContainer);
        this.containers[containerId] = viewContainer;
      }
      let container = viewContainer.querySelector(`.${placement}`);
      if (!container) {
        container = document.createElement("div");
        container.className = placement;
        container.style.position = "absolute";
        Object.assign(container.style, PLACEMENTS[placement]);
        viewContainer.append(container);
      }
      return container;
    }
    _updateContainers() {
      const canvasWidth = this.deck.width;
      const canvasHeight = this.deck.height;
      for (const id in this.containers) {
        const viewport = this.lastViewports[id] || null;
        const visible = id === ROOT_CONTAINER_ID || viewport;
        const container = this.containers[id];
        if (visible) {
          container.style.display = "block";
          container.style.left = `${viewport ? viewport.x : 0}px`;
          container.style.top = `${viewport ? viewport.y : 0}px`;
          container.style.width = `${viewport ? viewport.width : canvasWidth}px`;
          container.style.height = `${viewport ? viewport.height : canvasHeight}px`;
        } else {
          container.style.display = "none";
        }
      }
    }
    onRedraw({ viewports, layers }) {
      const viewportsById = viewports.reduce((acc, v2) => {
        acc[v2.id] = v2;
        return acc;
      }, {});
      const { lastViewports } = this;
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (viewId) {
          const viewport = viewportsById[viewId];
          if (viewport) {
            if (widget.onViewportChange && !viewport.equals(lastViewports[viewId])) {
              widget.onViewportChange(viewport);
            }
            widget.onRedraw?.({ viewports: [viewport], layers });
          }
        } else {
          if (widget.onViewportChange) {
            for (const viewport of viewports) {
              if (!viewport.equals(lastViewports[viewport.id])) {
                widget.onViewportChange(viewport);
              }
            }
          }
          widget.onRedraw?.({ viewports, layers });
        }
      }
      this.lastViewports = viewportsById;
      this._updateContainers();
    }
    onHover(info, event) {
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (!viewId || viewId === info.viewport?.id) {
          widget.onHover?.(info, event);
        }
      }
    }
    onEvent(info, event) {
      const eventOptions = EVENTS[event.type];
      if (!eventOptions) {
        return;
      }
      for (const widget of this.getWidgets()) {
        const { viewId } = widget;
        if (!viewId || viewId === info.viewport?.id) {
          widget[eventOptions.handler]?.(info, event);
        }
      }
    }
  };

  // ../core/src/lib/tooltip.ts
  var defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  var Tooltip = class {
    constructor() {
      this.id = "default-tooltip";
      this.placement = "fill";
      this.props = {};
      this.isVisible = false;
    }
    onAdd({ deck }) {
      const el = document.createElement("div");
      el.className = "deck-tooltip";
      Object.assign(el.style, defaultStyle);
      this.deck = deck;
      this.element = el;
      return el;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    setProps() {
    }
    onViewportChange(viewport) {
      if (this.isVisible && viewport.id === this.lastViewport?.id && viewport !== this.lastViewport) {
        this.setTooltip(null);
      }
    }
    onHover(info) {
      const { deck } = this;
      const getTooltip = deck && deck.props.getTooltip;
      if (!getTooltip) {
        return;
      }
      const displayInfo = getTooltip(info);
      this.lastViewport = info.viewport;
      this.setTooltip(displayInfo, info.x, info.y);
    }
    setTooltip(displayInfo, x3, y3) {
      const el = this.element;
      if (!el) {
        return;
      }
      if (typeof displayInfo === "string") {
        el.innerText = displayInfo;
      } else if (!displayInfo) {
        this.isVisible = false;
        el.style.display = "none";
        return;
      } else {
        if (displayInfo.text) {
          el.innerText = displayInfo.text;
        }
        if (displayInfo.html) {
          el.innerHTML = displayInfo.html;
        }
        if (displayInfo.className) {
          el.className = displayInfo.className;
        }
      }
      this.isVisible = true;
      el.style.display = "block";
      el.style.transform = `translate(${x3}px, ${y3}px)`;
      if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
        Object.assign(el.style, displayInfo.style);
      }
    }
  };

  // ../../node_modules/@luma.gl/constants/dist/webgl-constants.js
  var GLEnum;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GLEnum4[GLEnum4["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GLEnum4[GLEnum4["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    GLEnum4[GLEnum4["POINTS"] = 0] = "POINTS";
    GLEnum4[GLEnum4["LINES"] = 1] = "LINES";
    GLEnum4[GLEnum4["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum4[GLEnum4["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum4[GLEnum4["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum4[GLEnum4["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum4[GLEnum4["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    GLEnum4[GLEnum4["ZERO"] = 0] = "ZERO";
    GLEnum4[GLEnum4["ONE"] = 1] = "ONE";
    GLEnum4[GLEnum4["SRC_COLOR"] = 768] = "SRC_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GLEnum4[GLEnum4["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum4[GLEnum4["DST_ALPHA"] = 772] = "DST_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GLEnum4[GLEnum4["DST_COLOR"] = 774] = "DST_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GLEnum4[GLEnum4["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GLEnum4[GLEnum4["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    GLEnum4[GLEnum4["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    GLEnum4[GLEnum4["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    GLEnum4[GLEnum4["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum4[GLEnum4["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum4[GLEnum4["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    GLEnum4[GLEnum4["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GLEnum4[GLEnum4["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GLEnum4[GLEnum4["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GLEnum4[GLEnum4["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    GLEnum4[GLEnum4["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    GLEnum4[GLEnum4["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    GLEnum4[GLEnum4["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    GLEnum4[GLEnum4["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    GLEnum4[GLEnum4["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    GLEnum4[GLEnum4["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    GLEnum4[GLEnum4["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    GLEnum4[GLEnum4["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    GLEnum4[GLEnum4["FRONT_FACE"] = 2886] = "FRONT_FACE";
    GLEnum4[GLEnum4["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    GLEnum4[GLEnum4["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    GLEnum4[GLEnum4["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    GLEnum4[GLEnum4["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    GLEnum4[GLEnum4["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    GLEnum4[GLEnum4["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    GLEnum4[GLEnum4["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    GLEnum4[GLEnum4["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    GLEnum4[GLEnum4["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    GLEnum4[GLEnum4["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum4[GLEnum4["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum4[GLEnum4["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum4[GLEnum4["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum4[GLEnum4["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum4[GLEnum4["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum4[GLEnum4["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum4[GLEnum4["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum4[GLEnum4["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum4[GLEnum4["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    GLEnum4[GLEnum4["VIEWPORT"] = 2978] = "VIEWPORT";
    GLEnum4[GLEnum4["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum4[GLEnum4["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum4[GLEnum4["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum4[GLEnum4["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum4[GLEnum4["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum4[GLEnum4["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum4[GLEnum4["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum4[GLEnum4["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum4[GLEnum4["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum4[GLEnum4["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum4[GLEnum4["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum4[GLEnum4["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum4[GLEnum4["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum4[GLEnum4["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum4[GLEnum4["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum4[GLEnum4["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum4[GLEnum4["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum4[GLEnum4["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum4[GLEnum4["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum4[GLEnum4["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum4[GLEnum4["VENDOR"] = 7936] = "VENDOR";
    GLEnum4[GLEnum4["RENDERER"] = 7937] = "RENDERER";
    GLEnum4[GLEnum4["VERSION"] = 7938] = "VERSION";
    GLEnum4[GLEnum4["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum4[GLEnum4["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum4[GLEnum4["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    GLEnum4[GLEnum4["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    GLEnum4[GLEnum4["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    GLEnum4[GLEnum4["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    GLEnum4[GLEnum4["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    GLEnum4[GLEnum4["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    GLEnum4[GLEnum4["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    GLEnum4[GLEnum4["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    GLEnum4[GLEnum4["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    GLEnum4[GLEnum4["CULL_FACE"] = 2884] = "CULL_FACE";
    GLEnum4[GLEnum4["FRONT"] = 1028] = "FRONT";
    GLEnum4[GLEnum4["BACK"] = 1029] = "BACK";
    GLEnum4[GLEnum4["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    GLEnum4[GLEnum4["BLEND"] = 3042] = "BLEND";
    GLEnum4[GLEnum4["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    GLEnum4[GLEnum4["DITHER"] = 3024] = "DITHER";
    GLEnum4[GLEnum4["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    GLEnum4[GLEnum4["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    GLEnum4[GLEnum4["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    GLEnum4[GLEnum4["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    GLEnum4[GLEnum4["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    GLEnum4[GLEnum4["NO_ERROR"] = 0] = "NO_ERROR";
    GLEnum4[GLEnum4["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GLEnum4[GLEnum4["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GLEnum4[GLEnum4["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GLEnum4[GLEnum4["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GLEnum4[GLEnum4["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    GLEnum4[GLEnum4["CW"] = 2304] = "CW";
    GLEnum4[GLEnum4["CCW"] = 2305] = "CCW";
    GLEnum4[GLEnum4["DONT_CARE"] = 4352] = "DONT_CARE";
    GLEnum4[GLEnum4["FASTEST"] = 4353] = "FASTEST";
    GLEnum4[GLEnum4["NICEST"] = 4354] = "NICEST";
    GLEnum4[GLEnum4["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    GLEnum4[GLEnum4["BYTE"] = 5120] = "BYTE";
    GLEnum4[GLEnum4["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum4[GLEnum4["SHORT"] = 5122] = "SHORT";
    GLEnum4[GLEnum4["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum4[GLEnum4["INT"] = 5124] = "INT";
    GLEnum4[GLEnum4["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum4[GLEnum4["FLOAT"] = 5126] = "FLOAT";
    GLEnum4[GLEnum4["DOUBLE"] = 5130] = "DOUBLE";
    GLEnum4[GLEnum4["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum4[GLEnum4["ALPHA"] = 6406] = "ALPHA";
    GLEnum4[GLEnum4["RGB"] = 6407] = "RGB";
    GLEnum4[GLEnum4["RGBA"] = 6408] = "RGBA";
    GLEnum4[GLEnum4["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum4[GLEnum4["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum4[GLEnum4["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GLEnum4[GLEnum4["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    GLEnum4[GLEnum4["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    GLEnum4[GLEnum4["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    GLEnum4[GLEnum4["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    GLEnum4[GLEnum4["LINK_STATUS"] = 35714] = "LINK_STATUS";
    GLEnum4[GLEnum4["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    GLEnum4[GLEnum4["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    GLEnum4[GLEnum4["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    GLEnum4[GLEnum4["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    GLEnum4[GLEnum4["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum4[GLEnum4["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum4[GLEnum4["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum4[GLEnum4["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum4[GLEnum4["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum4[GLEnum4["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    GLEnum4[GLEnum4["NEVER"] = 512] = "NEVER";
    GLEnum4[GLEnum4["LESS"] = 513] = "LESS";
    GLEnum4[GLEnum4["EQUAL"] = 514] = "EQUAL";
    GLEnum4[GLEnum4["LEQUAL"] = 515] = "LEQUAL";
    GLEnum4[GLEnum4["GREATER"] = 516] = "GREATER";
    GLEnum4[GLEnum4["NOTEQUAL"] = 517] = "NOTEQUAL";
    GLEnum4[GLEnum4["GEQUAL"] = 518] = "GEQUAL";
    GLEnum4[GLEnum4["ALWAYS"] = 519] = "ALWAYS";
    GLEnum4[GLEnum4["KEEP"] = 7680] = "KEEP";
    GLEnum4[GLEnum4["REPLACE"] = 7681] = "REPLACE";
    GLEnum4[GLEnum4["INCR"] = 7682] = "INCR";
    GLEnum4[GLEnum4["DECR"] = 7683] = "DECR";
    GLEnum4[GLEnum4["INVERT"] = 5386] = "INVERT";
    GLEnum4[GLEnum4["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum4[GLEnum4["DECR_WRAP"] = 34056] = "DECR_WRAP";
    GLEnum4[GLEnum4["NEAREST"] = 9728] = "NEAREST";
    GLEnum4[GLEnum4["LINEAR"] = 9729] = "LINEAR";
    GLEnum4[GLEnum4["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    GLEnum4[GLEnum4["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    GLEnum4[GLEnum4["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum4[GLEnum4["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    GLEnum4[GLEnum4["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum4[GLEnum4["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum4[GLEnum4["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum4[GLEnum4["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum4[GLEnum4["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum4[GLEnum4["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    GLEnum4[GLEnum4["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum4[GLEnum4["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum4[GLEnum4["REPEAT"] = 10497] = "REPEAT";
    GLEnum4[GLEnum4["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum4[GLEnum4["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    GLEnum4[GLEnum4["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum4[GLEnum4["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    GLEnum4[GLEnum4["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum4[GLEnum4["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum4[GLEnum4["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum4[GLEnum4["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum4[GLEnum4["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum4[GLEnum4["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum4[GLEnum4["BOOL"] = 35670] = "BOOL";
    GLEnum4[GLEnum4["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum4[GLEnum4["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum4[GLEnum4["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum4[GLEnum4["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum4[GLEnum4["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum4[GLEnum4["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum4[GLEnum4["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum4[GLEnum4["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    GLEnum4[GLEnum4["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum4[GLEnum4["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum4[GLEnum4["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum4[GLEnum4["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum4[GLEnum4["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum4[GLEnum4["HIGH_INT"] = 36341] = "HIGH_INT";
    GLEnum4[GLEnum4["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum4[GLEnum4["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum4[GLEnum4["RGBA4"] = 32854] = "RGBA4";
    GLEnum4[GLEnum4["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum4[GLEnum4["RGB565"] = 36194] = "RGB565";
    GLEnum4[GLEnum4["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum4[GLEnum4["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum4[GLEnum4["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum4[GLEnum4["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum4[GLEnum4["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum4[GLEnum4["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum4[GLEnum4["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum4[GLEnum4["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum4[GLEnum4["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum4[GLEnum4["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum4[GLEnum4["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum4[GLEnum4["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum4[GLEnum4["NONE"] = 0] = "NONE";
    GLEnum4[GLEnum4["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum4[GLEnum4["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum4[GLEnum4["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum4[GLEnum4["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum4[GLEnum4["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum4[GLEnum4["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum4[GLEnum4["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    GLEnum4[GLEnum4["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum4[GLEnum4["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum4[GLEnum4["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    GLEnum4[GLEnum4["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum4[GLEnum4["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum4[GLEnum4["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum4[GLEnum4["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum4[GLEnum4["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum4[GLEnum4["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum4[GLEnum4["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum4[GLEnum4["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum4[GLEnum4["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum4[GLEnum4["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum4[GLEnum4["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum4[GLEnum4["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
    GLEnum4[GLEnum4["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum4[GLEnum4["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum4[GLEnum4["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum4[GLEnum4["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum4[GLEnum4["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum4[GLEnum4["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum4[GLEnum4["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum4[GLEnum4["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum4[GLEnum4["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum4[GLEnum4["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum4[GLEnum4["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    GLEnum4[GLEnum4["RED"] = 6403] = "RED";
    GLEnum4[GLEnum4["RGB8"] = 32849] = "RGB8";
    GLEnum4[GLEnum4["RGBA8"] = 32856] = "RGBA8";
    GLEnum4[GLEnum4["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum4[GLEnum4["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    GLEnum4[GLEnum4["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum4[GLEnum4["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum4[GLEnum4["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum4[GLEnum4["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum4[GLEnum4["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum4[GLEnum4["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum4[GLEnum4["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum4[GLEnum4["SRGB"] = 35904] = "SRGB";
    GLEnum4[GLEnum4["SRGB8"] = 35905] = "SRGB8";
    GLEnum4[GLEnum4["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum4[GLEnum4["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum4[GLEnum4["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum4[GLEnum4["RGB32F"] = 34837] = "RGB32F";
    GLEnum4[GLEnum4["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum4[GLEnum4["RGB16F"] = 34843] = "RGB16F";
    GLEnum4[GLEnum4["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum4[GLEnum4["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum4[GLEnum4["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum4[GLEnum4["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum4[GLEnum4["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum4[GLEnum4["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum4[GLEnum4["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum4[GLEnum4["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum4[GLEnum4["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum4[GLEnum4["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum4[GLEnum4["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum4[GLEnum4["RGB32I"] = 36227] = "RGB32I";
    GLEnum4[GLEnum4["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum4[GLEnum4["RGB16I"] = 36233] = "RGB16I";
    GLEnum4[GLEnum4["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum4[GLEnum4["RGB8I"] = 36239] = "RGB8I";
    GLEnum4[GLEnum4["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum4[GLEnum4["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum4[GLEnum4["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum4[GLEnum4["R8"] = 33321] = "R8";
    GLEnum4[GLEnum4["RG8"] = 33323] = "RG8";
    GLEnum4[GLEnum4["R16F"] = 33325] = "R16F";
    GLEnum4[GLEnum4["R32F"] = 33326] = "R32F";
    GLEnum4[GLEnum4["RG16F"] = 33327] = "RG16F";
    GLEnum4[GLEnum4["RG32F"] = 33328] = "RG32F";
    GLEnum4[GLEnum4["R8I"] = 33329] = "R8I";
    GLEnum4[GLEnum4["R8UI"] = 33330] = "R8UI";
    GLEnum4[GLEnum4["R16I"] = 33331] = "R16I";
    GLEnum4[GLEnum4["R16UI"] = 33332] = "R16UI";
    GLEnum4[GLEnum4["R32I"] = 33333] = "R32I";
    GLEnum4[GLEnum4["R32UI"] = 33334] = "R32UI";
    GLEnum4[GLEnum4["RG8I"] = 33335] = "RG8I";
    GLEnum4[GLEnum4["RG8UI"] = 33336] = "RG8UI";
    GLEnum4[GLEnum4["RG16I"] = 33337] = "RG16I";
    GLEnum4[GLEnum4["RG16UI"] = 33338] = "RG16UI";
    GLEnum4[GLEnum4["RG32I"] = 33339] = "RG32I";
    GLEnum4[GLEnum4["RG32UI"] = 33340] = "RG32UI";
    GLEnum4[GLEnum4["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum4[GLEnum4["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum4[GLEnum4["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum4[GLEnum4["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum4[GLEnum4["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    GLEnum4[GLEnum4["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum4[GLEnum4["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    GLEnum4[GLEnum4["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum4[GLEnum4["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum4[GLEnum4["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum4[GLEnum4["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum4[GLEnum4["RG"] = 33319] = "RG";
    GLEnum4[GLEnum4["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum4[GLEnum4["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    GLEnum4[GLEnum4["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    GLEnum4[GLEnum4["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    GLEnum4[GLEnum4["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    GLEnum4[GLEnum4["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    GLEnum4[GLEnum4["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    GLEnum4[GLEnum4["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum4[GLEnum4["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum4[GLEnum4["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum4[GLEnum4["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum4[GLEnum4["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum4[GLEnum4["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum4[GLEnum4["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum4[GLEnum4["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum4[GLEnum4["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum4[GLEnum4["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum4[GLEnum4["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum4[GLEnum4["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum4[GLEnum4["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum4[GLEnum4["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum4[GLEnum4["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum4[GLEnum4["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum4[GLEnum4["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum4[GLEnum4["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum4[GLEnum4["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    GLEnum4[GLEnum4["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum4[GLEnum4["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum4[GLEnum4["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum4[GLEnum4["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum4[GLEnum4["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum4[GLEnum4["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum4[GLEnum4["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum4[GLEnum4["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum4[GLEnum4["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum4[GLEnum4["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum4[GLEnum4["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    GLEnum4[GLEnum4["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum4[GLEnum4["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum4[GLEnum4["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum4[GLEnum4["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum4[GLEnum4["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum4[GLEnum4["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    GLEnum4[GLEnum4["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum4[GLEnum4["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum4[GLEnum4["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum4[GLEnum4["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum4[GLEnum4["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum4[GLEnum4["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum4[GLEnum4["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum4[GLEnum4["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum4[GLEnum4["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum4[GLEnum4["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum4[GLEnum4["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum4[GLEnum4["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum4[GLEnum4["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum4[GLEnum4["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum4[GLEnum4["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    GLEnum4[GLEnum4["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum4[GLEnum4["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum4[GLEnum4["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum4[GLEnum4["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum4[GLEnum4["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    GLEnum4[GLEnum4["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum4[GLEnum4["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum4[GLEnum4["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum4[GLEnum4["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum4[GLEnum4["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum4[GLEnum4["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum4[GLEnum4["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum4[GLEnum4["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum4[GLEnum4["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum4[GLEnum4["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum4[GLEnum4["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum4[GLEnum4["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum4[GLEnum4["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    GLEnum4[GLEnum4["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum4[GLEnum4["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum4[GLEnum4["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum4[GLEnum4["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum4[GLEnum4["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum4[GLEnum4["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum4[GLEnum4["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum4[GLEnum4["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum4[GLEnum4["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum4[GLEnum4["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum4[GLEnum4["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum4[GLEnum4["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum4[GLEnum4["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    GLEnum4[GLEnum4["COLOR"] = 6144] = "COLOR";
    GLEnum4[GLEnum4["DEPTH"] = 6145] = "DEPTH";
    GLEnum4[GLEnum4["STENCIL"] = 6146] = "STENCIL";
    GLEnum4[GLEnum4["MIN"] = 32775] = "MIN";
    GLEnum4[GLEnum4["MAX"] = 32776] = "MAX";
    GLEnum4[GLEnum4["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum4[GLEnum4["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum4[GLEnum4["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum4[GLEnum4["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum4[GLEnum4["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum4[GLEnum4["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum4[GLEnum4["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum4[GLEnum4["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum4[GLEnum4["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum4[GLEnum4["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum4[GLEnum4["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum4[GLEnum4["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    GLEnum4[GLEnum4["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    GLEnum4[GLEnum4["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    GLEnum4[GLEnum4["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum4[GLEnum4["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum4[GLEnum4["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum4[GLEnum4["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum4[GLEnum4["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum4[GLEnum4["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum4[GLEnum4["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum4[GLEnum4["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum4[GLEnum4["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum4[GLEnum4["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum4[GLEnum4["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    GLEnum4[GLEnum4["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GLEnum4[GLEnum4["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum4[GLEnum4["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    GLEnum4[GLEnum4["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum4[GLEnum4["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GLEnum4[GLEnum4["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    GLEnum4[GLEnum4["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    GLEnum4[GLEnum4["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    GLEnum4[GLEnum4["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    GLEnum4[GLEnum4["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    GLEnum4[GLEnum4["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    GLEnum4[GLEnum4["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    GLEnum4[GLEnum4["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
    GLEnum4[GLEnum4["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
    GLEnum4[GLEnum4["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
    GLEnum4[GLEnum4["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
    GLEnum4[GLEnum4["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
    GLEnum4[GLEnum4["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
    GLEnum4[GLEnum4["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
    GLEnum4[GLEnum4["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
    GLEnum4[GLEnum4["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
    GLEnum4[GLEnum4["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
    GLEnum4[GLEnum4["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
    GLEnum4[GLEnum4["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
    GLEnum4[GLEnum4["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
    GLEnum4[GLEnum4["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
    GLEnum4[GLEnum4["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
    GLEnum4[GLEnum4["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
    GLEnum4[GLEnum4["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
    GLEnum4[GLEnum4["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
    GLEnum4[GLEnum4["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
    GLEnum4[GLEnum4["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
    GLEnum4[GLEnum4["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
    GLEnum4[GLEnum4["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
    GLEnum4[GLEnum4["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
    GLEnum4[GLEnum4["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
  })(GLEnum || (GLEnum = {}));

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [35725]: null,
    [36006]: null,
    [36007]: null,
    [34229]: null,
    [34964]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32926]: false,
    [32928]: false,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [36389]: null,
    [36662]: null,
    [36663]: null,
    [35053]: null,
    [35055]: null,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var bindFramebuffer = (gl, value, key) => {
    const target = key === 36006 ? 36009 : 36008;
    return gl.bindFramebuffer(target, value);
  };
  var bindBuffer = (gl, value, key) => {
    const bindingMap = {
      [34964]: 34962,
      [36662]: 36662,
      [36663]: 36663,
      [35053]: 35051,
      [35055]: 35052
    };
    const glTarget = bindingMap[key];
    gl.bindBuffer(glTarget, value);
  };
  function isArray2(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [35725]: (gl, value) => gl.useProgram(value),
    [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
    [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
    [34229]: (gl, value) => gl.bindVertexArray(value),
    [36006]: bindFramebuffer,
    [36010]: bindFramebuffer,
    [34964]: bindBuffer,
    [36662]: bindBuffer,
    [36663]: bindBuffer,
    [35053]: bindBuffer,
    [35055]: bindBuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32926]: enable,
    [32928]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [34383]: enable,
    [10754]: enable,
    [12288]: enable,
    [12289]: enable,
    [12290]: enable,
    [12291]: enable,
    [12292]: enable,
    [12293]: enable,
    [12294]: enable,
    [12295]: enable,
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      const separateModes = typeof args === "number" ? [args, args] : args;
      gl.blendEquationSeparate(...separateModes);
    },
    blendFunc: (gl, args) => {
      const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...separateFuncs);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray2(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray2(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache3) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache3[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache3) => gl.blendEquationSeparate(getValue(32777, values, cache3), getValue(34877, values, cache3)),
    blendFunc: (gl, values, cache3) => gl.blendFuncSeparate(getValue(32969, values, cache3), getValue(32968, values, cache3), getValue(32971, values, cache3), getValue(32970, values, cache3)),
    polygonOffset: (gl, values, cache3) => gl.polygonOffset(getValue(32824, values, cache3), getValue(10752, values, cache3)),
    sampleCoverage: (gl, values, cache3) => gl.sampleCoverage(getValue(32938, values, cache3), getValue(32939, values, cache3)),
    stencilFuncFront: (gl, values, cache3) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache3), getValue(2967, values, cache3), getValue(2963, values, cache3)),
    stencilFuncBack: (gl, values, cache3) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache3), getValue(36003, values, cache3), getValue(36004, values, cache3)),
    stencilOpFront: (gl, values, cache3) => gl.stencilOpSeparate(1028, getValue(2964, values, cache3), getValue(2965, values, cache3), getValue(2966, values, cache3)),
    stencilOpBack: (gl, values, cache3) => gl.stencilOpSeparate(1029, getValue(34817, values, cache3), getValue(34818, values, cache3), getValue(34819, values, cache3))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    useProgram: (update, value) => update({
      [35725]: value
    }),
    bindRenderbuffer: (update, target, value) => update({
      [36007]: value
    }),
    bindTransformFeedback: (update, target, value) => update({
      [36389]: value
    }),
    bindVertexArray: (update, value) => update({
      [34229]: value
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({ [36006]: framebuffer });
        case 36008:
          return update({ [36010]: framebuffer });
        default:
          return null;
      }
    },
    bindBuffer: (update, target, buffer) => {
      const pname = {
        [34962]: [34964],
        [36662]: [36662],
        [36663]: [36663],
        [35051]: [35053],
        [35052]: [35055]
      }[target];
      if (pname) {
        return update({ [pname]: buffer });
      }
      return { valueChanged: true };
    },
    blendColor: (update, r3, g2, b2, a3) => update({
      [32773]: new Float32Array([r3, g2, b2, a3])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r3, g2, b2, a3) => update({
      [3106]: new Float32Array([r3, g2, b2, a3])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s3) => update({
      [2961]: s3
    }),
    colorMask: (update, r3, g2, b2, a3) => update({
      [3107]: [r3, g2, b2, a3]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert4) => update({
      [32938]: value,
      [32939]: invert4
    }),
    scissor: (update, x3, y3, width, height) => update({
      [3088]: new Int32Array([x3, y3, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x3, y3, width, height) => update({
      [2978]: [x3, y3, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };
  var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
    34016,
    36388,
    36387,
    35983,
    35368,
    34965,
    35739,
    35738,
    3074,
    34853,
    34854,
    34855,
    34856,
    34857,
    34858,
    34859,
    34860,
    34861,
    34862,
    34863,
    34864,
    34865,
    34866,
    34867,
    34868,
    35097,
    32873,
    35869,
    32874,
    34068
  ]);

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js
  function setGLParameters(gl, parameters2) {
    if (isObjectEmpty2(parameters2)) {
      return;
    }
    const compositeSetters = {};
    for (const key in parameters2) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, parameters2[key], glConstant);
        }
      }
    }
    const cache3 = gl.state && gl.state.cache;
    if (cache3) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, parameters2, cache3);
      }
    }
  }
  function getGLParameters(gl, parameters2 = GL_PARAMETER_DEFAULTS) {
    if (typeof parameters2 === "number") {
      const key = parameters2;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters2) ? parameters2 : Object.keys(parameters2);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetGLParameters(gl) {
    setGLParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function isObjectEmpty2(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js
  function deepArrayEqual(x3, y3) {
    if (x3 === y3) {
      return true;
    }
    const isArrayX = Array.isArray(x3) || ArrayBuffer.isView(x3);
    const isArrayY = Array.isArray(y3) || ArrayBuffer.isView(y3);
    if (isArrayX && isArrayY && x3.length === y3.length) {
      for (let i5 = 0; i5 < x3.length; ++i5) {
        if (x3[i5] !== y3[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/track-context-state.js
  var GLState = class {
    gl;
    program = null;
    stateStack = [];
    enable = true;
    cache;
    log;
    constructor(gl, {
      copyState = false,
      log: log3 = () => {
      }
    } = {}) {
      this.gl = gl;
      this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log3;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push(values = {}) {
      this.stateStack.push({});
    }
    pop() {
      assert6(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setGLParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
      for (const key in values) {
        assert6(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return { valueChanged, oldValue };
    }
  };
  function getContextState(gl) {
    return gl.state;
  }
  function trackContextState(gl, options) {
    const { enable: enable2 = true, copyState } = options;
    assert6(copyState !== void 0);
    if (!gl.state) {
      gl.state = new GLState(gl, { copyState });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    const glState = getContextState(gl);
    glState.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    let glState = getContextState(gl);
    if (!glState) {
      trackContextState(gl, { copyState: false });
      glState = getContextState(gl);
    }
    glState.push();
  }
  function popContextState(gl) {
    const glState = getContextState(gl);
    assert6(glState);
    glState.pop();
  }
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get(pname) {
      if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
        return originalGetterFunc(pname);
      }
      const glState = getContextState(gl);
      if (!(pname in glState.cache)) {
        glState.cache[pname] = originalGetterFunc(pname);
      }
      return glState.enable ? glState.cache[pname] : originalGetterFunc(pname);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-from-cache`,
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    if (!gl[functionName]) {
      return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set5(...params) {
      const glState = getContextState(gl);
      const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-to-cache`,
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      const glState = getContextState(gl);
      if (glState.program !== handle) {
        originalUseProgram(handle);
        glState.program = handle;
      }
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js
  var DEFAULT_CONTEXT_PROPS = {
    powerPreference: "high-performance",
    onContextLost: () => console.error("WebGL context lost"),
    onContextRestored: () => console.info("WebGL context restored")
  };
  function createBrowserContext(canvas2, props) {
    props = { ...DEFAULT_CONTEXT_PROPS, ...props };
    let errorMessage = null;
    const onCreateError = (error) => errorMessage = error.statusMessage || errorMessage;
    canvas2.addEventListener("webglcontextcreationerror", onCreateError, false);
    let gl = null;
    gl ||= canvas2.getContext("webgl2", props);
    canvas2.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      throw new Error(`Failed to create WebGL context: ${errorMessage || "Unknown error"}`);
    }
    if (props.onContextLost) {
      const { onContextLost } = props;
      canvas2.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
    }
    if (props.onContextRestored) {
      const { onContextRestored } = props;
      canvas2.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
    }
    return gl;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js
  function getWebGLExtension(gl, name13, extensions) {
    if (extensions[name13] === void 0) {
      extensions[name13] = gl.getExtension(name13) || null;
    }
    return extensions[name13];
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js
  function getDeviceInfo(gl, extensions) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
    const ext = extensions.WEBGL_debug_renderer_info;
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    const version = gl.getParameter(7938);
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    const shadingLanguage = "glsl";
    const shadingLanguageVersion = 300;
    return {
      type: "webgl",
      gpu,
      gpuType,
      gpuBackend,
      vendor,
      renderer,
      version,
      shadingLanguage,
      shadingLanguageVersion
    };
  }
  function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
      return "nvidia";
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
      return "intel";
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
      return "apple";
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
      return "amd";
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "software";
    }
    return "unknown";
  }
  function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
      return "metal";
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
      return "opengl";
    }
    return "unknown";
  }
  function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "cpu";
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch (gpuVendor) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/vertex-formats.js
  function getGLFromVertexType(dataType) {
    switch (dataType) {
      case "uint8":
        return 5121;
      case "sint8":
        return 5120;
      case "unorm8":
        return 5121;
      case "snorm8":
        return 5120;
      case "uint16":
        return 5123;
      case "sint16":
        return 5122;
      case "unorm16":
        return 5123;
      case "snorm16":
        return 5122;
      case "uint32":
        return 5125;
      case "sint32":
        return 5124;
      case "float16":
        return 5131;
      case "float32":
        return 5126;
    }
    throw new Error(String(dataType));
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/texture-formats.js
  var texture_compression_bc = "texture-compression-bc";
  var texture_compression_astc = "texture-compression-astc";
  var texture_compression_etc2 = "texture-compression-etc2";
  var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
  var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
  var texture_compression_atc_webgl = "texture-compression-atc-webgl";
  var float32_renderable = "float32-renderable-webgl";
  var float16_renderable = "float16-renderable-webgl";
  var rgb9e5ufloat_renderable = "rgb9e5ufloat_renderable-webgl";
  var snorm8_renderable = "snorm8-renderable-webgl";
  var norm16_renderable = "norm16-renderable-webgl";
  var snorm16_renderable = "snorm16-renderable-webgl";
  var float32_filterable = "float32-filterable";
  var float16_filterable = "float16-filterable-webgl";
  var X_S3TC = "WEBGL_compressed_texture_s3tc";
  var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
  var X_RGTC = "EXT_texture_compression_rgtc";
  var X_BPTC = "EXT_texture_compression_bptc";
  var X_ETC2 = "WEBGL_compressed_texture_etc";
  var X_ASTC = "WEBGL_compressed_texture_astc";
  var X_ETC1 = "WEBGL_compressed_texture_etc1";
  var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
  var X_ATC = "WEBGL_compressed_texture_atc";
  var EXT_texture_norm16 = "EXT_texture_norm16";
  var EXT_render_snorm = "EXT_render_snorm";
  var EXT_color_buffer_float = "EXT_color_buffer_float";
  var TEXTURE_FEATURES = {
    "float32-renderable-webgl": ["EXT_color_buffer_float"],
    "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
    "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
    "snorm8-renderable-webgl": [EXT_render_snorm],
    "norm16-renderable-webgl": [EXT_texture_norm16],
    "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
    "float32-filterable": ["OES_texture_float_linear"],
    "float16-filterable-webgl": ["OES_texture_half_float_linear"],
    "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
    "texture-blend-float-webgl": ["EXT_float_blend"],
    "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
    "texture-compression-bc5-webgl": [X_RGTC],
    "texture-compression-bc7-webgl": [X_BPTC],
    "texture-compression-etc2": [X_ETC2],
    "texture-compression-astc": [X_ASTC],
    "texture-compression-etc1-webgl": [X_ETC1],
    "texture-compression-pvrtc-webgl": [X_PVRTC],
    "texture-compression-atc-webgl": [X_ATC]
  };
  function isTextureFeature(feature) {
    return feature in TEXTURE_FEATURES;
  }
  function checkTextureFeature(gl, feature, extensions) {
    const textureExtensions = TEXTURE_FEATURES[feature] || [];
    return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
  }
  var TEXTURE_FORMATS = {
    "rgb8unorm-unsized": {
      gl: 6407,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6407,
      types: [5121, 33635]
    },
    "rgba8unorm-unsized": {
      gl: 6408,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    "r8unorm": { gl: 33321, b: 1, c: 1, rb: true },
    "r8snorm": { gl: 36756, b: 1, c: 1, render: snorm8_renderable },
    "r8uint": { gl: 33330, b: 1, c: 1, rb: true },
    "r8sint": { gl: 33329, b: 1, c: 1, rb: true },
    "rg8unorm": { gl: 33323, b: 2, c: 2, rb: true },
    "rg8snorm": { gl: 36757, b: 2, c: 2, render: snorm8_renderable },
    "rg8uint": { gl: 33336, b: 2, c: 2, rb: true },
    "rg8sint": { gl: 33335, b: 2, c: 2, rb: true },
    "r16uint": { gl: 33332, b: 2, c: 1, rb: true },
    "r16sint": { gl: 33331, b: 2, c: 1, rb: true },
    "r16float": { gl: 33325, b: 2, c: 1, render: float16_renderable, filter: "float16-filterable-webgl", rb: true },
    "r16unorm-webgl": { gl: 33322, b: 2, c: 1, f: norm16_renderable, rb: true },
    "r16snorm-webgl": { gl: 36760, b: 2, c: 1, f: snorm16_renderable },
    "rgba4unorm-webgl": { gl: 32854, b: 2, c: 4, wgpu: false, rb: true },
    "rgb565unorm-webgl": { gl: 36194, b: 2, c: 4, wgpu: false, rb: true },
    "rgb5a1unorm-webgl": { gl: 32855, b: 2, c: 4, wgpu: false, rb: true },
    "rgb8unorm-webgl": { gl: 32849, b: 3, c: 3, wgpu: false },
    "rgb8snorm-webgl": { gl: 36758, b: 3, c: 3, wgpu: false },
    "rgba8unorm": { gl: 32856, b: 4, c: 2, bpp: 4 },
    "rgba8unorm-srgb": { gl: 35907, b: 4, c: 4, bpp: 4 },
    "rgba8snorm": { gl: 36759, b: 4, c: 4, render: snorm8_renderable },
    "rgba8uint": { gl: 36220, b: 4, c: 4, bpp: 4 },
    "rgba8sint": { gl: 36238, b: 4, c: 4, bpp: 4 },
    "bgra8unorm": { b: 4, c: 4 },
    "bgra8unorm-srgb": { b: 4, c: 4 },
    "rg16uint": { gl: 33338, b: 4, c: 1, bpp: 4 },
    "rg16sint": { gl: 33337, b: 4, c: 2, bpp: 4 },
    "rg16float": { gl: 33327, bpp: 4, b: 4, c: 2, render: float16_renderable, filter: float16_filterable, rb: true },
    "rg16unorm-webgl": { gl: 33324, b: 2, c: 2, render: norm16_renderable },
    "rg16snorm-webgl": { gl: 36761, b: 2, c: 2, render: snorm16_renderable },
    "r32uint": { gl: 33334, b: 4, c: 1, bpp: 4, rb: true },
    "r32sint": { gl: 33333, b: 4, c: 1, bpp: 4, rb: true },
    "r32float": { gl: 33326, bpp: 4, b: 4, c: 1, render: float32_renderable, filter: float32_filterable },
    "rgb9e5ufloat": { gl: 35901, b: 4, c: 3, p: 1, render: rgb9e5ufloat_renderable },
    "rg11b10ufloat": { gl: 35898, b: 4, c: 3, p: 1, render: float32_renderable, rb: true },
    "rgb10a2unorm": { gl: 32857, b: 4, c: 4, p: 1, rb: true },
    "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975, p: 1, wgpu: false, bpp: 4, rb: true },
    "rgb16unorm-webgl": { gl: 32852, b: 2, c: 3, f: norm16_renderable },
    "rgb16snorm-webgl": { gl: 36762, b: 2, c: 3, f: norm16_renderable },
    "rg32uint": { gl: 33340, b: 8, c: 2, rb: true },
    "rg32sint": { gl: 33339, b: 8, c: 2, rb: true },
    "rg32float": { gl: 33328, b: 8, c: 2, render: float32_renderable, filter: float32_filterable, rb: true },
    "rgba16uint": { gl: 36214, b: 8, c: 4, rb: true },
    "rgba16sint": { gl: 36232, b: 8, c: 4, rb: true },
    "rgba16float": { gl: 34842, b: 8, c: 4, render: float16_renderable, filter: float16_filterable },
    "rgba16unorm-webgl": { gl: 32859, b: 2, c: 4, render: norm16_renderable, rb: true },
    "rgba16snorm-webgl": { gl: 36763, b: 2, c: 4, render: snorm16_renderable },
    "rgb32float-webgl": {
      gl: 34837,
      render: float32_renderable,
      filter: float32_filterable,
      gl2ext: EXT_color_buffer_float,
      dataFormat: 6407,
      types: [5126]
    },
    "rgba32uint": { gl: 36208, b: 16, c: 4, rb: true },
    "rgba32sint": { gl: 36226, b: 16, c: 4, rb: true },
    "rgba32float": { gl: 34836, b: 16, c: 4, render: float32_renderable, filter: float32_filterable, rb: true },
    "stencil8": { gl: 36168, b: 1, c: 1, attachment: 36128, rb: true },
    "depth16unorm": {
      gl: 33189,
      b: 2,
      c: 1,
      attachment: 36096,
      dataFormat: 6402,
      types: [5123],
      rb: true
    },
    "depth24plus": {
      gl: 33190,
      b: 3,
      c: 1,
      attachment: 36096,
      dataFormat: 6402,
      types: [5125]
    },
    "depth32float": {
      gl: 36012,
      b: 4,
      c: 1,
      attachment: 36096,
      dataFormat: 6402,
      types: [5126],
      rb: true
    },
    "depth24plus-stencil8": {
      gl: 35056,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306,
      rb: true,
      depthTexture: true,
      dataFormat: 34041,
      types: [34042]
    },
    "depth24unorm-stencil8": {
      gl: 35056,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306,
      dataFormat: 34041,
      types: [34042],
      rb: true
    },
    "depth32float-stencil8": {
      gl: 36013,
      b: 5,
      c: 2,
      p: 1,
      attachment: 33306,
      dataFormat: 34041,
      types: [36269],
      rb: true
    },
    "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC, f: texture_compression_bc },
    "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc1-rgba-unorm": { gl: 33777, x: X_S3TC, f: texture_compression_bc },
    "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc2-rgba-unorm": { gl: 33778, x: X_S3TC, f: texture_compression_bc },
    "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc3-rgba-unorm": { gl: 33779, x: X_S3TC, f: texture_compression_bc },
    "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc4-r-unorm": { gl: 36283, x: X_RGTC, f: texture_compression_bc },
    "bc4-r-snorm": { gl: 36284, x: X_RGTC, f: texture_compression_bc },
    "bc5-rg-unorm": { gl: 36285, x: X_RGTC, f: texture_compression_bc },
    "bc5-rg-snorm": { gl: 36286, x: X_RGTC, f: texture_compression_bc },
    "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC, f: texture_compression_bc },
    "bc6h-rgb-float": { gl: 36494, x: X_BPTC, f: texture_compression_bc },
    "bc7-rgba-unorm": { gl: 36492, x: X_BPTC, f: texture_compression_bc },
    "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC, f: texture_compression_bc },
    "etc2-rgb8unorm": { gl: 37492, f: texture_compression_etc2 },
    "etc2-rgb8unorm-srgb": { gl: 37494, f: texture_compression_etc2 },
    "etc2-rgb8a1unorm": { gl: 37496, f: texture_compression_etc2 },
    "etc2-rgb8a1unorm-srgb": { gl: 37497, f: texture_compression_etc2 },
    "etc2-rgba8unorm": { gl: 37493, f: texture_compression_etc2 },
    "etc2-rgba8unorm-srgb": { gl: 37495, f: texture_compression_etc2 },
    "eac-r11unorm": { gl: 37488, f: texture_compression_etc2 },
    "eac-r11snorm": { gl: 37489, f: texture_compression_etc2 },
    "eac-rg11unorm": { gl: 37490, f: texture_compression_etc2 },
    "eac-rg11snorm": { gl: 37491, f: texture_compression_etc2 },
    "astc-4x4-unorm": { gl: 37808, f: texture_compression_astc },
    "astc-4x4-unorm-srgb": { gl: 37840, f: texture_compression_astc },
    "astc-5x4-unorm": { gl: 37809, f: texture_compression_astc },
    "astc-5x4-unorm-srgb": { gl: 37841, f: texture_compression_astc },
    "astc-5x5-unorm": { gl: 37810, f: texture_compression_astc },
    "astc-5x5-unorm-srgb": { gl: 37842, f: texture_compression_astc },
    "astc-6x5-unorm": { gl: 37811, f: texture_compression_astc },
    "astc-6x5-unorm-srgb": { gl: 37843, f: texture_compression_astc },
    "astc-6x6-unorm": { gl: 37812, f: texture_compression_astc },
    "astc-6x6-unorm-srgb": { gl: 37844, f: texture_compression_astc },
    "astc-8x5-unorm": { gl: 37813, f: texture_compression_astc },
    "astc-8x5-unorm-srgb": { gl: 37845, f: texture_compression_astc },
    "astc-8x6-unorm": { gl: 37814, f: texture_compression_astc },
    "astc-8x6-unorm-srgb": { gl: 37846, f: texture_compression_astc },
    "astc-8x8-unorm": { gl: 37815, f: texture_compression_astc },
    "astc-8x8-unorm-srgb": { gl: 37847, f: texture_compression_astc },
    "astc-10x5-unorm": { gl: 37819, f: texture_compression_astc },
    "astc-10x5-unorm-srgb": { gl: 37851, f: texture_compression_astc },
    "astc-10x6-unorm": { gl: 37817, f: texture_compression_astc },
    "astc-10x6-unorm-srgb": { gl: 37849, f: texture_compression_astc },
    "astc-10x8-unorm": { gl: 37818, f: texture_compression_astc },
    "astc-10x8-unorm-srgb": { gl: 37850, f: texture_compression_astc },
    "astc-10x10-unorm": { gl: 37819, f: texture_compression_astc },
    "astc-10x10-unorm-srgb": { gl: 37851, f: texture_compression_astc },
    "astc-12x10-unorm": { gl: 37820, f: texture_compression_astc },
    "astc-12x10-unorm-srgb": { gl: 37852, f: texture_compression_astc },
    "astc-12x12-unorm": { gl: 37821, f: texture_compression_astc },
    "astc-12x12-unorm-srgb": { gl: 37853, f: texture_compression_astc },
    "pvrtc-rgb4unorm-webgl": { gl: 35840, f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba4unorm-webgl": { gl: 35842, f: texture_compression_pvrtc_webgl },
    "pvrtc-rbg2unorm-webgl": { gl: 35841, f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba2unorm-webgl": { gl: 35843, f: texture_compression_pvrtc_webgl },
    "etc1-rbg-unorm-webgl": { gl: 36196, f: texture_compression_etc1_webgl },
    "atc-rgb-unorm-webgl": { gl: 35986, f: texture_compression_atc_webgl },
    "atc-rgba-unorm-webgl": { gl: 35986, f: texture_compression_atc_webgl },
    "atc-rgbai-unorm-webgl": { gl: 34798, f: texture_compression_atc_webgl }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES3 = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isTextureFormatSupported(gl, format, extensions) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl === void 0) {
      return false;
    }
    const extension = info.x || info.gl2ext;
    if (extension) {
      return Boolean(getWebGLExtension(gl, extension, extensions));
    }
    return true;
  }
  function convertTextureFormatToGL(format) {
    const formatInfo = TEXTURE_FORMATS[format];
    const webglFormat = formatInfo?.gl;
    if (webglFormat === void 0) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
  }
  function isTextureFormatFilterable(gl, format, extensions) {
    if (!isTextureFormatSupported(gl, format, extensions)) {
      return false;
    }
    if (format.startsWith("depth") || format.startsWith("stencil")) {
      return false;
    }
    try {
      const decoded = decodeTextureFormat(format);
      if (decoded.signed) {
        return false;
      }
    } catch {
      return false;
    }
    if (format.endsWith("32float")) {
      return Boolean(getWebGLExtension(gl, "OES_texture_float_linear, extensions", extensions));
    }
    if (format.endsWith("16float")) {
      return Boolean(getWebGLExtension(gl, "OES_texture_half_float_linear, extensions", extensions));
    }
    return true;
  }
  function isTextureFormatRenderable(gl, format, extensions) {
    if (!isTextureFormatSupported(gl, format, extensions)) {
      return false;
    }
    if (typeof format === "number") {
      return false;
    }
    return true;
  }
  function getWebGLTextureParameters(format) {
    const formatData = TEXTURE_FORMATS[format];
    const webglFormat = convertTextureFormatToGL(format);
    const decoded = decodeTextureFormat(format);
    return {
      format: webglFormat,
      dataFormat: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.format, decoded.integer, decoded.normalized, webglFormat),
      type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121,
      compressed: decoded.compressed
    };
  }
  function getDepthStencilAttachmentWebGL(format) {
    const info = TEXTURE_FORMATS[format];
    if (!info?.attachment) {
      throw new Error(`${format} is not a depth stencil format`);
    }
    return info.attachment;
  }
  function getTextureFormatBytesPerPixel(format) {
    const params = getWebGLTextureParameters(format);
    const channels = DATA_FORMAT_CHANNELS[params.dataFormat] || 4;
    const channelSize = TYPE_SIZES3[params.type] || 1;
    return channels * channelSize;
  }
  function getWebGLPixelDataFormat(dataFormat, integer, normalized, format) {
    if (format === 6408 || format === 6407) {
      return format;
    }
    switch (dataFormat) {
      case "r":
        return integer && !normalized ? 36244 : 6403;
      case "rg":
        return integer && !normalized ? 33320 : 33319;
      case "rgb":
        return integer && !normalized ? 36248 : 6407;
      case "rgba":
        return integer && !normalized ? 36249 : 6408;
      default:
        return 6408;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js
  var WEBGL_FEATURES = {
    "depth-clip-control": "EXT_depth_clamp",
    "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
    "compilation-status-async-webgl": "KHR_parallel_shader_compile",
    "polygon-mode-webgl": "WEBGL_polygon_mode",
    "provoking-vertex-webgl": "WEBGL_provoking_vertex",
    "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
    "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
    "shader-conservative-depth-webgl": "EXT_conservative_depth"
  };
  var WebGLDeviceFeatures = class extends DeviceFeatures {
    gl;
    extensions;
    testedFeatures = /* @__PURE__ */ new Set();
    constructor(gl, extensions, disabledFeatures) {
      super([], disabledFeatures);
      this.gl = gl;
      this.extensions = extensions;
      getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
    }
    *[Symbol.iterator]() {
      const features = this.getFeatures();
      for (const feature of features) {
        if (this.has(feature)) {
          yield feature;
        }
      }
      return [];
    }
    has(feature) {
      if (this.disabledFeatures[feature]) {
        return false;
      }
      if (!this.testedFeatures.has(feature)) {
        this.testedFeatures.add(feature);
        if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
          this.features.add(feature);
        }
        if (this.getWebGLFeature(feature)) {
          this.features.add(feature);
        }
      }
      return this.features.has(feature);
    }
    initializeFeatures() {
      const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
      for (const feature of features) {
        this.has(feature);
      }
    }
    getFeatures() {
      return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
    }
    getWebGLFeature(feature) {
      const featureInfo = WEBGL_FEATURES[feature];
      const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
      return isSupported;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js
  var WebGLDeviceLimits = class extends DeviceLimits {
    get maxTextureDimension1D() {
      return 0;
    }
    get maxTextureDimension2D() {
      return this.getParameter(3379);
    }
    get maxTextureDimension3D() {
      return this.getParameter(32883);
    }
    get maxTextureArrayLayers() {
      return this.getParameter(35071);
    }
    get maxBindGroups() {
      return 0;
    }
    get maxDynamicUniformBuffersPerPipelineLayout() {
      return 0;
    }
    get maxDynamicStorageBuffersPerPipelineLayout() {
      return 0;
    }
    get maxSampledTexturesPerShaderStage() {
      return this.getParameter(35660);
    }
    get maxSamplersPerShaderStage() {
      return this.getParameter(35661);
    }
    get maxStorageBuffersPerShaderStage() {
      return 0;
    }
    get maxStorageTexturesPerShaderStage() {
      return 0;
    }
    get maxUniformBuffersPerShaderStage() {
      return this.getParameter(35375);
    }
    get maxUniformBufferBindingSize() {
      return this.getParameter(35376);
    }
    get maxStorageBufferBindingSize() {
      return 0;
    }
    get minUniformBufferOffsetAlignment() {
      return this.getParameter(35380);
    }
    get minStorageBufferOffsetAlignment() {
      return 0;
    }
    get maxVertexBuffers() {
      return 16;
    }
    get maxVertexAttributes() {
      return this.getParameter(34921);
    }
    get maxVertexBufferArrayStride() {
      return 2048;
    }
    get maxInterStageShaderComponents() {
      return this.getParameter(35659);
    }
    get maxComputeWorkgroupStorageSize() {
      return 0;
    }
    get maxComputeInvocationsPerWorkgroup() {
      return 0;
    }
    get maxComputeWorkgroupSizeX() {
      return 0;
    }
    get maxComputeWorkgroupSizeY() {
      return 0;
    }
    get maxComputeWorkgroupSizeZ() {
      return 0;
    }
    get maxComputeWorkgroupsPerDimension() {
      return 0;
    }
    gl;
    limits = {};
    constructor(gl) {
      super();
      this.gl = gl;
    }
    getParameter(parameter) {
      if (this.limits[parameter] === void 0) {
        this.limits[parameter] = this.gl.getParameter(parameter);
      }
      return this.limits[parameter];
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js
  function withGLParameters(gl, parameters2, func) {
    if (isObjectEmpty3(parameters2)) {
      return func(gl);
    }
    const { nocatch = true } = parameters2;
    pushContextState(gl);
    setGLParameters(gl, parameters2);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }
  function isObjectEmpty3(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js
  function withDeviceAndGLParameters(device, parameters2, glParameters, func) {
    if (isObjectEmpty(parameters2)) {
      return func(device);
    }
    const webglDevice = device;
    pushContextState(webglDevice.gl);
    try {
      setDeviceParameters(device, parameters2);
      setGLParameters(webglDevice.gl, glParameters);
      return func(device);
    } finally {
      popContextState(webglDevice.gl);
    }
  }
  function setDeviceParameters(device, parameters2) {
    const webglDevice = device;
    const { gl } = webglDevice;
    if (parameters2.cullMode) {
      switch (parameters2.cullMode) {
        case "none":
          gl.disable(2884);
          break;
        case "front":
          gl.enable(2884);
          gl.cullFace(1028);
          break;
        case "back":
          gl.enable(2884);
          gl.cullFace(1029);
          break;
      }
    }
    if (parameters2.frontFace) {
      gl.frontFace(map2("frontFace", parameters2.frontFace, {
        ccw: 2305,
        cw: 2304
      }));
    }
    if (parameters2.unclippedDepth) {
      if (device.features.has("depth-clip-control")) {
        gl.enable(34383);
      }
    }
    if (parameters2.depthBias !== void 0) {
      gl.enable(32823);
      gl.polygonOffset(parameters2.depthBias, parameters2.depthBiasSlopeScale || 0);
    }
    if (parameters2.provokingVertex) {
      if (device.features.has("provoking-vertex-webgl")) {
        const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
        const ext = extensions.WEBGL_provoking_vertex;
        const vertex = map2("provokingVertex", parameters2.provokingVertex, {
          first: 36429,
          last: 36430
        });
        ext?.provokingVertexWEBGL(vertex);
      }
    }
    if (parameters2.polygonMode || parameters2.polygonOffsetLine) {
      if (device.features.has("polygon-mode-webgl")) {
        if (parameters2.polygonMode) {
          const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
          const ext = extensions.WEBGL_polygon_mode;
          const mode = map2("polygonMode", parameters2.polygonMode, {
            fill: 6914,
            line: 6913
          });
          ext?.polygonModeWEBGL(1028, mode);
          ext?.polygonModeWEBGL(1029, mode);
        }
        if (parameters2.polygonOffsetLine) {
          gl.enable(10754);
        }
      }
    }
    if (device.features.has("shader-clip-cull-distance-webgl")) {
      if (parameters2.clipDistance0) {
        gl.enable(12288);
      }
      if (parameters2.clipDistance1) {
        gl.enable(12289);
      }
      if (parameters2.clipDistance2) {
        gl.enable(12290);
      }
      if (parameters2.clipDistance3) {
        gl.enable(12291);
      }
      if (parameters2.clipDistance4) {
        gl.enable(12292);
      }
      if (parameters2.clipDistance5) {
        gl.enable(12293);
      }
      if (parameters2.clipDistance6) {
        gl.enable(12294);
      }
      if (parameters2.clipDistance7) {
        gl.enable(12295);
      }
    }
    if (parameters2.depthWriteEnabled !== void 0) {
      gl.depthMask(mapBoolean("depthWriteEnabled", parameters2.depthWriteEnabled));
    }
    if (parameters2.depthCompare) {
      parameters2.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
      gl.depthFunc(convertCompareFunction("depthCompare", parameters2.depthCompare));
    }
    if (parameters2.stencilWriteMask) {
      const mask = parameters2.stencilWriteMask;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, mask);
    }
    if (parameters2.stencilReadMask) {
      log2.warn("stencilReadMask not supported under WebGL");
    }
    if (parameters2.stencilCompare) {
      const mask = parameters2.stencilReadMask || 4294967295;
      const glValue = convertCompareFunction("depthCompare", parameters2.stencilCompare);
      parameters2.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
      gl.stencilFuncSeparate(1028, glValue, 0, mask);
      gl.stencilFuncSeparate(1029, glValue, 0, mask);
    }
    if (parameters2.stencilPassOperation && parameters2.stencilFailOperation && parameters2.stencilDepthFailOperation) {
      const dppass = convertStencilOperation("stencilPassOperation", parameters2.stencilPassOperation);
      const sfail = convertStencilOperation("stencilFailOperation", parameters2.stencilFailOperation);
      const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters2.stencilDepthFailOperation);
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
    }
    if (parameters2.blendColorOperation || parameters2.blendAlphaOperation) {
      gl.enable(3042);
      const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters2.blendColorOperation || "add");
      const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters2.blendAlphaOperation || "add");
      gl.blendEquationSeparate(colorEquation, alphaEquation);
      const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters2.blendColorSrcFactor || "one");
      const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters2.blendColorDstFactor || "zero");
      const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters2.blendAlphaSrcFactor || "one");
      const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters2.blendAlphaDstFactor || "zero");
      gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
  }
  function convertCompareFunction(parameter, value) {
    return map2(parameter, value, {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    });
  }
  function convertStencilOperation(parameter, value) {
    return map2(parameter, value, {
      keep: 7680,
      zero: 0,
      replace: 7681,
      invert: 5386,
      "increment-clamp": 7682,
      "decrement-clamp": 7683,
      "increment-wrap": 34055,
      "decrement-wrap": 34056
    });
  }
  function convertBlendOperationToEquation(parameter, value) {
    return map2(parameter, value, {
      add: 32774,
      subtract: 32778,
      "reverse-subtract": 32779,
      min: 32775,
      max: 32776
    });
  }
  function convertBlendFactorToFunction(parameter, value) {
    return map2(parameter, value, {
      one: 1,
      zero: 0,
      "src-color": 768,
      "one-minus-src-color": 769,
      "dst-color": 774,
      "one-minus-dst-color": 775,
      "src-alpha": 770,
      "one-minus-src-alpha": 771,
      "dst-alpha": 772,
      "one-minus-dst-alpha": 773,
      "src-alpha-saturated": 776,
      "constant-color": 32769,
      "one-minus-constant-color": 32770,
      "constant-alpha": 32771,
      "one-minus-constant-alpha": 32772
    });
  }
  function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
  }
  function map2(parameter, value, valueMap) {
    if (!(value in valueMap)) {
      throw new Error(message(parameter, value));
    }
    return valueMap[value];
  }
  function mapBoolean(parameter, value) {
    return value;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js
  function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
      params[10242] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
      params[10243] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
      params[32882] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
      params[10240] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
      params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
    }
    if (props.lodMinClamp !== void 0) {
      params[33082] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== void 0) {
      params[33083] = props.lodMaxClamp;
    }
    if (props.type === "comparison-sampler") {
      params[34892] = 34894;
    }
    if (props.compare) {
      params[34893] = convertCompareFunction("compare", props.compare);
    }
    if (props.maxAnisotropy) {
      params[34046] = props.maxAnisotropy;
    }
    return params;
  }
  function convertAddressMode(addressMode) {
    switch (addressMode) {
      case "clamp-to-edge":
        return 33071;
      case "repeat":
        return 10497;
      case "mirror-repeat":
        return 33648;
    }
  }
  function convertMaxFilterMode(maxFilter) {
    switch (maxFilter) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
    }
  }
  function convertMinFilterMode(minFilter, mipmapFilter) {
    if (!mipmapFilter) {
      return convertMaxFilterMode(minFilter);
    }
    switch (minFilter) {
      case "nearest":
        return mipmapFilter === "nearest" ? 9984 : 9986;
      case "linear":
        return mipmapFilter === "nearest" ? 9985 : 9987;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js
  var WEBGLBuffer = class extends Buffer2 {
    device;
    gl;
    handle;
    glTarget;
    glUsage;
    glIndexType = 5123;
    byteLength;
    bytesUsed;
    constructor(device, props = {}) {
      super(device, props);
      this.device = device;
      this.gl = this.device.gl;
      const handle = typeof props === "object" ? props.handle : void 0;
      this.handle = handle || this.gl.createBuffer();
      device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
      this.glTarget = getWebGLTarget(this.props.usage);
      this.glUsage = getWebGLUsage(this.props.usage);
      this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
      if (props.data) {
        this._initWithData(props.data, props.byteOffset, props.byteLength);
      } else {
        this._initWithByteLength(props.byteLength || 0);
      }
    }
    _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, byteLength, this.glUsage);
      this.gl.bufferSubData(glTarget, byteOffset, data);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(data, byteOffset, byteLength);
      this.trackAllocatedMemory(byteLength);
    }
    _initWithByteLength(byteLength) {
      assert6(byteLength >= 0);
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, data, this.glUsage);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(null, 0, byteLength);
      this.trackAllocatedMemory(byteLength);
      return this;
    }
    destroy() {
      if (!this.destroyed && this.handle) {
        this.removeStats();
        this.trackDeallocatedMemory();
        this.gl.deleteBuffer(this.handle);
        this.destroyed = true;
        this.handle = null;
      }
    }
    write(data, byteOffset = 0) {
      const srcOffset = 0;
      const byteLength = void 0;
      const glTarget = 36663;
      this.gl.bindBuffer(glTarget, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(glTarget, byteOffset, data);
      }
      this.gl.bindBuffer(glTarget, null);
      this._setDebugData(data, byteOffset, data.byteLength);
    }
    async readAsync(byteOffset = 0, byteLength) {
      return this.readSyncWebGL(byteOffset, byteLength);
    }
    readSyncWebGL(byteOffset = 0, byteLength) {
      byteLength = byteLength ?? this.byteLength - byteOffset;
      const data = new Uint8Array(byteLength);
      const dstOffset = 0;
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
      this.gl.bindBuffer(36662, null);
      this._setDebugData(data, byteOffset, byteLength);
      return data;
    }
  };
  function getWebGLTarget(usage) {
    if (usage & Buffer2.INDEX) {
      return 34963;
    }
    if (usage & Buffer2.VERTEX) {
      return 34962;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35345;
    }
    return 34962;
  }
  function getWebGLUsage(usage) {
    if (usage & Buffer2.INDEX) {
      return 35044;
    }
    if (usage & Buffer2.VERTEX) {
      return 35044;
    }
    if (usage & Buffer2.UNIFORM) {
      return 35048;
    }
    return 35044;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js
  var WEBGLSampler = class extends Sampler {
    device;
    handle;
    parameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.parameters = convertSamplerParametersToWebGL(props);
      this.handle = this.handle || this.device.gl.createSampler();
      this._setSamplerParameters(this.parameters);
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteSampler(this.handle);
        this.handle = void 0;
      }
    }
    toString() {
      return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    _setSamplerParameters(parameters2) {
      for (const [pname, value] of Object.entries(parameters2)) {
        const param = Number(pname);
        switch (param) {
          case 33082:
          case 33083:
            this.device.gl.samplerParameterf(this.handle, param, value);
            break;
          default:
            this.device.gl.samplerParameteri(this.handle, param, value);
            break;
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js
  var WEBGLTextureView = class extends TextureView {
    device;
    gl;
    handle;
    texture;
    constructor(device, props) {
      super(device, { ...Texture.defaultProps, ...props });
      this.device = device;
      this.gl = this.device.gl;
      this.handle = null;
      this.texture = props.texture;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js
  var DEFAULT_WEBGL_TEXTURE_PROPS = {
    parameters: {},
    pixelStore: {},
    pixels: null,
    border: 0,
    dataFormat: void 0,
    textureUnit: void 0,
    target: void 0
  };
  var _WEBGLTexture = class extends Texture {
    MAX_ATTRIBUTES;
    device;
    gl;
    handle;
    sampler = void 0;
    view = void 0;
    glFormat = void 0;
    type = void 0;
    dataFormat = void 0;
    mipmaps = void 0;
    target;
    textureUnit = void 0;
    loaded = false;
    _video;
    constructor(device, props) {
      super(device, { ...DEFAULT_WEBGL_TEXTURE_PROPS, format: "rgba8unorm", ...props });
      this.device = device;
      this.gl = this.device.gl;
      this.handle = this.props.handle || this.gl.createTexture();
      this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
      this.glFormat = 6408;
      this.target = getWebGLTextureTarget(this.props);
      this.loaded = false;
      if (typeof this.props?.data === "string") {
        Object.assign(this.props, { data: loadImage(this.props.data) });
      }
      this.initialize(this.props);
      Object.seal(this);
    }
    destroy() {
      if (this.handle) {
        this.gl.deleteTexture(this.handle);
        this.removeStats();
        this.trackDeallocatedMemory("Texture");
        this.destroyed = true;
      }
    }
    toString() {
      return `Texture(${this.id},${this.width}x${this.height})`;
    }
    createView(props) {
      return new WEBGLTextureView(this.device, { ...props, texture: this });
    }
    initialize(props = {}) {
      if (this.props.dimension === "cube") {
        return this.initializeCube(props);
      }
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const { parameters: parameters2 = {} } = props;
      const { pixels = null, pixelStore = {}, textureUnit = void 0, mipmaps = true } = props;
      if (!data) {
        data = pixels;
      }
      let { width, height, dataFormat, type, compressed = false } = props;
      const { depth = 0 } = props;
      const glFormat = convertTextureFormatToGL(props.format);
      ({ width, height, compressed, dataFormat, type } = this._deduceParameters({
        format: props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.glFormat = glFormat;
      this.type = type;
      this.dataFormat = dataFormat;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format: glFormat,
        type,
        dataFormat,
        parameters: pixelStore,
        compressed
      });
      this.setSampler(props.sampler);
      this._setSamplerParameters(parameters2);
      this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 });
      if (mipmaps && this.device.isTextureFormatFilterable(props.format)) {
        this.generateMipmap();
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters: parameters2,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    initializeCube(props) {
      const { mipmaps = true, parameters: parameters2 = {} } = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setSampler(props.sampler);
        this._setSamplerParameters(parameters2);
      });
      return this;
    }
    setSampler(sampler = {}) {
      let samplerProps;
      if (sampler instanceof WEBGLSampler) {
        this.sampler = sampler;
        samplerProps = sampler.props;
      } else {
        this.sampler = new WEBGLSampler(this.device, sampler);
        samplerProps = sampler;
      }
      const parameters2 = convertSamplerParametersToWebGL(samplerProps);
      this._setSamplerParameters(parameters2);
      return this;
    }
    resize(options) {
      const { height, width, mipmaps = false } = options;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          mipmaps
        });
      }
      return this;
    }
    update() {
      if (this._video) {
        const { video, parameters: parameters2, lastTime } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters: parameters2
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    generateMipmap(params = {}) {
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      if (this.props.dimension === "3d" || this.props.dimension === "2d-array") {
        return this.setImageData3D(options);
      }
      this.trackDeallocatedMemory("Texture");
      const { target = this.target, pixels = null, level = 0, glFormat = this.glFormat, offset = 0, parameters: parameters2 = {} } = options;
      let { data = null, type = this.type, width = this.width, height = this.height, dataFormat = this.dataFormat, compressed = false } = options;
      if (!data) {
        data = pixels;
      }
      ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const { gl } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({ data, dataType } = this._getDataType({ data, compressed }));
      withGLParameters(this.gl, parameters2, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              dataFormat,
              type,
              data,
              offset
            );
            break;
          case "buffer":
            this.device.gl.bindBuffer(35052, data.handle || data);
            this.device.gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, offset);
            this.device.gl.bindBuffer(35052, null);
            break;
          case "browser-object":
            gl.texImage2D(target, level, glFormat, width, height, 0, dataFormat, type, data);
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, 0, levelData.data);
            }
            break;
          default:
            assert6(false, "Unknown image data type");
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
        this.trackAllocatedMemory(this.width * this.height * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData({ target = this.target, pixels = null, data = null, x: x3 = 0, y: y3 = 0, width = this.width, height = this.height, level = 0, glFormat = this.glFormat, type = this.type, dataFormat = this.dataFormat, compressed = false, offset = 0, parameters: parameters2 = {} }) {
      ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert6(this.depth === 1, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof WEBGLBuffer) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, parameters2, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x3, y3, width, height, glFormat, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x3, y3, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x3, y3, width, height, dataFormat, type, data, offset);
        } else if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
          this.device.gl.bindBuffer(35052, data);
          this.device.gl.texSubImage2D(target, level, x3, y3, width, height, dataFormat, type, offset);
          this.device.gl.bindBuffer(35052, null);
        } else {
          this.device.gl.texSubImage2D(target, level, x3, y3, width, height, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer(opts = {}) {
      log2.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind(textureUnit = this.textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind(textureUnit = this.textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType({ data, compressed = false }) {
      if (compressed) {
        return { data, dataType: "compressed" };
      }
      if (data === null) {
        return { data, dataType: "null" };
      }
      if (ArrayBuffer.isView(data)) {
        return { data, dataType: "typed-array" };
      }
      if (data instanceof WEBGLBuffer) {
        return { data: data.handle, dataType: "buffer" };
      }
      if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
        return { data, dataType: "buffer" };
      }
      return { data, dataType: "browser-object" };
    }
    _deduceParameters(opts) {
      const { format, data } = opts;
      let { width, height, dataFormat, type, compressed } = opts;
      const parameters2 = getWebGLTextureParameters(format);
      dataFormat = dataFormat || parameters2.dataFormat;
      type = type || parameters2.type;
      compressed = compressed || parameters2.compressed;
      ({ width, height } = this._deduceImageSize(data, width, height));
      return { dataFormat, type, compressed, width, height, format, data };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = { width: data.naturalWidth, height: data.naturalHeight };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = { width: data.width, height: data.height };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = { width: data.videoWidth, height: data.videoHeight };
      } else if (!data) {
        size = { width: width >= 0 ? width : 1, height: height >= 0 ? height : 1 };
      } else {
        size = { width, height };
      }
      assert6(size, "Could not deduced texture size");
      assert6(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert6(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    async setCubeMapImageData(options) {
      const { gl } = this;
      const { width, height, pixels, data, format = 6408, type = 5121 } = options;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(_WEBGLTexture.FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));
      this.bind();
      _WEBGLTexture.FACES.forEach((face, index2) => {
        if (resolvedFaces[index2].length > 1 && this.props.mipmaps !== false) {
          log2.warn(`${this.id} has mipmap and multiple LODs.`)();
        }
        resolvedFaces[index2].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, 0, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        format = 6408,
        type = 5121
      } = options;
      const { gl } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
    setImageData3D(options) {
      const {
        level = 0,
        dataFormat,
        format,
        type,
        width,
        height,
        depth = 1,
        offset = 0,
        data,
        parameters: parameters2 = {}
      } = options;
      this.trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      const webglTextureFormat = getWebGLTextureParameters(format);
      withGLParameters(this.gl, parameters2, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(
            this.target,
            level,
            webglTextureFormat.format,
            width,
            height,
            depth,
            0,
            webglTextureFormat.dataFormat,
            webglTextureFormat.type,
            data
          );
        }
        if (data instanceof WEBGLBuffer) {
          this.gl.bindBuffer(35052, data.handle);
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, 0, format, type, offset);
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
        this.trackAllocatedMemory(this.width * this.height * this.depth * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    _setSamplerParameters(parameters2) {
      if (isObjectEmpty(parameters2)) {
        return;
      }
      logParameters(parameters2);
      this.gl.bindTexture(this.target, this.handle);
      for (const [pname, pvalue] of Object.entries(parameters2)) {
        const param = Number(pname);
        const value = pvalue;
        switch (param) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.target, param, value);
            break;
          default:
            this.gl.texParameteri(this.target, param, value);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
      return;
    }
  };
  var WEBGLTexture = _WEBGLTexture;
  __publicField(WEBGLTexture, "FACES", [
    34069,
    34070,
    34071,
    34072,
    34073,
    34074
  ]);
  function getWebGLTextureTarget(props) {
    switch (props.dimension) {
      case "2d":
        return 3553;
      case "cube":
        return 34067;
      case "2d-array":
        return 35866;
      case "3d":
        return 32879;
      case "1d":
      case "cube-array":
      default:
        throw new Error(props.dimension);
    }
  }
  function logParameters(parameters2) {
    log2.log(1, "texture sampler parameters", parameters2)();
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js
  var WEBGLFramebuffer = class extends Framebuffer {
    device;
    gl;
    handle;
    get texture() {
      return this.colorAttachments[0];
    }
    constructor(device, props) {
      super(device, props);
      const isDefaultFramebuffer = props.handle === null;
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
      if (!isDefaultFramebuffer) {
        device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
        this.autoCreateAttachmentTextures();
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for (let i5 = 0; i5 < this.colorAttachments.length; ++i5) {
          const attachment = this.colorAttachments[i5];
          const attachmentPoint = 36064 + i5;
          if (attachment) {
            this._attachOne(attachmentPoint, attachment);
          }
        }
        if (this.depthStencilAttachment) {
          this._attachOne(getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format), this.depthStencilAttachment);
        }
        if (props.check !== false) {
          const status = this.gl.checkFramebufferStatus(36160);
          if (status !== 36053) {
            throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
          }
        }
        this.gl.bindFramebuffer(36160, prevHandle);
      }
    }
    destroy() {
      super.destroy();
      if (!this.destroyed && this.handle !== null) {
        this.gl.deleteFramebuffer(this.handle);
      }
    }
    createDepthStencilTexture(format) {
      return new WEBGLTexture(this.device, {
        id: `${this.id}-depth-stencil`,
        format,
        width: this.width,
        height: this.height,
        mipmaps: false
      });
    }
    resizeAttachments(width, height) {
      if (this.handle === null) {
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      for (const colorAttachment of this.colorAttachments) {
        colorAttachment.texture.resize({ width, height });
      }
      if (this.depthStencilAttachment) {
        this.depthStencilAttachment.texture.resize({ width, height });
      }
      return this;
    }
    _attachOne(attachmentPoint, attachment) {
      if (Array.isArray(attachment)) {
        const [texture, layer = 0, level = 0] = attachment;
        this._attachTexture(attachmentPoint, texture, layer, level);
        return texture;
      }
      if (attachment instanceof WEBGLTexture) {
        this._attachTexture(attachmentPoint, attachment, 0, 0);
        return attachment;
      }
      if (attachment instanceof WEBGLTextureView) {
        const textureView = attachment;
        this._attachTexture(attachmentPoint, textureView.texture, textureView.props.baseMipLevel, textureView.props.baseArrayLayer);
        return attachment.texture;
      }
      throw new Error("attach");
    }
    _attachTexture(attachment, texture, layer, level) {
      const { gl } = this.device;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          gl.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert6(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    switch (status) {
      case 36053:
        return "success";
      case 36054:
        return "Mismatched attachments";
      case 36055:
        return "No attachments";
      case 36057:
        return "Height/width mismatch";
      case 36061:
        return "Unsupported or split attachments";
      case 36182:
        return "Samples mismatch";
      default:
        return `${status}`;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js
  var WebGLCanvasContext = class extends CanvasContext {
    device;
    presentationSize;
    _framebuffer = null;
    constructor(device, props) {
      super(props);
      this.device = device;
      this.presentationSize = [-1, -1];
      this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
      this.update();
    }
    getCurrentFramebuffer() {
      this.update();
      this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
      return this._framebuffer;
    }
    update() {
      const size = this.getPixelSize();
      const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
      if (sizeChanged) {
        this.presentationSize = size;
        this.resize();
      }
    }
    resize(options) {
      if (!this.device.gl)
        return;
      if (this.canvas) {
        const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
        this.setDevicePixelRatio(devicePixelRatio, options);
        return;
      }
    }
    commit() {
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/spector.js
  var DEFAULT_SPECTOR_PROPS = {
    spector: log2.get("spector") || log2.get("inspect")
  };
  var SPECTOR_CDN_URL = "https://spectorcdn.babylonjs.com/spector.bundle.js";
  var LOG_LEVEL = 1;
  var spector = null;
  var initialized = false;
  async function loadSpectorJS(props) {
    if (!globalThis.SPECTOR) {
      try {
        await loadScript(SPECTOR_CDN_URL);
      } catch (error) {
        log2.warn(String(error));
      }
    }
  }
  function initializeSpectorJS(props) {
    props = { ...DEFAULT_SPECTOR_PROPS, ...props };
    if (!props?.spector) {
      return null;
    }
    if (!spector && globalThis.SPECTOR) {
      log2.probe(LOG_LEVEL, "SPECTOR found and initialized")();
      spector = new globalThis.SPECTOR.Spector();
      if (globalThis.luma) {
        globalThis.luma.spector = spector;
      }
    }
    if (!spector) {
      return null;
    }
    if (!initialized) {
      initialized = true;
      spector.spyCanvases();
      spector?.onCaptureStarted.add((capture) => log2.info("Spector capture started:", capture)());
      spector?.onCapture.add((capture) => {
        log2.info("Spector capture complete:", capture)();
        spector?.getResultUI();
        spector?.resultView.display();
        spector?.resultView.addCapture(capture);
      });
    }
    if (props?.canvas) {
      if (typeof props.spector === "string" && props.spector !== props.canvas.id) {
        return spector;
      }
      spector?.startCapture(props?.canvas, 500);
      new Promise((resolve2) => setTimeout(resolve2, 2e3)).then((_) => {
        log2.info("Spector capture stopped after 2 seconds")();
        spector?.stopCapture();
      });
    }
    return spector;
  }

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
  var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
  function getWebGLContextData(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
  }
  async function loadWebGLDeveloperTools() {
    if (isBrowser3() && !globalThis.WebGLDebugUtils) {
      globalThis.global = globalThis.global || globalThis;
      globalThis.global.module = {};
      await loadScript(WEBGL_DEBUG_CDN_URL);
    }
  }
  function makeDebugContext(gl, props = {}) {
    if (!gl) {
      return null;
    }
    return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
  }
  function getRealContext(gl) {
    const data = getWebGLContextData(gl);
    return data.realContext ? data.realContext : gl;
  }
  function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
      log2.warn("webgl-debug not loaded")();
      return gl;
    }
    const data = getWebGLContextData(gl);
    if (data.debugContext) {
      return data.debugContext;
    }
    globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
    for (const key in GLEnum) {
      if (!(key in glDebug) && typeof GLEnum[key] === "number") {
        glDebug[key] = GLEnum[key];
      }
    }
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    return debugContext;
  }
  function getFunctionString(functionName, functionArgs) {
    functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
    return `gl.${functionName}(${args})`;
  }
  function onGLError(props, err, functionName, args) {
    args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
    log2.error(message2)();
    debugger;
    if (props.throwOnError) {
      throw new Error(message2);
    }
  }
  function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = "";
    if (log2.level >= 1) {
      functionString = getFunctionString(functionName, functionArgs);
      log2.log(1, functionString)();
    }
    if (props.break && props.break.length > 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      const isBreakpoint = props.break.every((breakOn) => functionString.indexOf(breakOn) !== -1);
      if (isBreakpoint) {
        debugger;
      }
    }
    for (const arg of functionArgs) {
      if (arg === void 0) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        if (props.throwOnError) {
          throw new Error(`Undefined argument: ${functionString}`);
        } else {
          log2.error(`Undefined argument: ${functionString}`)();
          debugger;
        }
      }
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js
  function parseShaderCompilerLog(errLog) {
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines) {
      if (line.length <= 1) {
        continue;
      }
      const segments = line.split(":");
      if (segments.length === 2) {
        const [messageType2, message2] = segments;
        messages.push({
          message: message2.trim(),
          type: getMessageType(messageType2),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [messageType, linePosition, lineNumber, ...rest] = segments;
      let lineNum = parseInt(lineNumber, 10);
      if (isNaN(lineNum)) {
        lineNum = 0;
      }
      let linePos = parseInt(linePosition, 10);
      if (isNaN(linePos)) {
        linePos = 0;
      }
      messages.push({
        message: rest.join(":").trim(),
        type: getMessageType(messageType),
        lineNum,
        linePos
      });
    }
    return messages;
  }
  function getMessageType(messageType) {
    const MESSAGE_TYPES = ["warning", "error", "info"];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js
  var WEBGLShader = class extends Shader {
    device;
    handle;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      switch (this.props.stage) {
        case "vertex":
          this.handle = this.props.handle || this.device.gl.createShader(35633);
          break;
        case "fragment":
          this.handle = this.props.handle || this.device.gl.createShader(35632);
          break;
        default:
          throw new Error(this.props.stage);
      }
      this._compile(this.source);
    }
    destroy() {
      if (this.handle) {
        this.removeStats();
        this.device.gl.deleteShader(this.handle);
        this.destroyed = true;
      }
    }
    async getCompilationInfo() {
      await this._waitForCompilationComplete();
      return this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
      const log3 = this.device.gl.getShaderInfoLog(this.handle);
      return parseShaderCompilerLog(log3);
    }
    getTranslatedSource() {
      const extensions = this.device.getExtension("WEBGL_debug_shaders");
      const ext = extensions.WEBGL_debug_shaders;
      return ext?.getTranslatedShaderSource(this.handle);
    }
    async _compile(source) {
      const addGLSLVersion = (source2) => source2.startsWith("#version ") ? source2 : `#version 100
${source2}`;
      source = addGLSLVersion(source);
      const { gl } = this.device;
      gl.shaderSource(this.handle, source);
      gl.compileShader(this.handle);
      if (log2.level === 0) {
        this.compilationStatus = "pending";
        return;
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        this._getCompilationStatus();
        this.debugShader();
        if (this.compilationStatus === "error") {
          throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
        }
        return;
      }
      log2.once(1, "Shader compilation is asynchronous")();
      await this._waitForCompilationComplete();
      log2.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
      this._getCompilationStatus();
      this.debugShader();
    }
    async _waitForCompilationComplete() {
      const waitMs = async (ms) => await new Promise((resolve2) => setTimeout(resolve2, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getShaderParameter(this.handle, 37297);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    _getCompilationStatus() {
      this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var COLOR_CHANNELS = [1, 2, 4, 8];
  var WEBGLRenderPass = class extends RenderPass {
    device;
    glParameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      pushContextState(this.device.gl);
      this.setParameters(this.props.parameters);
      this.clear();
    }
    end() {
      popContextState(this.device.gl);
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    setParameters(parameters2 = {}) {
      const glParameters = { ...this.glParameters };
      if (this.props.framebuffer) {
        glParameters.framebuffer = this.props.framebuffer;
      }
      if (this.props.depthReadOnly) {
        glParameters.depthMask = !this.props.depthReadOnly;
      }
      glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
      glParameters[35977] = this.props.discard;
      if (parameters2.viewport) {
        if (parameters2.viewport.length >= 6) {
          glParameters.viewport = parameters2.viewport.slice(0, 4);
          glParameters.depthRange = [parameters2.viewport[4], parameters2.viewport[5]];
        } else {
          glParameters.viewport = parameters2.viewport;
        }
      }
      if (parameters2.scissorRect) {
        glParameters.scissorTest = true;
        glParameters.scissor = parameters2.scissorRect;
      }
      if (parameters2.blendConstant) {
        glParameters.blendColor = parameters2.blendConstant;
      }
      if (parameters2.stencilReference) {
        console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
        parameters2[2967] = parameters2.stencilReference;
      }
      if (parameters2.colorMask) {
        glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters2.colorMask));
      }
      this.glParameters = glParameters;
      setGLParameters(this.device.gl, glParameters);
    }
    beginOcclusionQuery(queryIndex) {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.beginOcclusionQuery();
    }
    endOcclusionQuery() {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.endOcclusionQuery();
    }
    clear() {
      const glParameters = { ...this.glParameters };
      let clearMask = 0;
      if (this.props.clearColor !== false) {
        clearMask |= GL_COLOR_BUFFER_BIT;
        glParameters.clearColor = this.props.clearColor;
      }
      if (this.props.clearDepth !== false) {
        clearMask |= GL_DEPTH_BUFFER_BIT;
        glParameters.clearDepth = this.props.clearDepth;
      }
      if (this.props.clearStencil !== false) {
        clearMask |= GL_STENCIL_BUFFER_BIT;
        glParameters.clearStencil = this.props.clearStencil;
      }
      if (clearMask !== 0) {
        withGLParameters(this.device.gl, glParameters, () => {
          this.device.gl.clear(clearMask);
        });
      }
    }
    clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
      withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
        switch (value.constructor) {
          case Int32Array:
            this.device.gl.clearBufferiv(GL_COLOR, drawBuffer, value);
            break;
          case Uint32Array:
            this.device.gl.clearBufferuiv(GL_COLOR, drawBuffer, value);
            break;
          case Float32Array:
          default:
            this.device.gl.clearBufferfv(GL_COLOR, drawBuffer, value);
            break;
        }
      });
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/classic/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType, options) {
    const { clamped = true } = options || {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/classic/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    offset;
    stride;
    type;
    size;
    divisor;
    normalized;
    integer;
    buffer;
    index;
    static getBytesPerElement(accessor) {
      const ArrayType2 = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType2.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert6(accessor.size);
      const ArrayType2 = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType2.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve(...accessors) {
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor(...accessors) {
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign(props = {}) {
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalize !== void 0) {
        this.normalized = props.normalize;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      if (this.offset === void 0)
        delete this.offset;
      if (this.stride === void 0)
        delete this.stride;
      if (this.type === void 0)
        delete this.type;
      if (this.size === void 0)
        delete this.size;
      if (this.divisor === void 0)
        delete this.divisor;
      if (this.normalized === void 0)
        delete this.normalized;
      if (this.integer === void 0)
        delete this.integer;
      if (this.buffer === void 0)
        delete this.buffer;
      if (this.index === void 0)
        delete this.index;
      return this;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/decode-webgl-types.js
  function isSamplerUniform(type) {
    return SAMPLER_TYPES.includes(type);
  }
  var SAMPLER_TYPES = [
    35678,
    35680,
    35679,
    35682,
    36289,
    36292,
    36293,
    36298,
    36299,
    36300,
    36303,
    36306,
    36307,
    36308,
    36311
  ];
  var COMPOSITE_GL_TYPES = {
    [5126]: [5126, 1, "float", "f32", "float32"],
    [35664]: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
    [35665]: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
    [35666]: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
    [5124]: [5124, 1, "int", "i32", "sint32"],
    [35667]: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
    [35668]: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
    [35669]: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
    [5125]: [5125, 1, "uint", "u32", "uint32"],
    [36294]: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
    [36295]: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
    [36296]: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
    [35670]: [5126, 1, "bool", "f32", "float32"],
    [35671]: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
    [35672]: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
    [35673]: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
    [35674]: [5126, 8, "mat2", "mat2x2<f32>"],
    [35685]: [5126, 8, "mat2x3", "mat2x3<f32>"],
    [35686]: [5126, 8, "mat2x4", "mat2x4<f32>"],
    [35687]: [5126, 12, "mat3x2", "mat3x2<f32>"],
    [35675]: [5126, 12, "mat3", "mat3x3<f32>"],
    [35688]: [5126, 12, "mat3x4", "mat3x4<f32>"],
    [35689]: [5126, 16, "mat4x2", "mat4x2<f32>"],
    [35690]: [5126, 16, "mat4x3", "mat4x3<f32>"],
    [35676]: [5126, 16, "mat4", "mat4x4<f32>"]
  };
  function decodeGLUniformType(glUniformType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
    if (!typeAndSize) {
      throw new Error("uniform");
    }
    const [glType, components, , format] = typeAndSize;
    return { format, components, glType };
  }
  function decodeGLAttributeType(glAttributeType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
    if (!typeAndSize) {
      throw new Error("attribute");
    }
    const [, components, , shaderType, vertexFormat] = typeAndSize;
    const attributeType = shaderType;
    return { attributeType, vertexFormat, components };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout.js
  function getShaderLayout(gl, program) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock of uniformBlocks) {
      const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
        name: uniform.name,
        format: uniform.format,
        byteOffset: uniform.byteOffset,
        byteStride: uniform.byteStride,
        arrayLength: uniform.arrayLength
      }));
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniformBlock.name,
        location: uniformBlock.location,
        visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
        minBindingSize: uniformBlock.byteLength,
        uniforms: uniforms2
      });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms) {
      if (isSamplerUniform(uniform.type)) {
        const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
        shaderLayout.bindings.push({
          type: "texture",
          name: uniform.name,
          location: textureUnit,
          viewDimension,
          sampleType
        });
        uniform.textureUnit = textureUnit;
        textureUnit += 1;
      }
    }
    if (uniforms.length) {
      shaderLayout.uniforms = uniforms;
    }
    const varyings = readVaryings(gl, program);
    if (varyings?.length) {
      shaderLayout.varyings = varyings;
    }
    return shaderLayout;
  }
  function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count2 = gl.getProgramParameter(program, 35721);
    for (let index2 = 0; index2 < count2; index2++) {
      const activeInfo = gl.getActiveAttrib(program, index2);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: name13, type: compositeType } = activeInfo;
      const location = gl.getAttribLocation(program, name13);
      if (location >= 0) {
        const { attributeType } = decodeGLAttributeType(compositeType);
        const stepMode = /instance/i.test(name13) ? "instance" : "vertex";
        attributes.push({
          name: name13,
          location,
          stepMode,
          type: attributeType
        });
      }
    }
    attributes.sort((a3, b2) => a3.location - b2.location);
    return attributes;
  }
  function readVaryings(gl, program) {
    const varyings = [];
    const count2 = gl.getProgramParameter(program, 35971);
    for (let location = 0; location < count2; location++) {
      const activeInfo = gl.getTransformFeedbackVarying(program, location);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: name13, type: compositeType, size } = activeInfo;
      const { glType, components } = decodeGLUniformType(compositeType);
      const accessor = new Accessor({ type: glType, size: size * components });
      const varying = { location, name: name13, accessor };
      varyings.push(varying);
    }
    varyings.sort((a3, b2) => a3.location - b2.location);
    return varyings;
  }
  function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718);
    for (let i5 = 0; i5 < uniformCount; i5++) {
      const activeInfo = gl.getActiveUniform(program, i5);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: rawName, size, type } = activeInfo;
      const { name: name13, isArray: isArray4 } = parseUniformName(rawName);
      let webglLocation = gl.getUniformLocation(program, name13);
      const uniformInfo = {
        location: webglLocation,
        name: name13,
        size,
        type,
        isArray: isArray4
      };
      uniforms.push(uniformInfo);
      if (uniformInfo.size > 1) {
        for (let j2 = 0; j2 < uniformInfo.size; j2++) {
          const elementName = `${name13}[${j2}]`;
          webglLocation = gl.getUniformLocation(program, elementName);
          const arrayElementUniformInfo = {
            ...uniformInfo,
            name: elementName,
            location: webglLocation
          };
          uniforms.push(arrayElementUniformInfo);
        }
      }
    }
    return uniforms;
  }
  function readUniformBlocks(gl, program) {
    const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl.getProgramParameter(program, 35382);
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      const blockInfo = {
        name: gl.getActiveUniformBlockName(program, blockIndex) || "",
        location: getBlockParameter(blockIndex, 35391),
        byteLength: getBlockParameter(blockIndex, 35392),
        vertex: getBlockParameter(blockIndex, 35396),
        fragment: getBlockParameter(blockIndex, 35398),
        uniformCount: getBlockParameter(blockIndex, 35394),
        uniforms: []
      };
      const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
      const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
      const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
      const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
      const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
      for (let i5 = 0; i5 < blockInfo.uniformCount; ++i5) {
        const activeInfo = gl.getActiveUniform(program, uniformIndices[i5]);
        if (!activeInfo) {
          throw new Error("activeInfo");
        }
        blockInfo.uniforms.push({
          name: activeInfo.name,
          format: decodeGLUniformType(uniformType[i5]).format,
          type: uniformType[i5],
          arrayLength: uniformArrayLength[i5],
          byteOffset: uniformOffset[i5],
          byteStride: uniformStride[i5]
        });
      }
      uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a3, b2) => a3.location - b2.location);
    return uniformBlocks;
  }
  var SAMPLER_UNIFORMS_GL_TO_GPU = {
    [35678]: ["2d", "float"],
    [35680]: ["cube", "float"],
    [35679]: ["3d", "float"],
    [35682]: ["3d", "depth"],
    [36289]: ["2d-array", "float"],
    [36292]: ["2d-array", "depth"],
    [36293]: ["cube", "float"],
    [36298]: ["2d", "sint"],
    [36299]: ["3d", "sint"],
    [36300]: ["cube", "sint"],
    [36303]: ["2d-array", "uint"],
    [36306]: ["2d", "uint"],
    [36307]: ["3d", "uint"],
    [36308]: ["cube", "uint"],
    [36311]: ["2d-array", "uint"]
  };
  function getSamplerInfo(type) {
    const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
    if (!sampler) {
      throw new Error("sampler");
    }
    const [viewDimension, sampleType] = sampler;
    return { viewDimension, sampleType };
  }
  function parseUniformName(name13) {
    if (name13[name13.length - 1] !== "]") {
      return {
        name: name13,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = UNIFORM_NAME_REGEXP.exec(name13);
    if (!matches3 || matches3.length < 2) {
      throw new Error(`Failed to parse GLSL uniform name ${name13}`);
    }
    return {
      name: matches3[1],
      length: matches3[2] ? 1 : 0,
      isArray: Boolean(matches3[2])
    };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js
  function setUniform(gl, location, type, value) {
    const gl2 = gl;
    let uniformValue = value;
    if (uniformValue === true) {
      uniformValue = 1;
    }
    if (uniformValue === false) {
      uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
    switch (type) {
      case 35678:
      case 35680:
      case 35679:
      case 35682:
      case 36289:
      case 36292:
      case 36293:
      case 36298:
      case 36299:
      case 36300:
      case 36303:
      case 36306:
      case 36307:
      case 36308:
      case 36311:
        if (typeof value !== "number") {
          throw new Error("samplers must be set to integers");
        }
        return gl.uniform1i(location, value);
      case 5126:
        return gl.uniform1fv(location, arrayValue);
      case 35664:
        return gl.uniform2fv(location, arrayValue);
      case 35665:
        return gl.uniform3fv(location, arrayValue);
      case 35666:
        return gl.uniform4fv(location, arrayValue);
      case 5124:
        return gl.uniform1iv(location, arrayValue);
      case 35667:
        return gl.uniform2iv(location, arrayValue);
      case 35668:
        return gl.uniform3iv(location, arrayValue);
      case 35669:
        return gl.uniform4iv(location, arrayValue);
      case 35670:
        return gl.uniform1iv(location, arrayValue);
      case 35671:
        return gl.uniform2iv(location, arrayValue);
      case 35672:
        return gl.uniform3iv(location, arrayValue);
      case 35673:
        return gl.uniform4iv(location, arrayValue);
      case 5125:
        return gl2.uniform1uiv(location, arrayValue, 1);
      case 36294:
        return gl2.uniform2uiv(location, arrayValue, 2);
      case 36295:
        return gl2.uniform3uiv(location, arrayValue, 3);
      case 36296:
        return gl2.uniform4uiv(location, arrayValue, 4);
      case 35674:
        return gl.uniformMatrix2fv(location, false, arrayValue);
      case 35675:
        return gl.uniformMatrix3fv(location, false, arrayValue);
      case 35676:
        return gl.uniformMatrix4fv(location, false, arrayValue);
      case 35685:
        return gl2.uniformMatrix2x3fv(location, false, arrayValue);
      case 35686:
        return gl2.uniformMatrix2x4fv(location, false, arrayValue);
      case 35687:
        return gl2.uniformMatrix3x2fv(location, false, arrayValue);
      case 35688:
        return gl2.uniformMatrix3x4fv(location, false, arrayValue);
      case 35689:
        return gl2.uniformMatrix4x2fv(location, false, arrayValue);
      case 35690:
        return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error("Illegal uniform");
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js
  function getGLDrawMode(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 3;
      case "line-loop-webgl":
        return 2;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 5;
      case "triangle-fan-webgl":
        return 6;
      default:
        throw new Error(topology);
    }
  }
  function getGLPrimitive(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 1;
      case "line-loop-webgl":
        return 1;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 4;
      case "triangle-fan-webgl":
        return 4;
      default:
        throw new Error(topology);
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var WEBGLRenderPipeline = class extends RenderPipeline {
    device;
    handle;
    vs;
    fs;
    introspectedLayout;
    uniforms = {};
    bindings = {};
    varyings = null;
    _uniformCount = 0;
    _uniformSetters = {};
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.props.handle || this.device.gl.createProgram();
      this.device.setSpectorMetadata(this.handle, { id: this.props.id });
      this.vs = cast(props.vs);
      this.fs = cast(props.fs);
      const { varyings, bufferMode = 35981 } = props;
      if (varyings && varyings.length > 0) {
        this.varyings = varyings;
        this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._linkShaders();
      log2.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
      log2.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.shaderLayout = mergeShaderLayout(this.introspectedLayout, props.shaderLayout);
      switch (this.props.topology) {
        case "triangle-fan-webgl":
        case "line-loop-webgl":
          log2.warn(`Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`);
          break;
        default:
      }
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteProgram(this.handle);
        this.destroyed = true;
      }
    }
    setBindings(bindings, options) {
      for (const [name13, value] of Object.entries(bindings)) {
        const binding = this.shaderLayout.bindings.find((binding2) => binding2.name === name13) || this.shaderLayout.bindings.find((binding2) => binding2.name === `${name13}Uniforms`);
        if (!binding) {
          const validBindings = this.shaderLayout.bindings.map((binding2) => `"${binding2.name}"`).join(", ");
          if (!options?.disableWarnings) {
            log2.warn(`Unknown binding "${name13}" in render pipeline "${this.id}", expected one of ${validBindings}`)();
          }
          continue;
        }
        if (!value) {
          log2.warn(`Unsetting binding "${name13}" in render pipeline "${this.id}"`)();
        }
        switch (binding.type) {
          case "uniform":
            if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
              throw new Error("buffer value");
            }
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture value");
            }
            break;
          case "sampler":
            log2.warn(`Ignoring sampler ${name13}`)();
            break;
          default:
            throw new Error(binding.type);
        }
        this.bindings[name13] = value;
      }
    }
    draw(options) {
      const {
        renderPass,
        parameters: parameters2 = this.props.parameters,
        topology = this.props.topology,
        vertexArray,
        vertexCount,
        instanceCount,
        firstVertex = 0,
        transformFeedback
      } = options;
      const glDrawMode = getGLDrawMode(topology);
      const isIndexed = Boolean(vertexArray.indexBuffer);
      const glIndexType = vertexArray.indexBuffer?.glIndexType;
      const isInstanced = Number(instanceCount) > 0;
      if (this.linkStatus !== "success") {
        log2.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
        return false;
      }
      if (!this._areTexturesRenderable() || vertexCount === 0) {
        log2.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
        return false;
      }
      if (vertexCount === 0) {
        log2.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();
        return true;
      }
      this.device.gl.useProgram(this.handle);
      vertexArray.bindBeforeRender(renderPass);
      if (transformFeedback) {
        transformFeedback.begin(this.props.topology);
      }
      this._applyBindings();
      this._applyUniforms();
      const webglRenderPass = renderPass;
      withDeviceAndGLParameters(this.device, parameters2, webglRenderPass.glParameters, () => {
        if (isIndexed && isInstanced) {
          this.device.gl.drawElementsInstanced(
            glDrawMode,
            vertexCount || 0,
            glIndexType,
            firstVertex,
            instanceCount || 0
          );
        } else if (isIndexed) {
          this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
        } else if (isInstanced) {
          this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
        } else {
          this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
        }
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      vertexArray.unbindAfterRender(renderPass);
      return true;
    }
    setUniformsWebGL(uniforms) {
      const { bindings } = splitUniformsAndBindings(uniforms);
      Object.keys(bindings).forEach((name13) => {
        log2.warn(`Unsupported value "${JSON.stringify(bindings[name13])}" used in setUniforms() for key ${name13}. Use setBindings() instead?`)();
      });
      Object.assign(this.uniforms, uniforms);
    }
    async _linkShaders() {
      const { gl } = this.device;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log2.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      gl.linkProgram(this.handle);
      log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      if (log2.level === 0) {
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        const status2 = this._getLinkStatus();
        this._reportLinkStatus(status2);
        return;
      }
      log2.once(1, "RenderPipeline linking is asynchronous")();
      await this._waitForLinkComplete();
      log2.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
      const status = this._getLinkStatus();
      this._reportLinkStatus(status);
    }
    _reportLinkStatus(status) {
      switch (status) {
        case "success":
          return;
        default:
          if (this.vs.compilationStatus === "error") {
            this.vs.debugShader();
            throw new Error(`Error during compilation of shader ${this.vs.id}`);
          }
          if (this.fs?.compilationStatus === "error") {
            this.vs.debugShader();
            throw new Error(`Error during compilation of shader ${this.fs.id}`);
          }
          throw new Error(`Error during ${status}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
      }
    }
    _getLinkStatus() {
      const { gl } = this.device;
      const linked = gl.getProgramParameter(this.handle, 35714);
      if (!linked) {
        this.linkStatus = "error";
        return "linking";
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, 35715);
      if (!validated) {
        this.linkStatus = "error";
        return "validation";
      }
      this.linkStatus = "success";
      return "success";
    }
    async _waitForLinkComplete() {
      const waitMs = async (ms) => await new Promise((resolve2) => setTimeout(resolve2, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getProgramParameter(this.handle, 37297);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const [, texture] of Object.entries(this.bindings)) {
        if (texture instanceof WEBGLTexture) {
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
      }
      return texturesRenderable;
    }
    _applyBindings() {
      if (this.linkStatus !== "success") {
        return;
      }
      const { gl } = this.device;
      gl.useProgram(this.handle);
      let textureUnit = 0;
      let uniformBufferIndex = 0;
      for (const binding of this.shaderLayout.bindings) {
        const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
        if (!value) {
          throw new Error(`No value for binding ${binding.name} in ${this.id}`);
        }
        switch (binding.type) {
          case "uniform":
            const { name: name13 } = binding;
            const location = gl.getUniformBlockIndex(this.handle, name13);
            if (location === 4294967295) {
              throw new Error(`Invalid uniform block name ${name13}`);
            }
            gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
            if (value instanceof WEBGLBuffer) {
              gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
            } else {
              gl.bindBufferRange(
                35345,
                uniformBufferIndex,
                value.buffer.handle,
                value.offset || 0,
                value.size || value.buffer.byteLength - value.offset
              );
            }
            uniformBufferIndex += 1;
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture");
            }
            let texture;
            if (value instanceof WEBGLTextureView) {
              texture = value.texture;
            } else if (value instanceof WEBGLTexture) {
              texture = value;
            } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
              log2.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
              texture = value.colorAttachments[0].texture;
            } else {
              throw new Error("No texture");
            }
            gl.activeTexture(33984 + textureUnit);
            gl.bindTexture(texture.target, texture.handle);
            textureUnit += 1;
            break;
          case "sampler":
            break;
          case "storage":
          case "read-only-storage":
            throw new Error(`binding type '${binding.type}' not supported in WebGL`);
        }
      }
    }
    _applyUniforms() {
      for (const uniformLayout of this.shaderLayout.uniforms || []) {
        const { name: name13, location, type, textureUnit } = uniformLayout;
        const value = this.uniforms[name13] ?? textureUnit;
        if (value !== void 0) {
          setUniform(this.device.gl, location, type, value);
        }
      }
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js
  function cast2(value) {
    return value;
  }
  var WEBGLCommandBuffer = class extends CommandBuffer {
    device;
    commands = [];
    constructor(device) {
      super(device, {});
      this.device = device;
    }
    submitCommands(commands = this.commands) {
      for (const command of commands) {
        switch (command.name) {
          case "copy-buffer-to-buffer":
            _copyBufferToBuffer(this.device, command.options);
            break;
          case "copy-buffer-to-texture":
            _copyBufferToTexture(this.device, command.options);
            break;
          case "copy-texture-to-buffer":
            _copyTextureToBuffer(this.device, command.options);
            break;
          case "copy-texture-to-texture":
            _copyTextureToTexture(this.device, command.options);
            break;
        }
      }
    }
  };
  function _copyBufferToBuffer(device, options) {
    const source = cast2(options.source);
    const destination = cast2(options.destination);
    device.gl.bindBuffer(36662, source.handle);
    device.gl.bindBuffer(36663, destination.handle);
    device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
    device.gl.bindBuffer(36662, null);
    device.gl.bindBuffer(36663, null);
  }
  function _copyBufferToTexture(device, options) {
    throw new Error("Not implemented");
  }
  function _copyTextureToBuffer(device, options) {
    const {
      source,
      mipLevel = 0,
      aspect = "all",
      width = options.source.width,
      height = options.source.height,
      depthOrArrayLayers = 0,
      origin = [0, 0],
      destination,
      byteOffset = 0,
      bytesPerRow,
      rowsPerImage
    } = options;
    if (aspect !== "all") {
      throw new Error("not supported");
    }
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
      throw new Error("not implemented");
    }
    const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
    let prevHandle;
    try {
      const webglBuffer = destination;
      const sourceWidth = width || framebuffer.width;
      const sourceHeight = height || framebuffer.height;
      const sourceParams = getWebGLTextureParameters(framebuffer.texture.props.format);
      const sourceFormat = sourceParams.dataFormat;
      const sourceType = sourceParams.type;
      device.gl.bindBuffer(35051, webglBuffer.handle);
      prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
      device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
    } finally {
      device.gl.bindBuffer(35051, null);
      if (prevHandle !== void 0) {
        device.gl.bindFramebuffer(36160, prevHandle);
      }
      if (destroyFramebuffer) {
        framebuffer.destroy();
      }
    }
  }
  function _copyTextureToTexture(device, options) {
    const {
      source,
      destinationMipLevel = 0,
      origin = [0, 0],
      destinationOrigin = [0, 0],
      destination
    } = options;
    let {
      width = options.destination.width,
      height = options.destination.height
    } = options;
    const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
    const [sourceX, sourceY] = origin;
    const [destinationX, destinationY, destinationZ] = destinationOrigin;
    const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    let texture = null;
    let textureTarget;
    if (destination instanceof WEBGLTexture) {
      texture = destination;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      textureTarget = texture.target;
    } else {
      throw new Error("invalid destination");
    }
    switch (textureTarget) {
      case 3553:
      case 34067:
        device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
        break;
      default:
    }
    if (texture) {
      texture.unbind();
    }
    device.gl.bindFramebuffer(36160, prevHandle);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
  function getFramebuffer(source) {
    if (source instanceof Texture) {
      const { width, height, id } = source;
      const framebuffer = source.device.createFramebuffer({
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [source]
      });
      return { framebuffer, destroyFramebuffer: true };
    }
    return { framebuffer: source, destroyFramebuffer: false };
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js
  var WEBGLCommandEncoder = class extends CommandEncoder {
    device;
    commandBuffer;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.commandBuffer = new WEBGLCommandBuffer(device);
    }
    destroy() {
    }
    finish() {
      this.commandBuffer.submitCommands();
    }
    copyBufferToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
    }
    copyBufferToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
    }
    copyTextureToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
    }
    copyTextureToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    resolveQuerySet(querySet, destination, options) {
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js
  var WEBGLVertexArray = class extends VertexArray {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    device;
    handle;
    buffer = null;
    bufferValue = null;
    static isConstantAttributeZeroSupported(device) {
      return getBrowser() === "Chrome";
    }
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.device.gl.createVertexArray();
    }
    destroy() {
      super.destroy();
      if (this.buffer) {
        this.buffer?.destroy();
      }
      if (this.handle) {
        this.device.gl.deleteVertexArray(this.handle);
        this.handle = void 0;
      }
    }
    setIndexBuffer(indexBuffer) {
      const buffer = indexBuffer;
      if (buffer && buffer.glTarget !== 34963) {
        throw new Error("Use .setBuffer()");
      }
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
      this.indexBuffer = buffer;
      this.device.gl.bindVertexArray(null);
    }
    setBuffer(location, attributeBuffer) {
      const buffer = attributeBuffer;
      if (buffer.glTarget === 34963) {
        throw new Error("Use .setIndexBuffer()");
      }
      const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34962, buffer.handle);
      if (integer) {
        this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      this.device.gl.enableVertexAttribArray(location);
      this.device.gl.vertexAttribDivisor(location, divisor || 0);
      this.attributes[location] = buffer;
      this.device.gl.bindVertexArray(null);
    }
    setConstantWebGL(location, value) {
      this._enable(location, false);
      this.attributes[location] = value;
    }
    bindBeforeRender() {
      this.device.gl.bindVertexArray(this.handle);
      this._applyConstantAttributes();
    }
    unbindAfterRender() {
      this.device.gl.bindVertexArray(null);
    }
    _applyConstantAttributes() {
      for (let location = 0; location < this.maxVertexAttributes; ++location) {
        const constant = this.attributes[location];
        if (ArrayBuffer.isView(constant)) {
          this.device.setConstantAttributeWebGL(location, constant);
        }
      }
    }
    _getAccessor(location) {
      const attributeInfo = this.attributeInfos[location];
      if (!attributeInfo) {
        throw new Error(`Unknown attribute location ${location}`);
      }
      const glType = getGLFromVertexType(attributeInfo.bufferDataType);
      return {
        size: attributeInfo.bufferComponents,
        type: glType,
        stride: attributeInfo.byteStride,
        offset: attributeInfo.byteOffset,
        normalized: attributeInfo.normalized,
        integer: attributeInfo.integer,
        divisor: attributeInfo.stepMode === "instance" ? 1 : 0
      };
    }
    _enable(location, enable2 = true) {
      const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
      const canDisableAttribute = canDisableAttributeZero || location !== 0;
      if (enable2 || canDisableAttribute) {
        location = Number(location);
        this.device.gl.bindVertexArray(this.handle);
        if (enable2) {
          this.device.gl.enableVertexAttribArray(location);
        } else {
          this.device.gl.disableVertexAttribArray(location);
        }
        this.device.gl.bindVertexArray(null);
      }
    }
    getConstantBuffer(elementCount, value) {
      const constantValue = normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length6 = constantValue.length * elementCount;
      if (this.buffer && byteLength !== this.buffer.byteLength) {
        throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
      }
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || this.device.createBuffer({ byteLength });
      updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length6);
        fillArray({ target: typedArray, source: constantValue, start: 0, count: length6 });
        this.buffer.write(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
  };
  function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i5 = 0; i5 < v1.length; ++i5) {
      if (v1[i5] !== v2[i5]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js
  var WEBGLTransformFeedback = class extends TransformFeedback {
    device;
    gl;
    handle;
    layout;
    buffers = {};
    unusedBuffers = {};
    bindOnUse = true;
    _bound = false;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || this.gl.createTransformFeedback();
      this.layout = this.props.layout;
      if (props.buffers) {
        this.setBuffers(props.buffers);
      }
      Object.seal(this);
    }
    destroy() {
      this.gl.deleteTransformFeedback(this.handle);
      super.destroy();
    }
    begin(topology = "point-list") {
      this.gl.bindTransformFeedback(36386, this.handle);
      if (this.bindOnUse) {
        this._bindBuffers();
      }
      this.gl.beginTransformFeedback(getGLPrimitive(topology));
    }
    end() {
      this.gl.endTransformFeedback();
      if (!this.bindOnUse) {
        this._unbindBuffers();
      }
      this.gl.bindTransformFeedback(36386, null);
    }
    setBuffers(buffers) {
      this.buffers = {};
      this.unusedBuffers = {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
    }
    setBuffer(locationOrName, bufferOrRange) {
      const location = this._getVaryingIndex(locationOrName);
      const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
      if (location < 0) {
        this.unusedBuffers[locationOrName] = buffer;
        log2.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
        return;
      }
      this.buffers[location] = { buffer, byteLength, byteOffset };
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteLength);
      }
    }
    getBuffer(locationOrName) {
      if (isIndex(locationOrName)) {
        return this.buffers[locationOrName] || null;
      }
      const location = this._getVaryingIndex(locationOrName);
      return location >= 0 ? this.buffers[location] : null;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this.gl.bindTransformFeedback(36386, funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this.gl.bindTransformFeedback(36386, null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    _getBufferRange(bufferOrRange) {
      if (bufferOrRange instanceof WEBGLBuffer) {
        return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
      }
      const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
      return { buffer, byteOffset, byteLength };
    }
    _getVaryingIndex(locationOrName) {
      if (isIndex(locationOrName)) {
        return Number(locationOrName);
      }
      for (const varying of this.layout.varyings) {
        if (locationOrName === varying.name) {
          return varying.location;
        }
      }
      return -1;
    }
    _bindBuffers() {
      for (const bufferIndex in this.buffers) {
        const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
        this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
      }
    }
    _unbindBuffers() {
      for (const bufferIndex in this.buffers) {
        this.gl.bindBufferBase(35982, Number(bufferIndex), null);
      }
    }
    _bindBuffer(index2, buffer, byteOffset = 0, byteLength) {
      const handle = buffer && buffer.handle;
      if (!handle || byteLength === void 0) {
        this.gl.bindBufferBase(35982, index2, handle);
      } else {
        this.gl.bindBufferRange(35982, index2, handle, byteOffset, byteLength);
      }
    }
  };
  function isIndex(value) {
    if (typeof value === "number") {
      return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js
  var WEBGLQuerySet = class extends QuerySet {
    device;
    handle;
    target = null;
    _queryPending = false;
    _pollingPromise = null;
    get [Symbol.toStringTag]() {
      return "Query";
    }
    constructor(device, props) {
      super(device, props);
      this.device = device;
      if (props.count > 1) {
        throw new Error("WebGL QuerySet can only have one value");
      }
      this.handle = this.device.gl.createQuery();
      Object.seal(this);
    }
    destroy() {
      this.device.gl.deleteQuery(this.handle);
    }
    beginTimestampQuery() {
      return this._begin(35007);
    }
    endTimestampQuery() {
      this._end();
    }
    beginOcclusionQuery(options) {
      return this._begin(options?.conservative ? 36202 : 35887);
    }
    endOcclusionQuery() {
      this._end();
    }
    beginTransformFeedbackQuery() {
      return this._begin(35976);
    }
    endTransformFeedbackQuery() {
      this._end();
    }
    async resolveQuery() {
      const value = await this.pollQuery();
      return [value];
    }
    _begin(target) {
      if (this._queryPending) {
        return;
      }
      this.target = target;
      this.device.gl.beginQuery(this.target, this.handle);
      return;
    }
    _end() {
      if (this._queryPending) {
        return;
      }
      if (this.target) {
        this.device.gl.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return;
    }
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    isTimerDisjoint() {
      return this.device.gl.getParameter(36795);
    }
    getResult() {
      return this.device.gl.getQueryParameter(this.handle, 34918);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    pollQuery(limit = Number.POSITIVE_INFINITY) {
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter2 = 0;
      this._pollingPromise = new Promise((resolve2, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve2(this.getResult());
            this._pollingPromise = null;
          } else if (counter2++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
  };

  // ../../node_modules/@luma.gl/webgl/dist/classic/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert6(false);
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        assert6(false);
        return 0;
    }
  }

  // ../../node_modules/@luma.gl/webgl/dist/classic/copy-and-blit.js
  function readPixelsToArray(source, options) {
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408,
      sourceAttachment = 36064
    } = options || {};
    let {
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    assert6(framebuffer);
    const { gl, handle } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const attachment = sourceAttachment - 36064;
    sourceType = sourceType || framebuffer.colorAttachments[attachment]?.texture?.type || 5121;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return target;
  }
  function readPixelsToBuffer(source, options) {
    const { target, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
    let { sourceWidth, sourceHeight, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    assert6(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const webglFramebuffer = framebuffer;
    sourceType = sourceType || 5121;
    let webglBufferTarget = target;
    if (!webglBufferTarget) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
    }
    const commandEncoder = source.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
      source,
      width: sourceWidth,
      height: sourceHeight,
      origin: [sourceX, sourceY],
      destination: webglBufferTarget,
      byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return webglBufferTarget;
  }
  function getFramebuffer2(source) {
    if (!(source instanceof Framebuffer)) {
      return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
    }
    return { framebuffer: source, deleteFramebuffer: false };
  }
  function toFramebuffer(texture, props) {
    const { device, width, height, id } = texture;
    const framebuffer = device.createFramebuffer({
      ...props,
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [texture]
    });
    return framebuffer;
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType2 = getTypedArrayFromGLType(type, { clamped: false });
    const components = glFormatToComponents(format);
    return new ArrayType2(width * height * components);
  }

  // ../../node_modules/@luma.gl/webgl/dist/classic/clear.js
  var GL_DEPTH_BUFFER_BIT2 = 256;
  var GL_STENCIL_BUFFER_BIT2 = 1024;
  var GL_COLOR_BUFFER_BIT2 = 16384;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(device, options) {
    const { framebuffer = null, color = null, depth = null, stencil = null } = options || {};
    const parameters2 = {};
    if (framebuffer) {
      parameters2.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT2;
      if (color !== true) {
        parameters2.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT2;
      if (depth !== true) {
        parameters2.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT2;
      if (depth !== true) {
        parameters2.clearStencil = depth;
      }
    }
    assert6(clearFlags !== 0, ERR_ARGUMENTS);
    const gl = device.gl;
    withGLParameters(gl, parameters2, () => {
      gl.clear(clearFlags);
    });
  }

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js
  var LOG_LEVEL2 = 1;
  var _WebGLDevice = class extends Device {
    type = "webgl";
    handle;
    features;
    limits;
    info;
    canvasContext;
    lost;
    _resolveContextLost;
    static isSupported() {
      return typeof WebGL2RenderingContext !== "undefined";
    }
    static attach(gl) {
      if (gl instanceof _WebGLDevice) {
        return gl;
      }
      if (gl?.device instanceof Device) {
        return gl.device;
      }
      if (!isWebGL(gl)) {
        throw new Error("Invalid WebGL2RenderingContext");
      }
      return new _WebGLDevice({ gl });
    }
    static async create(props = {}) {
      log2.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
      const promises = [];
      if (props.debug) {
        promises.push(loadWebGLDeveloperTools());
      }
      if (props.spector) {
        promises.push(loadSpectorJS());
      }
      if (typeof props.canvas === "string") {
        promises.push(CanvasContext.pageLoaded);
      }
      const results = await Promise.allSettled(promises);
      for (const result of results) {
        if (result.status === "rejected") {
          log2.error(`Failed to initialize debug libraries ${result.reason}`)();
        }
      }
      log2.probe(LOG_LEVEL2 + 1, "DOM is loaded")();
      if (props.gl?.device) {
        log2.warn("reattaching existing device")();
        return _WebGLDevice.attach(props.gl);
      }
      const device = new _WebGLDevice(props);
      const message2 = `Created ${device.type}${device.debug ? " debug" : ""} context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
      log2.probe(LOG_LEVEL2, message2)();
      log2.table(LOG_LEVEL2, device.info)();
      log2.groupEnd(LOG_LEVEL2)();
      return device;
    }
    constructor(props) {
      super({ ...props, id: props.id || uid("webgl-device") });
      const device = props.gl?.device;
      if (device) {
        throw new Error(`WebGL context already attached to device ${device.id}`);
      }
      const canvas2 = props.gl?.canvas || props.canvas;
      this.canvasContext = new WebGLCanvasContext(this, { ...props, canvas: canvas2 });
      this.lost = new Promise((resolve2) => {
        this._resolveContextLost = resolve2;
      });
      let gl = props.gl || null;
      gl ||= createBrowserContext(this.canvasContext.canvas, {
        ...props,
        onContextLost: (event) => this._resolveContextLost?.({
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        })
      });
      if (!gl) {
        throw new Error("WebGL context creation failed");
      }
      this.handle = gl;
      this.gl = gl;
      this.gl.device = this;
      this.gl._version = 2;
      this.info = getDeviceInfo(this.gl, this._extensions);
      this.limits = new WebGLDeviceLimits(this.gl);
      this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props.disabledFeatures);
      if (this.props.initalizeFeatures) {
        this.features.initializeFeatures();
      }
      this.canvasContext.resize();
      const { enable: enable2 = true, copyState = false } = props;
      trackContextState(this.gl, {
        enable: enable2,
        copyState,
        log: (...args) => log2.log(1, ...args)()
      });
      if (props.debug) {
        this.gl = makeDebugContext(this.gl, { ...props, throwOnError: true });
        this.debug = true;
        log2.level = Math.max(log2.level, 1);
        log2.warn("WebGL debug mode activated. Performance reduced.")();
      }
      if (props.spector) {
        this.spectorJS = initializeSpectorJS({ ...this.props, canvas: this.handle.canvas });
      }
    }
    destroy() {
    }
    get isLost() {
      return this.gl.isContextLost();
    }
    getSize() {
      return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
    }
    isTextureFormatSupported(format) {
      return isTextureFormatSupported(this.gl, format, this._extensions);
    }
    isTextureFormatFilterable(format) {
      return isTextureFormatFilterable(this.gl, format, this._extensions);
    }
    isTextureFormatRenderable(format) {
      return isTextureFormatRenderable(this.gl, format, this._extensions);
    }
    createCanvasContext(props) {
      throw new Error("WebGL only supports a single canvas");
    }
    createBuffer(props) {
      const newProps = this._getBufferProps(props);
      return new WEBGLBuffer(this, newProps);
    }
    _createTexture(props) {
      return new WEBGLTexture(this, props);
    }
    createExternalTexture(props) {
      throw new Error("createExternalTexture() not implemented");
    }
    createSampler(props) {
      return new WEBGLSampler(this, props);
    }
    createShader(props) {
      return new WEBGLShader(this, props);
    }
    createFramebuffer(props) {
      return new WEBGLFramebuffer(this, props);
    }
    createVertexArray(props) {
      return new WEBGLVertexArray(this, props);
    }
    createTransformFeedback(props) {
      return new WEBGLTransformFeedback(this, props);
    }
    createQuerySet(props) {
      return new WEBGLQuerySet(this, props);
    }
    createRenderPipeline(props) {
      return new WEBGLRenderPipeline(this, props);
    }
    beginRenderPass(props) {
      return new WEBGLRenderPass(this, props);
    }
    createComputePipeline(props) {
      throw new Error("ComputePipeline not supported in WebGL");
    }
    beginComputePass(props) {
      throw new Error("ComputePass not supported in WebGL");
    }
    renderPass = null;
    createCommandEncoder(props) {
      return new WEBGLCommandEncoder(this, props);
    }
    submit() {
      this.renderPass?.end();
      this.renderPass = null;
    }
    readPixelsToArrayWebGL(source, options) {
      return readPixelsToArray(source, options);
    }
    readPixelsToBufferWebGL(source, options) {
      return readPixelsToBuffer(source, options);
    }
    setParametersWebGL(parameters2) {
      setGLParameters(this.gl, parameters2);
    }
    getParametersWebGL(parameters2) {
      return getGLParameters(this.gl, parameters2);
    }
    withParametersWebGL(parameters2, func) {
      return withGLParameters(this.gl, parameters2, func);
    }
    clearWebGL(options) {
      clear(this, options);
    }
    resetWebGL() {
      log2.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
      resetGLParameters(this.gl);
    }
    gl;
    debug = false;
    _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
    _extensions = {};
    _polyfilled = false;
    spectorJS;
    loseDevice() {
      let deviceLossTriggered = false;
      const extensions = this.getExtension("WEBGL_lose_context");
      const ext = extensions.WEBGL_lose_context;
      if (ext) {
        deviceLossTriggered = true;
        ext.loseContext();
      }
      this._resolveContextLost?.({
        reason: "destroyed",
        message: "Application triggered context loss"
      });
      return deviceLossTriggered;
    }
    pushState() {
      pushContextState(this.gl);
    }
    popState() {
      popContextState(this.gl);
    }
    setSpectorMetadata(handle, props) {
      handle.__SPECTOR_Metadata = props;
    }
    getGLKey(value, gl) {
      gl = gl || this.gl2 || this.gl;
      const number = Number(value);
      for (const key in gl) {
        if (gl[key] === number) {
          return `GL.${key}`;
        }
      }
      return String(value);
    }
    _constants;
    setConstantAttributeWebGL(location, constant) {
      const maxVertexAttributes = this.limits.maxVertexAttributes;
      this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
      const currentConstant = this._constants[location];
      if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
        log2.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
      }
      this._constants[location] = constant;
      switch (constant.constructor) {
        case Float32Array:
          setConstantFloatArray(this, location, constant);
          break;
        case Int32Array:
          setConstantIntArray(this, location, constant);
          break;
        case Uint32Array:
          setConstantUintArray(this, location, constant);
          break;
        default:
          assert6(false);
      }
    }
    getExtension(name13) {
      getWebGLExtension(this.gl, name13, this._extensions);
      return this._extensions;
    }
  };
  var WebGLDevice = _WebGLDevice;
  __publicField(WebGLDevice, "type", "webgl");
  function isWebGL(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function setConstantFloatArray(device, location, array) {
    switch (array.length) {
      case 1:
        device.gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        device.gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        device.gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        device.gl.vertexAttrib4fv(location, array);
        break;
      default:
        assert6(false);
    }
  }
  function setConstantIntArray(device, location, array) {
    device.gl.vertexAttribI4iv(location, array);
  }
  function setConstantUintArray(device, location, array) {
    device.gl.vertexAttribI4uiv(location, array);
  }
  function compareConstantArrayValues2(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i5 = 0; i5 < v1.length; ++i5) {
      if (v1[i5] !== v2[i5]) {
        return false;
      }
    }
    return true;
  }

  // ../../node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  var hammerjs = __toESM(require_hammer());

  // ../../node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  function some(array, predict) {
    for (let i5 = 0; i5 < array.length; i5++) {
      if (predict(array[i5])) {
        return true;
      }
    }
    return false;
  }
  function enhancePointerEventInput(PointerEventInput2) {
    const oldHandler = PointerEventInput2.prototype.handler;
    PointerEventInput2.prototype.handler = function handler(ev) {
      const store = this.store;
      if (ev.button > 0 && ev.type === "pointerdown") {
        if (!some(store, (e3) => e3.pointerId === ev.pointerId)) {
          store.push(ev);
        }
      }
      oldHandler.call(this, ev);
    };
  }
  function enhanceMouseInput(MouseInput2) {
    MouseInput2.prototype.handler = function handler(ev) {
      let eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button >= 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which === 0) {
        eventType = INPUT_END;
      }
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: "mouse",
        srcEvent: ev
      });
    };
  }

  // ../../node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  enhancePointerEventInput(hammerjs.PointerEventInput);
  enhanceMouseInput(hammerjs.MouseInput);
  var Manager2 = hammerjs.Manager;
  var hammer_browser_default = hammerjs;

  // ../../node_modules/mjolnir.js/dist/esm/inputs/input.js
  var Input = class {
    constructor(element, callback, options) {
      this.element = element;
      this.callback = callback;
      this.options = { enable: true, ...options };
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/constants.js
  var RECOGNIZERS = hammer_browser_default ? [
    [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
    [hammer_browser_default.Rotate, { enable: false }],
    [hammer_browser_default.Pinch, { enable: false }],
    [hammer_browser_default.Swipe, { enable: false }],
    [hammer_browser_default.Pan, { threshold: 0, enable: false }],
    [hammer_browser_default.Press, { enable: false }],
    [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
    [hammer_browser_default.Tap, { event: "anytap", enable: false }],
    [hammer_browser_default.Tap, { enable: false }]
  ] : null;
  var RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ["rotate", "pinch", "pan"],
    rotate: ["pinch"],
    pinch: ["pan"],
    pan: ["press", "doubletap", "anytap", "tap"],
    doubletap: ["anytap"],
    anytap: ["tap"]
  };
  var RECOGNIZER_FALLBACK_MAP = {
    doubletap: ["tap"]
  };
  var BASIC_EVENT_ALIASES = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
  };
  var INPUT_EVENT_TYPES = {
    KEY_EVENTS: ["keydown", "keyup"],
    MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
    WHEEL_EVENTS: [
      "wheel",
      "mousewheel"
    ]
  };
  var EVENT_RECOGNIZER_MAP = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
  };
  var GESTURE_EVENT_ALIASES = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
  };

  // ../../node_modules/mjolnir.js/dist/esm/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_4 = typeof window !== "undefined" ? window : global;
  var passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return true;
      }
    };
    window_4.addEventListener("test", null, options);
    window_4.removeEventListener("test", null);
  } catch (err) {
    passiveSupported = false;
  }

  // ../../node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
  var EVENT_TYPE = "wheel";
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        let value = event.deltaY;
        if (window_4.WheelEvent) {
          if (firefox && event.deltaMode === window_4.WheelEvent.DOM_DELTA_PIXEL) {
            value /= window_4.devicePixelRatio;
          }
          if (event.deltaMode === window_4.WheelEvent.DOM_DELTA_LINE) {
            value *= WHEEL_DELTA_PER_LINE;
          }
        }
        if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value) {
          value = value * SHIFT_MULTIPLIER;
        }
        this.callback({
          type: EVENT_TYPE,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          delta: -value,
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      this.events = (this.options.events || []).concat(WHEEL_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/inputs/move-input.js
  var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
  var MOVE_EVENT_TYPE = "pointermove";
  var OVER_EVENT_TYPE = "pointerover";
  var OUT_EVENT_TYPE = "pointerout";
  var ENTER_EVENT_TYPE = "pointerenter";
  var LEAVE_EVENT_TYPE = "pointerleave";
  var MoveInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleEnterEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      };
      this.pressed = false;
      const { enable: enable2 } = this.options;
      this.enableMoveEvent = enable2;
      this.enableLeaveEvent = enable2;
      this.enableEnterEvent = enable2;
      this.enableOutEvent = enable2;
      this.enableOverEvent = enable2;
      this.events = (this.options.events || []).concat(MOUSE_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }
      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }
      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }
      if (eventType === ENTER_EVENT_TYPE) {
        this.enableEnterEvent = enabled;
      }
      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
    handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === "mouseover") {
          this._emit(OVER_EVENT_TYPE, event);
        }
      }
    }
    handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === "mouseout") {
          this._emit(OUT_EVENT_TYPE, event);
        }
      }
    }
    handleEnterEvent(event) {
      if (this.enableEnterEvent) {
        if (event.type === "mouseenter") {
          this._emit(ENTER_EVENT_TYPE, event);
        }
      }
    }
    handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === "mouseleave") {
          this._emit(LEAVE_EVENT_TYPE, event);
        }
      }
    }
    handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case "mousedown":
            if (event.button >= 0) {
              this.pressed = true;
            }
            break;
          case "mousemove":
            if (event.which === 0) {
              this.pressed = false;
            }
            if (!this.pressed) {
              this._emit(MOVE_EVENT_TYPE, event);
            }
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
      }
    }
    _emit(type, event) {
      this.callback({
        type,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/inputs/key-input.js
  var { KEY_EVENTS } = INPUT_EVENT_TYPES;
  var DOWN_EVENT_TYPE = "keydown";
  var UP_EVENT_TYPE = "keyup";
  var KeyInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        const targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: DOWN_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: UP_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      };
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      this.events = (this.options.events || []).concat(KEY_EVENTS);
      element.tabIndex = this.options.tabIndex || 0;
      element.style.outline = "none";
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }
      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
  var EVENT_TYPE2 = "contextmenu";
  var ContextmenuInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: EVENT_TYPE2,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE2) {
        this.options.enable = enabled;
      }
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_WHICH_LEFT = 1;
  var MOUSE_EVENT_WHICH_MIDDLE = 2;
  var MOUSE_EVENT_WHICH_RIGHT = 3;
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    const eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    const { buttons, button, which } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
      leftButton = which === MOUSE_EVENT_WHICH_LEFT;
      middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
      rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === DOWN_EVENT) {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
  }
  function getOffsetPosition(event, rootElement) {
    const center = event.center;
    if (!center) {
      return null;
    }
    const rect = rootElement.getBoundingClientRect();
    const scaleX2 = rect.width / rootElement.offsetWidth || 1;
    const scaleY2 = rect.height / rootElement.offsetHeight || 1;
    const offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return { center, offsetCenter };
  }

  // ../../node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = class {
    constructor(eventManager) {
      this.handleEvent = (event) => {
        if (this.isEmpty()) {
          return;
        }
        const mjolnirEvent = this._normalizeEvent(event);
        let target = event.srcEvent.target;
        while (target && target !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target);
          if (mjolnirEvent.handled) {
            return;
          }
          target = target.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      };
      this.eventManager = eventManager;
      this.handlers = [];
      this.handlersByElement = /* @__PURE__ */ new Map();
      this._active = false;
    }
    isEmpty() {
      return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
      const { handlers, handlersByElement } = this;
      let opts = DEFAULT_OPTIONS;
      if (typeof options === "string" || options && options.addEventListener) {
        opts = { ...DEFAULT_OPTIONS, srcElement: options };
      } else if (options) {
        opts = { ...DEFAULT_OPTIONS, ...options };
      }
      let entries = handlersByElement.get(opts.srcElement);
      if (!entries) {
        entries = [];
        handlersByElement.set(opts.srcElement, entries);
      }
      const entry = {
        type,
        handler,
        srcElement: opts.srcElement,
        priority: opts.priority
      };
      if (once) {
        entry.once = true;
      }
      if (passive) {
        entry.passive = true;
      }
      handlers.push(entry);
      this._active = this._active || !entry.passive;
      let insertPosition = entries.length - 1;
      while (insertPosition >= 0) {
        if (entries[insertPosition].priority >= entry.priority) {
          break;
        }
        insertPosition--;
      }
      entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
      const { handlers, handlersByElement } = this;
      for (let i5 = handlers.length - 1; i5 >= 0; i5--) {
        const entry = handlers[i5];
        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i5, 1);
          const entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);
          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
      this._active = handlers.some((entry) => !entry.passive);
    }
    _emit(event, srcElement) {
      const entries = this.handlersByElement.get(srcElement);
      if (entries) {
        let immediatePropagationStopped = false;
        const stopPropagation = () => {
          event.handled = true;
        };
        const stopImmediatePropagation = () => {
          event.handled = true;
          immediatePropagationStopped = true;
        };
        const entriesToRemove = [];
        for (let i5 = 0; i5 < entries.length; i5++) {
          const { type, handler, once } = entries[i5];
          handler({
            ...event,
            type,
            stopPropagation,
            stopImmediatePropagation
          });
          if (once) {
            entriesToRemove.push(entries[i5]);
          }
          if (immediatePropagationStopped) {
            break;
          }
        }
        for (let i5 = 0; i5 < entriesToRemove.length; i5++) {
          const { type, handler } = entriesToRemove[i5];
          this.remove(type, handler);
        }
      }
    }
    _normalizeEvent(event) {
      const rootElement = this.eventManager.getElement();
      return {
        ...event,
        ...whichButtons(event),
        ...getOffsetPosition(event, rootElement),
        preventDefault: () => {
          event.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement
      };
    }
  };

  // ../../node_modules/mjolnir.js/dist/esm/event-manager.js
  var DEFAULT_OPTIONS2 = {
    events: null,
    recognizers: null,
    recognizerOptions: {},
    Manager: Manager2,
    touchAction: "none",
    tabIndex: 0
  };
  var EventManager = class {
    constructor(element = null, options) {
      this._onBasicInput = (event) => {
        const { srcEvent } = event;
        const alias = BASIC_EVENT_ALIASES[srcEvent.type];
        if (alias) {
          this.manager.emit(alias, event);
        }
      };
      this._onOtherEvent = (event) => {
        this.manager.emit(event.type, event);
      };
      this.options = { ...DEFAULT_OPTIONS2, ...options };
      this.events = /* @__PURE__ */ new Map();
      this.setElement(element);
      const { events } = this.options;
      if (events) {
        this.on(events);
      }
    }
    getElement() {
      return this.element;
    }
    setElement(element) {
      if (this.element) {
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }
      const { options } = this;
      const ManagerClass = options.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options.touchAction,
        recognizers: options.recognizers || RECOGNIZERS
      }).on("hammer.input", this._onBasicInput);
      if (!options.recognizers) {
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name13) => {
          const recognizer = this.manager.get(name13);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name13].forEach((otherName) => {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }
      for (const recognizerName in options.recognizerOptions) {
        const recognizer = this.manager.get(recognizerName);
        if (recognizer) {
          const recognizerOption = options.recognizerOptions[recognizerName];
          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      }
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new KeyInput(element, this._onOtherEvent, {
        enable: false,
        tabIndex: options.tabIndex
      });
      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
        enable: false
      });
      for (const [eventAlias, eventRegistrar] of this.events) {
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
          this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
    }
    destroy() {
      if (this.element) {
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    }
    on(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
      this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
      this._removeEventHandler(event, handler);
    }
    _toggleRecognizer(name13, enabled) {
      const { manager } = this;
      if (!manager) {
        return;
      }
      const recognizer = manager.get(name13);
      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({ enable: enabled });
        const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name13];
        if (fallbackRecognizers && !this.options.recognizers) {
          fallbackRecognizers.forEach((otherName) => {
            const otherRecognizer = manager.get(otherName);
            if (enabled) {
              otherRecognizer.requireFailure(name13);
              recognizer.dropRequireFailure(otherName);
            } else {
              otherRecognizer.dropRequireFailure(name13);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name13, enabled);
      this.moveInput.enableEventType(name13, enabled);
      this.keyInput.enableEventType(name13, enabled);
      this.contextmenuInput.enableEventType(name13, enabled);
    }
    _addEventHandler(event, handler, opts, once, passive) {
      if (typeof event !== "string") {
        opts = handler;
        for (const eventName in event) {
          this._addEventHandler(eventName, event[eventName], opts, once, passive);
        }
        return;
      }
      const { manager, events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      let eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        eventRegistrar = new EventRegistrar(this);
        events.set(eventAlias, eventRegistrar);
        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
      eventRegistrar.add(event, handler, opts, once, passive);
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
      }
    }
    _removeEventHandler(event, handler) {
      if (typeof event !== "string") {
        for (const eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
        return;
      }
      const { events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      const eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        return;
      }
      eventRegistrar.remove(event, handler);
      if (eventRegistrar.isEmpty()) {
        const { recognizerName } = eventRegistrar;
        let isRecognizerUsed = false;
        for (const eh of events.values()) {
          if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
            isRecognizerUsed = true;
            break;
          }
        }
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
  };

  // ../core/src/lib/deck.ts
  function noop3() {
  }
  var getCursor = ({ isDragging }) => isDragging ? "grabbing" : "grab";
  var defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    parameters: {},
    parent: null,
    device: null,
    deviceProps: { type: "webgl" },
    gl: null,
    glOptions: {},
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    widgets: [],
    onDeviceInitialized: noop3,
    onWebGLInitialized: noop3,
    onResize: noop3,
    onViewStateChange: noop3,
    onInteractionStateChange: noop3,
    onBeforeRender: noop3,
    onAfterRender: noop3,
    onLoad: noop3,
    onError: (error) => log_default.error(error.message, error.cause)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  var Deck = class {
    constructor(props) {
      this.width = 0;
      this.height = 0;
      this.userData = {};
      this.device = null;
      this.canvas = null;
      this.viewManager = null;
      this.layerManager = null;
      this.effectManager = null;
      this.deckRenderer = null;
      this.deckPicker = null;
      this.eventManager = null;
      this.widgetManager = null;
      this.tooltip = null;
      this.animationLoop = null;
      this.cursorState = {
        isHovering: false,
        isDragging: false
      };
      this.stats = new Stats({ id: "deck.gl" });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this._needsRedraw = "Initial render";
      this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      };
      this._lastPointerDownInfo = null;
      this._onPointerMove = (event) => {
        const { _pickRequest } = this;
        if (event.type === "pointerleave") {
          _pickRequest.x = -1;
          _pickRequest.y = -1;
          _pickRequest.radius = 0;
        } else if (event.leftButton || event.rightButton) {
          return;
        } else {
          const pos = event.offsetCenter;
          if (!pos) {
            return;
          }
          _pickRequest.x = pos.x;
          _pickRequest.y = pos.y;
          _pickRequest.radius = this.props.pickingRadius;
        }
        if (this.layerManager) {
          this.layerManager.context.mousePosition = { x: _pickRequest.x, y: _pickRequest.y };
        }
        _pickRequest.event = event;
      };
      this._onEvent = (event) => {
        const eventOptions = EVENTS[event.type];
        const pos = event.offsetCenter;
        if (!eventOptions || !pos || !this.layerManager) {
          return;
        }
        const layers = this.layerManager.getLayers();
        const info = this.deckPicker.getLastPickedObject(
          {
            x: pos.x,
            y: pos.y,
            layers,
            viewports: this.getViewports(pos)
          },
          this._lastPointerDownInfo
        );
        const { layer } = info;
        const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
        const rootHandler = this.props[eventOptions.handler];
        let handled = false;
        if (layerHandler) {
          handled = layerHandler.call(layer, info, event);
        }
        if (!handled) {
          rootHandler?.(info, event);
          this.widgetManager.onEvent(info, event);
        }
      };
      this._onPointerDown = (event) => {
        const pos = event.offsetCenter;
        const pickedInfo = this._pick("pickObject", "pickObject Time", {
          x: pos.x,
          y: pos.y,
          radius: this.props.pickingRadius
        });
        this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
      };
      this.props = { ...defaultProps, ...props };
      props = this.props;
      if (props.viewState && props.initialViewState) {
        log_default.warn(
          "View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update."
        )();
      }
      this.viewState = this.props.initialViewState;
      if (props.device) {
        this.device = props.device;
      } else if (props.gl) {
        if (props.gl instanceof WebGLRenderingContext) {
          log_default.error("WebGL1 context not supported.")();
        }
        this.device = WebGLDevice.attach(props.gl);
      }
      let deviceOrPromise = this.device;
      if (!deviceOrPromise) {
        luma.registerDevices([WebGLDevice]);
        deviceOrPromise = luma.createDevice({
          ...props.deviceProps,
          canvas: this._createCanvas(props)
        });
      }
      this.animationLoop = this._createAnimationLoop(deviceOrPromise, props);
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setOptions(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    finalize() {
      this.animationLoop?.stop();
      this.animationLoop?.destroy();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;
      this.layerManager?.finalize();
      this.layerManager = null;
      this.viewManager?.finalize();
      this.viewManager = null;
      this.effectManager?.finalize();
      this.effectManager = null;
      this.deckRenderer?.finalize();
      this.deckRenderer = null;
      this.deckPicker?.finalize();
      this.deckPicker = null;
      this.eventManager?.destroy();
      this.eventManager = null;
      this.widgetManager?.finalize();
      this.widgetManager = null;
      if (!this.props.canvas && !this.props.device && this.canvas) {
        this.canvas.parentElement?.removeChild(this.canvas);
        this.canvas = null;
      }
    }
    setProps(props) {
      this.stats.get("setProps Time").timeStart();
      if ("onLayerHover" in props) {
        log_default.removed("onLayerHover", "onHover")();
      }
      if ("onLayerClick" in props) {
        log_default.removed("onLayerClick", "onClick")();
      }
      if (props.initialViewState && !deepEqual2(this.props.initialViewState, props.initialViewState, 3)) {
        this.viewState = props.initialViewState;
      }
      Object.assign(this.props, props);
      this._setCanvasSize(this.props);
      const resolvedProps = Object.create(this.props);
      Object.assign(resolvedProps, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      });
      this.animationLoop?.setProps(resolvedProps);
      if (this.layerManager) {
        this.viewManager.setProps(resolvedProps);
        this.layerManager.activateViewport(this.getViewports()[0]);
        this.layerManager.setProps(resolvedProps);
        this.effectManager.setProps(resolvedProps);
        this.deckRenderer.setProps(resolvedProps);
        this.deckPicker.setProps(resolvedProps);
        this.widgetManager.setProps(resolvedProps);
      }
      this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = { clearRedrawFlags: false }) {
      if (!this.layerManager) {
        return false;
      }
      if (this.props._animate) {
        return "Deck._animate";
      }
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
    redraw(reason) {
      if (!this.layerManager) {
        return;
      }
      let redrawReason = this.needsRedraw({ clearRedrawFlags: true });
      redrawReason = reason || redrawReason;
      if (!redrawReason) {
        return;
      }
      this.stats.get("Redraw Count").incrementCount();
      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
    get isInitialized() {
      return this.viewManager !== null;
    }
    getViews() {
      assert9(this.viewManager);
      return this.viewManager.views;
    }
    getViewports(rect) {
      assert9(this.viewManager);
      return this.viewManager.getViewports(rect);
    }
    getCanvas() {
      return this.canvas;
    }
    pickObject(opts) {
      const infos = this._pick("pickObject", "pickObject Time", opts).result;
      return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
      opts.depth = opts.depth || 10;
      return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
      return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
      for (const id in resources) {
        this.layerManager.resourceManager.add({ resourceId: id, data: resources[id], forceUpdate });
      }
    }
    _removeResources(resourceIds) {
      for (const id of resourceIds) {
        this.layerManager.resourceManager.remove(id);
      }
    }
    _addDefaultEffect(effect) {
      this.effectManager.addDefaultEffect(effect);
    }
    _addDefaultShaderModule(module) {
      this.layerManager.addDefaultShaderModule(module);
    }
    _removeDefaultShaderModule(module) {
      this.layerManager?.removeDefaultShaderModule(module);
    }
    _pick(method, statKey, opts) {
      assert9(this.deckPicker);
      const { stats } = this;
      stats.get("Pick Count").incrementCount();
      stats.get(statKey).timeStart();
      const infos = this.deckPicker[method]({
        layers: this.layerManager.getLayers(opts),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(opts),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...opts
      });
      stats.get(statKey).timeEnd();
      return infos;
    }
    _createCanvas(props) {
      let canvas2 = props.canvas;
      if (typeof canvas2 === "string") {
        canvas2 = document.getElementById(canvas2);
        assert9(canvas2);
      }
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.id = props.id || "deckgl-overlay";
        const parent = props.parent || document.body;
        parent.appendChild(canvas2);
      }
      Object.assign(canvas2.style, props.style);
      return canvas2;
    }
    _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }
      const { width, height } = props;
      if (width || width === 0) {
        const cssWidth = Number.isFinite(width) ? `${width}px` : width;
        this.canvas.style.width = cssWidth;
      }
      if (height || height === 0) {
        const cssHeight = Number.isFinite(height) ? `${height}px` : height;
        this.canvas.style.position = props.style?.position || "absolute";
        this.canvas.style.height = cssHeight;
      }
    }
    _updateCanvasSize() {
      const { canvas: canvas2 } = this;
      if (!canvas2) {
        return;
      }
      const newWidth = canvas2.clientWidth ?? canvas2.width;
      const newHeight = canvas2.clientHeight ?? canvas2.height;
      if (newWidth !== this.width || newHeight !== this.height) {
        this.width = newWidth;
        this.height = newHeight;
        this.viewManager?.setProps({ width: newWidth, height: newHeight });
        this.layerManager?.activateViewport(this.getViewports()[0]);
        this.props.onResize({ width: newWidth, height: newHeight });
      }
    }
    _createAnimationLoop(deviceOrPromise, props) {
      const {
        gl,
        onError,
        useDevicePixels
      } = props;
      return new AnimationLoop({
        device: deviceOrPromise,
        useDevicePixels,
        autoResizeDrawingBuffer: !gl,
        autoResizeViewport: false,
        onInitialize: (context) => this._setDevice(context.device),
        onRender: this._onRenderFrame.bind(this),
        onError
      });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      const { views } = this.props;
      const normalizedViews = Array.isArray(views) ? views : views ? [views] : [new MapView({ id: "default-view" })];
      if (normalizedViews.length && this.props.controller) {
        normalizedViews[0].props.controller = this.props.controller;
      }
      return normalizedViews;
    }
    _onContextLost() {
      const { onError } = this.props;
      if (this.animationLoop && onError) {
        onError(new Error("WebGL context is lost"));
      }
    }
    _pickAndCallback() {
      const { _pickRequest } = this;
      if (_pickRequest.event) {
        const { result, emptyInfo } = this._pick("pickObject", "pickObject Time", _pickRequest);
        this.cursorState.isHovering = result.length > 0;
        let pickedInfo = emptyInfo;
        let handled = false;
        for (const info of result) {
          pickedInfo = info;
          handled = info.layer?.onHover(info, _pickRequest.event) || handled;
        }
        if (!handled) {
          this.props.onHover?.(pickedInfo, _pickRequest.event);
          this.widgetManager.onHover(pickedInfo, _pickRequest.event);
        }
        _pickRequest.event = null;
      }
    }
    _updateCursor() {
      const container = this.props.parent || this.canvas;
      if (container) {
        container.style.cursor = this.props.getCursor(this.cursorState);
      }
    }
    _setDevice(device) {
      this.device = device;
      if (!this.animationLoop) {
        return;
      }
      if (!this.canvas) {
        this.canvas = this.device.canvasContext?.canvas;
      }
      this.device.setParametersWebGL({
        blend: true,
        blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: GLEnum.LEQUAL
      });
      this.props.onDeviceInitialized(this.device);
      if (this.device instanceof WebGLDevice) {
        this.props.onWebGLInitialized(this.device.gl);
      }
      const timeline = new Timeline();
      timeline.play();
      this.animationLoop.attachTimeline(timeline);
      this.eventManager = new EventManager(this.props.parent || this.canvas, {
        touchAction: this.props.touchAction,
        recognizerOptions: this.props.eventRecognizerOptions,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const eventType in EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }
      this.viewManager = new ViewManager({
        timeline,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const viewport = this.viewManager.getViewports()[0];
      this.layerManager = new LayerManager(this.device, {
        deck: this,
        stats: this.stats,
        viewport,
        timeline
      });
      this.effectManager = new EffectManager({
        deck: this,
        device: this.device
      });
      this.deckRenderer = new DeckRenderer(this.device);
      this.deckPicker = new DeckPicker(this.device);
      this.widgetManager = new WidgetManager({
        deck: this,
        parentElement: this.canvas?.parentElement
      });
      this.widgetManager.addDefault(new Tooltip());
      this.setProps(this.props);
      this._updateCanvasSize();
      this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
      const { device, gl } = this.layerManager.context;
      this.props.onBeforeRender({ device, gl });
      const opts = {
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...renderOptions
      };
      this.deckRenderer?.renderLayers(opts);
      if (opts.pass === "screen") {
        this.widgetManager.onRedraw({
          viewports: opts.viewports,
          layers: opts.layers
        });
      }
      this.props.onAfterRender({ device, gl });
    }
    _onRenderFrame() {
      this._getFrameStats();
      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();
        this.stats.reset();
        log_default.table(4, this.metrics)();
        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }
      this._updateCanvasSize();
      this._updateCursor();
      this.layerManager.updateLayers();
      this._pickAndCallback();
      this.redraw();
      if (this.viewManager) {
        this.viewManager.updateViewStates();
      }
    }
    _onViewStateChange(params) {
      const viewState = this.props.onViewStateChange(params) || params.viewState;
      if (this.viewState) {
        this.viewState = { ...this.viewState, [params.viewId]: viewState };
        if (!this.props.viewState) {
          if (this.viewManager) {
            this.viewManager.setProps({ viewState: this.viewState });
          }
        }
      }
    }
    _onInteractionStateChange(interactionState) {
      this.cursorState.isDragging = interactionState.isDragging || false;
      this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
      const { stats } = this;
      stats.get("frameRate").timeEnd();
      stats.get("frameRate").timeStart();
      const animationLoopStats = this.animationLoop.stats;
      stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
      stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const { metrics, stats } = this;
      metrics.fps = stats.get("frameRate").getHz();
      metrics.setPropsTime = stats.get("setProps Time").time;
      metrics.updateAttributesTime = stats.get("Update Attributes").time;
      metrics.framesRedrawn = stats.get("Redraw Count").count;
      metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
      metrics.pickCount = stats.get("Pick Count").count;
      metrics.gpuTime = stats.get("GPU Time").time;
      metrics.cpuTime = stats.get("CPU Time").time;
      metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
      metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
      const memoryStats = luma.stats.get("Memory Usage");
      metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
      metrics.textureMemory = memoryStats.get("Texture Memory").count;
      metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
      metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
  };
  Deck.defaultProps = defaultProps;
  Deck.VERSION = VERSION4;

  // ../core/src/lib/attribute/gl-utils.ts
  function typedArrayFromDataType(type) {
    switch (type) {
      case "float64":
        return Float64Array;
      case "uint8":
      case "unorm8":
        return Uint8ClampedArray;
      default:
        return getTypedArrayFromDataType(type);
    }
  }
  var dataTypeFromTypedArray = getDataTypeFromTypedArray2;
  function getBufferAttributeLayout(name13, accessor) {
    return {
      attribute: name13,
      format: accessor.size > 1 ? `${accessor.type}x${accessor.size}` : accessor.type,
      byteOffset: accessor.offset || 0
    };
  }
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function bufferLayoutEqual(accessor1, accessor2) {
    return accessor1.type === accessor2.type && accessor1.size === accessor2.size && getStride(accessor1) === getStride(accessor2) && (accessor1.offset || 0) === (accessor2.offset || 0);
  }

  // ../core/src/lib/attribute/data-column.ts
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    const stride = getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
      ...shaderAttributeOptions,
      offset,
      stride
    };
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: {
        ...resolvedOptions,
        offset: resolvedOptions.offset + baseAccessor.size * 4
      }
    };
  }
  var DataColumn = class {
    constructor(device, opts, state) {
      this._buffer = null;
      this.device = device;
      this.id = opts.id || "";
      this.size = opts.size || 1;
      const logicalType = opts.logicalType || opts.type;
      const doublePrecision = logicalType === "float64";
      let { defaultValue: defaultValue2 } = opts;
      defaultValue2 = Number.isFinite(defaultValue2) ? [defaultValue2] : defaultValue2 || new Array(this.size).fill(0);
      let bufferType;
      if (doublePrecision) {
        bufferType = "float32";
      } else if (!logicalType && opts.isIndexed) {
        bufferType = "uint32";
      } else {
        bufferType = logicalType || "float32";
      }
      let defaultType = typedArrayFromDataType(logicalType || bufferType);
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      this.value = null;
      this.settings = {
        ...opts,
        defaultType,
        defaultValue: defaultValue2,
        logicalType,
        type: bufferType,
        normalized: bufferType.includes("norm"),
        size: this.size,
        bytesPerElement: defaultType.BYTES_PER_ELEMENT
      };
      this.state = {
        ...state,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
    }
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      return this._buffer;
    }
    get byteOffset() {
      const accessor = this.getAccessor();
      if (accessor.vertexOffset) {
        return accessor.vertexOffset * getStride(accessor);
      }
      return 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(n3) {
      this.state.numInstances = n3;
    }
    delete() {
      if (this._buffer) {
        this._buffer.delete();
        this._buffer = null;
      }
      typed_array_manager_default.release(this.state.allocatedValue);
    }
    getBuffer() {
      if (this.state.constant) {
        return null;
      }
      return this.state.externalBuffer || this._buffer;
    }
    getValue(attributeName = this.id, options = null) {
      const result = {};
      if (this.state.constant) {
        const value = this.value;
        if (options) {
          const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
          const offset = shaderAttributeDef.offset / value.BYTES_PER_ELEMENT;
          const size = shaderAttributeDef.size || this.size;
          result[attributeName] = value.subarray(offset, offset + size);
        } else {
          result[attributeName] = value;
        }
      } else {
        result[attributeName] = this.getBuffer();
      }
      if (this.doublePrecision) {
        if (this.value instanceof Float64Array) {
          result[`${attributeName}64Low`] = result[attributeName];
        } else {
          result[`${attributeName}64Low`] = new Float32Array(this.size);
        }
      }
      return result;
    }
    getBufferLayout(attributeName = this.id, options = null) {
      const accessor = this.getAccessor();
      const attributes = [];
      const result = {
        name: this.id,
        byteStride: getStride(accessor),
        attributes
      };
      if (this.doublePrecision) {
        const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(
          accessor,
          options || {}
        );
        attributes.push(
          getBufferAttributeLayout(attributeName, { ...accessor, ...doubleShaderAttributeDefs.high }),
          getBufferAttributeLayout(`${attributeName}64Low`, {
            ...accessor,
            ...doubleShaderAttributeDefs.low
          })
        );
      } else if (options) {
        const shaderAttributeDef = resolveShaderAttribute(accessor, options);
        attributes.push(
          getBufferAttributeLayout(attributeName, { ...accessor, ...shaderAttributeDef })
        );
      } else {
        attributes.push(getBufferAttributeLayout(attributeName, accessor));
      }
      return result;
    }
    setAccessor(accessor) {
      this.state.bufferAccessor = accessor;
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    getBounds() {
      if (this.state.bounds) {
        return this.state.bounds;
      }
      let result = null;
      if (this.state.constant && this.value) {
        const min4 = Array.from(this.value);
        result = [min4, min4];
      } else {
        const { value, numInstances, size } = this;
        const len4 = numInstances * size;
        if (value && len4 && value.length >= len4) {
          const min4 = new Array(size).fill(Infinity);
          const max4 = new Array(size).fill(-Infinity);
          for (let i5 = 0; i5 < len4; ) {
            for (let j2 = 0; j2 < size; j2++) {
              const v2 = value[i5++];
              if (v2 < min4[j2])
                min4[j2] = v2;
              if (v2 > max4[j2])
                max4[j2] = v2;
            }
          }
          result = [min4, max4];
        }
      }
      this.state.bounds = result;
      return result;
    }
    setData(data) {
      const { state } = this;
      let opts;
      if (ArrayBuffer.isView(data)) {
        opts = { value: data };
      } else if (data instanceof Buffer2) {
        opts = { buffer: data };
      } else {
        opts = data;
      }
      const accessor = { ...this.settings, ...opts };
      if (ArrayBuffer.isView(opts.value)) {
        if (!opts.type) {
          const is64Bit = this.doublePrecision && opts.value instanceof Float64Array;
          if (is64Bit) {
            accessor.type = "float32";
          } else {
            const type = dataTypeFromTypedArray(opts.value);
            accessor.type = accessor.normalized ? type.replace("int", "norm") : type;
          }
        }
        accessor.bytesPerElement = opts.value.BYTES_PER_ELEMENT;
        accessor.stride = getStride(accessor);
      }
      state.bounds = null;
      if (opts.constant) {
        let value = opts.value;
        value = this._normalizeValue(value, [], 0);
        if (this.settings.normalized) {
          value = this.normalizeConstant(value);
        }
        const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
        if (!hasChanged) {
          return false;
        }
        state.externalBuffer = null;
        state.constant = true;
        this.value = ArrayBuffer.isView(value) ? value : new Float32Array(value);
      } else if (opts.buffer) {
        const buffer = opts.buffer;
        state.externalBuffer = buffer;
        state.constant = false;
        this.value = opts.value || null;
      } else if (opts.value) {
        this._checkExternalBuffer(opts);
        let value = opts.value;
        state.externalBuffer = null;
        state.constant = false;
        this.value = value;
        let { buffer } = this;
        const stride = getStride(accessor);
        const byteOffset = (accessor.vertexOffset || 0) * stride;
        if (this.doublePrecision && value instanceof Float64Array) {
          value = toDoublePrecisionArray(value, accessor);
        }
        if (this.settings.isIndexed) {
          const ArrayType2 = this.settings.defaultType;
          if (value.constructor !== ArrayType2) {
            value = new ArrayType2(value);
          }
        }
        const requiredBufferSize = value.byteLength + byteOffset + stride * 2;
        if (!buffer || buffer.byteLength < requiredBufferSize) {
          buffer = this._createBuffer(requiredBufferSize);
        }
        buffer.write(value, byteOffset);
      }
      this.setAccessor(accessor);
      return true;
    }
    updateSubBuffer(opts = {}) {
      this.state.bounds = null;
      const value = this.value;
      const { startOffset = 0, endOffset } = opts;
      this.buffer.write(
        this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
          size: this.size,
          startIndex: startOffset,
          endIndex: endOffset
        }) : value.subarray(startOffset, endOffset),
        startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
      );
    }
    allocate(numInstances, copy6 = false) {
      const { state } = this;
      const oldValue = state.allocatedValue;
      const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy: copy6
      });
      this.value = value;
      const { byteOffset } = this;
      let { buffer } = this;
      if (!buffer || buffer.byteLength < value.byteLength + byteOffset) {
        buffer = this._createBuffer(value.byteLength + byteOffset);
        if (copy6 && oldValue) {
          buffer.write(
            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
            byteOffset
          );
        }
      }
      state.allocatedValue = value;
      state.constant = false;
      state.externalBuffer = null;
      this.setAccessor(this.settings);
      return true;
    }
    _checkExternalBuffer(opts) {
      const { value } = opts;
      if (!ArrayBuffer.isView(value)) {
        throw new Error(`Attribute ${this.id} value is not TypedArray`);
      }
      const ArrayType2 = this.settings.defaultType;
      let illegalArrayType = false;
      if (this.doublePrecision) {
        illegalArrayType = value.BYTES_PER_ELEMENT < 4;
      }
      if (illegalArrayType) {
        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);
      }
      if (!(value instanceof ArrayType2) && this.settings.normalized && !("normalized" in opts)) {
        log_default.warn(`Attribute ${this.id} is normalized`)();
      }
    }
    normalizeConstant(value) {
      switch (this.settings.type) {
        case "snorm8":
          return new Float32Array(value).map((x3) => (x3 + 128) / 255 * 2 - 1);
        case "snorm16":
          return new Float32Array(value).map((x3) => (x3 + 32768) / 65535 * 2 - 1);
        case "unorm8":
          return new Float32Array(value).map((x3) => x3 / 255);
        case "unorm16":
          return new Float32Array(value).map((x3) => x3 / 65535);
        default:
          return value;
      }
    }
    _normalizeValue(value, out, start) {
      const { defaultValue: defaultValue2, size } = this.settings;
      if (Number.isFinite(value)) {
        out[start] = value;
        return out;
      }
      if (!value) {
        let i5 = size;
        while (--i5 >= 0) {
          out[start + i5] = defaultValue2[i5];
        }
        return out;
      }
      switch (size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue2[3];
        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue2[2];
        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue2[1];
        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue2[0];
          break;
        default:
          let i5 = size;
          while (--i5 >= 0) {
            out[start + i5] = Number.isFinite(value[i5]) ? value[i5] : defaultValue2[i5];
          }
      }
      return out;
    }
    _areValuesEqual(value1, value2) {
      if (!value1 || !value2) {
        return false;
      }
      const { size } = this;
      for (let i5 = 0; i5 < size; i5++) {
        if (value1[i5] !== value2[i5]) {
          return false;
        }
      }
      return true;
    }
    _createBuffer(byteLength) {
      if (this._buffer) {
        this._buffer.destroy();
      }
      const { isIndexed, type } = this.settings;
      this._buffer = this.device.createBuffer({
        ...this._buffer?.props,
        id: this.id,
        usage: isIndexed ? Buffer2.INDEX : Buffer2.VERTEX,
        indexType: isIndexed ? type : void 0,
        byteLength
      });
      return this._buffer;
    }
  };

  // ../core/src/utils/iterable-utils.ts
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data, startRow = 0, endRow = Infinity) {
    let iterable = EMPTY_ARRAY;
    const objectInfo = {
      index: -1,
      data,
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return { iterable, objectInfo };
  }
  function isAsyncIterable2(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, options) {
    const { size, stride, offset, startIndices, nested } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_, { index: index2, target }) => {
      if (!startIndices) {
        const sourceIndex = index2 * elementStride + elementOffset;
        for (let j2 = 0; j2 < size; j2++) {
          target[j2] = typedArray[sourceIndex + j2];
        }
        return target;
      }
      const startIndex = startIndices[index2];
      const endIndex = startIndices[index2 + 1] || vertexCount;
      let result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          const sourceIndex = i5 * elementStride + elementOffset;
          target = new Array(size);
          for (let j2 = 0; j2 < size; j2++) {
            target[j2] = typedArray[sourceIndex + j2];
          }
          result[i5 - startIndex] = target;
        }
      } else if (elementStride === size) {
        result = typedArray.subarray(
          startIndex * size + elementOffset,
          endIndex * size + elementOffset
        );
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size);
        let targetIndex = 0;
        for (let i5 = startIndex; i5 < endIndex; i5++) {
          const sourceIndex = i5 * elementStride + elementOffset;
          for (let j2 = 0; j2 < size; j2++) {
            result[targetIndex++] = typedArray[sourceIndex + j2];
          }
        }
      }
      return result;
    };
  }

  // ../core/src/utils/range.ts
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add6(rangeList, range) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    if (range[0] >= range[1]) {
      return rangeList;
    }
    const newRangeList = [];
    const len4 = rangeList.length;
    let insertPosition = 0;
    for (let i5 = 0; i5 < len4; i5++) {
      const range0 = rangeList[i5];
      if (range0[1] < range[0]) {
        newRangeList.push(range0);
        insertPosition = i5 + 1;
      } else if (range0[0] > range[1]) {
        newRangeList.push(range0);
      } else {
        range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
  }

  // ../core/src/lib/attribute/transition-settings.ts
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: (t3) => t3
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = { type: "interpolation", duration: userSettings };
    }
    const type = userSettings.type || "interpolation";
    return {
      ...DEFAULT_TRANSITION_SETTINGS[type],
      ...layerSettings,
      ...userSettings,
      type
    };
  }

  // ../core/src/lib/attribute/attribute.ts
  var Attribute2 = class extends DataColumn {
    constructor(device, opts) {
      super(device, opts, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        layoutChanged: false,
        updateRanges: FULL
      });
      this.constant = false;
      this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
      Object.seal(this.settings);
      Object.seal(this.state);
      this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(layout) {
      this.state.startIndices = layout;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags = false } = {}) {
      const needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
    layoutChanged() {
      return this.state.layoutChanged;
    }
    setAccessor(accessor) {
      this.state.layoutChanged ||= !bufferLayoutEqual(accessor, this.getAccessor());
      super.setAccessor(accessor);
    }
    getUpdateTriggers() {
      const { accessor } = this.settings;
      return [this.id].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
      if (!opts || !this.supportsTransition()) {
        return null;
      }
      const { accessor } = this.settings;
      const layerSettings = this.settings.transition;
      const userSettings = Array.isArray(accessor) ? opts[accessor.find((a3) => opts[a3])] : opts[accessor];
      return normalizeTransitionSettings(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
      this.state.needsUpdate = this.state.needsUpdate || reason;
      this.setNeedsRedraw(reason);
      if (dataRange) {
        const { startRow = 0, endRow = Infinity } = dataRange;
        this.state.updateRanges = add6(this.state.updateRanges, [startRow, endRow]);
      } else {
        this.state.updateRanges = FULL;
      }
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false;
      this.state.updateRanges = EMPTY;
    }
    setNeedsRedraw(reason = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
      const { state, settings } = this;
      if (settings.noAlloc) {
        return false;
      }
      if (settings.update) {
        super.allocate(numInstances, state.updateRanges !== FULL);
        return true;
      }
      return false;
    }
    updateBuffer({
      numInstances,
      data,
      props,
      context
    }) {
      if (!this.needsUpdate()) {
        return false;
      }
      const {
        state: { updateRanges },
        settings: { update, noAlloc }
      } = this;
      let updated = true;
      if (update) {
        for (const [startRow, endRow] of updateRanges) {
          update.call(context, this, { data, startRow, endRow, props, numInstances });
        }
        if (!this.value) {
        } else if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
          this.setData({
            value: this.value,
            constant: this.constant
          });
          this.constant = false;
        } else {
          for (const [startRow, endRow] of updateRanges) {
            const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
            const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
            super.updateSubBuffer({ startOffset, endOffset });
          }
        }
        this._checkAttributeArray();
      } else {
        updated = false;
      }
      this.clearNeedsUpdate();
      this.setNeedsRedraw();
      return updated;
    }
    setConstantValue(value) {
      if (value === void 0 || typeof value === "function") {
        return false;
      }
      const hasChanged = this.setData({ constant: true, value });
      if (hasChanged) {
        this.setNeedsRedraw();
      }
      this.clearNeedsUpdate();
      return true;
    }
    setExternalBuffer(buffer) {
      const { state } = this;
      if (!buffer) {
        state.lastExternalBuffer = null;
        return false;
      }
      this.clearNeedsUpdate();
      if (state.lastExternalBuffer === buffer) {
        return true;
      }
      state.lastExternalBuffer = buffer;
      this.setNeedsRedraw();
      this.setData(buffer);
      return true;
    }
    setBinaryValue(buffer, startIndices = null) {
      const { state, settings } = this;
      if (!buffer) {
        state.binaryValue = null;
        state.binaryAccessor = null;
        return false;
      }
      if (settings.noAlloc) {
        return false;
      }
      if (state.binaryValue === buffer) {
        this.clearNeedsUpdate();
        return true;
      }
      state.binaryValue = buffer;
      this.setNeedsRedraw();
      const needsUpdate = settings.transform || startIndices !== this.startIndices;
      if (needsUpdate) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = { value: buffer };
        }
        const binaryValue = buffer;
        assert9(ArrayBuffer.isView(binaryValue.value), `invalid ${settings.accessor}`);
        const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
        state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
          size: binaryValue.size || this.size,
          stride: binaryValue.stride,
          offset: binaryValue.offset,
          startIndices,
          nested: needsNormalize
        });
        return false;
      }
      this.clearNeedsUpdate();
      this.setData(buffer);
      return true;
    }
    getVertexOffset(row) {
      const { startIndices } = this;
      const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
      return vertexIndex * this.size;
    }
    getValue() {
      const shaderAttributeDefs = this.settings.shaderAttributes;
      const result = super.getValue();
      if (!shaderAttributeDefs) {
        return result;
      }
      for (const shaderAttributeName in shaderAttributeDefs) {
        Object.assign(
          result,
          super.getValue(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])
        );
      }
      return result;
    }
    getBufferLayout() {
      this.state.layoutChanged = false;
      const shaderAttributeDefs = this.settings.shaderAttributes;
      const result = super.getBufferLayout();
      if (!shaderAttributeDefs) {
        return result;
      }
      for (const shaderAttributeName in shaderAttributeDefs) {
        const map3 = super.getBufferLayout(
          shaderAttributeName,
          shaderAttributeDefs[shaderAttributeName]
        );
        result.attributes.push(...map3.attributes);
      }
      return result;
    }
    _autoUpdater(attribute, {
      data,
      startRow,
      endRow,
      props,
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const { settings, state, value, size, startIndices } = attribute;
      const { accessor, transform: transform2 } = settings;
      const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
      assert9(typeof accessorFunc === "function", `accessor "${accessor}" is not a function`);
      let i5 = attribute.getVertexOffset(startRow);
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let objectValue = accessorFunc(object, objectInfo);
        if (transform2) {
          objectValue = transform2.call(this, objectValue);
        }
        if (startIndices) {
          const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
          if (objectValue && Array.isArray(objectValue[0])) {
            let startIndex = i5;
            for (const item of objectValue) {
              attribute._normalizeValue(item, value, startIndex);
              startIndex += size;
            }
          } else if (objectValue && objectValue.length > size) {
            value.set(objectValue, i5);
          } else {
            attribute._normalizeValue(objectValue, objectInfo.target, 0);
            fillArray2({
              target: value,
              source: objectInfo.target,
              start: i5,
              count: numVertices
            });
          }
          i5 += numVertices * size;
        } else {
          attribute._normalizeValue(objectValue, value, i5);
          i5 += size;
        }
      }
    }
    _validateAttributeUpdaters() {
      const { settings } = this;
      const hasUpdater = settings.noAlloc || typeof settings.update === "function";
      if (!hasUpdater) {
        throw new Error(`Attribute ${this.id} missing update or accessor`);
      }
    }
    _checkAttributeArray() {
      const { value } = this;
      const limit = Math.min(4, this.size);
      if (value && value.length >= limit) {
        let valid = true;
        switch (limit) {
          case 4:
            valid = valid && Number.isFinite(value[3]);
          case 3:
            valid = valid && Number.isFinite(value[2]);
          case 2:
            valid = valid && Number.isFinite(value[1]);
          case 1:
            valid = valid && Number.isFinite(value[0]);
            break;
          default:
            valid = false;
        }
        if (!valid) {
          throw new Error(`Illegal attribute generated for ${this.id}`);
        }
      }
    }
  };

  // ../core/src/utils/array-utils.ts
  function padArrayChunk(options) {
    const { source, target, start = 0, size, getData } = options;
    const end = options.end || target.length;
    const sourceLength = source.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
      target.set(source.subarray(0, targetLength), start);
      return;
    }
    target.set(source, start);
    if (!getData) {
      return;
    }
    let i5 = sourceLength;
    while (i5 < targetLength) {
      const datum = getData(i5, source);
      for (let j2 = 0; j2 < size; j2++) {
        target[start + i5] = datum[j2] || 0;
        i5++;
      }
    }
  }
  function padArray({
    source,
    target,
    size,
    getData,
    sourceStartIndices,
    targetStartIndices
  }) {
    if (!sourceStartIndices || !targetStartIndices) {
      padArrayChunk({
        source,
        target,
        size,
        getData
      });
      return target;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i5, chunk) => getData(i5 + targetIndex, chunk));
    const n3 = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (let i5 = 1; i5 < n3; i5++) {
      const nextSourceIndex = sourceStartIndices[i5] * size;
      const nextTargetIndex = targetStartIndices[i5] * size;
      padArrayChunk({
        source: source.subarray(sourceIndex, nextSourceIndex),
        target,
        start: targetIndex,
        end: nextTargetIndex,
        size,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) {
      padArrayChunk({
        source: [],
        target,
        start: targetIndex,
        size,
        getData: getChunkData
      });
    }
    return target;
  }

  // ../core/src/transitions/gpu-transition-utils.ts
  function cloneAttribute(attribute) {
    const { device, settings, value } = attribute;
    const newAttribute = new Attribute2(device, settings);
    newAttribute.setData({
      value: value instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
      normalized: settings.normalized
    });
    return newAttribute;
  }
  function getAttributeTypeFromSize(size) {
    switch (size) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`No defined attribute type for size "${size}"`);
    }
  }
  function getFloat32VertexFormat(size) {
    switch (size) {
      case 1:
        return "float32";
      case 2:
        return "float32x2";
      case 3:
        return "float32x3";
      case 4:
        return "float32x4";
      default:
        throw new Error("invalid type size");
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    const { doublePrecision, settings, value, size } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    let maxVertexOffset = 0;
    const { shaderAttributes } = attribute.settings;
    if (shaderAttributes) {
      for (const shaderAttribute of Object.values(shaderAttributes)) {
        maxVertexOffset = Math.max(maxVertexOffset, shaderAttribute.vertexOffset ?? 0);
      }
    }
    return (settings.noAlloc ? value.length : (numInstances + maxVertexOffset) * size) * multiplier;
  }
  function matchBuffer({
    device,
    source,
    target
  }) {
    if (!target || target.byteLength < source.byteLength) {
      target?.destroy();
      target = device.createBuffer({
        byteLength: source.byteLength,
        usage: source.usage
      });
    }
    return target;
  }
  function padBuffer({
    device,
    buffer,
    attribute,
    fromLength,
    toLength,
    fromStartIndices,
    getData = (x3) => x3
  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const targetByteOffset = attribute.settings.bytesPerElement < 4 ? byteOffset / attribute.settings.bytesPerElement * 4 : byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && buffer && fromLength >= toLength) {
      return buffer;
    }
    const ArrayType2 = attribute.value instanceof Float64Array ? Float32Array : attribute.value.constructor;
    const toData = isConstant ? attribute.value : new ArrayType2(
      attribute.getBuffer().readSyncWebGL(byteOffset, toLength * ArrayType2.BYTES_PER_ELEMENT).buffer
    );
    if (attribute.settings.normalized && !isConstant) {
      const getter = getData;
      getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i5, chunk) => getData(toData, chunk) : (i5, chunk) => getData(toData.subarray(i5 + byteOffset, i5 + byteOffset + size), chunk);
    const source = buffer ? new Float32Array(buffer.readSyncWebGL(targetByteOffset, fromLength * 4).buffer) : new Float32Array(0);
    const target = new Float32Array(toLength);
    padArray({
      source,
      target,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size,
      getData: getMissingData
    });
    if (!buffer || buffer.byteLength < target.byteLength + targetByteOffset) {
      buffer?.destroy();
      buffer = device.createBuffer({
        byteLength: target.byteLength + targetByteOffset,
        usage: GLEnum.DYNAMIC_COPY
      });
    }
    buffer.write(target, targetByteOffset);
    return buffer;
  }

  // ../core/src/transitions/gpu-transition.ts
  var GPUTransitionBase = class {
    constructor({
      device,
      attribute,
      timeline
    }) {
      this.buffers = [];
      this.currentLength = 0;
      this.device = device;
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = cloneAttribute(attribute);
      this.currentStartIndices = attribute.startIndices;
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances, duration = Infinity) {
      this.settings = transitionSettings;
      this.currentStartIndices = this.attribute.startIndices;
      this.currentLength = getAttributeBufferLength(this.attribute, numInstances);
      this.transition.start({ ...transitionSettings, duration });
    }
    update() {
      const updated = this.transition.update();
      if (updated) {
        this.onUpdate();
      }
      return updated;
    }
    setBuffer(buffer) {
      this.attributeInTransition.setData({
        buffer,
        normalized: this.attribute.settings.normalized,
        value: this.attributeInTransition.value
      });
    }
    cancel() {
      this.transition.cancel();
    }
    delete() {
      this.cancel();
      for (const buffer of this.buffers) {
        buffer.destroy();
      }
      this.buffers.length = 0;
    }
  };

  // ../core/src/transitions/gpu-interpolation-transition.ts
  var GPUInterpolationTransition = class extends GPUTransitionBase {
    constructor({
      device,
      attribute,
      timeline
    }) {
      super({ device, attribute, timeline });
      this.type = "interpolation";
      this.transform = getTransform(device, attribute);
    }
    start(transitionSettings, numInstances) {
      const prevLength = this.currentLength;
      const prevStartIndices = this.currentStartIndices;
      super.start(transitionSettings, numInstances, transitionSettings.duration);
      if (transitionSettings.duration <= 0) {
        this.transition.cancel();
        return;
      }
      const { buffers, attribute } = this;
      cycleBuffers(buffers);
      buffers[0] = padBuffer({
        device: this.device,
        buffer: buffers[0],
        attribute,
        fromLength: prevLength,
        toLength: this.currentLength,
        fromStartIndices: prevStartIndices,
        getData: transitionSettings.enter
      });
      buffers[1] = matchBuffer({
        device: this.device,
        source: buffers[0],
        target: buffers[1]
      });
      this.setBuffer(buffers[1]);
      const { transform: transform2 } = this;
      const model = transform2.model;
      model.setVertexCount(Math.floor(this.currentLength / attribute.size));
      if (attribute.isConstant) {
        model.setAttributes({ aFrom: buffers[0] });
        model.setConstantAttributes({ aTo: attribute.value });
      } else {
        model.setAttributes({
          aFrom: buffers[0],
          aTo: attribute.getBuffer()
        });
      }
      transform2.transformFeedback.setBuffers({ vCurrent: buffers[1] });
    }
    onUpdate() {
      const { duration, easing } = this.settings;
      const { time } = this.transition;
      let t3 = time / duration;
      if (easing) {
        t3 = easing(t3);
      }
      const { model } = this.transform;
      model.setUniforms({ time: t3 });
      const gl = model.device.gl;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      this.transform.run({ discard: true });
    }
    delete() {
      super.delete();
      this.transform.destroy();
    }
  };
  var vs6 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
  function getTransform(device, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new BufferTransform(device, {
      vs: vs6,
      bufferLayout: [
        { name: "aFrom", format: getFloat32VertexFormat(attribute.size) },
        { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
      ],
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"]
    });
  }

  // ../core/src/transitions/gpu-spring-transition.ts
  var GPUSpringTransition = class extends GPUTransitionBase {
    constructor({
      device,
      attribute,
      timeline
    }) {
      super({ device, attribute, timeline });
      this.type = "spring";
      this.texture = getTexture(device);
      this.framebuffer = getFramebuffer3(device, this.texture);
      this.transform = getTransform2(device, attribute);
    }
    start(transitionSettings, numInstances) {
      const prevLength = this.currentLength;
      const prevStartIndices = this.currentStartIndices;
      super.start(transitionSettings, numInstances);
      const { buffers, attribute } = this;
      for (let i5 = 0; i5 < 2; i5++) {
        buffers[i5] = padBuffer({
          device: this.device,
          buffer: buffers[i5],
          attribute,
          fromLength: prevLength,
          toLength: this.currentLength,
          fromStartIndices: prevStartIndices,
          getData: transitionSettings.enter
        });
      }
      buffers[2] = matchBuffer({
        device: this.device,
        source: buffers[0],
        target: buffers[2]
      });
      this.setBuffer(buffers[1]);
      const { model } = this.transform;
      model.setVertexCount(Math.floor(this.currentLength / attribute.size));
      if (attribute.isConstant) {
        model.setConstantAttributes({ aTo: attribute.value });
      } else {
        model.setAttributes({ aTo: attribute.getBuffer() });
      }
    }
    onUpdate() {
      const { buffers, transform: transform2, framebuffer, transition } = this;
      const settings = this.settings;
      transform2.model.setAttributes({
        aPrev: buffers[0],
        aCur: buffers[1]
      });
      transform2.transformFeedback.setBuffers({ vNext: buffers[2] });
      transform2.model.setUniforms({
        stiffness: settings.stiffness,
        damping: settings.damping
      });
      transform2.run({
        framebuffer,
        discard: false,
        parameters: { viewport: [0, 0, 1, 1] },
        clearColor: [0, 0, 0, 0]
      });
      cycleBuffers(buffers);
      this.setBuffer(buffers[1]);
      const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;
      if (!isTransitioning) {
        transition.end();
      }
    }
    delete() {
      super.delete();
      this.transform.destroy();
      this.texture.destroy();
      this.framebuffer.destroy();
    }
  };
  var vs7 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`;
  var fs5 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
  function getTransform2(device, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    const format = getFloat32VertexFormat(attribute.size);
    return new BufferTransform(device, {
      vs: vs7,
      fs: fs5,
      bufferLayout: [
        { name: "aPrev", format },
        { name: "aCur", format },
        { name: "aTo", format: attribute.getBufferLayout().attributes[0].format }
      ],
      varyings: ["vNext"],
      defines: { ATTRIBUTE_TYPE: attributeType },
      parameters: {
        depthCompare: "always",
        blendColorOperation: "max",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      }
    });
  }
  function getTexture(device) {
    return device.createTexture({
      data: new Uint8Array(4),
      format: "rgba8unorm",
      mipmaps: false,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer3(device, texture) {
    return device.createFramebuffer({
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      colorAttachments: [texture]
    });
  }

  // ../core/src/lib/attribute/attribute-transition-manager.ts
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = class {
    constructor(device, {
      id,
      timeline
    }) {
      if (!device)
        throw new Error("AttributeTransitionManager is constructed without device");
      this.id = id;
      this.device = device;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
    }
    finalize() {
      for (const attributeName in this.transitions) {
        this._removeTransition(attributeName);
      }
    }
    update({
      attributes,
      transitions,
      numInstances
    }) {
      this.numInstances = numInstances || 1;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const settings = attribute.getTransitionSetting(transitions);
        if (!settings)
          continue;
        this._updateAttribute(attributeName, attribute, settings);
      }
      for (const attributeName in this.transitions) {
        const attribute = attributes[attributeName];
        if (!attribute || !attribute.getTransitionSetting(transitions)) {
          this._removeTransition(attributeName);
        }
      }
    }
    hasAttribute(attributeName) {
      const transition = this.transitions[attributeName];
      return transition && transition.inProgress;
    }
    getAttributes() {
      const animatedAttributes = {};
      for (const attributeName in this.transitions) {
        const transition = this.transitions[attributeName];
        if (transition.inProgress) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }
      return animatedAttributes;
    }
    run() {
      if (this.numInstances === 0) {
        return false;
      }
      for (const attributeName in this.transitions) {
        const updated = this.transitions[attributeName].update();
        if (updated) {
          this.needsRedraw = true;
        }
      }
      const needsRedraw = this.needsRedraw;
      this.needsRedraw = false;
      return needsRedraw;
    }
    _removeTransition(attributeName) {
      this.transitions[attributeName].delete();
      delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
      const transition = this.transitions[attributeName];
      let isNew = !transition || transition.type !== settings.type;
      if (isNew) {
        if (transition) {
          this._removeTransition(attributeName);
        }
        const TransitionType = TRANSITION_TYPES[settings.type];
        if (TransitionType) {
          this.transitions[attributeName] = new TransitionType({
            attribute,
            timeline: this.timeline,
            device: this.device
          });
        } else {
          log_default.error(`unsupported transition type '${settings.type}'`)();
          isNew = false;
        }
      }
      if (isNew || attribute.needsRedraw()) {
        this.needsRedraw = true;
        this.transitions[attributeName].start(settings, this.numInstances);
      }
    }
  };

  // ../core/src/lib/attribute/attribute-manager.ts
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = class {
    constructor(device, {
      id = "attribute-manager",
      stats,
      timeline
    } = {}) {
      this.mergeBoundsMemoized = memoize(mergeBounds);
      this.id = id;
      this.device = device;
      this.attributes = {};
      this.updateTriggers = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats;
      this.attributeTransitionManager = new AttributeTransitionManager(device, {
        id: `${id}-transitions`,
        timeline
      });
      Object.seal(this);
    }
    finalize() {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = { clearRedrawFlags: false }) {
      const redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    add(attributes) {
      this._add(attributes);
    }
    addInstanced(attributes) {
      this._add(attributes, { instanced: 1 });
    }
    remove(attributeNameArray) {
      for (const name13 of attributeNameArray) {
        if (this.attributes[name13] !== void 0) {
          this.attributes[name13].delete();
          delete this.attributes[name13];
        }
      }
    }
    invalidate(triggerName, dataRange) {
      const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }
      debug(TRACE_INVALIDATE, this, "all");
    }
    update({
      data,
      numInstances,
      startIndices = null,
      transitions,
      props = {},
      buffers = {},
      context = {}
    }) {
      let updated = false;
      debug(TRACE_UPDATE_START, this);
      if (this.stats) {
        this.stats.get("Update Attributes").timeStart();
      }
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        const accessorName = attribute.settings.accessor;
        attribute.startIndices = startIndices;
        attribute.numInstances = numInstances;
        if (props[attributeName]) {
          log_default.removed(`props.${attributeName}`, `data.attributes.${attributeName}`)();
        }
        if (attribute.setExternalBuffer(buffers[attributeName])) {
        } else if (attribute.setBinaryValue(
          typeof accessorName === "string" ? buffers[accessorName] : void 0,
          data.startIndices
        )) {
        } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
        } else if (attribute.needsUpdate()) {
          updated = true;
          this._updateAttribute({
            attribute,
            numInstances,
            data,
            props,
            context
          });
        }
        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
      }
      if (updated) {
        debug(TRACE_UPDATE_END, this, numInstances);
      }
      if (this.stats) {
        this.stats.get("Update Attributes").timeEnd();
      }
      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances,
        transitions
      });
    }
    updateTransition() {
      const { attributeTransitionManager } = this;
      const transitionUpdated = attributeTransitionManager.run();
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    getAttributes() {
      return { ...this.attributes, ...this.attributeTransitionManager.getAttributes() };
    }
    getBounds(attributeNames) {
      const bounds = attributeNames.map((attributeName) => this.attributes[attributeName]?.getBounds());
      return this.mergeBoundsMemoized(bounds);
    }
    getChangedAttributes(opts = { clearChangedFlags: false }) {
      const { attributes, attributeTransitionManager } = this;
      const changedAttributes = { ...attributeTransitionManager.getAttributes() };
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }
    getBufferLayouts(attributes, excludeAttributes = {}) {
      if (!attributes) {
        attributes = this.getAttributes();
      }
      const bufferMaps = [];
      for (const attributeName in attributes) {
        if (!excludeAttributes[attributeName]) {
          bufferMaps.push(attributes[attributeName].getBufferLayout());
        }
      }
      return bufferMaps;
    }
    _add(attributes, extraProps = {}) {
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name13, attribute, extraProps) {
      const props = {
        ...attribute,
        id: name13,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        divisor: extraProps.instanced ? 1 : attribute.divisor || 0
      };
      return new Attribute2(this.device, props);
    }
    _mapUpdateTriggersToAttributes() {
      const triggers = {};
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach((triggerName) => {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }
          triggers[triggerName].push(attributeName);
        });
      }
      this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
      const { attributes, updateTriggers } = this;
      const invalidatedAttributes = updateTriggers[triggerName];
      if (invalidatedAttributes) {
        invalidatedAttributes.forEach((name13) => {
          const attribute = attributes[name13];
          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      }
      return invalidatedAttributes;
    }
    _updateAttribute(opts) {
      const { attribute, numInstances } = opts;
      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
      if (attribute.constant) {
        attribute.setConstantValue(attribute.value);
        return;
      }
      if (attribute.allocate(numInstances)) {
        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
      }
      const updated = attribute.updateBuffer(opts);
      if (updated) {
        this.needsRedraw = true;
        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
      }
    }
  };

  // ../core/src/transitions/cpu-interpolation-transition.ts
  var CPUInterpolationTransition = class extends Transition {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const {
        time,
        settings: { fromValue: fromValue2, toValue, duration, easing }
      } = this;
      const t3 = easing(time / duration);
      this._value = lerp(fromValue2, toValue, t3);
    }
  };

  // ../core/src/transitions/cpu-spring-transition.ts
  var EPSILON23 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      const next = [];
      for (let i5 = 0; i5 < dest.length; i5++) {
        next[i5] = updateSpringElement(prev[i5], cur[i5], dest[i5], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance4(value1, value2) {
    if (Array.isArray(value1)) {
      let distanceSquare = 0;
      for (let i5 = 0; i5 < value1.length; i5++) {
        const d2 = value1[i5] - value2[i5];
        distanceSquare += d2 * d2;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
  }
  var CPUSpringTransition = class extends Transition {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const { fromValue: fromValue2, toValue, damping, stiffness } = this.settings;
      const { _prevValue = fromValue2, _currValue = fromValue2 } = this;
      let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
      const delta = distance4(nextValue, toValue);
      const velocity = distance4(nextValue, _currValue);
      if (delta < EPSILON23 && velocity < EPSILON23) {
        nextValue = toValue;
        this.end();
      }
      this._prevValue = _currValue;
      this._currValue = nextValue;
    }
  };

  // ../core/src/lib/uniform-transition-manager.ts
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = class {
    constructor(timeline) {
      this.transitions = /* @__PURE__ */ new Map();
      this.timeline = timeline;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(key, fromValue2, toValue, settings) {
      const { transitions } = this;
      if (transitions.has(key)) {
        const transition2 = transitions.get(key);
        const { value = transition2.settings.fromValue } = transition2;
        fromValue2 = value;
        this.remove(key);
      }
      settings = normalizeTransitionSettings(settings);
      if (!settings) {
        return;
      }
      const TransitionType = TRANSITION_TYPES2[settings.type];
      if (!TransitionType) {
        log_default.error(`unsupported transition type '${settings.type}'`)();
        return;
      }
      const transition = new TransitionType(this.timeline);
      transition.start({
        ...settings,
        fromValue: fromValue2,
        toValue
      });
      transitions.set(key, transition);
    }
    remove(key) {
      const { transitions } = this;
      if (transitions.has(key)) {
        transitions.get(key).cancel();
        transitions.delete(key);
      }
    }
    update() {
      const propsInTransition = {};
      for (const [key, transition] of this.transitions) {
        transition.update();
        propsInTransition[key] = transition.value;
        if (!transition.inProgress) {
          this.remove(key);
        }
      }
      return propsInTransition;
    }
    clear() {
      for (const key of this.transitions.keys()) {
        this.remove(key);
      }
    }
  };

  // ../core/src/lifecycle/props.ts
  function validateProps(props) {
    const propTypes = props[PROP_TYPES_SYMBOL];
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const { validate: validate2 } = propType;
      if (validate2 && !validate2(props[propName], propType)) {
        throw new Error(`Invalid prop ${propName}: ${props[propName]}`);
      }
    }
  }
  function diffProps(props, oldProps) {
    const propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: props[PROP_TYPES_SYMBOL],
      ignoreProps: { data: null, updateTriggers: null, extensions: null, transitions: null }
    });
    const dataChangedReason = diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return false;
    }
    const result = {};
    const propTypes = props[PROP_TYPES_SYMBOL];
    let changed = false;
    for (const key in props.transitions) {
      const propType = propTypes[key];
      const type = propType && propType.type;
      const isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
        changed = true;
      }
    }
    return changed ? result : false;
  }
  function compareProps({
    newProps,
    oldProps,
    ignoreProps = {},
    propTypes = {},
    triggerName = "props"
  }) {
    if (oldProps === newProps) {
      return false;
    }
    if (typeof newProps !== "object" || newProps === null) {
      return `${triggerName} changed shallowly`;
    }
    if (typeof oldProps !== "object" || oldProps === null) {
      return `${triggerName} changed shallowly`;
    }
    for (const key of Object.keys(newProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return `${triggerName}.${key} added`;
        }
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return `${triggerName}.${key} ${changed}`;
        }
      }
    }
    for (const key of Object.keys(oldProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in newProps)) {
          return `${triggerName}.${key} dropped`;
        }
        if (!Object.hasOwnProperty.call(newProps, key)) {
          const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
          if (changed) {
            return `${triggerName}.${key} ${changed}`;
          }
        }
      }
    }
    return false;
  }
  function comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal) {
      equal = newProp && oldProp && newProp.equals;
      if (equal && !equal.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    let dataChanged = false;
    const { dataComparator, _dataDiff } = props;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return { all: true };
    }
    if ("all" in props.updateTriggers) {
      const diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return { all: true };
      }
    }
    const reason = {};
    let changed = false;
    for (const triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
          reason[triggerName] = true;
          changed = true;
        }
      }
    }
    return changed ? reason : false;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return true;
    }
    const oldExtensions = oldProps.extensions;
    const { extensions } = props;
    if (extensions === oldExtensions) {
      return false;
    }
    if (!oldExtensions || !extensions) {
      return true;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (let i5 = 0; i5 < extensions.length; i5++) {
      if (!extensions[i5].equals(oldExtensions[i5])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    const diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }

  // ../core/src/utils/count.ts
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count(container) {
    if (!isObject2(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
  }
  function isObject2(value) {
    return value !== null && typeof value === "object";
  }

  // ../core/src/utils/shader.ts
  function mergeShaders(target, source) {
    if (!source) {
      return target;
    }
    const result = { ...target, ...source };
    if ("defines" in source) {
      result.defines = { ...target.defines, ...source.defines };
    }
    if ("modules" in source) {
      result.modules = (target.modules || []).concat(source.modules);
      if (source.modules.some((module) => module.name === "project64")) {
        const index2 = result.modules.findIndex((module) => module.name === "project32");
        if (index2 >= 0) {
          result.modules.splice(index2, 1);
        }
      }
    }
    if ("inject" in source) {
      if (!target.inject) {
        result.inject = source.inject;
      } else {
        const mergedInjection = { ...target.inject };
        for (const key in source.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // ../core/src/utils/texture.ts
  var DEFAULT_TEXTURE_PARAMETERS = {
    minFilter: "linear",
    mipmapFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  };
  var internalTextures = {};
  function createTexture(owner, device, image, sampler) {
    if (image instanceof Texture) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = { data: image };
    }
    let samplerParameters = null;
    if (image.compressed) {
      samplerParameters = {
        minFilter: "linear",
        mipmapFilter: image.data.length > 1 ? "nearest" : "linear"
      };
    }
    const texture = device.createTexture({
      ...image,
      sampler: {
        ...DEFAULT_TEXTURE_PARAMETERS,
        ...samplerParameters,
        ...sampler
      }
    });
    internalTextures[texture.id] = owner;
    return texture;
  }
  function destroyTexture(owner, texture) {
    if (!texture || !(texture instanceof Texture)) {
      return;
    }
    if (internalTextures[texture.id] === owner) {
      texture.delete();
      delete internalTextures[texture.id];
    }
  }

  // ../core/src/lifecycle/prop-types.ts
  var TYPE_DEFINITIONS = {
    boolean: {
      validate(value, propType) {
        return true;
      },
      equal(value1, value2, propType) {
        return Boolean(value1) === Boolean(value2);
      }
    },
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    color: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
      },
      equal(value1, value2, propType) {
        return deepEqual2(value1, value2, 1);
      }
    },
    accessor: {
      validate(value, propType) {
        const valueType = getTypeOf2(value);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal(value1, value2, propType) {
        if (typeof value2 === "function") {
          return true;
        }
        return deepEqual2(value1, value2, 1);
      }
    },
    array: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value);
      },
      equal(value1, value2, propType) {
        const { compare: compare2 } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual2(value1, value2, depth) : value1 === value2;
      }
    },
    object: {
      equal(value1, value2, propType) {
        if (propType.ignore) {
          return true;
        }
        const { compare: compare2 } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual2(value1, value2, depth) : value1 === value2;
      }
    },
    function: {
      validate(value, propType) {
        return propType.optional && !value || typeof value === "function";
      },
      equal(value1, value2, propType) {
        const shouldIgnore = !propType.compare && propType.ignore !== false;
        return shouldIgnore || value1 === value2;
      }
    },
    data: {
      transform: (value, propType, component) => {
        if (!value) {
          return value;
        }
        const { dataTransform } = component.props;
        if (dataTransform) {
          return dataTransform(value);
        }
        if (typeof value.shape === "string" && value.shape.endsWith("-table") && Array.isArray(value.data)) {
          return value.data;
        }
        return value;
      }
    },
    image: {
      transform: (value, propType, component) => {
        const context = component.context;
        if (!context || !context.device) {
          return null;
        }
        return createTexture(component.id, context.device, value, {
          ...propType.parameters,
          ...component.props.textureParameters
        });
      },
      release: (value, propType, component) => {
        destroyTexture(component.id, value);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes = {};
    const defaultProps53 = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)) {
      const deprecated = propDef?.deprecatedFor;
      if (deprecated) {
        deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
      } else {
        const propType = parsePropType(propName, propDef);
        propTypes[propName] = propType;
        defaultProps53[propName] = propType.value;
      }
    }
    return { propTypes, defaultProps: defaultProps53, deprecatedProps };
  }
  function parsePropType(name13, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name13, propDef);
      case "array":
        return normalizePropDefinition(name13, { type: "array", value: propDef, compare: false });
      case "boolean":
        return normalizePropDefinition(name13, { type: "boolean", value: propDef });
      case "number":
        return normalizePropDefinition(name13, { type: "number", value: propDef });
      case "function":
        return normalizePropDefinition(name13, { type: "function", value: propDef, compare: true });
      default:
        return { name: name13, type: "unknown", value: propDef };
    }
  }
  function normalizePropDefinition(name13, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return { name: name13, type: "object", value: propDef };
      }
      return { name: name13, type: getTypeOf2(propDef.value), ...propDef };
    }
    return { name: name13, ...TYPE_DEFINITIONS[propDef.type], ...propDef };
  }
  function isArray3(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
  }
  function getTypeOf2(value) {
    if (isArray3(value)) {
      return "array";
    }
    if (value === null) {
      return "null";
    }
    return typeof value;
  }

  // ../core/src/lifecycle/create-props.ts
  function createProps(component, propObjects) {
    let extensions;
    for (let i5 = propObjects.length - 1; i5 >= 0; i5--) {
      const props = propObjects[i5];
      if ("extensions" in props) {
        extensions = props.extensions;
      }
    }
    const propsPrototype = getPropsPrototype(component.constructor, extensions);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT_SYMBOL] = component;
    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
    for (let i5 = 0; i5 < propObjects.length; ++i5) {
      const props = propObjects[i5];
      for (const key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  function getPropsPrototype(componentClass, extensions) {
    let cacheKey = MergedDefaultPropsCacheKey;
    if (extensions) {
      for (const extension of extensions) {
        const ExtensionClass = extension.constructor;
        if (ExtensionClass) {
          cacheKey += `:${ExtensionClass.extensionName || ExtensionClass.name}`;
        }
      }
    }
    const defaultProps53 = getOwnProperty(componentClass, cacheKey);
    if (!defaultProps53) {
      return componentClass[cacheKey] = createPropsPrototypeAndTypes(
        componentClass,
        extensions || []
      );
    }
    return defaultProps53;
  }
  function createPropsPrototypeAndTypes(componentClass, extensions) {
    const parent = componentClass.prototype;
    if (!parent) {
      return null;
    }
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = getPropsPrototype(parentClass);
    const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = parsePropTypes(componentDefaultProps);
    const defaultProps53 = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps,
      componentPropDefs.defaultProps
    );
    const propTypes = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps?.[PROP_TYPES_SYMBOL],
      componentPropDefs.propTypes
    );
    const deprecatedProps = Object.assign(
      /* @__PURE__ */ Object.create(null),
      parentDefaultProps?.[DEPRECATED_PROPS_SYMBOL],
      componentPropDefs.deprecatedProps
    );
    for (const extension of extensions) {
      const extensionDefaultProps = getPropsPrototype(extension.constructor);
      if (extensionDefaultProps) {
        Object.assign(defaultProps53, extensionDefaultProps);
        Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
        Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
      }
    }
    createPropsPrototype(defaultProps53, componentClass);
    addAsyncPropsToPropPrototype(defaultProps53, propTypes);
    addDeprecatedPropsToPropPrototype(defaultProps53, deprecatedProps);
    defaultProps53[PROP_TYPES_SYMBOL] = propTypes;
    defaultProps53[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
    if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
      componentClass._propTypes = propTypes;
    }
    return defaultProps53;
  }
  function createPropsPrototype(defaultProps53, componentClass) {
    const id = getComponentName(componentClass);
    Object.defineProperties(defaultProps53, {
      id: {
        writable: true,
        value: id
      }
    });
  }
  function addDeprecatedPropsToPropPrototype(defaultProps53, deprecatedProps) {
    for (const propName in deprecatedProps) {
      Object.defineProperty(defaultProps53, propName, {
        enumerable: false,
        set(newValue) {
          const nameStr = `${this.id}: ${propName}`;
          for (const newPropName of deprecatedProps[propName]) {
            if (!hasOwnProperty(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
          log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
      });
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps53, propTypes) {
    const defaultValues = {};
    const descriptors = {};
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const { name: name13, value } = propType;
      if (propType.async) {
        defaultValues[name13] = value;
        descriptors[name13] = getDescriptorForAsyncProp(name13);
      }
    }
    defaultProps53[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
    defaultProps53[ASYNC_ORIGINAL_SYMBOL] = {};
    Object.defineProperties(defaultProps53, descriptors);
  }
  function getDescriptorForAsyncProp(name13) {
    return {
      enumerable: true,
      set(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
          this[ASYNC_ORIGINAL_SYMBOL][name13] = newValue;
        } else {
          this[ASYNC_RESOLVED_SYMBOL][name13] = newValue;
        }
      },
      get() {
        if (this[ASYNC_RESOLVED_SYMBOL]) {
          if (name13 in this[ASYNC_RESOLVED_SYMBOL]) {
            const value = this[ASYNC_RESOLVED_SYMBOL][name13];
            return value || this[ASYNC_DEFAULTS_SYMBOL][name13];
          }
          if (name13 in this[ASYNC_ORIGINAL_SYMBOL]) {
            const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
            if (state && state.hasAsyncProp(name13)) {
              return state.getAsyncProp(name13) || this[ASYNC_DEFAULTS_SYMBOL][name13];
            }
          }
        }
        return this[ASYNC_DEFAULTS_SYMBOL][name13];
      }
    };
  }
  function hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  function getOwnProperty(object, prop) {
    return hasOwnProperty(object, prop) && object[prop];
  }
  function getComponentName(componentClass) {
    const componentName = componentClass.componentName;
    if (!componentName) {
      log_default.warn(`${componentClass.name}.componentName not specified`)();
    }
    return componentName || componentClass.name;
  }

  // ../core/src/lifecycle/component.ts
  var counter = 0;
  var Component = class {
    constructor(...propObjects) {
      this.props = createProps(this, propObjects);
      this.id = this.props.id;
      this.count = counter++;
    }
    clone(newProps) {
      const { props } = this;
      const asyncProps = {};
      for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
        if (key in props[ASYNC_RESOLVED_SYMBOL]) {
          asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
        } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
          asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
        }
      }
      return new this.constructor({ ...props, ...asyncProps, ...newProps });
    }
  };
  Component.componentName = "Component";
  Component.defaultProps = {};

  // ../core/src/lifecycle/component-state.ts
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = class {
    constructor(component) {
      this.component = component;
      this.asyncProps = {};
      this.onAsyncPropUpdated = () => {
      };
      this.oldProps = null;
      this.oldAsyncProps = null;
    }
    finalize() {
      for (const propName in this.asyncProps) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && asyncProp.type && asyncProp.type.release) {
          asyncProp.type.release(
            asyncProp.resolvedValue,
            asyncProp.type,
            this.component
          );
        }
      }
      this.asyncProps = {};
      this.component = null;
      this.resetOldProps();
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
    }
    resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component ? this.component.props : null;
    }
    hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
      const asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
      if (propName) {
        const asyncProp = this.asyncProps[propName];
        return Boolean(
          asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount
        );
      }
      for (const key in this.asyncProps) {
        if (this.isAsyncPropLoading(key)) {
          return true;
        }
      }
      return false;
    }
    reloadAsyncProp(propName, value) {
      this._watchPromise(propName, Promise.resolve(value));
    }
    setAsyncProps(props) {
      this.component = props[COMPONENT_SYMBOL] || this.component;
      const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
      const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
      const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
      for (const propName in resolvedValues) {
        const value = resolvedValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
        resolvedValues[propName] = this.getAsyncProp(propName);
      }
      for (const propName in originalValues) {
        const value = originalValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
      }
    }
    _fetch(propName, url) {
      return null;
    }
    _onResolve(propName, value) {
    }
    _onError(propName, error) {
    }
    _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }
      if (typeof value === "string") {
        value = this._fetch(propName, value);
      }
      if (value instanceof Promise) {
        this._watchPromise(propName, value);
        return;
      }
      if (isAsyncIterable2(value)) {
        this._resolveAsyncIterable(propName, value);
        return;
      }
      this._setPropValue(propName, value);
    }
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
    _didAsyncInputValueChange(propName, value) {
      const asyncProp = this.asyncProps[propName];
      if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
        return false;
      }
      asyncProp.lastValue = value;
      return true;
    }
    _setPropValue(propName, value) {
      this._freezeAsyncOldProps();
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        value = this._postProcessValue(asyncProp, value);
        asyncProp.resolvedValue = value;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }
    _setAsyncPropValue(propName, value, loadCount) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
        this._freezeAsyncOldProps();
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
    _watchPromise(propName, promise) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        promise.then((data) => {
          if (!this.component) {
            return;
          }
          data = this._postProcessValue(asyncProp, data);
          this._setAsyncPropValue(propName, data, loadCount);
          this._onResolve(propName, data);
        }).catch((error) => {
          this._onError(propName, error);
        });
      }
    }
    async _resolveAsyncIterable(propName, iterable) {
      if (propName !== "data") {
        this._setPropValue(propName, iterable);
        return;
      }
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        return;
      }
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      let data = [];
      let count2 = 0;
      for await (const chunk of iterable) {
        if (!this.component) {
          return;
        }
        const { dataTransform } = this.component.props;
        if (dataTransform) {
          data = dataTransform(chunk, data);
        } else {
          data = data.concat(chunk);
        }
        Object.defineProperty(data, "__diff", {
          enumerable: false,
          value: [{ startRow: count2, endRow: data.length }]
        });
        count2 = data.length;
        this._setAsyncPropValue(propName, data, loadCount);
      }
      this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value) {
      const propType = asyncProp.type;
      if (propType && this.component) {
        if (propType.release) {
          propType.release(asyncProp.resolvedValue, propType, this.component);
        }
        if (propType.transform) {
          return propType.transform(value, propType, this.component);
        }
      }
      return value;
    }
    _createAsyncPropData(propName, defaultValue2) {
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
        this.asyncProps[propName] = {
          type: propTypes && propTypes[propName],
          lastValue: null,
          resolvedValue: defaultValue2,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  };

  // ../core/src/lib/layer-state.ts
  var LayerState = class extends ComponentState {
    constructor({
      attributeManager,
      layer
    }) {
      super(layer);
      this.attributeManager = attributeManager;
      this.needsRedraw = true;
      this.needsUpdate = true;
      this.subLayers = null;
      this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    _fetch(propName, url) {
      const layer = this.layer;
      const fetch2 = layer?.props.fetch;
      if (fetch2) {
        return fetch2(url, { propName, layer });
      }
      return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
      const layer = this.layer;
      if (layer) {
        const onDataLoad = layer.props.onDataLoad;
        if (propName === "data" && onDataLoad) {
          onDataLoad(value, { propName, layer });
        }
      }
    }
    _onError(propName, error) {
      const layer = this.layer;
      if (layer) {
        layer.raiseError(error, `loading ${propName} of ${this.layer}`);
      }
    }
  };

  // ../core/src/lib/layer.ts
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(
    ({ oldViewport, viewport }) => {
      return oldViewport.equals(viewport);
    }
  );
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    data: { type: "data", value: EMPTY_ARRAY2, async: true },
    dataComparator: { type: "function", value: null, optional: true },
    _dataDiff: {
      type: "function",
      value: (data) => data && data.__diff,
      optional: true
    },
    dataTransform: { type: "function", value: null, optional: true },
    onDataLoad: { type: "function", value: null, optional: true },
    onError: { type: "function", value: null, optional: true },
    fetch: {
      type: "function",
      value: (url, {
        propName,
        layer,
        loaders,
        loadOptions,
        signal
      }) => {
        const { resourceManager } = layer.context;
        loadOptions = loadOptions || layer.getLoadOptions();
        loaders = loaders || layer.props.loaders;
        if (signal) {
          loadOptions = {
            ...loadOptions,
            fetch: {
              ...loadOptions?.fetch,
              signal
            }
          };
        }
        let inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({ resourceId: url, data: load(url, loaders), persistent: false });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: (data) => layer.internalState?.reloadAsyncProp(propName, data),
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      }
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: { type: "number", min: 0, max: 1, value: 1 },
    operation: "draw",
    onHover: { type: "function", value: null, optional: true },
    onClick: { type: "function", value: null, optional: true },
    onDragStart: { type: "function", value: null, optional: true },
    onDrag: { type: "function", value: null, optional: true },
    onDragEnd: { type: "function", value: null, optional: true },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: { type: "array", value: [0, 0, 0], compare: true },
    modelMatrix: { type: "array", value: null, compare: true, optional: true },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: { type: "object", value: {}, optional: true, compare: 2 },
    loadOptions: { type: "object", value: null, optional: true, ignore: true },
    transitions: null,
    extensions: [],
    loaders: { type: "array", value: [], optional: true, ignore: true },
    getPolygonOffset: {
      type: "function",
      value: ({ layerIndex }) => [0, -layerIndex * 100]
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: { type: "accessor", value: [0, 0, 128, 128] }
  };
  var Layer = class extends Component {
    constructor() {
      super(...arguments);
      this.internalState = null;
      this.lifecycle = LIFECYCLE.NO_STATE;
      this.parent = null;
    }
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    get root() {
      let layer = this;
      while (layer.parent) {
        layer = layer.parent;
      }
      return layer;
    }
    toString() {
      const className = this.constructor.layerName || this.constructor.name;
      return `${className}({id: '${this.props.id}'})`;
    }
    project(xyz) {
      assert9(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      const worldPosition = getWorldPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
      const [x3, y3, z2] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
      return xyz.length === 2 ? [x3, y3] : [x3, y3, z2];
    }
    unproject(xy) {
      assert9(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
      assert9(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return projectPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...params
      });
    }
    get isComposite() {
      return false;
    }
    setState(partialState) {
      this.setChangeFlags({ stateChanged: true });
      Object.assign(this.state, partialState);
      this.setNeedsRedraw();
    }
    setNeedsRedraw() {
      if (this.internalState) {
        this.internalState.needsRedraw = true;
      }
    }
    setNeedsUpdate() {
      if (this.internalState) {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      const state = this.state;
      return state && (state.models || state.model && [state.model]) || [];
    }
    setModuleParameters(moduleParameters) {
      for (const model of this.getModels()) {
        model.updateModuleSettings(moduleParameters);
      }
    }
    setShaderModuleProps(...props) {
      for (const model of this.getModels()) {
        model.shaderInputs.setProps(...props);
      }
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const { coordinateSystem } = this.props;
      return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
    }
    onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent) || false;
      }
      return false;
    }
    onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent) || false;
      }
      return false;
    }
    nullPickingColor() {
      return [0, 0, 0];
    }
    encodePickingColor(i5, target = []) {
      target[0] = i5 + 1 & 255;
      target[1] = i5 + 1 >> 8 & 255;
      target[2] = i5 + 1 >> 8 >> 8 & 255;
      return target;
    }
    decodePickingColor(color) {
      assert9(color instanceof Uint8Array);
      const [i1, i22, i32] = color;
      const index2 = i1 + i22 * 256 + i32 * 65536 - 1;
      return index2;
    }
    getNumInstances() {
      if (Number.isFinite(this.props.numInstances)) {
        return this.props.numInstances;
      }
      if (this.state && this.state.numInstances !== void 0) {
        return this.state.numInstances;
      }
      return count(this.props.data);
    }
    getStartIndices() {
      if (this.props.startIndices) {
        return this.props.startIndices;
      }
      if (this.state && this.state.startIndices) {
        return this.state.startIndices;
      }
      return null;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["positions", "instancePositions"]);
    }
    getShaders(shaders) {
      shaders = mergeShaders(shaders, {
        disableWarnings: true,
        modules: this.context.defaultShaderModules
      });
      for (const extension of this.props.extensions) {
        shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
      }
      return shaders;
    }
    shouldUpdateState(params) {
      return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
      const attributeManager = this.getAttributeManager();
      const { dataChanged } = params.changeFlags;
      if (dataChanged && attributeManager) {
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            attributeManager.invalidateAll(dataRange);
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
      if (attributeManager) {
        const { props } = params;
        const hasPickingBuffer = this.internalState.hasPickingBuffer;
        const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
        if (hasPickingBuffer !== needsPickingBuffer) {
          this.internalState.hasPickingBuffer = needsPickingBuffer;
          const { pickingColors, instancePickingColors } = attributeManager.attributes;
          const pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needsPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needsPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }
    finalizeState(context) {
      for (const model of this.getModels()) {
        model.destroy();
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.finalize();
      }
      if (this.context) {
        this.context.resourceManager.unsubscribe({ consumerId: this.id });
      }
      if (this.internalState) {
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }
    draw(opts) {
      for (const model of this.getModels()) {
        model.draw(opts);
      }
    }
    getPickingInfo({ info, mode, sourceLayer }) {
      const { index: index2 } = info;
      if (index2 >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index2];
        }
      }
      return info;
    }
    raiseError(error, message2) {
      if (message2) {
        error = new Error(`${message2}: ${error.message}`, { cause: error });
      }
      if (!this.props.onError?.(error)) {
        this.context?.onError?.(error, this);
      }
    }
    getNeedsRedraw(opts = { clearRedrawFlags: false }) {
      return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
      if (!this.internalState) {
        return false;
      }
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
      return this.internalState?.uniformTransitions.active || false;
    }
    activateViewport(viewport) {
      if (!this.internalState) {
        return;
      }
      const oldViewport = this.internalState.viewport;
      this.internalState.viewport = viewport;
      if (!oldViewport || !areViewportsEqual({ oldViewport, viewport })) {
        this.setChangeFlags({ viewportChanged: true });
        if (this.isComposite) {
          if (this.needsUpdate()) {
            this.setNeedsUpdate();
          }
        } else {
          this._update();
        }
      }
    }
    invalidateAttribute(name13 = "all") {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      if (name13 === "all") {
        attributeManager.invalidateAll();
      } else {
        attributeManager.invalidate(name13);
      }
    }
    updateAttributes(changedAttributes) {
      let bufferLayoutChanged = false;
      for (const id in changedAttributes) {
        if (changedAttributes[id].layoutChanged()) {
          bufferLayoutChanged = true;
        }
      }
      for (const model of this.getModels()) {
        this._setModelAttributes(model, changedAttributes, bufferLayoutChanged);
      }
    }
    _updateAttributes() {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      const props = this.props;
      const numInstances = this.getNumInstances();
      const startIndices = this.getStartIndices();
      attributeManager.update({
        data: props.data,
        numInstances,
        startIndices,
        props,
        transitions: props.transitions,
        buffers: props.data.attributes,
        context: this
      });
      const changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
      this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
    _updateUniformTransition() {
      const { uniformTransitions } = this.internalState;
      if (uniformTransitions.active) {
        const propsInTransition = uniformTransitions.update();
        const props = Object.create(this.props);
        for (const key in propsInTransition) {
          Object.defineProperty(props, key, { value: propsInTransition[key] });
        }
        return props;
      }
      return this.props;
    }
    calculateInstancePickingColors(attribute, { numInstances }) {
      if (attribute.constant) {
        return;
      }
      const cacheSize = Math.floor(pickingColorCache.length / 4);
      this.internalState.usesPickingColorCache = true;
      if (cacheSize < numInstances) {
        if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
          log_default.warn(
            "Layer has too many data objects. Picking might not be able to distinguish all objects."
          )();
        }
        pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
          size: 4,
          copy: true,
          maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
        });
        const newCacheSize = Math.floor(pickingColorCache.length / 4);
        const pickingColor = [];
        for (let i5 = cacheSize; i5 < newCacheSize; i5++) {
          this.encodePickingColor(i5, pickingColor);
          pickingColorCache[i5 * 4 + 0] = pickingColor[0];
          pickingColorCache[i5 * 4 + 1] = pickingColor[1];
          pickingColorCache[i5 * 4 + 2] = pickingColor[2];
        }
      }
      attribute.value = pickingColorCache.subarray(0, numInstances * 4);
    }
    _setModelAttributes(model, changedAttributes, bufferLayoutChanged = false) {
      if (!Object.keys(changedAttributes).length) {
        return;
      }
      if (bufferLayoutChanged) {
        const attributeManager = this.getAttributeManager();
        model.setBufferLayout(attributeManager.getBufferLayouts());
        changedAttributes = attributeManager.getAttributes();
      }
      const excludeAttributes = model.userData?.excludeAttributes || {};
      const attributeBuffers = {};
      const constantAttributes = {};
      for (const name13 in changedAttributes) {
        if (excludeAttributes[name13]) {
          continue;
        }
        const values = changedAttributes[name13].getValue();
        for (const attributeName in values) {
          const value = values[attributeName];
          if (value instanceof Buffer2) {
            if (changedAttributes[name13].settings.isIndexed) {
              model.setIndexBuffer(value);
            } else {
              attributeBuffers[attributeName] = value;
            }
          } else if (value) {
            constantAttributes[attributeName] = value;
          }
        }
      }
      model.setAttributes(attributeBuffers);
      model.setConstantAttributes(constantAttributes);
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (!("attributes" in data)) {
        this._disablePickingIndex(objectIndex);
        return;
      }
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
      if (externalColorAttribute && externalColorAttribute.value) {
        const values = externalColorAttribute.value;
        const objectColor = this.encodePickingColor(objectIndex);
        for (let index2 = 0; index2 < data.length; index2++) {
          const i5 = colors.getVertexOffset(index2);
          if (values[i5] === objectColor[0] && values[i5 + 1] === objectColor[1] && values[i5 + 2] === objectColor[2]) {
            this._disablePickingIndex(index2);
          }
        }
      } else {
        this._disablePickingIndex(objectIndex);
      }
    }
    _disablePickingIndex(objectIndex) {
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      const start = colors.getVertexOffset(objectIndex);
      const end = colors.getVertexOffset(objectIndex + 1);
      colors.buffer.write(new Uint8Array(end - start), start);
    }
    restorePickingColors() {
      const { pickingColors, instancePickingColors } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
        colors.value = pickingColorCache.subarray(0, colors.value.length);
      }
      colors.updateSubBuffer({ startOffset: 0 });
    }
    _initialize() {
      assert9(!this.internalState);
      assert9(Number.isFinite(this.props.coordinateSystem));
      debug(TRACE_INITIALIZE, this);
      const attributeManager = this._getAttributeManager();
      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: "uint8",
            size: 4,
            noAlloc: true,
            update: this.calculateInstancePickingColors
          }
        });
      }
      this.internalState = new LayerState({
        attributeManager,
        layer: this
      });
      this._clearChangeFlags();
      this.state = {};
      Object.defineProperty(this.state, "attributeManager", {
        get: () => {
          log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
          return attributeManager;
        }
      });
      this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
      this.initializeState(this.context);
      for (const extension of this.props.extensions) {
        extension.initializeState.call(this, this.context, extension);
      }
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      });
      this._update();
    }
    _transferState(oldLayer) {
      debug(TRACE_MATCHED, this, this === oldLayer);
      const { state, internalState } = oldLayer;
      if (this === oldLayer) {
        return;
      }
      this.internalState = internalState;
      this.state = state;
      this.internalState.setAsyncProps(this.props);
      this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
      const stateNeedsUpdate = this.needsUpdate();
      debug(TRACE_UPDATE, this, stateNeedsUpdate);
      if (!stateNeedsUpdate) {
        return;
      }
      const currentProps = this.props;
      const context = this.context;
      const internalState = this.internalState;
      const currentViewport = context.viewport;
      const propsInTransition = this._updateUniformTransition();
      internalState.propsInTransition = propsInTransition;
      context.viewport = internalState.viewport || currentViewport;
      this.props = propsInTransition;
      try {
        const updateParams = this._getUpdateParams();
        const oldModels = this.getModels();
        if (context.device) {
          this.updateState(updateParams);
        } else {
          try {
            this.updateState(updateParams);
          } catch (error) {
          }
        }
        for (const extension of this.props.extensions) {
          extension.updateState.call(this, updateParams, extension);
        }
        const modelChanged = this.getModels()[0] !== oldModels[0];
        this._postUpdate(updateParams, modelChanged);
      } finally {
        context.viewport = currentViewport;
        this.props = currentProps;
        this._clearChangeFlags();
        internalState.needsUpdate = false;
        internalState.resetOldProps();
      }
    }
    _finalize() {
      debug(TRACE_FINALIZE, this);
      this.finalizeState(this.context);
      for (const extension of this.props.extensions) {
        extension.finalizeState.call(this, this.context, extension);
      }
    }
    _drawLayer({
      renderPass,
      moduleParameters = null,
      uniforms = {},
      parameters: parameters2 = {}
    }) {
      this._updateAttributeTransition();
      const currentProps = this.props;
      const context = this.context;
      this.props = this.internalState.propsInTransition || currentProps;
      const opacity = this.props.opacity;
      uniforms.opacity = Math.pow(opacity, 1 / 2.2);
      try {
        if (moduleParameters) {
          const { isActive, isAttribute } = moduleParameters.picking;
          this.setModuleParameters(moduleParameters);
          this.setShaderModuleProps({ picking: { isActive, isAttribute } });
        }
        const { getPolygonOffset } = this.props;
        const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
        context.device.setParametersWebGL({ polygonOffset: offsets });
        for (const model of this.getModels()) {
          model.setParameters(parameters2);
        }
        context.device.withParametersWebGL(parameters2, () => {
          const opts = { renderPass, moduleParameters, uniforms, parameters: parameters2, context };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } finally {
        this.props = currentProps;
      }
    }
    getChangeFlags() {
      return this.internalState?.changeFlags;
    }
    setChangeFlags(flags) {
      if (!this.internalState) {
        return;
      }
      const { changeFlags } = this.internalState;
      for (const key in flags) {
        if (flags[key]) {
          let flagChanged = false;
          switch (key) {
            case "dataChanged":
              const dataChangedReason = flags[key];
              const prevDataChangedReason = changeFlags[key];
              if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                flagChanged = true;
              }
            default:
              if (!changeFlags[key]) {
                changeFlags[key] = flags[key];
                flagChanged = true;
              }
          }
          if (flagChanged) {
            debug(TRACE_CHANGE_FLAG, this, key, flags);
          }
        }
      }
      const propsOrDataChanged = Boolean(
        changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged
      );
      changeFlags.propsOrDataChanged = propsOrDataChanged;
      changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    _diffProps(newProps, oldProps) {
      const changeFlags = diffProps(newProps, oldProps);
      if (changeFlags.updateTriggersChanged) {
        for (const key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this.invalidateAttribute(key);
          }
        }
      }
      if (changeFlags.transitionsChanged) {
        for (const key in changeFlags.transitionsChanged) {
          this.internalState.uniformTransitions.add(
            key,
            oldProps[key],
            newProps[key],
            newProps.transitions?.[key]
          );
        }
      }
      return this.setChangeFlags(changeFlags);
    }
    validateProps() {
      validateProps(this.props);
    }
    updateAutoHighlight(info) {
      if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
        this._updateAutoHighlight(info);
      }
    }
    _updateAutoHighlight(info) {
      const picking2 = {
        highlightedObjectColor: info.picked ? info.color : null
      };
      const { highlightColor } = this.props;
      if (info.picked && typeof highlightColor === "function") {
        picking2.highlightColor = highlightColor(info);
      }
      this.setShaderModuleProps({ picking: picking2 });
      this.setNeedsRedraw();
    }
    _getAttributeManager() {
      const context = this.context;
      return new AttributeManager(context.device, {
        id: this.props.id,
        stats: context.stats,
        timeline: context.timeline
      });
    }
    _postUpdate(updateParams, forceUpdate) {
      const { props, oldProps } = updateParams;
      this.setNeedsRedraw();
      this._updateAttributes();
      const model = this.state.model;
      model?.setInstanceCount(this.getNumInstances());
      const { autoHighlight, highlightedObjectIndex, highlightColor } = props;
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
        const picking2 = {};
        if (!autoHighlight) {
          picking2.highlightedObjectColor = null;
        }
        if (Array.isArray(highlightColor)) {
          picking2.highlightColor = highlightColor;
        }
        if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
          picking2.highlightedObjectColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
        }
        this.setShaderModuleProps({ picking: picking2 });
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
    _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }
      let redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      const attributeManager = this.getAttributeManager();
      const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
      redraw = redraw || attributeManagerNeedsRedraw;
      if (redraw) {
        for (const extension of this.props.extensions) {
          extension.onNeedsRedraw.call(this, extension);
        }
      }
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      return redraw;
    }
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps());
      this.setNeedsUpdate();
    }
  };
  Layer.defaultProps = defaultProps2;
  Layer.layerName = "Layer";

  // ../core/src/lib/composite-layer.ts
  var TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
  var CompositeLayer = class extends Layer {
    get isComposite() {
      return true;
    }
    get isLoaded() {
      return super.isLoaded && this.getSubLayers().every((layer) => layer.isLoaded);
    }
    getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
    initializeState(context) {
    }
    setState(updateObject) {
      super.setState(updateObject);
      this.setNeedsUpdate();
    }
    getPickingInfo({ info }) {
      const { object } = info;
      const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
      if (!isDataWrapped) {
        return info;
      }
      info.object = object.__source.object;
      info.index = object.__source.index;
      return info;
    }
    filterSubLayer(context) {
      return true;
    }
    shouldRenderSubLayer(subLayerId, data) {
      return data && data.length;
    }
    getSubLayerClass(subLayerId, DefaultLayerClass) {
      const { _subLayerProps: overridingProps } = this.props;
      return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
    }
    getSubLayerRow(row, sourceObject, sourceObjectIndex) {
      row.__source = {
        parent: this,
        object: sourceObject,
        index: sourceObjectIndex
      };
      return row;
    }
    getSubLayerAccessor(accessor) {
      if (typeof accessor === "function") {
        const objectInfo = {
          index: -1,
          data: this.props.data,
          target: []
        };
        return (x3, i5) => {
          if (x3 && x3.__source) {
            objectInfo.index = x3.__source.index;
            return accessor(x3.__source.object, objectInfo);
          }
          return accessor(x3, i5);
        };
      }
      return accessor;
    }
    getSubLayerProps(sublayerProps = {}) {
      const {
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation,
        _subLayerProps: overridingProps
      } = this.props;
      const newProps = {
        id: "",
        updateTriggers: {},
        opacity,
        pickable,
        visible,
        parameters: parameters2,
        getPolygonOffset,
        highlightedObjectIndex,
        autoHighlight,
        highlightColor,
        coordinateSystem,
        coordinateOrigin,
        wrapLongitude,
        positionFormat,
        modelMatrix: modelMatrix2,
        extensions,
        fetch: fetch2,
        operation
      };
      const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
      const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
      const sublayerId = sublayerProps.id || "sublayer";
      if (overridingSublayerProps) {
        const propTypes = this.props[PROP_TYPES_SYMBOL];
        const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};
        for (const key in overridingSublayerProps) {
          const propType = subLayerPropTypes[key] || propTypes[key];
          if (propType && propType.type === "accessor") {
            overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
          }
        }
      }
      Object.assign(
        newProps,
        sublayerProps,
        overridingSublayerProps
      );
      newProps.id = `${this.props.id}-${sublayerId}`;
      newProps.updateTriggers = {
        all: this.props.updateTriggers?.all,
        ...sublayerProps.updateTriggers,
        ...overridingSublayerTriggers
      };
      for (const extension of extensions) {
        const passThroughProps = extension.getSubLayerProps.call(this, extension);
        if (passThroughProps) {
          Object.assign(newProps, passThroughProps, {
            updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
          });
        }
      }
      return newProps;
    }
    _updateAutoHighlight(info) {
      for (const layer of this.getSubLayers()) {
        layer.updateAutoHighlight(info);
      }
    }
    _getAttributeManager() {
      return null;
    }
    _postUpdate(updateParams, forceUpdate) {
      let subLayers = this.internalState.subLayers;
      const shouldUpdate = !subLayers || this.needsUpdate();
      if (shouldUpdate) {
        const subLayersList = this.renderLayers();
        subLayers = flatten(subLayersList, Boolean);
        this.internalState.subLayers = subLayers;
      }
      debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
      for (const layer of subLayers) {
        layer.parent = this;
      }
    }
  };
  CompositeLayer.layerName = "CompositeLayer";

  // ../core/src/viewports/globe-viewport.ts
  var DEGREES_TO_RADIANS6 = Math.PI / 180;
  var RADIANS_TO_DEGREES3 = 180 / Math.PI;
  var EARTH_RADIUS = 6370972;
  var GLOBE_RADIUS = 256;
  function getDistanceScales2() {
    const unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
    const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
    return {
      unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
      unitsPerMeter2: [0, 0, 0],
      metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
      unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
      unitsPerDegree2: [0, 0, 0],
      degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
    };
  }
  var GlobeViewport = class extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 2,
        resolution = 10
      } = opts;
      let { height, altitude = 1.5 } = opts;
      height = height || 1;
      altitude = Math.max(0.75, altitude);
      const viewMatrix2 = new Matrix4().lookAt({ eye: [0, -altitude, 0], up: [0, 0, 1] });
      const scale7 = Math.pow(2, zoom);
      viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS6);
      viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS6);
      viewMatrix2.scale(scale7 / height);
      const halfFov = Math.atan(0.5 / altitude);
      const relativeScale = GLOBE_RADIUS * 2 * scale7 / height;
      super({
        ...opts,
        height,
        viewMatrix: viewMatrix2,
        longitude,
        latitude,
        zoom,
        distanceScales: getDistanceScales2(),
        fovyRadians: halfFov * 2,
        focalDistance: altitude,
        near: nearZMultiplier,
        far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
      });
      this.latitude = latitude;
      this.longitude = longitude;
      this.resolution = resolution;
    }
    get projectionMode() {
      return PROJECTION_MODE.GLOBE;
    }
    getDistanceScales() {
      return this.distanceScales;
    }
    getBounds(options = {}) {
      const unprojectOption = { targetZ: options.z || 0 };
      const left = this.unproject([0, this.height / 2], unprojectOption);
      const top = this.unproject([this.width / 2, 0], unprojectOption);
      const right = this.unproject([this.width, this.height / 2], unprojectOption);
      const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
      if (right[0] < this.longitude)
        right[0] += 360;
      if (left[0] > this.longitude)
        left[0] -= 360;
      return [
        Math.min(left[0], right[0], top[0], bottom[0]),
        Math.min(left[1], right[1], top[1], bottom[1]),
        Math.max(left[0], right[0], top[0], bottom[0]),
        Math.max(left[1], right[1], top[1], bottom[1])
      ];
    }
    unproject(xyz, { topLeft = true, targetZ } = {}) {
      const [x3, y3, z2] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const { pixelUnprojectionMatrix } = this;
      let coord;
      if (Number.isFinite(z2)) {
        coord = transformVector2(pixelUnprojectionMatrix, [x3, y22, z2, 1]);
      } else {
        const coord0 = transformVector2(pixelUnprojectionMatrix, [x3, y22, -1, 1]);
        const coord1 = transformVector2(pixelUnprojectionMatrix, [x3, y22, 1, 1]);
        const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
        const lSqr = vec3_exports.sqrLen(vec3_exports.sub([], coord0, coord1));
        const l0Sqr = vec3_exports.sqrLen(coord0);
        const l1Sqr = vec3_exports.sqrLen(coord1);
        const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
        const dSqr = 4 * sSqr / lSqr;
        const r0 = Math.sqrt(l0Sqr - dSqr);
        const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
        const t3 = (r0 - dr) / Math.sqrt(lSqr);
        coord = vec3_exports.lerp([], coord0, coord1, t3);
      }
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z2)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [lng, lat, Z = 0] = xyz;
      const lambda = lng * DEGREES_TO_RADIANS6;
      const phi = lat * DEGREES_TO_RADIANS6;
      const cosPhi = Math.cos(phi);
      const D2 = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      return [Math.sin(lambda) * cosPhi * D2, -Math.cos(lambda) * cosPhi * D2, Math.sin(phi) * D2];
    }
    unprojectPosition(xyz) {
      const [x3, y3, z2] = xyz;
      const D2 = vec3_exports.len(xyz);
      const phi = Math.asin(z2 / D2);
      const lambda = Math.atan2(x3, -y3);
      const lng = lambda * RADIANS_TO_DEGREES3;
      const lat = phi * RADIANS_TO_DEGREES3;
      const Z = (D2 / GLOBE_RADIUS - 1) * EARTH_RADIUS;
      return [lng, lat, Z];
    }
    projectFlat(xyz) {
      return xyz;
    }
    unprojectFlat(xyz) {
      return xyz;
    }
    panByPosition(coords, pixel) {
      const fromPosition = this.unproject(pixel);
      return {
        longitude: coords[0] - fromPosition[0] + this.longitude,
        latitude: coords[1] - fromPosition[1] + this.latitude
      };
    }
  };
  function transformVector2(matrix, vector) {
    const result = vec4_exports.transformMat4([], vector, matrix);
    vec4_exports.scale(result, result, 1 / result[3]);
    return result;
  }

  // ../core/src/viewports/orbit-viewport.ts
  var DEGREES_TO_RADIANS7 = Math.PI / 180;
  function getViewMatrix2({
    height,
    focalDistance,
    orbitAxis,
    rotationX,
    rotationOrbit,
    zoom
  }) {
    const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
    const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
    const viewMatrix2 = new Matrix4().lookAt({ eye, up });
    viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS7);
    if (orbitAxis === "Z") {
      viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS7);
    } else {
      viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS7);
    }
    const projectionScale = Math.pow(2, zoom) / height;
    viewMatrix2.scale(projectionScale);
    return viewMatrix2;
  }
  var OrbitViewport = class extends Viewport {
    constructor(props) {
      const {
        height,
        projectionMatrix,
        fovy = 50,
        orbitAxis = "Z",
        target = [0, 0, 0],
        rotationX = 0,
        rotationOrbit = 0,
        zoom = 0
      } = props;
      const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
      super({
        ...props,
        longitude: void 0,
        viewMatrix: getViewMatrix2({
          height: height || 1,
          focalDistance,
          orbitAxis,
          rotationX,
          rotationOrbit,
          zoom
        }),
        fovy,
        focalDistance,
        position: target,
        zoom
      });
      this.projectedCenter = this.project(this.center);
    }
    unproject(xyz, { topLeft = true } = {}) {
      const [x3, y3, z2 = this.projectedCenter[2]] = xyz;
      const y22 = topLeft ? y3 : this.height - y3;
      const [X, Y, Z] = pixelsToWorld([x3, y22, z2], this.pixelUnprojectionMatrix);
      return [X, Y, Z];
    }
    panByPosition(coords, pixel) {
      const p0 = this.project(coords);
      const nextCenter = [
        this.width / 2 + p0[0] - pixel[0],
        this.height / 2 + p0[1] - pixel[1],
        this.projectedCenter[2]
      ];
      return {
        target: this.unproject(nextCenter)
      };
    }
  };

  // ../core/src/viewports/orthographic-viewport.ts
  var viewMatrix = new Matrix4().lookAt({ eye: [0, 0, 1] });
  function getProjectionMatrix2({
    width,
    height,
    near,
    far,
    padding
  }) {
    let left = -width / 2;
    let right = width / 2;
    let bottom = -height / 2;
    let top = height / 2;
    if (padding) {
      const { left: l3 = 0, right: r3 = 0, top: t3 = 0, bottom: b2 = 0 } = padding;
      const offsetX = clamp((l3 + width - r3) / 2, 0, width) - width / 2;
      const offsetY = clamp((t3 + height - b2) / 2, 0, height) - height / 2;
      left -= offsetX;
      right -= offsetX;
      bottom += offsetY;
      top += offsetY;
    }
    return new Matrix4().ortho({
      left,
      right,
      bottom,
      top,
      near,
      far
    });
  }
  var OrthographicViewport = class extends Viewport {
    constructor(props) {
      const {
        width,
        height,
        near = 0.1,
        far = 1e3,
        zoom = 0,
        target = [0, 0, 0],
        padding = null,
        flipY = true
      } = props;
      const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
      const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
      const zoom_ = Math.min(zoomX, zoomY);
      const scale7 = Math.pow(2, zoom_);
      let distanceScales;
      if (zoomX !== zoomY) {
        const scaleX2 = Math.pow(2, zoomX);
        const scaleY2 = Math.pow(2, zoomY);
        distanceScales = {
          unitsPerMeter: [scaleX2 / scale7, scaleY2 / scale7, 1],
          metersPerUnit: [scale7 / scaleX2, scale7 / scaleY2, 1]
        };
      }
      super({
        ...props,
        longitude: void 0,
        position: target,
        viewMatrix: viewMatrix.clone().scale([scale7, scale7 * (flipY ? -1 : 1), scale7]),
        projectionMatrix: getProjectionMatrix2({
          width: width || 1,
          height: height || 1,
          padding,
          near,
          far
        }),
        zoom: zoom_,
        distanceScales
      });
    }
    projectFlat([X, Y]) {
      const { unitsPerMeter: unitsPerMeter2 } = this.distanceScales;
      return [X * unitsPerMeter2[0], Y * unitsPerMeter2[1]];
    }
    unprojectFlat([x3, y3]) {
      const { metersPerUnit } = this.distanceScales;
      return [x3 * metersPerUnit[0], y3 * metersPerUnit[1]];
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate3 = vec2_exports.add([], toLocation, vec2_exports.negate([], fromLocation));
      const newCenter = vec2_exports.add([], this.center, translate3);
      return { target: this.unprojectFlat(newCenter) };
    }
  };

  // ../core/src/viewports/first-person-viewport.ts
  var FirstPersonViewport = class extends Viewport {
    constructor(props) {
      const { longitude, latitude, modelMatrix: modelMatrix2, bearing = 0, pitch = 0, up = [0, 0, 1] } = props;
      const spherical = new SphericalCoordinates({
        bearing,
        pitch: pitch === -90 ? 1e-4 : 90 + pitch
      });
      const dir = spherical.toVector3().normalize();
      const center = modelMatrix2 ? new Matrix4(modelMatrix2).transformAsVector(dir) : dir;
      const zoom = Number.isFinite(latitude) ? getMeterZoom({ latitude }) : 0;
      const scale7 = Math.pow(2, zoom);
      const viewMatrix2 = new Matrix4().lookAt({ eye: [0, 0, 0], center, up }).scale(scale7);
      super({
        ...props,
        zoom,
        viewMatrix: viewMatrix2
      });
      this.latitude = latitude;
      this.longitude = longitude;
    }
  };

  // ../core/src/controllers/first-person-controller.ts
  var MOVEMENT_SPEED = 20;
  var PAN_SPEED = 500;
  var FirstPersonState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        position = [0, 0, 0],
        bearing = 0,
        pitch = 0,
        longitude = null,
        latitude = null,
        maxPitch = 90,
        minPitch = -90,
        startRotatePos,
        startBearing,
        startPitch,
        startZoomPosition,
        startPanPos,
        startPanPosition
      } = options;
      super(
        {
          width,
          height,
          position,
          bearing,
          pitch,
          longitude,
          latitude,
          maxPitch,
          minPitch
        },
        {
          startRotatePos,
          startBearing,
          startPitch,
          startZoomPosition,
          startPanPos,
          startPanPosition
        }
      );
      this.makeViewport = options.makeViewport;
    }
    panStart({ pos }) {
      const { position } = this.getViewportProps();
      return this._getUpdatedState({
        startPanPos: pos,
        startPanPosition: position
      });
    }
    pan({ pos }) {
      if (!pos) {
        return this;
      }
      const { startPanPos = [0, 0], startPanPosition = [0, 0] } = this.getState();
      const { width, height, bearing, pitch } = this.getViewportProps();
      const deltaScaleX = PAN_SPEED * (pos[0] - startPanPos[0]) / width;
      const deltaScaleY = PAN_SPEED * (pos[1] - startPanPos[1]) / height;
      const up = new SphericalCoordinates({ bearing, pitch });
      const forward = new SphericalCoordinates({ bearing, pitch: -90 });
      const yDirection = up.toVector3().normalize();
      const xDirection = forward.toVector3().cross(yDirection).normalize();
      return this._getUpdatedState({
        position: new Vector3(startPanPosition).add(xDirection.scale(deltaScaleX)).add(yDirection.scale(deltaScaleY))
      });
    }
    panEnd() {
      return this._getUpdatedState({
        startPanPos: null,
        startPanPosition: null
      });
    }
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startBearing, startPitch } = this.getState();
      const { width, height } = this.getViewportProps();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        newRotation = {
          bearing: startBearing - deltaScaleX * 180,
          pitch: startPitch - deltaScaleY * 90
        };
      } else {
        newRotation = {
          bearing: startBearing - deltaAngleX,
          pitch: startPitch - deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startRotatePos: null,
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart() {
      return this._getUpdatedState({
        startZoomPosition: this.getViewportProps().position
      });
    }
    zoom({ pos, scale: scale7 }) {
      const viewportProps = this.getViewportProps();
      const startZoomPosition = this.getState().startZoomPosition || viewportProps.position;
      const viewport = this.makeViewport(viewportProps);
      const { projectionMatrix, width } = viewport;
      const fovxRadians = 2 * Math.atan(1 / projectionMatrix[0]);
      const angle3 = fovxRadians * (pos[0] / width - 0.5);
      const direction = this.getDirection(true);
      return this._move(
        direction.rotateZ({ radians: -angle3 }),
        Math.log2(scale7) * MOVEMENT_SPEED,
        startZoomPosition
      );
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null
      });
    }
    moveLeft(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({ radians: Math.PI / 2 }), speed);
    }
    moveRight(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.rotateZ({ radians: -Math.PI / 2 }), speed);
    }
    moveUp(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction, speed);
    }
    moveDown(speed = MOVEMENT_SPEED) {
      const direction = this.getDirection(true);
      return this._move(direction.negate(), speed);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    zoomIn(speed = MOVEMENT_SPEED) {
      return this._move(new Vector3(0, 0, 1), speed);
    }
    zoomOut(speed = MOVEMENT_SPEED) {
      return this._move(new Vector3(0, 0, -1), speed);
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { bearing, longitude } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    _move(direction, speed, fromPosition = this.getViewportProps().position) {
      const delta = direction.scale(speed);
      return this._getUpdatedState({
        position: new Vector3(fromPosition).add(delta)
      });
    }
    getDirection(use2D = false) {
      const spherical = new SphericalCoordinates({
        bearing: this.getViewportProps().bearing,
        pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
      });
      const direction = spherical.toVector3().normalize();
      return direction;
    }
    _getUpdatedState(newProps) {
      return new FirstPersonState({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    applyConstraints(props) {
      const { pitch, maxPitch, minPitch, longitude, bearing } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      if (longitude !== null && (longitude < -180 || longitude > 180)) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      if (bearing < -180 || bearing > 180) {
        props.bearing = mod2(bearing + 180, 360) - 180;
      }
      return props;
    }
  };
  var FirstPersonController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = FirstPersonState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["position", "pitch", "bearing"])
      };
    }
  };

  // ../core/src/views/first-person-view.ts
  var FirstPersonView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    get ViewportType() {
      return FirstPersonViewport;
    }
    get ControllerType() {
      return FirstPersonController;
    }
  };
  FirstPersonView.displayName = "FirstPersonView";

  // ../core/src/controllers/orbit-controller.ts
  var OrbitState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        rotationX = 0,
        rotationOrbit = 0,
        target = [0, 0, 0],
        zoom = 0,
        minRotationX = -90,
        maxRotationX = 90,
        minZoom = -Infinity,
        maxZoom = Infinity,
        startPanPosition,
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        startZoomPosition,
        startZoom
      } = options;
      super(
        {
          width,
          height,
          rotationX,
          rotationOrbit,
          target,
          zoom,
          minRotationX,
          maxRotationX,
          minZoom,
          maxZoom
        },
        {
          startPanPosition,
          startRotatePos,
          startRotationX,
          startRotationOrbit,
          startZoomPosition,
          startZoom
        }
      );
      this.makeViewport = options.makeViewport;
    }
    panStart({ pos }) {
      return this._getUpdatedState({
        startPanPosition: this._unproject(pos)
      });
    }
    pan({ pos, startPosition }) {
      const startPanPosition = this.getState().startPanPosition || startPosition;
      if (!startPanPosition) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanPosition, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanPosition: null
      });
    }
    rotateStart({ pos }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startRotationX: this.getViewportProps().rotationX,
        startRotationOrbit: this.getViewportProps().rotationOrbit
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const { startRotatePos, startRotationX, startRotationOrbit } = this.getState();
      const { width, height } = this.getViewportProps();
      if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        if (startRotationX < -90 || startRotationX > 90) {
          deltaScaleX *= -1;
        }
        newRotation = {
          rotationX: startRotationX + deltaScaleY * 180,
          rotationOrbit: startRotationOrbit + deltaScaleX * 180
        };
      } else {
        newRotation = {
          rotationX: startRotationX + deltaAngleY,
          rotationOrbit: startRotationOrbit + deltaAngleX
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = { ...this.getViewportProps() };
      const { rotationOrbit } = props;
      if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
        props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
      }
      return props;
    }
    zoomStart({ pos }) {
      return this._getUpdatedState({
        startZoomPosition: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale7
    }) {
      let { startZoom, startZoomPosition } = this.getState();
      if (!startZoomPosition) {
        startZoom = this.getViewportProps().zoom;
        startZoomPosition = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomPosition) {
        return this;
      }
      const newZoom = this._calculateNewZoom({ scale: scale7, startZoom });
      const zoomedViewport = this.makeViewport({ ...this.getViewportProps(), zoom: newZoom });
      return this._getUpdatedState({
        zoom: newZoom,
        ...zoomedViewport.panByPosition(startZoomPosition, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({ scale: speed })
      });
    }
    zoomOut(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({ scale: 1 / speed })
      });
    }
    moveLeft(speed = 50) {
      return this._panFromCenter([-speed, 0]);
    }
    moveRight(speed = 50) {
      return this._panFromCenter([speed, 0]);
    }
    moveUp(speed = 50) {
      return this._panFromCenter([0, -speed]);
    }
    moveDown(speed = 50) {
      return this._panFromCenter([0, speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX - speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX + speed
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _calculateNewZoom({
      scale: scale7,
      startZoom
    }) {
      const { maxZoom, minZoom } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      const zoom = startZoom + Math.log2(scale7);
      return clamp(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
      const { width, height, target } = this.getViewportProps();
      return this.pan({
        startPosition: target,
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit } = props;
      props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
      props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
      if (rotationOrbit < -180 || rotationOrbit > 180) {
        props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
      }
      return props;
    }
  };
  var OrbitController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = OrbitState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["target", "zoom", "rotationX", "rotationOrbit"],
            required: ["target", "zoom"]
          }
        })
      };
    }
  };

  // ../core/src/views/orbit-view.ts
  var OrbitView = class extends View {
    constructor(props = {}) {
      super(props);
      this.props.orbitAxis = props.orbitAxis || "Z";
    }
    get ViewportType() {
      return OrbitViewport;
    }
    get ControllerType() {
      return OrbitController;
    }
  };
  OrbitView.displayName = "OrbitView";

  // ../core/src/controllers/orthographic-controller.ts
  var OrthographicState = class extends OrbitState {
    constructor(props) {
      super(props);
      this.zoomAxis = props.zoomAxis || "all";
    }
    _calculateNewZoom({ scale: scale7, startZoom }) {
      const { maxZoom, minZoom } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      let deltaZoom = Math.log2(scale7);
      if (Array.isArray(startZoom)) {
        let [newZoomX, newZoomY] = startZoom;
        switch (this.zoomAxis) {
          case "X":
            newZoomX = clamp(newZoomX + deltaZoom, minZoom, maxZoom);
            break;
          case "Y":
            newZoomY = clamp(newZoomY + deltaZoom, minZoom, maxZoom);
            break;
          default:
            let z2 = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z2 < minZoom) {
              deltaZoom += minZoom - z2;
            }
            z2 = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);
            if (z2 > maxZoom) {
              deltaZoom += maxZoom - z2;
            }
            newZoomX += deltaZoom;
            newZoomY += deltaZoom;
        }
        return [newZoomX, newZoomY];
      }
      return clamp(startZoom + deltaZoom, minZoom, maxZoom);
    }
  };
  var OrthographicController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = OrthographicState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["target", "zoom"])
      };
      this.dragMode = "pan";
    }
    _onPanRotate() {
      return false;
    }
  };

  // ../core/src/views/orthographic-view.ts
  var OrthographicView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    get ViewportType() {
      return OrthographicViewport;
    }
    get ControllerType() {
      return OrthographicController;
    }
  };
  OrthographicView.displayName = "OrthographicView";

  // ../core/src/controllers/globe-controller.ts
  var GlobeState = class extends MapState {
    applyConstraints(props) {
      const { maxZoom, minZoom, zoom } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const { longitude, latitude } = props;
      if (longitude < -180 || longitude > 180) {
        props.longitude = mod2(longitude + 180, 360) - 180;
      }
      props.latitude = clamp(latitude, -89, 89);
      return props;
    }
  };
  var GlobeController = class extends Controller {
    constructor() {
      super(...arguments);
      this.ControllerState = GlobeState;
      this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"])
      };
      this.dragMode = "pan";
    }
    setProps(props) {
      super.setProps(props);
      this.dragRotate = false;
      this.touchRotate = false;
    }
  };

  // ../core/src/views/globe-view.ts
  var GlobeView = class extends View {
    constructor(props = {}) {
      super(props);
    }
    get ViewportType() {
      return GlobeViewport;
    }
    get ControllerType() {
      return GlobeController;
    }
  };
  GlobeView.displayName = "GlobeView";

  // ../core/src/lib/layer-extension.ts
  var LayerExtension = class {
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "extensionName") ? this.extensionName : "";
    }
    constructor(opts) {
      if (opts) {
        this.opts = opts;
      }
    }
    equals(extension) {
      if (this === extension) {
        return true;
      }
      return this.constructor === extension.constructor && deepEqual2(this.opts, extension.opts, 1);
    }
    getShaders(extension) {
      return null;
    }
    getSubLayerProps(extension) {
      const { defaultProps: defaultProps53 } = extension.constructor;
      const newProps = {
        updateTriggers: {}
      };
      for (const key in defaultProps53) {
        if (key in this.props) {
          const propDef = defaultProps53[key];
          const propValue = this.props[key];
          newProps[key] = propValue;
          if (propDef && propDef.type === "accessor") {
            newProps.updateTriggers[key] = this.props.updateTriggers[key];
            if (typeof propValue === "function") {
              newProps[key] = this.getSubLayerAccessor(propValue);
            }
          }
        }
      }
      return newProps;
    }
    initializeState(context, extension) {
    }
    updateState(params, extension) {
    }
    onNeedsRedraw(extension) {
    }
    getNeedsPickingBuffer(extension) {
      return false;
    }
    draw(params, extension) {
    }
    finalizeState(context, extension) {
    }
  };
  LayerExtension.defaultProps = {};
  LayerExtension.extensionName = "LayerExtension";

  // ../core/src/transitions/fly-to-interpolator.ts
  var LINEARLY_INTERPOLATED_PROPS = {
    bearing: 0,
    pitch: 0,
    position: [0, 0, 0]
  };
  var DEFAULT_OPTS2 = {
    speed: 1.2,
    curve: 1.414
  };
  var FlyToInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      super({
        compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch", "position"],
        required: ["width", "height", "latitude", "longitude", "zoom"]
      });
      this.opts = { ...DEFAULT_OPTS2, ...opts };
    }
    interpolateProps(startProps, endProps, t3) {
      const viewport = flyToViewport(startProps, endProps, t3, this.opts);
      for (const key in LINEARLY_INTERPOLATED_PROPS) {
        viewport[key] = lerp(
          startProps[key] || LINEARLY_INTERPOLATED_PROPS[key],
          endProps[key] || LINEARLY_INTERPOLATED_PROPS[key],
          t3
        );
      }
      return viewport;
    }
    getDuration(startProps, endProps) {
      let { transitionDuration } = endProps;
      if (transitionDuration === "auto") {
        transitionDuration = getFlyToDuration(startProps, endProps, this.opts);
      }
      return transitionDuration;
    }
  };

  // ../core/src/utils/tesselator.ts
  var Tesselator = class {
    constructor(opts) {
      this.indexStarts = [0];
      this.vertexStarts = [0];
      this.vertexCount = 0;
      this.instanceCount = 0;
      const { attributes = {} } = opts;
      this.typedArrayManager = typed_array_manager_default;
      this.attributes = {};
      this._attributeDefs = attributes;
      this.opts = opts;
      this.updateGeometry(opts);
    }
    updateGeometry(opts) {
      Object.assign(this.opts, opts);
      const {
        data,
        buffers = {},
        getGeometry: getGeometry2,
        geometryBuffer,
        positionFormat,
        dataChanged,
        normalize: normalize6 = true
      } = this.opts;
      this.data = data;
      this.getGeometry = getGeometry2;
      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
      this.buffers = buffers;
      this.normalize = normalize6;
      if (geometryBuffer) {
        assert9(data.startIndices);
        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
        if (!normalize6) {
          buffers.vertexPositions = geometryBuffer;
        }
      }
      this.geometryBuffer = buffers.vertexPositions;
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          this._rebuildGeometry(dataRange);
        }
      } else {
        this._rebuildGeometry();
      }
    }
    updatePartialGeometry({ startRow, endRow }) {
      this._rebuildGeometry({ startRow, endRow });
    }
    getGeometryFromBuffer(geometryBuffer) {
      const value = geometryBuffer.value || geometryBuffer;
      if (!ArrayBuffer.isView(value)) {
        return null;
      }
      return getAccessorFromBuffer(value, {
        size: this.positionSize,
        offset: geometryBuffer.offset,
        stride: geometryBuffer.stride,
        startIndices: this.data.startIndices
      });
    }
    _allocate(instanceCount, copy6) {
      const { attributes, buffers, _attributeDefs, typedArrayManager } = this;
      for (const name13 in _attributeDefs) {
        if (name13 in buffers) {
          typedArrayManager.release(attributes[name13]);
          attributes[name13] = null;
        } else {
          const def = _attributeDefs[name13];
          def.copy = copy6;
          attributes[name13] = typedArrayManager.allocate(attributes[name13], instanceCount, def);
        }
      }
    }
    _forEachGeometry(visitor, startRow, endRow) {
      const { data, getGeometry: getGeometry2 } = this;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        const geometry = getGeometry2 ? getGeometry2(object, objectInfo) : null;
        visitor(geometry, objectInfo.index);
      }
    }
    _rebuildGeometry(dataRange) {
      if (!this.data) {
        return;
      }
      let { indexStarts, vertexStarts, instanceCount } = this;
      const { data, geometryBuffer } = this;
      const { startRow = 0, endRow = Infinity } = dataRange || {};
      const normalizedData = {};
      if (!dataRange) {
        indexStarts = [0];
        vertexStarts = [0];
      }
      if (this.normalize || !geometryBuffer) {
        this._forEachGeometry(
          (geometry, dataIndex) => {
            const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
            normalizedData[dataIndex] = normalizedGeometry;
            vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
          },
          startRow,
          endRow
        );
        instanceCount = vertexStarts[vertexStarts.length - 1];
      } else {
        vertexStarts = data.startIndices;
        instanceCount = vertexStarts[data.length] || 0;
        if (ArrayBuffer.isView(geometryBuffer)) {
          instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
        } else if (geometryBuffer instanceof Buffer2) {
          const byteStride = this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
        } else if (geometryBuffer.buffer) {
          const byteStride = geometryBuffer.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
        } else if (geometryBuffer.value) {
          const bufferValue = geometryBuffer.value;
          const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
          instanceCount = instanceCount || bufferValue.length / elementStride;
        }
      }
      this._allocate(instanceCount, Boolean(dataRange));
      this.indexStarts = indexStarts;
      this.vertexStarts = vertexStarts;
      this.instanceCount = instanceCount;
      const context = {};
      this._forEachGeometry(
        (geometry, dataIndex) => {
          const normalizedGeometry = normalizedData[dataIndex] || geometry;
          context.vertexStart = vertexStarts[dataIndex];
          context.indexStart = indexStarts[dataIndex];
          const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
          context.geometrySize = vertexEnd - vertexStarts[dataIndex];
          context.geometryIndex = dataIndex;
          this.updateGeometryAttributes(normalizedGeometry, context);
        },
        startRow,
        endRow
      );
      this.vertexCount = indexStarts[indexStarts.length - 1];
    }
  };

  // ../layers/src/arc-layer/arc-layer-vertex.glsl.ts
  var arc_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-vertex-shader

in vec3 positions;
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;

uniform bool greatCircle;
uniform bool useShortestPath;
uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;

out vec4 vColor;
out vec2 uv;
out float isValid;

float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
  // d: distance on the xy plane
  // r: ratio of the current point
  // p: ratio of the peak of the arc
  // h: height multiplier
  // z = f(r) = sqrt(r * (p * 2 - r)) * d * h
  // f(0) = 0
  // f(1) = dz

  float deltaZ = targetZ - sourceZ;
  float dh = distance * instanceHeights;
  if (dh == 0.0) {
    return sourceZ + deltaZ * ratio;
  }
  float unitZ = deltaZ / dh;
  float p2 = unitZ * unitZ + 1.0;

  // sqrt does not deal with negative values, manually flip source and target if delta.z < 0
  float dir = step(deltaZ, 0.0);
  float z0 = mix(sourceZ, targetZ, dir);
  float r = mix(ratio, 1.0 - ratio, dir);
  return sqrt(r * (p2 - r)) * dh + z0;
}

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

float getSegmentRatio(float index) {
  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}

vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
  float distance = length(source.xy - target.xy);
  float z = paraboloid(distance, source.z, target.z, segmentRatio);

  float tiltAngle = radians(instanceTilts);
  vec2 tiltDirection = normalize(target.xy - source.xy);
  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);

  return vec3(
    mix(source.xy, target.xy, segmentRatio) + tilt,
    z * cos(tiltAngle)
  );
}

/* Great circle interpolation
 * http://www.movable-type.co.uk/scripts/latlong.html
 */
float getAngularDist (vec2 source, vec2 target) {
  vec2 sourceRadians = radians(source);
  vec2 targetRadians = radians(target);
  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
  vec2 shd_sq = sin_half_delta * sin_half_delta;

  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
  return 2.0 * asin(sqrt(a));
}

vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
  vec2 lngLat;

  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation
  if(abs(angularDist - PI) < 0.001) {
    lngLat = (1.0 - t) * source.xy + t * target.xy;
  } else {
    float a = sin((1.0 - t) * angularDist);
    float b = sin(t * angularDist);
    vec3 p = source3D.yxz * a + target3D.yxz * b;
    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
  }

  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);

  return vec3(lngLat, z);
}

/* END GREAT CIRCLE */

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  float segmentIndex = positions.x;
  float segmentRatio = getSegmentRatio(segmentIndex);
  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));

  // if it's the first point, use next - current as direction
  // otherwise use current - prev
  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
  isValid = 1.0;

  uv = vec2(segmentRatio, positions.y);
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  vec4 curr;
  vec4 next;
  vec3 source;
  vec3 target;

  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);

    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);

    if (abs(currPos.x - prevPos.x) > 180.0) {
      indexDir = -1.0;
      isValid = 0.0;
    } else if (abs(currPos.x - nextPos.x) > 180.0) {
      indexDir = 1.0;
      isValid = 0.0;
    }
    nextPos = indexDir < 0.0 ? prevPos : nextPos;
    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;

    if (isValid == 0.0) {
      // split at the 180th meridian
      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
      currPos = mix(currPos, nextPos, t);
      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
    }

    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
  
    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
  
  } else {
    vec3 source_world = instanceSourcePositions;
    vec3 target_world = instanceTargetPositions;
    if (useShortestPath) {
      source_world.x = mod(source_world.x + 180., 360.0) - 180.;
      target_world.x = mod(target_world.x + 180., 360.0) - 180.;

      float deltaLng = target_world.x - source_world.x;
      if (deltaLng > 180.) target_world.x -= 360.;
      if (deltaLng < -180.) source_world.x -= 360.;
    }
    source = project_position(source_world, instanceSourcePositions64Low);
    target = project_position(target_world, instanceTargetPositions64Low);

    // common x at longitude=-180
    float antiMeridianX = 0.0;

    if (useShortestPath) {
      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;
      }
      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);

      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
        isValid = 0.0;
        indexDir = sign(segmentRatio - thresholdRatio);
        segmentRatio = thresholdRatio;
      }
    }

    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
    vec3 currPos = interpolateFlat(source, target, segmentRatio);
    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);

    if (useShortestPath) {
      if (nextPos.x < antiMeridianX) {
        currPos.x += TILE_SIZE;
        nextPos.x += TILE_SIZE;
      }
    }

    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
    geometry.position = vec4(currPos, 1.0);
  }

  // Multiply out width and clamp to limits
  // mercator pixels are interpreted as screen pixels
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(curr, geometry);
  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
  vColor = vec4(color.rgb, color.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer-fragment.glsl.ts
  var arc_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME arc-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 uv;
in float isValid;

out vec4 fragColor;

void main(void) {
  if (isValid == 0.0) {
    discard;
  }

  fragColor = vColor;
  geometry.uv = uv;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/arc-layer/arc-layer.ts
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps3 = {
    getSourcePosition: { type: "accessor", value: (x3) => x3.sourcePosition },
    getTargetPosition: { type: "accessor", value: (x3) => x3.targetPosition },
    getSourceColor: { type: "accessor", value: DEFAULT_COLOR },
    getTargetColor: { type: "accessor", value: DEFAULT_COLOR },
    getWidth: { type: "accessor", value: 1 },
    getHeight: { type: "accessor", value: 1 },
    getTilt: { type: "accessor", value: 0 },
    greatCircle: false,
    numSegments: { type: "number", value: 50, min: 1 },
    widthUnits: "pixels",
    widthScale: { type: "number", value: 1, min: 0 },
    widthMinPixels: { type: "number", value: 0, min: 0 },
    widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
  };
  var ArcLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds([
        "instanceSourcePositions",
        "instanceTargetPositions"
      ]);
    }
    getShaders() {
      return super.getShaders({ vs: arc_layer_vertex_glsl_default, fs: arc_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceSourceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getSourceColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceTargetColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getTargetColor",
          defaultValue: DEFAULT_COLOR
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        },
        instanceHeights: {
          size: 1,
          transition: true,
          accessor: "getHeight",
          defaultValue: 1
        },
        instanceTilts: {
          size: 1,
          transition: true,
          accessor: "getTilt",
          defaultValue: 0
        }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      const { props, oldProps, changeFlags } = opts;
      if (changeFlags.extensionsChanged || props.numSegments !== oldProps.numSegments) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle, wrapLongitude } = this.props;
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        greatCircle,
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude
      });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const { numSegments } = this.props;
      let positions = [];
      for (let i5 = 0; i5 < numSegments; i5++) {
        positions = positions.concat([i5, 1, 0, i5, -1, 0]);
      }
      const model = new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: { size: 3, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
      model.setUniforms({ numSegments });
      return model;
    }
  };
  ArcLayer.layerName = "ArcLayer";
  ArcLayer.defaultProps = defaultProps3;

  // ../layers/src/bitmap-layer/create-mesh.ts
  var DEFAULT_INDICES = new Uint32Array([0, 2, 1, 0, 3, 2]);
  var DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  function createMesh(bounds, resolution) {
    if (!resolution) {
      return createQuad(bounds);
    }
    const maxXSpan = Math.max(
      Math.abs(bounds[0][0] - bounds[3][0]),
      Math.abs(bounds[1][0] - bounds[2][0])
    );
    const maxYSpan = Math.max(
      Math.abs(bounds[1][1] - bounds[0][1]),
      Math.abs(bounds[2][1] - bounds[3][1])
    );
    const uCount = Math.ceil(maxXSpan / resolution) + 1;
    const vCount = Math.ceil(maxYSpan / resolution) + 1;
    const vertexCount = (uCount - 1) * (vCount - 1) * 6;
    const indices = new Uint32Array(vertexCount);
    const texCoords = new Float32Array(uCount * vCount * 2);
    const positions = new Float64Array(uCount * vCount * 3);
    let vertex = 0;
    let index2 = 0;
    for (let u3 = 0; u3 < uCount; u3++) {
      const ut = u3 / (uCount - 1);
      for (let v2 = 0; v2 < vCount; v2++) {
        const vt = v2 / (vCount - 1);
        const p3 = interpolateQuad(bounds, ut, vt);
        positions[vertex * 3 + 0] = p3[0];
        positions[vertex * 3 + 1] = p3[1];
        positions[vertex * 3 + 2] = p3[2] || 0;
        texCoords[vertex * 2 + 0] = ut;
        texCoords[vertex * 2 + 1] = 1 - vt;
        if (u3 > 0 && v2 > 0) {
          indices[index2++] = vertex - vCount;
          indices[index2++] = vertex - vCount - 1;
          indices[index2++] = vertex - 1;
          indices[index2++] = vertex - vCount;
          indices[index2++] = vertex - 1;
          indices[index2++] = vertex;
        }
        vertex++;
      }
    }
    return {
      vertexCount,
      positions,
      indices,
      texCoords
    };
  }
  function createQuad(bounds) {
    const positions = new Float64Array(12);
    for (let i5 = 0; i5 < bounds.length; i5++) {
      positions[i5 * 3 + 0] = bounds[i5][0];
      positions[i5 * 3 + 1] = bounds[i5][1];
      positions[i5 * 3 + 2] = bounds[i5][2] || 0;
    }
    return {
      vertexCount: 6,
      positions,
      indices: DEFAULT_INDICES,
      texCoords: DEFAULT_TEX_COORDS
    };
  }
  function interpolateQuad(quad, ut, vt) {
    return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
  }

  // ../layers/src/bitmap-layer/bitmap-layer-vertex.ts
  var bitmap_layer_vertex_default = `#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer-fragment.ts
  var packUVsIntoRGB = `
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`;
  var bitmap_layer_fragment_default = `#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

${packUVsIntoRGB}

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;

  // ../layers/src/bitmap-layer/bitmap-layer.ts
  var defaultProps4 = {
    image: { type: "image", value: null, async: true },
    bounds: { type: "array", value: [1, 0, 0, 1], compare: true },
    _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    desaturate: { type: "number", min: 0, max: 1, value: 0 },
    transparentColor: { type: "color", value: [0, 0, 0, 0] },
    tintColor: { type: "color", value: [255, 255, 255] },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var BitmapLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: bitmap_layer_vertex_default, fs: bitmap_layer_fragment_default, modules: [project32_default, picking_default] });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.remove(["instancePickingColors"]);
      const noAlloc = true;
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: (attribute) => attribute.value = this.state.mesh.indices,
          noAlloc
        },
        positions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          update: (attribute) => attribute.value = this.state.mesh.positions,
          noAlloc
        },
        texCoords: {
          size: 2,
          update: (attribute) => attribute.value = this.state.mesh.texCoords,
          noAlloc
        }
      });
    }
    updateState({ props, oldProps, changeFlags }) {
      const attributeManager = this.getAttributeManager();
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
      if (props.bounds !== oldProps.bounds) {
        const oldMesh = this.state.mesh;
        const mesh = this._createMesh();
        this.state.model.setVertexCount(mesh.vertexCount);
        for (const key in mesh) {
          if (oldMesh && oldMesh[key] !== mesh[key]) {
            attributeManager.invalidate(key);
          }
        }
        this.setState({ mesh, ...this._getCoordinateUniforms() });
      } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {
        this.setState(this._getCoordinateUniforms());
      }
    }
    getPickingInfo(params) {
      const { image } = this.props;
      const info = params.info;
      if (!info.color || !image) {
        info.bitmap = null;
        return info;
      }
      const { width, height } = image;
      info.index = 0;
      const uv = unpackUVsFromRGB(info.color);
      info.bitmap = {
        size: { width, height },
        uv,
        pixel: [Math.floor(uv[0] * width), Math.floor(uv[1] * height)]
      };
      return info;
    }
    disablePickingIndex() {
      this.setState({ disablePicking: true });
    }
    restorePickingColors() {
      this.setState({ disablePicking: false });
    }
    _updateAutoHighlight(info) {
      super._updateAutoHighlight({
        ...info,
        color: this.encodePickingColor(0)
      });
    }
    _createMesh() {
      const { bounds } = this.props;
      let normalizedBounds = bounds;
      if (isRectangularBounds(bounds)) {
        normalizedBounds = [
          [bounds[0], bounds[1]],
          [bounds[0], bounds[3]],
          [bounds[2], bounds[3]],
          [bounds[2], bounds[1]]
        ];
      }
      return createMesh(normalizedBounds, this.context.viewport.resolution);
    }
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        topology: "triangle-list",
        isInstanced: false
      });
    }
    draw(opts) {
      const { uniforms, moduleParameters } = opts;
      const { model, coordinateConversion, bounds, disablePicking } = this.state;
      const { image, desaturate, transparentColor, tintColor } = this.props;
      if (moduleParameters.picking.isActive && disablePicking) {
        return;
      }
      if (image && model) {
        model.setUniforms(uniforms);
        model.setBindings({ bitmapTexture: image });
        model.setUniforms({
          desaturate,
          transparentColor: transparentColor.map((x3) => x3 / 255),
          tintColor: tintColor.slice(0, 3).map((x3) => x3 / 255),
          coordinateConversion,
          bounds
        });
        model.draw(this.context.renderPass);
      }
    }
    _getCoordinateUniforms() {
      const { LNGLAT, CARTESIAN, DEFAULT } = COORDINATE_SYSTEM;
      let { _imageCoordinateSystem: imageCoordinateSystem } = this.props;
      if (imageCoordinateSystem !== DEFAULT) {
        const { bounds } = this.props;
        if (!isRectangularBounds(bounds)) {
          throw new Error("_imageCoordinateSystem only supports rectangular bounds");
        }
        const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;
        imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;
        if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {
          return { coordinateConversion: -1, bounds };
        }
        if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {
          const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);
          const topRight = lngLatToWorld([bounds[2], bounds[3]]);
          return {
            coordinateConversion: 1,
            bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]
          };
        }
      }
      return {
        coordinateConversion: 0,
        bounds: [0, 0, 0, 0]
      };
    }
  };
  BitmapLayer.layerName = "BitmapLayer";
  BitmapLayer.defaultProps = defaultProps4;
  function unpackUVsFromRGB(color) {
    const [u3, v2, fracUV] = color;
    const vFrac = (fracUV & 240) / 256;
    const uFrac = (fracUV & 15) / 16;
    return [(u3 + uFrac) / 256, (v2 + vFrac) / 256];
  }
  function isRectangularBounds(bounds) {
    return Number.isFinite(bounds[0]);
  }

  // ../layers/src/icon-layer/icon-layer-vertex.glsl.ts
  var icon_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-vertex-shader

in vec2 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;

uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;

out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;

  vec2 iconSize = instanceIconFrames.zw;
  // convert size in meters to pixels, then scaled and clamp
 
  // project meters to pixels and clamp to limits 
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), 
    sizeMinPixels, sizeMaxPixels
  );

  // scale icon height to match instanceSize
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;

  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
  pixelOffset += instancePixelOffset;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); 
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / iconsTextureDim;

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);

  vColorMode = instanceColorModes;
}
`;

  // ../layers/src/icon-layer/icon-layer-fragment.glsl.ts
  var icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;

in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  vec4 texColor = texture(iconsTexture, vTextureCoords);

  // if colorMode == 0, use pixel color from the texture
  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask
  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
  // Take the global opacity and the alpha from vColor into account for the alpha component
  float a = texColor.a * opacity * vColor.a;

  if (a < alphaCutoff) {
    discard;
  }

  fragColor = vec4(color, a);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/icon-layer/icon-manager.ts
  var DEFAULT_CANVAS_WIDTH = 1024;
  var DEFAULT_BUFFER = 4;
  var noop4 = () => {
  };
  var DEFAULT_SAMPLER_PARAMETERS = {
    minFilter: "linear",
    mipmapFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  };
  var MISSING_ICON = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  function nextPowOfTwo(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function resizeImage(ctx2, imageData, maxWidth, maxHeight) {
    const resizeRatio = Math.min(maxWidth / imageData.width, maxHeight / imageData.height);
    const width = Math.floor(imageData.width * resizeRatio);
    const height = Math.floor(imageData.height * resizeRatio);
    if (resizeRatio === 1) {
      return { data: imageData, width, height };
    }
    ctx2.canvas.height = height;
    ctx2.canvas.width = width;
    ctx2.clearRect(0, 0, width, height);
    ctx2.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
    return { data: ctx2.canvas, width, height };
  }
  function getIconId(icon) {
    return icon && (icon.id || icon.url);
  }
  function resizeTexture(texture, width, height, sampler) {
    const { width: oldWidth, height: oldHeight, device } = texture;
    const newTexture = device.createTexture({ format: "rgba8unorm", width, height, sampler });
    const commandEncoder = device.createCommandEncoder();
    commandEncoder.copyTextureToTexture({
      source: texture,
      destination: newTexture,
      width: oldWidth,
      height: oldHeight
    });
    commandEncoder.finish();
    texture.destroy();
    return newTexture;
  }
  function buildRowMapping(mapping, columns, yOffset) {
    for (let i5 = 0; i5 < columns.length; i5++) {
      const { icon, xOffset } = columns[i5];
      const id = getIconId(icon);
      mapping[id] = {
        ...icon,
        x: xOffset,
        y: yOffset
      };
    }
  }
  function buildMapping({
    icons,
    buffer,
    mapping = {},
    xOffset = 0,
    yOffset = 0,
    rowHeight = 0,
    canvasWidth
  }) {
    let columns = [];
    for (let i5 = 0; i5 < icons.length; i5++) {
      const icon = icons[i5];
      const id = getIconId(icon);
      if (!mapping[id]) {
        const { height, width } = icon;
        if (xOffset + width + buffer > canvasWidth) {
          buildRowMapping(mapping, columns, yOffset);
          xOffset = 0;
          yOffset = rowHeight + yOffset + buffer;
          rowHeight = 0;
          columns = [];
        }
        columns.push({
          icon,
          xOffset
        });
        xOffset = xOffset + width + buffer;
        rowHeight = Math.max(rowHeight, height);
      }
    }
    if (columns.length > 0) {
      buildRowMapping(mapping, columns, yOffset);
    }
    return {
      mapping,
      rowHeight,
      xOffset,
      yOffset,
      canvasWidth,
      canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
    };
  }
  function getDiffIcons(data, getIcon, cachedIcons) {
    if (!data || !getIcon) {
      return null;
    }
    cachedIcons = cachedIcons || {};
    const icons = {};
    const { iterable, objectInfo } = createIterable(data);
    for (const object of iterable) {
      objectInfo.index++;
      const icon = getIcon(object, objectInfo);
      const id = getIconId(icon);
      if (!icon) {
        throw new Error("Icon is missing.");
      }
      if (!icon.url) {
        throw new Error("Icon url is missing.");
      }
      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
        icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index };
      }
    }
    return icons;
  }
  var IconManager = class {
    constructor(device, {
      onUpdate = noop4,
      onError = noop4
    }) {
      this._loadOptions = null;
      this._texture = null;
      this._externalTexture = null;
      this._mapping = {};
      this._textureParameters = null;
      this._pendingCount = 0;
      this._autoPacking = false;
      this._xOffset = 0;
      this._yOffset = 0;
      this._rowHeight = 0;
      this._buffer = DEFAULT_BUFFER;
      this._canvasWidth = DEFAULT_CANVAS_WIDTH;
      this._canvasHeight = 0;
      this._canvas = null;
      this.device = device;
      this.onUpdate = onUpdate;
      this.onError = onError;
    }
    finalize() {
      this._texture?.delete();
    }
    getTexture() {
      return this._texture || this._externalTexture;
    }
    getIconMapping(icon) {
      const id = this._autoPacking ? getIconId(icon) : icon;
      return this._mapping[id] || MISSING_ICON;
    }
    setProps({
      loadOptions,
      autoPacking,
      iconAtlas,
      iconMapping,
      textureParameters
    }) {
      if (loadOptions) {
        this._loadOptions = loadOptions;
      }
      if (autoPacking !== void 0) {
        this._autoPacking = autoPacking;
      }
      if (iconMapping) {
        this._mapping = iconMapping;
      }
      if (iconAtlas) {
        this._texture?.delete();
        this._texture = null;
        this._externalTexture = iconAtlas;
      }
      if (textureParameters) {
        this._textureParameters = textureParameters;
      }
    }
    get isLoaded() {
      return this._pendingCount === 0;
    }
    packIcons(data, getIcon) {
      if (!this._autoPacking || typeof document === "undefined") {
        return;
      }
      const icons = Object.values(getDiffIcons(data, getIcon, this._mapping) || {});
      if (icons.length > 0) {
        const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({
          icons,
          buffer: this._buffer,
          canvasWidth: this._canvasWidth,
          mapping: this._mapping,
          rowHeight: this._rowHeight,
          xOffset: this._xOffset,
          yOffset: this._yOffset
        });
        this._rowHeight = rowHeight;
        this._mapping = mapping;
        this._xOffset = xOffset;
        this._yOffset = yOffset;
        this._canvasHeight = canvasHeight;
        if (!this._texture) {
          this._texture = this.device.createTexture({
            format: "rgba8unorm",
            width: this._canvasWidth,
            height: this._canvasHeight,
            sampler: this._textureParameters || DEFAULT_SAMPLER_PARAMETERS
          });
        }
        if (this._texture.height !== this._canvasHeight) {
          this._texture = resizeTexture(
            this._texture,
            this._canvasWidth,
            this._canvasHeight,
            this._textureParameters || DEFAULT_SAMPLER_PARAMETERS
          );
        }
        this.onUpdate();
        this._canvas = this._canvas || document.createElement("canvas");
        this._loadIcons(icons);
      }
    }
    _loadIcons(icons) {
      const ctx2 = this._canvas.getContext("2d", {
        willReadFrequently: true
      });
      for (const icon of icons) {
        this._pendingCount++;
        load(icon.url, this._loadOptions).then((imageData) => {
          const id = getIconId(icon);
          const iconDef = this._mapping[id];
          const { x: x3, y: y3, width: maxWidth, height: maxHeight } = iconDef;
          const { data, width, height } = resizeImage(
            ctx2,
            imageData,
            maxWidth,
            maxHeight
          );
          this._texture.setSubImageData({
            data,
            x: x3 + (maxWidth - width) / 2,
            y: y3 + (maxHeight - height) / 2,
            width,
            height
          });
          iconDef.width = width;
          iconDef.height = height;
          this._texture.generateMipmap();
          this.onUpdate();
        }).catch((error) => {
          this.onError({
            url: icon.url,
            source: icon.source,
            sourceIndex: icon.sourceIndex,
            loadOptions: this._loadOptions,
            error
          });
        }).finally(() => {
          this._pendingCount--;
        });
      }
    }
  };

  // ../layers/src/icon-layer/icon-layer.ts
  var DEFAULT_COLOR2 = [0, 0, 0, 255];
  var defaultProps5 = {
    iconAtlas: { type: "image", value: null, async: true },
    iconMapping: { type: "object", value: {}, async: true },
    sizeScale: { type: "number", value: 1, min: 0 },
    billboard: true,
    sizeUnits: "pixels",
    sizeMinPixels: { type: "number", min: 0, value: 0 },
    sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    alphaCutoff: { type: "number", value: 0.05, min: 0, max: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getIcon: { type: "accessor", value: (x3) => x3.icon },
    getColor: { type: "accessor", value: DEFAULT_COLOR2 },
    getSize: { type: "accessor", value: 1 },
    getAngle: { type: "accessor", value: 0 },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    onIconError: { type: "function", value: null, optional: true },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var IconLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: icon_layer_vertex_glsl_default, fs: icon_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    initializeState() {
      this.state = {
        iconManager: new IconManager(this.context.device, {
          onUpdate: this._onUpdate.bind(this),
          onError: this._onError.bind(this)
        })
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceOffsets: {
          size: 2,
          accessor: "getIcon",
          transform: this.getInstanceOffset
        },
        instanceIconFrames: {
          size: 4,
          accessor: "getIcon",
          transform: this.getInstanceIconFrame
        },
        instanceColorModes: {
          size: 1,
          type: "uint8",
          accessor: "getIcon",
          transform: this.getInstanceColorMode
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR2
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instancePixelOffset: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const attributeManager = this.getAttributeManager();
      const { iconAtlas, iconMapping, data, getIcon, textureParameters } = props;
      const { iconManager } = this.state;
      if (typeof iconAtlas === "string") {
        return;
      }
      const prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
      iconManager.setProps({
        loadOptions: props.loadOptions,
        autoPacking: !prePacked,
        iconAtlas,
        iconMapping: prePacked ? iconMapping : null,
        textureParameters
      });
      if (prePacked) {
        if (oldProps.iconMapping !== props.iconMapping) {
          attributeManager.invalidate("getIcon");
        }
      } else if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
        iconManager.packIcons(data, getIcon);
      }
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
    }
    get isLoaded() {
      return super.isLoaded && this.state.iconManager.isLoaded;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.iconManager.finalize();
    }
    draw({ uniforms }) {
      const { sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff } = this.props;
      const { iconManager } = this.state;
      const iconsTexture = iconManager.getTexture();
      if (iconsTexture) {
        const model = this.state.model;
        model.setBindings({ iconsTexture });
        model.setUniforms(uniforms);
        model.setUniforms({
          iconsTextureDim: [iconsTexture.width, iconsTexture.height],
          sizeUnits: UNIT[sizeUnits],
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          billboard,
          alphaCutoff
        });
        model.draw(this.context.renderPass);
      }
    }
    _getModel() {
      const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: {
              size: 2,
              value: new Float32Array(positions)
            }
          }
        }),
        isInstanced: true
      });
    }
    _onUpdate() {
      this.setNeedsRedraw();
    }
    _onError(evt) {
      const onIconError = this.getCurrentLayer()?.props.onIconError;
      if (onIconError) {
        onIconError(evt);
      } else {
        log_default.error(evt.error.message)();
      }
    }
    getInstanceOffset(icon) {
      const {
        width,
        height,
        anchorX = width / 2,
        anchorY = height / 2
      } = this.state.iconManager.getIconMapping(icon);
      return [width / 2 - anchorX, height / 2 - anchorY];
    }
    getInstanceColorMode(icon) {
      const mapping = this.state.iconManager.getIconMapping(icon);
      return mapping.mask ? 1 : 0;
    }
    getInstanceIconFrame(icon) {
      const { x: x3, y: y3, width, height } = this.state.iconManager.getIconMapping(icon);
      return [x3, y3, width, height];
    }
  };
  IconLayer.defaultProps = defaultProps5;
  IconLayer.layerName = "IconLayer";

  // ../layers/src/line-layer/line-layer-vertex.glsl.ts
  var line_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-vertex-shader

in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;

uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float useShortestPath;
uniform int widthUnits;

out vec4 vColor;
out vec2 uv;

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  return dir_screenspace * offset_direction * width / 2.0;
}

vec3 splitLine(vec3 a, vec3 b, float x) {
  float t = (x - a.x) / (b.x - a.x);
  return vec3(x, mix(a.yz, b.yz, t));
}

void main(void) {
  geometry.worldPosition = instanceSourcePositions;
  geometry.worldPositionAlt = instanceTargetPositions;

  vec3 source_world = instanceSourcePositions;
  vec3 target_world = instanceTargetPositions;
  vec3 source_world_64low = instanceSourcePositions64Low;
  vec3 target_world_64low = instanceTargetPositions64Low;

  if (useShortestPath > 0.5 || useShortestPath < -0.5) {
    source_world.x = mod(source_world.x + 180., 360.0) - 180.;
    target_world.x = mod(target_world.x + 180., 360.0) - 180.;
    float deltaLng = target_world.x - source_world.x;

    if (deltaLng * useShortestPath > 180.) {
      source_world.x += 360. * useShortestPath;
      source_world = splitLine(source_world, target_world, 180. * useShortestPath);
      source_world_64low = vec3(0.0);
    } else if (deltaLng * useShortestPath < -180.) {
      target_world.x += 360. * useShortestPath;
      target_world = splitLine(source_world, target_world, 180. * useShortestPath);
      target_world_64low = vec3(0.0);
    } else if (useShortestPath < 0.) {
      // Line is not split, abort
      gl_Position = vec4(0.);
      return;
    }
  }

  // Position
  vec4 source_commonspace;
  vec4 target_commonspace;
  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
  
  // linear interpolation of source & target to pick right coord
  float segmentIndex = positions.x;
  vec4 p = mix(source, target, segmentIndex);
  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
  uv = positions.xy;
  geometry.uv = uv;
  geometry.pickingColor = instancePickingColors;

  // Multiply out width and clamp to limits
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels
  );

  // extrude
  vec3 offset = vec3(
    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
    0.0);
  DECKGL_FILTER_SIZE(offset, geometry);
  DECKGL_FILTER_GL_POSITION(p, geometry);
  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);

  // Color
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer-fragment.glsl.ts
  var line_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME line-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/line-layer/line-layer.ts
  var DEFAULT_COLOR3 = [0, 0, 0, 255];
  var defaultProps6 = {
    getSourcePosition: { type: "accessor", value: (x3) => x3.sourcePosition },
    getTargetPosition: { type: "accessor", value: (x3) => x3.targetPosition },
    getColor: { type: "accessor", value: DEFAULT_COLOR3 },
    getWidth: { type: "accessor", value: 1 },
    widthUnits: "pixels",
    widthScale: { type: "number", value: 1, min: 0 },
    widthMinPixels: { type: "number", value: 0, min: 0 },
    widthMaxPixels: { type: "number", value: Number.MAX_SAFE_INTEGER, min: 0 }
  };
  var LineLayer = class extends Layer {
    getBounds() {
      return this.getAttributeManager()?.getBounds([
        "instanceSourcePositions",
        "instanceTargetPositions"
      ]);
    }
    getShaders() {
      return super.getShaders({ vs: line_layer_vertex_glsl_default, fs: line_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const { widthUnits, widthScale, widthMinPixels, widthMaxPixels, wrapLongitude } = this.props;
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude ? 1 : 0
      });
      model.draw(this.context.renderPass);
      if (wrapLongitude) {
        model.setUniforms({
          useShortestPath: -1
        });
        model.draw(this.context.renderPass);
      }
    }
    _getModel() {
      const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: { size: 3, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  LineLayer.layerName = "LineLayer";
  LineLayer.defaultProps = defaultProps6;

  // ../layers/src/point-cloud-layer/point-cloud-layer-vertex.glsl.ts
  var point_cloud_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader

in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;

out vec4 vColor;
out vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);

  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  // Find the center of the point and add the current vertex
  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);

  // Apply lighting
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);

  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(lightColor, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer-fragment.glsl.ts
  var point_cloud_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

in vec4 vColor;
in vec2 unitPosition;

out vec4 fragColor;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  fragColor = vColor;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/point-cloud-layer/point-cloud-layer.ts
  var DEFAULT_COLOR4 = [0, 0, 0, 255];
  var DEFAULT_NORMAL = [0, 0, 1];
  var defaultProps7 = {
    sizeUnits: "pixels",
    pointSize: { type: "number", min: 0, value: 10 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getNormal: { type: "accessor", value: DEFAULT_NORMAL },
    getColor: { type: "accessor", value: DEFAULT_COLOR4 },
    material: true,
    radiusPixels: { deprecatedFor: "pointSize" }
  };
  function normalizeData(data) {
    const { header, attributes } = data;
    if (!header || !attributes) {
      return;
    }
    data.length = header.vertexCount;
    if (attributes.POSITION) {
      attributes.instancePositions = attributes.POSITION;
    }
    if (attributes.NORMAL) {
      attributes.instanceNormals = attributes.NORMAL;
    }
    if (attributes.COLOR_0) {
      const { size, value } = attributes.COLOR_0;
      attributes.instanceColors = { size, type: "unorm8", value };
    }
  }
  var PointCloudLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: point_cloud_layer_vertex_glsl_default, fs: point_cloud_layer_fragment_glsl_default, modules: [project32_default, gouraudLighting, picking_default] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceNormals: {
          size: 3,
          transition: true,
          accessor: "getNormal",
          defaultValue: DEFAULT_NORMAL
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR4
        }
      });
    }
    updateState(params) {
      const { changeFlags, props } = params;
      super.updateState(params);
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
      if (changeFlags.dataChanged) {
        normalizeData(props.data);
      }
    }
    draw({ uniforms }) {
      const { pointSize, sizeUnits } = this.props;
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        sizeUnits: UNIT[sizeUnits],
        radiusPixels: pointSize
      });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [];
      for (let i5 = 0; i5 < 3; i5++) {
        const angle3 = i5 / 3 * Math.PI * 2;
        positions.push(Math.cos(angle3) * 2, Math.sin(angle3) * 2, 0);
      }
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-list",
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  PointCloudLayer.layerName = "PointCloudLayer";
  PointCloudLayer.defaultProps = defaultProps7;

  // ../layers/src/scatterplot-layer/scatterplot-layer-vertex.glsl.ts
  var scatterplot_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader

in vec3 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;

uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;

out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;


void main(void) {
  geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  outerRadiusPixels = clamp(
    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
    radiusMinPixels, radiusMaxPixels
  );
  
  // Multiply out line width and clamp to limits
  float lineWidthPixels = clamp(
    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
    lineWidthMinPixels, lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  outerRadiusPixels += stroked * lineWidthPixels / 2.0;

  // Expand geometry to accomodate edge smoothing
  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;

  // position on the containing square in [-1, 1] space
  unitPosition = edgePadding * positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;

  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
  
  if (billboard) {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = edgePadding * positions * outerRadiusPixels;
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

  // ../layers/src/scatterplot-layer/scatterplot-layer-fragment.glsl.ts
  var scatterplot_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader

precision highp float;

uniform bool filled;
uniform float stroked;
uniform bool antialiasing;

in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;

out vec4 fragColor;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition) * outerRadiusPixels;
  float inCircle = antialiasing ? 
    smoothedge(distToCenter, outerRadiusPixels) : 
    step(distToCenter, outerRadiusPixels);

  if (inCircle == 0.0) {
    discard;
  }

  if (stroked > 0.5) {
    float isLine = antialiasing ? 
      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
      step(innerUnitRadius * outerRadiusPixels, distToCenter);

    if (filled) {
      fragColor = mix(vFillColor, vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        discard;
      }
      fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
    }
  } else if (!filled) {
    discard;
  } else {
    fragColor = vFillColor;
  }

  fragColor.a *= inCircle;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/scatterplot-layer/scatterplot-layer.ts
  var DEFAULT_COLOR5 = [0, 0, 0, 255];
  var defaultProps8 = {
    radiusUnits: "meters",
    radiusScale: { type: "number", min: 0, value: 1 },
    radiusMinPixels: { type: "number", min: 0, value: 0 },
    radiusMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    lineWidthUnits: "meters",
    lineWidthScale: { type: "number", min: 0, value: 1 },
    lineWidthMinPixels: { type: "number", min: 0, value: 0 },
    lineWidthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getRadius: { type: "accessor", value: 1 },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR5 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR5 },
    getLineWidth: { type: "accessor", value: 1 },
    strokeWidth: { deprecatedFor: "getLineWidth" },
    outline: { deprecatedFor: "stroked" },
    getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
  };
  var ScatterplotLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: scatterplot_layer_vertex_glsl_default, fs: scatterplot_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceRadius: {
          size: 1,
          transition: true,
          accessor: "getRadius",
          defaultValue: 1
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const {
        radiusUnits,
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        stroked,
        filled,
        billboard,
        antialiasing,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      } = this.props;
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        stroked: stroked ? 1 : 0,
        filled,
        billboard,
        antialiasing,
        radiusUnits: UNIT[radiusUnits],
        radiusScale,
        radiusMinPixels,
        radiusMaxPixels,
        lineWidthUnits: UNIT[lineWidthUnits],
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels
      });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: { size: 3, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  ScatterplotLayer.defaultProps = defaultProps8;
  ScatterplotLayer.layerName = "ScatterplotLayer";

  // ../../node_modules/@math.gl/polygon/dist/polygon-utils.js
  var WINDING = {
    CLOCKWISE: 1,
    COUNTER_CLOCKWISE: -1
  };
  function modifyPolygonWindingDirection(points, direction, options = {}) {
    const windingDirection = getPolygonWindingDirection(points, options);
    if (windingDirection !== direction) {
      reversePolygon(points, options);
      return true;
    }
    return false;
  }
  function getPolygonWindingDirection(points, options = {}) {
    return Math.sign(getPolygonSignedArea(points, options));
  }
  var DimIndex = {
    x: 0,
    y: 1,
    z: 2
  };
  function getPolygonSignedArea(points, options = {}) {
    const { start = 0, end = points.length, plane = "xy" } = options;
    const dim = options.size || 2;
    let area2 = 0;
    const i0 = DimIndex[plane[0]];
    const i1 = DimIndex[plane[1]];
    for (let i5 = start, j2 = end - dim; i5 < end; i5 += dim) {
      area2 += (points[i5 + i0] - points[j2 + i0]) * (points[i5 + i1] + points[j2 + i1]);
      j2 = i5;
    }
    return area2 / 2;
  }
  function reversePolygon(points, options) {
    const { start = 0, end = points.length, size = 2 } = options;
    const numPoints = (end - start) / size;
    const numSwaps = Math.floor(numPoints / 2);
    for (let i5 = 0; i5 < numSwaps; ++i5) {
      const b1 = start + i5 * size;
      const b2 = start + (numPoints - 1 - i5) * size;
      for (let j2 = 0; j2 < size; ++j2) {
        const tmp = points[b1 + j2];
        points[b1 + j2] = points[b2 + j2];
        points[b2 + j2] = tmp;
      }
    }
  }

  // ../../node_modules/@math.gl/polygon/dist/earcut.js
  function earcut(positions, holeIndices, dim = 2, areas, plane = "xy") {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;
    let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0], plane);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let invSize;
    let maxX;
    let maxY;
    let minX;
    let minY;
    let x3;
    let y3;
    if (hasHoles)
      outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas, plane);
    if (positions.length > 80 * dim) {
      minX = maxX = positions[0];
      minY = maxY = positions[1];
      for (let i5 = dim; i5 < outerLen; i5 += dim) {
        x3 = positions[i5];
        y3 = positions[i5 + 1];
        if (x3 < minX)
          minX = x3;
        if (y3 < minY)
          minY = y3;
        if (x3 > maxX)
          maxX = x3;
        if (y3 > maxY)
          maxY = y3;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise, area2, plane) {
    let i5;
    let last;
    if (area2 === void 0) {
      area2 = getPolygonSignedArea(data, { start, end, size: dim, plane });
    }
    let i0 = DimIndex[plane[0]];
    let i1 = DimIndex[plane[1]];
    if (clockwise === area2 < 0) {
      for (i5 = start; i5 < end; i5 += dim)
        last = insertNode(i5, data[i5 + i0], data[i5 + i1], last);
    } else {
      for (i5 = end - dim; i5 >= start; i5 -= dim)
        last = insertNode(i5, data[i5 + i0], data[i5 + i1], last);
    }
    if (last && equals6(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p3 = start;
    let again;
    do {
      again = false;
      if (!p3.steiner && (equals6(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
        removeNode(p3);
        p3 = end = p3.prev;
        if (p3 === p3.next)
          break;
        again = true;
      } else {
        p3 = p3.next;
      }
    } while (again || p3 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear;
    let prev;
    let next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a3 = ear.prev;
    const b2 = ear;
    const c2 = ear.next;
    if (area(a3, b2, c2) >= 0)
      return false;
    const ax = a3.x;
    const bx = b2.x;
    const cx = c2.x;
    const ay = a3.y;
    const by = b2.y;
    const cy = c2.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    let p3 = c2.next;
    while (p3 !== a3) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a3 = ear.prev;
    const b2 = ear;
    const c2 = ear.next;
    if (area(a3, b2, c2) >= 0)
      return false;
    const ax = a3.x;
    const bx = b2.x;
    const cx = c2.x;
    const ay = a3.y;
    const by = b2.y;
    const cy = c2.y;
    const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx;
    const y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy;
    const x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx;
    const y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    const minZ = zOrder(x0, y0, minX, minY, invSize);
    const maxZ = zOrder(x1, y1, minX, minY, invSize);
    let p3 = ear.prevZ;
    let n3 = ear.nextZ;
    while (p3 && p3.z >= minZ && n3 && n3.z <= maxZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.prevZ;
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    while (p3 && p3.z >= minZ) {
      if (p3.x >= x0 && p3.x <= x1 && p3.y >= y0 && p3.y <= y1 && p3 !== a3 && p3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
        return false;
      p3 = p3.prevZ;
    }
    while (n3 && n3.z <= maxZ) {
      if (n3.x >= x0 && n3.x <= x1 && n3.y >= y0 && n3.y <= y1 && n3 !== a3 && n3 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n3.x, n3.y) && area(n3.prev, n3, n3.next) >= 0)
        return false;
      n3 = n3.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p3 = start;
    do {
      const a3 = p3.prev;
      const b2 = p3.next.next;
      if (!equals6(a3, b2) && intersects(a3, p3, p3.next, b2) && locallyInside(a3, b2) && locallyInside(b2, a3)) {
        triangles.push(a3.i / dim | 0);
        triangles.push(p3.i / dim | 0);
        triangles.push(b2.i / dim | 0);
        removeNode(p3);
        removeNode(p3.next);
        p3 = start = b2;
      }
      p3 = p3.next;
    } while (p3 !== start);
    return filterPoints(p3);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a3 = start;
    do {
      let b2 = a3.next.next;
      while (b2 !== a3.prev) {
        if (a3.i !== b2.i && isValidDiagonal(a3, b2)) {
          let c2 = splitPolygon(a3, b2);
          a3 = filterPoints(a3, a3.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a3, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b2 = b2.next;
      }
      a3 = a3.next;
    } while (a3 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim, areas, plane) {
    const queue = [];
    let i5;
    let len4;
    let start;
    let end;
    let list;
    for (i5 = 0, len4 = holeIndices.length; i5 < len4; i5++) {
      start = holeIndices[i5] * dim;
      end = i5 < len4 - 1 ? holeIndices[i5 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false, areas && areas[i5 + 1], plane);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i5 = 0; i5 < queue.length; i5++) {
      outerNode = eliminateHole(queue[i5], outerNode);
    }
    return outerNode;
  }
  function compareX(a3, b2) {
    return a3.x - b2.x;
  }
  function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    const bridgeReverse = splitPolygon(bridge, hole);
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }
  function findHoleBridge(hole, outerNode) {
    let p3 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m2;
    do {
      if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
        const x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
        if (x3 <= hx && x3 > qx) {
          qx = x3;
          m2 = p3.x < p3.next.x ? p3 : p3.next;
          if (x3 === hx)
            return m2;
        }
      }
      p3 = p3.next;
    } while (p3 !== outerNode);
    if (!m2)
      return null;
    const stop = m2;
    const mx = m2.x;
    const my = m2.y;
    let tanMin = Infinity;
    let tan2;
    p3 = m2;
    do {
      if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
        tan2 = Math.abs(hy - p3.y) / (hx - p3.x);
        if (locallyInside(p3, hole) && (tan2 < tanMin || tan2 === tanMin && (p3.x > m2.x || p3.x === m2.x && sectorContainsSector(m2, p3)))) {
          m2 = p3;
          tanMin = tan2;
        }
      }
      p3 = p3.next;
    } while (p3 !== stop);
    return m2;
  }
  function sectorContainsSector(m2, p3) {
    return area(m2.prev, m2, p3.prev) < 0 && area(p3.next, m2, m2.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p3 = start;
    do {
      if (p3.z === 0)
        p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
      p3.prevZ = p3.prev;
      p3.nextZ = p3.next;
      p3 = p3.next;
    } while (p3 !== start);
    p3.prevZ.nextZ = null;
    p3.prevZ = null;
    sortLinked(p3);
  }
  function sortLinked(list) {
    let e3;
    let i5;
    let inSize = 1;
    let numMerges;
    let p3;
    let pSize;
    let q2;
    let qSize;
    let tail;
    do {
      p3 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p3) {
        numMerges++;
        q2 = p3;
        pSize = 0;
        for (i5 = 0; i5 < inSize; i5++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
            e3 = p3;
            p3 = p3.nextZ;
            pSize--;
          } else {
            e3 = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e3;
          else
            list = e3;
          e3.prevZ = tail;
          tail = e3;
        }
        p3 = q2;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x3, y3, minX, minY, invSize) {
    x3 = (x3 - minX) * invSize | 0;
    y3 = (y3 - minY) * invSize | 0;
    x3 = (x3 | x3 << 8) & 16711935;
    x3 = (x3 | x3 << 4) & 252645135;
    x3 = (x3 | x3 << 2) & 858993459;
    x3 = (x3 | x3 << 1) & 1431655765;
    y3 = (y3 | y3 << 8) & 16711935;
    y3 = (y3 | y3 << 4) & 252645135;
    y3 = (y3 | y3 << 2) & 858993459;
    y3 = (y3 | y3 << 1) & 1431655765;
    return x3 | y3 << 1;
  }
  function getLeftmost(start) {
    let p3 = start;
    let leftmost = start;
    do {
      if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
        leftmost = p3;
      p3 = p3.next;
    } while (p3 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function isValidDiagonal(a3, b2) {
    return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon(a3, b2) && (locallyInside(a3, b2) && locallyInside(b2, a3) && middleInside(a3, b2) && (area(a3.prev, a3, b2.prev) || area(a3, b2.prev, b2)) || equals6(a3, b2) && area(a3.prev, a3, a3.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p3, q2, r3) {
    return (q2.y - p3.y) * (r3.x - q2.x) - (q2.x - p3.x) * (r3.y - q2.y);
  }
  function equals6(p1, p22) {
    return p1.x === p22.x && p1.y === p22.y;
  }
  function intersects(p1, q1, p22, q2) {
    const o1 = sign(area(p1, q1, p22));
    const o22 = sign(area(p1, q1, q2));
    const o3 = sign(area(p22, q2, p1));
    const o4 = sign(area(p22, q2, q1));
    if (o1 !== o22 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p22, q1))
      return true;
    if (o22 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p22, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p22, q1, q2))
      return true;
    return false;
  }
  function onSegment(p3, q2, r3) {
    return q2.x <= Math.max(p3.x, r3.x) && q2.x >= Math.min(p3.x, r3.x) && q2.y <= Math.max(p3.y, r3.y) && q2.y >= Math.min(p3.y, r3.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a3, b2) {
    let p3 = a3;
    do {
      if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b2.i && p3.next.i !== b2.i && intersects(p3, p3.next, a3, b2))
        return true;
      p3 = p3.next;
    } while (p3 !== a3);
    return false;
  }
  function locallyInside(a3, b2) {
    return area(a3.prev, a3, a3.next) < 0 ? area(a3, b2, a3.next) >= 0 && area(a3, a3.prev, b2) >= 0 : area(a3, b2, a3.prev) < 0 || area(a3, a3.next, b2) < 0;
  }
  function middleInside(a3, b2) {
    let p3 = a3;
    let inside = false;
    const px = (a3.x + b2.x) / 2;
    const py = (a3.y + b2.y) / 2;
    do {
      if (p3.y > py !== p3.next.y > py && p3.next.y !== p3.y && px < (p3.next.x - p3.x) * (py - p3.y) / (p3.next.y - p3.y) + p3.x)
        inside = !inside;
      p3 = p3.next;
    } while (p3 !== a3);
    return inside;
  }
  function splitPolygon(a3, b2) {
    const a22 = new Vertex(a3.i, a3.x, a3.y);
    const b22 = new Vertex(b2.i, b2.x, b2.y);
    const an = a3.next;
    const bp = b2.prev;
    a3.next = b2;
    b2.prev = a3;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i5, x3, y3, last) {
    const p3 = new Vertex(i5, x3, y3);
    if (!last) {
      p3.prev = p3;
      p3.next = p3;
    } else {
      p3.next = last.next;
      p3.prev = last;
      last.next.prev = p3;
      last.next = p3;
    }
    return p3;
  }
  function removeNode(p3) {
    p3.next.prev = p3.prev;
    p3.prev.next = p3.next;
    if (p3.prevZ)
      p3.prevZ.nextZ = p3.nextZ;
    if (p3.nextZ)
      p3.nextZ.prevZ = p3.prevZ;
  }
  var Vertex = class {
    constructor(i5, x3, y3) {
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
      this.i = i5;
      this.x = x3;
      this.y = y3;
    }
  };

  // ../../node_modules/@math.gl/polygon/dist/utils.js
  function push(target, source) {
    const size = source.length;
    const startIndex = target.length;
    if (startIndex > 0) {
      let isDuplicate = true;
      for (let i5 = 0; i5 < size; i5++) {
        if (target[startIndex - size + i5] !== source[i5]) {
          isDuplicate = false;
          break;
        }
      }
      if (isDuplicate) {
        return false;
      }
    }
    for (let i5 = 0; i5 < size; i5++) {
      target[startIndex + i5] = source[i5];
    }
    return true;
  }
  function copy5(target, source) {
    const size = source.length;
    for (let i5 = 0; i5 < size; i5++) {
      target[i5] = source[i5];
    }
  }
  function getPointAtIndex(positions, index2, size, offset, out = []) {
    const startI = offset + index2 * size;
    for (let i5 = 0; i5 < size; i5++) {
      out[i5] = positions[startI + i5];
    }
    return out;
  }

  // ../../node_modules/@math.gl/polygon/dist/lineclip.js
  function intersect(a3, b2, edge, bbox, out = []) {
    let t3;
    let snap;
    if (edge & 8) {
      t3 = (bbox[3] - a3[1]) / (b2[1] - a3[1]);
      snap = 3;
    } else if (edge & 4) {
      t3 = (bbox[1] - a3[1]) / (b2[1] - a3[1]);
      snap = 1;
    } else if (edge & 2) {
      t3 = (bbox[2] - a3[0]) / (b2[0] - a3[0]);
      snap = 2;
    } else if (edge & 1) {
      t3 = (bbox[0] - a3[0]) / (b2[0] - a3[0]);
      snap = 0;
    } else {
      return null;
    }
    for (let i5 = 0; i5 < a3.length; i5++) {
      out[i5] = (snap & 1) === i5 ? bbox[snap] : t3 * (b2[i5] - a3[i5]) + a3[i5];
    }
    return out;
  }
  function bitCode(p3, bbox) {
    let code = 0;
    if (p3[0] < bbox[0])
      code |= 1;
    else if (p3[0] > bbox[2])
      code |= 2;
    if (p3[1] < bbox[1])
      code |= 4;
    else if (p3[1] > bbox[3])
      code |= 8;
    return code;
  }

  // ../../node_modules/@math.gl/polygon/dist/cut-by-grid.js
  function cutPolylineByGrid(positions, options) {
    const { size = 2, broken = false, gridResolution = 10, gridOffset = [0, 0], startIndex = 0, endIndex = positions.length } = options || {};
    const numPoints = (endIndex - startIndex) / size;
    let part = [];
    const result = [part];
    const a3 = getPointAtIndex(positions, 0, size, startIndex);
    let b2;
    let codeB;
    const cell = getGridCell(a3, gridResolution, gridOffset, []);
    const scratchPoint2 = [];
    push(part, a3);
    for (let i5 = 1; i5 < numPoints; i5++) {
      b2 = getPointAtIndex(positions, i5, size, startIndex, b2);
      codeB = bitCode(b2, cell);
      while (codeB) {
        intersect(a3, b2, codeB, cell, scratchPoint2);
        const codeAlt = bitCode(scratchPoint2, cell);
        if (codeAlt) {
          intersect(a3, scratchPoint2, codeAlt, cell, scratchPoint2);
          codeB = codeAlt;
        }
        push(part, scratchPoint2);
        copy5(a3, scratchPoint2);
        moveToNeighborCell(cell, gridResolution, codeB);
        if (broken && part.length > size) {
          part = [];
          result.push(part);
          push(part, a3);
        }
        codeB = bitCode(b2, cell);
      }
      push(part, b2);
      copy5(a3, b2);
    }
    return broken ? result : result[0];
  }
  var TYPE_INSIDE = 0;
  var TYPE_BORDER = 1;
  function cutPolygonByGrid(positions, holeIndices = null, options) {
    if (!positions.length) {
      return [];
    }
    const { size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false } = options || {};
    const result = [];
    const queue = [
      {
        pos: positions,
        types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
        holes: holeIndices || []
      }
    ];
    const bbox = [[], []];
    let cell = [];
    while (queue.length) {
      const { pos, types, holes } = queue.shift();
      getBoundingBox(pos, size, holes[0] || pos.length, bbox);
      cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
      const code = bitCode(bbox[1], cell);
      if (code) {
        let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
        const polygonLow = { pos: parts[0].pos, types: parts[0].types, holes: [] };
        const polygonHigh = { pos: parts[1].pos, types: parts[1].types, holes: [] };
        queue.push(polygonLow, polygonHigh);
        for (let i5 = 0; i5 < holes.length; i5++) {
          parts = bisectPolygon(pos, types, size, holes[i5], holes[i5 + 1] || pos.length, cell, code);
          if (parts[0]) {
            polygonLow.holes.push(polygonLow.pos.length);
            polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
            if (edgeTypes) {
              polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
            }
          }
          if (parts[1]) {
            polygonHigh.holes.push(polygonHigh.pos.length);
            polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
            if (edgeTypes) {
              polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
            }
          }
        }
      } else {
        const polygon = { positions: pos };
        if (edgeTypes) {
          polygon.edgeTypes = types;
        }
        if (holes.length) {
          polygon.holeIndices = holes;
        }
        result.push(polygon);
      }
    }
    return result;
  }
  function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
    const numPoints = (endIndex - startIndex) / size;
    const resultLow = [];
    const resultHigh = [];
    const typesLow = [];
    const typesHigh = [];
    const scratchPoint2 = [];
    let p3;
    let side;
    let type;
    const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
    let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
    let prevType = edgeTypes && edgeTypes[numPoints - 1];
    let lowPointCount = 0;
    let highPointCount = 0;
    for (let i5 = 0; i5 < numPoints; i5++) {
      p3 = getPointAtIndex(positions, i5, size, startIndex, p3);
      side = Math.sign(edge & 8 ? p3[1] - bbox[3] : p3[0] - bbox[2]);
      type = edgeTypes && edgeTypes[startIndex / size + i5];
      if (side && prevSide && prevSide !== side) {
        intersect(prev, p3, edge, bbox, scratchPoint2);
        push(resultLow, scratchPoint2) && typesLow.push(prevType);
        push(resultHigh, scratchPoint2) && typesHigh.push(prevType);
      }
      if (side <= 0) {
        push(resultLow, p3) && typesLow.push(type);
        lowPointCount -= side;
      } else if (typesLow.length) {
        typesLow[typesLow.length - 1] = TYPE_INSIDE;
      }
      if (side >= 0) {
        push(resultHigh, p3) && typesHigh.push(type);
        highPointCount += side;
      } else if (typesHigh.length) {
        typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
      }
      copy5(prev, p3);
      prevSide = side;
      prevType = type;
    }
    return [
      lowPointCount ? { pos: resultLow, types: edgeTypes && typesLow } : null,
      highPointCount ? { pos: resultHigh, types: edgeTypes && typesHigh } : null
    ];
  }
  function getGridCell(p3, gridResolution, gridOffset, out) {
    const left = Math.floor((p3[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom = Math.floor((p3[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left;
    out[1] = bottom;
    out[2] = left + gridResolution;
    out[3] = bottom + gridResolution;
    return out;
  }
  function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
      cell[1] += gridResolution;
      cell[3] += gridResolution;
    } else if (edge & 4) {
      cell[1] -= gridResolution;
      cell[3] -= gridResolution;
    } else if (edge & 2) {
      cell[0] += gridResolution;
      cell[2] += gridResolution;
    } else if (edge & 1) {
      cell[0] -= gridResolution;
      cell[2] -= gridResolution;
    }
  }
  function getBoundingBox(positions, size, endIndex, out) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i5 = 0; i5 < endIndex; i5 += size) {
      const x3 = positions[i5];
      const y3 = positions[i5 + 1];
      minX = x3 < minX ? x3 : minX;
      maxX = x3 > maxX ? x3 : maxX;
      minY = y3 < minY ? y3 : minY;
      maxY = y3 > maxY ? y3 : maxY;
    }
    out[0][0] = minX;
    out[0][1] = minY;
    out[1][0] = maxX;
    out[1][1] = maxY;
    return out;
  }
  function concatInPlace(arr1, arr2) {
    for (let i5 = 0; i5 < arr2.length; i5++) {
      arr1.push(arr2[i5]);
    }
    return arr1;
  }

  // ../../node_modules/@math.gl/polygon/dist/cut-by-mercator-bounds.js
  var DEFAULT_MAX_LATITUDE = 85.051129;
  function cutPolylineByMercatorBounds(positions, options) {
    const { size = 2, startIndex = 0, endIndex = positions.length, normalize: normalize6 = true } = options || {};
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
    const parts = cutPolylineByGrid(newPositions, {
      size,
      broken: true,
      gridResolution: 360,
      gridOffset: [-180, -180]
    });
    if (normalize6) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part, size);
      }
    }
    return parts;
  }
  function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
    const { size = 2, normalize: normalize6 = true, edgeTypes = false } = options || {};
    holeIndices = holeIndices || [];
    const newPositions = [];
    const newHoleIndices = [];
    let srcStartIndex = 0;
    let targetIndex = 0;
    for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
      const srcEndIndex = holeIndices[ringIndex] || positions.length;
      const targetStartIndex = targetIndex;
      const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
      for (let i5 = splitIndex; i5 < srcEndIndex; i5++) {
        newPositions[targetIndex++] = positions[i5];
      }
      for (let i5 = srcStartIndex; i5 < splitIndex; i5++) {
        newPositions[targetIndex++] = positions[i5];
      }
      wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
      insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);
      srcStartIndex = srcEndIndex;
      newHoleIndices[ringIndex] = targetIndex;
    }
    newHoleIndices.pop();
    const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
      size,
      gridResolution: 360,
      gridOffset: [-180, -180],
      edgeTypes
    });
    if (normalize6) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part.positions, size);
      }
    }
    return parts;
  }
  function findSplitIndex(positions, size, startIndex, endIndex) {
    let maxLat = -1;
    let pointIndex = -1;
    for (let i5 = startIndex + 1; i5 < endIndex; i5 += size) {
      const lat = Math.abs(positions[i5]);
      if (lat > maxLat) {
        maxLat = lat;
        pointIndex = i5 - 1;
      }
    }
    return pointIndex;
  }
  function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
    const firstLng = positions[startIndex];
    const lastLng = positions[endIndex - size];
    if (Math.abs(firstLng - lastLng) > 180) {
      const p3 = getPointAtIndex(positions, 0, size, startIndex);
      p3[0] += Math.round((lastLng - firstLng) / 360) * 360;
      push(positions, p3);
      p3[1] = Math.sign(p3[1]) * maxLatitude;
      push(positions, p3);
      p3[0] = firstLng;
      push(positions, p3);
    }
  }
  function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng;
    for (let i5 = startIndex; i5 < endIndex; i5 += size) {
      lng = positions[i5];
      const delta = lng - prevLng;
      if (delta > 180 || delta < -180) {
        lng -= Math.round(delta / 360) * 360;
      }
      positions[i5] = prevLng = lng;
    }
  }
  function shiftLongitudesIntoRange(positions, size) {
    let refLng;
    const pointCount = positions.length / size;
    for (let i5 = 0; i5 < pointCount; i5++) {
      refLng = positions[i5 * size];
      if ((refLng + 180) % 360 !== 0) {
        break;
      }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
      return;
    }
    for (let i5 = 0; i5 < pointCount; i5++) {
      positions[i5 * size] += delta;
    }
  }

  // ../layers/src/column-layer/column-geometry.ts
  var ColumnGeometry = class extends Geometry {
    constructor(props) {
      const { indices, attributes } = tesselateColumn(props);
      super({
        ...props,
        indices,
        attributes
      });
    }
  };
  function tesselateColumn(props) {
    const { radius, height = 1, nradial = 10 } = props;
    let { vertices } = props;
    if (vertices) {
      log_default.assert(vertices.length >= nradial);
      vertices = vertices.flatMap((v2) => [v2[0], v2[1]]);
      modifyPolygonWindingDirection(vertices, WINDING.COUNTER_CLOCKWISE);
    }
    const isExtruded = height > 0;
    const vertsAroundEdge = nradial + 1;
    const numVertices = isExtruded ? vertsAroundEdge * 3 + 1 : nradial;
    const stepAngle = Math.PI * 2 / nradial;
    const indices = new Uint16Array(isExtruded ? nradial * 3 * 2 : 0);
    const positions = new Float32Array(numVertices * 3);
    const normals = new Float32Array(numVertices * 3);
    let i5 = 0;
    if (isExtruded) {
      for (let j2 = 0; j2 < vertsAroundEdge; j2++) {
        const a3 = j2 * stepAngle;
        const vertexIndex = j2 % nradial;
        const sin2 = Math.sin(a3);
        const cos2 = Math.cos(a3);
        for (let k2 = 0; k2 < 2; k2++) {
          positions[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
          positions[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
          positions[i5 + 2] = (1 / 2 - k2) * height;
          normals[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos2;
          normals[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2;
          i5 += 3;
        }
      }
      positions[i5 + 0] = positions[i5 - 3];
      positions[i5 + 1] = positions[i5 - 2];
      positions[i5 + 2] = positions[i5 - 1];
      i5 += 3;
    }
    for (let j2 = isExtruded ? 0 : 1; j2 < vertsAroundEdge; j2++) {
      const v2 = Math.floor(j2 / 2) * Math.sign(0.5 - j2 % 2);
      const a3 = v2 * stepAngle;
      const vertexIndex = (v2 + nradial) % nradial;
      const sin2 = Math.sin(a3);
      const cos2 = Math.cos(a3);
      positions[i5 + 0] = vertices ? vertices[vertexIndex * 2] : cos2 * radius;
      positions[i5 + 1] = vertices ? vertices[vertexIndex * 2 + 1] : sin2 * radius;
      positions[i5 + 2] = height / 2;
      normals[i5 + 2] = 1;
      i5 += 3;
    }
    if (isExtruded) {
      let index2 = 0;
      for (let j2 = 0; j2 < nradial; j2++) {
        indices[index2++] = j2 * 2 + 0;
        indices[index2++] = j2 * 2 + 2;
        indices[index2++] = j2 * 2 + 0;
        indices[index2++] = j2 * 2 + 1;
        indices[index2++] = j2 * 2 + 1;
        indices[index2++] = j2 * 2 + 3;
      }
    }
    return {
      indices,
      attributes: {
        POSITION: { size: 3, value: positions },
        NORMAL: { size: 3, value: normals }
      }
    };
  }

  // ../layers/src/column-layer/column-layer-vertex.glsl.ts
  var column_layer_vertex_glsl_default = `#version 300 es

#define SHADER_NAME column-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;

in vec3 instancePickingColors;

// Custom uniforms
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int radiusUnits;
uniform int widthUnits;

// Result
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif

void main(void) {
  geometry.worldPosition = instancePositions;

  vec4 color = isStroke ? instanceLineColors : instanceFillColors;
  // rotate primitive position and normal
  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));

  // calculate elevation, if 3d not enabled set to 0
  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
  float elevation = 0.0;
  // calculate stroke offset
  float strokeOffsetRatio = 1.0;

  if (extruded) {
    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
  } else if (stroked) {
    float widthPixels = clamp(
      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
      widthMinPixels, widthMaxPixels) / 2.0;
    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
    if (isStroke) {
      strokeOffsetRatio -= sign(positions.z) * halfOffset;
    } else {
      strokeOffsetRatio -= halfOffset;
    }
  }

  // if alpha == 0.0 or z < 0.0, do not render element
  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
  float dotRadius = radius * coverage * shouldRender;

  geometry.pickingColor = instancePickingColors;

  // project center of column
  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
  vec3 centroidPosition64Low = instancePositions64Low;
  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;
  if (radiusUnits == UNIT_METERS) {
    offset = project_size(offset);
  }
  vec3 pos = vec3(offset, 0.);
  DECKGL_FILTER_SIZE(pos, geometry);

  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  // Light calculations
  if (extruded && !isStroke) {
#ifdef FLAT_SHADING
    position_commonspace = geometry.position;
    vColor = vec4(color.rgb, color.a * opacity);
#else
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, color.a * opacity);
#endif
  } else {
    vColor = vec4(color.rgb, color.a * opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer-fragment.glsl.ts
  var column_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader

precision highp float;

uniform vec3 project_uCameraPosition;
uniform bool extruded;
uniform bool isStroke;

out vec4 fragColor;

in vec4 vColor;
#ifdef FLAT_SHADING
in vec4 position_commonspace;
#endif

void main(void) {
  fragColor = vColor;
#ifdef FLAT_SHADING
  if (extruded && !isStroke && !bool(picking.isActive)) {
    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
  }
#endif
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/column-layer/column-layer.ts
  var DEFAULT_COLOR6 = [0, 0, 0, 255];
  var defaultProps9 = {
    diskResolution: { type: "number", min: 4, value: 20 },
    vertices: null,
    radius: { type: "number", min: 0, value: 1e3 },
    angle: { type: "number", value: 0 },
    offset: { type: "array", value: [0, 0] },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    elevationScale: { type: "number", min: 0, value: 1 },
    radiusUnits: "meters",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    extruded: true,
    wireframe: false,
    filled: true,
    stroked: false,
    flatShading: false,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR6 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR6 },
    getLineWidth: { type: "accessor", value: 1 },
    getElevation: { type: "accessor", value: 1e3 },
    material: true,
    getColor: { deprecatedFor: ["getFillColor", "getLineColor"] }
  };
  var ColumnLayer = class extends Layer {
    getShaders() {
      const defines2 = {};
      const { flatShading } = this.props;
      if (flatShading) {
        defines2.FLAT_SHADING = 1;
      }
      return super.getShaders({
        vs: column_layer_vertex_glsl_default,
        fs: column_layer_fragment_glsl_default,
        defines: defines2,
        modules: [project32_default, flatShading ? phongLighting : gouraudLighting, picking_default]
      });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: "getElevation"
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR6
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getLineWidth",
          transition: true
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;
      if (regenerateModels) {
        this.state.models?.forEach((model) => model.destroy());
        this.setState(this._getModels());
        this.getAttributeManager().invalidateAll();
      }
      const instanceCount = this.getNumInstances();
      this.state.fillModel.setInstanceCount(instanceCount);
      this.state.wireframeModel.setInstanceCount(instanceCount);
      if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices || (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {
        this._updateGeometry(props);
      }
    }
    getGeometry(diskResolution, vertices, hasThinkness) {
      const geometry = new ColumnGeometry({
        radius: 1,
        height: hasThinkness ? 2 : 0,
        vertices,
        nradial: diskResolution
      });
      let meanVertexDistance = 0;
      if (vertices) {
        for (let i5 = 0; i5 < diskResolution; i5++) {
          const p3 = vertices[i5];
          const d2 = Math.sqrt(p3[0] * p3[0] + p3[1] * p3[1]);
          meanVertexDistance += d2 / diskResolution;
        }
      } else {
        meanVertexDistance = 1;
      }
      this.setState({
        edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
      });
      return geometry;
    }
    _getModels() {
      const shaders = this.getShaders();
      const bufferLayout = this.getAttributeManager().getBufferLayouts();
      const fillModel = new Model(this.context.device, {
        ...shaders,
        id: `${this.props.id}-fill`,
        bufferLayout,
        isInstanced: true
      });
      const wireframeModel = new Model(this.context.device, {
        ...shaders,
        id: `${this.props.id}-wireframe`,
        bufferLayout,
        isInstanced: true
      });
      return {
        fillModel,
        wireframeModel,
        models: [wireframeModel, fillModel]
      };
    }
    _updateGeometry({ diskResolution, vertices, extruded, stroked }) {
      const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);
      this.setState({
        fillVertexCount: geometry.attributes.POSITION.value.length / 3
      });
      const fillModel = this.state.fillModel;
      const wireframeModel = this.state.wireframeModel;
      fillModel.setGeometry(geometry);
      fillModel.setTopology("triangle-strip");
      fillModel.setIndexBuffer(null);
      wireframeModel.setGeometry(geometry);
      wireframeModel.setTopology("line-list");
    }
    draw({ uniforms }) {
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        radiusUnits,
        elevationScale,
        extruded,
        filled,
        stroked,
        wireframe,
        offset,
        coverage,
        radius,
        angle: angle3
      } = this.props;
      const fillModel = this.state.fillModel;
      const wireframeModel = this.state.wireframeModel;
      const { fillVertexCount, edgeDistance } = this.state;
      const renderUniforms = {
        ...uniforms,
        radius,
        angle: angle3 / 180 * Math.PI,
        offset,
        extruded,
        stroked,
        coverage,
        elevationScale,
        edgeDistance,
        radiusUnits: UNIT[radiusUnits],
        widthUnits: UNIT[lineWidthUnits],
        widthScale: lineWidthScale,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      };
      if (extruded && wireframe) {
        wireframeModel.setUniforms(renderUniforms);
        wireframeModel.setUniforms({ isStroke: true });
        wireframeModel.draw(this.context.renderPass);
      }
      fillModel.setUniforms(renderUniforms);
      if (filled) {
        fillModel.setVertexCount(fillVertexCount);
        fillModel.setUniforms({ isStroke: false });
        fillModel.draw(this.context.renderPass);
      }
      if (!extruded && stroked) {
        fillModel.setVertexCount(fillVertexCount * 2 / 3);
        fillModel.setUniforms({ isStroke: true });
        fillModel.draw(this.context.renderPass);
      }
    }
  };
  ColumnLayer.layerName = "ColumnLayer";
  ColumnLayer.defaultProps = defaultProps9;

  // ../layers/src/column-layer/grid-cell-layer.ts
  var defaultProps10 = {
    cellSize: { type: "number", min: 0, value: 1e3 },
    offset: { type: "array", value: [1, 1] }
  };
  var GridCellLayer = class extends ColumnLayer {
    _updateGeometry() {
      const geometry = new CubeGeometry();
      this.state.fillModel.setGeometry(geometry);
    }
    draw({ uniforms }) {
      const { elevationScale, extruded, offset, coverage, cellSize, angle: angle3, radiusUnits } = this.props;
      const fillModel = this.state.fillModel;
      fillModel.setUniforms(uniforms);
      fillModel.setUniforms({
        radius: cellSize / 2,
        radiusUnits: UNIT[radiusUnits],
        angle: angle3,
        offset,
        extruded,
        coverage,
        elevationScale,
        edgeDistance: 1,
        isStroke: false
      });
      fillModel.draw(this.context.renderPass);
    }
  };
  GridCellLayer.layerName = "GridCellLayer";
  GridCellLayer.defaultProps = defaultProps10;

  // ../layers/src/path-layer/path.ts
  function normalizePath(path, size, gridResolution, wrapLongitude) {
    let flatPath;
    if (Array.isArray(path[0])) {
      const length6 = path.length * size;
      flatPath = new Array(length6);
      for (let i5 = 0; i5 < path.length; i5++) {
        for (let j2 = 0; j2 < size; j2++) {
          flatPath[i5 * size + j2] = path[i5][j2] || 0;
        }
      }
    } else {
      flatPath = path;
    }
    if (gridResolution) {
      return cutPolylineByGrid(flatPath, { size, gridResolution });
    }
    if (wrapLongitude) {
      return cutPolylineByMercatorBounds(flatPath, { size });
    }
    return flatPath;
  }

  // ../layers/src/path-layer/path-tesselator.ts
  var START_CAP = 1;
  var END_CAP = 2;
  var INVALID = 4;
  var PathTesselator = class extends Tesselator {
    constructor(opts) {
      super({
        ...opts,
        attributes: {
          positions: {
            size: 3,
            padding: 18,
            initialize: true,
            type: opts.fp64 ? Float64Array : Float32Array
          },
          segmentTypes: { size: 1, type: Uint8ClampedArray }
        }
      });
    }
    get(attributeName) {
      return this.attributes[attributeName];
    }
    getGeometryFromBuffer(buffer) {
      if (this.normalize) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    normalizeGeometry(path) {
      if (this.normalize) {
        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
      }
      return path;
    }
    getGeometrySize(path) {
      if (isCut(path)) {
        let size = 0;
        for (const subPath of path) {
          size += this.getGeometrySize(subPath);
        }
        return size;
      }
      const numPoints = this.getPathLength(path);
      if (numPoints < 2) {
        return 0;
      }
      if (this.isClosed(path)) {
        return numPoints < 3 ? 0 : numPoints + 2;
      }
      return numPoints;
    }
    updateGeometryAttributes(path, context) {
      if (context.geometrySize === 0) {
        return;
      }
      if (path && isCut(path)) {
        for (const subPath of path) {
          const geometrySize = this.getGeometrySize(subPath);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPath, context);
          context.vertexStart += geometrySize;
        }
      } else {
        this._updateSegmentTypes(path, context);
        this._updatePositions(path, context);
      }
    }
    _updateSegmentTypes(path, context) {
      const segmentTypes = this.attributes.segmentTypes;
      const isPathClosed = path ? this.isClosed(path) : false;
      const { vertexStart, geometrySize } = context;
      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
      if (isPathClosed) {
        segmentTypes[vertexStart] = INVALID;
        segmentTypes[vertexStart + geometrySize - 2] = INVALID;
      } else {
        segmentTypes[vertexStart] += START_CAP;
        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
      }
      segmentTypes[vertexStart + geometrySize - 1] = INVALID;
    }
    _updatePositions(path, context) {
      const { positions } = this.attributes;
      if (!positions || !path) {
        return;
      }
      const { vertexStart, geometrySize } = context;
      const p3 = new Array(3);
      for (let i5 = vertexStart, ptIndex = 0; ptIndex < geometrySize; i5++, ptIndex++) {
        this.getPointOnPath(path, ptIndex, p3);
        positions[i5 * 3] = p3[0];
        positions[i5 * 3 + 1] = p3[1];
        positions[i5 * 3 + 2] = p3[2];
      }
    }
    getPathLength(path) {
      return path.length / this.positionSize;
    }
    getPointOnPath(path, index2, target = []) {
      const { positionSize } = this;
      if (index2 * positionSize >= path.length) {
        index2 += 1 - path.length / positionSize;
      }
      const i5 = index2 * positionSize;
      target[0] = path[i5];
      target[1] = path[i5 + 1];
      target[2] = positionSize === 3 && path[i5 + 2] || 0;
      return target;
    }
    isClosed(path) {
      if (!this.normalize) {
        return Boolean(this.opts.loop);
      }
      const { positionSize } = this;
      const lastPointIndex = path.length - positionSize;
      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
    }
  };
  function isCut(path) {
    return Array.isArray(path[0]);
  }

  // ../layers/src/path-layer/path-layer-vertex.glsl.ts
  var path_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-vertex-shader

in vec2 positions;

in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;

uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;

uniform float opacity;

out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;

const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}

// calculate line join positions
vec3 getLineJoinOffset(
  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
  vec2 width
) {
  bool isEnd = positions.x > 0.0;
  // side of the segment - -1: left, 0: center, 1: right
  float sideOfPath = positions.y;
  float isJoint = float(sideOfPath == 0.0);

  vec3 deltaA3 = (currPoint - prevPoint);
  vec3 deltaB3 = (nextPoint - currPoint);

  mat3 rotationMatrix;
  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
  if (needsRotation) {
    deltaA3 = deltaA3 * rotationMatrix;
    deltaB3 = deltaB3 * rotationMatrix;
  }
  vec2 deltaA = deltaA3.xy / width;
  vec2 deltaB = deltaB3.xy / width;

  float lenA = length(deltaA);
  float lenB = length(deltaB);

  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);

  // tangent of the corner
  vec2 tangent = dirA + dirB;
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  // direction of the corner
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  // direction of the segment
  vec2 dir = isEnd ? dirA : dirB;
  // direction of the extrusion
  vec2 perp = isEnd ? perpA : perpB;
  // length of the segment
  float L = isEnd ? lenA : lenB;

  // A = angle of the corner
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));

  // -1: right, 1: left
  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);

  // relative position to the corner:
  // -1: inside (smaller side of the angle)
  // 0: center
  // 1: outside (bigger side of the angle)
  float cornerPosition = sideOfPath * turnDirection;

  float miterSize = 1.0 / max(sinHalfA, EPSILON);
  // trim if inside corner extends further than the line segment
  miterSize = mix(
    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
    miterSize,
    step(0.0, cornerPosition)
  );

  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
    * (sideOfPath + isJoint * turnDirection);

  // special treatment for start cap and end cap
  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
  bool isCap = isStartCap || isEndCap;

  // extend out a triangle to envelope the round cap
  if (isCap) {
    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
    vJointType = capType;
  } else {
    vJointType = jointType;
  }

  // Generate variables for fragment shader
  vPathLength = L;
  vCornerOffset = offsetVec;
  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
  vMiterLength = isCap ? isJoint : vMiterLength;

  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
  vPathPosition = vec2(
    dot(offsetFromStartOfPath, perp),
    dot(offsetFromStartOfPath, dir)
  );
  geometry.uv = vPathPosition;

  float isValid = step(instanceTypes, 3.5);
  vec3 offset = vec3(offsetVec * width * isValid, 0.0);

  if (needsRotation) {
    offset = rotationMatrix * offset;
  }
  return offset;
}

// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts
void clipLine(inout vec4 position, vec4 refPosition) {
  if (position.w < EPSILON) {
    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
    position = refPosition + (position - refPosition) * r;
  }
}

void main() {
  geometry.pickingColor = instancePickingColors;

  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);

  float isEnd = positions.x;

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);

  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);

  geometry.worldPosition = currPosition;
  vec2 widthPixels = vec2(clamp(
    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
    widthMinPixels, widthMaxPixels) / 2.0);
  vec3 width;

  if (billboard) {
    // Extrude in clipspace
    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);

    clipLine(prevPositionScreen, currPositionScreen);
    clipLine(nextPositionScreen, currPositionScreen);
    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));

    width = vec3(widthPixels, 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(
      prevPositionScreen.xyz / prevPositionScreen.w,
      currPositionScreen.xyz / currPositionScreen.w,
      nextPositionScreen.xyz / nextPositionScreen.w,
      project_pixel_size_to_clipspace(width.xy)
    );

    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
  } else {
    // Extrude in commonspace
    prevPosition = project_position(prevPosition, prevPosition64Low);
    currPosition = project_position(currPosition, currPosition64Low);
    nextPosition = project_position(nextPosition, nextPosition64Low);

    width = vec3(project_pixel_size(widthPixels), 0.0);
    DECKGL_FILTER_SIZE(width, geometry);

    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
    geometry.position = vec4(currPosition + offset, 1.0);
    gl_Position = project_common_position_to_clipspace(geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer-fragment.glsl.ts
  var path_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME path-layer-fragment-shader

precision highp float;

uniform float miterLimit;

in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
/*
 * vPathPosition represents the relative coordinates of the current fragment on the path segment.
 * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.
 * vPathPosition.y - position along the length of the path, between [0, L / width].
 */
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;

out vec4 fragColor;

void main(void) {
  geometry.uv = vPathPosition;

  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
    // if joint is rounded, test distance from the corner
    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
      discard;
    }
    // trim miter
    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
      discard;
    }
  }
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/path-layer/path-layer.ts
  var DEFAULT_COLOR7 = [0, 0, 0, 255];
  var defaultProps11 = {
    widthUnits: "meters",
    widthScale: { type: "number", min: 0, value: 1 },
    widthMinPixels: { type: "number", min: 0, value: 0 },
    widthMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    jointRounded: false,
    capRounded: false,
    miterLimit: { type: "number", min: 0, value: 4 },
    billboard: false,
    _pathType: null,
    getPath: { type: "accessor", value: (object) => object.path },
    getColor: { type: "accessor", value: DEFAULT_COLOR7 },
    getWidth: { type: "accessor", value: 1 },
    rounded: { deprecatedFor: ["jointRounded", "capRounded"] }
  };
  var ATTRIBUTE_TRANSITION = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var PathLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: path_layer_vertex_glsl_default, fs: path_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    get wrapLongitude() {
      return false;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["vertexPositions"]);
    }
    initializeState() {
      const noAlloc = true;
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        vertexPositions: {
          size: 3,
          vertexOffset: 1,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION,
          accessor: "getPath",
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            instanceLeftPositions: {
              vertexOffset: 0
            },
            instanceStartPositions: {
              vertexOffset: 1
            },
            instanceEndPositions: {
              vertexOffset: 2
            },
            instanceRightPositions: {
              vertexOffset: 3
            }
          }
        },
        instanceTypes: {
          size: 1,
          type: "uint8",
          update: this.calculateSegmentTypes,
          noAlloc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getWidth",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: 1
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          accessor: "getColor",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: DEFAULT_COLOR7
        },
        instancePickingColors: {
          size: 4,
          type: "uint8",
          accessor: (object, { index: index2, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index2, value)
        }
      });
      this.setState({
        pathTesselator: new PathTesselator({
          fp64: this.use64bitPositions()
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, changeFlags } = params;
      const attributeManager = this.getAttributeManager();
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
      if (geometryChanged) {
        const { pathTesselator } = this.state;
        const buffers = props.data.attributes || {};
        pathTesselator.updateGeometry({
          data: props.data,
          geometryBuffer: buffers.getPath,
          buffers,
          normalize: !props._pathType,
          loop: props._pathType === "loop",
          getGeometry: props.getPath,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          resolution: this.context.viewport.resolution,
          dataChanged: changeFlags.dataChanged
        });
        this.setState({
          numInstances: pathTesselator.instanceCount,
          startIndices: pathTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          attributeManager.invalidateAll();
        }
      }
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        attributeManager.invalidateAll();
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index: index2 } = info;
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        info.object = data.find((d2) => d2.__source.index === index2);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        for (let i5 = 0; i5 < data.length; i5++) {
          if (data[i5].__source.index === objectIndex) {
            this._disablePickingIndex(i5);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({ uniforms }) {
      const {
        jointRounded,
        capRounded,
        billboard,
        miterLimit,
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels
      } = this.props;
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        jointType: Number(jointRounded),
        capType: Number(capRounded),
        billboard,
        widthUnits: UNIT[widthUnits],
        widthScale,
        miterLimit,
        widthMinPixels,
        widthMaxPixels
      });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const SEGMENT_INDICES = [
        0,
        1,
        2,
        1,
        4,
        2,
        1,
        3,
        4,
        3,
        5,
        4
      ];
      const SEGMENT_POSITIONS = [
        0,
        0,
        0,
        -1,
        0,
        1,
        1,
        -1,
        1,
        1,
        1,
        0
      ];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-list",
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: { value: new Float32Array(SEGMENT_POSITIONS), size: 2 }
          }
        }),
        isInstanced: true
      });
    }
    calculatePositions(attribute) {
      const { pathTesselator } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("positions");
    }
    calculateSegmentTypes(attribute) {
      const { pathTesselator } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("segmentTypes");
    }
  };
  PathLayer.defaultProps = defaultProps11;
  PathLayer.layerName = "PathLayer";

  // ../layers/src/solid-polygon-layer/polygon.ts
  var import_earcut2 = __toESM(require_earcut(), 1);
  var OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;
  var HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;
  var windingOptions = {
    isClosed: true
  };
  function validate(polygon) {
    polygon = polygon && polygon.positions || polygon;
    if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
      throw new Error("invalid polygon");
    }
  }
  function getPositions(polygon) {
    return "positions" in polygon ? polygon.positions : polygon;
  }
  function getHoleIndices(polygon) {
    return "holeIndices" in polygon ? polygon.holeIndices : null;
  }
  function isNested(polygon) {
    return Array.isArray(polygon[0]);
  }
  function isSimple(polygon) {
    return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
  }
  function isNestedRingClosed(simplePolygon) {
    const p0 = simplePolygon[0];
    const p1 = simplePolygon[simplePolygon.length - 1];
    return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
  }
  function isFlatRingClosed(positions, size, startIndex, endIndex) {
    for (let i5 = 0; i5 < size; i5++) {
      if (positions[startIndex + i5] !== positions[endIndex - size + i5]) {
        return false;
      }
    }
    return true;
  }
  function copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {
    let targetIndex = targetStartIndex;
    const len4 = simplePolygon.length;
    for (let i5 = 0; i5 < len4; i5++) {
      for (let j2 = 0; j2 < size; j2++) {
        target[targetIndex++] = simplePolygon[i5][j2] || 0;
      }
    }
    if (!isNestedRingClosed(simplePolygon)) {
      for (let j2 = 0; j2 < size; j2++) {
        target[targetIndex++] = simplePolygon[0][j2] || 0;
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex, windingDirection) {
    srcEndIndex = srcEndIndex || positions.length;
    const srcLength = srcEndIndex - srcStartIndex;
    if (srcLength <= 0) {
      return targetStartIndex;
    }
    let targetIndex = targetStartIndex;
    for (let i5 = 0; i5 < srcLength; i5++) {
      target[targetIndex++] = positions[srcStartIndex + i5];
    }
    if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
      for (let i5 = 0; i5 < size; i5++) {
        target[targetIndex++] = positions[srcStartIndex + i5];
      }
    }
    windingOptions.start = targetStartIndex;
    windingOptions.end = targetIndex;
    windingOptions.size = size;
    modifyPolygonWindingDirection(target, windingDirection, windingOptions);
    return targetIndex;
  }
  function normalize5(polygon, positionSize) {
    validate(polygon);
    const positions = [];
    const holeIndices = [];
    if ("positions" in polygon) {
      const { positions: srcPositions, holeIndices: srcHoleIndices } = polygon;
      if (srcHoleIndices) {
        let targetIndex = 0;
        for (let i5 = 0; i5 <= srcHoleIndices.length; i5++) {
          targetIndex = copyFlatRing(
            positions,
            targetIndex,
            srcPositions,
            positionSize,
            srcHoleIndices[i5 - 1],
            srcHoleIndices[i5],
            i5 === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING
          );
          holeIndices.push(targetIndex);
        }
        holeIndices.pop();
        return { positions, holeIndices };
      }
      polygon = srcPositions;
    }
    if (!isNested(polygon)) {
      copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);
      return positions;
    }
    if (!isSimple(polygon)) {
      let targetIndex = 0;
      for (const [polygonIndex, simplePolygon] of polygon.entries()) {
        targetIndex = copyNestedRing(
          positions,
          targetIndex,
          simplePolygon,
          positionSize,
          polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING
        );
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return { positions, holeIndices };
    }
    copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);
    return positions;
  }
  function getPlaneArea(positions, xIndex, yIndex) {
    const numVerts = positions.length / 3;
    let area2 = 0;
    for (let i5 = 0; i5 < numVerts; i5++) {
      const j2 = (i5 + 1) % numVerts;
      area2 += positions[i5 * 3 + xIndex] * positions[j2 * 3 + yIndex];
      area2 -= positions[j2 * 3 + xIndex] * positions[i5 * 3 + yIndex];
    }
    return Math.abs(area2 / 2);
  }
  function permutePositions(positions, xIndex, yIndex, zIndex) {
    const numVerts = positions.length / 3;
    for (let i5 = 0; i5 < numVerts; i5++) {
      const o3 = i5 * 3;
      const x3 = positions[o3 + 0];
      const y3 = positions[o3 + 1];
      const z2 = positions[o3 + 2];
      positions[o3 + xIndex] = x3;
      positions[o3 + yIndex] = y3;
      positions[o3 + zIndex] = z2;
    }
  }
  function getSurfaceIndices(polygon, positionSize, preproject, full3d) {
    let holeIndices = getHoleIndices(polygon);
    if (holeIndices) {
      holeIndices = holeIndices.map((positionIndex) => positionIndex / positionSize);
    }
    let positions = getPositions(polygon);
    const is3d = full3d && positionSize === 3;
    if (preproject) {
      const n3 = positions.length;
      positions = positions.slice();
      const p3 = [];
      for (let i5 = 0; i5 < n3; i5 += positionSize) {
        p3[0] = positions[i5];
        p3[1] = positions[i5 + 1];
        if (is3d) {
          p3[2] = positions[i5 + 2];
        }
        const xy = preproject(p3);
        positions[i5] = xy[0];
        positions[i5 + 1] = xy[1];
        if (is3d) {
          positions[i5 + 2] = xy[2];
        }
      }
    }
    if (is3d) {
      const xyArea = getPlaneArea(positions, 0, 1);
      const xzArea = getPlaneArea(positions, 0, 2);
      const yzArea = getPlaneArea(positions, 1, 2);
      if (!xyArea && !xzArea && !yzArea) {
        return [];
      }
      if (xyArea > xzArea && xyArea > yzArea) {
      } else if (xzArea > yzArea) {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 0, 2, 1);
      } else {
        if (!preproject) {
          positions = positions.slice();
        }
        permutePositions(positions, 2, 0, 1);
      }
    }
    return (0, import_earcut2.default)(positions, holeIndices, positionSize);
  }

  // ../layers/src/solid-polygon-layer/polygon-tesselator.ts
  var PolygonTesselator = class extends Tesselator {
    constructor(opts) {
      const { fp64: fp642, IndexType = Uint32Array } = opts;
      super({
        ...opts,
        attributes: {
          positions: { size: 3, type: fp642 ? Float64Array : Float32Array },
          vertexValid: { type: Uint16Array, size: 1 },
          indices: { type: IndexType, size: 1 }
        }
      });
    }
    get(attributeName) {
      const { attributes } = this;
      if (attributeName === "indices") {
        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
      }
      return attributes[attributeName];
    }
    updateGeometry(opts) {
      super.updateGeometry(opts);
      const externalIndices = this.buffers.indices;
      if (externalIndices) {
        this.vertexCount = (externalIndices.value || externalIndices).length;
      } else if (this.data && !this.getGeometry) {
        throw new Error("missing indices buffer");
      }
    }
    normalizeGeometry(polygon) {
      if (this.normalize) {
        const normalizedPolygon = normalize5(polygon, this.positionSize);
        if (this.opts.resolution) {
          return cutPolygonByGrid(
            getPositions(normalizedPolygon),
            getHoleIndices(normalizedPolygon),
            {
              size: this.positionSize,
              gridResolution: this.opts.resolution,
              edgeTypes: true
            }
          );
        }
        if (this.opts.wrapLongitude) {
          return cutPolygonByMercatorBounds(
            getPositions(normalizedPolygon),
            getHoleIndices(normalizedPolygon),
            {
              size: this.positionSize,
              maxLatitude: 86,
              edgeTypes: true
            }
          );
        }
        return normalizedPolygon;
      }
      return polygon;
    }
    getGeometrySize(polygon) {
      if (isCut2(polygon)) {
        let size = 0;
        for (const subPolygon of polygon) {
          size += this.getGeometrySize(subPolygon);
        }
        return size;
      }
      return getPositions(polygon).length / this.positionSize;
    }
    getGeometryFromBuffer(buffer) {
      if (this.normalize || !this.buffers.indices) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    updateGeometryAttributes(polygon, context) {
      if (polygon && isCut2(polygon)) {
        for (const subPolygon of polygon) {
          const geometrySize = this.getGeometrySize(subPolygon);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPolygon, context);
          context.vertexStart += geometrySize;
          context.indexStart = this.indexStarts[context.geometryIndex + 1];
        }
      } else {
        const normalizedPolygon = polygon;
        this._updateIndices(normalizedPolygon, context);
        this._updatePositions(normalizedPolygon, context);
        this._updateVertexValid(normalizedPolygon, context);
      }
    }
    _updateIndices(polygon, { geometryIndex, vertexStart: offset, indexStart }) {
      const { attributes, indexStarts, typedArrayManager } = this;
      let target = attributes.indices;
      if (!target || !polygon) {
        return;
      }
      let i5 = indexStart;
      const indices = getSurfaceIndices(
        polygon,
        this.positionSize,
        this.opts.preproject,
        this.opts.full3d
      );
      target = typedArrayManager.allocate(target, indexStart + indices.length, {
        copy: true
      });
      for (let j2 = 0; j2 < indices.length; j2++) {
        target[i5++] = indices[j2] + offset;
      }
      indexStarts[geometryIndex + 1] = indexStart + indices.length;
      attributes.indices = target;
    }
    _updatePositions(polygon, { vertexStart, geometrySize }) {
      const {
        attributes: { positions },
        positionSize
      } = this;
      if (!positions || !polygon) {
        return;
      }
      const polygonPositions = getPositions(polygon);
      for (let i5 = vertexStart, j2 = 0; j2 < geometrySize; i5++, j2++) {
        const x3 = polygonPositions[j2 * positionSize];
        const y3 = polygonPositions[j2 * positionSize + 1];
        const z2 = positionSize > 2 ? polygonPositions[j2 * positionSize + 2] : 0;
        positions[i5 * 3] = x3;
        positions[i5 * 3 + 1] = y3;
        positions[i5 * 3 + 2] = z2;
      }
    }
    _updateVertexValid(polygon, { vertexStart, geometrySize }) {
      const { positionSize } = this;
      const vertexValid = this.attributes.vertexValid;
      const holeIndices = polygon && getHoleIndices(polygon);
      if (polygon && polygon.edgeTypes) {
        vertexValid.set(polygon.edgeTypes, vertexStart);
      } else {
        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
      }
      if (holeIndices) {
        for (let j2 = 0; j2 < holeIndices.length; j2++) {
          vertexValid[vertexStart + holeIndices[j2] / positionSize - 1] = 0;
        }
      }
      vertexValid[vertexStart + geometrySize - 1] = 0;
    }
  };
  function isCut2(polygon) {
    return Array.isArray(polygon) && polygon.length > 0 && !Number.isFinite(polygon[0]);
  }

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.ts
  var solid_polygon_layer_vertex_main_glsl_default = `
uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;

out vec4 vColor;

struct PolygonProps {
  vec4 fillColors;
  vec4 lineColors;
  vec3 positions;
  vec3 positions64Low;
  vec3 pickingColors;
  vec3 normal;
  float elevations;
};

vec3 project_offset_normal(vec3 vector) {
  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
    // normals generated by the polygon tesselator are in lnglat offsets instead of meters
    return normalize(vector * project_uCommonUnitsPerWorldUnit);
  }
  return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
  vec3 pos = props.positions;
  vec3 pos64Low = props.positions64Low;
  vec3 normal = props.normal;
  vec4 colors = isWireframe ? props.lineColors : props.fillColors;

  geometry.worldPosition = props.positions;
  geometry.pickingColor = props.pickingColors;

  if (extruded) {
    pos.z += props.elevations * elevationScale;
  }
  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  if (extruded) {
  #ifdef IS_SIDE_VERTEX
    normal = project_offset_normal(normal);
  #else
    normal = project_normal(normal);
  #endif
    geometry.normal = normal;
    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, colors.a * opacity);
  } else {
    vColor = vec4(colors.rgb, colors.a * opacity);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.ts
  var solid_polygon_layer_vertex_top_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader

in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  PolygonProps props;

  props.positions = vertexPositions;
  props.positions64Low = vertexPositions64Low;
  props.elevations = elevations;
  props.fillColors = fillColors;
  props.lineColors = lineColors;
  props.pickingColors = pickingColors;
  props.normal = vec3(0.0, 0.0, 1.0);

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.ts
  var solid_polygon_layer_vertex_side_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX

in vec2 positions;

in vec3 instancePositions;
in vec3 instanceNextPositions;
in vec3 instancePositions64Low;
in vec3 instanceNextPositions64Low;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
in float instanceVertexValid;

${solid_polygon_layer_vertex_main_glsl_default}

void main(void) {
  if(instanceVertexValid < 0.5){
    gl_Position = vec4(0.);
    return;
  }

  PolygonProps props;

  vec3 pos;
  vec3 pos64Low;
  vec3 nextPos;
  vec3 nextPos64Low;

  #if RING_WINDING_ORDER_CW == 1
    pos = instancePositions;
    pos64Low = instancePositions64Low;
    nextPos = instanceNextPositions;
    nextPos64Low = instanceNextPositions64Low;
  #else
    pos = instanceNextPositions;
    pos64Low = instanceNextPositions64Low;
    nextPos = instancePositions;
    nextPos64Low = instancePositions64Low;
  #endif

  props.positions = mix(pos, nextPos, positions.x);
  props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);

  props.normal = vec3(
    pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
    nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
    0.0);

  props.elevations = instanceElevations * positions.y;
  props.fillColors = instanceFillColors;
  props.lineColors = instanceLineColors;
  props.pickingColors = instancePickingColors;

  calculatePosition(props);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.ts
  var solid_polygon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/solid-polygon-layer/solid-polygon-layer.ts
  var DEFAULT_COLOR8 = [0, 0, 0, 255];
  var defaultProps12 = {
    filled: true,
    extruded: false,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    _full3d: false,
    elevationScale: { type: "number", min: 0, value: 1 },
    getPolygon: { type: "accessor", value: (f4) => f4.polygon },
    getElevation: { type: "accessor", value: 1e3 },
    getFillColor: { type: "accessor", value: DEFAULT_COLOR8 },
    getLineColor: { type: "accessor", value: DEFAULT_COLOR8 },
    material: true
  };
  var ATTRIBUTE_TRANSITION2 = {
    enter: (value, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
    }
  };
  var SolidPolygonLayer = class extends Layer {
    getShaders(type) {
      return super.getShaders({
        vs: type === "top" ? solid_polygon_layer_vertex_top_glsl_default : solid_polygon_layer_vertex_side_glsl_default,
        fs: solid_polygon_layer_fragment_glsl_default,
        defines: {
          RING_WINDING_ORDER_CW: !this.props._normalize && this.props._windingOrder === "CCW" ? 0 : 1
        },
        modules: [project32_default, gouraudLighting, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    getBounds() {
      return this.getAttributeManager()?.getBounds(["vertexPositions"]);
    }
    initializeState() {
      const { viewport } = this.context;
      let { coordinateSystem } = this.props;
      const { _full3d } = this.props;
      if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
      }
      let preproject;
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        if (_full3d) {
          preproject = viewport.projectPosition.bind(viewport);
        } else {
          preproject = viewport.projectFlat.bind(viewport);
        }
      }
      this.setState({
        numInstances: 0,
        polygonTesselator: new PolygonTesselator({
          preproject,
          fp64: this.use64bitPositions(),
          IndexType: Uint32Array
        })
      });
      const attributeManager = this.getAttributeManager();
      const noAlloc = true;
      attributeManager.remove(["instancePickingColors"]);
      attributeManager.add({
        indices: {
          size: 1,
          isIndexed: true,
          update: this.calculateIndices,
          noAlloc
        },
        vertexPositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getPolygon",
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            instancePositions: {
              vertexOffset: 0,
              divisor: 1
            },
            instanceNextPositions: {
              vertexOffset: 1,
              divisor: 1
            }
          }
        },
        instanceVertexValid: {
          size: 1,
          type: "uint16",
          divisor: 1,
          update: this.calculateVertexValid,
          noAlloc
        },
        elevations: {
          size: 1,
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getElevation",
          shaderAttributes: {
            instanceElevations: {
              divisor: 1
            }
          }
        },
        fillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getFillColor",
          defaultValue: DEFAULT_COLOR8,
          shaderAttributes: {
            instanceFillColors: {
              divisor: 1
            }
          }
        },
        lineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: ATTRIBUTE_TRANSITION2,
          accessor: "getLineColor",
          defaultValue: DEFAULT_COLOR8,
          shaderAttributes: {
            instanceLineColors: {
              divisor: 1
            }
          }
        },
        pickingColors: {
          size: 4,
          type: "uint8",
          accessor: (object, { index: index2, target: value }) => this.encodePickingColor(object && object.__source ? object.__source.index : index2, value),
          shaderAttributes: {
            instancePickingColors: {
              divisor: 1
            }
          }
        }
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index: index2 } = info;
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        info.object = data.find((d2) => d2.__source.index === index2);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (data[0] && data[0].__source) {
        for (let i5 = 0; i5 < data.length; i5++) {
          if (data[i5].__source.index === objectIndex) {
            this._disablePickingIndex(i5);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({ uniforms }) {
      const { extruded, filled, wireframe, elevationScale } = this.props;
      const { topModel, sideModel, wireframeModel, polygonTesselator } = this.state;
      const renderUniforms = {
        ...uniforms,
        extruded: Boolean(extruded),
        elevationScale
      };
      if (wireframeModel && wireframe) {
        wireframeModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        wireframeModel.setUniforms(renderUniforms);
        wireframeModel.draw(this.context.renderPass);
      }
      if (sideModel && filled) {
        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
        sideModel.setUniforms(renderUniforms);
        sideModel.draw(this.context.renderPass);
      }
      if (topModel && filled) {
        topModel.setVertexCount(polygonTesselator.vertexCount);
        topModel.setUniforms(renderUniforms);
        topModel.draw(this.context.renderPass);
      }
    }
    updateState(updateParams) {
      super.updateState(updateParams);
      this.updateGeometry(updateParams);
      const { props, oldProps, changeFlags } = updateParams;
      const attributeManager = this.getAttributeManager();
      const regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
      if (regenerateModels) {
        this.state.models?.forEach((model) => model.destroy());
        this.setState(this._getModels());
        attributeManager.invalidateAll();
      }
    }
    updateGeometry({ props, oldProps, changeFlags }) {
      const geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryConfigChanged) {
        const { polygonTesselator } = this.state;
        const buffers = props.data.attributes || {};
        polygonTesselator.updateGeometry({
          data: props.data,
          normalize: props._normalize,
          geometryBuffer: buffers.getPolygon,
          buffers,
          getGeometry: props.getPolygon,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          resolution: this.context.viewport.resolution,
          fp64: this.use64bitPositions(),
          dataChanged: changeFlags.dataChanged,
          full3d: props._full3d
        });
        this.setState({
          numInstances: polygonTesselator.instanceCount,
          startIndices: polygonTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          this.getAttributeManager().invalidateAll();
        }
      }
    }
    _getModels() {
      const { id, filled, extruded } = this.props;
      let topModel;
      let sideModel;
      let wireframeModel;
      const bufferLayout = this.getAttributeManager().getBufferLayouts();
      if (filled) {
        const shaders = this.getShaders("top");
        shaders.defines.NON_INSTANCED_MODEL = 1;
        topModel = new Model(this.context.device, {
          ...shaders,
          id: `${id}-top`,
          topology: "triangle-list",
          uniforms: {
            isWireframe: false
          },
          bufferLayout,
          isIndexed: true,
          userData: {
            excludeAttributes: { instanceVertexValid: true }
          }
        });
      }
      if (extruded) {
        sideModel = new Model(this.context.device, {
          ...this.getShaders("side"),
          id: `${id}-side`,
          bufferLayout,
          uniforms: {
            isWireframe: false
          },
          geometry: new Geometry({
            topology: "triangle-strip",
            attributes: {
              positions: {
                size: 2,
                value: new Float32Array([1, 0, 0, 0, 1, 1, 0, 1])
              }
            }
          }),
          isInstanced: 1,
          userData: {
            excludeAttributes: { indices: true }
          }
        });
        wireframeModel = new Model(this.context.device, {
          ...this.getShaders("side"),
          id: `${id}-wireframe`,
          bufferLayout,
          uniforms: {
            isWireframe: true
          },
          geometry: new Geometry({
            topology: "line-strip",
            attributes: {
              positions: {
                size: 2,
                value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
              }
            }
          }),
          isInstanced: 1,
          userData: {
            excludeAttributes: { indices: true }
          }
        });
      }
      return {
        models: [sideModel, wireframeModel, topModel].filter(Boolean),
        topModel,
        sideModel,
        wireframeModel
      };
    }
    calculateIndices(attribute) {
      const { polygonTesselator } = this.state;
      attribute.startIndices = polygonTesselator.indexStarts;
      attribute.value = polygonTesselator.get("indices");
    }
    calculatePositions(attribute) {
      const { polygonTesselator } = this.state;
      attribute.startIndices = polygonTesselator.vertexStarts;
      attribute.value = polygonTesselator.get("positions");
    }
    calculateVertexValid(attribute) {
      attribute.value = this.state.polygonTesselator.get("vertexValid");
    }
  };
  SolidPolygonLayer.defaultProps = defaultProps12;
  SolidPolygonLayer.layerName = "SolidPolygonLayer";

  // ../layers/src/utils.ts
  function replaceInRange({
    data,
    getIndex,
    dataRange,
    replace
  }) {
    const { startRow = 0, endRow = Infinity } = dataRange;
    const count2 = data.length;
    let replaceStart = count2;
    let replaceEnd = count2;
    for (let i5 = 0; i5 < count2; i5++) {
      const row = getIndex(data[i5]);
      if (replaceStart > i5 && row >= startRow) {
        replaceStart = i5;
      }
      if (row >= endRow) {
        replaceEnd = i5;
        break;
      }
    }
    let index2 = replaceStart;
    const dataLengthChanged = replaceEnd - replaceStart !== replace.length;
    const endChunk = dataLengthChanged ? data.slice(replaceEnd) : void 0;
    for (let i5 = 0; i5 < replace.length; i5++) {
      data[index2++] = replace[i5];
    }
    if (endChunk) {
      for (let i5 = 0; i5 < endChunk.length; i5++) {
        data[index2++] = endChunk[i5];
      }
      data.length = index2;
    }
    return {
      startRow: replaceStart,
      endRow: replaceStart + replace.length
    };
  }

  // ../layers/src/polygon-layer/polygon-layer.ts
  var defaultLineColor = [0, 0, 0, 255];
  var defaultFillColor = [0, 0, 0, 255];
  var defaultProps13 = {
    stroked: true,
    filled: true,
    extruded: false,
    elevationScale: 1,
    wireframe: false,
    _normalize: true,
    _windingOrder: "CW",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    lineJointRounded: false,
    lineMiterLimit: 4,
    getPolygon: { type: "accessor", value: (f4) => f4.polygon },
    getFillColor: { type: "accessor", value: defaultFillColor },
    getLineColor: { type: "accessor", value: defaultLineColor },
    getLineWidth: { type: "accessor", value: 1 },
    getElevation: { type: "accessor", value: 1e3 },
    material: true
  };
  var PolygonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        paths: [],
        pathsDiff: null
      };
      if (this.props.getLineDashArray) {
        log_default.removed("getLineDashArray", "PathStyleExtension")();
      }
    }
    updateState({ changeFlags }) {
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
      if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
        const paths = this.state.paths.slice();
        const pathsDiff = changeFlags.dataChanged.map(
          (dataRange) => replaceInRange({
            data: paths,
            getIndex: (p3) => p3.__source.index,
            dataRange,
            replace: this._getPaths(dataRange)
          })
        );
        this.setState({ paths, pathsDiff });
      } else if (geometryChanged) {
        this.setState({
          paths: this._getPaths(),
          pathsDiff: null
        });
      }
    }
    _getPaths(dataRange = {}) {
      const { data, getPolygon, positionFormat, _normalize } = this.props;
      const paths = [];
      const positionSize = positionFormat === "XY" ? 2 : 3;
      const { startRow, endRow } = dataRange;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let polygon = getPolygon(object, objectInfo);
        if (_normalize) {
          polygon = normalize5(polygon, positionSize);
        }
        const { holeIndices } = polygon;
        const positions = polygon.positions || polygon;
        if (holeIndices) {
          for (let i5 = 0; i5 <= holeIndices.length; i5++) {
            const path = positions.slice(holeIndices[i5 - 1] || 0, holeIndices[i5] || positions.length);
            paths.push(this.getSubLayerRow({ path }, object, objectInfo.index));
          }
        } else {
          paths.push(this.getSubLayerRow({ path: positions }, object, objectInfo.index));
        }
      }
      return paths;
    }
    renderLayers() {
      const {
        data,
        _dataDiff,
        stroked,
        filled,
        extruded,
        wireframe,
        _normalize,
        _windingOrder,
        elevationScale,
        transitions,
        positionFormat
      } = this.props;
      const {
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified
      } = this.props;
      const {
        getFillColor,
        getLineColor,
        getLineWidth,
        getLineDashArray,
        getElevation,
        getPolygon,
        updateTriggers,
        material
      } = this.props;
      const { paths, pathsDiff } = this.state;
      const FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
      const StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
      const polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer(
        {
          _dataDiff,
          extruded,
          elevationScale,
          filled,
          wireframe,
          _normalize,
          _windingOrder,
          getElevation,
          getFillColor,
          getLineColor: extruded && wireframe ? getLineColor : defaultLineColor,
          material,
          transitions
        },
        this.getSubLayerProps({
          id: "fill",
          updateTriggers: updateTriggers && {
            getPolygon: updateTriggers.getPolygon,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            lineColors: extruded && wireframe,
            getLineColor: updateTriggers.getLineColor
          }
        }),
        {
          data,
          positionFormat,
          getPolygon
        }
      );
      const polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer(
        {
          _dataDiff: pathsDiff && (() => pathsDiff),
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          jointRounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,
          _pathType: "loop",
          transitions: transitions && {
            getWidth: transitions.getLineWidth,
            getColor: transitions.getLineColor,
            getPath: transitions.getPolygon
          },
          getColor: this.getSubLayerAccessor(getLineColor),
          getWidth: this.getSubLayerAccessor(getLineWidth),
          getDashArray: this.getSubLayerAccessor(getLineDashArray)
        },
        this.getSubLayerProps({
          id: "stroke",
          updateTriggers: updateTriggers && {
            getWidth: updateTriggers.getLineWidth,
            getColor: updateTriggers.getLineColor,
            getDashArray: updateTriggers.getLineDashArray
          }
        }),
        {
          data: paths,
          positionFormat,
          getPath: (x3) => x3.path
        }
      );
      return [
        !extruded && polygonLayer,
        polygonLineLayer,
        extruded && polygonLayer
      ];
    }
  };
  PolygonLayer.layerName = "PolygonLayer";
  PolygonLayer.defaultProps = defaultProps13;

  // ../layers/src/geojson-layer/geojson-binary.ts
  function binaryToFeatureForAccesor(data, index2) {
    if (!data) {
      return null;
    }
    const featureIndex = "startIndices" in data ? data.startIndices[index2] : index2;
    const geometryIndex = data.featureIds.value[featureIndex];
    if (featureIndex !== -1) {
      return getPropertiesForIndex(data, geometryIndex, featureIndex);
    }
    return null;
  }
  function getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {
    const feature = {
      properties: { ...data.properties[propertiesIndex] }
    };
    for (const prop in data.numericProps) {
      feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];
    }
    return feature;
  }
  function calculatePickingColors(geojsonBinary, encodePickingColor) {
    const pickingColors = {
      points: null,
      lines: null,
      polygons: null
    };
    for (const key in pickingColors) {
      const featureIds = geojsonBinary[key].globalFeatureIds.value;
      pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);
      const pickingColor = [];
      for (let i5 = 0; i5 < featureIds.length; i5++) {
        encodePickingColor(featureIds[i5], pickingColor);
        pickingColors[key][i5 * 3 + 0] = pickingColor[0];
        pickingColors[key][i5 * 3 + 1] = pickingColor[1];
        pickingColors[key][i5 * 3 + 2] = pickingColor[2];
      }
    }
    return pickingColors;
  }

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.ts
  var multi_icon_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;

in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  if (!bool(picking.isActive)) {
    float alpha = texture(iconsTexture, vTextureCoords).a;
    vec4 color = vColor;

    // if enable sdf (signed distance fields)
    if (sdf) {
      float distance = alpha;
      alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);

      if (outlineBuffer > 0.0) {
        float inFill = alpha;
        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
        color = mix(outlineColor, vColor, inFill);
        alpha = inBorder;
      }
    }

    // Take the global opacity and the alpha from color into account for the alpha component
    float a = alpha * color.a;
    
    if (a < alphaCutoff) {
      discard;
    }

    fragColor = vec4(color.rgb, a * opacity);
  }

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/text-layer/multi-icon-layer/multi-icon-layer.ts
  var DEFAULT_BUFFER2 = 192 / 256;
  var EMPTY_ARRAY3 = [];
  var defaultProps14 = {
    getIconOffsets: { type: "accessor", value: (x3) => x3.offsets },
    alphaCutoff: 1e-3,
    smoothing: 0.1,
    outlineWidth: 0,
    outlineColor: { type: "color", value: [0, 0, 0, 255] }
  };
  var MultiIconLayer = class extends IconLayer {
    getShaders() {
      return { ...super.getShaders(), fs: multi_icon_layer_fragment_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceOffsets: {
          size: 2,
          accessor: "getIconOffsets"
        },
        instancePickingColors: {
          type: "uint8",
          size: 3,
          accessor: (object, { index: index2, target: value }) => this.encodePickingColor(index2, value)
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      let { outlineColor } = props;
      if (outlineColor !== oldProps.outlineColor) {
        outlineColor = outlineColor.map((x3) => x3 / 255);
        outlineColor[3] = Number.isFinite(outlineColor[3]) ? outlineColor[3] : 1;
        this.setState({
          outlineColor
        });
      }
      if (!props.sdf && props.outlineWidth) {
        log_default.warn(`${this.id}: fontSettings.sdf is required to render outline`)();
      }
    }
    draw(params) {
      const { sdf, smoothing, outlineWidth } = this.props;
      const { outlineColor } = this.state;
      const outlineBuffer = outlineWidth ? Math.max(smoothing, DEFAULT_BUFFER2 * (1 - outlineWidth)) : -1;
      params.uniforms = {
        ...params.uniforms,
        sdfBuffer: DEFAULT_BUFFER2,
        outlineBuffer,
        gamma: smoothing,
        sdf: Boolean(sdf),
        outlineColor
      };
      super.draw(params);
      if (sdf && outlineWidth) {
        const { iconManager } = this.state;
        const iconsTexture = iconManager.getTexture();
        const model = this.state.model;
        if (iconsTexture) {
          model.setUniforms({ outlineBuffer: DEFAULT_BUFFER2 });
          model.draw(this.context.renderPass);
        }
      }
    }
    getInstanceOffset(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceOffset(icon)) : EMPTY_ARRAY3;
    }
    getInstanceColorMode(icons) {
      return 1;
    }
    getInstanceIconFrame(icons) {
      return icons ? Array.from(icons).flatMap((icon) => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY3;
    }
  };
  MultiIconLayer.defaultProps = defaultProps14;
  MultiIconLayer.layerName = "MultiIconLayer";

  // ../../node_modules/@mapbox/tiny-sdf/index.js
  var INF = 1e20;
  var TinySDF = class {
    constructor({
      fontSize = 24,
      buffer = 3,
      radius = 8,
      cutoff = 0.25,
      fontFamily = "sans-serif",
      fontWeight = "normal",
      fontStyle = "normal"
    } = {}) {
      this.buffer = buffer;
      this.cutoff = cutoff;
      this.radius = radius;
      const size = this.size = fontSize + buffer * 4;
      const canvas2 = this._createCanvas(size);
      const ctx2 = this.ctx = canvas2.getContext("2d", { willReadFrequently: true });
      ctx2.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
      ctx2.textBaseline = "alphabetic";
      ctx2.textAlign = "left";
      ctx2.fillStyle = "black";
      this.gridOuter = new Float64Array(size * size);
      this.gridInner = new Float64Array(size * size);
      this.f = new Float64Array(size);
      this.z = new Float64Array(size + 1);
      this.v = new Uint16Array(size);
    }
    _createCanvas(size) {
      const canvas2 = document.createElement("canvas");
      canvas2.width = canvas2.height = size;
      return canvas2;
    }
    draw(char) {
      const {
        width: glyphAdvance,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,
        actualBoundingBoxLeft,
        actualBoundingBoxRight
      } = this.ctx.measureText(char);
      const glyphTop = Math.ceil(actualBoundingBoxAscent);
      const glyphLeft = 0;
      const glyphWidth = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(actualBoundingBoxRight - actualBoundingBoxLeft)));
      const glyphHeight = Math.min(this.size - this.buffer, glyphTop + Math.ceil(actualBoundingBoxDescent));
      const width = glyphWidth + 2 * this.buffer;
      const height = glyphHeight + 2 * this.buffer;
      const len4 = Math.max(width * height, 0);
      const data = new Uint8ClampedArray(len4);
      const glyph = { data, width, height, glyphWidth, glyphHeight, glyphTop, glyphLeft, glyphAdvance };
      if (glyphWidth === 0 || glyphHeight === 0)
        return glyph;
      const { ctx: ctx2, buffer, gridInner, gridOuter } = this;
      ctx2.clearRect(buffer, buffer, glyphWidth, glyphHeight);
      ctx2.fillText(char, buffer, buffer + glyphTop);
      const imgData = ctx2.getImageData(buffer, buffer, glyphWidth, glyphHeight);
      gridOuter.fill(INF, 0, len4);
      gridInner.fill(0, 0, len4);
      for (let y3 = 0; y3 < glyphHeight; y3++) {
        for (let x3 = 0; x3 < glyphWidth; x3++) {
          const a3 = imgData.data[4 * (y3 * glyphWidth + x3) + 3] / 255;
          if (a3 === 0)
            continue;
          const j2 = (y3 + buffer) * width + x3 + buffer;
          if (a3 === 1) {
            gridOuter[j2] = 0;
            gridInner[j2] = INF;
          } else {
            const d2 = 0.5 - a3;
            gridOuter[j2] = d2 > 0 ? d2 * d2 : 0;
            gridInner[j2] = d2 < 0 ? d2 * d2 : 0;
          }
        }
      }
      edt(gridOuter, 0, 0, width, height, width, this.f, this.v, this.z);
      edt(gridInner, buffer, buffer, glyphWidth, glyphHeight, width, this.f, this.v, this.z);
      for (let i5 = 0; i5 < len4; i5++) {
        const d2 = Math.sqrt(gridOuter[i5]) - Math.sqrt(gridInner[i5]);
        data[i5] = Math.round(255 - 255 * (d2 / this.radius + this.cutoff));
      }
      return glyph;
    }
  };
  function edt(data, x0, y0, width, height, gridSize, f4, v2, z2) {
    for (let x3 = x0; x3 < x0 + width; x3++)
      edt1d(data, y0 * gridSize + x3, gridSize, height, f4, v2, z2);
    for (let y3 = y0; y3 < y0 + height; y3++)
      edt1d(data, y3 * gridSize + x0, 1, width, f4, v2, z2);
  }
  function edt1d(grid, offset, stride, length6, f4, v2, z2) {
    v2[0] = 0;
    z2[0] = -INF;
    z2[1] = INF;
    f4[0] = grid[offset];
    for (let q2 = 1, k2 = 0, s3 = 0; q2 < length6; q2++) {
      f4[q2] = grid[offset + q2 * stride];
      const q22 = q2 * q2;
      do {
        const r3 = v2[k2];
        s3 = (f4[q2] - f4[r3] + q22 - r3 * r3) / (q2 - r3) / 2;
      } while (s3 <= z2[k2] && --k2 > -1);
      k2++;
      v2[k2] = q2;
      z2[k2] = s3;
      z2[k2 + 1] = INF;
    }
    for (let q2 = 0, k2 = 0; q2 < length6; q2++) {
      while (z2[k2 + 1] < q2)
        k2++;
      const r3 = v2[k2];
      const qr = q2 - r3;
      grid[offset + q2 * stride] = f4[r3] + qr * qr;
    }
  }

  // ../layers/src/text-layer/utils.ts
  var MISSING_CHAR_WIDTH = 32;
  var SINGLE_LINE = [];
  function nextPowOfTwo2(number) {
    return Math.pow(2, Math.ceil(Math.log2(number)));
  }
  function buildMapping2({
    characterSet,
    getFontWidth,
    fontHeight,
    buffer,
    maxCanvasWidth,
    mapping = {},
    xOffset = 0,
    yOffset = 0
  }) {
    let row = 0;
    let x3 = xOffset;
    const rowHeight = fontHeight + buffer * 2;
    for (const char of characterSet) {
      if (!mapping[char]) {
        const width = getFontWidth(char);
        if (x3 + width + buffer * 2 > maxCanvasWidth) {
          x3 = 0;
          row++;
        }
        mapping[char] = {
          x: x3 + buffer,
          y: yOffset + row * rowHeight + buffer,
          width,
          height: rowHeight,
          layoutWidth: width,
          layoutHeight: fontHeight
        };
        x3 += width + buffer * 2;
      }
    }
    return {
      mapping,
      xOffset: x3,
      yOffset: yOffset + row * rowHeight,
      canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
    };
  }
  function getTextWidth(text, startIndex, endIndex, mapping) {
    let width = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const character = text[i5];
      width += mapping[character]?.layoutWidth || 0;
    }
    return width;
  }
  function breakAll(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    let rowStartCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const textWidth = getTextWidth(text, i5, i5 + 1, iconMapping);
      if (rowOffsetLeft + textWidth > maxWidth) {
        if (rowStartCharIndex < i5) {
          target.push(i5);
        }
        rowStartCharIndex = i5;
        rowOffsetLeft = 0;
      }
      rowOffsetLeft += textWidth;
    }
    return rowOffsetLeft;
  }
  function breakWord(text, startIndex, endIndex, maxWidth, iconMapping, target) {
    let rowStartCharIndex = startIndex;
    let groupStartCharIndex = startIndex;
    let groupEndCharIndex = startIndex;
    let rowOffsetLeft = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      if (text[i5] === " ") {
        groupEndCharIndex = i5 + 1;
      } else if (text[i5 + 1] === " " || i5 + 1 === endIndex) {
        groupEndCharIndex = i5 + 1;
      }
      if (groupEndCharIndex > groupStartCharIndex) {
        let groupWidth = getTextWidth(text, groupStartCharIndex, groupEndCharIndex, iconMapping);
        if (rowOffsetLeft + groupWidth > maxWidth) {
          if (rowStartCharIndex < groupStartCharIndex) {
            target.push(groupStartCharIndex);
            rowStartCharIndex = groupStartCharIndex;
            rowOffsetLeft = 0;
          }
          if (groupWidth > maxWidth) {
            groupWidth = breakAll(
              text,
              groupStartCharIndex,
              groupEndCharIndex,
              maxWidth,
              iconMapping,
              target
            );
            rowStartCharIndex = target[target.length - 1];
          }
        }
        groupStartCharIndex = groupEndCharIndex;
        rowOffsetLeft += groupWidth;
      }
    }
    return rowOffsetLeft;
  }
  function autoWrapping(text, wordBreak, maxWidth, iconMapping, startIndex = 0, endIndex) {
    if (endIndex === void 0) {
      endIndex = text.length;
    }
    const result = [];
    if (wordBreak === "break-all") {
      breakAll(text, startIndex, endIndex, maxWidth, iconMapping, result);
    } else {
      breakWord(text, startIndex, endIndex, maxWidth, iconMapping, result);
    }
    return result;
  }
  function transformRow(line, startIndex, endIndex, iconMapping, leftOffsets, rowSize) {
    let x3 = 0;
    let rowHeight = 0;
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      const character = line[i5];
      const frame = iconMapping[character];
      if (frame) {
        if (!rowHeight) {
          rowHeight = frame.layoutHeight;
        }
        leftOffsets[i5] = x3 + frame.layoutWidth / 2;
        x3 += frame.layoutWidth;
      } else {
        log_default.warn(`Missing character: ${character} (${character.codePointAt(0)})`)();
        leftOffsets[i5] = x3;
        x3 += MISSING_CHAR_WIDTH;
      }
    }
    rowSize[0] = x3;
    rowSize[1] = rowHeight;
  }
  function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
    const characters = Array.from(paragraph);
    const numCharacters = characters.length;
    const x3 = new Array(numCharacters);
    const y3 = new Array(numCharacters);
    const rowWidth = new Array(numCharacters);
    const autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
    const size = [0, 0];
    const rowSize = [0, 0];
    let rowOffsetTop = 0;
    let lineStartIndex = 0;
    let lineEndIndex = 0;
    for (let i5 = 0; i5 <= numCharacters; i5++) {
      const char = characters[i5];
      if (char === "\n" || i5 === numCharacters) {
        lineEndIndex = i5;
      }
      if (lineEndIndex > lineStartIndex) {
        const rows = autoWrappingEnabled ? autoWrapping(characters, wordBreak, maxWidth, iconMapping, lineStartIndex, lineEndIndex) : SINGLE_LINE;
        for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
          const rowStart = rowIndex === 0 ? lineStartIndex : rows[rowIndex - 1];
          const rowEnd = rowIndex < rows.length ? rows[rowIndex] : lineEndIndex;
          transformRow(characters, rowStart, rowEnd, iconMapping, x3, rowSize);
          for (let j2 = rowStart; j2 < rowEnd; j2++) {
            const char2 = characters[j2];
            const layoutOffsetY = iconMapping[char2]?.layoutOffsetY || 0;
            y3[j2] = rowOffsetTop + rowSize[1] / 2 + layoutOffsetY;
            rowWidth[j2] = rowSize[0];
          }
          rowOffsetTop = rowOffsetTop + rowSize[1] * lineHeight;
          size[0] = Math.max(size[0], rowSize[0]);
        }
        lineStartIndex = lineEndIndex;
      }
      if (char === "\n") {
        x3[lineStartIndex] = 0;
        y3[lineStartIndex] = 0;
        rowWidth[lineStartIndex] = 0;
        lineStartIndex++;
      }
    }
    size[1] = rowOffsetTop;
    return { x: x3, y: y3, rowWidth, size };
  }
  function getTextFromBuffer({
    value,
    length: length6,
    stride,
    offset,
    startIndices,
    characterSet
  }) {
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : 1;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const characterCount = startIndices[length6] || Math.ceil((value.length - elementOffset) / elementStride);
    const autoCharacterSet = characterSet && /* @__PURE__ */ new Set();
    const texts = new Array(length6);
    let codes = value;
    if (elementStride > 1 || elementOffset > 0) {
      const ArrayType2 = value.constructor;
      codes = new ArrayType2(characterCount);
      for (let i5 = 0; i5 < characterCount; i5++) {
        codes[i5] = value[i5 * elementStride + elementOffset];
      }
    }
    for (let index2 = 0; index2 < length6; index2++) {
      const startIndex = startIndices[index2];
      const endIndex = startIndices[index2 + 1] || characterCount;
      const codesAtIndex = codes.subarray(startIndex, endIndex);
      texts[index2] = String.fromCodePoint.apply(null, codesAtIndex);
      if (autoCharacterSet) {
        codesAtIndex.forEach(autoCharacterSet.add, autoCharacterSet);
      }
    }
    if (autoCharacterSet) {
      for (const charCode of autoCharacterSet) {
        characterSet.add(String.fromCodePoint(charCode));
      }
    }
    return { texts, characterCount };
  }

  // ../layers/src/text-layer/lru-cache.ts
  var LRUCache = class {
    constructor(limit = 5) {
      this._cache = {};
      this._order = [];
      this.limit = limit;
    }
    get(key) {
      const value = this._cache[key];
      if (value) {
        this._deleteOrder(key);
        this._appendOrder(key);
      }
      return value;
    }
    set(key, value) {
      if (!this._cache[key]) {
        if (Object.keys(this._cache).length === this.limit) {
          this.delete(this._order[0]);
        }
        this._cache[key] = value;
        this._appendOrder(key);
      } else {
        this.delete(key);
        this._cache[key] = value;
        this._appendOrder(key);
      }
    }
    delete(key) {
      const value = this._cache[key];
      if (value) {
        delete this._cache[key];
        this._deleteOrder(key);
      }
    }
    _deleteOrder(key) {
      const index2 = this._order.indexOf(key);
      if (index2 >= 0) {
        this._order.splice(index2, 1);
      }
    }
    _appendOrder(key) {
      this._order.push(key);
    }
  };

  // ../layers/src/text-layer/font-atlas-manager.ts
  function getDefaultCharacterSet() {
    const charSet = [];
    for (let i5 = 32; i5 < 128; i5++) {
      charSet.push(String.fromCharCode(i5));
    }
    return charSet;
  }
  var DEFAULT_FONT_SETTINGS = {
    fontFamily: "Monaco, monospace",
    fontWeight: "normal",
    characterSet: getDefaultCharacterSet(),
    fontSize: 64,
    buffer: 4,
    sdf: false,
    cutoff: 0.25,
    radius: 12,
    smoothing: 0.1
  };
  var MAX_CANVAS_WIDTH = 1024;
  var BASELINE_SCALE = 0.9;
  var HEIGHT_SCALE = 1.2;
  var CACHE_LIMIT = 3;
  var cache2 = new LRUCache(CACHE_LIMIT);
  function getNewChars(cacheKey, characterSet) {
    let newCharSet;
    if (typeof characterSet === "string") {
      newCharSet = new Set(Array.from(characterSet));
    } else {
      newCharSet = new Set(characterSet);
    }
    const cachedFontAtlas = cache2.get(cacheKey);
    if (!cachedFontAtlas) {
      return newCharSet;
    }
    for (const char in cachedFontAtlas.mapping) {
      if (newCharSet.has(char)) {
        newCharSet.delete(char);
      }
    }
    return newCharSet;
  }
  function populateAlphaChannel(alphaChannel, imageData) {
    for (let i5 = 0; i5 < alphaChannel.length; i5++) {
      imageData.data[4 * i5 + 3] = alphaChannel[i5];
    }
  }
  function setTextStyle(ctx2, fontFamily, fontSize, fontWeight) {
    ctx2.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    ctx2.fillStyle = "#000";
    ctx2.textBaseline = "alphabetic";
    ctx2.textAlign = "left";
  }
  function setFontAtlasCacheLimit(limit) {
    log_default.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, "Invalid cache limit");
    cache2 = new LRUCache(limit);
  }
  var FontAtlasManager = class {
    constructor() {
      this.props = { ...DEFAULT_FONT_SETTINGS };
    }
    get atlas() {
      return this._atlas;
    }
    get mapping() {
      return this._atlas && this._atlas.mapping;
    }
    get scale() {
      const { fontSize, buffer } = this.props;
      return (fontSize * HEIGHT_SCALE + buffer * 2) / fontSize;
    }
    setProps(props = {}) {
      Object.assign(this.props, props);
      this._key = this._getKey();
      const charSet = getNewChars(this._key, this.props.characterSet);
      const cachedFontAtlas = cache2.get(this._key);
      if (cachedFontAtlas && charSet.size === 0) {
        if (this._atlas !== cachedFontAtlas) {
          this._atlas = cachedFontAtlas;
        }
        return;
      }
      const fontAtlas = this._generateFontAtlas(charSet, cachedFontAtlas);
      this._atlas = fontAtlas;
      cache2.set(this._key, fontAtlas);
    }
    _generateFontAtlas(characterSet, cachedFontAtlas) {
      const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
      let canvas2 = cachedFontAtlas && cachedFontAtlas.data;
      if (!canvas2) {
        canvas2 = document.createElement("canvas");
        canvas2.width = MAX_CANVAS_WIDTH;
      }
      const ctx2 = canvas2.getContext("2d", { willReadFrequently: true });
      setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
      const { mapping, canvasHeight, xOffset, yOffset } = buildMapping2({
        getFontWidth: (char) => ctx2.measureText(char).width,
        fontHeight: fontSize * HEIGHT_SCALE,
        buffer,
        characterSet,
        maxCanvasWidth: MAX_CANVAS_WIDTH,
        ...cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        }
      });
      if (canvas2.height !== canvasHeight) {
        const imageData = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);
        canvas2.height = canvasHeight;
        ctx2.putImageData(imageData, 0, 0);
      }
      setTextStyle(ctx2, fontFamily, fontSize, fontWeight);
      if (sdf) {
        const tinySDF = new TinySDF({
          fontSize,
          buffer,
          radius,
          cutoff,
          fontFamily,
          fontWeight: `${fontWeight}`
        });
        for (const char of characterSet) {
          const { data, width, height, glyphTop } = tinySDF.draw(char);
          mapping[char].width = width;
          mapping[char].layoutOffsetY = fontSize * BASELINE_SCALE - glyphTop;
          const imageData = ctx2.createImageData(width, height);
          populateAlphaChannel(data, imageData);
          ctx2.putImageData(imageData, mapping[char].x, mapping[char].y);
        }
      } else {
        for (const char of characterSet) {
          ctx2.fillText(char, mapping[char].x, mapping[char].y + buffer + fontSize * BASELINE_SCALE);
        }
      }
      return {
        xOffset,
        yOffset,
        mapping,
        data: canvas2,
        width: canvas2.width,
        height: canvas2.height
      };
    }
    _getKey() {
      const { fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff } = this.props;
      if (sdf) {
        return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
      }
      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
    }
  };

  // ../layers/src/text-layer/text-background-layer/text-background-layer-vertex.glsl.ts
  var text_background_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader

in vec2 positions;

in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;

uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;

out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = radians(angle);
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = positions;
  geometry.pickingColor = instancePickingColors;
  uv = positions;
  vLineWidth = instanceLineWidths;

  // convert size in meters to pixels, then scaled and clamp

  // project meters to pixels and clamp to limits
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
    sizeMinPixels, sizeMaxPixels
  );

  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;

  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
  pixelOffset += instancePixelOffsets;
  pixelOffset.y *= -1.0;

  if (billboard)  {
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
    vec3 offset = vec3(pixelOffset, 0.0);
    DECKGL_FILTER_SIZE(offset, geometry);
    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    DECKGL_FILTER_SIZE(offset_common, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
  DECKGL_FILTER_COLOR(vFillColor, geometry);
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
  DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer-fragment.glsl.ts
  var text_background_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader

precision highp float;

uniform bool stroked;

in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;

out vec4 fragColor;

void main(void) {
  geometry.uv = uv;

  vec2 pixelPosition = uv * dimensions;
  if (stroked) {
    float distToEdge = min(
      min(pixelPosition.x, dimensions.x - pixelPosition.x),
      min(pixelPosition.y, dimensions.y - pixelPosition.y)
    );
    float isBorder = smoothedge(distToEdge, vLineWidth);
    fragColor = mix(vFillColor, vLineColor, isBorder);
  } else {
    fragColor = vFillColor;
  }

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../layers/src/text-layer/text-background-layer/text-background-layer.ts
  var defaultProps15 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    padding: { type: "array", value: [0, 0, 0, 0] },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getSize: { type: "accessor", value: 1 },
    getAngle: { type: "accessor", value: 0 },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    getBoundingRect: { type: "accessor", value: [0, 0, 0, 0] },
    getFillColor: { type: "accessor", value: [0, 0, 0, 255] },
    getLineColor: { type: "accessor", value: [0, 0, 0, 255] },
    getLineWidth: { type: "accessor", value: 1 }
  };
  var TextBackgroundLayer = class extends Layer {
    getShaders() {
      return super.getShaders({ vs: text_background_layer_vertex_glsl_default, fs: text_background_layer_fragment_glsl_default, modules: [project32_default, picking_default] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceSizes: {
          size: 1,
          transition: true,
          accessor: "getSize",
          defaultValue: 1
        },
        instanceAngles: {
          size: 1,
          transition: true,
          accessor: "getAngle"
        },
        instanceRects: {
          size: 4,
          accessor: "getBoundingRect"
        },
        instancePixelOffsets: {
          size: 2,
          transition: true,
          accessor: "getPixelOffset"
        },
        instanceFillColors: {
          size: 4,
          transition: true,
          type: "unorm8",
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: 4,
          transition: true,
          type: "unorm8",
          accessor: "getLineColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { changeFlags } = params;
      if (changeFlags.extensionsChanged) {
        this.state.model?.destroy();
        this.state.model = this._getModel();
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({ uniforms }) {
      const { billboard, sizeScale, sizeUnits, sizeMinPixels, sizeMaxPixels, getLineWidth } = this.props;
      let { padding } = this.props;
      if (padding.length < 4) {
        padding = [padding[0], padding[1], padding[0], padding[1]];
      }
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setUniforms({
        billboard,
        stroked: Boolean(getLineWidth),
        padding,
        sizeUnits: UNIT[sizeUnits],
        sizeScale,
        sizeMinPixels,
        sizeMaxPixels
      });
      model.draw(this.context.renderPass);
    }
    _getModel() {
      const positions = [0, 0, 1, 0, 1, 1, 0, 1];
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-fan-webgl",
          vertexCount: 4,
          attributes: {
            positions: { size: 2, value: new Float32Array(positions) }
          }
        }),
        isInstanced: true
      });
    }
  };
  TextBackgroundLayer.defaultProps = defaultProps15;
  TextBackgroundLayer.layerName = "TextBackgroundLayer";

  // ../layers/src/text-layer/text-layer.ts
  var TEXT_ANCHOR = {
    start: 1,
    middle: 0,
    end: -1
  };
  var ALIGNMENT_BASELINE = {
    top: 1,
    center: 0,
    bottom: -1
  };
  var DEFAULT_COLOR9 = [0, 0, 0, 255];
  var DEFAULT_LINE_HEIGHT = 1;
  var defaultProps16 = {
    billboard: true,
    sizeScale: 1,
    sizeUnits: "pixels",
    sizeMinPixels: 0,
    sizeMaxPixels: Number.MAX_SAFE_INTEGER,
    background: false,
    getBackgroundColor: { type: "accessor", value: [255, 255, 255, 255] },
    getBorderColor: { type: "accessor", value: DEFAULT_COLOR9 },
    getBorderWidth: { type: "accessor", value: 0 },
    backgroundPadding: { type: "array", value: [0, 0, 0, 0] },
    characterSet: { type: "object", value: DEFAULT_FONT_SETTINGS.characterSet },
    fontFamily: DEFAULT_FONT_SETTINGS.fontFamily,
    fontWeight: DEFAULT_FONT_SETTINGS.fontWeight,
    lineHeight: DEFAULT_LINE_HEIGHT,
    outlineWidth: { type: "number", value: 0, min: 0 },
    outlineColor: { type: "color", value: DEFAULT_COLOR9 },
    fontSettings: { type: "object", value: {}, compare: 1 },
    wordBreak: "break-word",
    maxWidth: { type: "number", value: -1 },
    getText: { type: "accessor", value: (x3) => x3.text },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR9 },
    getSize: { type: "accessor", value: 32 },
    getAngle: { type: "accessor", value: 0 },
    getTextAnchor: { type: "accessor", value: "middle" },
    getAlignmentBaseline: { type: "accessor", value: "center" },
    getPixelOffset: { type: "accessor", value: [0, 0] },
    backgroundColor: { deprecatedFor: ["background", "getBackgroundColor"] }
  };
  var TextLayer = class extends CompositeLayer {
    constructor() {
      super(...arguments);
      this.getBoundingRect = (object, objectInfo) => {
        let {
          size: [width, height]
        } = this.transformParagraph(object, objectInfo);
        const { fontSize } = this.state.fontAtlasManager.props;
        width /= fontSize;
        height /= fontSize;
        const { getTextAnchor, getAlignmentBaseline } = this.props;
        const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
        const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
        return [(anchorX - 1) * width / 2, (anchorY - 1) * height / 2, width, height];
      };
      this.getIconOffsets = (object, objectInfo) => {
        const { getTextAnchor, getAlignmentBaseline } = this.props;
        const {
          x: x3,
          y: y3,
          rowWidth,
          size: [width, height]
        } = this.transformParagraph(object, objectInfo);
        const anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
        const anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
        const numCharacters = x3.length;
        const offsets = new Array(numCharacters * 2);
        let index2 = 0;
        for (let i5 = 0; i5 < numCharacters; i5++) {
          const rowOffset = (1 - anchorX) * (width - rowWidth[i5]) / 2;
          offsets[index2++] = (anchorX - 1) * width / 2 + rowOffset + x3[i5];
          offsets[index2++] = (anchorY - 1) * height / 2 + y3[i5];
        }
        return offsets;
      };
    }
    initializeState() {
      this.state = {
        styleVersion: 0,
        fontAtlasManager: new FontAtlasManager()
      };
      if (this.props.maxWidth > 0) {
        log_default.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")();
      }
    }
    updateState(params) {
      const { props, oldProps, changeFlags } = params;
      const textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
      if (textChanged) {
        this._updateText();
      }
      const fontChanged = this._updateFontAtlas();
      const styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
      if (styleChanged) {
        this.setState({
          styleVersion: this.state.styleVersion + 1
        });
      }
    }
    getPickingInfo({ info }) {
      info.object = info.index >= 0 ? this.props.data[info.index] : null;
      return info;
    }
    _updateFontAtlas() {
      const { fontSettings, fontFamily, fontWeight } = this.props;
      const { fontAtlasManager, characterSet } = this.state;
      const fontProps = {
        ...fontSettings,
        characterSet,
        fontFamily,
        fontWeight
      };
      if (!fontAtlasManager.mapping) {
        fontAtlasManager.setProps(fontProps);
        return true;
      }
      for (const key in fontProps) {
        if (fontProps[key] !== fontAtlasManager.props[key]) {
          fontAtlasManager.setProps(fontProps);
          return true;
        }
      }
      return false;
    }
    _updateText() {
      const { data, characterSet } = this.props;
      const textBuffer = data.attributes?.getText;
      let { getText } = this.props;
      let startIndices = data.startIndices;
      let numInstances;
      const autoCharacterSet = characterSet === "auto" && /* @__PURE__ */ new Set();
      if (textBuffer && startIndices) {
        const { texts, characterCount } = getTextFromBuffer({
          ...ArrayBuffer.isView(textBuffer) ? { value: textBuffer } : textBuffer,
          length: data.length,
          startIndices,
          characterSet: autoCharacterSet
        });
        numInstances = characterCount;
        getText = (_, { index: index2 }) => texts[index2];
      } else {
        const { iterable, objectInfo } = createIterable(data);
        startIndices = [0];
        numInstances = 0;
        for (const object of iterable) {
          objectInfo.index++;
          const text = Array.from(getText(object, objectInfo) || "");
          if (autoCharacterSet) {
            text.forEach(autoCharacterSet.add, autoCharacterSet);
          }
          numInstances += text.length;
          startIndices.push(numInstances);
        }
      }
      this.setState({
        getText,
        startIndices,
        numInstances,
        characterSet: autoCharacterSet || characterSet
      });
    }
    transformParagraph(object, objectInfo) {
      const { fontAtlasManager } = this.state;
      const iconMapping = fontAtlasManager.mapping;
      const getText = this.state.getText;
      const { wordBreak, lineHeight, maxWidth } = this.props;
      const paragraph = getText(object, objectInfo) || "";
      return transformParagraph(
        paragraph,
        lineHeight,
        wordBreak,
        maxWidth * fontAtlasManager.props.fontSize,
        iconMapping
      );
    }
    renderLayers() {
      const {
        startIndices,
        numInstances,
        getText,
        fontAtlasManager: { scale: scale7, atlas, mapping },
        styleVersion
      } = this.state;
      const {
        data,
        _dataDiff,
        getPosition: getPosition2,
        getColor: getColor2,
        getSize,
        getAngle,
        getPixelOffset,
        getBackgroundColor,
        getBorderColor,
        getBorderWidth,
        backgroundPadding,
        background,
        billboard,
        fontSettings,
        outlineWidth,
        outlineColor,
        sizeScale,
        sizeUnits,
        sizeMinPixels,
        sizeMaxPixels,
        transitions,
        updateTriggers
      } = this.props;
      const CharactersLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
      const BackgroundLayerClass = this.getSubLayerClass("background", TextBackgroundLayer);
      return [
        background && new BackgroundLayerClass(
          {
            getFillColor: getBackgroundColor,
            getLineColor: getBorderColor,
            getLineWidth: getBorderWidth,
            padding: backgroundPadding,
            getPosition: getPosition2,
            getSize,
            getAngle,
            getPixelOffset,
            billboard,
            sizeScale,
            sizeUnits,
            sizeMinPixels,
            sizeMaxPixels,
            transitions: transitions && {
              getPosition: transitions.getPosition,
              getAngle: transitions.getAngle,
              getSize: transitions.getSize,
              getFillColor: transitions.getBackgroundColor,
              getLineColor: transitions.getBorderColor,
              getLineWidth: transitions.getBorderWidth,
              getPixelOffset: transitions.getPixelOffset
            }
          },
          this.getSubLayerProps({
            id: "background",
            updateTriggers: {
              getPosition: updateTriggers.getPosition,
              getAngle: updateTriggers.getAngle,
              getSize: updateTriggers.getSize,
              getFillColor: updateTriggers.getBackgroundColor,
              getLineColor: updateTriggers.getBorderColor,
              getLineWidth: updateTriggers.getBorderWidth,
              getPixelOffset: updateTriggers.getPixelOffset,
              getBoundingRect: {
                getText: updateTriggers.getText,
                getTextAnchor: updateTriggers.getTextAnchor,
                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
                styleVersion
              }
            }
          }),
          {
            data: data.attributes && data.attributes.background ? { length: data.length, attributes: data.attributes.background } : data,
            _dataDiff,
            autoHighlight: false,
            getBoundingRect: this.getBoundingRect
          }
        ),
        new CharactersLayerClass(
          {
            sdf: fontSettings.sdf,
            smoothing: Number.isFinite(fontSettings.smoothing) ? fontSettings.smoothing : DEFAULT_FONT_SETTINGS.smoothing,
            outlineWidth: outlineWidth / (fontSettings.radius || DEFAULT_FONT_SETTINGS.radius),
            outlineColor,
            iconAtlas: atlas,
            iconMapping: mapping,
            getPosition: getPosition2,
            getColor: getColor2,
            getSize,
            getAngle,
            getPixelOffset,
            billboard,
            sizeScale: sizeScale * scale7,
            sizeUnits,
            sizeMinPixels: sizeMinPixels * scale7,
            sizeMaxPixels: sizeMaxPixels * scale7,
            transitions: transitions && {
              getPosition: transitions.getPosition,
              getAngle: transitions.getAngle,
              getColor: transitions.getColor,
              getSize: transitions.getSize,
              getPixelOffset: transitions.getPixelOffset
            }
          },
          this.getSubLayerProps({
            id: "characters",
            updateTriggers: {
              all: updateTriggers.getText,
              getPosition: updateTriggers.getPosition,
              getAngle: updateTriggers.getAngle,
              getColor: updateTriggers.getColor,
              getSize: updateTriggers.getSize,
              getPixelOffset: updateTriggers.getPixelOffset,
              getIconOffsets: {
                getTextAnchor: updateTriggers.getTextAnchor,
                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
                styleVersion
              }
            }
          }),
          {
            data,
            _dataDiff,
            startIndices,
            numInstances,
            getIconOffsets: this.getIconOffsets,
            getIcon: getText
          }
        )
      ];
    }
    static set fontAtlasCacheLimit(limit) {
      setFontAtlasCacheLimit(limit);
    }
  };
  TextLayer.defaultProps = defaultProps16;
  TextLayer.layerName = "TextLayer";

  // ../layers/src/geojson-layer/sub-layer-map.ts
  var POINT_LAYER = {
    circle: {
      type: ScatterplotLayer,
      props: {
        filled: "filled",
        stroked: "stroked",
        lineWidthMaxPixels: "lineWidthMaxPixels",
        lineWidthMinPixels: "lineWidthMinPixels",
        lineWidthScale: "lineWidthScale",
        lineWidthUnits: "lineWidthUnits",
        pointRadiusMaxPixels: "radiusMaxPixels",
        pointRadiusMinPixels: "radiusMinPixels",
        pointRadiusScale: "radiusScale",
        pointRadiusUnits: "radiusUnits",
        pointAntialiasing: "antialiasing",
        pointBillboard: "billboard",
        getFillColor: "getFillColor",
        getLineColor: "getLineColor",
        getLineWidth: "getLineWidth",
        getPointRadius: "getRadius"
      }
    },
    icon: {
      type: IconLayer,
      props: {
        iconAtlas: "iconAtlas",
        iconMapping: "iconMapping",
        iconSizeMaxPixels: "sizeMaxPixels",
        iconSizeMinPixels: "sizeMinPixels",
        iconSizeScale: "sizeScale",
        iconSizeUnits: "sizeUnits",
        iconAlphaCutoff: "alphaCutoff",
        iconBillboard: "billboard",
        getIcon: "getIcon",
        getIconAngle: "getAngle",
        getIconColor: "getColor",
        getIconPixelOffset: "getPixelOffset",
        getIconSize: "getSize"
      }
    },
    text: {
      type: TextLayer,
      props: {
        textSizeMaxPixels: "sizeMaxPixels",
        textSizeMinPixels: "sizeMinPixels",
        textSizeScale: "sizeScale",
        textSizeUnits: "sizeUnits",
        textBackground: "background",
        textBackgroundPadding: "backgroundPadding",
        textFontFamily: "fontFamily",
        textFontWeight: "fontWeight",
        textLineHeight: "lineHeight",
        textMaxWidth: "maxWidth",
        textOutlineColor: "outlineColor",
        textOutlineWidth: "outlineWidth",
        textWordBreak: "wordBreak",
        textCharacterSet: "characterSet",
        textBillboard: "billboard",
        textFontSettings: "fontSettings",
        getText: "getText",
        getTextAngle: "getAngle",
        getTextColor: "getColor",
        getTextPixelOffset: "getPixelOffset",
        getTextSize: "getSize",
        getTextAnchor: "getTextAnchor",
        getTextAlignmentBaseline: "getAlignmentBaseline",
        getTextBackgroundColor: "getBackgroundColor",
        getTextBorderColor: "getBorderColor",
        getTextBorderWidth: "getBorderWidth"
      }
    }
  };
  var LINE_LAYER = {
    type: PathLayer,
    props: {
      lineWidthUnits: "widthUnits",
      lineWidthScale: "widthScale",
      lineWidthMinPixels: "widthMinPixels",
      lineWidthMaxPixels: "widthMaxPixels",
      lineJointRounded: "jointRounded",
      lineCapRounded: "capRounded",
      lineMiterLimit: "miterLimit",
      lineBillboard: "billboard",
      getLineColor: "getColor",
      getLineWidth: "getWidth"
    }
  };
  var POLYGON_LAYER = {
    type: SolidPolygonLayer,
    props: {
      extruded: "extruded",
      filled: "filled",
      wireframe: "wireframe",
      elevationScale: "elevationScale",
      material: "material",
      _full3d: "_full3d",
      getElevation: "getElevation",
      getFillColor: "getFillColor",
      getLineColor: "getLineColor"
    }
  };
  function getDefaultProps({
    type,
    props
  }) {
    const result = {};
    for (const key in props) {
      result[key] = type.defaultProps[props[key]];
    }
    return result;
  }
  function forwardProps(layer, mapping) {
    const { transitions, updateTriggers } = layer.props;
    const result = {
      updateTriggers: {},
      transitions: transitions && {
        getPosition: transitions.geometry
      }
    };
    for (const sourceKey in mapping) {
      const targetKey = mapping[sourceKey];
      let value = layer.props[sourceKey];
      if (sourceKey.startsWith("get")) {
        value = layer.getSubLayerAccessor(value);
        result.updateTriggers[targetKey] = updateTriggers[sourceKey];
        if (transitions) {
          result.transitions[targetKey] = transitions[sourceKey];
        }
      }
      result[targetKey] = value;
    }
    return result;
  }

  // ../layers/src/geojson-layer/geojson.ts
  function getGeojsonFeatures(geojson) {
    if (Array.isArray(geojson)) {
      return geojson;
    }
    log_default.assert(geojson.type, "GeoJSON does not have type");
    switch (geojson.type) {
      case "Feature":
        return [geojson];
      case "FeatureCollection":
        log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
        return geojson.features;
      default:
        return [{ geometry: geojson }];
    }
  }
  function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {
    const separated = {
      pointFeatures: [],
      lineFeatures: [],
      polygonFeatures: [],
      polygonOutlineFeatures: []
    };
    const { startRow = 0, endRow = features.length } = dataRange;
    for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {
      const feature = features[featureIndex];
      const { geometry } = feature;
      if (!geometry) {
        continue;
      }
      if (geometry.type === "GeometryCollection") {
        log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
        const { geometries } = geometry;
        for (let i5 = 0; i5 < geometries.length; i5++) {
          const subGeometry = geometries[i5];
          separateGeometry(
            subGeometry,
            separated,
            wrapFeature,
            feature,
            featureIndex
          );
        }
      } else {
        separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
      }
    }
    return separated;
  }
  function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
    const { type, coordinates } = geometry;
    const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = separated;
    if (!validateGeometry(type, coordinates)) {
      log_default.warn(`${type} coordinates are malformed`)();
      return;
    }
    switch (type) {
      case "Point":
        pointFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        break;
      case "MultiPoint":
        coordinates.forEach((point) => {
          pointFeatures.push(
            wrapFeature(
              {
                geometry: { type: "Point", coordinates: point }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "LineString":
        lineFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        break;
      case "MultiLineString":
        coordinates.forEach((path) => {
          lineFeatures.push(
            wrapFeature(
              {
                geometry: { type: "LineString", coordinates: path }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "Polygon":
        polygonFeatures.push(
          wrapFeature(
            {
              geometry
            },
            sourceFeature,
            sourceFeatureIndex
          )
        );
        coordinates.forEach((path) => {
          polygonOutlineFeatures.push(
            wrapFeature(
              {
                geometry: { type: "LineString", coordinates: path }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
        });
        break;
      case "MultiPolygon":
        coordinates.forEach((polygon) => {
          polygonFeatures.push(
            wrapFeature(
              {
                geometry: { type: "Polygon", coordinates: polygon }
              },
              sourceFeature,
              sourceFeatureIndex
            )
          );
          polygon.forEach((path) => {
            polygonOutlineFeatures.push(
              wrapFeature(
                {
                  geometry: { type: "LineString", coordinates: path }
                },
                sourceFeature,
                sourceFeatureIndex
              )
            );
          });
        });
        break;
      default:
    }
  }
  var COORDINATE_NEST_LEVEL = {
    Point: 1,
    MultiPoint: 2,
    LineString: 2,
    MultiLineString: 3,
    Polygon: 3,
    MultiPolygon: 4
  };
  function validateGeometry(type, coordinates) {
    let nestLevel = COORDINATE_NEST_LEVEL[type];
    log_default.assert(nestLevel, `Unknown GeoJSON type ${type}`);
    while (coordinates && --nestLevel > 0) {
      coordinates = coordinates[0];
    }
    return coordinates && Number.isFinite(coordinates[0]);
  }

  // ../layers/src/geojson-layer/geojson-layer-props.ts
  function createEmptyLayerProps() {
    return {
      points: {},
      lines: {},
      polygons: {},
      polygonsOutline: {}
    };
  }
  function getCoordinates(f4) {
    return f4.geometry.coordinates;
  }
  function createLayerPropsFromFeatures(features, featuresDiff) {
    const layerProps = createEmptyLayerProps();
    const { pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures } = features;
    layerProps.points.data = pointFeatures;
    layerProps.points._dataDiff = featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures);
    layerProps.points.getPosition = getCoordinates;
    layerProps.lines.data = lineFeatures;
    layerProps.lines._dataDiff = featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures);
    layerProps.lines.getPath = getCoordinates;
    layerProps.polygons.data = polygonFeatures;
    layerProps.polygons._dataDiff = featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures);
    layerProps.polygons.getPolygon = getCoordinates;
    layerProps.polygonsOutline.data = polygonOutlineFeatures;
    layerProps.polygonsOutline._dataDiff = featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures);
    layerProps.polygonsOutline.getPath = getCoordinates;
    return layerProps;
  }
  function createLayerPropsFromBinary(geojsonBinary, encodePickingColor) {
    const layerProps = createEmptyLayerProps();
    const { points, lines, polygons } = geojsonBinary;
    const customPickingColors = calculatePickingColors(geojsonBinary, encodePickingColor);
    layerProps.points.data = {
      length: points.positions.value.length / points.positions.size,
      attributes: {
        ...points.attributes,
        getPosition: points.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.points
        }
      },
      properties: points.properties,
      numericProps: points.numericProps,
      featureIds: points.featureIds
    };
    layerProps.lines.data = {
      length: lines.pathIndices.value.length - 1,
      startIndices: lines.pathIndices.value,
      attributes: {
        ...lines.attributes,
        getPath: lines.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.lines
        }
      },
      properties: lines.properties,
      numericProps: lines.numericProps,
      featureIds: lines.featureIds
    };
    layerProps.lines._pathType = "open";
    layerProps.polygons.data = {
      length: polygons.polygonIndices.value.length - 1,
      startIndices: polygons.polygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPolygon: polygons.positions,
        pickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygons._normalize = false;
    if (polygons.triangles) {
      layerProps.polygons.data.attributes.indices = polygons.triangles.value;
    }
    layerProps.polygonsOutline.data = {
      length: polygons.primitivePolygonIndices.value.length - 1,
      startIndices: polygons.primitivePolygonIndices.value,
      attributes: {
        ...polygons.attributes,
        getPath: polygons.positions,
        instancePickingColors: {
          size: 3,
          value: customPickingColors.polygons
        }
      },
      properties: polygons.properties,
      numericProps: polygons.numericProps,
      featureIds: polygons.featureIds
    };
    layerProps.polygonsOutline._pathType = "open";
    return layerProps;
  }

  // ../layers/src/geojson-layer/geojson-layer.ts
  var FEATURE_TYPES = ["points", "linestrings", "polygons"];
  var defaultProps17 = {
    ...getDefaultProps(POINT_LAYER.circle),
    ...getDefaultProps(POINT_LAYER.icon),
    ...getDefaultProps(POINT_LAYER.text),
    ...getDefaultProps(LINE_LAYER),
    ...getDefaultProps(POLYGON_LAYER),
    stroked: true,
    filled: true,
    extruded: false,
    wireframe: false,
    _full3d: false,
    iconAtlas: { type: "object", value: null },
    iconMapping: { type: "object", value: {} },
    getIcon: { type: "accessor", value: (f4) => f4.properties.icon },
    getText: { type: "accessor", value: (f4) => f4.properties.text },
    pointType: "circle",
    getRadius: { deprecatedFor: "getPointRadius" }
  };
  var GeoJsonLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        layerProps: {},
        features: {},
        featuresDiff: {}
      };
    }
    updateState({ props, changeFlags }) {
      if (!changeFlags.dataChanged) {
        return;
      }
      const { data } = this.props;
      const binary = data && "points" in data && "polygons" in data && "lines" in data;
      this.setState({ binary });
      if (binary) {
        this._updateStateBinary({ props, changeFlags });
      } else {
        this._updateStateJSON({ props, changeFlags });
      }
    }
    _updateStateBinary({ props, changeFlags }) {
      const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);
      this.setState({ layerProps });
    }
    _updateStateJSON({ props, changeFlags }) {
      const features = getGeojsonFeatures(props.data);
      const wrapFeature = this.getSubLayerRow.bind(this);
      let newFeatures = {};
      const featuresDiff = {};
      if (Array.isArray(changeFlags.dataChanged)) {
        const oldFeatures = this.state.features;
        for (const key in oldFeatures) {
          newFeatures[key] = oldFeatures[key].slice();
          featuresDiff[key] = [];
        }
        for (const dataRange of changeFlags.dataChanged) {
          const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
          for (const key in oldFeatures) {
            featuresDiff[key].push(
              replaceInRange({
                data: newFeatures[key],
                getIndex: (f4) => f4.__source.index,
                dataRange,
                replace: partialFeatures[key]
              })
            );
          }
        }
      } else {
        newFeatures = separateGeojsonFeatures(features, wrapFeature);
      }
      const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);
      this.setState({
        features: newFeatures,
        featuresDiff,
        layerProps
      });
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const { index: index2, sourceLayer } = info;
      info.featureType = FEATURE_TYPES.find((ft) => sourceLayer.id.startsWith(`${this.id}-${ft}-`));
      if (index2 >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {
        info.index = this.props.data.points.globalFeatureIds.value[index2];
      }
      return info;
    }
    _updateAutoHighlight(info) {
      const pointLayerIdPrefix = `${this.id}-points-`;
      const sourceIsPoints = info.featureType === "points";
      for (const layer of this.getSubLayers()) {
        if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    _renderPolygonLayer() {
      const { extruded, wireframe } = this.props;
      const { layerProps } = this.state;
      const id = "polygons-fill";
      const PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons?.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);
      if (PolygonFillLayer) {
        const forwardedProps = forwardProps(this, POLYGON_LAYER.props);
        const useLineColor = extruded && wireframe;
        if (!useLineColor) {
          delete forwardedProps.getLineColor;
        }
        forwardedProps.updateTriggers.lineColors = useLineColor;
        return new PolygonFillLayer(
          forwardedProps,
          this.getSubLayerProps({
            id,
            updateTriggers: forwardedProps.updateTriggers
          }),
          layerProps.polygons
        );
      }
      return null;
    }
    _renderLineLayers() {
      const { extruded, stroked } = this.props;
      const { layerProps } = this.state;
      const polygonStrokeLayerId = "polygons-stroke";
      const lineStringsLayerId = "linestrings";
      const PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline?.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);
      const LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines?.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);
      if (PolygonStrokeLayer || LineStringsLayer) {
        const forwardedProps = forwardProps(this, LINE_LAYER.props);
        return [
          PolygonStrokeLayer && new PolygonStrokeLayer(
            forwardedProps,
            this.getSubLayerProps({
              id: polygonStrokeLayerId,
              updateTriggers: forwardedProps.updateTriggers
            }),
            layerProps.polygonsOutline
          ),
          LineStringsLayer && new LineStringsLayer(
            forwardedProps,
            this.getSubLayerProps({
              id: lineStringsLayerId,
              updateTriggers: forwardedProps.updateTriggers
            }),
            layerProps.lines
          )
        ];
      }
      return null;
    }
    _renderPointLayers() {
      const { pointType } = this.props;
      const { layerProps, binary } = this.state;
      let { highlightedObjectIndex } = this.props;
      if (!binary && Number.isFinite(highlightedObjectIndex)) {
        highlightedObjectIndex = layerProps.points.data.findIndex(
          (d2) => d2.__source.index === highlightedObjectIndex
        );
      }
      const types = new Set(pointType.split("+"));
      const pointLayers = [];
      for (const type of types) {
        const id = `points-${type}`;
        const PointLayerMapping = POINT_LAYER[type];
        const PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points?.data) && this.getSubLayerClass(id, PointLayerMapping.type);
        if (PointsLayer) {
          const forwardedProps = forwardProps(this, PointLayerMapping.props);
          let pointsLayerProps = layerProps.points;
          if (type === "text" && binary) {
            const { instancePickingColors, ...rest } = pointsLayerProps.data.attributes;
            pointsLayerProps = {
              ...pointsLayerProps,
              data: { ...pointsLayerProps.data, attributes: rest }
            };
          }
          pointLayers.push(
            new PointsLayer(
              forwardedProps,
              this.getSubLayerProps({
                id,
                updateTriggers: forwardedProps.updateTriggers,
                highlightedObjectIndex
              }),
              pointsLayerProps
            )
          );
        }
      }
      return pointLayers;
    }
    renderLayers() {
      const { extruded } = this.props;
      const polygonFillLayer = this._renderPolygonLayer();
      const lineLayers = this._renderLineLayers();
      const pointLayers = this._renderPointLayers();
      return [
        !extruded && polygonFillLayer,
        lineLayers,
        pointLayers,
        extruded && polygonFillLayer
      ];
    }
    getSubLayerAccessor(accessor) {
      const { binary } = this.state;
      if (!binary || typeof accessor !== "function") {
        return super.getSubLayerAccessor(accessor);
      }
      return (object, info) => {
        const { data, index: index2 } = info;
        const feature = binaryToFeatureForAccesor(data, index2);
        return accessor(feature, info);
      };
    }
  };
  GeoJsonLayer.layerName = "GeoJsonLayer";
  GeoJsonLayer.defaultProps = defaultProps17;

  // ../../node_modules/@loaders.gl/xml/dist/lib/xml-utils/uncapitalize.js
  function uncapitalize(str5) {
    return typeof str5 === "string" ? str5.charAt(0).toLowerCase() + str5.slice(1) : str5;
  }
  function uncapitalizeKeys(object) {
    if (Array.isArray(object)) {
      return object.map((element) => uncapitalizeKeys(element));
    }
    if (object && typeof object === "object") {
      const newObject = {};
      for (const [key, value] of Object.entries(object)) {
        newObject[uncapitalize(key)] = uncapitalizeKeys(value);
      }
      return newObject;
    }
    return object;
  }

  // ../../node_modules/@loaders.gl/xml/dist/lib/parsers/parse-xml.js
  var import_fast_xml_parser = __toESM(require_fxp(), 1);
  function parseXMLSync(text, options) {
    if (options !== null && options !== void 0 && options._parser && options._parser !== "fast-xml-parser") {
      throw new Error(options === null || options === void 0 ? void 0 : options._parser);
    }
    const fastXMLOptions = {
      allowBooleanAttributes: true,
      ignoreDeclaration: true,
      removeNSPrefix: options === null || options === void 0 ? void 0 : options.removeNSPrefix,
      textNodeName: options === null || options === void 0 ? void 0 : options.textNodeName,
      isArray: (name13, jpath, isLeafNode, isAttribute) => {
        var _options$arrayPaths;
        const array = Boolean(options === null || options === void 0 ? void 0 : (_options$arrayPaths = options.arrayPaths) === null || _options$arrayPaths === void 0 ? void 0 : _options$arrayPaths.some((path) => jpath === path));
        return array;
      },
      ...options === null || options === void 0 ? void 0 : options._fastXML
    };
    const xml = fastParseXML(text, fastXMLOptions);
    return options !== null && options !== void 0 && options.uncapitalizeKeys ? uncapitalizeKeys(xml) : xml;
  }
  function fastParseXML(text, options) {
    const parser = new import_fast_xml_parser.XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: "",
      ...options
    });
    const parsedXML = parser.parse(text);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/xml/dist/xml-loader.js
  var VERSION6 = true ? "4.1.4" : "latest";
  var XMLLoader = {
    name: "XML",
    id: "xml",
    module: "xml",
    version: VERSION6,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/xml", "text/xml"],
    testText: testXMLFile,
    options: {
      xml: {
        _parser: "fast-xml-parser",
        uncapitalizeKeys: false,
        removeNSPrefix: false,
        textNodeName: "value",
        arrayPaths: []
      }
    },
    parse: async (arrayBuffer2, options) => parseXMLSync(new TextDecoder().decode(arrayBuffer2), {
      ...XMLLoader.options.xml,
      ...options === null || options === void 0 ? void 0 : options.xml
    }),
    parseTextSync: (text, options) => parseXMLSync(text, {
      ...XMLLoader.options.xml,
      ...options === null || options === void 0 ? void 0 : options.xml
    })
  };
  function testXMLFile(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-error.js
  function parseWMSError(text, options) {
    var _XMLLoader$parseTextS, _parsedXML$ServiceExc, _parsedXML$ogcServic;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    const serviceExceptionXML = (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ServiceExc = parsedXML.ServiceExceptionReport) === null || _parsedXML$ServiceExc === void 0 ? void 0 : _parsedXML$ServiceExc.ServiceException) || (parsedXML === null || parsedXML === void 0 ? void 0 : (_parsedXML$ogcServic = parsedXML["ogc:ServiceExceptionReport"]) === null || _parsedXML$ogcServic === void 0 ? void 0 : _parsedXML$ogcServic["ogc:ServiceException"]);
    const message2 = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
    return message2;
  }

  // ../../node_modules/@loaders.gl/wms/dist/wms-error-loader.js
  var VERSION7 = true ? "4.1.4" : "latest";
  var WMSErrorLoader = {
    id: "wms-error",
    name: "WMS Error",
    module: "wms",
    version: VERSION7,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
    testText: testXMLFile2,
    options: {
      wms: {
        throwOnError: false
      }
    },
    parse: async (arrayBuffer2, options) => parseTextSync(new TextDecoder().decode(arrayBuffer2), options),
    parseSync: (arrayBuffer2, options) => parseTextSync(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseTextSync(text, options)
  };
  function testXMLFile2(text) {
    return text.startsWith("<?xml");
  }
  function parseTextSync(text, options) {
    const wmsOptions = {
      ...WMSErrorLoader.options.wms,
      ...options === null || options === void 0 ? void 0 : options.wms
    };
    const error = parseWMSError(text, wmsOptions);
    const message2 = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
    if (wmsOptions.throwOnError) {
      throw new Error(message2);
    }
    return message2;
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/xml/parse-xml-helpers.js
  function getXMLArray(xmlValue) {
    if (Array.isArray(xmlValue)) {
      return xmlValue;
    }
    if (xmlValue) {
      return [xmlValue];
    }
    return [];
  }
  function getXMLStringArray(xmlValue) {
    const xmlArray = getXMLArray(xmlValue);
    if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
      return xmlArray;
    }
    return [];
  }
  function getXMLFloat(xmlValue) {
    let defaultValue2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseFloat(xmlValue);
      default:
        return void 0;
    }
  }
  function getXMLInteger(xmlValue) {
    let defaultValue2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    switch (typeof xmlValue) {
      case "number":
        return xmlValue;
      case "string":
        return parseInt(xmlValue, 10);
      default:
        return void 0;
    }
  }
  function getXMLBoolean(xmlValue) {
    switch (xmlValue) {
      case "true":
        return true;
      case "false":
        return false;
      case "1":
        return true;
      case "0":
        return false;
      default:
        return false;
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js
  function parseWMSCapabilities(xmlText, options) {
    var _XMLLoader$parseTextS;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, xmlText, options);
    const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
    const capabilities = extractCapabilities(xmlCapabilities);
    if (options !== null && options !== void 0 && options.inheritedLayerProps) {
      for (const layer of capabilities.layers) {
        addInheritedLayerProps(layer, null);
      }
    }
    if (options !== null && options !== void 0 && options.includeRawJSON) {
      capabilities.json = xmlCapabilities;
    }
    if (options !== null && options !== void 0 && options.includeXMLText) {
      capabilities.xml = xmlText;
    }
    return capabilities;
  }
  function extractCapabilities(xml) {
    var _xml$Service, _xml$Service2, _xml$Service3, _xml$Service4, _xml$Service5, _xml$Service6, _xml$Service6$Keyword, _xml$Service7, _xml$Service8, _xml$Service9, _xml$Service10, _xml$Service11, _xml$Service12, _xml$Service13, _xml$Capability, _xml$Capability2;
    const capabilities = {
      version: String(xml.version || ""),
      name: String(((_xml$Service = xml.Service) === null || _xml$Service === void 0 ? void 0 : _xml$Service.Name) || "unnamed"),
      title: (_xml$Service2 = xml.Service) !== null && _xml$Service2 !== void 0 && _xml$Service2.Title ? String((_xml$Service3 = xml.Service) === null || _xml$Service3 === void 0 ? void 0 : _xml$Service3.Title) : void 0,
      abstract: (_xml$Service4 = xml.Service) !== null && _xml$Service4 !== void 0 && _xml$Service4.Abstract ? String((_xml$Service5 = xml.Service) === null || _xml$Service5 === void 0 ? void 0 : _xml$Service5.Abstract) : void 0,
      keywords: getXMLStringArray((_xml$Service6 = xml.Service) === null || _xml$Service6 === void 0 ? void 0 : (_xml$Service6$Keyword = _xml$Service6.KeywordList) === null || _xml$Service6$Keyword === void 0 ? void 0 : _xml$Service6$Keyword.Keyword),
      fees: (_xml$Service7 = xml.Service) !== null && _xml$Service7 !== void 0 && _xml$Service7.Fees ? JSON.stringify((_xml$Service8 = xml.Service) === null || _xml$Service8 === void 0 ? void 0 : _xml$Service8.Fees) : void 0,
      accessConstraints: (_xml$Service9 = xml.Service) !== null && _xml$Service9 !== void 0 && _xml$Service9.AccessConstraints ? JSON.stringify((_xml$Service10 = xml.Service) === null || _xml$Service10 === void 0 ? void 0 : _xml$Service10.AccessConstraints) : void 0,
      layerLimit: getXMLInteger((_xml$Service11 = xml.Service) === null || _xml$Service11 === void 0 ? void 0 : _xml$Service11.LayerLimit),
      maxWidth: getXMLInteger((_xml$Service12 = xml.Service) === null || _xml$Service12 === void 0 ? void 0 : _xml$Service12.maxWidth),
      maxHeight: getXMLInteger((_xml$Service13 = xml.Service) === null || _xml$Service13 === void 0 ? void 0 : _xml$Service13.maxHeight),
      layers: [],
      requests: extractRequests((_xml$Capability = xml.Capability) === null || _xml$Capability === void 0 ? void 0 : _xml$Capability.Request),
      exceptions: extractExceptions(xml.Exception)
    };
    const xmlLayers = getXMLArray((_xml$Capability2 = xml.Capability) === null || _xml$Capability2 === void 0 ? void 0 : _xml$Capability2.Layer);
    for (const xmlSubLayer of xmlLayers) {
      capabilities.layers.push(extractLayer(xmlSubLayer));
    }
    for (const [key, value] of Object.entries(capabilities)) {
      if (value === void 0) {
        delete capabilities[key];
      }
    }
    return capabilities;
  }
  function extractRequests(xmlRequests) {
    const requests = {};
    for (const [name13, xmlRequest] of Object.entries(xmlRequests || {})) {
      const mimeTypes = getXMLStringArray(xmlRequest === null || xmlRequest === void 0 ? void 0 : xmlRequest.Format);
      requests[name13] = {
        mimeTypes
      };
    }
    return requests;
  }
  function extractExceptions(xmlException) {
    const xmlExceptionFormats = getXMLArray(xmlException === null || xmlException === void 0 ? void 0 : xmlException.Format);
    if (xmlExceptionFormats.length > 0) {
      return {
        mimeTypes: getXMLStringArray(xmlException)
      };
    }
    return void 0;
  }
  function extractLayer(xmlLayer) {
    var _xmlLayer$KeywordList;
    const layer = {
      title: String((xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Title) || ""),
      name: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name),
      abstract: (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Name) && String(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Abstract),
      keywords: getXMLStringArray((_xmlLayer$KeywordList = xmlLayer.KeywordList) === null || _xmlLayer$KeywordList === void 0 ? void 0 : _xmlLayer$KeywordList.Keyword)
    };
    const crs = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.CRS) || (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.SRS);
    if (crs && Array.isArray(crs) && crs.every((_) => typeof _ === "string")) {
      layer.crs = crs;
    }
    let geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.EX_GeographicBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    geographicBoundingBox = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.LatLonBoundingBox);
    if (geographicBoundingBox) {
      layer.geographicBoundingBox = geographicBoundingBox;
    }
    const boundingBoxes = (xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.BoundingBox);
    if (boundingBoxes && boundingBoxes.length > 0) {
      layer.boundingBoxes = boundingBoxes;
    }
    const xmlDimensions = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Dimension);
    const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
    if (dimensions.length) {
      layer.dimensions = dimensions;
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.opaque) {
      layer.opaque = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.opaque);
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.cascaded) {
      layer.cascaded = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.cascaded);
    }
    if (xmlLayer !== null && xmlLayer !== void 0 && xmlLayer.queryable) {
      layer.queryable = getXMLBoolean(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.queryable);
    }
    const xmlLayers = getXMLArray(xmlLayer === null || xmlLayer === void 0 ? void 0 : xmlLayer.Layer);
    const layers = [];
    for (const xmlSubLayer of xmlLayers) {
      layers.push(extractLayer(xmlSubLayer));
    }
    if (layers.length > 0) {
      layer.layers = layers;
    }
    for (const [key, value] of Object.entries(layer)) {
      if (value === void 0) {
        delete layer[key];
      }
    }
    return layer;
  }
  function extractEXBoundingBox(xmlBoundingBox) {
    const {
      westBoundLongitude: w2,
      northBoundLatitude: n3,
      eastBoundLongitude: e3,
      southBoundLatitude: s3
    } = xmlBoundingBox;
    return [[w2, s3], [e3, n3]];
  }
  function extractLatLonBoundingBox(xmlBoundingBox) {
    const {
      minx,
      miny,
      maxx,
      maxy
    } = xmlBoundingBox;
    return [[minx, miny], [maxx, maxy]];
  }
  function extractWMSBoundingBoxes(xmlBoundingBoxes) {
    const xmlBoxes = getXMLArray(xmlBoundingBoxes);
    return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
  }
  function extractWMSBoundingBox(xmlBoundingBox) {
    const {
      CRS,
      SRS,
      minx,
      miny,
      maxx,
      maxy,
      resx,
      resy
    } = xmlBoundingBox;
    const boundingBox = {
      crs: CRS || SRS,
      boundingBox: [[getXMLFloat(minx), getXMLFloat(miny)], [getXMLFloat(maxx), getXMLFloat(maxy)]]
    };
    if (resx) {
      boundingBox.xResolution = resx;
    }
    if (resy) {
      boundingBox.yResolution = resy;
    }
    return boundingBox;
  }
  function extractDimension(xmlDimension) {
    const {
      name: name13,
      units,
      value: extent
    } = xmlDimension;
    const dimension = {
      name: name13,
      units,
      extent
    };
    if (xmlDimension.unitSymbol) {
      dimension.unitSymbol = xmlDimension.unitSymbol;
    }
    if (xmlDimension.default) {
      dimension.defaultValue = xmlDimension.default;
    }
    if (xmlDimension.multipleValues) {
      dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
    }
    if (xmlDimension.nearestValue) {
      dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
    }
    if (xmlDimension.current) {
      dimension.current = getXMLBoolean(xmlDimension.current);
    }
    return dimension;
  }
  function addInheritedLayerProps(layer, parent) {
    if (parent !== null && parent !== void 0 && parent.geographicBoundingBox && !layer.geographicBoundingBox) {
      layer.geographicBoundingBox = [...parent.geographicBoundingBox];
    }
    if (parent !== null && parent !== void 0 && parent.crs && !layer.crs) {
      layer.crs = [...parent.crs];
    }
    if (parent !== null && parent !== void 0 && parent.boundingBoxes && !layer.boundingBoxes) {
      layer.boundingBoxes = [...parent.boundingBoxes];
    }
    if (parent !== null && parent !== void 0 && parent.dimensions && !layer.dimensions) {
      layer.dimensions = [...parent.dimensions];
    }
    for (const subLayer of layer.layers || []) {
      addInheritedLayerProps(subLayer, layer);
    }
  }

  // ../../node_modules/@loaders.gl/wms/dist/wms-capabilities-loader.js
  var VERSION8 = true ? "4.1.4" : "latest";
  var WMSCapabilitiesLoader = {
    id: "wms-capabilities",
    name: "WMS Capabilities",
    module: "wms",
    version: VERSION8,
    worker: false,
    extensions: ["xml"],
    mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
    testText: testXMLFile3,
    options: {
      wms: {}
    },
    parse: async (arrayBuffer2, options) => parseWMSCapabilities(new TextDecoder().decode(arrayBuffer2), options === null || options === void 0 ? void 0 : options.wms),
    parseTextSync: (text, options) => parseWMSCapabilities(text, options === null || options === void 0 ? void 0 : options.wms)
  };
  function testXMLFile3(text) {
    return text.startsWith("<?xml");
  }

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-features.js
  function parseWMSFeatureInfo(text, options) {
    var _XMLLoader$parseTextS, _parsedXML$FeatureInf;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    const xmlFeatureInfo = ((_parsedXML$FeatureInf = parsedXML.FeatureInfoResponse) === null || _parsedXML$FeatureInf === void 0 ? void 0 : _parsedXML$FeatureInf.FIELDS) || [];
    const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
    return {
      features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
    };
  }
  function extractFeature(xmlFeature) {
    const xmlFields = xmlFeature || {};
    return {
      attributes: xmlFields,
      type: "",
      bounds: {
        bottom: 0,
        top: 0,
        left: 0,
        right: 0
      }
    };
  }

  // ../../node_modules/@loaders.gl/wms/dist/wip/wms-feature-info-loader.js
  var WMSFeatureInfoLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-feature-info",
    name: "WMS FeatureInfo",
    parse: async (arrayBuffer2, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-layer-description.js
  function parseWMSLayerDescription(text, options) {
    var _XMLLoader$parseTextS;
    const parsedXML = (_XMLLoader$parseTextS = XMLLoader.parseTextSync) === null || _XMLLoader$parseTextS === void 0 ? void 0 : _XMLLoader$parseTextS.call(XMLLoader, text, options);
    return parsedXML;
  }

  // ../../node_modules/@loaders.gl/wms/dist/wip/wms-layer-description-loader.js
  var WMSLayerDescriptionLoader = {
    ...WMSCapabilitiesLoader,
    id: "wms-layer-description",
    name: "WMS DescribeLayer",
    parse: async (arrayBuffer2, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer2), options),
    parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/services/create-image-service.js
  function createImageService(props, services) {
    const {
      type = "auto"
    } = props;
    const service = type === "auto" ? guessServiceType(props.url, services) : getServiceOfType(type, services);
    if (!service) {
      throw new Error("Not a valid image source type");
    }
    return service.create(props);
  }
  function getServiceOfType(type, services) {
    for (const service of services) {
      if (service.type === type) {
        return service;
      }
    }
    return null;
  }
  function guessServiceType(url, services) {
    for (const service of services) {
      if (service.testURL && service.testURL(url)) {
        return service;
      }
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/wms/dist/services/ogc/wms-service.js
  var WMSService = {
    type: "wms",
    testURL: (url) => url.toLowerCase().includes("wms"),
    create: (props) => new WMSSource(props)
  };
  var WMSSource = class extends ImageSource {
    constructor(props) {
      var _props$substituteCRS;
      super(props);
      this.url = void 0;
      this.data = void 0;
      this.substituteCRS84 = void 0;
      this.flipCRS = void 0;
      this.wmsParameters = void 0;
      this.vendorParameters = void 0;
      this.capabilities = null;
      this.url = props.url;
      this.data = props.url;
      this.substituteCRS84 = (_props$substituteCRS = props.substituteCRS84) !== null && _props$substituteCRS !== void 0 ? _props$substituteCRS : false;
      this.flipCRS = ["EPSG:4326"];
      this.wmsParameters = {
        layers: void 0,
        query_layers: void 0,
        styles: void 0,
        version: "1.3.0",
        crs: "EPSG:4326",
        format: "image/png",
        info_format: "text/plain",
        transparent: void 0,
        time: void 0,
        elevation: void 0,
        ...props.wmsParameters
      };
      this.vendorParameters = props.vendorParameters || {};
    }
    async getMetadata() {
      const capabilities = await this.getCapabilities();
      return this.normalizeMetadata(capabilities);
    }
    async getImage(parameters2) {
      const {
        boundingBox,
        bbox,
        ...rest
      } = parameters2;
      const wmsParameters = {
        bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
        ...rest
      };
      return await this.getMap(wmsParameters);
    }
    normalizeMetadata(capabilities) {
      return capabilities;
    }
    async getCapabilities(wmsParameters, vendorParameters) {
      const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer2, this.loadOptions);
      this.capabilities = capabilities;
      return capabilities;
    }
    async getMap(wmsParameters, vendorParameters) {
      const url = this.getMapURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    async getFeatureInfo(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSFeatureInfoLoader.parse(arrayBuffer2, this.loadOptions);
    }
    async getFeatureInfoText(wmsParameters, vendorParameters) {
      const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return new TextDecoder().decode(arrayBuffer2);
    }
    async describeLayer(wmsParameters, vendorParameters) {
      const url = this.describeLayerURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return await WMSLayerDescriptionLoader.parse(arrayBuffer2, this.loadOptions);
    }
    async getLegendGraphic(wmsParameters, vendorParameters) {
      const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      try {
        return await ImageLoader.parse(arrayBuffer2, this.loadOptions);
      } catch {
        throw this._parseError(arrayBuffer2);
      }
    }
    getCapabilitiesURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("GetCapabilities", options, vendorParameters);
    }
    getMapURL(wmsParameters, vendorParameters) {
      wmsParameters = this._getWMS130Parameters(wmsParameters);
      const options = {
        version: this.wmsParameters.version,
        format: this.wmsParameters.format,
        transparent: this.wmsParameters.transparent,
        time: this.wmsParameters.time,
        elevation: this.wmsParameters.elevation,
        layers: this.wmsParameters.layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        ...wmsParameters
      };
      return this._getWMSUrl("GetMap", options, vendorParameters);
    }
    getFeatureInfoURL(wmsParameters, vendorParameters) {
      wmsParameters = this._getWMS130Parameters(wmsParameters);
      const options = {
        version: this.wmsParameters.version,
        info_format: this.wmsParameters.info_format,
        layers: this.wmsParameters.layers,
        query_layers: this.wmsParameters.query_layers,
        styles: this.wmsParameters.styles,
        crs: this.wmsParameters.crs,
        ...wmsParameters
      };
      return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
    }
    describeLayerURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("DescribeLayer", options, vendorParameters);
    }
    getLegendGraphicURL(wmsParameters, vendorParameters) {
      const options = {
        version: this.wmsParameters.version,
        ...wmsParameters
      };
      return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
    }
    _parseWMSUrl(url) {
      const [baseUrl, search] = url.split("?");
      const searchParams = search.split("&");
      const parameters2 = {};
      for (const parameter of searchParams) {
        const [key, value] = parameter.split("=");
        parameters2[key] = value;
      }
      return {
        url: baseUrl,
        parameters: parameters2
      };
    }
    _getWMSUrl(request, wmsParameters, vendorParameters) {
      let url = this.url;
      let first = true;
      const allParameters = {
        service: "WMS",
        version: wmsParameters.version,
        request,
        ...wmsParameters,
        ...this.vendorParameters,
        ...vendorParameters
      };
      const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
      for (const [key, value] of Object.entries(allParameters)) {
        if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
          url += first ? "?" : "&";
          first = false;
          url += this._getURLParameter(key, value, wmsParameters);
        }
      }
      return encodeURI(url);
    }
    _getWMS130Parameters(wmsParameters) {
      const newParameters = {
        ...wmsParameters
      };
      if (newParameters.srs) {
        newParameters.crs = newParameters.crs || newParameters.srs;
        delete newParameters.srs;
      }
      return newParameters;
    }
    _getURLParameter(key, value, wmsParameters) {
      switch (key) {
        case "crs":
          if (wmsParameters.version !== "1.3.0") {
            key = "srs";
          } else if (this.substituteCRS84 && value === "EPSG:4326") {
            value = "CRS:84";
          }
          break;
        case "srs":
          if (wmsParameters.version === "1.3.0") {
            key = "crs";
          }
          break;
        case "bbox":
          const bbox = this._flipBoundingBox(value, wmsParameters);
          if (bbox) {
            value = bbox;
          }
          break;
        default:
      }
      key = key.toUpperCase();
      return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
    }
    _flipBoundingBox(bboxValue, wmsParameters) {
      if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
        return null;
      }
      const flipCoordinates = wmsParameters.version === "1.3.0" && this.flipCRS.includes(wmsParameters.crs || "") && !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326");
      const bbox = bboxValue;
      return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
    }
    async _fetchArrayBuffer(url) {
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      this._checkResponse(response, arrayBuffer2);
      return arrayBuffer2;
    }
    _checkResponse(response, arrayBuffer2) {
      const contentType = response.headers["content-type"];
      if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
        var _WMSErrorLoader$parse;
        const loadOptions = mergeLoaderOptions(this.loadOptions, {
          wms: {
            throwOnError: true
          }
        });
        const error = (_WMSErrorLoader$parse = WMSErrorLoader.parseSync) === null || _WMSErrorLoader$parse === void 0 ? void 0 : _WMSErrorLoader$parse.call(WMSErrorLoader, arrayBuffer2, loadOptions);
        throw new Error(error);
      }
    }
    _parseError(arrayBuffer2) {
      var _WMSErrorLoader$parse2;
      const error = (_WMSErrorLoader$parse2 = WMSErrorLoader.parseSync) === null || _WMSErrorLoader$parse2 === void 0 ? void 0 : _WMSErrorLoader$parse2.call(WMSErrorLoader, arrayBuffer2, this.loadOptions);
      return new Error(error);
    }
  };

  // ../../node_modules/@loaders.gl/wms/dist/lib/services/image-service.js
  var ImageService = class extends ImageSource {
    constructor(props) {
      super(props);
    }
    async getMetadata() {
      throw new Error("ImageSource.getMetadata not implemented");
    }
    async getImage(parameters2) {
      const granularParameters = this.getGranularParameters(parameters2);
      const url = this.getURLFromTemplate(granularParameters);
      const response = await this.fetch(url);
      const arrayBuffer2 = await response.arrayBuffer();
      return await ImageLoader.parse(arrayBuffer2);
    }
    getGranularParameters(parameters2) {
      const [[east, north], [west, south]] = parameters2.boundingBox;
      return {
        ...parameters2,
        east,
        north,
        south,
        west
      };
    }
    getURLFromTemplate(parameters2) {
      let url = this.props.url;
      for (const [key, value] of Object.entries(parameters2)) {
        url = url.replace(`\${${key}}`, String(value));
        url = url.replace(`{${key}}`, String(value));
      }
      return url;
    }
  };
  ImageService.type = "template";
  ImageService.testURL = (url) => url.toLowerCase().includes("{");

  // ../../node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-service.js
  var ArcGISImageSource = class extends ImageService {
    constructor(props) {
      super(props);
      this.data = void 0;
      this.data = props.url;
    }
    async getMetadata() {
      return await this.metadata();
    }
    async getImage(parameters2) {
      throw new Error("not implemented");
    }
    async metadata() {
      throw new Error("not implemented");
    }
    exportImage(options) {
      throw new Error("not implemented");
    }
    metadataURL(options) {
      return `${this.props.url}?f=pjson`;
    }
    exportImageURL(options) {
      const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
      const size = `size=${options.width},${options.height}`;
      const arcgisOptions = {
        ...options,
        bbox,
        size
      };
      delete arcgisOptions.width;
      delete arcgisOptions.height;
      return this.getUrl("exportImage", arcgisOptions);
    }
    getUrl(path, options, extra) {
      let url = `${this.props.url}/${path}`;
      let first = true;
      for (const [key, value] of Object.entries(options)) {
        url += first ? "?" : "&";
        first = false;
        if (Array.isArray(value)) {
          url += `${key.toUpperCase()}=${value.join(",")}`;
        } else {
          url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
        }
      }
      return url;
    }
    async checkResponse(response) {
      if (!response.ok) {
        throw new Error("error");
      }
    }
  };
  var ArcGISImageService = {
    type: "arcgis-image-server",
    testURL: (url) => url.toLowerCase().includes("ImageServer"),
    create: (props) => new ArcGISImageSource(props)
  };

  // ../../node_modules/@loaders.gl/wms/dist/services/create-image-source.js
  var SERVICES = [WMSService, ArcGISImageService];
  function createImageSource(props) {
    return createImageService(props, SERVICES);
  }

  // ../geo-layers/src/wms-layer/utils.ts
  var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
  function WGS84ToPseudoMercator(coord) {
    const mercator = lngLatToWorld(coord);
    mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
    return mercator;
  }

  // ../geo-layers/src/wms-layer/wms-layer.ts
  var defaultProps18 = {
    id: "imagery-layer",
    data: "",
    serviceType: "auto",
    srs: "auto",
    layers: { type: "array", compare: true, value: [] },
    onMetadataLoad: { type: "function", value: () => {
    } },
    onMetadataLoadError: { type: "function", value: console.error },
    onImageLoadStart: { type: "function", value: () => {
    } },
    onImageLoad: { type: "function", value: () => {
    } },
    onImageLoadError: {
      type: "function",
      compare: false,
      value: (requestId, error) => console.error(error, requestId)
    }
  };
  var WMSLayer = class extends CompositeLayer {
    get isLoaded() {
      return this.state?.loadCounter === 0 && super.isLoaded;
    }
    shouldUpdateState() {
      return true;
    }
    initializeState() {
      this.state._nextRequestId = 0;
      this.state.lastRequestId = -1;
      this.state.loadCounter = 0;
    }
    updateState({ changeFlags, props, oldProps }) {
      const { viewport } = this.context;
      if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
        this.state.imageSource = this._createImageSource(props);
        this._loadMetadata();
        this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
      } else if (!deepEqual2(props.layers, oldProps.layers, 1)) {
        this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
      } else if (changeFlags.viewportChanged) {
        this.debounce(() => this.loadImage(viewport, "viewport changed"));
      }
    }
    finalizeState() {
    }
    renderLayers() {
      const { bounds, image, lastRequestParameters } = this.state;
      return image && new BitmapLayer({
        ...this.getSubLayerProps({ id: "bitmap" }),
        _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
        bounds,
        image
      });
    }
    async getFeatureInfoText(x3, y3) {
      const { lastRequestParameters } = this.state;
      if (lastRequestParameters) {
        const featureInfo = await this.state.imageSource.getFeatureInfoText?.({
          ...lastRequestParameters,
          query_layers: lastRequestParameters.layers,
          x: x3,
          y: y3,
          info_format: "application/vnd.ogc.gml"
        });
        return featureInfo;
      }
      return "";
    }
    _createImageSource(props) {
      if (props.data instanceof ImageSource) {
        return props.data;
      }
      if (typeof props.data === "string") {
        return createImageSource({
          url: props.data,
          loadOptions: props.loadOptions,
          type: props.serviceType
        });
      }
      throw new Error("invalid image source in props.data");
    }
    async _loadMetadata() {
      const { imageSource } = this.state;
      try {
        this.state.loadCounter++;
        const metadata = await imageSource.getMetadata();
        if (this.state.imageSource === imageSource) {
          this.getCurrentLayer()?.props.onMetadataLoad(metadata);
        }
      } catch (error) {
        this.getCurrentLayer()?.props.onMetadataLoadError(error);
      } finally {
        this.state.loadCounter--;
      }
    }
    async loadImage(viewport, reason) {
      const { layers, serviceType } = this.props;
      if (serviceType === "wms" && layers.length === 0) {
        return;
      }
      const bounds = viewport.getBounds();
      const { width, height } = viewport;
      const requestId = this.getRequestId();
      let { srs } = this.props;
      if (srs === "auto") {
        srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
      }
      const requestParams = {
        width,
        height,
        boundingBox: [
          [bounds[0], bounds[1]],
          [bounds[2], bounds[3]]
        ],
        layers,
        crs: srs
      };
      if (srs === "EPSG:3857") {
        const min4 = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
        const max4 = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
        requestParams.boundingBox = [min4, max4];
      }
      try {
        this.state.loadCounter++;
        this.props.onImageLoadStart(requestId);
        const image = await this.state.imageSource.getImage(requestParams);
        if (this.state.lastRequestId < requestId) {
          this.getCurrentLayer()?.props.onImageLoad(requestId);
          this.setState({
            image,
            bounds,
            lastRequestParameters: requestParams,
            lastRequestId: requestId
          });
        }
      } catch (error) {
        this.raiseError(error, "Load image");
        this.getCurrentLayer()?.props.onImageLoadError(requestId, error);
      } finally {
        this.state.loadCounter--;
      }
    }
    getRequestId() {
      return this.state._nextRequestId++;
    }
    debounce(fn, ms = 500) {
      clearTimeout(this.state._timeoutId);
      this.state._timeoutId = setTimeout(() => fn(), ms);
    }
  };
  WMSLayer.layerName = "WMSLayer";
  WMSLayer.defaultProps = defaultProps18;

  // ../geo-layers/src/great-circle-layer/great-circle-layer.ts
  var defaultProps19 = {
    getHeight: { type: "accessor", value: 0 },
    greatCircle: true
  };
  var GreatCircleLayer = class extends ArcLayer {
  };
  GreatCircleLayer.layerName = "GreatCircleLayer";
  GreatCircleLayer.defaultProps = defaultProps19;

  // ../geo-layers/src/geo-cell-layer/GeoCellLayer.ts
  var defaultProps20 = {
    ...PolygonLayer.defaultProps
  };
  var GeoCellLayer = class extends CompositeLayer {
    indexToBounds() {
      return null;
    }
    renderLayers() {
      const {
        elevationScale,
        extruded,
        wireframe,
        filled,
        stroked,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        lineJointRounded,
        lineMiterLimit,
        lineDashJustified,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth
      } = this.props;
      const { updateTriggers, material, transitions } = this.props;
      const CellLayer = this.getSubLayerClass("cell", PolygonLayer);
      const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
      return new CellLayer(
        {
          filled,
          wireframe,
          extruded,
          elevationScale,
          stroked,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,
          lineJointRounded,
          lineMiterLimit,
          lineDashJustified,
          material,
          transitions,
          getElevation,
          getFillColor,
          getLineColor,
          getLineWidth
        },
        this.getSubLayerProps({
          id: "cell",
          updateTriggers: updateTriggers && {
            ...boundsUpdateTriggers,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getLineWidth: updateTriggers.getLineWidth
          }
        }),
        boundsProps
      );
    }
  };
  GeoCellLayer.layerName = "GeoCellLayer";
  GeoCellLayer.defaultProps = defaultProps20;

  // ../geo-layers/src/s2-layer/s2-geometry.ts
  var import_long = __toESM(require_long(), 1);
  var FACE_BITS = 3;
  var MAX_LEVEL = 30;
  var POS_BITS = 2 * MAX_LEVEL + 1;
  var RADIAN_TO_DEGREE = 180 / Math.PI;
  function IJToST(ij, order, offsets) {
    const maxSize = 1 << order;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV(st) {
    return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
  }
  function FaceUVToXYZ(face, [u3, v2]) {
    switch (face) {
      case 0:
        return [1, u3, v2];
      case 1:
        return [-u3, 1, v2];
      case 2:
        return [-u3, -v2, 1];
      case 3:
        return [-1, -v2, -u3];
      case 4:
        return [v2, -1, -u3];
      case 5:
        return [v2, u3, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat([x3, y3, z2]) {
    const lat = Math.atan2(z2, Math.sqrt(x3 * x3 + y3 * y3));
    const lng = Math.atan2(y3, x3);
    return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
  }
  function toHilbertQuadkey(idS) {
    let bin = import_long.default.fromString(idS, true, 10).toString(2);
    while (bin.length < FACE_BITS + POS_BITS) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
    let posS = import_long.default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
    return `${faceS}/${posS}`;
  }
  function rotateAndFlipQuadrant(n3, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n3 - 1 - point[0];
        point[1] = n3 - 1 - point[1];
      }
      const x3 = point[0];
      point[0] = point[1];
      point[1] = x3;
    }
  }
  function FromHilbertQuadKey(hilbertQuadkey) {
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    const point = [0, 0];
    let level;
    for (let i5 = maxLevel - 1; i5 >= 0; i5--) {
      level = maxLevel - i5;
      const bit = position[i5];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t3 = point[0];
      point[0] = point[1];
      point[1] = t3;
    }
    return { face, ij: point, level };
  }

  // ../geo-layers/src/s2-layer/s2-utils.ts
  var import_long2 = __toESM(require_long(), 1);
  function getIdFromToken(token) {
    const paddedToken = token.padEnd(16, "0");
    return import_long2.default.fromString(paddedToken, 16);
  }
  var MAX_RESOLUTION = 100;
  function getGeoBounds({
    face,
    ij,
    level
  }) {
    const offsets = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0]
    ];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i5 = 0; i5 < 4; i5++) {
      const offset = offsets[i5].slice(0);
      const nextOffset = offsets[i5 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j2 = 0; j2 < resolution; j2++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST(ij, level, offset);
        const uv = STToUV(st);
        const xyz = FaceUVToXYZ(face, uv);
        const lngLat = XYZToLngLat(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }
  function getS2QuadKey(token) {
    if (typeof token === "string") {
      if (token.indexOf("/") > 0) {
        return token;
      }
      token = getIdFromToken(token);
    }
    return toHilbertQuadkey(token.toString());
  }
  function getS2Polygon(token) {
    const key = getS2QuadKey(token);
    const s2cell = FromHilbertQuadKey(key);
    return getGeoBounds(s2cell);
  }

  // ../geo-layers/src/s2-layer/s2-layer.ts
  var defaultProps21 = {
    getS2Token: { type: "accessor", value: (d2) => d2.token }
  };
  var S2Layer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, getS2Token } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getS2Polygon(getS2Token(x3, objectInfo))
      };
    }
  };
  S2Layer.layerName = "S2Layer";
  S2Layer.defaultProps = defaultProps21;

  // ../geo-layers/src/quadkey-layer/quadkey-utils.ts
  var TILE_SIZE3 = 512;
  function quadkeyToWorldBounds(quadkey, coverage) {
    let x3 = 0;
    let y3 = 0;
    let mask = 1 << quadkey.length;
    const scale7 = mask / TILE_SIZE3;
    for (let i5 = 0; i5 < quadkey.length; i5++) {
      mask >>= 1;
      const q2 = parseInt(quadkey[i5]);
      if (q2 % 2)
        x3 |= mask;
      if (q2 > 1)
        y3 |= mask;
    }
    return [
      [x3 / scale7, TILE_SIZE3 - y3 / scale7],
      [(x3 + coverage) / scale7, TILE_SIZE3 - (y3 + coverage) / scale7]
    ];
  }
  function getQuadkeyPolygon(quadkey, coverage = 1) {
    const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
    const [w2, n3] = worldToLngLat(topLeft);
    const [e3, s3] = worldToLngLat(bottomRight);
    return [e3, n3, e3, s3, w2, s3, w2, n3, e3, n3];
  }

  // ../geo-layers/src/quadkey-layer/quadkey-layer.ts
  var defaultProps22 = {
    getQuadkey: { type: "accessor", value: (d2) => d2.quadkey }
  };
  var QuadkeyLayer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, extruded, getQuadkey } = this.props;
      const coverage = extruded ? 0.99 : 1;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getQuadkeyPolygon(getQuadkey(x3, objectInfo), coverage),
        updateTriggers: { getPolygon: coverage }
      };
    }
  };
  QuadkeyLayer.layerName = "QuadkeyLayer";
  QuadkeyLayer.defaultProps = defaultProps22;

  // ../geo-layers/src/tileset-2d/tile-2d-header.ts
  var Tile2DHeader = class {
    constructor(index2) {
      this.index = index2;
      this.isVisible = false;
      this.isSelected = false;
      this.parent = null;
      this.children = [];
      this.content = null;
      this._loader = void 0;
      this._abortController = null;
      this._loaderId = 0;
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
    }
    get bbox() {
      return this._bbox;
    }
    set bbox(value) {
      if (this._bbox)
        return;
      this._bbox = value;
      if ("west" in value) {
        this.boundingBox = [
          [value.west, value.south],
          [value.east, value.north]
        ];
      } else {
        this.boundingBox = [
          [value.left, value.top],
          [value.right, value.bottom]
        ];
      }
    }
    get data() {
      return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
    }
    get isLoaded() {
      return this._isLoaded && !this._needsReload;
    }
    get isLoading() {
      return Boolean(this._loader) && !this._isCancelled;
    }
    get needsReload() {
      return this._needsReload || this._isCancelled;
    }
    get byteLength() {
      const result = this.content ? this.content.byteLength : 0;
      if (!Number.isFinite(result)) {
        console.error("byteLength not defined in tile data");
      }
      return result;
    }
    async _loadData({
      getData,
      requestScheduler,
      onLoad,
      onError
    }) {
      const { index: index2, id, bbox, userData, zoom } = this;
      const loaderId = this._loaderId;
      this._abortController = new AbortController();
      const { signal } = this._abortController;
      const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
        return tile.isSelected ? 1 : -1;
      });
      if (!requestToken) {
        this._isCancelled = true;
        return;
      }
      if (this._isCancelled) {
        requestToken.done();
        return;
      }
      let tileData = null;
      let error;
      try {
        tileData = await getData({ index: index2, id, bbox, userData, zoom, signal });
      } catch (err) {
        error = err || true;
      } finally {
        requestToken.done();
      }
      if (loaderId !== this._loaderId) {
        return;
      }
      this._loader = void 0;
      this.content = tileData;
      if (this._isCancelled && !tileData) {
        this._isLoaded = false;
        return;
      }
      this._isLoaded = true;
      this._isCancelled = false;
      if (error) {
        onError(error, this);
      } else {
        onLoad(this);
      }
    }
    loadData(opts) {
      this._isLoaded = false;
      this._isCancelled = false;
      this._needsReload = false;
      this._loaderId++;
      this._loader = this._loadData(opts);
      return this._loader;
    }
    setNeedsReload() {
      if (this.isLoading) {
        this.abort();
        this._loader = void 0;
      }
      this._needsReload = true;
    }
    abort() {
      if (this.isLoaded) {
        return;
      }
      this._isCancelled = true;
      this._abortController?.abort();
    }
  };

  // ../../node_modules/@math.gl/culling/dist/constants.js
  var INTERSECTION = {
    OUTSIDE: -1,
    INTERSECTING: 0,
    INSIDE: 1
  };

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
  var scratchVector2 = new Vector3();
  var scratchNormal = new Vector3();
  var AxisAlignedBoundingBox = class {
    constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {
      center = center || scratchVector2.copy(minimum).add(maximum).scale(0.5);
      this.center = new Vector3(center);
      this.halfDiagonal = new Vector3(maximum).subtract(this.center);
      this.minimum = new Vector3(minimum);
      this.maximum = new Vector3(maximum);
    }
    clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
    equals(right) {
      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
    transform(transform2) {
      this.center.transformAsPoint(transform2);
      this.halfDiagonal.transform(transform2);
      this.minimum.transform(transform2);
      this.maximum.transform(transform2);
      return this;
    }
    intersectPlane(plane) {
      const { halfDiagonal } = this;
      const normal = scratchNormal.from(plane.normal);
      const e3 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
      const s3 = this.center.dot(normal) + plane.distance;
      if (s3 - e3 > 0) {
        return INTERSECTION.INSIDE;
      }
      if (s3 + e3 < 0) {
        return INTERSECTION.OUTSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchVector2.from(point).subtract(this.center);
      const { halfDiagonal } = this;
      let distanceSquared = 0;
      let d2;
      d2 = Math.abs(offset.x) - halfDiagonal.x;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.y) - halfDiagonal.y;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.z) - halfDiagonal.z;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      return distanceSquared;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
  var scratchVector3 = new Vector3();
  var scratchVector22 = new Vector3();
  var BoundingSphere = class {
    constructor(center = [0, 0, 0], radius = 0) {
      this.radius = -0;
      this.center = new Vector3();
      this.fromCenterRadius(center, radius);
    }
    fromCenterRadius(center, radius) {
      this.center.from(center);
      this.radius = radius;
      return this;
    }
    fromCornerPoints(corner, oppositeCorner) {
      oppositeCorner = scratchVector3.from(oppositeCorner);
      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
      this.radius = this.center.distance(oppositeCorner);
      return this;
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
    }
    clone() {
      return new BoundingSphere(this.center, this.radius);
    }
    union(boundingSphere) {
      const leftCenter = this.center;
      const leftRadius = this.radius;
      const rightCenter = boundingSphere.center;
      const rightRadius = boundingSphere.radius;
      const toRightCenter = scratchVector3.copy(rightCenter).subtract(leftCenter);
      const centerSeparation = toRightCenter.magnitude();
      if (leftRadius >= centerSeparation + rightRadius) {
        return this.clone();
      }
      if (rightRadius >= centerSeparation + leftRadius) {
        return boundingSphere.clone();
      }
      const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
      scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
      this.center.copy(scratchVector22);
      this.radius = halfDistanceBetweenTangentPoints;
      return this;
    }
    expand(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const radius = scratchPoint2.subtract(this.center).magnitude();
      if (radius > this.radius) {
        this.radius = radius;
      }
      return this;
    }
    transform(transform2) {
      this.center.transform(transform2);
      const scale7 = mat4_exports.getScaling(scratchVector3, transform2);
      this.radius = Math.max(scale7[0], Math.max(scale7[1], scale7[2])) * this.radius;
      return this;
    }
    distanceSquaredTo(point) {
      const d2 = this.distanceTo(point);
      return d2 * d2;
    }
    distanceTo(point) {
      const scratchPoint2 = scratchVector3.from(point);
      const delta = scratchPoint2.subtract(this.center);
      return Math.max(0, delta.len() - this.radius);
    }
    intersectPlane(plane) {
      const center = this.center;
      const radius = this.radius;
      const normal = plane.normal;
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane < -radius) {
        return INTERSECTION.OUTSIDE;
      }
      if (distanceToPlane < radius) {
        return INTERSECTION.INTERSECTING;
      }
      return INTERSECTION.INSIDE;
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
  var scratchVector32 = new Vector3();
  var scratchOffset = new Vector3();
  var scratchVectorU = new Vector3();
  var scratchVectorV = new Vector3();
  var scratchVectorW = new Vector3();
  var scratchCorner = new Vector3();
  var scratchToCenter = new Vector3();
  var MATRIX3 = {
    COLUMN0ROW0: 0,
    COLUMN0ROW1: 1,
    COLUMN0ROW2: 2,
    COLUMN1ROW0: 3,
    COLUMN1ROW1: 4,
    COLUMN1ROW2: 5,
    COLUMN2ROW0: 6,
    COLUMN2ROW1: 7,
    COLUMN2ROW2: 8
  };
  var OrientedBoundingBox = class {
    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.center = new Vector3().from(center);
      this.halfAxes = new Matrix3(halfAxes);
    }
    get halfSize() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
    }
    get quaternion() {
      const xAxis = this.halfAxes.getColumn(0);
      const yAxis = this.halfAxes.getColumn(1);
      const zAxis = this.halfAxes.getColumn(2);
      const normXAxis = new Vector3(xAxis).normalize();
      const normYAxis = new Vector3(yAxis).normalize();
      const normZAxis = new Vector3(zAxis).normalize();
      return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
    }
    fromCenterHalfSizeQuaternion(center, halfSize, quaternion2) {
      const quaternionObject = new Quaternion(quaternion2);
      const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
      this.center = new Vector3().from(center);
      this.halfAxes = directionsMatrix;
      return this;
    }
    clone() {
      return new OrientedBoundingBox(this.center, this.halfAxes);
    }
    equals(right) {
      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
    }
    getBoundingSphere(result = new BoundingSphere()) {
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const cornerVector = scratchVector32.copy(u3).add(v2).add(w2);
      result.center.copy(this.center);
      result.radius = cornerVector.magnitude();
      return result;
    }
    intersectPlane(plane) {
      const center = this.center;
      const normal = plane.normal;
      const halfAxes = this.halfAxes;
      const normalX = normal.x;
      const normalY = normal.y;
      const normalZ = normal.z;
      const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
      const distanceToPlane = normal.dot(center) + plane.distance;
      if (distanceToPlane <= -radEffective) {
        return INTERSECTION.OUTSIDE;
      } else if (distanceToPlane >= radEffective) {
        return INTERSECTION.INSIDE;
      }
      return INTERSECTION.INTERSECTING;
    }
    distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
    distanceSquaredTo(point) {
      const offset = scratchOffset.from(point).subtract(this.center);
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const uHalf = u3.magnitude();
      const vHalf = v2.magnitude();
      const wHalf = w2.magnitude();
      u3.normalize();
      v2.normalize();
      w2.normalize();
      let distanceSquared = 0;
      let d2;
      d2 = Math.abs(offset.dot(u3)) - uHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(v2)) - vHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      d2 = Math.abs(offset.dot(w2)) - wHalf;
      if (d2 > 0) {
        distanceSquared += d2 * d2;
      }
      return distanceSquared;
    }
    computePlaneDistances(position, direction, result = [-0, -0]) {
      let minDist = Number.POSITIVE_INFINITY;
      let maxDist = Number.NEGATIVE_INFINITY;
      const center = this.center;
      const halfAxes = this.halfAxes;
      const u3 = halfAxes.getColumn(0, scratchVectorU);
      const v2 = halfAxes.getColumn(1, scratchVectorV);
      const w2 = halfAxes.getColumn(2, scratchVectorW);
      const corner = scratchCorner.copy(u3).add(v2).add(w2).add(center);
      const toCenter = scratchToCenter.copy(corner).subtract(position);
      let mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      corner.copy(center).add(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).add(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).add(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      center.copy(corner).subtract(u3).subtract(v2).subtract(w2);
      toCenter.copy(corner).subtract(position);
      mag = direction.dot(toCenter);
      minDist = Math.min(mag, minDist);
      maxDist = Math.max(mag, maxDist);
      result[0] = minDist;
      result[1] = maxDist;
      return result;
    }
    transform(transformation) {
      this.center.transformAsPoint(transformation);
      const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
      xAxis.transformAsPoint(transformation);
      const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
      yAxis.transformAsPoint(transformation);
      const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
      zAxis.transformAsPoint(transformation);
      this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
      return this;
    }
    getTransform() {
      throw new Error("not implemented");
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/plane.js
  var scratchPosition = new Vector3();
  var scratchNormal2 = new Vector3();
  var Plane = class {
    constructor(normal = [0, 0, 1], distance5 = 0) {
      this.normal = new Vector3();
      this.distance = -0;
      this.fromNormalDistance(normal, distance5);
    }
    fromNormalDistance(normal, distance5) {
      assert7(Number.isFinite(distance5));
      this.normal.from(normal).normalize();
      this.distance = distance5;
      return this;
    }
    fromPointNormal(point, normal) {
      point = scratchPosition.from(point);
      this.normal.from(normal).normalize();
      const distance5 = -this.normal.dot(point);
      this.distance = distance5;
      return this;
    }
    fromCoefficients(a3, b2, c2, d2) {
      this.normal.set(a3, b2, c2);
      assert7(equals(this.normal.len(), 1));
      this.distance = d2;
      return this;
    }
    clone() {
      return new Plane(this.normal, this.distance);
    }
    equals(right) {
      return equals(this.distance, right.distance) && equals(this.normal, right.normal);
    }
    getPointDistance(point) {
      return this.normal.dot(point) + this.distance;
    }
    transform(matrix4) {
      const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
      const point = this.normal.scale(-this.distance).transform(matrix4);
      return this.fromPointNormal(point, normal);
    }
    projectPointOntoPlane(point, result = [0, 0, 0]) {
      const scratchPoint2 = scratchPosition.from(point);
      const pointDistance = this.getPointDistance(scratchPoint2);
      const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
      return scratchPoint2.subtract(scaledNormal).to(result);
    }
  };

  // ../../node_modules/@math.gl/culling/dist/lib/culling-volume.js
  var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
  var scratchPlaneCenter = new Vector3();
  var scratchPlaneNormal = new Vector3();
  var CullingVolume = class {
    constructor(planes = []) {
      this.planes = planes;
    }
    fromBoundingSphere(boundingSphere) {
      this.planes.length = 2 * faces.length;
      const center = boundingSphere.center;
      const radius = boundingSphere.radius;
      let planeIndex = 0;
      for (const faceNormal of faces) {
        let plane0 = this.planes[planeIndex];
        let plane1 = this.planes[planeIndex + 1];
        if (!plane0) {
          plane0 = this.planes[planeIndex] = new Plane();
        }
        if (!plane1) {
          plane1 = this.planes[planeIndex + 1] = new Plane();
        }
        const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);
        plane0.fromPointNormal(plane0Center, faceNormal);
        const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);
        const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
        plane1.fromPointNormal(plane1Center, negatedFaceNormal);
        planeIndex += 2;
      }
      return this;
    }
    computeVisibility(boundingVolume) {
      let intersect3 = INTERSECTION.INSIDE;
      for (const plane of this.planes) {
        const result = boundingVolume.intersectPlane(plane);
        switch (result) {
          case INTERSECTION.OUTSIDE:
            return INTERSECTION.OUTSIDE;
          case INTERSECTION.INTERSECTING:
            intersect3 = INTERSECTION.INTERSECTING;
            break;
          default:
        }
      }
      return intersect3;
    }
    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
      assert7(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {
        return parentPlaneMask;
      }
      let mask = CullingVolume.MASK_INSIDE;
      const planes = this.planes;
      for (let k2 = 0; k2 < this.planes.length; ++k2) {
        const flag = k2 < 31 ? 1 << k2 : 0;
        if (k2 < 31 && (parentPlaneMask & flag) === 0) {
          continue;
        }
        const plane = planes[k2];
        const result = boundingVolume.intersectPlane(plane);
        if (result === INTERSECTION.OUTSIDE) {
          return CullingVolume.MASK_OUTSIDE;
        } else if (result === INTERSECTION.INTERSECTING) {
          mask |= flag;
        }
      }
      return mask;
    }
  };
  CullingVolume.MASK_OUTSIDE = 4294967295;
  CullingVolume.MASK_INSIDE = 0;
  CullingVolume.MASK_INDETERMINATE = 2147483647;

  // ../../node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
  var scratchPlaneUpVector = new Vector3();
  var scratchPlaneRightVector = new Vector3();
  var scratchPlaneNearCenter = new Vector3();
  var scratchPlaneFarCenter = new Vector3();
  var scratchPlaneNormal2 = new Vector3();

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
  var fromPointsXMin = new Vector3();
  var fromPointsYMin = new Vector3();
  var fromPointsZMin = new Vector3();
  var fromPointsXMax = new Vector3();
  var fromPointsYMax = new Vector3();
  var fromPointsZMax = new Vector3();
  var fromPointsCurrentPos = new Vector3();
  var fromPointsScratch = new Vector3();
  var fromPointsRitterCenter = new Vector3();
  var fromPointsMinBoxPt = new Vector3();
  var fromPointsMaxBoxPt = new Vector3();
  var fromPointsNaiveCenterScratch = new Vector3();

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
  var scratchMatrix = new Matrix3();
  var scratchUnitary = new Matrix3();
  var scratchDiagonal = new Matrix3();
  var jMatrix = new Matrix3();
  var jMatrixTranspose = new Matrix3();
  function computeEigenDecomposition(matrix, result = {}) {
    const EIGEN_TOLERANCE = math_utils_exports.EPSILON20;
    const EIGEN_MAX_SWEEPS = 10;
    let count2 = 0;
    let sweep = 0;
    const unitaryMatrix = scratchUnitary;
    const diagonalMatrix = scratchDiagonal;
    unitaryMatrix.identity();
    diagonalMatrix.copy(matrix);
    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
      shurDecomposition(diagonalMatrix, jMatrix);
      jMatrixTranspose.copy(jMatrix).transpose();
      diagonalMatrix.multiplyRight(jMatrix);
      diagonalMatrix.multiplyLeft(jMatrixTranspose);
      unitaryMatrix.multiplyRight(jMatrix);
      if (++count2 > 2) {
        ++sweep;
        count2 = 0;
      }
    }
    result.unitary = unitaryMatrix.toTarget(result.unitary);
    result.diagonal = diagonalMatrix.toTarget(result.diagonal);
    return result;
  }
  function computeFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 9; ++i5) {
      const temp = matrix[i5];
      norm += temp * temp;
    }
    return Math.sqrt(norm);
  }
  var rowVal = [1, 0, 0];
  var colVal = [2, 2, 1];
  function offDiagonalFrobeniusNorm(matrix) {
    let norm = 0;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = matrix[scratchMatrix.getElementIndex(colVal[i5], rowVal[i5])];
      norm += 2 * temp * temp;
    }
    return Math.sqrt(norm);
  }
  function shurDecomposition(matrix, result) {
    const tolerance = math_utils_exports.EPSILON15;
    let maxDiagonal = 0;
    let rotAxis = 1;
    for (let i5 = 0; i5 < 3; ++i5) {
      const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i5], rowVal[i5])]);
      if (temp > maxDiagonal) {
        rotAxis = i5;
        maxDiagonal = temp;
      }
    }
    const p3 = rowVal[rotAxis];
    const q2 = colVal[rotAxis];
    let c2 = 1;
    let s3 = 0;
    if (Math.abs(matrix[scratchMatrix.getElementIndex(q2, p3)]) > tolerance) {
      const qq = matrix[scratchMatrix.getElementIndex(q2, q2)];
      const pp = matrix[scratchMatrix.getElementIndex(p3, p3)];
      const qp = matrix[scratchMatrix.getElementIndex(q2, p3)];
      const tau = (qq - pp) / 2 / qp;
      let t3;
      if (tau < 0) {
        t3 = -1 / (-tau + Math.sqrt(1 + tau * tau));
      } else {
        t3 = 1 / (tau + Math.sqrt(1 + tau * tau));
      }
      c2 = 1 / Math.sqrt(1 + t3 * t3);
      s3 = t3 * c2;
    }
    Matrix3.IDENTITY.to(result);
    result[scratchMatrix.getElementIndex(p3, p3)] = result[scratchMatrix.getElementIndex(q2, q2)] = c2;
    result[scratchMatrix.getElementIndex(q2, p3)] = s3;
    result[scratchMatrix.getElementIndex(p3, q2)] = -s3;
    return result;
  }

  // ../../node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
  var scratchVector23 = new Vector3();
  var scratchVector33 = new Vector3();
  var scratchVector4 = new Vector3();
  var scratchVector5 = new Vector3();
  var scratchVector6 = new Vector3();
  var scratchCovarianceResult = new Matrix3();
  var scratchEigenResult = {
    diagonal: new Matrix3(),
    unitary: new Matrix3()
  };
  function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
    if (!positions || positions.length === 0) {
      result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      result.center = new Vector3();
      return result;
    }
    const length6 = positions.length;
    const meanPoint = new Vector3(0, 0, 0);
    for (const position of positions) {
      meanPoint.add(position);
    }
    const invLength = 1 / length6;
    meanPoint.multiplyByScalar(invLength);
    let exx = 0;
    let exy = 0;
    let exz = 0;
    let eyy = 0;
    let eyz = 0;
    let ezz = 0;
    for (const position of positions) {
      const p3 = scratchVector23.copy(position).subtract(meanPoint);
      exx += p3.x * p3.x;
      exy += p3.x * p3.y;
      exz += p3.x * p3.z;
      eyy += p3.y * p3.y;
      eyz += p3.y * p3.z;
      ezz += p3.z * p3.z;
    }
    exx *= invLength;
    exy *= invLength;
    exz *= invLength;
    eyy *= invLength;
    eyz *= invLength;
    ezz *= invLength;
    const covarianceMatrix = scratchCovarianceResult;
    covarianceMatrix[0] = exx;
    covarianceMatrix[1] = exy;
    covarianceMatrix[2] = exz;
    covarianceMatrix[3] = exy;
    covarianceMatrix[4] = eyy;
    covarianceMatrix[5] = eyz;
    covarianceMatrix[6] = exz;
    covarianceMatrix[7] = eyz;
    covarianceMatrix[8] = ezz;
    const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
    const rotation = result.halfAxes.copy(unitary);
    let v1 = rotation.getColumn(0, scratchVector4);
    let v2 = rotation.getColumn(1, scratchVector5);
    let v3 = rotation.getColumn(2, scratchVector6);
    let u1 = -Number.MAX_VALUE;
    let u22 = -Number.MAX_VALUE;
    let u3 = -Number.MAX_VALUE;
    let l1 = Number.MAX_VALUE;
    let l22 = Number.MAX_VALUE;
    let l3 = Number.MAX_VALUE;
    for (const position of positions) {
      scratchVector23.copy(position);
      u1 = Math.max(scratchVector23.dot(v1), u1);
      u22 = Math.max(scratchVector23.dot(v2), u22);
      u3 = Math.max(scratchVector23.dot(v3), u3);
      l1 = Math.min(scratchVector23.dot(v1), l1);
      l22 = Math.min(scratchVector23.dot(v2), l22);
      l3 = Math.min(scratchVector23.dot(v3), l3);
    }
    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
    v2 = v2.multiplyByScalar(0.5 * (l22 + u22));
    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
    result.center.copy(v1).add(v2).add(v3);
    const scale7 = scratchVector33.set(u1 - l1, u22 - l22, u3 - l3).multiplyByScalar(0.5);
    const scaleMatrix = new Matrix3([scale7[0], 0, 0, 0, scale7[1], 0, 0, 0, scale7[2]]);
    result.halfAxes.multiplyRight(scaleMatrix);
    return result;
  }

  // ../geo-layers/src/tileset-2d/tile-2d-traversal.ts
  var TILE_SIZE4 = 512;
  var MAX_MAPS = 3;
  var REF_POINTS_5 = [
    [0.5, 0.5],
    [0, 0],
    [0, 1],
    [1, 0],
    [1, 1]
  ];
  var REF_POINTS_9 = REF_POINTS_5.concat([
    [0, 0.5],
    [0.5, 0],
    [1, 0.5],
    [0.5, 1]
  ]);
  var REF_POINTS_11 = REF_POINTS_9.concat([
    [0.25, 0.5],
    [0.75, 0.5]
  ]);
  var OSMNode = class {
    constructor(x3, y3, z2) {
      this.x = x3;
      this.y = y3;
      this.z = z2;
    }
    get children() {
      if (!this._children) {
        const x3 = this.x * 2;
        const y3 = this.y * 2;
        const z2 = this.z + 1;
        this._children = [
          new OSMNode(x3, y3, z2),
          new OSMNode(x3, y3 + 1, z2),
          new OSMNode(x3 + 1, y3, z2),
          new OSMNode(x3 + 1, y3 + 1, z2)
        ];
      }
      return this._children;
    }
    update(params) {
      const { viewport, cullingVolume: cullingVolume2, elevationBounds, minZ, maxZ, bounds, offset, project: project2 } = params;
      const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project2);
      if (bounds && !this.insideBounds(bounds)) {
        return false;
      }
      const isInside = cullingVolume2.computeVisibility(boundingVolume);
      if (isInside < 0) {
        return false;
      }
      if (!this.childVisible) {
        let { z: z2 } = this;
        if (z2 < maxZ && z2 >= minZ) {
          const distance5 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
          z2 += Math.floor(Math.log2(distance5));
        }
        if (z2 >= maxZ) {
          this.selected = true;
          return true;
        }
      }
      this.selected = false;
      this.childVisible = true;
      for (const child of this.children) {
        child.update(params);
      }
      return true;
    }
    getSelected(result = []) {
      if (this.selected) {
        result.push(this);
      }
      if (this._children) {
        for (const node2 of this._children) {
          node2.getSelected(result);
        }
      }
      return result;
    }
    insideBounds([minX, minY, maxX, maxY]) {
      const scale7 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale7;
      return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
    }
    getBoundingVolume(zRange, worldOffset, project2) {
      if (project2) {
        const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
        const refPointPositions = [];
        for (const p3 of refPoints) {
          const lngLat = osmTile2lngLat(this.x + p3[0], this.y + p3[1], this.z);
          lngLat[2] = zRange[0];
          refPointPositions.push(project2(lngLat));
          if (zRange[0] !== zRange[1]) {
            lngLat[2] = zRange[1];
            refPointPositions.push(project2(lngLat));
          }
        }
        return makeOrientedBoundingBoxFromPoints(refPointPositions);
      }
      const scale7 = Math.pow(2, this.z);
      const extent = TILE_SIZE4 / scale7;
      const originX = this.x * extent + worldOffset * TILE_SIZE4;
      const originY = TILE_SIZE4 - (this.y + 1) * extent;
      return new AxisAlignedBoundingBox(
        [originX, originY, zRange[0]],
        [originX + extent, originY + extent, zRange[1]]
      );
    }
  };
  function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
    const project2 = viewport instanceof GlobeViewport && viewport.resolution ? viewport.projectPosition : null;
    const planes = Object.values(viewport.getFrustumPlanes()).map(
      ({ normal, distance: distance5 }) => new Plane(normal.clone().negate(), distance5)
    );
    const cullingVolume2 = new CullingVolume(planes);
    const unitsPerMeter2 = viewport.distanceScales.unitsPerMeter[2];
    const elevationMin = zRange && zRange[0] * unitsPerMeter2 || 0;
    const elevationMax = zRange && zRange[1] * unitsPerMeter2 || 0;
    const minZ = viewport instanceof WebMercatorViewport2 && viewport.pitch <= 60 ? maxZ : 0;
    if (bounds) {
      const [minLng, minLat, maxLng, maxLat] = bounds;
      const topLeft = lngLatToWorld([minLng, maxLat]);
      const bottomRight = lngLatToWorld([maxLng, minLat]);
      bounds = [topLeft[0], TILE_SIZE4 - topLeft[1], bottomRight[0], TILE_SIZE4 - bottomRight[1]];
    }
    const root = new OSMNode(0, 0, 0);
    const traversalParams = {
      viewport,
      project: project2,
      cullingVolume: cullingVolume2,
      elevationBounds: [elevationMin, elevationMax],
      minZ,
      maxZ,
      bounds,
      offset: 0
    };
    root.update(traversalParams);
    if (viewport instanceof WebMercatorViewport2 && viewport.subViewports && viewport.subViewports.length > 1) {
      traversalParams.offset = -1;
      while (root.update(traversalParams)) {
        if (--traversalParams.offset < -MAX_MAPS) {
          break;
        }
      }
      traversalParams.offset = 1;
      while (root.update(traversalParams)) {
        if (++traversalParams.offset > MAX_MAPS) {
          break;
        }
      }
    }
    return root.getSelected();
  }

  // ../geo-layers/src/tileset-2d/utils.ts
  var TILE_SIZE5 = 512;
  var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
  var urlType = {
    type: "object",
    value: null,
    validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
    equal: (value1, value2) => {
      if (value1 === value2) {
        return true;
      }
      if (!Array.isArray(value1) || !Array.isArray(value2)) {
        return false;
      }
      const len4 = value1.length;
      if (len4 !== value2.length) {
        return false;
      }
      for (let i5 = 0; i5 < len4; i5++) {
        if (value1[i5] !== value2[i5]) {
          return false;
        }
      }
      return true;
    }
  };
  function transformBox(bbox, modelMatrix2) {
    const transformedCoords = [
      modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
      modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
      modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
      modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
    ];
    const transformedBox = [
      Math.min(...transformedCoords.map((i5) => i5[0])),
      Math.min(...transformedCoords.map((i5) => i5[1])),
      Math.max(...transformedCoords.map((i5) => i5[0])),
      Math.max(...transformedCoords.map((i5) => i5[1]))
    ];
    return transformedBox;
  }
  function stringHash(s3) {
    return Math.abs(s3.split("").reduce((a3, b2) => (a3 << 5) - a3 + b2.charCodeAt(0) | 0, 0));
  }
  function getURLFromTemplate(template, tile) {
    if (!template || !template.length) {
      return null;
    }
    const { index: index2, id } = tile;
    if (Array.isArray(template)) {
      const i5 = stringHash(id) % template.length;
      template = template[i5];
    }
    let url = template;
    for (const key of Object.keys(index2)) {
      const regex = new RegExp(`{${key}}`, "g");
      url = url.replace(regex, String(index2[key]));
    }
    if (Number.isInteger(index2.y) && Number.isInteger(index2.z)) {
      url = url.replace(/\{-y\}/g, String(Math.pow(2, index2.z) - index2.y - 1));
    }
    return url;
  }
  function getBoundingBox2(viewport, zRange, extent) {
    let bounds;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({ z: minZ });
      const bounds1 = viewport.getBounds({ z: maxZ });
      bounds = [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
      ];
    } else {
      bounds = viewport.getBounds();
    }
    if (!viewport.isGeospatial) {
      return [
        Math.max(Math.min(bounds[0], extent[2]), extent[0]),
        Math.max(Math.min(bounds[1], extent[3]), extent[1]),
        Math.min(Math.max(bounds[2], extent[0]), extent[2]),
        Math.min(Math.max(bounds[3], extent[1]), extent[3])
      ];
    }
    return [
      Math.max(bounds[0], extent[0]),
      Math.max(bounds[1], extent[1]),
      Math.min(bounds[2], extent[2]),
      Math.min(bounds[3], extent[3])
    ];
  }
  function getCullBounds({
    viewport,
    z: z2,
    cullRect
  }) {
    const subViewports = viewport.subViewports || [viewport];
    return subViewports.map((v2) => getCullBoundsInViewport(v2, z2 || 0, cullRect));
  }
  function getCullBoundsInViewport(viewport, z2, cullRect) {
    if (!Array.isArray(z2)) {
      const x3 = cullRect.x - viewport.x;
      const y3 = cullRect.y - viewport.y;
      const { width, height } = cullRect;
      const unprojectOption = { targetZ: z2 };
      const topLeft = viewport.unproject([x3, y3], unprojectOption);
      const topRight = viewport.unproject([x3 + width, y3], unprojectOption);
      const bottomLeft = viewport.unproject([x3, y3 + height], unprojectOption);
      const bottomRight = viewport.unproject([x3 + width, y3 + height], unprojectOption);
      return [
        Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
        Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
        Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
      ];
    }
    const bounds0 = getCullBoundsInViewport(viewport, z2[0], cullRect);
    const bounds1 = getCullBoundsInViewport(viewport, z2[1], cullRect);
    return [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  }
  function getIndexingCoords(bbox, scale7, modelMatrixInverse) {
    if (modelMatrixInverse) {
      const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(
        (i5) => i5 * scale7 / TILE_SIZE5
      );
      return transformedTileIndex;
    }
    return bbox.map((i5) => i5 * scale7 / TILE_SIZE5);
  }
  function getScale(z2, tileSize) {
    return Math.pow(2, z2) * TILE_SIZE5 / tileSize;
  }
  function osmTile2lngLat(x3, y3, z2) {
    const scale7 = getScale(z2, TILE_SIZE5);
    const lng = x3 / scale7 * 360 - 180;
    const n3 = Math.PI - 2 * Math.PI * y3 / scale7;
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n3) - Math.exp(-n3)));
    return [lng, lat];
  }
  function tile2XY(x3, y3, z2, tileSize) {
    const scale7 = getScale(z2, tileSize);
    return [x3 / scale7 * TILE_SIZE5, y3 / scale7 * TILE_SIZE5];
  }
  function tileToBoundingBox(viewport, x3, y3, z2, tileSize = TILE_SIZE5) {
    if (viewport.isGeospatial) {
      const [west, north] = osmTile2lngLat(x3, y3, z2);
      const [east, south] = osmTile2lngLat(x3 + 1, y3 + 1, z2);
      return { west, north, east, south };
    }
    const [left, top] = tile2XY(x3, y3, z2, tileSize);
    const [right, bottom] = tile2XY(x3 + 1, y3 + 1, z2, tileSize);
    return { left, top, right, bottom };
  }
  function getIdentityTileIndices(viewport, z2, tileSize, extent, modelMatrixInverse) {
    const bbox = getBoundingBox2(viewport, null, extent);
    const scale7 = getScale(z2, tileSize);
    const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale7, modelMatrixInverse);
    const indices = [];
    for (let x3 = Math.floor(minX); x3 < maxX; x3++) {
      for (let y3 = Math.floor(minY); y3 < maxY; y3++) {
        indices.push({ x: x3, y: y3, z: z2 });
      }
    }
    return indices;
  }
  function getTileIndices({
    viewport,
    maxZoom,
    minZoom,
    zRange,
    extent,
    tileSize = TILE_SIZE5,
    modelMatrix: modelMatrix2,
    modelMatrixInverse,
    zoomOffset = 0
  }) {
    let z2 = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE5 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
    if (typeof minZoom === "number" && Number.isFinite(minZoom) && z2 < minZoom) {
      if (!extent) {
        return [];
      }
      z2 = minZoom;
    }
    if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z2 > maxZoom) {
      z2 = maxZoom;
    }
    let transformedExtent = extent;
    if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
      transformedExtent = transformBox(extent, modelMatrix2);
    }
    return viewport.isGeospatial ? getOSMTileIndices(viewport, z2, zRange, extent) : getIdentityTileIndices(
      viewport,
      z2,
      tileSize,
      transformedExtent || DEFAULT_EXTENT,
      modelMatrixInverse
    );
  }
  function isURLTemplate(s3) {
    return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s3);
  }
  function isGeoBoundingBox(v2) {
    return Number.isFinite(v2.west) && Number.isFinite(v2.north) && Number.isFinite(v2.east) && Number.isFinite(v2.south);
  }

  // ../geo-layers/src/tileset-2d/memoize.ts
  function memoize2(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual2(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }
  function isEqual2(a3, b2) {
    if (a3 === b2) {
      return true;
    }
    if (Array.isArray(a3)) {
      const len4 = a3.length;
      if (!b2 || b2.length !== len4) {
        return false;
      }
      for (let i5 = 0; i5 < len4; i5++) {
        if (a3[i5] !== b2[i5]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ../geo-layers/src/tileset-2d/tileset-2d.ts
  var TILE_STATE_VISITED = 1;
  var TILE_STATE_VISIBLE = 2;
  var STRATEGY_NEVER = "never";
  var STRATEGY_REPLACE = "no-overlap";
  var STRATEGY_DEFAULT = "best-available";
  var DEFAULT_CACHE_SCALE = 5;
  var STRATEGIES = {
    [STRATEGY_DEFAULT]: updateTileStateDefault,
    [STRATEGY_REPLACE]: updateTileStateReplace,
    [STRATEGY_NEVER]: () => {
    }
  };
  var DEFAULT_TILESET2D_PROPS = {
    extent: null,
    tileSize: 512,
    maxZoom: null,
    minZoom: null,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: "best-available",
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    }
  };
  var Tileset2D = class {
    constructor(opts) {
      this._getCullBounds = memoize2(getCullBounds);
      this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
      this.setOptions(this.opts);
      this.onTileLoad = (tile) => {
        this.opts.onTileLoad?.(tile);
        if (this.opts.maxCacheByteSize) {
          this._cacheByteSize += tile.byteLength;
          this._resizeCache();
        }
      };
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
        maxRequests: this.opts.maxRequests,
        debounceTime: this.opts.debounceTime
      });
      this._cache = /* @__PURE__ */ new Map();
      this._tiles = [];
      this._dirty = false;
      this._cacheByteSize = 0;
      this._viewport = null;
      this._zRange = null;
      this._selectedTiles = null;
      this._frameNumber = 0;
      this._modelMatrix = new Matrix4();
      this._modelMatrixInverse = new Matrix4();
    }
    get tiles() {
      return this._tiles;
    }
    get selectedTiles() {
      return this._selectedTiles;
    }
    get isLoaded() {
      return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
    }
    get needsReload() {
      return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
    }
    setOptions(opts) {
      Object.assign(this.opts, opts);
      if (Number.isFinite(opts.maxZoom)) {
        this._maxZoom = Math.floor(opts.maxZoom);
      }
      if (Number.isFinite(opts.minZoom)) {
        this._minZoom = Math.ceil(opts.minZoom);
      }
    }
    finalize() {
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          tile.abort();
        }
      }
      this._cache.clear();
      this._tiles = [];
      this._selectedTiles = null;
    }
    reloadAll() {
      for (const id of this._cache.keys()) {
        const tile = this._cache.get(id);
        if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
          this._cache.delete(id);
        } else {
          tile.setNeedsReload();
        }
      }
    }
    update(viewport, { zRange, modelMatrix: modelMatrix2 } = {
      zRange: null,
      modelMatrix: null
    }) {
      const modelMatrixAsMatrix4 = modelMatrix2 ? new Matrix4(modelMatrix2) : new Matrix4();
      const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
      if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
        if (isModelMatrixNew) {
          this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
          this._modelMatrix = modelMatrixAsMatrix4;
        }
        this._viewport = viewport;
        this._zRange = zRange;
        const tileIndices = this.getTileIndices({
          viewport,
          maxZoom: this._maxZoom,
          minZoom: this._minZoom,
          zRange,
          modelMatrix: this._modelMatrix,
          modelMatrixInverse: this._modelMatrixInverse
        });
        this._selectedTiles = tileIndices.map((index2) => this._getTile(index2, true));
        if (this._dirty) {
          this._rebuildTree();
        }
      } else if (this.needsReload) {
        this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
      }
      const changed = this.updateTileStates();
      this._pruneRequests();
      if (this._dirty) {
        this._resizeCache();
      }
      if (changed) {
        this._frameNumber++;
      }
      return this._frameNumber;
    }
    isTileVisible(tile, cullRect) {
      if (!tile.isVisible) {
        return false;
      }
      if (cullRect && this._viewport) {
        const boundsArr = this._getCullBounds({
          viewport: this._viewport,
          z: this._zRange,
          cullRect
        });
        const { bbox } = tile;
        for (const [minX, minY, maxX, maxY] of boundsArr) {
          let overlaps;
          if ("west" in bbox) {
            overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
          } else {
            const y0 = Math.min(bbox.top, bbox.bottom);
            const y1 = Math.max(bbox.top, bbox.bottom);
            overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
          }
          if (overlaps) {
            return true;
          }
        }
        return false;
      }
      return true;
    }
    getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      modelMatrix: modelMatrix2,
      modelMatrixInverse
    }) {
      const { tileSize, extent, zoomOffset } = this.opts;
      return getTileIndices({
        viewport,
        maxZoom,
        minZoom,
        zRange,
        tileSize,
        extent,
        modelMatrix: modelMatrix2,
        modelMatrixInverse,
        zoomOffset
      });
    }
    getTileId(index2) {
      return `${index2.x}-${index2.y}-${index2.z}`;
    }
    getTileZoom(index2) {
      return index2.z;
    }
    getTileMetadata(index2) {
      const { tileSize } = this.opts;
      return { bbox: tileToBoundingBox(this._viewport, index2.x, index2.y, index2.z, tileSize) };
    }
    getParentIndex(index2) {
      const x3 = Math.floor(index2.x / 2);
      const y3 = Math.floor(index2.y / 2);
      const z2 = index2.z - 1;
      return { x: x3, y: y3, z: z2 };
    }
    updateTileStates() {
      const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
      const visibilities = new Array(this._cache.size);
      let i5 = 0;
      for (const tile of this._cache.values()) {
        visibilities[i5++] = tile.isVisible;
        tile.isSelected = false;
        tile.isVisible = false;
      }
      for (const tile of this._selectedTiles) {
        tile.isSelected = true;
        tile.isVisible = true;
      }
      (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
      i5 = 0;
      for (const tile of this._cache.values()) {
        if (visibilities[i5++] !== tile.isVisible) {
          return true;
        }
      }
      return false;
    }
    _pruneRequests() {
      const { maxRequests = 0 } = this.opts;
      const abortCandidates = [];
      let ongoingRequestCount = 0;
      for (const tile of this._cache.values()) {
        if (tile.isLoading) {
          ongoingRequestCount++;
          if (!tile.isSelected && !tile.isVisible) {
            abortCandidates.push(tile);
          }
        }
      }
      while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
        const tile = abortCandidates.shift();
        tile.abort();
        ongoingRequestCount--;
      }
    }
    _rebuildTree() {
      const { _cache } = this;
      for (const tile of _cache.values()) {
        tile.parent = null;
        if (tile.children) {
          tile.children.length = 0;
        }
      }
      for (const tile of _cache.values()) {
        const parent = this._getNearestAncestor(tile);
        tile.parent = parent;
        if (parent?.children) {
          parent.children.push(tile);
        }
      }
    }
    _resizeCache() {
      const { _cache, opts } = this;
      const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
      const maxCacheByteSize = opts.maxCacheByteSize || Infinity;
      const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
      if (overflown) {
        for (const [id, tile] of _cache) {
          if (!tile.isVisible && !tile.isSelected) {
            this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;
            _cache.delete(id);
            this.opts.onTileUnload?.(tile);
          }
          if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
            break;
          }
        }
        this._rebuildTree();
        this._dirty = true;
      }
      if (this._dirty) {
        this._tiles = Array.from(this._cache.values()).sort((t1, t22) => t1.zoom - t22.zoom);
        this._dirty = false;
      }
    }
    _getTile(index2, create7) {
      const id = this.getTileId(index2);
      let tile = this._cache.get(id);
      let needsReload = false;
      if (!tile && create7) {
        tile = new Tile2DHeader(index2);
        Object.assign(tile, this.getTileMetadata(tile.index));
        Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
        needsReload = true;
        this._cache.set(id, tile);
        this._dirty = true;
      } else if (tile && tile.needsReload) {
        needsReload = true;
      }
      if (tile && needsReload) {
        tile.loadData({
          getData: this.opts.getTileData,
          requestScheduler: this._requestScheduler,
          onLoad: this.onTileLoad,
          onError: this.opts.onTileError
        });
      }
      return tile;
    }
    _getNearestAncestor(tile) {
      const { _minZoom = 0 } = this;
      let index2 = tile.index;
      while (this.getTileZoom(index2) > _minZoom) {
        index2 = this.getParentIndex(index2);
        const parent = this._getTile(index2);
        if (parent) {
          return parent;
        }
      }
      return null;
    }
  };
  function updateTileStateDefault(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
        getPlaceholderInChildren(tile);
      }
    }
    for (const tile of allTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    }
  }
  function updateTileStateReplace(allTiles) {
    for (const tile of allTiles) {
      tile.state = 0;
    }
    for (const tile of allTiles) {
      if (tile.isSelected) {
        getPlaceholderInAncestors(tile);
      }
    }
    const sortedTiles = Array.from(allTiles).sort((t1, t22) => t1.zoom - t22.zoom);
    for (const tile of sortedTiles) {
      tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
      if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
        for (const child of tile.children) {
          child.state = TILE_STATE_VISITED;
        }
      } else if (tile.isSelected) {
        getPlaceholderInChildren(tile);
      }
    }
  }
  function getPlaceholderInAncestors(startTile) {
    let tile = startTile;
    while (tile) {
      if (tile.isLoaded || tile.content) {
        tile.state |= TILE_STATE_VISIBLE;
        return true;
      }
      tile = tile.parent;
    }
    return false;
  }
  function getPlaceholderInChildren(tile) {
    for (const child of tile.children) {
      if (child.isLoaded || child.content) {
        child.state |= TILE_STATE_VISIBLE;
      } else {
        getPlaceholderInChildren(child);
      }
    }
  }

  // ../geo-layers/src/tile-layer/tile-layer.ts
  var defaultProps23 = {
    TilesetClass: Tileset2D,
    data: { type: "data", value: [] },
    dataComparator: urlType.equal,
    renderSubLayers: { type: "function", value: (props) => new GeoJsonLayer(props) },
    getTileData: { type: "function", optional: true, value: null },
    onViewportLoad: { type: "function", optional: true, value: null },
    onTileLoad: { type: "function", value: (tile) => {
    } },
    onTileUnload: { type: "function", value: (tile) => {
    } },
    onTileError: { type: "function", value: (err) => console.error(err) },
    extent: { type: "array", optional: true, value: null, compare: true },
    tileSize: 512,
    maxZoom: null,
    minZoom: 0,
    maxCacheSize: null,
    maxCacheByteSize: null,
    refinementStrategy: STRATEGY_DEFAULT,
    zRange: null,
    maxRequests: 6,
    debounceTime: 0,
    zoomOffset: 0
  };
  var TileLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        tileset: null,
        isLoaded: false
      };
    }
    finalizeState() {
      this.state?.tileset?.finalize();
    }
    get isLoaded() {
      return Boolean(
        this.state?.tileset?.selectedTiles?.every(
          (tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)
        )
      );
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState({ changeFlags }) {
      let { tileset } = this.state;
      const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
      const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
      if (!tileset) {
        tileset = new this.props.TilesetClass(this._getTilesetOptions());
        this.setState({ tileset });
      } else if (propsChanged) {
        tileset.setOptions(this._getTilesetOptions());
        if (dataChanged) {
          tileset.reloadAll();
        } else {
          tileset.tiles.forEach((tile) => {
            tile.layers = null;
          });
        }
      }
      this._updateTileset();
    }
    _getTilesetOptions() {
      const {
        tileSize,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy,
        extent,
        maxZoom,
        minZoom,
        maxRequests,
        debounceTime,
        zoomOffset
      } = this.props;
      return {
        maxCacheSize,
        maxCacheByteSize,
        maxZoom,
        minZoom,
        tileSize,
        refinementStrategy,
        extent,
        maxRequests,
        debounceTime,
        zoomOffset,
        getTileData: this.getTileData.bind(this),
        onTileLoad: this._onTileLoad.bind(this),
        onTileError: this._onTileError.bind(this),
        onTileUnload: this._onTileUnload.bind(this)
      };
    }
    _updateTileset() {
      const tileset = this.state.tileset;
      const { zRange, modelMatrix: modelMatrix2 } = this.props;
      const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix: modelMatrix2 });
      const { isLoaded } = tileset;
      const loadingStateChanged = this.state.isLoaded !== isLoaded;
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (isLoaded && (loadingStateChanged || tilesetChanged)) {
        this._onViewportLoad();
      }
      if (tilesetChanged) {
        this.setState({ frameNumber });
      }
      this.state.isLoaded = isLoaded;
    }
    _onViewportLoad() {
      const { tileset } = this.state;
      const { onViewportLoad } = this.props;
      if (onViewportLoad) {
        onViewportLoad(tileset.selectedTiles);
      }
    }
    _onTileLoad(tile) {
      this.props.onTileLoad(tile);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileError(error, tile) {
      this.props.onTileError(error);
      tile.layers = null;
      this.setNeedsUpdate();
    }
    _onTileUnload(tile) {
      this.props.onTileUnload(tile);
    }
    getTileData(tile) {
      const { data, getTileData, fetch: fetch2 } = this.props;
      const { signal } = tile;
      tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
      if (getTileData) {
        return getTileData(tile);
      }
      if (fetch2 && tile.url) {
        return fetch2(tile.url, { propName: "data", layer: this, signal });
      }
      return null;
    }
    renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
    getSubLayerPropsByTile(tile) {
      return null;
    }
    getPickingInfo(params) {
      const sourceTile = params.sourceLayer.props.tile;
      const info = params.info;
      if (info.picked) {
        info.tile = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      if (sourceTile && sourceTile.layers) {
        for (const layer of sourceTile.layers) {
          layer.updateAutoHighlight(info);
        }
      }
    }
    renderLayers() {
      return this.state.tileset.tiles.map((tile) => {
        const subLayerProps = this.getSubLayerPropsByTile(tile);
        if (!tile.isLoaded && !tile.content) {
        } else if (!tile.layers) {
          const layers = this.renderSubLayers({
            ...this.props,
            ...this.getSubLayerProps({
              id: tile.id,
              updateTriggers: this.props.updateTriggers
            }),
            data: tile.content,
            _offset: 0,
            tile
          });
          tile.layers = flatten(layers, Boolean).map(
            (layer) => layer.clone({
              tile,
              ...subLayerProps
            })
          );
        } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(
          (propName) => tile.layers[0].props[propName] !== subLayerProps[propName]
        )) {
          tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
        }
        return tile.layers;
      });
    }
    filterSubLayer({ layer, cullRect }) {
      const { tile } = layer.props;
      return this.state.tileset.isTileVisible(tile, cullRect);
    }
  };
  TileLayer.defaultProps = defaultProps23;
  TileLayer.layerName = "TileLayer";

  // ../geo-layers/src/trips-layer/trips-layer.ts
  var defaultProps24 = {
    fadeTrail: true,
    trailLength: { type: "number", value: 120, min: 0 },
    currentTime: { type: "number", value: 0, min: 0 },
    getTimestamps: { type: "accessor", value: (d2) => d2.timestamps }
  };
  var TripsLayer = class extends PathLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.inject = {
        "vs:#decl": `uniform float trailLength;
in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
        "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
        "fs:#decl": `uniform bool fadeTrail;
uniform float trailLength;
uniform float currentTime;
in float vTime;
`,
        "fs:#main-start": `if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {
  discard;
}
`,
        "fs:DECKGL_FILTER_COLOR": `if(fadeTrail) {
  color.a *= 1.0 - (currentTime - vTime) / trailLength;
}
`
      };
      return shaders;
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        timestamps: {
          size: 1,
          accessor: "getTimestamps",
          shaderAttributes: {
            instanceTimestamps: {
              vertexOffset: 0
            },
            instanceNextTimestamps: {
              vertexOffset: 1
            }
          }
        }
      });
    }
    draw(params) {
      const { fadeTrail, trailLength, currentTime } = this.props;
      params.uniforms = {
        ...params.uniforms,
        fadeTrail,
        trailLength,
        currentTime
      };
      super.draw(params);
    }
  };
  TripsLayer.layerName = "TripsLayer";
  TripsLayer.defaultProps = defaultProps24;

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var import_h3_js3 = __toESM(require_h3_js(), 1);

  // ../geo-layers/src/h3-layers/h3-hexagon-layer.ts
  var import_h3_js2 = __toESM(require_h3_js(), 1);

  // ../geo-layers/src/h3-layers/h3-utils.ts
  var import_h3_js = __toESM(require_h3_js(), 1);
  function normalizeLongitudes(vertices, refLng) {
    refLng = refLng === void 0 ? vertices[0][0] : refLng;
    for (const pt of vertices) {
      const deltaLng = pt[0] - refLng;
      if (deltaLng > 180) {
        pt[0] -= 360;
      } else if (deltaLng < -180) {
        pt[0] += 360;
      }
    }
  }
  function scalePolygon(hexId, vertices, factor) {
    const [lat, lng] = (0, import_h3_js.cellToLatLng)(hexId);
    const actualCount = vertices.length;
    normalizeLongitudes(vertices, lng);
    const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
    for (let i5 = 0; i5 < vertexCount; i5++) {
      vertices[i5][0] = lerp(lng, vertices[i5][0], factor);
      vertices[i5][1] = lerp(lat, vertices[i5][1], factor);
    }
  }
  function getHexagonCentroid(getHexagon, object, objectInfo) {
    const hexagonId = getHexagon(object, objectInfo);
    const [lat, lng] = (0, import_h3_js.cellToLatLng)(hexagonId);
    return [lng, lat];
  }
  function h3ToPolygon(hexId, coverage = 1) {
    const vertices = (0, import_h3_js.cellToBoundary)(hexId, true);
    if (coverage !== 1) {
      scalePolygon(hexId, vertices, coverage);
    } else {
      normalizeLongitudes(vertices);
    }
    return vertices;
  }
  function flattenPolygon(vertices) {
    const positions = new Float64Array(vertices.length * 2);
    let i5 = 0;
    for (const pt of vertices) {
      positions[i5++] = pt[0];
      positions[i5++] = pt[1];
    }
    return positions;
  }

  // ../geo-layers/src/h3-layers/h3-hexagon-layer.ts
  var UPDATE_THRESHOLD_KM = 10;
  function mergeTriggers(getHexagon, coverage) {
    let trigger;
    if (getHexagon === void 0 || getHexagon === null) {
      trigger = coverage;
    } else if (typeof getHexagon === "object") {
      trigger = { ...getHexagon, coverage };
    } else {
      trigger = { getHexagon, coverage };
    }
    return trigger;
  }
  var defaultProps25 = {
    ...PolygonLayer.defaultProps,
    highPrecision: "auto",
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    centerHexagon: null,
    getHexagon: { type: "accessor", value: (x3) => x3.hexagon },
    extruded: true
  };
  var _H3HexagonLayer = class extends CompositeLayer {
    initializeState() {
      _H3HexagonLayer._checkH3Lib();
      this.state = {
        edgeLengthKM: 0,
        resolution: -1
      };
    }
    shouldUpdateState({ changeFlags }) {
      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
    }
    updateState({ props, changeFlags }) {
      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
        const dataProps = this._calculateH3DataProps();
        this.setState(dataProps);
      }
      this._updateVertices(this.context.viewport);
    }
    _calculateH3DataProps() {
      let resolution = -1;
      let hasPentagon = false;
      let hasMultipleRes = false;
      const { iterable, objectInfo } = createIterable(this.props.data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexId = this.props.getHexagon(object, objectInfo);
        const hexResolution = (0, import_h3_js2.getResolution)(hexId);
        if (resolution < 0) {
          resolution = hexResolution;
          if (!this.props.highPrecision)
            break;
        } else if (resolution !== hexResolution) {
          hasMultipleRes = true;
          break;
        }
        if ((0, import_h3_js2.isPentagon)(hexId)) {
          hasPentagon = true;
          break;
        }
      }
      return {
        resolution,
        edgeLengthKM: resolution >= 0 ? (0, import_h3_js2.getHexagonEdgeLengthAvg)(resolution, "km") : 0,
        hasMultipleRes,
        hasPentagon
      };
    }
    _shouldUseHighPrecision() {
      if (this.props.highPrecision === "auto") {
        const { resolution, hasPentagon, hasMultipleRes } = this.state;
        const { viewport } = this.context;
        return Boolean(viewport?.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
      }
      return this.props.highPrecision;
    }
    _updateVertices(viewport) {
      if (this._shouldUseHighPrecision()) {
        return;
      }
      const { resolution, edgeLengthKM, centerHex } = this.state;
      if (resolution < 0) {
        return;
      }
      const hex = this.props.centerHexagon || (0, import_h3_js2.latLngToCell)(viewport.latitude, viewport.longitude, resolution);
      if (centerHex === hex) {
        return;
      }
      if (centerHex) {
        try {
          const distance5 = (0, import_h3_js2.gridDistance)(centerHex, hex);
          if (distance5 * edgeLengthKM < UPDATE_THRESHOLD_KM) {
            return;
          }
        } catch {
        }
      }
      const { unitsPerMeter: unitsPerMeter2 } = viewport.distanceScales;
      let vertices = h3ToPolygon(hex);
      const [centerLat, centerLng] = (0, import_h3_js2.cellToLatLng)(hex);
      const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
      vertices = vertices.map((p3) => {
        const worldPosition = viewport.projectFlat(p3);
        return [
          (worldPosition[0] - centerX) / unitsPerMeter2[0],
          (worldPosition[1] - centerY) / unitsPerMeter2[1]
        ];
      });
      this.setState({ centerHex: hex, vertices });
    }
    renderLayers() {
      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
    }
    _getForwardProps() {
      const {
        elevationScale,
        material,
        coverage,
        extruded,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        getFillColor,
        getElevation,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers
      } = this.props;
      return {
        elevationScale,
        extruded,
        coverage,
        wireframe,
        stroked,
        filled,
        lineWidthUnits,
        lineWidthScale,
        lineWidthMinPixels,
        lineWidthMaxPixels,
        material,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth,
        transitions,
        updateTriggers: {
          getFillColor: updateTriggers.getFillColor,
          getElevation: updateTriggers.getElevation,
          getLineColor: updateTriggers.getLineColor,
          getLineWidth: updateTriggers.getLineWidth
        }
      };
    }
    _renderPolygonLayer() {
      const { data, getHexagon, updateTriggers, coverage } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", PolygonLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
      return new SubLayerClass(
        forwardProps2,
        this.getSubLayerProps({
          id: "hexagon-cell-hifi",
          updateTriggers: forwardProps2.updateTriggers
        }),
        {
          data,
          _normalize: false,
          _windingOrder: "CCW",
          positionFormat: "XY",
          getPolygon: (object, objectInfo) => {
            const hexagonId = getHexagon(object, objectInfo);
            return flattenPolygon(h3ToPolygon(hexagonId, coverage));
          }
        }
      );
    }
    _renderColumnLayer() {
      const { data, getHexagon, updateTriggers } = this.props;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
      const forwardProps2 = this._getForwardProps();
      forwardProps2.updateTriggers.getPosition = updateTriggers.getHexagon;
      return new SubLayerClass(
        forwardProps2,
        this.getSubLayerProps({
          id: "hexagon-cell",
          flatShading: true,
          updateTriggers: forwardProps2.updateTriggers
        }),
        {
          data,
          diskResolution: 6,
          radius: 1,
          vertices: this.state.vertices,
          getPosition: getHexagonCentroid.bind(null, getHexagon)
        }
      );
    }
  };
  var H3HexagonLayer = _H3HexagonLayer;
  H3HexagonLayer.defaultProps = defaultProps25;
  H3HexagonLayer.layerName = "H3HexagonLayer";
  H3HexagonLayer._checkH3Lib = () => {
  };

  // ../geo-layers/src/h3-layers/h3-cluster-layer.ts
  var defaultProps26 = {
    getHexagons: { type: "accessor", value: (d2) => d2.hexagons }
  };
  var H3ClusterLayer = class extends GeoCellLayer {
    initializeState() {
      H3HexagonLayer._checkH3Lib();
    }
    updateState({ props, changeFlags }) {
      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
        const { data, getHexagons } = props;
        const polygons = [];
        const { iterable, objectInfo } = createIterable(data);
        for (const object of iterable) {
          objectInfo.index++;
          const hexagons = getHexagons(object, objectInfo);
          const multiPolygon = (0, import_h3_js3.cellsToMultiPolygon)(hexagons, true);
          for (const polygon of multiPolygon) {
            for (const ring of polygon) {
              normalizeLongitudes(ring);
            }
            polygons.push(this.getSubLayerRow({ polygon }, object, objectInfo.index));
          }
        }
        this.setState({ polygons });
      }
    }
    indexToBounds() {
      const { getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
      return {
        data: this.state.polygons,
        getPolygon: (d2) => d2.polygon,
        getElevation: this.getSubLayerAccessor(getElevation),
        getFillColor: this.getSubLayerAccessor(getFillColor),
        getLineColor: this.getSubLayerAccessor(getLineColor),
        getLineWidth: this.getSubLayerAccessor(getLineWidth)
      };
    }
  };
  H3ClusterLayer.layerName = "H3ClusterLayer";
  H3ClusterLayer.defaultProps = defaultProps26;

  // ../mesh-layers/src/utils/matrix.ts
  var RADIAN_PER_DEGREE = Math.PI / 180;
  var modelMatrix = new Float32Array(16);
  var valueArray = new Float32Array(12);
  function calculateTransformMatrix(targetMatrix, orientation, scale7) {
    const pitch = orientation[0] * RADIAN_PER_DEGREE;
    const yaw = orientation[1] * RADIAN_PER_DEGREE;
    const roll = orientation[2] * RADIAN_PER_DEGREE;
    const sr = Math.sin(roll);
    const sp = Math.sin(pitch);
    const sw = Math.sin(yaw);
    const cr = Math.cos(roll);
    const cp = Math.cos(pitch);
    const cw = Math.cos(yaw);
    const scx = scale7[0];
    const scy = scale7[1];
    const scz = scale7[2];
    targetMatrix[0] = scx * cw * cp;
    targetMatrix[1] = scx * sw * cp;
    targetMatrix[2] = scx * -sp;
    targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
    targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
    targetMatrix[5] = scy * cp * sr;
    targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
    targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
    targetMatrix[8] = scz * cp * cr;
  }
  function getExtendedMat3FromMat4(mat4) {
    mat4[0] = mat4[0];
    mat4[1] = mat4[1];
    mat4[2] = mat4[2];
    mat4[3] = mat4[4];
    mat4[4] = mat4[5];
    mat4[5] = mat4[6];
    mat4[6] = mat4[8];
    mat4[7] = mat4[9];
    mat4[8] = mat4[10];
    mat4[9] = mat4[12];
    mat4[10] = mat4[13];
    mat4[11] = mat4[14];
    return mat4.subarray(0, 12);
  }
  var MATRIX_ATTRIBUTES = {
    size: 12,
    accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
    shaderAttributes: {
      instanceModelMatrixCol0: {
        size: 3,
        elementOffset: 0
      },
      instanceModelMatrixCol1: {
        size: 3,
        elementOffset: 3
      },
      instanceModelMatrixCol2: {
        size: 3,
        elementOffset: 6
      },
      instanceTranslation: {
        size: 3,
        elementOffset: 9
      }
    },
    update(attribute, { startRow, endRow }) {
      const { data, getOrientation, getScale: getScale3, getTranslation: getTranslation3, getTransformMatrix } = this.props;
      const arrayMatrix = Array.isArray(getTransformMatrix);
      const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
      const constantScale = Array.isArray(getScale3);
      const constantOrientation = Array.isArray(getOrientation);
      const constantTranslation = Array.isArray(getTranslation3);
      const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
      if (hasMatrix) {
        attribute.constant = constantMatrix;
      } else {
        attribute.constant = constantOrientation && constantScale && constantTranslation;
      }
      const instanceModelMatrixData = attribute.value;
      if (attribute.constant) {
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(getTransformMatrix);
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = getOrientation;
          const scale7 = getScale3;
          calculateTransformMatrix(matrix, orientation, scale7);
          matrix.set(getTranslation3, 9);
        }
        attribute.value = new Float32Array(matrix);
      } else {
        let i5 = startRow * attribute.size;
        const { iterable, objectInfo } = createIterable(data, startRow, endRow);
        for (const object of iterable) {
          objectInfo.index++;
          let matrix;
          if (hasMatrix) {
            modelMatrix.set(
              constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)
            );
            matrix = getExtendedMat3FromMat4(modelMatrix);
          } else {
            matrix = valueArray;
            const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
            const scale7 = constantScale ? getScale3 : getScale3(object, objectInfo);
            calculateTransformMatrix(matrix, orientation, scale7);
            matrix.set(constantTranslation ? getTranslation3 : getTranslation3(object, objectInfo), 9);
          }
          instanceModelMatrixData[i5++] = matrix[0];
          instanceModelMatrixData[i5++] = matrix[1];
          instanceModelMatrixData[i5++] = matrix[2];
          instanceModelMatrixData[i5++] = matrix[3];
          instanceModelMatrixData[i5++] = matrix[4];
          instanceModelMatrixData[i5++] = matrix[5];
          instanceModelMatrixData[i5++] = matrix[6];
          instanceModelMatrixData[i5++] = matrix[7];
          instanceModelMatrixData[i5++] = matrix[8];
          instanceModelMatrixData[i5++] = matrix[9];
          instanceModelMatrixData[i5++] = matrix[10];
          instanceModelMatrixData[i5++] = matrix[11];
        }
      }
    }
  };
  function shouldComposeModelMatrix(viewport, coordinateSystem) {
    return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
  }

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts
  var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts
  var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;

  // ../mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts
  function normalizeGeometryAttributes(attributes) {
    const positionAttribute = attributes.positions || attributes.POSITION;
    log_default.assert(positionAttribute, 'no "postions" or "POSITION" attribute in mesh');
    const vertexCount = positionAttribute.value.length / positionAttribute.size;
    let colorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!colorAttribute) {
      colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };
    }
    let normalAttribute = attributes.NORMAL || attributes.normals;
    if (!normalAttribute) {
      normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };
    }
    let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;
    if (!texCoordAttribute) {
      texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };
    }
    return {
      positions: positionAttribute,
      colors: colorAttribute,
      normals: normalAttribute,
      texCoords: texCoordAttribute
    };
  }
  function getGeometry(data) {
    if (data instanceof Geometry) {
      data.attributes = normalizeGeometryAttributes(data.attributes);
      return data;
    } else if (data.attributes) {
      return new Geometry({
        ...data,
        topology: "triangle-list",
        attributes: normalizeGeometryAttributes(data.attributes)
      });
    } else {
      return new Geometry({
        topology: "triangle-list",
        attributes: normalizeGeometryAttributes(data)
      });
    }
  }
  var DEFAULT_COLOR10 = [0, 0, 0, 255];
  var defaultProps27 = {
    mesh: { type: "object", value: null, async: true },
    texture: { type: "image", value: null, async: true },
    sizeScale: { type: "number", value: 1, min: 0 },
    _instanced: true,
    wireframe: false,
    material: true,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR10 },
    getOrientation: { type: "accessor", value: [0, 0, 0] },
    getScale: { type: "accessor", value: [1, 1, 1] },
    getTranslation: { type: "accessor", value: [0, 0, 0] },
    getTransformMatrix: { type: "accessor", value: [] },
    textureParameters: { type: "object", ignore: true, value: null }
  };
  var SimpleMeshLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: simple_mesh_layer_vertex_glsl_default,
        fs: simple_mesh_layer_fragment_glsl_default,
        modules: [project32_default, phongLighting, picking_default]
      });
    }
    getBounds() {
      if (this.props._instanced) {
        return super.getBounds();
      }
      let result = this.state.positionBounds;
      if (result) {
        return result;
      }
      const { mesh } = this.props;
      if (!mesh) {
        return null;
      }
      result = mesh.header?.boundingBox;
      if (!result) {
        const { attributes } = getGeometry(mesh);
        attributes.POSITION = attributes.POSITION || attributes.positions;
        result = getMeshBoundingBox(attributes);
      }
      this.state.positionBounds = result;
      return result;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          transition: true,
          type: "float64",
          fp64: this.use64bitPositions(),
          size: 3,
          accessor: "getPosition"
        },
        instanceColors: {
          type: "unorm8",
          transition: true,
          size: this.props.colorFormat.length,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
      this.setState({
        emptyTexture: this.context.device.createTexture({
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
        this.state.positionBounds = null;
        this.state.model?.destroy();
        if (props.mesh) {
          this.state.model = this.getModel(props.mesh);
          const attributes = props.mesh.attributes || props.mesh;
          this.setState({
            hasNormals: Boolean(attributes.NORMAL || attributes.normals)
          });
        }
        this.getAttributeManager().invalidateAll();
      }
      if (props.texture !== oldProps.texture && props.texture instanceof Texture) {
        this.setTexture(props.texture);
      }
      if (this.state.model) {
        this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.emptyTexture.delete();
    }
    draw({ uniforms }) {
      const { model } = this.state;
      if (!model) {
        return;
      }
      const { viewport, renderPass } = this.context;
      const { sizeScale, coordinateSystem, _instanced } = this.props;
      model.setUniforms(uniforms);
      model.setUniforms({
        sizeScale,
        composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
        flatShading: !this.state.hasNormals
      });
      model.draw(renderPass);
    }
    get isLoaded() {
      return Boolean(this.state?.model && super.isLoaded);
    }
    getModel(mesh) {
      const model = new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: getGeometry(mesh),
        isInstanced: true
      });
      const { texture } = this.props;
      const { emptyTexture } = this.state;
      model.setBindings({
        sampler: texture || emptyTexture
      });
      model.setUniforms({
        hasTexture: Boolean(texture)
      });
      return model;
    }
    setTexture(texture) {
      const { emptyTexture, model } = this.state;
      if (model) {
        model.setBindings({
          sampler: texture || emptyTexture
        });
        model.setUniforms({
          hasTexture: Boolean(texture)
        });
      }
    }
  };
  SimpleMeshLayer.defaultProps = defaultProps27;
  SimpleMeshLayer.layerName = "SimpleMeshLayer";

  // ../../node_modules/@luma.gl/gltf/dist/pbr/parse-pbr-material.js
  var GLEnum2;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum4[GLEnum4["ONE"] = 1] = "ONE";
    GLEnum4[GLEnum4["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum4[GLEnum4["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum4[GLEnum4["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum4[GLEnum4["LINEAR"] = 9729] = "LINEAR";
    GLEnum4[GLEnum4["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum4[GLEnum4["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  })(GLEnum2 || (GLEnum2 = {}));
  function parsePBRMaterial(device, material, attributes, options) {
    const parsedMaterial = {
      defines: {
        MANUAL_SRGB: 1,
        SRGB_FAST_APPROXIMATION: 1
      },
      bindings: {},
      uniforms: {
        u_Camera: [0, 0, 0],
        u_MetallicRoughnessValues: [1, 1]
      },
      parameters: {},
      glParameters: {},
      generatedTextures: []
    };
    parsedMaterial.defines.USE_TEX_LOD = 1;
    const { imageBasedLightingEnvironment } = options;
    if (imageBasedLightingEnvironment) {
      parsedMaterial.bindings.u_DiffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler;
      parsedMaterial.bindings.u_SpecularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler;
      parsedMaterial.bindings.u_brdfLUT = imageBasedLightingEnvironment.brdfLutTexture;
      parsedMaterial.uniforms.u_ScaleIBLAmbient = [1, 1];
    }
    if (options?.pbrDebug) {
      parsedMaterial.defines.PBR_DEBUG = 1;
      parsedMaterial.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];
      parsedMaterial.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];
    }
    if (attributes.NORMAL)
      parsedMaterial.defines.HAS_NORMALS = 1;
    if (attributes.TANGENT && options?.useTangents)
      parsedMaterial.defines.HAS_TANGENTS = 1;
    if (attributes.TEXCOORD_0)
      parsedMaterial.defines.HAS_UV = 1;
    if (options?.imageBasedLightingEnvironment)
      parsedMaterial.defines.USE_IBL = 1;
    if (options?.lights)
      parsedMaterial.defines.USE_LIGHTS = 1;
    if (material) {
      parseMaterial(device, material, parsedMaterial);
    }
    return parsedMaterial;
  }
  function parseMaterial(device, material, parsedMaterial) {
    parsedMaterial.uniforms.pbr_uUnlit = Boolean(material.unlit);
    if (material.pbrMetallicRoughness) {
      parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);
    }
    if (material.normalTexture) {
      addTexture(device, material.normalTexture, "u_NormalSampler", "HAS_NORMALMAP", parsedMaterial);
      const { scale: scale7 = 1 } = material.normalTexture;
      parsedMaterial.uniforms.u_NormalScale = scale7;
    }
    if (material.occlusionTexture) {
      addTexture(device, material.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP", parsedMaterial);
      const { strength = 1 } = material.occlusionTexture;
      parsedMaterial.uniforms.u_OcclusionStrength = strength;
    }
    if (material.emissiveTexture) {
      addTexture(device, material.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP", parsedMaterial);
      parsedMaterial.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];
    }
    switch (material.alphaMode) {
      case "MASK":
        const { alphaCutoff = 0.5 } = material;
        parsedMaterial.defines.ALPHA_CUTOFF = 1;
        parsedMaterial.uniforms.u_AlphaCutoff = alphaCutoff;
        break;
      case "BLEND":
        log2.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")();
        parsedMaterial.parameters.blendColorOperation = "add";
        parsedMaterial.parameters.blendColorSrcFactor = "src-alpha";
        parsedMaterial.parameters.blendColorDstFactor = "one-minus-src-alpha";
        parsedMaterial.parameters.blendAlphaOperation = "add";
        parsedMaterial.parameters.blendAlphaSrcFactor = "one";
        parsedMaterial.parameters.blendAlphaDstFactor = "one-minus-src-alpha";
        parsedMaterial.glParameters.blend = true;
        parsedMaterial.glParameters.blendEquation = GLEnum2.FUNC_ADD;
        parsedMaterial.glParameters.blendFunc = [
          GLEnum2.SRC_ALPHA,
          GLEnum2.ONE_MINUS_SRC_ALPHA,
          GLEnum2.ONE,
          GLEnum2.ONE_MINUS_SRC_ALPHA
        ];
        break;
    }
  }
  function parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {
    if (pbrMetallicRoughness.baseColorTexture) {
      addTexture(device, pbrMetallicRoughness.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP", parsedMaterial);
    }
    parsedMaterial.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
    if (pbrMetallicRoughness.metallicRoughnessTexture) {
      addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP", parsedMaterial);
    }
    const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;
    parsedMaterial.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];
  }
  function addTexture(device, gltfTexture, uniformName, define2 = null, parsedMaterial) {
    const parameters2 = gltfTexture?.texture?.sampler?.parameters || {};
    const image = gltfTexture.texture.source.image;
    let textureOptions;
    let specialTextureParameters = {};
    if (image.compressed) {
      textureOptions = image;
      specialTextureParameters = {
        [GLEnum2.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum2.LINEAR_MIPMAP_NEAREST : GLEnum2.LINEAR
      };
    } else {
      textureOptions = { data: image };
    }
    const texture = device.createTexture({
      id: gltfTexture.uniformName || gltfTexture.id,
      parameters: {
        ...parameters2,
        ...specialTextureParameters
      },
      pixelStore: {
        [GLEnum2.UNPACK_FLIP_Y_WEBGL]: false
      },
      ...textureOptions
    });
    parsedMaterial.bindings[uniformName] = texture;
    if (define2)
      parsedMaterial.defines[define2] = 1;
    parsedMaterial.generatedTextures.push(texture);
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/utils/version.js
  var VERSION9 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
  var BASIS_EXTERNAL_LIBRARIES = {
    TRANSCODER: "basis_transcoder.js",
    TRANSCODER_WASM: "basis_transcoder.wasm",
    ENCODER: "basis_encoder.js",
    ENCODER_WASM: "basis_encoder.wasm"
  };
  var loadBasisTranscoderPromise;
  async function loadBasisTranscoderModule(options) {
    const modules = options.modules || {};
    if (modules.basis) {
      return modules.basis;
    }
    loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTranscoder(options);
    return await loadBasisTranscoderPromise;
  }
  async function loadBasisTranscoder(options) {
    let BASIS = null;
    let wasmBinary = null;
    [BASIS, wasmBinary] = await Promise.all([await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options), await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)]);
    BASIS = BASIS || globalThis.BASIS;
    return await initializeBasisTranscoderModule(BASIS, wasmBinary);
  }
  function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisModule(options).then((module) => {
        const {
          BasisFile,
          initializeBasis
        } = module;
        initializeBasis();
        resolve2({
          BasisFile
        });
      });
    });
  }
  var loadBasisEncoderPromise;
  async function loadBasisEncoderModule(options) {
    const modules = options.modules || {};
    if (modules.basisEncoder) {
      return modules.basisEncoder;
    }
    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
    return await loadBasisEncoderPromise;
  }
  async function loadBasisEncoder(options) {
    let BASIS_ENCODER = null;
    let wasmBinary = null;
    [BASIS_ENCODER, wasmBinary] = await Promise.all([await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options), await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)]);
    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
  }
  function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      BasisEncoderModule(options).then((module) => {
        const {
          BasisFile,
          KTX2File,
          initializeBasis,
          BasisEncoder
        } = module;
        initializeBasis();
        resolve2({
          BasisFile,
          KTX2File,
          BasisEncoder
        });
      });
    });
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
  var GL_EXTENSIONS_CONSTANTS = {
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_R11_EAC: 37488,
    COMPRESSED_SIGNED_R11_EAC: 37489,
    COMPRESSED_RG11_EAC: 37490,
    COMPRESSED_SIGNED_RG11_EAC: 37491,
    COMPRESSED_RGB8_ETC2: 37492,
    COMPRESSED_RGBA8_ETC2_EAC: 37493,
    COMPRESSED_SRGB8_ETC2: 37494,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGB_ATC_WEBGL: 35986,
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
    COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
    COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
    COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
    COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
    COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
    COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
    COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
    COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
    COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
    COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
    COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
    COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
    COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
    COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
    COMPRESSED_RED_RGTC1_EXT: 36283,
    COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
    COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
    COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
  };

  // ../../node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
  var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
  var WEBGL_EXTENSIONS = {
    WEBGL_compressed_texture_s3tc: "dxt",
    WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
    WEBGL_compressed_texture_etc1: "etc1",
    WEBGL_compressed_texture_etc: "etc2",
    WEBGL_compressed_texture_pvrtc: "pvrtc",
    WEBGL_compressed_texture_atc: "atc",
    WEBGL_compressed_texture_astc: "astc",
    EXT_texture_compression_rgtc: "rgtc"
  };
  var formats = null;
  function getSupportedGPUTextureFormats(gl) {
    if (!formats) {
      gl = gl || getWebGLContext() || void 0;
      formats = /* @__PURE__ */ new Set();
      for (const prefix of BROWSER_PREFIXES) {
        for (const extension in WEBGL_EXTENSIONS) {
          if (gl && gl.getExtension(`${prefix}${extension}`)) {
            const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
            formats.add(gpuTextureFormat);
          }
        }
      }
    }
    return formats;
  }
  function getWebGLContext() {
    try {
      const canvas2 = document.createElement("canvas");
      return canvas2.getContext("webgl");
    } catch (error) {
      return null;
    }
  }

  // ../../node_modules/ktx-parse/dist/ktx-parse.modern.js
  var t = new Uint8Array([0]);
  var n;
  var i;
  var s;
  var a;
  var r;
  var o;
  var l;
  var f;
  !function(t3) {
    t3[t3.NONE = 0] = "NONE", t3[t3.BASISLZ = 1] = "BASISLZ", t3[t3.ZSTD = 2] = "ZSTD", t3[t3.ZLIB = 3] = "ZLIB";
  }(n || (n = {})), function(t3) {
    t3[t3.BASICFORMAT = 0] = "BASICFORMAT";
  }(i || (i = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.ETC1S = 163] = "ETC1S", t3[t3.UASTC = 166] = "UASTC";
  }(s || (s = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.SRGB = 1] = "SRGB";
  }(a || (a = {})), function(t3) {
    t3[t3.UNSPECIFIED = 0] = "UNSPECIFIED", t3[t3.LINEAR = 1] = "LINEAR", t3[t3.SRGB = 2] = "SRGB", t3[t3.ITU = 3] = "ITU", t3[t3.NTSC = 4] = "NTSC", t3[t3.SLOG = 5] = "SLOG", t3[t3.SLOG2 = 6] = "SLOG2";
  }(r || (r = {})), function(t3) {
    t3[t3.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", t3[t3.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
  }(o || (o = {})), function(t3) {
    t3[t3.RGB = 0] = "RGB", t3[t3.RRR = 3] = "RRR", t3[t3.GGG = 4] = "GGG", t3[t3.AAA = 15] = "AAA";
  }(l || (l = {})), function(t3) {
    t3[t3.RGB = 0] = "RGB", t3[t3.RGBA = 3] = "RGBA", t3[t3.RRR = 4] = "RRR", t3[t3.RRRG = 5] = "RRRG";
  }(f || (f = {}));

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
  var KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
  function isKTX(data) {
    const id = new Uint8Array(data);
    const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
    return !notKTX;
  }

  // ../../node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
  var OutputFormat = {
    etc1: {
      basisFormat: 0,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
    },
    etc2: {
      basisFormat: 1,
      compressed: true
    },
    bc1: {
      basisFormat: 2,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
    },
    bc3: {
      basisFormat: 3,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    bc4: {
      basisFormat: 4,
      compressed: true
    },
    bc5: {
      basisFormat: 5,
      compressed: true
    },
    "bc7-m6-opaque-only": {
      basisFormat: 6,
      compressed: true
    },
    "bc7-m5": {
      basisFormat: 7,
      compressed: true
    },
    "pvrtc1-4-rgb": {
      basisFormat: 8,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
    },
    "pvrtc1-4-rgba": {
      basisFormat: 9,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    },
    "astc-4x4": {
      basisFormat: 10,
      compressed: true,
      format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
    },
    "atc-rgb": {
      basisFormat: 11,
      compressed: true
    },
    "atc-rgba-interpolated-alpha": {
      basisFormat: 12,
      compressed: true
    },
    rgba32: {
      basisFormat: 13,
      compressed: false
    },
    rgb565: {
      basisFormat: 14,
      compressed: false
    },
    bgr565: {
      basisFormat: 15,
      compressed: false
    },
    rgba4444: {
      basisFormat: 16,
      compressed: false
    }
  };
  async function parseBasis(data, options) {
    if (options.basis.containerFormat === "auto") {
      if (isKTX(data)) {
        const fileConstructors = await loadBasisEncoderModule(options);
        return parseKTX2File(fileConstructors.KTX2File, data, options);
      }
      const {
        BasisFile
      } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
    }
    switch (options.basis.module) {
      case "encoder":
        const fileConstructors = await loadBasisEncoderModule(options);
        switch (options.basis.containerFormat) {
          case "ktx2":
            return parseKTX2File(fileConstructors.KTX2File, data, options);
          case "basis":
          default:
            return parseBasisFile(fileConstructors.BasisFile, data, options);
        }
      case "transcoder":
      default:
        const {
          BasisFile
        } = await loadBasisTranscoderModule(options);
        return parseBasisFile(BasisFile, data, options);
    }
  }
  function parseBasisFile(BasisFile, data, options) {
    const basisFile = new BasisFile(new Uint8Array(data));
    try {
      if (!basisFile.startTranscoding()) {
        throw new Error("Failed to start basis transcoding");
      }
      const imageCount = basisFile.getNumImages();
      const images = [];
      for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
        const levelsCount = basisFile.getNumLevels(imageIndex);
        const levels = [];
        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
          levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
        }
        images.push(levels);
      }
      return images;
    } finally {
      basisFile.close();
      basisFile.delete();
    }
  }
  function transcodeImage(basisFile, imageIndex, levelIndex, options) {
    const width = basisFile.getImageWidth(imageIndex, levelIndex);
    const height = basisFile.getImageHeight(imageIndex, levelIndex);
    const hasAlpha = basisFile.getHasAlpha();
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, hasAlpha);
    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
      throw new Error("failed to start Basis transcoding");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      format,
      hasAlpha
    };
  }
  function parseKTX2File(KTX2File, data, options) {
    const ktx2File = new KTX2File(new Uint8Array(data));
    try {
      if (!ktx2File.startTranscoding()) {
        throw new Error("failed to start KTX2 transcoding");
      }
      const levelsCount = ktx2File.getLevels();
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
        break;
      }
      return [levels];
    } finally {
      ktx2File.close();
      ktx2File.delete();
    }
  }
  function transcodeKTX2Image(ktx2File, levelIndex, options) {
    const {
      alphaFlag,
      height,
      width
    } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
    const {
      compressed,
      format,
      basisFormat
    } = getBasisOptions(options, alphaFlag);
    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
    const decodedData = new Uint8Array(decodedSize);
    if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
      throw new Error("Failed to transcode KTX2 image");
    }
    return {
      width,
      height,
      data: decodedData,
      compressed,
      levelSize: decodedSize,
      hasAlpha: alphaFlag,
      format
    };
  }
  function getBasisOptions(options, hasAlpha) {
    let format = options && options.basis && options.basis.format;
    if (format === "auto") {
      format = selectSupportedBasisFormat();
    }
    if (typeof format === "object") {
      format = hasAlpha ? format.alpha : format.noAlpha;
    }
    format = format.toLowerCase();
    return OutputFormat[format];
  }
  function selectSupportedBasisFormat() {
    const supportedFormats = getSupportedGPUTextureFormats();
    if (supportedFormats.has("astc")) {
      return "astc-4x4";
    } else if (supportedFormats.has("dxt")) {
      return {
        alpha: "bc3",
        noAlpha: "bc1"
      };
    } else if (supportedFormats.has("pvrtc")) {
      return {
        alpha: "pvrtc1-4-rgba",
        noAlpha: "pvrtc1-4-rgb"
      };
    } else if (supportedFormats.has("etc1")) {
      return "etc1";
    } else if (supportedFormats.has("etc2")) {
      return "etc2";
    }
    return "rgb565";
  }

  // ../../node_modules/@loaders.gl/textures/dist/basis-loader.js
  var BasisWorkerLoader = {
    name: "Basis",
    id: "basis",
    module: "textures",
    version: VERSION9,
    worker: true,
    extensions: ["basis", "ktx2"],
    mimeTypes: ["application/octet-stream", "image/ktx2"],
    tests: ["sB"],
    binary: true,
    options: {
      basis: {
        format: "auto",
        libraryPath: "libs/",
        containerFormat: "auto",
        module: "transcoder"
      }
    }
  };
  var BasisLoader = {
    ...BasisWorkerLoader,
    parse: parseBasis
  };

  // ../../node_modules/@luma.gl/gltf/dist/gltf/gltf-animator.js
  var ATTRIBUTE_TYPE_TO_COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var GLTFAnimation = class {
    name;
    startTime = 0;
    playing = true;
    speed = 1;
    channels = [];
    constructor(props) {
      Object.assign(this, props);
    }
    animate(timeMs) {
      if (!this.playing) {
        return;
      }
      const absTime = timeMs / 1e3;
      const time = (absTime - this.startTime) * this.speed;
      this.channels.forEach(({ sampler, target, path }) => {
        interpolate(time, sampler, target, path);
        applyTranslationRotationScale(target, target._node);
      });
    }
  };
  var GLTFAnimator = class {
    animations;
    constructor(gltf) {
      this.animations = gltf.animations.map((animation, index2) => {
        const name13 = animation.name || `Animation-${index2}`;
        const samplers = animation.samplers.map(({ input, interpolation = "LINEAR", output }) => ({
          input: accessorToJsArray(gltf.accessors[input]),
          interpolation,
          output: accessorToJsArray(gltf.accessors[output])
        }));
        const channels = animation.channels.map(({ sampler, target }) => ({
          sampler: samplers[sampler],
          target: gltf.nodes[target.node],
          path: target.path
        }));
        return new GLTFAnimation({ name: name13, channels });
      });
    }
    animate(time) {
      this.setTime(time);
    }
    setTime(time) {
      this.animations.forEach((animation) => animation.animate(time));
    }
    getAnimations() {
      return this.animations;
    }
  };
  function accessorToJsArray(accessor) {
    if (!accessor._animation) {
      const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
      const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
      const length6 = components * accessor.count;
      const { buffer, byteOffset } = accessor.bufferView.data;
      const array = new ArrayType2(buffer, byteOffset + (accessor.byteOffset || 0), length6);
      if (components === 1) {
        accessor._animation = Array.from(array);
      } else {
        const slicedArray = [];
        for (let i5 = 0; i5 < array.length; i5 += components) {
          slicedArray.push(Array.from(array.slice(i5, i5 + components)));
        }
        accessor._animation = slicedArray;
      }
    }
    return accessor._animation;
  }
  var helperMatrix = new Matrix4();
  function applyTranslationRotationScale(gltfNode, node2) {
    node2.matrix.identity();
    if (gltfNode.translation) {
      node2.matrix.translate(gltfNode.translation);
    }
    if (gltfNode.rotation) {
      const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);
      node2.matrix.multiplyRight(rotationMatrix);
    }
    if (gltfNode.scale) {
      node2.matrix.scale(gltfNode.scale);
    }
  }
  var quaternion = new Quaternion();
  function linearInterpolate(target, path, start, stop, ratio) {
    if (path === "rotation") {
      quaternion.slerp({ start, target: stop, ratio });
      for (let i5 = 0; i5 < quaternion.length; i5++) {
        target[path][i5] = quaternion[i5];
      }
    } else {
      for (let i5 = 0; i5 < start.length; i5++) {
        target[path][i5] = ratio * stop[i5] + (1 - ratio) * start[i5];
      }
    }
  }
  function cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t3 }) {
    for (let i5 = 0; i5 < target[path].length; i5++) {
      const m0 = outTangent0[i5] * tDiff;
      const m1 = inTangent1[i5] * tDiff;
      target[path][i5] = (2 * Math.pow(t3, 3) - 3 * Math.pow(t3, 2) + 1) * p0[i5] + (Math.pow(t3, 3) - 2 * Math.pow(t3, 2) + t3) * m0 + (-2 * Math.pow(t3, 3) + 3 * Math.pow(t3, 2)) * p1[i5] + (Math.pow(t3, 3) - Math.pow(t3, 2)) * m1;
    }
  }
  function stepInterpolate(target, path, value) {
    for (let i5 = 0; i5 < value.length; i5++) {
      target[path][i5] = value[i5];
    }
  }
  function interpolate(time, { input, interpolation, output }, target, path) {
    const maxTime = input[input.length - 1];
    const animationTime = time % maxTime;
    const nextIndex = input.findIndex((t3) => t3 >= animationTime);
    const previousIndex = Math.max(0, nextIndex - 1);
    if (!Array.isArray(target[path])) {
      switch (path) {
        case "translation":
          target[path] = [0, 0, 0];
          break;
        case "rotation":
          target[path] = [0, 0, 0, 1];
          break;
        case "scale":
          target[path] = [1, 1, 1];
          break;
        default:
          log2.warn(`Bad animation path ${path}`)();
      }
    }
    assert6(target[path].length === output[previousIndex].length);
    const previousTime = input[previousIndex];
    const nextTime = input[nextIndex];
    switch (interpolation) {
      case "STEP":
        stepInterpolate(target, path, output[previousIndex]);
        break;
      case "LINEAR":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
        }
        break;
      case "CUBICSPLINE":
        if (nextTime > previousTime) {
          const ratio = (animationTime - previousTime) / (nextTime - previousTime);
          const tDiff = nextTime - previousTime;
          const p0 = output[3 * previousIndex + 1];
          const outTangent0 = output[3 * previousIndex + 2];
          const inTangent1 = output[3 * nextIndex + 0];
          const p1 = output[3 * nextIndex + 1];
          cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });
        }
        break;
      default:
        log2.warn(`Interpolation ${interpolation} not supported`)();
        break;
    }
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/create-gltf-model.js
  var vs8 = `
#pragma vscode_glsllint_stage: vert
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  // _attr vec4 POSITION;
  _attr vec4 positions;

  #ifdef HAS_NORMALS
    // _attr vec4 NORMAL;
    _attr vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // _attr vec2 TEXCOORD_0;
    _attr vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }
`;
  var fs6 = `
#pragma vscode_glsllint_stage: frag
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;
  function createGLTFModel(device, options) {
    const { id, geometry, material, vertexCount, materialOptions, modelOptions } = options;
    const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);
    log2.info(4, "createGLTFModel defines: ", parsedMaterial.defines)();
    const managedResources = [];
    const parameters2 = {
      depthWriteEnabled: true,
      depthCompare: "less",
      depthFormat: "depth24plus",
      cullMode: "back"
    };
    const modelProps = {
      id,
      geometry,
      topology: geometry.topology,
      vertexCount,
      modules: [pbr],
      vs: addVersionToShader(device, vs8),
      fs: addVersionToShader(device, fs6),
      ...modelOptions,
      bindings: { ...parsedMaterial.bindings, ...modelOptions.bindings },
      defines: { ...parsedMaterial.defines, ...modelOptions.defines },
      parameters: { ...parameters2, ...parsedMaterial.parameters, ...modelOptions.parameters },
      uniforms: { ...parsedMaterial.uniforms, ...modelOptions.uniforms }
    };
    const model = new Model(device, modelProps);
    return new ModelNode({ managedResources, model });
  }
  function addVersionToShader(device, source) {
    return `#version 300 es
${source}`;
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/gltf-instantiator.js
  var DEFAULT_OPTIONS3 = {
    modelOptions: {},
    pbrDebug: false,
    imageBasedLightingEnvironment: null,
    lights: true,
    useTangents: false
  };
  var GLTFInstantiator = class {
    device;
    options;
    gltf;
    constructor(device, options = {}) {
      this.device = device;
      this.options = { ...DEFAULT_OPTIONS3, ...options };
    }
    instantiate(gltf) {
      this.gltf = gltf;
      const scenes = (gltf.scenes || []).map((scene) => this.createScene(scene));
      return scenes;
    }
    createAnimator() {
      if (Array.isArray(this.gltf.animations)) {
        return new GLTFAnimator(this.gltf);
      }
      return null;
    }
    createScene(gltfScene) {
      const gltfNodes = gltfScene.nodes || [];
      const nodes = gltfNodes.map((node2) => this.createNode(node2));
      const scene = new GroupNode({
        id: gltfScene.name || gltfScene.id,
        children: nodes
      });
      return scene;
    }
    createNode(gltfNode) {
      if (!gltfNode._node) {
        const gltfChildren = gltfNode.children || [];
        const children = gltfChildren.map((child) => this.createNode(child));
        if (gltfNode.mesh) {
          children.push(this.createMesh(gltfNode.mesh));
        }
        const node2 = new GroupNode({
          id: gltfNode.name || gltfNode.id,
          children
        });
        if (gltfNode.matrix) {
          node2.setMatrix(gltfNode.matrix);
        } else {
          node2.matrix.identity();
          if (gltfNode.translation) {
            node2.matrix.translate(gltfNode.translation);
          }
          if (gltfNode.rotation) {
            const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
            node2.matrix.multiplyRight(rotationMatrix);
          }
          if (gltfNode.scale) {
            node2.matrix.scale(gltfNode.scale);
          }
        }
        gltfNode._node = node2;
      }
      return gltfNode._node;
    }
    createMesh(gltfMesh) {
      if (!gltfMesh._mesh) {
        const gltfPrimitives = gltfMesh.primitives || [];
        const primitives = gltfPrimitives.map((gltfPrimitive, i5) => this.createPrimitive(gltfPrimitive, i5, gltfMesh));
        const mesh = new GroupNode({
          id: gltfMesh.name || gltfMesh.id,
          children: primitives
        });
        gltfMesh._mesh = mesh;
      }
      return gltfMesh._mesh;
    }
    createPrimitive(gltfPrimitive, i5, gltfMesh) {
      const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i5}`;
      const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);
      const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes);
      const modelNode = createGLTFModel(this.device, {
        id,
        geometry: this.createGeometry(id, gltfPrimitive, topology),
        material: gltfPrimitive.material,
        materialOptions: this.options,
        modelOptions: this.options.modelOptions,
        vertexCount
      });
      modelNode.bounds = [
        gltfPrimitive.attributes.POSITION.min,
        gltfPrimitive.attributes.POSITION.max
      ];
      return modelNode;
    }
    getVertexCount(attributes) {
      throw new Error("getVertexCount not implemented");
    }
    createGeometry(id, gltfPrimitive, topology) {
      const attributes = {};
      for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {
        const { components, size, value } = attribute;
        attributes[attributeName] = { size: size ?? components, value };
      }
      return new Geometry({
        id,
        topology,
        indices: gltfPrimitive.indices.value,
        attributes
      });
    }
    createBuffer(attribute, usage) {
      if (!attribute.bufferView) {
        attribute.bufferView = {};
      }
      const { bufferView } = attribute;
      if (!bufferView.lumaBuffers) {
        bufferView.lumaBuffers = {};
      }
      if (!bufferView.lumaBuffers[usage]) {
        bufferView.lumaBuffers[usage] = this.device.createBuffer({
          id: `from-${bufferView.id}`,
          data: bufferView.data || attribute.value
        });
      }
      return bufferView.lumaBuffers[usage];
    }
    createSampler(gltfSampler) {
      return gltfSampler;
    }
    needsPOT() {
      return false;
    }
  };
  var GLEnum3;
  (function(GLEnum4) {
    GLEnum4[GLEnum4["POINTS"] = 0] = "POINTS";
    GLEnum4[GLEnum4["LINES"] = 1] = "LINES";
    GLEnum4[GLEnum4["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum4[GLEnum4["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum4[GLEnum4["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum4[GLEnum4["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum4[GLEnum4["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  })(GLEnum3 || (GLEnum3 = {}));
  function convertGLDrawModeToTopology(drawMode) {
    switch (drawMode) {
      case GLEnum3.POINTS:
        return "point-list";
      case GLEnum3.LINES:
        return "line-list";
      case GLEnum3.LINE_STRIP:
        return "line-strip";
      case GLEnum3.LINE_LOOP:
        return "line-loop-webgl";
      case GLEnum3.TRIANGLES:
        return "triangle-list";
      case GLEnum3.TRIANGLE_STRIP:
        return "triangle-strip";
      case GLEnum3.TRIANGLE_FAN:
        return "triangle-fan-webgl";
      default:
        throw new Error(drawMode);
    }
  }

  // ../../node_modules/@luma.gl/gltf/dist/gltf/create-gltf-objects.js
  function createScenegraphsFromGLTF(device, gltf, options) {
    const instantiator = new GLTFInstantiator(device, options);
    const scenes = instantiator.instantiate(gltf);
    const animator = instantiator.createAnimator();
    return { scenes, animator };
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
  var EXT_mesh_features_exports = {};
  __export(EXT_mesh_features_exports, {
    decode: () => decode,
    name: () => name2
  });

  // ../../node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
  function assert10(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "assert failed: gltf");
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
  var COMPONENTS = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
  var MIPMAP_FACTOR = 1.33;
  var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
  var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]];
  var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
  var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  function getAccessorTypeFromSize(size) {
    const type = TYPES[size - 1];
    return type || TYPES[0];
  }
  function getComponentTypeFromArray(typedArray) {
    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
    if (!componentType) {
      throw new Error("Illegal typed array");
    }
    return componentType;
  }
  function getAccessorArrayTypeAndLength(accessor, bufferView) {
    const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
    const components = ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type];
    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
    const length6 = accessor.count * components;
    const byteLength = accessor.count * components * bytesPerComponent;
    assert10(byteLength >= 0 && byteLength <= bufferView.byteLength);
    const componentByteSize = BYTES[accessor.componentType];
    const numberOfComponentsInElement = COMPONENTS[accessor.type];
    return {
      ArrayType: ArrayType2,
      length: length6,
      byteLength,
      componentByteSize,
      numberOfComponentsInElement
    };
  }
  function getMemoryUsageGLTF(gltf) {
    let {
      images,
      bufferViews
    } = gltf;
    images = images || [];
    bufferViews = bufferViews || [];
    const imageBufferViews = images.map((i5) => i5.bufferView);
    bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));
    const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);
    const pixelCount = images.reduce((acc, image) => {
      const {
        width,
        height
      } = image.image;
      return acc + width * height;
    }, 0);
    return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
  function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
    const bufferView = json.bufferViews[bufferViewIndex];
    assert10(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = buffers[bufferIndex];
    assert10(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  function getTypedArrayForAccessor(json, buffers, accessor) {
    var _json$accessors, _json$bufferViews;
    const gltfAccessor = typeof accessor === "number" ? (_json$accessors = json.accessors) === null || _json$accessors === void 0 ? void 0 : _json$accessors[accessor] : accessor;
    if (!gltfAccessor) {
      throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
    }
    const bufferView = (_json$bufferViews = json.bufferViews) === null || _json$bufferViews === void 0 ? void 0 : _json$bufferViews[gltfAccessor.bufferView || 0];
    if (!bufferView) {
      throw new Error(`No gltf buffer view for accessor ${bufferView}`);
    }
    const {
      arrayBuffer: arrayBuffer2,
      byteOffset: bufferByteOffset
    } = buffers[bufferView.buffer];
    const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
    const {
      ArrayType: ArrayType2,
      length: length6,
      componentByteSize,
      numberOfComponentsInElement
    } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
    const elementByteSize = componentByteSize * numberOfComponentsInElement;
    const elementAddressScale = bufferView.byteStride || elementByteSize;
    if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
      const result2 = new ArrayType2(arrayBuffer2, byteOffset, length6);
      return result2;
    }
    const result = new ArrayType2(length6);
    for (let i5 = 0; i5 < gltfAccessor.count; i5++) {
      const values = new ArrayType2(arrayBuffer2, byteOffset + i5 * elementAddressScale, numberOfComponentsInElement);
      result.set(values, i5 * numberOfComponentsInElement);
    }
    return result;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
  function makeDefaultGLTFJson() {
    return {
      asset: {
        version: "2.0",
        generator: "loaders.gl"
      },
      buffers: [],
      extensions: {},
      extensionsRequired: [],
      extensionsUsed: []
    };
  }
  var GLTFScenegraph = class {
    constructor(gltf) {
      this.gltf = void 0;
      this.sourceBuffers = void 0;
      this.byteLength = void 0;
      this.gltf = {
        json: (gltf === null || gltf === void 0 ? void 0 : gltf.json) || makeDefaultGLTFJson(),
        buffers: (gltf === null || gltf === void 0 ? void 0 : gltf.buffers) || [],
        images: (gltf === null || gltf === void 0 ? void 0 : gltf.images) || []
      };
      this.sourceBuffers = [];
      this.byteLength = 0;
      if (this.gltf.buffers && this.gltf.buffers[0]) {
        this.byteLength = this.gltf.buffers[0].byteLength;
        this.sourceBuffers = [this.gltf.buffers[0]];
      }
    }
    get json() {
      return this.gltf.json;
    }
    getApplicationData(key) {
      const data = this.json[key];
      return data;
    }
    getExtraData(key) {
      const extras = this.json.extras || {};
      return extras[key];
    }
    hasExtension(extensionName) {
      const isUsedExtension = this.getUsedExtensions().find((name13) => name13 === extensionName);
      const isRequiredExtension = this.getRequiredExtensions().find((name13) => name13 === extensionName);
      return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
    }
    getExtension(extensionName) {
      const isExtension = this.getUsedExtensions().find((name13) => name13 === extensionName);
      const extensions = this.json.extensions || {};
      return isExtension ? extensions[extensionName] : null;
    }
    getRequiredExtension(extensionName) {
      const isRequired = this.getRequiredExtensions().find((name13) => name13 === extensionName);
      return isRequired ? this.getExtension(extensionName) : null;
    }
    getRequiredExtensions() {
      return this.json.extensionsRequired || [];
    }
    getUsedExtensions() {
      return this.json.extensionsUsed || [];
    }
    getRemovedExtensions() {
      return this.json.extensionsRemoved || [];
    }
    getObjectExtension(object, extensionName) {
      const extensions = object.extensions || {};
      return extensions[extensionName];
    }
    getScene(index2) {
      return this.getObject("scenes", index2);
    }
    getNode(index2) {
      return this.getObject("nodes", index2);
    }
    getSkin(index2) {
      return this.getObject("skins", index2);
    }
    getMesh(index2) {
      return this.getObject("meshes", index2);
    }
    getMaterial(index2) {
      return this.getObject("materials", index2);
    }
    getAccessor(index2) {
      return this.getObject("accessors", index2);
    }
    getTexture(index2) {
      return this.getObject("textures", index2);
    }
    getSampler(index2) {
      return this.getObject("samplers", index2);
    }
    getImage(index2) {
      return this.getObject("images", index2);
    }
    getBufferView(index2) {
      return this.getObject("bufferViews", index2);
    }
    getBuffer(index2) {
      return this.getObject("buffers", index2);
    }
    getObject(array, index2) {
      if (typeof index2 === "object") {
        return index2;
      }
      const object = this.json[array] && this.json[array][index2];
      if (!object) {
        throw new Error(`glTF file error: Could not find ${array}[${index2}]`);
      }
      return object;
    }
    getTypedArrayForBufferView(bufferView) {
      bufferView = this.getBufferView(bufferView);
      const bufferIndex = bufferView.buffer;
      const binChunk = this.gltf.buffers[bufferIndex];
      assert10(binChunk);
      const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
    }
    getTypedArrayForAccessor(accessor) {
      const gltfAccessor = this.getAccessor(accessor);
      return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
    }
    getTypedArrayForImageData(image) {
      image = this.getAccessor(image);
      const bufferView = this.getBufferView(image.bufferView);
      const buffer = this.getBuffer(bufferView.buffer);
      const arrayBuffer2 = buffer.data;
      const byteOffset = bufferView.byteOffset || 0;
      return new Uint8Array(arrayBuffer2, byteOffset, bufferView.byteLength);
    }
    addApplicationData(key, data) {
      this.json[key] = data;
      return this;
    }
    addExtraData(key, data) {
      this.json.extras = this.json.extras || {};
      this.json.extras[key] = data;
      return this;
    }
    addObjectExtension(object, extensionName, data) {
      object.extensions = object.extensions || {};
      object.extensions[extensionName] = data;
      this.registerUsedExtension(extensionName);
      return this;
    }
    setObjectExtension(object, extensionName, data) {
      const extensions = object.extensions || {};
      extensions[extensionName] = data;
    }
    removeObjectExtension(object, extensionName) {
      const extensions = (object === null || object === void 0 ? void 0 : object.extensions) || {};
      if (extensions[extensionName]) {
        this.json.extensionsRemoved = this.json.extensionsRemoved || [];
        const extensionsRemoved = this.json.extensionsRemoved;
        if (!extensionsRemoved.includes(extensionName)) {
          extensionsRemoved.push(extensionName);
        }
      }
      delete extensions[extensionName];
    }
    addExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert10(extensionData);
      this.json.extensions = this.json.extensions || {};
      this.json.extensions[extensionName] = extensionData;
      this.registerUsedExtension(extensionName);
      return extensionData;
    }
    addRequiredExtension(extensionName) {
      let extensionData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert10(extensionData);
      this.addExtension(extensionName, extensionData);
      this.registerRequiredExtension(extensionName);
      return extensionData;
    }
    registerUsedExtension(extensionName) {
      this.json.extensionsUsed = this.json.extensionsUsed || [];
      if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
        this.json.extensionsUsed.push(extensionName);
      }
    }
    registerRequiredExtension(extensionName) {
      this.registerUsedExtension(extensionName);
      this.json.extensionsRequired = this.json.extensionsRequired || [];
      if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
        this.json.extensionsRequired.push(extensionName);
      }
    }
    removeExtension(extensionName) {
      var _this$json$extensions;
      if ((_this$json$extensions = this.json.extensions) !== null && _this$json$extensions !== void 0 && _this$json$extensions[extensionName]) {
        this.json.extensionsRemoved = this.json.extensionsRemoved || [];
        const extensionsRemoved = this.json.extensionsRemoved;
        if (!extensionsRemoved.includes(extensionName)) {
          extensionsRemoved.push(extensionName);
        }
      }
      if (this.json.extensions) {
        delete this.json.extensions[extensionName];
      }
      if (this.json.extensionsRequired) {
        this._removeStringFromArray(this.json.extensionsRequired, extensionName);
      }
      if (this.json.extensionsUsed) {
        this._removeStringFromArray(this.json.extensionsUsed, extensionName);
      }
    }
    setDefaultScene(sceneIndex) {
      this.json.scene = sceneIndex;
    }
    addScene(scene) {
      const {
        nodeIndices
      } = scene;
      this.json.scenes = this.json.scenes || [];
      this.json.scenes.push({
        nodes: nodeIndices
      });
      return this.json.scenes.length - 1;
    }
    addNode(node2) {
      const {
        meshIndex,
        matrix
      } = node2;
      this.json.nodes = this.json.nodes || [];
      const nodeData = {
        mesh: meshIndex
      };
      if (matrix) {
        nodeData.matrix = matrix;
      }
      this.json.nodes.push(nodeData);
      return this.json.nodes.length - 1;
    }
    addMesh(mesh) {
      const {
        attributes,
        indices,
        material,
        mode = 4
      } = mesh;
      const accessors = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessors,
          mode
        }]
      };
      if (indices) {
        const indicesAccessor = this._addIndices(indices);
        glTFMesh.primitives[0].indices = indicesAccessor;
      }
      if (Number.isFinite(material)) {
        glTFMesh.primitives[0].material = material;
      }
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addPointCloud(attributes) {
      const accessorIndices = this._addAttributes(attributes);
      const glTFMesh = {
        primitives: [{
          attributes: accessorIndices,
          mode: 0
        }]
      };
      this.json.meshes = this.json.meshes || [];
      this.json.meshes.push(glTFMesh);
      return this.json.meshes.length - 1;
    }
    addImage(imageData, mimeTypeOpt) {
      const metadata = getBinaryImageMetadata(imageData);
      const mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);
      const bufferViewIndex = this.addBufferView(imageData);
      const glTFImage = {
        bufferView: bufferViewIndex,
        mimeType
      };
      this.json.images = this.json.images || [];
      this.json.images.push(glTFImage);
      return this.json.images.length - 1;
    }
    addBufferView(buffer) {
      let bufferIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;
      const byteLength = buffer.byteLength;
      assert10(Number.isFinite(byteLength));
      this.sourceBuffers = this.sourceBuffers || [];
      this.sourceBuffers.push(buffer);
      const glTFBufferView = {
        buffer: bufferIndex,
        byteOffset,
        byteLength
      };
      this.byteLength += padToNBytes(byteLength, 4);
      this.json.bufferViews = this.json.bufferViews || [];
      this.json.bufferViews.push(glTFBufferView);
      return this.json.bufferViews.length - 1;
    }
    addAccessor(bufferViewIndex, accessor) {
      const glTFAccessor = {
        bufferView: bufferViewIndex,
        type: getAccessorTypeFromSize(accessor.size),
        componentType: accessor.componentType,
        count: accessor.count,
        max: accessor.max,
        min: accessor.min
      };
      this.json.accessors = this.json.accessors || [];
      this.json.accessors.push(glTFAccessor);
      return this.json.accessors.length - 1;
    }
    addBinaryBuffer(sourceBuffer) {
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        size: 3
      };
      const bufferViewIndex = this.addBufferView(sourceBuffer);
      let minMax = {
        min: accessor.min,
        max: accessor.max
      };
      if (!minMax.min || !minMax.max) {
        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
      }
      const accessorDefaults = {
        size: accessor.size,
        componentType: getComponentTypeFromArray(sourceBuffer),
        count: Math.round(sourceBuffer.length / accessor.size),
        min: minMax.min,
        max: minMax.max
      };
      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
    }
    addTexture(texture) {
      const {
        imageIndex
      } = texture;
      const glTFTexture = {
        source: imageIndex
      };
      this.json.textures = this.json.textures || [];
      this.json.textures.push(glTFTexture);
      return this.json.textures.length - 1;
    }
    addMaterial(pbrMaterialInfo) {
      this.json.materials = this.json.materials || [];
      this.json.materials.push(pbrMaterialInfo);
      return this.json.materials.length - 1;
    }
    createBinaryChunk() {
      var _this$json, _this$json$buffers;
      this.gltf.buffers = [];
      const totalByteLength = this.byteLength;
      const arrayBuffer2 = new ArrayBuffer(totalByteLength);
      const targetArray = new Uint8Array(arrayBuffer2);
      let dstByteOffset = 0;
      for (const sourceBuffer of this.sourceBuffers || []) {
        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
      }
      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {
        this.json.buffers[0].byteLength = totalByteLength;
      } else {
        this.json.buffers = [{
          byteLength: totalByteLength
        }];
      }
      this.gltf.binary = arrayBuffer2;
      this.sourceBuffers = [arrayBuffer2];
    }
    _removeStringFromArray(array, string) {
      let found = true;
      while (found) {
        const index2 = array.indexOf(string);
        if (index2 > -1) {
          array.splice(index2, 1);
        } else {
          found = false;
        }
      }
    }
    _addAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const result = {};
      for (const attributeKey in attributes) {
        const attributeData = attributes[attributeKey];
        const attrName = this._getGltfAttributeName(attributeKey);
        const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
        result[attrName] = accessor;
      }
      return result;
    }
    _addIndices(indices) {
      return this.addBinaryBuffer(indices, {
        size: 1
      });
    }
    _getGltfAttributeName(attributeName) {
      switch (attributeName.toLowerCase()) {
        case "position":
        case "positions":
        case "vertices":
          return "POSITION";
        case "normal":
        case "normals":
          return "NORMAL";
        case "color":
        case "colors":
          return "COLOR_0";
        case "texcoord":
        case "texcoords":
          return "TEXCOORD_0";
        default:
          return attributeName;
      }
    }
    _getAccessorMinMax(buffer, size) {
      const result = {
        min: null,
        max: null
      };
      if (buffer.length < size) {
        return result;
      }
      result.min = [];
      result.max = [];
      const initValues = buffer.subarray(0, size);
      for (const value of initValues) {
        result.min.push(value);
        result.max.push(value);
      }
      for (let index2 = size; index2 < buffer.length; index2 += size) {
        for (let componentIndex = 0; componentIndex < size; componentIndex++) {
          result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index2 + componentIndex]);
          result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index2 + componentIndex]);
        }
      }
      return result;
    }
  };

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
  function emod(n3) {
    return (n3 % 1 + 1) % 1;
  }
  var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
    BOOLEAN: 1,
    STRING: 1,
    ENUM: 1
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3 = {
    INT8: Int8Array,
    UINT8: Uint8Array,
    INT16: Int16Array,
    UINT16: Uint16Array,
    INT32: Int32Array,
    UINT32: Uint32Array,
    INT64: BigInt64Array,
    UINT64: BigUint64Array,
    FLOAT32: Float32Array,
    FLOAT64: Float64Array
  };
  var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
    INT8: 1,
    UINT8: 1,
    INT16: 2,
    UINT16: 2,
    INT32: 4,
    UINT32: 4,
    INT64: 8,
    UINT64: 8,
    FLOAT32: 4,
    FLOAT64: 8
  };
  function getArrayElementByteSize(attributeType, componentType) {
    return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
  }
  function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
    if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
      return null;
    }
    const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
    const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, "SCALAR", offsetType, numberOfElements + 1);
    if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
      return null;
    }
    return arrayOffsets;
  }
  function convertRawBufferToMetadataArray(data, attributeType, componentType) {
    let elementCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
    const ArrayType2 = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3[componentType];
    const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
    const length6 = elementCount * numberOfComponents;
    const byteLength = length6 * size;
    let buffer = data.buffer;
    let offset = data.byteOffset;
    if (offset % size !== 0) {
      const bufferArray = new Uint8Array(buffer);
      buffer = bufferArray.slice(offset, offset + byteLength).buffer;
      offset = 0;
    }
    return new ArrayType2(buffer, offset, length6);
  }
  function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
    var _json$textures, _json$textures$textur;
    const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
    const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
    const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
    const json = scenegraph.gltf.json;
    const textureIndex = textureInfo.index;
    const imageIndex = (_json$textures = json.textures) === null || _json$textures === void 0 ? void 0 : (_json$textures$textur = _json$textures[textureIndex]) === null || _json$textures$textur === void 0 ? void 0 : _json$textures$textur.source;
    if (typeof imageIndex !== "undefined") {
      var _json$images, _json$images$imageInd, _scenegraph$gltf$imag;
      const mimeType = (_json$images = json.images) === null || _json$images === void 0 ? void 0 : (_json$images$imageInd = _json$images[imageIndex]) === null || _json$images$imageInd === void 0 ? void 0 : _json$images$imageInd.mimeType;
      const parsedImage = (_scenegraph$gltf$imag = scenegraph.gltf.images) === null || _scenegraph$gltf$imag === void 0 ? void 0 : _scenegraph$gltf$imag[imageIndex];
      if (parsedImage && typeof parsedImage.width !== "undefined") {
        const textureData = [];
        for (let index2 = 0; index2 < textureCoordinates.length; index2 += 2) {
          const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index2, textureInfo.channels);
          textureData.push(value);
        }
        return textureData;
      }
    }
    return [];
  }
  function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
    if (!(propertyData !== null && propertyData !== void 0 && propertyData.length)) {
      return;
    }
    const featureIndices = [];
    for (const texelData of propertyData) {
      let index2 = featureTable.findIndex((item) => item === texelData);
      if (index2 === -1) {
        index2 = featureTable.push(texelData) - 1;
      }
      featureIndices.push(index2);
    }
    const typedArray = new Uint32Array(featureIndices);
    const bufferIndex = scenegraph.gltf.buffers.push({
      arrayBuffer: typedArray.buffer,
      byteOffset: typedArray.byteOffset,
      byteLength: typedArray.byteLength
    }) - 1;
    const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
    const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
      size: 1,
      componentType: getComponentTypeFromArray(typedArray),
      count: typedArray.length
    });
    primitive.attributes[attributeName] = accessorIndex;
  }
  function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index2) {
    let channels = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
    const CHANNELS_MAP = {
      r: {
        offset: 0,
        shift: 0
      },
      g: {
        offset: 1,
        shift: 8
      },
      b: {
        offset: 2,
        shift: 16
      },
      a: {
        offset: 3,
        shift: 24
      }
    };
    const u3 = textureCoordinates[index2];
    const v2 = textureCoordinates[index2 + 1];
    let components = 1;
    if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
      components = 4;
    const offset = coordinatesToOffset(u3, v2, parsedImage, components);
    let value = 0;
    for (const c2 of channels) {
      const map3 = typeof c2 === "number" ? Object.values(CHANNELS_MAP)[c2] : CHANNELS_MAP[c2];
      const imageOffset = offset + map3.offset;
      const imageData = getImageData(parsedImage);
      if (imageData.data.length <= imageOffset) {
        throw new Error(`${imageData.data.length} <= ${imageOffset}`);
      }
      const imageValue = imageData.data[imageOffset];
      value |= imageValue << map3.shift;
    }
    return value;
  }
  function coordinatesToOffset(u3, v2, parsedImage) {
    let componentsCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    const w2 = parsedImage.width;
    const iX = emod(u3) * (w2 - 1);
    const indX = Math.round(iX);
    const h2 = parsedImage.height;
    const iY = emod(v2) * (h2 - 1);
    const indY = Math.round(iY);
    const components = parsedImage.components ? parsedImage.components : componentsCount;
    const offset = (indY * w2 + indX) * components;
    return offset;
  }
  function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
    const attributeValueArray = [];
    for (let index2 = 0; index2 < numberOfElements; index2++) {
      const arrayOffset = arrayOffsets[index2];
      const arrayByteSize = arrayOffsets[index2 + 1] - arrayOffsets[index2];
      if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
        break;
      }
      const typedArrayOffset = arrayOffset / valueSize;
      const elementCount = arrayByteSize / valueSize;
      attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
    }
    return attributeValueArray;
  }
  function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
    const attributeValueArray = [];
    for (let index2 = 0; index2 < numberOfElements; index2++) {
      const elementOffset = index2 * arrayCount;
      attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
    }
    return attributeValueArray;
  }
  function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
    if (arrayOffsets) {
      throw new Error("Not implemented - arrayOffsets for strings is specified");
    }
    if (stringOffsets) {
      const stringsArray = [];
      const textDecoder = new TextDecoder("utf8");
      let stringOffset = 0;
      for (let index2 = 0; index2 < numberOfElements; index2++) {
        const stringByteSize = stringOffsets[index2 + 1] - stringOffsets[index2];
        if (stringByteSize + stringOffset <= valuesDataBytes.length) {
          const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
          const stringAttribute = textDecoder.decode(stringData);
          stringsArray.push(stringAttribute);
          stringOffset += stringByteSize;
        }
      }
      return stringsArray;
    }
    return [];
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
  var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
  var name2 = EXT_MESH_FEATURES_NAME;
  async function decode(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtMeshFeatures(scenegraph, options);
  }
  function decodeExtMeshFeatures(scenegraph, options) {
    const json = scenegraph.gltf.json;
    if (!json.meshes) {
      return;
    }
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processMeshPrimitiveFeatures(scenegraph, primitive, options);
      }
    }
  }
  function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
    var _options$gltf, _primitive$extensions;
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.loadBuffers)) {
      return;
    }
    const extension = (_primitive$extensions = primitive.extensions) === null || _primitive$extensions === void 0 ? void 0 : _primitive$extensions[EXT_MESH_FEATURES_NAME];
    const featureIds = extension === null || extension === void 0 ? void 0 : extension.featureIds;
    if (!featureIds) {
      return;
    }
    for (const featureId of featureIds) {
      var _options$gltf2;
      let featureIdData;
      if (typeof featureId.attribute !== "undefined") {
        const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
        const accessorIndex = primitive.attributes[accessorKey];
        featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
      } else if (typeof featureId.texture !== "undefined" && options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadImages) {
        featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
      } else {
        featureIdData = [];
      }
      featureId.data = featureIdData;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
  var EXT_structural_metadata_exports = {};
  __export(EXT_structural_metadata_exports, {
    decode: () => decode2,
    name: () => name3
  });
  var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
  var name3 = EXT_STRUCTURAL_METADATA_NAME;
  async function decode2(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtStructuralMetadata(scenegraph, options);
  }
  function decodeExtStructuralMetadata(scenegraph, options) {
    var _options$gltf, _options$gltf2;
    if (!((_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.loadBuffers)) {
      return;
    }
    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
    if (!extension) {
      return;
    }
    if ((_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadImages) {
      decodePropertyTextures(scenegraph, extension);
    }
    decodePropertyTables(scenegraph, extension);
  }
  function decodePropertyTextures(scenegraph, extension) {
    const propertyTextures = extension.propertyTextures;
    const json = scenegraph.gltf.json;
    if (propertyTextures && json.meshes) {
      for (const mesh of json.meshes) {
        for (const primitive of mesh.primitives) {
          processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
        }
      }
    }
  }
  function decodePropertyTables(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const propertyTables = extension.propertyTables;
    if (schemaClasses && propertyTables) {
      for (const schemaName in schemaClasses) {
        const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
        if (propertyTable) {
          processPropertyTable(scenegraph, schema, propertyTable);
        }
      }
    }
  }
  function findPropertyTableByClass(propertyTables, schemaClassName) {
    for (const propertyTable of propertyTables) {
      if (propertyTable.class === schemaClassName) {
        return propertyTable;
      }
    }
    return null;
  }
  function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
    var _primitive$extensions;
    if (!propertyTextures) {
      return;
    }
    const primitiveExtension = (_primitive$extensions = primitive.extensions) === null || _primitive$extensions === void 0 ? void 0 : _primitive$extensions[EXT_STRUCTURAL_METADATA_NAME];
    const primitivePropertyTextureIndices = primitiveExtension === null || primitiveExtension === void 0 ? void 0 : primitiveExtension.propertyTextures;
    if (!primitivePropertyTextureIndices) {
      return;
    }
    for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
      const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
      processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
    }
  }
  function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
    if (!propertyTexture.properties) {
      return;
    }
    if (!extension.dataAttributeNames) {
      extension.dataAttributeNames = [];
    }
    const className = propertyTexture.class;
    for (const propertyName in propertyTexture.properties) {
      var _propertyTexture$prop;
      const attributeName = `${className}_${propertyName}`;
      const textureInfoTopLevel = (_propertyTexture$prop = propertyTexture.properties) === null || _propertyTexture$prop === void 0 ? void 0 : _propertyTexture$prop[propertyName];
      if (!textureInfoTopLevel) {
        continue;
      }
      if (!textureInfoTopLevel.data) {
        textureInfoTopLevel.data = [];
      }
      const featureTextureTable = textureInfoTopLevel.data;
      const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
      if (propertyData === null) {
        continue;
      }
      primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
      textureInfoTopLevel.data = featureTextureTable;
      extension.dataAttributeNames.push(attributeName);
    }
  }
  function processPropertyTable(scenegraph, schema, propertyTable) {
    var _schema$classes;
    const schemaClass = (_schema$classes = schema.classes) === null || _schema$classes === void 0 ? void 0 : _schema$classes[propertyTable.class];
    if (!schemaClass) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
    }
    const numberOfElements = propertyTable.count;
    for (const propertyName in schemaClass.properties) {
      var _propertyTable$proper;
      const classProperty = schemaClass.properties[propertyName];
      const propertyTableProperty = (_propertyTable$proper = propertyTable.properties) === null || _propertyTable$proper === void 0 ? void 0 : _propertyTable$proper[propertyName];
      if (propertyTableProperty) {
        const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
        propertyTableProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
    let data = [];
    const valuesBufferView = propertyTableProperty.values;
    const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
    const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
    switch (classProperty.type) {
      case "SCALAR":
      case "VEC2":
      case "VEC3":
      case "VEC4":
      case "MAT2":
      case "MAT3":
      case "MAT4": {
        data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
        break;
      }
      case "BOOLEAN": {
        throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
      }
      case "STRING": {
        data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
        break;
      }
      case "ENUM": {
        data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
        break;
      }
      default:
        throw new Error(`Unknown classProperty type ${classProperty.type}`);
    }
    return data;
  }
  function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (classProperty.array && typeof classProperty.count === "undefined" && typeof propertyTableProperty.arrayOffsets !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
    if (typeof propertyTableProperty.stringOffsets !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    const isArray4 = classProperty.array;
    const arrayCount = classProperty.count;
    const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    let valuesData;
    if (classProperty.componentType) {
      valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, classProperty.componentType, elementCount);
    } else {
      valuesData = valuesDataBytes;
    }
    if (isArray4) {
      if (arrayOffsets) {
        return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
      }
      if (arrayCount) {
        return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
      }
      return [];
    }
    return valuesData;
  }
  function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    var _schema$enums;
    const enumType = classProperty.enumType;
    if (!enumType) {
      throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
    }
    const enumEntry = (_schema$enums = schema.enums) === null || _schema$enums === void 0 ? void 0 : _schema$enums[enumType];
    if (!enumEntry) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
    }
    const enumValueType = enumEntry.valueType || "UINT16";
    const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
    if (!valuesData) {
      valuesData = valuesDataBytes;
    }
    if (classProperty.array) {
      if (arrayOffsets) {
        return parseVariableLengthArrayENUM({
          valuesData,
          numberOfElements,
          arrayOffsets,
          valuesDataBytesLength: valuesDataBytes.length,
          elementSize,
          enumEntry
        });
      }
      const arrayCount = classProperty.count;
      if (arrayCount) {
        return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
      }
      return [];
    }
    return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
  }
  function parseVariableLengthArrayENUM(params) {
    const {
      valuesData,
      numberOfElements,
      arrayOffsets,
      valuesDataBytesLength,
      elementSize,
      enumEntry
    } = params;
    const attributeValueArray = [];
    for (let index2 = 0; index2 < numberOfElements; index2++) {
      const arrayOffset = arrayOffsets[index2];
      const arrayByteSize = arrayOffsets[index2 + 1] - arrayOffsets[index2];
      if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
        break;
      }
      const typedArrayOffset = arrayOffset / elementSize;
      const elementCount = arrayByteSize / elementSize;
      const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
      attributeValueArray.push(array);
    }
    return attributeValueArray;
  }
  function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
    const attributeValueArray = [];
    for (let index2 = 0; index2 < numberOfElements; index2++) {
      const elementOffset = arrayCount * index2;
      const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
      attributeValueArray.push(array);
    }
    return attributeValueArray;
  }
  function getEnumsArray(valuesData, offset, count2, enumEntry) {
    const array = [];
    for (let i5 = 0; i5 < count2; i5++) {
      if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
        array.push("");
      } else {
        const value = valuesData[offset + i5];
        const enumObject = getEnumByValue(enumEntry, value);
        if (enumObject) {
          array.push(enumObject.name);
        } else {
          array.push("");
        }
      }
    }
    return array;
  }
  function getEnumByValue(enumEntry, value) {
    for (const enumValue of enumEntry.values) {
      if (enumValue.value === value) {
        return enumValue;
      }
    }
    return null;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
  var EXT_feature_metadata_exports = {};
  __export(EXT_feature_metadata_exports, {
    decode: () => decode3,
    name: () => name4
  });
  var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
  var name4 = EXT_FEATURE_METADATA_NAME;
  async function decode3(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    decodeExtFeatureMetadata(scenegraph, options);
  }
  function decodeExtFeatureMetadata(scenegraph, options) {
    var _options$gltf, _options$gltf2;
    if (!((_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.loadBuffers)) {
      return;
    }
    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
    if (!extension) {
      return;
    }
    if ((_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadImages) {
      decodePropertyTextures2(scenegraph, extension);
    }
    decodePropertyTables2(scenegraph, extension);
  }
  function decodePropertyTextures2(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const {
      featureTextures
    } = extension;
    if (schemaClasses && featureTextures) {
      for (const schemaName in schemaClasses) {
        const schemaClass = schemaClasses[schemaName];
        const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
        if (featureTexture) {
          handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
        }
      }
    }
  }
  function decodePropertyTables2(scenegraph, extension) {
    const schema = extension.schema;
    if (!schema) {
      return;
    }
    const schemaClasses = schema.classes;
    const propertyTables = extension.featureTables;
    if (schemaClasses && propertyTables) {
      for (const schemaName in schemaClasses) {
        const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
        if (propertyTable) {
          processPropertyTable2(scenegraph, schema, propertyTable);
        }
      }
    }
  }
  function findPropertyTableByClass2(propertyTables, schemaClassName) {
    for (const propertyTableName in propertyTables) {
      const propertyTable = propertyTables[propertyTableName];
      if (propertyTable.class === schemaClassName) {
        return propertyTable;
      }
    }
    return null;
  }
  function findFeatureTextureByClass(featureTextures, schemaClassName) {
    for (const featureTexturesName in featureTextures) {
      const featureTable = featureTextures[featureTexturesName];
      if (featureTable.class === schemaClassName) {
        return featureTable;
      }
    }
    return null;
  }
  function processPropertyTable2(scenegraph, schema, propertyTable) {
    var _schema$classes;
    if (!propertyTable.class) {
      return;
    }
    const schemaClass = (_schema$classes = schema.classes) === null || _schema$classes === void 0 ? void 0 : _schema$classes[propertyTable.class];
    if (!schemaClass) {
      throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
    }
    const numberOfElements = propertyTable.count;
    for (const propertyName in schemaClass.properties) {
      var _propertyTable$proper;
      const classProperty = schemaClass.properties[propertyName];
      const propertyTableProperty = (_propertyTable$proper = propertyTable.properties) === null || _propertyTable$proper === void 0 ? void 0 : _propertyTable$proper[propertyName];
      if (propertyTableProperty) {
        const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
        propertyTableProperty.data = data;
      }
    }
  }
  function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
    const attributeName = featureTexture.class;
    for (const propertyName in schemaClass.properties) {
      var _featureTexture$prope;
      const featureTextureProperty = featureTexture === null || featureTexture === void 0 ? void 0 : (_featureTexture$prope = featureTexture.properties) === null || _featureTexture$prope === void 0 ? void 0 : _featureTexture$prope[propertyName];
      if (featureTextureProperty) {
        const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
        featureTextureProperty.data = data;
      }
    }
  }
  function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
    let data = [];
    const bufferView = featureTableProperty.bufferView;
    const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
    const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
    const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
    if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
      data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
    } else if (isNumericProperty(classProperty)) {
      data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
    }
    return data;
  }
  function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (classProperty.type === "ARRAY" && typeof classProperty.componentCount === "undefined" && typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
    if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
      return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || "UINT32", numberOfElements);
    }
    return null;
  }
  function isNumericProperty(schemaProperty) {
    const types = ["UINT8", "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", "FLOAT32", "FLOAT64"];
    return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
  }
  function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
    const isArray4 = classProperty.type === "ARRAY";
    const arrayCount = classProperty.componentCount;
    const attributeType = "SCALAR";
    const componentType = classProperty.componentType || classProperty.type;
    const elementSize = getArrayElementByteSize(attributeType, componentType);
    const elementCount = valuesDataBytes.byteLength / elementSize;
    const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
    if (isArray4) {
      if (arrayOffsets) {
        return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
      }
      if (arrayCount) {
        return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
      }
      return [];
    }
    return valuesData;
  }
  function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
    const json = scenegraph.gltf.json;
    if (!json.meshes) {
      return [];
    }
    const featureTextureTable = [];
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
      }
    }
    return featureTextureTable;
  }
  function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
    const textureInfoTopLevel = {
      channels: featureTextureProperty.channels,
      ...featureTextureProperty.texture
    };
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (!propertyData) {
      return;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
  var VERSION10 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
  var LITTLE_ENDIAN2 = true;
  var MAGIC_glTF = 1735152710;
  var GLB_FILE_HEADER_SIZE = 12;
  var GLB_CHUNK_HEADER_SIZE = 8;
  var GLB_CHUNK_TYPE_JSON = 1313821514;
  var GLB_CHUNK_TYPE_BIN = 5130562;
  var GLB_V1_CONTENT_FORMAT_JSON = 0;
  var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
  var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
  function getMagicString3(dataView) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
  }
  function isGLB(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const dataView = new DataView(arrayBuffer2);
    const {
      magic = MAGIC_glTF
    } = options;
    const magic1 = dataView.getUint32(byteOffset, false);
    return magic1 === magic || magic1 === MAGIC_glTF;
  }
  function parseGLBSync(glb, arrayBuffer2) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const dataView = new DataView(arrayBuffer2);
    const type = getMagicString3(dataView, byteOffset + 0);
    const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN2);
    Object.assign(glb, {
      header: {
        byteOffset,
        byteLength,
        hasBinChunk: false
      },
      type,
      version,
      json: {},
      binChunks: []
    });
    byteOffset += GLB_FILE_HEADER_SIZE;
    switch (glb.version) {
      case 1:
        return parseGLBV1(glb, dataView, byteOffset);
      case 2:
        return parseGLBV2(glb, dataView, byteOffset, options = {});
      default:
        throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
    }
  }
  function parseGLBV1(glb, dataView, byteOffset) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
    const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
    parseJSONChunk(glb, dataView, byteOffset, contentLength);
    byteOffset += contentLength;
    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
    return byteOffset;
  }
  function parseGLBV2(glb, dataView, byteOffset, options) {
    assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
    parseGLBChunksSync(glb, dataView, byteOffset, options);
    return byteOffset + glb.header.byteLength;
  }
  function parseGLBChunksSync(glb, dataView, byteOffset, options) {
    while (byteOffset + 8 <= glb.header.byteLength) {
      const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
      const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
      byteOffset += GLB_CHUNK_HEADER_SIZE;
      switch (chunkFormat) {
        case GLB_CHUNK_TYPE_JSON:
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_BIN:
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
          break;
        case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseJSONChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
          if (!options.strict) {
            parseBINChunk(glb, dataView, byteOffset, chunkLength);
          }
          break;
        default:
          break;
      }
      byteOffset += padToNBytes(chunkLength, 4);
    }
    return byteOffset;
  }
  function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
    const textDecoder = new TextDecoder("utf8");
    const jsonText = textDecoder.decode(jsonChunk);
    glb.json = JSON.parse(jsonText);
    return padToNBytes(chunkLength, 4);
  }
  function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
    glb.header.hasBinChunk = true;
    glb.binChunks.push({
      byteOffset,
      byteLength: chunkLength,
      arrayBuffer: dataView.buffer
    });
    return padToNBytes(chunkLength, 4);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
  function resolveUrl(url, options) {
    const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
    if (absolute) {
      return url;
    }
    const baseUrl = options.baseUri || options.uri;
    if (!baseUrl) {
      throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
    }
    return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
  var EXT_meshopt_compression_exports = {};
  __export(EXT_meshopt_compression_exports, {
    decode: () => decode5,
    name: () => name5
  });

  // ../../node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
  var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
  var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
  var FILTERS = {
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var DECODERS = {
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  async function meshoptDecodeGltfBuffer(target, count2, size, source, mode) {
    let filter = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
    const instance = await loadWasmInstance();
    decode4(instance, instance.exports[DECODERS[mode]], target, count2, size, source, instance.exports[FILTERS[filter || "NONE"]]);
  }
  var wasmPromise;
  async function loadWasmInstance() {
    if (!wasmPromise) {
      wasmPromise = loadWasmModule();
    }
    return wasmPromise;
  }
  async function loadWasmModule() {
    let wasm2 = wasm_base;
    if (WebAssembly.validate(detector)) {
      wasm2 = wasm_simd;
      console.log("Warning: meshopt_decoder is using experimental SIMD support");
    }
    const result = await WebAssembly.instantiate(unpack(wasm2), {});
    await result.instance.exports.__wasm_call_ctors();
    return result.instance;
  }
  function unpack(data) {
    const result = new Uint8Array(data.length);
    for (let i5 = 0; i5 < data.length; ++i5) {
      const ch = data.charCodeAt(i5);
      result[i5] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
    }
    let write = 0;
    for (let i5 = 0; i5 < data.length; ++i5) {
      result[write++] = result[i5] < 60 ? wasmpack[result[i5]] : (result[i5] - 60) * 64 + result[++i5];
    }
    return result.buffer.slice(0, write);
  }
  function decode4(instance, fun, target, count2, size, source, filter) {
    const sbrk = instance.exports.sbrk;
    const count4 = count2 + 3 & ~3;
    const tp = sbrk(count4 * size);
    const sp = sbrk(source.length);
    const heap = new Uint8Array(instance.exports.memory.buffer);
    heap.set(source, sp);
    const res = fun(tp, count2, size, sp, source.length);
    if (res === 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count2 * size));
    sbrk(tp - sbrk(0));
    if (res !== 0) {
      throw new Error(`Malformed buffer data: ${res}`);
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
  var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
  var name5 = EXT_MESHOPT_COMPRESSION;
  async function decode5(gltfData, options) {
    var _options$gltf, _options$gltf2;
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) || !((_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers)) {
      return;
    }
    const promises = [];
    for (const bufferViewIndex of gltfData.json.bufferViews || []) {
      promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
    }
    await Promise.all(promises);
    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
  }
  async function decodeMeshoptBufferView(scenegraph, bufferView) {
    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    if (meshoptExtension) {
      const {
        byteOffset = 0,
        byteLength = 0,
        byteStride,
        count: count2,
        mode,
        filter = "NONE",
        buffer: bufferIndex
      } = meshoptExtension;
      const buffer = scenegraph.gltf.buffers[bufferIndex];
      const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
      const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
      await meshoptDecodeGltfBuffer(result, count2, byteStride, source, mode, filter);
      scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
  var EXT_texture_webp_exports = {};
  __export(EXT_texture_webp_exports, {
    name: () => name6,
    preprocess: () => preprocess
  });
  var EXT_TEXTURE_WEBP = "EXT_texture_webp";
  var name6 = EXT_TEXTURE_WEBP;
  function preprocess(gltfData, options) {
    const scenegraph = new GLTFScenegraph(gltfData);
    if (!isImageFormatSupported("image/webp")) {
      if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
        throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
      }
      return;
    }
    const {
      json
    } = scenegraph;
    for (const texture of json.textures || []) {
      const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
      if (extension) {
        texture.source = extension.source;
      }
      scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
    }
    scenegraph.removeExtension(EXT_TEXTURE_WEBP);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
  var KHR_texture_basisu_exports = {};
  __export(KHR_texture_basisu_exports, {
    name: () => name7,
    preprocess: () => preprocess2
  });
  var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
  var name7 = KHR_TEXTURE_BASISU;
  function preprocess2(gltfData, options) {
    const scene = new GLTFScenegraph(gltfData);
    const {
      json
    } = scene;
    for (const texture of json.textures || []) {
      const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
      if (extension) {
        texture.source = extension.source;
        scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
      }
    }
    scene.removeExtension(KHR_TEXTURE_BASISU);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_draco_mesh_compression_exports = {};
  __export(KHR_draco_mesh_compression_exports, {
    decode: () => decode6,
    encode: () => encode,
    name: () => name8,
    preprocess: () => preprocess3
  });

  // ../../node_modules/@loaders.gl/draco/dist/lib/utils/version.js
  var VERSION11 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/draco/dist/draco-loader.js
  var DracoLoader = {
    name: "Draco",
    id: "draco",
    module: "draco",
    version: VERSION11,
    worker: true,
    extensions: ["drc"],
    mimeTypes: ["application/octet-stream"],
    binary: true,
    tests: ["DRACO"],
    options: {
      draco: {
        decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
        libraryPath: "libs/",
        extraAttributes: {},
        attributeNameEntry: void 0
      }
    }
  };

  // ../../node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
  function getDracoSchema(attributes, loaderData, indices) {
    const metadata = makeMetadata(loaderData.metadata);
    const fields = [];
    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
      fields.push(field);
    }
    if (indices) {
      const indicesField = getArrowFieldFromAttribute("indices", indices);
      fields.push(indicesField);
    }
    return {
      fields,
      metadata
    };
  }
  function transformAttributesLoaderData(loaderData) {
    const result = {};
    for (const key in loaderData) {
      const dracoAttribute = loaderData[key];
      result[dracoAttribute.name || "undefined"] = dracoAttribute;
    }
    return result;
  }
  function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
    const field = deduceMeshField(attributeName, attribute, metadataMap);
    return field;
  }
  function makeMetadata(metadata) {
    Object.entries(metadata);
    const serializedMetadata = {};
    for (const key in metadata) {
      serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
    }
    return serializedMetadata;
  }

  // ../../node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
  var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
    POSITION: "POSITION",
    NORMAL: "NORMAL",
    COLOR: "COLOR_0",
    TEX_COORD: "TEXCOORD_0"
  };
  var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
    1: Int8Array,
    2: Uint8Array,
    3: Int16Array,
    4: Uint16Array,
    5: Int32Array,
    6: Uint32Array,
    9: Float32Array
  };
  var INDEX_ITEM_SIZE = 4;
  var DracoParser = class {
    constructor(draco) {
      this.draco = void 0;
      this.decoder = void 0;
      this.metadataQuerier = void 0;
      this.draco = draco;
      this.decoder = new this.draco.Decoder();
      this.metadataQuerier = new this.draco.MetadataQuerier();
    }
    destroy() {
      this.draco.destroy(this.decoder);
      this.draco.destroy(this.metadataQuerier);
    }
    parseSync(arrayBuffer2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer2), arrayBuffer2.byteLength);
      this._disableAttributeTransforms(options);
      const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
      const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
      try {
        let dracoStatus;
        switch (geometry_type) {
          case this.draco.TRIANGULAR_MESH:
            dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            break;
          case this.draco.POINT_CLOUD:
            dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            break;
          default:
            throw new Error("DRACO: Unknown geometry type.");
        }
        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          const message2 = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
          throw new Error(message2);
        }
        const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
        const geometry = this._getMeshData(dracoGeometry, loaderData, options);
        const boundingBox = getMeshBoundingBox(geometry.attributes);
        const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
        const data = {
          loader: "draco",
          loaderData,
          header: {
            vertexCount: dracoGeometry.num_points(),
            boundingBox
          },
          ...geometry,
          schema
        };
        return data;
      } finally {
        this.draco.destroy(buffer);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
      }
    }
    _getDracoLoaderData(dracoGeometry, geometry_type, options) {
      const metadata = this._getTopLevelMetadata(dracoGeometry);
      const attributes = this._getDracoAttributes(dracoGeometry, options);
      return {
        geometry_type,
        num_attributes: dracoGeometry.num_attributes(),
        num_points: dracoGeometry.num_points(),
        num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
        metadata,
        attributes
      };
    }
    _getDracoAttributes(dracoGeometry, options) {
      const dracoAttributes = {};
      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
        const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
        dracoAttributes[dracoAttribute.unique_id()] = {
          unique_id: dracoAttribute.unique_id(),
          attribute_type: dracoAttribute.attribute_type(),
          data_type: dracoAttribute.data_type(),
          num_components: dracoAttribute.num_components(),
          byte_offset: dracoAttribute.byte_offset(),
          byte_stride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          attribute_index: attributeId,
          metadata
        };
        const quantization = this._getQuantizationTransform(dracoAttribute, options);
        if (quantization) {
          dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
        }
        const octahedron = this._getOctahedronTransform(dracoAttribute, options);
        if (octahedron) {
          dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
        }
      }
      return dracoAttributes;
    }
    _getMeshData(dracoGeometry, loaderData, options) {
      const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
      const positionAttribute = attributes.POSITION;
      if (!positionAttribute) {
        throw new Error("DRACO: No position attribute found.");
      }
      if (dracoGeometry instanceof this.draco.Mesh) {
        switch (options.topology) {
          case "triangle-strip":
            return {
              topology: "triangle-strip",
              mode: 4,
              attributes,
              indices: {
                value: this._getTriangleStripIndices(dracoGeometry),
                size: 1
              }
            };
          case "triangle-list":
          default:
            return {
              topology: "triangle-list",
              mode: 5,
              attributes,
              indices: {
                value: this._getTriangleListIndices(dracoGeometry),
                size: 1
              }
            };
        }
      }
      return {
        topology: "point-list",
        mode: 0,
        attributes
      };
    }
    _getMeshAttributes(loaderData, dracoGeometry, options) {
      const attributes = {};
      for (const loaderAttribute of Object.values(loaderData.attributes)) {
        const attributeName = this._deduceAttributeName(loaderAttribute, options);
        loaderAttribute.name = attributeName;
        const {
          value,
          size
        } = this._getAttributeValues(dracoGeometry, loaderAttribute);
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
      return attributes;
    }
    _getTriangleListIndices(dracoGeometry) {
      const numFaces = dracoGeometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * INDEX_ITEM_SIZE;
      const ptr = this.draco._malloc(byteLength);
      try {
        this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
        return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
      } finally {
        this.draco._free(ptr);
      }
    }
    _getTriangleStripIndices(dracoGeometry) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
        return getUint32Array(dracoArray);
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _getAttributeValues(dracoGeometry, attribute) {
      const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
      const numComponents = attribute.num_components;
      const numPoints = dracoGeometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
      const dataType = getDracoDataType(this.draco, TypedArrayCtor);
      let value;
      const ptr = this.draco._malloc(byteLength);
      try {
        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
        this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
        value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
      } finally {
        this.draco._free(ptr);
      }
      return {
        value,
        size: numComponents
      };
    }
    _deduceAttributeName(attribute, options) {
      const uniqueId = attribute.unique_id;
      for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
        if (attributeUniqueId === uniqueId) {
          return attributeName;
        }
      }
      const thisAttributeType = attribute.attribute_type;
      for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        const attributeType = this.draco[dracoAttributeConstant];
        if (attributeType === thisAttributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }
      const entryName = options.attributeNameEntry || "name";
      if (attribute.metadata[entryName]) {
        return attribute.metadata[entryName].string;
      }
      return `CUSTOM_ATTRIBUTE_${uniqueId}`;
    }
    _getTopLevelMetadata(dracoGeometry) {
      const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getAttributeMetadata(dracoGeometry, attributeId) {
      const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._getDracoMetadata(dracoMetadata);
    }
    _getDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }
      const result = {};
      const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
      for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
      }
      return result;
    }
    _getDracoMetadataField(dracoMetadata, entryName) {
      const dracoArray = new this.draco.DracoInt32Array();
      try {
        this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
        const intArray = getInt32Array(dracoArray);
        return {
          int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray
        };
      } finally {
        this.draco.destroy(dracoArray);
      }
    }
    _disableAttributeTransforms(options) {
      const {
        quantizedAttributes = [],
        octahedronAttributes = []
      } = options;
      const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
      for (const dracoAttributeName of skipAttributes) {
        this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
      }
    }
    _getQuantizationTransform(dracoAttribute, options) {
      const {
        quantizedAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (skip) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits(),
              range: transform2.range(),
              min_values: new Float32Array([1, 2, 3]).map((i5) => transform2.min_value(i5))
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
    _getOctahedronTransform(dracoAttribute, options) {
      const {
        octahedronAttributes = []
      } = options;
      const attribute_type = dracoAttribute.attribute_type();
      const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
      if (octahedron) {
        const transform2 = new this.draco.AttributeQuantizationTransform();
        try {
          if (transform2.InitFromAttribute(dracoAttribute)) {
            return {
              quantization_bits: transform2.quantization_bits()
            };
          }
        } finally {
          this.draco.destroy(transform2);
        }
      }
      return null;
    }
  };
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
      default:
        return draco.DT_INVALID;
    }
  }
  function getInt32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i5 = 0; i5 < numValues; i5++) {
      intArray[i5] = dracoArray.GetValue(i5);
    }
    return intArray;
  }
  function getUint32Array(dracoArray) {
    const numValues = dracoArray.size();
    const intArray = new Int32Array(numValues);
    for (let i5 = 0; i5 < numValues; i5++) {
      intArray[i5] = dracoArray.GetValue(i5);
    }
    return intArray;
  }

  // ../../node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
  var DRACO_DECODER_VERSION = "1.5.6";
  var DRACO_ENCODER_VERSION = "1.4.1";
  var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
  var DRACO_EXTERNAL_LIBRARIES = {
    DECODER: "draco_wasm_wrapper.js",
    DECODER_WASM: "draco_decoder.wasm",
    FALLBACK_DECODER: "draco_decoder.js",
    ENCODER: "draco_encoder.js"
  };
  var DRACO_EXTERNAL_LIBRARY_URLS = {
    [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
    [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
    [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
    [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
  };
  var loadDecoderPromise;
  async function loadDracoDecoderModule(options) {
    const modules = options.modules || {};
    if (modules.draco3d) {
      loadDecoderPromise = loadDecoderPromise || modules.draco3d.createDecoderModule({}).then((draco) => {
        return {
          draco
        };
      });
    } else {
      loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
    }
    return await loadDecoderPromise;
  }
  async function loadDracoDecoder(options) {
    let DracoDecoderModule;
    let wasmBinary;
    switch (options.draco && options.draco.decoderType) {
      case "js":
        DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
        break;
      case "wasm":
      default:
        [DracoDecoderModule, wasmBinary] = await Promise.all([await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER), await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)]);
    }
    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
  }
  function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
    const options = {};
    if (wasmBinary) {
      options.wasmBinary = wasmBinary;
    }
    return new Promise((resolve2) => {
      DracoDecoderModule({
        ...options,
        onModuleLoaded: (draco) => resolve2({
          draco
        })
      });
    });
  }

  // ../../node_modules/@loaders.gl/draco/dist/index.js
  var DracoLoader2 = {
    ...DracoLoader,
    parse: parse2
  };
  async function parse2(arrayBuffer2, options) {
    const {
      draco
    } = await loadDracoDecoderModule(options);
    const dracoParser = new DracoParser(draco);
    try {
      return dracoParser.parseSync(arrayBuffer2, options === null || options === void 0 ? void 0 : options.draco);
    } finally {
      dracoParser.destroy();
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
  function getGLTFAccessors(attributes) {
    const accessors = {};
    for (const name13 in attributes) {
      const attribute = attributes[name13];
      if (name13 !== "indices") {
        const glTFAccessor = getGLTFAccessor(attribute);
        accessors[name13] = glTFAccessor;
      }
    }
    return accessors;
  }
  function getGLTFAccessor(attribute) {
    const {
      buffer,
      size,
      count: count2
    } = getAccessorData(attribute);
    const glTFAccessor = {
      value: buffer,
      size,
      byteOffset: 0,
      count: count2,
      type: getAccessorTypeFromSize(size),
      componentType: getComponentTypeFromArray(buffer)
    };
    return glTFAccessor;
  }
  function getAccessorData(attribute) {
    let buffer = attribute;
    let size = 1;
    let count2 = 0;
    if (attribute && attribute.value) {
      buffer = attribute.value;
      size = attribute.size || 1;
    }
    if (buffer) {
      if (!ArrayBuffer.isView(buffer)) {
        buffer = toTypedArray(buffer, Float32Array);
      }
      count2 = buffer.length / size;
    }
    return {
      buffer,
      size,
      count: count2
    };
  }
  function toTypedArray(array, ArrayType2) {
    let convertTypedArrays = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!array) {
      return null;
    }
    if (Array.isArray(array)) {
      return new ArrayType2(array);
    }
    if (convertTypedArrays && !(array instanceof ArrayType2)) {
      return new ArrayType2(array);
    }
    return array;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
  var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
  var name8 = KHR_DRACO_MESH_COMPRESSION;
  function preprocess3(gltfData, options, context) {
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      }
    }
  }
  async function decode6(gltfData, options, context) {
    var _options$gltf;
    if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {
      return;
    }
    const scenegraph = new GLTFScenegraph(gltfData);
    const promises = [];
    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
        promises.push(decompressPrimitive(scenegraph, primitive, options, context));
      }
    }
    await Promise.all(promises);
    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
  }
  function encode(gltfData) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const scenegraph = new GLTFScenegraph(gltfData);
    for (const mesh of scenegraph.json.meshes || []) {
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
    }
  }
  async function decompressPrimitive(scenegraph, primitive, options, context) {
    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    if (!dracoExtension) {
      return;
    }
    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
    const dracoOptions = {
      ...options
    };
    delete dracoOptions["3d-tiles"];
    const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
    const decodedAttributes = getGLTFAccessors(decodedData.attributes);
    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
      if (attributeName in primitive.attributes) {
        const accessorIndex = primitive.attributes[attributeName];
        const accessor = scenegraph.getAccessor(accessorIndex);
        if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {
          decodedAttribute.min = accessor.min;
          decodedAttribute.max = accessor.max;
        }
      }
    }
    primitive.attributes = decodedAttributes;
    if (decodedData.indices) {
      primitive.indices = getGLTFAccessor(decodedData.indices);
    }
    scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
    checkPrimitive(primitive);
  }
  function compressMesh(attributes, indices) {
    var _context$parseSync;
    let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    if (!options.DracoWriter) {
      throw new Error("options.gltf.DracoWriter not provided");
    }
    const compressedData = options.DracoWriter.encodeSync({
      attributes
    });
    const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {
      attributes
    });
    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
    const bufferViewIndex = options.addBufferView(compressedData);
    const glTFMesh = {
      primitives: [{
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }]
    };
    return glTFMesh;
  }
  function checkPrimitive(primitive) {
    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
      throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
    }
  }
  function* makeMeshPrimitiveIterator(scenegraph) {
    for (const mesh of scenegraph.json.meshes || []) {
      for (const primitive of mesh.primitives) {
        yield primitive;
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
  var KHR_texture_transform_exports = {};
  __export(KHR_texture_transform_exports, {
    decode: () => decode7,
    name: () => name9
  });
  var EXT_MESHOPT_TRANSFORM = "KHR_texture_transform";
  var name9 = EXT_MESHOPT_TRANSFORM;
  var scratchVector7 = new Vector3();
  var scratchRotationMatrix = new Matrix3();
  var scratchScaleMatrix = new Matrix3();
  async function decode7(gltfData, options) {
    var _options$gltf;
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const hasExtension = gltfScenegraph.hasExtension(EXT_MESHOPT_TRANSFORM);
    if (!hasExtension || !((_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.loadBuffers)) {
      return;
    }
    const materials = gltfData.json.materials || [];
    for (let i5 = 0; i5 < materials.length; i5++) {
      transformTexCoords(i5, gltfData);
    }
  }
  function transformTexCoords(materialIndex, gltfData) {
    var _gltfData$json$materi, _material$pbrMetallic, _material$pbrMetallic2;
    const processedTexCoords = [];
    const material = (_gltfData$json$materi = gltfData.json.materials) === null || _gltfData$json$materi === void 0 ? void 0 : _gltfData$json$materi[materialIndex];
    const baseColorTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic = material.pbrMetallicRoughness) === null || _material$pbrMetallic === void 0 ? void 0 : _material$pbrMetallic.baseColorTexture;
    if (baseColorTexture) {
      transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);
    }
    const emisiveTexture = material === null || material === void 0 ? void 0 : material.emissiveTexture;
    if (emisiveTexture) {
      transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);
    }
    const normalTexture = material === null || material === void 0 ? void 0 : material.normalTexture;
    if (normalTexture) {
      transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);
    }
    const occlusionTexture = material === null || material === void 0 ? void 0 : material.occlusionTexture;
    if (occlusionTexture) {
      transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);
    }
    const metallicRoughnessTexture = material === null || material === void 0 ? void 0 : (_material$pbrMetallic2 = material.pbrMetallicRoughness) === null || _material$pbrMetallic2 === void 0 ? void 0 : _material$pbrMetallic2.metallicRoughnessTexture;
    if (metallicRoughnessTexture) {
      transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);
    }
  }
  function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
    const transformParameters = getTransformParameters(texture, processedTexCoords);
    if (!transformParameters) {
      return;
    }
    const meshes = gltfData.json.meshes || [];
    for (const mesh of meshes) {
      for (const primitive of mesh.primitives) {
        const material = primitive.material;
        if (Number.isFinite(material) && materialIndex === material) {
          transformPrimitive(gltfData, primitive, transformParameters);
        }
      }
    }
  }
  function getTransformParameters(texture, processedTexCoords) {
    var _texture$extensions;
    const textureInfo = (_texture$extensions = texture.extensions) === null || _texture$extensions === void 0 ? void 0 : _texture$extensions[EXT_MESHOPT_TRANSFORM];
    const {
      texCoord: originalTexCoord = 0
    } = texture;
    const {
      texCoord = originalTexCoord
    } = textureInfo;
    const isProcessed = processedTexCoords.findIndex((_ref) => {
      let [original, newTexCoord] = _ref;
      return original === originalTexCoord && newTexCoord === texCoord;
    }) !== -1;
    if (!isProcessed) {
      const matrix = makeTransformationMatrix(textureInfo);
      if (originalTexCoord !== texCoord) {
        texture.texCoord = texCoord;
      }
      processedTexCoords.push([originalTexCoord, texCoord]);
      return {
        originalTexCoord,
        texCoord,
        matrix
      };
    }
    return null;
  }
  function transformPrimitive(gltfData, primitive, transformParameters) {
    const {
      originalTexCoord,
      texCoord,
      matrix
    } = transformParameters;
    const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
    if (Number.isFinite(texCoordAccessor)) {
      var _gltfData$json$access;
      const accessor = (_gltfData$json$access = gltfData.json.accessors) === null || _gltfData$json$access === void 0 ? void 0 : _gltfData$json$access[texCoordAccessor];
      if (accessor && accessor.bufferView) {
        var _gltfData$json$buffer;
        const bufferView = (_gltfData$json$buffer = gltfData.json.bufferViews) === null || _gltfData$json$buffer === void 0 ? void 0 : _gltfData$json$buffer[accessor.bufferView];
        if (bufferView) {
          const {
            arrayBuffer: arrayBuffer2,
            byteOffset: bufferByteOffset
          } = gltfData.buffers[bufferView.buffer];
          const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
          const {
            ArrayType: ArrayType2,
            length: length6
          } = getAccessorArrayTypeAndLength(accessor, bufferView);
          const bytes = BYTES[accessor.componentType];
          const components = COMPONENTS[accessor.type];
          const elementAddressScale = bufferView.byteStride || bytes * components;
          const result = new Float32Array(length6);
          for (let i5 = 0; i5 < accessor.count; i5++) {
            const uv = new ArrayType2(arrayBuffer2, byteOffset + i5 * elementAddressScale, 2);
            scratchVector7.set(uv[0], uv[1], 1);
            scratchVector7.transformByMatrix3(matrix);
            result.set([scratchVector7[0], scratchVector7[1]], i5 * components);
          }
          if (originalTexCoord === texCoord) {
            updateGltf(accessor, bufferView, gltfData.buffers, result);
          } else {
            createAttribute(texCoord, accessor, primitive, gltfData, result);
          }
        }
      }
    }
  }
  function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
    accessor.componentType = 5126;
    buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    bufferView.buffer = buffers.length - 1;
    bufferView.byteLength = newTexCoordArray.buffer.byteLength;
    bufferView.byteOffset = 0;
    delete bufferView.byteStride;
  }
  function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
    gltfData.buffers.push({
      arrayBuffer: newTexCoordArray.buffer,
      byteOffset: 0,
      byteLength: newTexCoordArray.buffer.byteLength
    });
    const bufferViews = gltfData.json.bufferViews;
    if (!bufferViews) {
      return;
    }
    bufferViews.push({
      buffer: gltfData.buffers.length - 1,
      byteLength: newTexCoordArray.buffer.byteLength,
      byteOffset: 0
    });
    const accessors = gltfData.json.accessors;
    if (!accessors) {
      return;
    }
    accessors.push({
      bufferView: (bufferViews === null || bufferViews === void 0 ? void 0 : bufferViews.length) - 1,
      byteOffset: 0,
      componentType: 5126,
      count: originalAccessor.count,
      type: "VEC2"
    });
    primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
  }
  function makeTransformationMatrix(extensionData) {
    const {
      offset = [0, 0],
      rotation = 0,
      scale: scale7 = [1, 1]
    } = extensionData;
    const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
    const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
    const scaleMatrix = scratchScaleMatrix.set(scale7[0], 0, 0, 0, scale7[1], 0, 0, 0, 1);
    return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
  var KHR_lights_punctual_exports = {};
  __export(KHR_lights_punctual_exports, {
    decode: () => decode8,
    encode: () => encode2,
    name: () => name10
  });
  var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
  var name10 = KHR_LIGHTS_PUNCTUAL;
  async function decode8(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
    if (extension) {
      gltfScenegraph.json.lights = extension.lights;
      gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
    }
    for (const node2 of json.nodes || []) {
      const nodeExtension = gltfScenegraph.getObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
      if (nodeExtension) {
        node2.light = nodeExtension.light;
      }
      gltfScenegraph.removeObjectExtension(node2, KHR_LIGHTS_PUNCTUAL);
    }
  }
  async function encode2(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (json.lights) {
      const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
      assert10(!extension.lights);
      extension.lights = json.lights;
      delete json.lights;
    }
    if (gltfScenegraph.json.lights) {
      for (const light of gltfScenegraph.json.lights) {
        const node2 = light.node;
        gltfScenegraph.addObjectExtension(node2, KHR_LIGHTS_PUNCTUAL, light);
      }
      delete gltfScenegraph.json.lights;
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
  var KHR_materials_unlit_exports = {};
  __export(KHR_materials_unlit_exports, {
    decode: () => decode9,
    encode: () => encode3,
    name: () => name11
  });
  var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
  var name11 = KHR_MATERIALS_UNLIT;
  async function decode9(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const material of json.materials || []) {
      const extension = material.extensions && material.extensions.KHR_materials_unlit;
      if (extension) {
        material.unlit = true;
      }
      gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
    }
    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
  }
  function encode3(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    if (gltfScenegraph.materials) {
      for (const material of json.materials || []) {
        if (material.unlit) {
          delete material.unlit;
          gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
          gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
  var KHR_techniques_webgl_exports = {};
  __export(KHR_techniques_webgl_exports, {
    decode: () => decode10,
    encode: () => encode4,
    name: () => name12
  });
  var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
  var name12 = KHR_TECHNIQUES_WEBGL;
  async function decode10(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
    if (extension) {
      const techniques = resolveTechniques(extension, gltfScenegraph);
      for (const material of json.materials || []) {
        const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
        if (materialExtension) {
          material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }
        gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      }
      gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
    }
  }
  async function encode4(gltfData, options) {
  }
  function resolveTechniques(techniquesExtension, gltfScenegraph) {
    const {
      programs = [],
      shaders = [],
      techniques = []
    } = techniquesExtension;
    const textDecoder = new TextDecoder();
    shaders.forEach((shader) => {
      if (Number.isFinite(shader.bufferView)) {
        shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
      } else {
        throw new Error("KHR_techniques_webgl: no shader code");
      }
    });
    programs.forEach((program) => {
      program.fragmentShader = shaders[program.fragmentShader];
      program.vertexShader = shaders[program.vertexShader];
    });
    techniques.forEach((technique) => {
      technique.program = programs[technique.program];
    });
    return techniques;
  }
  function resolveValues(technique, gltfScenegraph) {
    const values = Object.assign({}, technique.values);
    Object.keys(technique.uniforms || {}).forEach((uniform) => {
      if (technique.uniforms[uniform].value && !(uniform in values)) {
        values[uniform] = technique.uniforms[uniform].value;
      }
    });
    Object.keys(values).forEach((uniform) => {
      if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
        values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
      }
    });
    return values;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
  var EXTENSIONS2 = [EXT_structural_metadata_exports, EXT_mesh_features_exports, EXT_meshopt_compression_exports, EXT_texture_webp_exports, KHR_texture_basisu_exports, KHR_draco_mesh_compression_exports, KHR_lights_punctual_exports, KHR_materials_unlit_exports, KHR_techniques_webgl_exports, KHR_texture_transform_exports, EXT_feature_metadata_exports];
  function preprocessExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$preprocess;
      (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);
    }
  }
  async function decodeExtensions(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
    for (const extension of extensions) {
      var _extension$decode;
      await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));
    }
  }
  function useExtension(extensionName, options) {
    var _options$gltf;
    const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    return !exclude;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
  var KHR_BINARY_GLTF = "KHR_binary_glTF";
  function preprocess4(gltfData) {
    const gltfScenegraph = new GLTFScenegraph(gltfData);
    const {
      json
    } = gltfScenegraph;
    for (const image of json.images || []) {
      const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
      if (extension) {
        Object.assign(image, extension);
      }
      gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
    }
    if (json.buffers && json.buffers[0]) {
      delete json.buffers[0].uri;
    }
    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
  var GLTF_ARRAYS = {
    accessors: "accessor",
    animations: "animation",
    buffers: "buffer",
    bufferViews: "bufferView",
    images: "image",
    materials: "material",
    meshes: "mesh",
    nodes: "node",
    samplers: "sampler",
    scenes: "scene",
    skins: "skin",
    textures: "texture"
  };
  var GLTF_KEYS = {
    accessor: "accessors",
    animations: "animation",
    buffer: "buffers",
    bufferView: "bufferViews",
    image: "images",
    material: "materials",
    mesh: "meshes",
    node: "nodes",
    sampler: "samplers",
    scene: "scenes",
    skin: "skins",
    texture: "textures"
  };
  var GLTFV1Normalizer = class {
    constructor() {
      this.idToIndexMap = {
        animations: {},
        accessors: {},
        buffers: {},
        bufferViews: {},
        images: {},
        materials: {},
        meshes: {},
        nodes: {},
        samplers: {},
        scenes: {},
        skins: {},
        textures: {}
      };
      this.json = void 0;
    }
    normalize(gltf, options) {
      this.json = gltf.json;
      const json = gltf.json;
      switch (json.asset && json.asset.version) {
        case "2.0":
          return;
        case void 0:
        case "1.0":
          break;
        default:
          console.warn(`glTF: Unknown version ${json.asset.version}`);
          return;
      }
      if (!options.normalize) {
        throw new Error("glTF v1 is not supported.");
      }
      console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
      this._addAsset(json);
      this._convertTopLevelObjectsToArrays(json);
      preprocess4(gltf);
      this._convertObjectIdsToArrayIndices(json);
      this._updateObjects(json);
      this._updateMaterial(json);
    }
    _addAsset(json) {
      json.asset = json.asset || {};
      json.asset.version = "2.0";
      json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
    }
    _convertTopLevelObjectsToArrays(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertTopLevelObjectToArray(json, arrayName);
      }
    }
    _convertTopLevelObjectToArray(json, mapName) {
      const objectMap = json[mapName];
      if (!objectMap || Array.isArray(objectMap)) {
        return;
      }
      json[mapName] = [];
      for (const id in objectMap) {
        const object = objectMap[id];
        object.id = object.id || id;
        const index2 = json[mapName].length;
        json[mapName].push(object);
        this.idToIndexMap[mapName][id] = index2;
      }
    }
    _convertObjectIdsToArrayIndices(json) {
      for (const arrayName in GLTF_ARRAYS) {
        this._convertIdsToIndices(json, arrayName);
      }
      if ("scene" in json) {
        json.scene = this._convertIdToIndex(json.scene, "scene");
      }
      for (const texture of json.textures) {
        this._convertTextureIds(texture);
      }
      for (const mesh of json.meshes) {
        this._convertMeshIds(mesh);
      }
      for (const node2 of json.nodes) {
        this._convertNodeIds(node2);
      }
      for (const node2 of json.scenes) {
        this._convertSceneIds(node2);
      }
    }
    _convertTextureIds(texture) {
      if (texture.source) {
        texture.source = this._convertIdToIndex(texture.source, "image");
      }
    }
    _convertMeshIds(mesh) {
      for (const primitive of mesh.primitives) {
        const {
          attributes,
          indices,
          material
        } = primitive;
        for (const attributeName in attributes) {
          attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
        }
        if (indices) {
          primitive.indices = this._convertIdToIndex(indices, "accessor");
        }
        if (material) {
          primitive.material = this._convertIdToIndex(material, "material");
        }
      }
    }
    _convertNodeIds(node2) {
      if (node2.children) {
        node2.children = node2.children.map((child) => this._convertIdToIndex(child, "node"));
      }
      if (node2.meshes) {
        node2.meshes = node2.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
      }
    }
    _convertSceneIds(scene) {
      if (scene.nodes) {
        scene.nodes = scene.nodes.map((node2) => this._convertIdToIndex(node2, "node"));
      }
    }
    _convertIdsToIndices(json, topLevelArrayName) {
      if (!json[topLevelArrayName]) {
        console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
        json[topLevelArrayName] = [];
      }
      for (const object of json[topLevelArrayName]) {
        for (const key in object) {
          const id = object[key];
          const index2 = this._convertIdToIndex(id, key);
          object[key] = index2;
        }
      }
    }
    _convertIdToIndex(id, key) {
      const arrayName = GLTF_KEYS[key];
      if (arrayName in this.idToIndexMap) {
        const index2 = this.idToIndexMap[arrayName][id];
        if (!Number.isFinite(index2)) {
          throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
        }
        return index2;
      }
      return id;
    }
    _updateObjects(json) {
      for (const buffer of this.json.buffers) {
        delete buffer.type;
      }
    }
    _updateMaterial(json) {
      for (const material of json.materials) {
        var _material$values, _material$values2, _material$values3;
        material.pbrMetallicRoughness = {
          baseColorFactor: [1, 1, 1, 1],
          metallicFactor: 1,
          roughnessFactor: 1
        };
        const textureId = ((_material$values = material.values) === null || _material$values === void 0 ? void 0 : _material$values.tex) || ((_material$values2 = material.values) === null || _material$values2 === void 0 ? void 0 : _material$values2.texture2d_0) || ((_material$values3 = material.values) === null || _material$values3 === void 0 ? void 0 : _material$values3.diffuseTex);
        const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
        if (textureIndex !== -1) {
          material.pbrMetallicRoughness.baseColorTexture = {
            index: textureIndex
          };
        }
      }
    }
  };
  function normalizeGLTFV1(gltf) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return new GLTFV1Normalizer().normalize(gltf, options);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
  async function parseGLTF(gltf, arrayBufferOrString) {
    var _options$gltf, _options$gltf2, _options$gltf3;
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    let options = arguments.length > 3 ? arguments[3] : void 0;
    let context = arguments.length > 4 ? arguments[4] : void 0;
    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
    normalizeGLTFV1(gltf, {
      normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize
    });
    preprocessExtensions(gltf, options, context);
    if (options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers) {
      await loadBuffers(gltf, options, context);
    }
    if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {
      await loadImages(gltf, options, context);
    }
    await decodeExtensions(gltf, options, context);
    return gltf;
  }
  function parseGLTFContainerSync(gltf, data, byteOffset, options) {
    if (options.uri) {
      gltf.baseUri = options.uri;
    }
    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
      const textDecoder = new TextDecoder();
      data = textDecoder.decode(data);
    }
    if (typeof data === "string") {
      gltf.json = parseJSON(data);
    } else if (data instanceof ArrayBuffer) {
      const glb = {};
      byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
      assert10(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
      gltf._glb = glb;
      gltf.json = glb.json;
    } else {
      assert10(false, "GLTF: must be ArrayBuffer or string");
    }
    const buffers = gltf.json.buffers || [];
    gltf.buffers = new Array(buffers.length).fill(null);
    if (gltf._glb && gltf._glb.header.hasBinChunk) {
      const {
        binChunks
      } = gltf._glb;
      gltf.buffers[0] = {
        arrayBuffer: binChunks[0].arrayBuffer,
        byteOffset: binChunks[0].byteOffset,
        byteLength: binChunks[0].byteLength
      };
    }
    const images = gltf.json.images || [];
    gltf.images = new Array(images.length).fill({});
  }
  async function loadBuffers(gltf, options, context) {
    const buffers = gltf.json.buffers || [];
    for (let i5 = 0; i5 < buffers.length; ++i5) {
      const buffer = buffers[i5];
      if (buffer.uri) {
        var _context$fetch, _response$arrayBuffer;
        const {
          fetch: fetch2
        } = context;
        assert10(fetch2);
        const uri = resolveUrl(buffer.uri, options);
        const response = await (context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri));
        const arrayBuffer2 = await (response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response));
        gltf.buffers[i5] = {
          arrayBuffer: arrayBuffer2,
          byteOffset: 0,
          byteLength: arrayBuffer2.byteLength
        };
        delete buffer.uri;
      } else if (gltf.buffers[i5] === null) {
        gltf.buffers[i5] = {
          arrayBuffer: new ArrayBuffer(buffer.byteLength),
          byteOffset: 0,
          byteLength: buffer.byteLength
        };
      }
    }
  }
  async function loadImages(gltf, options, context) {
    const imageIndices = getReferencesImageIndices(gltf);
    const images = gltf.json.images || [];
    const promises = [];
    for (const imageIndex of imageIndices) {
      promises.push(loadImage2(gltf, images[imageIndex], imageIndex, options, context));
    }
    return await Promise.all(promises);
  }
  function getReferencesImageIndices(gltf) {
    const imageIndices = /* @__PURE__ */ new Set();
    const textures = gltf.json.textures || [];
    for (const texture of textures) {
      if (texture.source !== void 0) {
        imageIndices.add(texture.source);
      }
    }
    return Array.from(imageIndices).sort();
  }
  async function loadImage2(gltf, image, index2, options, context) {
    let arrayBuffer2;
    if (image.uri && !image.hasOwnProperty("bufferView")) {
      const uri = resolveUrl(image.uri, options);
      const {
        fetch: fetch2
      } = context;
      const response = await fetch2(uri);
      arrayBuffer2 = await response.arrayBuffer();
      image.bufferView = {
        data: arrayBuffer2
      };
    }
    if (Number.isFinite(image.bufferView)) {
      const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
      arrayBuffer2 = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
    }
    assert10(arrayBuffer2, "glTF image has no data");
    let parsedImage = await parseFromContext(arrayBuffer2, [ImageLoader, BasisLoader], {
      ...options,
      mimeType: image.mimeType,
      basis: options.basis || {
        format: selectSupportedBasisFormat()
      }
    }, context);
    if (parsedImage && parsedImage[0]) {
      parsedImage = {
        compressed: true,
        mipmaps: false,
        width: parsedImage[0].width,
        height: parsedImage[0].height,
        data: parsedImage[0]
      };
    }
    gltf.images = gltf.images || [];
    gltf.images[index2] = parsedImage;
  }

  // ../../node_modules/@loaders.gl/gltf/dist/gltf-loader.js
  var GLTFLoader = {
    name: "glTF",
    id: "gltf",
    module: "gltf",
    version: VERSION10,
    extensions: ["gltf", "glb"],
    mimeTypes: ["model/gltf+json", "model/gltf-binary"],
    text: true,
    binary: true,
    tests: ["glTF"],
    parse: parse3,
    options: {
      gltf: {
        normalize: true,
        loadBuffers: true,
        loadImages: true,
        decompressMeshes: true
      },
      log: console
    }
  };
  async function parse3(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    options = {
      ...GLTFLoader.options,
      ...options
    };
    options.gltf = {
      ...GLTFLoader.options.gltf,
      ...options.gltf
    };
    const {
      byteOffset = 0
    } = options;
    const gltf = {};
    return await parseGLTF(gltf, arrayBuffer2, byteOffset, options, context);
  }

  // ../../node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
  var COMPONENTS2 = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var BYTES2 = {
    5120: 1,
    5121: 1,
    5122: 2,
    5123: 2,
    5125: 4,
    5126: 4
  };
  var GL_SAMPLER = {
    TEXTURE_MAG_FILTER: 10240,
    TEXTURE_MIN_FILTER: 10241,
    TEXTURE_WRAP_S: 10242,
    TEXTURE_WRAP_T: 10243,
    REPEAT: 10497,
    LINEAR: 9729,
    NEAREST_MIPMAP_LINEAR: 9986
  };
  var SAMPLER_PARAMETER_GLTF_TO_GL = {
    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
    wrapT: GL_SAMPLER.TEXTURE_WRAP_T
  };
  var DEFAULT_SAMPLER_PARAMETERS2 = {
    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
  };
  function makeDefaultSampler() {
    return {
      id: "default-sampler",
      parameters: DEFAULT_SAMPLER_PARAMETERS2
    };
  }
  function getBytesFromComponentType(componentType) {
    return BYTES2[componentType];
  }
  function getSizeFromAccessorType(type) {
    return COMPONENTS2[type];
  }
  var GLTFPostProcessor = class {
    constructor() {
      this.baseUri = "";
      this.jsonUnprocessed = void 0;
      this.json = void 0;
      this.buffers = [];
      this.images = [];
    }
    postProcess(gltf) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        json,
        buffers = [],
        images = []
      } = gltf;
      const {
        baseUri = ""
      } = gltf;
      assert10(json);
      this.baseUri = baseUri;
      this.buffers = buffers;
      this.images = images;
      this.jsonUnprocessed = json;
      this.json = this._resolveTree(gltf.json, options);
      return this.json;
    }
    _resolveTree(gltf) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const json = {
        ...gltf
      };
      this.json = json;
      if (gltf.bufferViews) {
        json.bufferViews = gltf.bufferViews.map((bufView, i5) => this._resolveBufferView(bufView, i5));
      }
      if (gltf.images) {
        json.images = gltf.images.map((image, i5) => this._resolveImage(image, i5));
      }
      if (gltf.samplers) {
        json.samplers = gltf.samplers.map((sampler, i5) => this._resolveSampler(sampler, i5));
      }
      if (gltf.textures) {
        json.textures = gltf.textures.map((texture, i5) => this._resolveTexture(texture, i5));
      }
      if (gltf.accessors) {
        json.accessors = gltf.accessors.map((accessor, i5) => this._resolveAccessor(accessor, i5));
      }
      if (gltf.materials) {
        json.materials = gltf.materials.map((material, i5) => this._resolveMaterial(material, i5));
      }
      if (gltf.meshes) {
        json.meshes = gltf.meshes.map((mesh, i5) => this._resolveMesh(mesh, i5));
      }
      if (gltf.nodes) {
        json.nodes = gltf.nodes.map((node2, i5) => this._resolveNode(node2, i5));
        json.nodes = json.nodes.map((node2, i5) => this._resolveNodeChildren(node2));
      }
      if (gltf.skins) {
        json.skins = gltf.skins.map((skin, i5) => this._resolveSkin(skin, i5));
      }
      if (gltf.scenes) {
        json.scenes = gltf.scenes.map((scene, i5) => this._resolveScene(scene, i5));
      }
      if (typeof this.json.scene === "number" && json.scenes) {
        json.scene = json.scenes[this.json.scene];
      }
      return json;
    }
    getScene(index2) {
      return this._get(this.json.scenes, index2);
    }
    getNode(index2) {
      return this._get(this.json.nodes, index2);
    }
    getSkin(index2) {
      return this._get(this.json.skins, index2);
    }
    getMesh(index2) {
      return this._get(this.json.meshes, index2);
    }
    getMaterial(index2) {
      return this._get(this.json.materials, index2);
    }
    getAccessor(index2) {
      return this._get(this.json.accessors, index2);
    }
    getCamera(index2) {
      return this._get(this.json.cameras, index2);
    }
    getTexture(index2) {
      return this._get(this.json.textures, index2);
    }
    getSampler(index2) {
      return this._get(this.json.samplers, index2);
    }
    getImage(index2) {
      return this._get(this.json.images, index2);
    }
    getBufferView(index2) {
      return this._get(this.json.bufferViews, index2);
    }
    getBuffer(index2) {
      return this._get(this.json.buffers, index2);
    }
    _get(array, index2) {
      if (typeof index2 === "object") {
        return index2;
      }
      const object = array && array[index2];
      if (!object) {
        console.warn(`glTF file error: Could not find ${array}[${index2}]`);
      }
      return object;
    }
    _resolveScene(scene, index2) {
      return {
        ...scene,
        id: scene.id || `scene-${index2}`,
        nodes: (scene.nodes || []).map((node2) => this.getNode(node2))
      };
    }
    _resolveNode(gltfNode, index2) {
      const node2 = {
        ...gltfNode,
        id: (gltfNode === null || gltfNode === void 0 ? void 0 : gltfNode.id) || `node-${index2}`
      };
      if (gltfNode.mesh !== void 0) {
        node2.mesh = this.getMesh(gltfNode.mesh);
      }
      if (gltfNode.camera !== void 0) {
        node2.camera = this.getCamera(gltfNode.camera);
      }
      if (gltfNode.skin !== void 0) {
        node2.skin = this.getSkin(gltfNode.skin);
      }
      if (gltfNode.meshes !== void 0 && gltfNode.meshes.length) {
        node2.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
          const mesh = this.getMesh(meshIndex);
          accum.id = mesh.id;
          accum.primitives = accum.primitives.concat(mesh.primitives);
          return accum;
        }, {
          primitives: []
        });
      }
      return node2;
    }
    _resolveNodeChildren(node2) {
      if (node2.children) {
        node2.children = node2.children.map((child) => this.getNode(child));
      }
      return node2;
    }
    _resolveSkin(gltfSkin, index2) {
      const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : void 0;
      return {
        ...gltfSkin,
        id: gltfSkin.id || `skin-${index2}`,
        inverseBindMatrices
      };
    }
    _resolveMesh(gltfMesh, index2) {
      const mesh = {
        ...gltfMesh,
        id: gltfMesh.id || `mesh-${index2}`,
        primitives: []
      };
      if (gltfMesh.primitives) {
        mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
          const primitive = {
            ...gltfPrimitive,
            attributes: {},
            indices: void 0,
            material: void 0
          };
          const attributes = gltfPrimitive.attributes;
          for (const attribute in attributes) {
            primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
          }
          if (gltfPrimitive.indices !== void 0) {
            primitive.indices = this.getAccessor(gltfPrimitive.indices);
          }
          if (gltfPrimitive.material !== void 0) {
            primitive.material = this.getMaterial(gltfPrimitive.material);
          }
          return primitive;
        });
      }
      return mesh;
    }
    _resolveMaterial(gltfMaterial, index2) {
      const material = {
        ...gltfMaterial,
        id: gltfMaterial.id || `material-${index2}`
      };
      if (material.normalTexture) {
        material.normalTexture = {
          ...material.normalTexture
        };
        material.normalTexture.texture = this.getTexture(material.normalTexture.index);
      }
      if (material.occlusionTexture) {
        material.occlusionTexture = {
          ...material.occlusionTexture
        };
        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
      }
      if (material.emissiveTexture) {
        material.emissiveTexture = {
          ...material.emissiveTexture
        };
        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
      }
      if (!material.emissiveFactor) {
        material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
      }
      if (material.pbrMetallicRoughness) {
        material.pbrMetallicRoughness = {
          ...material.pbrMetallicRoughness
        };
        const mr = material.pbrMetallicRoughness;
        if (mr.baseColorTexture) {
          mr.baseColorTexture = {
            ...mr.baseColorTexture
          };
          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
        }
        if (mr.metallicRoughnessTexture) {
          mr.metallicRoughnessTexture = {
            ...mr.metallicRoughnessTexture
          };
          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
        }
      }
      return material;
    }
    _resolveAccessor(gltfAccessor, index2) {
      const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
      const components = getSizeFromAccessorType(gltfAccessor.type);
      const bytesPerElement = bytesPerComponent * components;
      const accessor = {
        ...gltfAccessor,
        id: gltfAccessor.id || `accessor-${index2}`,
        bytesPerComponent,
        components,
        bytesPerElement,
        value: void 0,
        bufferView: void 0,
        sparse: void 0
      };
      if (gltfAccessor.bufferView !== void 0) {
        accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
      }
      if (accessor.bufferView) {
        const buffer = accessor.bufferView.buffer;
        const {
          ArrayType: ArrayType2,
          byteLength
        } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
        const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
        let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
        if (accessor.bufferView.byteStride) {
          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
        }
        accessor.value = new ArrayType2(cutBuffer);
      }
      return accessor;
    }
    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count2) {
      const result = new Uint8Array(count2 * bytesPerElement);
      for (let i5 = 0; i5 < count2; i5++) {
        const elementOffset = byteOffset + i5 * byteStride;
        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i5 * bytesPerElement);
      }
      return result.buffer;
    }
    _resolveTexture(gltfTexture, index2) {
      return {
        ...gltfTexture,
        id: gltfTexture.id || `texture-${index2}`,
        sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
        source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : void 0
      };
    }
    _resolveSampler(gltfSampler, index2) {
      const sampler = {
        id: gltfSampler.id || `sampler-${index2}`,
        ...gltfSampler,
        parameters: {}
      };
      for (const key in sampler) {
        const glEnum = this._enumSamplerParameter(key);
        if (glEnum !== void 0) {
          sampler.parameters[glEnum] = sampler[key];
        }
      }
      return sampler;
    }
    _enumSamplerParameter(key) {
      return SAMPLER_PARAMETER_GLTF_TO_GL[key];
    }
    _resolveImage(gltfImage, index2) {
      const image = {
        ...gltfImage,
        id: gltfImage.id || `image-${index2}`,
        image: null,
        bufferView: gltfImage.bufferView !== void 0 ? this.getBufferView(gltfImage.bufferView) : void 0
      };
      const preloadedImage = this.images[index2];
      if (preloadedImage) {
        image.image = preloadedImage;
      }
      return image;
    }
    _resolveBufferView(gltfBufferView, index2) {
      const bufferIndex = gltfBufferView.buffer;
      const arrayBuffer2 = this.buffers[bufferIndex].arrayBuffer;
      let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
      if (gltfBufferView.byteOffset) {
        byteOffset += gltfBufferView.byteOffset;
      }
      const bufferView = {
        id: `bufferView-${index2}`,
        ...gltfBufferView,
        buffer: this.buffers[bufferIndex],
        data: new Uint8Array(arrayBuffer2, byteOffset, gltfBufferView.byteLength)
      };
      return bufferView;
    }
    _resolveCamera(gltfCamera, index2) {
      const camera = {
        ...gltfCamera,
        id: gltfCamera.id || `camera-${index2}`
      };
      if (camera.perspective) {
      }
      if (camera.orthographic) {
      }
      return camera;
    }
  };
  function postProcessGLTF(gltf, options) {
    return new GLTFPostProcessor().postProcess(gltf, options);
  }

  // ../mesh-layers/src/scenegraph-layer/gltf-utils.ts
  async function waitForGLTFAssets(gltfObjects) {
    const remaining = [];
    gltfObjects.scenes.forEach((scene) => {
      scene.traverse((modelNode) => {
        Object.values(modelNode.model.uniforms).forEach((uniform) => {
          if (uniform.loaded === false) {
            remaining.push(uniform);
          }
        });
      });
    });
    return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
  }
  async function waitWhileCondition(condition) {
    while (condition()) {
      await new Promise((resolve2) => requestAnimationFrame(resolve2));
    }
  }

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts
  var scenegraph_layer_vertex_glsl_default = `#version 300 es

#define SHADER_NAME scenegraph-layer-vertex-shader

// Instance attributes
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;

// Scale the model
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;

// Primitive attributes
in vec3 positions;
#ifdef HAS_UV
  in vec2 texCoords;
#endif
#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec3 normals;
  #endif
#endif

// Varying
out vec4 vColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif

// Main
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = texCoords;
    geometry.uv = texCoords;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    // using instancePositions as world coordinates
    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth
    // call project_normal before setting position to avoid rotation
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = texCoords;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts
  var scenegraph_layer_fragment_glsl_default = `#version 300 es

#define SHADER_NAME scenegraph-layer-fragment-shader

// Uniforms
uniform float opacity;

// Varying
in vec4 vColor;

out vec4 fragColor;

// MODULE_PBR contains all the varying definitions needed
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragColor = vColor;
    #endif
  #endif

  fragColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../mesh-layers/src/scenegraph-layer/scenegraph-layer.ts
  var DEFAULT_COLOR11 = [255, 255, 255, 255];
  var defaultProps28 = {
    scenegraph: { type: "object", value: null, async: true },
    getScene: (gltf) => {
      if (gltf && gltf.scenes) {
        return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
      }
      return gltf;
    },
    getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
    _animations: null,
    sizeScale: { type: "number", value: 1, min: 0 },
    sizeMinPixels: { type: "number", min: 0, value: 0 },
    sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getColor: { type: "accessor", value: DEFAULT_COLOR11 },
    _lighting: "flat",
    _imageBasedLightingEnvironment: void 0,
    getOrientation: { type: "accessor", value: [0, 0, 0] },
    getScale: { type: "accessor", value: [1, 1, 1] },
    getTranslation: { type: "accessor", value: [0, 0, 0] },
    getTransformMatrix: { type: "accessor", value: [] },
    loaders: [GLTFLoader]
  };
  var ScenegraphLayer = class extends Layer {
    getShaders() {
      const modules = [project32_default, picking_default];
      if (this.props._lighting === "pbr") {
        modules.push(pbr);
      }
      return super.getShaders({ vs: scenegraph_layer_vertex_glsl_default, fs: scenegraph_layer_fragment_glsl_default, modules });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          accessor: "getPosition",
          transition: true
        },
        instanceColors: {
          type: "unorm8",
          size: this.props.colorFormat.length,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR11,
          transition: true
        },
        instanceModelMatrix: MATRIX_ATTRIBUTES
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      if (props.scenegraph !== oldProps.scenegraph) {
        this._updateScenegraph();
      } else if (props._animations !== oldProps._animations) {
        this._applyAnimationsProp(this.state.animator, props._animations);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.scenegraph?.destroy();
    }
    get isLoaded() {
      return Boolean(this.state?.scenegraph && super.isLoaded);
    }
    _updateScenegraph() {
      const props = this.props;
      const { device } = this.context;
      let scenegraphData = null;
      if (props.scenegraph instanceof ScenegraphNode) {
        scenegraphData = { scenes: [props.scenegraph] };
      } else if (props.scenegraph && typeof props.scenegraph === "object") {
        const gltf = props.scenegraph;
        const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;
        const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());
        scenegraphData = { gltf: processedGLTF, ...gltfObjects };
        waitForGLTFAssets(gltfObjects).then(() => {
          this.setNeedsRedraw();
        }).catch((ex) => {
          this.raiseError(ex, "loading glTF");
        });
      }
      const options = { layer: this, device: this.context.device };
      const scenegraph = props.getScene(scenegraphData, options);
      const animator = props.getAnimator(scenegraphData, options);
      if (scenegraph instanceof GroupNode) {
        this.state.scenegraph?.destroy();
        this._applyAnimationsProp(animator, props._animations);
        const models = [];
        scenegraph.traverse((node2) => {
          if (node2 instanceof ModelNode) {
            models.push(node2.model);
          }
        });
        this.setState({ scenegraph, animator, models });
        this.getAttributeManager().invalidateAll();
      } else if (scenegraph !== null) {
        log_default.warn("invalid scenegraph:", scenegraph)();
      }
    }
    _applyAnimationsProp(animator, animationsProp) {
      if (!animator || !animationsProp) {
        return;
      }
      const animations = animator.getAnimations();
      Object.keys(animationsProp).sort().forEach((key) => {
        const value = animationsProp[key];
        if (key === "*") {
          animations.forEach((animation) => {
            Object.assign(animation, value);
          });
        } else if (Number.isFinite(Number(key))) {
          const number = Number(key);
          if (number >= 0 && number < animations.length) {
            Object.assign(animations[number], value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        } else {
          const findResult = animations.find(({ name: name13 }) => name13 === key);
          if (findResult) {
            Object.assign(findResult, value);
          } else {
            log_default.warn(`animation ${key} not found`)();
          }
        }
      });
    }
    _getModelOptions() {
      const { _imageBasedLightingEnvironment } = this.props;
      let env;
      if (_imageBasedLightingEnvironment) {
        if (typeof _imageBasedLightingEnvironment === "function") {
          env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });
        } else {
          env = _imageBasedLightingEnvironment;
        }
      }
      return {
        imageBasedLightingEnvironment: env,
        modelOptions: {
          id: this.props.id,
          isInstanced: true,
          bufferLayout: this.getAttributeManager().getBufferLayouts(),
          ...this.getShaders()
        },
        useTangents: false
      };
    }
    draw({ context }) {
      if (!this.state.scenegraph)
        return;
      if (this.props._animations && this.state.animator) {
        this.state.animator.animate(context.timeline.getTime());
        this.setNeedsRedraw();
      }
      const { viewport, renderPass } = this.context;
      const { sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem } = this.props;
      const numInstances = this.getNumInstances();
      this.state.scenegraph.traverse((node2, { worldMatrix }) => {
        if (node2 instanceof ModelNode) {
          const { model } = node2;
          model.setInstanceCount(numInstances);
          model.setUniforms({
            sizeScale,
            opacity,
            sizeMinPixels,
            sizeMaxPixels,
            composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
            sceneModelMatrix: worldMatrix,
            u_Camera: model.uniforms.project_uCameraPosition
          });
          model.draw(renderPass);
        }
      });
    }
  };
  ScenegraphLayer.defaultProps = defaultProps28;
  ScenegraphLayer.layerName = "ScenegraphLayer";

  // ../geo-layers/src/mesh-layer/mesh-layer-vertex.glsl.ts
  var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs

// Scale the model
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;

// Primitive attributes
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;

// Instance attributes
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;

// Outputs to fragment shader
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    // https://github.com/Esri/i3s-spec/blob/master/docs/1.7/geometryUVRegion.cmn.md
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    // set PBR data
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer-fragment.glsl.ts
  var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {

  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../geo-layers/src/mesh-layer/mesh-layer.ts
  function validateGeometryAttributes(attributes) {
    const positionAttribute = attributes.positions || attributes.POSITION;
    const vertexCount = positionAttribute.value.length / positionAttribute.size;
    const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
    if (!hasColorAttribute) {
      attributes.colors = {
        size: 4,
        value: new Uint8Array(vertexCount * 4).fill(255),
        normalized: true
      };
    }
  }
  var defaultProps29 = {
    pbrMaterial: { type: "object", value: null },
    featureIds: { type: "array", value: null, optional: true }
  };
  var MeshLayer = class extends SimpleMeshLayer {
    getShaders() {
      const shaders = super.getShaders();
      const modules = shaders.modules;
      modules.push(pbr);
      return { ...shaders, vs: mesh_layer_vertex_glsl_default, fs: mesh_layer_fragment_glsl_default };
    }
    initializeState() {
      const { featureIds } = this.props;
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      if (featureIds) {
        attributeManager.add({
          featureIdsPickingColors: {
            type: "uint8",
            size: 3,
            noAlloc: true,
            update: this.calculateFeatureIdsPickingColors
          }
        });
      }
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      if (props.pbrMaterial !== oldProps.pbrMaterial) {
        this.updatePbrMaterialUniforms(props.pbrMaterial);
      }
    }
    draw(opts) {
      const { featureIds } = this.props;
      if (!this.state.model) {
        return;
      }
      this.state.model.setUniforms({
        u_Camera: this.state.model.uniforms.project_uCameraPosition,
        pickFeatureIds: Boolean(featureIds)
      });
      super.draw(opts);
    }
    getModel(mesh) {
      const { id, pbrMaterial } = this.props;
      const parsedPBRMaterial = this.parseMaterial(pbrMaterial, mesh);
      this.setState({ parsedPBRMaterial });
      const shaders = this.getShaders();
      validateGeometryAttributes(mesh.attributes);
      const model = new Model(this.context.device, {
        ...this.getShaders(),
        id,
        geometry: mesh,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        defines: {
          ...shaders.defines,
          ...parsedPBRMaterial?.defines,
          HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0
        },
        parameters: parsedPBRMaterial?.parameters,
        isInstanced: true
      });
      return model;
    }
    updatePbrMaterialUniforms(pbrMaterial) {
      const { model } = this.state;
      if (model) {
        const { mesh } = this.props;
        const parsedPBRMaterial = this.parseMaterial(pbrMaterial, mesh);
        this.setState({ parsedPBRMaterial });
        model.setBindings(parsedPBRMaterial.bindings);
        model.setUniforms(parsedPBRMaterial.uniforms);
      }
    }
    parseMaterial(pbrMaterial, mesh) {
      const unlit = Boolean(
        pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture
      );
      return parsePBRMaterial(
        this.context.device,
        { unlit, ...pbrMaterial },
        { NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords },
        {
          pbrDebug: false,
          lights: true,
          useTangents: false
        }
      );
    }
    calculateFeatureIdsPickingColors(attribute) {
      const featureIds = this.props.featureIds;
      const value = new Uint8ClampedArray(featureIds.length * attribute.size);
      const pickingColor = [];
      for (let index2 = 0; index2 < featureIds.length; index2++) {
        this.encodePickingColor(featureIds[index2], pickingColor);
        value[index2 * 3] = pickingColor[0];
        value[index2 * 3 + 1] = pickingColor[1];
        value[index2 * 3 + 2] = pickingColor[2];
      }
      attribute.value = value;
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.parsedPBRMaterial?.generatedTextures.forEach((texture) => texture.destroy());
      this.setState({ parsedPBRMaterial: null });
    }
  };
  MeshLayer.layerName = "MeshLayer";
  MeshLayer.defaultProps = defaultProps29;

  // ../../node_modules/@math.gl/geospatial/dist/constants.js
  var WGS84_RADIUS_X = 6378137;
  var WGS84_RADIUS_Y = 6378137;
  var WGS84_RADIUS_Z = 6356752314245179e-9;
  var WGS84_CONSTANTS = {
    radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
    radiiSquared: [
      WGS84_RADIUS_X * WGS84_RADIUS_X,
      WGS84_RADIUS_Y * WGS84_RADIUS_Y,
      WGS84_RADIUS_Z * WGS84_RADIUS_Z
    ],
    oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
    oneOverRadiiSquared: [
      1 / (WGS84_RADIUS_X * WGS84_RADIUS_X),
      1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),
      1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)
    ],
    maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
    centerToleranceSquared: 0.1
  };

  // ../../node_modules/@math.gl/geospatial/dist/type-utils.js
  function identity3(x3) {
    return x3;
  }
  var scratchVector8 = new Vector3();
  function fromCartographic(cartographic, result = [], map3 = identity3) {
    if ("longitude" in cartographic) {
      result[0] = map3(cartographic.longitude);
      result[1] = map3(cartographic.latitude);
      result[2] = cartographic.height;
    } else if ("x" in cartographic) {
      result[0] = map3(cartographic.x);
      result[1] = map3(cartographic.y);
      result[2] = cartographic.z;
    } else {
      result[0] = map3(cartographic[0]);
      result[1] = map3(cartographic[1]);
      result[2] = cartographic[2];
    }
    return result;
  }
  function fromCartographicToRadians(cartographic, vector = []) {
    return fromCartographic(cartographic, vector, config._cartographicRadians ? identity3 : toRadians);
  }
  function toCartographic(vector, cartographic, map3 = identity3) {
    if ("longitude" in cartographic) {
      cartographic.longitude = map3(vector[0]);
      cartographic.latitude = map3(vector[1]);
      cartographic.height = vector[2];
    } else if ("x" in cartographic) {
      cartographic.x = map3(vector[0]);
      cartographic.y = map3(vector[1]);
      cartographic.z = vector[2];
    } else {
      cartographic[0] = map3(vector[0]);
      cartographic[1] = map3(vector[1]);
      cartographic[2] = vector[2];
    }
    return cartographic;
  }
  function toCartographicFromRadians(vector, cartographic) {
    return toCartographic(vector, cartographic, config._cartographicRadians ? identity3 : toDegrees);
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/ellipsoid-transform.js
  var EPSILON142 = 1e-14;
  var scratchOrigin = new Vector3();
  var VECTOR_PRODUCT_LOCAL_FRAME = {
    up: {
      south: "east",
      north: "west",
      west: "south",
      east: "north"
    },
    down: {
      south: "west",
      north: "east",
      west: "north",
      east: "south"
    },
    south: {
      up: "west",
      down: "east",
      west: "down",
      east: "up"
    },
    north: {
      up: "east",
      down: "west",
      west: "up",
      east: "down"
    },
    west: {
      up: "north",
      down: "south",
      north: "down",
      south: "up"
    },
    east: {
      up: "south",
      down: "north",
      north: "up",
      south: "down"
    }
  };
  var degeneratePositionLocalFrame = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1]
  };
  var scratchAxisVectors = {
    east: new Vector3(),
    north: new Vector3(),
    up: new Vector3(),
    west: new Vector3(),
    south: new Vector3(),
    down: new Vector3()
  };
  var scratchVector1 = new Vector3();
  var scratchVector24 = new Vector3();
  var scratchVector34 = new Vector3();
  function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
    const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
    assert7(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
    let firstAxisVector;
    let secondAxisVector;
    let thirdAxisVector;
    const origin = scratchOrigin.copy(cartesianOrigin);
    const atPole = equals(origin.x, 0, EPSILON142) && equals(origin.y, 0, EPSILON142);
    if (atPole) {
      const sign2 = Math.sign(origin.z);
      firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
      if (firstAxis !== "east" && firstAxis !== "west") {
        firstAxisVector.scale(sign2);
      }
      secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
      if (secondAxis !== "east" && secondAxis !== "west") {
        secondAxisVector.scale(sign2);
      }
      thirdAxisVector = scratchVector34.fromArray(degeneratePositionLocalFrame[thirdAxis]);
      if (thirdAxis !== "east" && thirdAxis !== "west") {
        thirdAxisVector.scale(sign2);
      }
    } else {
      const { up, east, north } = scratchAxisVectors;
      east.set(-origin.y, origin.x, 0).normalize();
      ellipsoid.geodeticSurfaceNormal(origin, up);
      north.copy(up).cross(east);
      const { down, west, south } = scratchAxisVectors;
      down.copy(up).scale(-1);
      west.copy(east).scale(-1);
      south.copy(north).scale(-1);
      firstAxisVector = scratchAxisVectors[firstAxis];
      secondAxisVector = scratchAxisVectors[secondAxis];
      thirdAxisVector = scratchAxisVectors[thirdAxis];
    }
    result[0] = firstAxisVector.x;
    result[1] = firstAxisVector.y;
    result[2] = firstAxisVector.z;
    result[3] = 0;
    result[4] = secondAxisVector.x;
    result[5] = secondAxisVector.y;
    result[6] = secondAxisVector.z;
    result[7] = 0;
    result[8] = thirdAxisVector.x;
    result[9] = thirdAxisVector.y;
    result[10] = thirdAxisVector.z;
    result[11] = 0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1;
    return result;
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/scale-to-geodetic-surface.js
  var scratchVector9 = new Vector3();
  var scaleToGeodeticSurfaceIntersection = new Vector3();
  var scaleToGeodeticSurfaceGradient = new Vector3();
  function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
    const { oneOverRadii, oneOverRadiiSquared, centerToleranceSquared } = ellipsoid;
    scratchVector9.from(cartesian);
    const positionX = scratchVector9.x;
    const positionY = scratchVector9.y;
    const positionZ = scratchVector9.z;
    const oneOverRadiiX = oneOverRadii.x;
    const oneOverRadiiY = oneOverRadii.y;
    const oneOverRadiiZ = oneOverRadii.z;
    const x22 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
    const y22 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
    const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
    const squaredNorm = x22 + y22 + z2;
    const ratio = Math.sqrt(1 / squaredNorm);
    if (!Number.isFinite(ratio)) {
      return void 0;
    }
    const intersection = scaleToGeodeticSurfaceIntersection;
    intersection.copy(cartesian).scale(ratio);
    if (squaredNorm < centerToleranceSquared) {
      return intersection.to(result);
    }
    const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
    const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
    const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
    const gradient = scaleToGeodeticSurfaceGradient;
    gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
    let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
    let correction = 0;
    let xMultiplier;
    let yMultiplier;
    let zMultiplier;
    let func;
    do {
      lambda -= correction;
      xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
      yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
      zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
      const xMultiplier2 = xMultiplier * xMultiplier;
      const yMultiplier2 = yMultiplier * yMultiplier;
      const zMultiplier2 = zMultiplier * zMultiplier;
      const xMultiplier3 = xMultiplier2 * xMultiplier;
      const yMultiplier3 = yMultiplier2 * yMultiplier;
      const zMultiplier3 = zMultiplier2 * zMultiplier;
      func = x22 * xMultiplier2 + y22 * yMultiplier2 + z2 * zMultiplier2 - 1;
      const denominator = x22 * xMultiplier3 * oneOverRadiiSquaredX + y22 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
      const derivative = -2 * denominator;
      correction = func / derivative;
    } while (Math.abs(func) > math_utils_exports.EPSILON12);
    return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
  }

  // ../../node_modules/@math.gl/geospatial/dist/ellipsoid/ellipsoid.js
  var scratchVector10 = new Vector3();
  var scratchNormal3 = new Vector3();
  var scratchK = new Vector3();
  var scratchPosition2 = new Vector3();
  var scratchHeight = new Vector3();
  var scratchCartesian = new Vector3();
  var Ellipsoid = class {
    constructor(x3 = 0, y3 = 0, z2 = 0) {
      this.centerToleranceSquared = math_utils_exports.EPSILON1;
      assert7(x3 >= 0);
      assert7(y3 >= 0);
      assert7(z2 >= 0);
      this.radii = new Vector3(x3, y3, z2);
      this.radiiSquared = new Vector3(x3 * x3, y3 * y3, z2 * z2);
      this.radiiToTheFourth = new Vector3(x3 * x3 * x3 * x3, y3 * y3 * y3 * y3, z2 * z2 * z2 * z2);
      this.oneOverRadii = new Vector3(x3 === 0 ? 0 : 1 / x3, y3 === 0 ? 0 : 1 / y3, z2 === 0 ? 0 : 1 / z2);
      this.oneOverRadiiSquared = new Vector3(x3 === 0 ? 0 : 1 / (x3 * x3), y3 === 0 ? 0 : 1 / (y3 * y3), z2 === 0 ? 0 : 1 / (z2 * z2));
      this.minimumRadius = Math.min(x3, y3, z2);
      this.maximumRadius = Math.max(x3, y3, z2);
      if (this.radiiSquared.z !== 0) {
        this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
      }
      Object.freeze(this);
    }
    equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
    toString() {
      return this.radii.toString();
    }
    cartographicToCartesian(cartographic, result = [0, 0, 0]) {
      const normal = scratchNormal3;
      const k2 = scratchK;
      const [, , height] = cartographic;
      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k2.copy(this.radiiSquared).scale(normal);
      const gamma = Math.sqrt(normal.dot(k2));
      k2.scale(1 / gamma);
      normal.scale(height);
      k2.add(normal);
      return k2.to(result);
    }
    cartesianToCartographic(cartesian, result = [0, 0, 0]) {
      scratchCartesian.from(cartesian);
      const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
      if (!point) {
        return void 0;
      }
      const normal = this.geodeticSurfaceNormal(point, scratchNormal3);
      const h2 = scratchHeight;
      h2.copy(scratchCartesian).subtract(point);
      const longitude = Math.atan2(normal.y, normal.x);
      const latitude = Math.asin(normal.z);
      const height = Math.sign(vec3_exports.dot(h2, scratchCartesian)) * vec3_exports.length(h2);
      return toCartographicFromRadians([longitude, latitude, height], result);
    }
    eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
    }
    localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
      return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
    geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).normalize().to(result);
    }
    geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
      const cartographicVectorRadians = fromCartographicToRadians(cartographic);
      const longitude = cartographicVectorRadians[0];
      const latitude = cartographicVectorRadians[1];
      const cosLatitude = Math.cos(latitude);
      scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector10.to(result);
    }
    geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
      return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
    scaleToGeodeticSurface(cartesian, result) {
      return scaleToGeodeticSurface(cartesian, this, result);
    }
    scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
      scratchPosition2.from(cartesian);
      const positionX = scratchPosition2.x;
      const positionY = scratchPosition2.y;
      const positionZ = scratchPosition2.z;
      const oneOverRadiiSquared = this.oneOverRadiiSquared;
      const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition2.multiplyScalar(beta).to(result);
    }
    transformPositionToScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
    }
    transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
      return scratchPosition2.from(position).scale(this.radii).to(result);
    }
    getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
      assert7(equals(this.radii.x, this.radii.y, math_utils_exports.EPSILON15));
      assert7(this.radii.z > 0);
      scratchPosition2.from(position);
      const z2 = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
      if (Math.abs(z2) >= this.radii.z - buffer) {
        return void 0;
      }
      return scratchPosition2.set(0, 0, z2).to(result);
    }
  };
  Ellipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);

  // ../../node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list-node.js
  var DoublyLinkedListNode = class {
    constructor(item, previous, next) {
      this.item = void 0;
      this.previous = void 0;
      this.next = void 0;
      this.item = item;
      this.previous = previous;
      this.next = next;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list.js
  var DoublyLinkedList = class {
    constructor() {
      this.head = null;
      this.tail = null;
      this._length = 0;
    }
    get length() {
      return this._length;
    }
    add(item) {
      const node2 = new DoublyLinkedListNode(item, this.tail, null);
      if (this.tail) {
        this.tail.next = node2;
        this.tail = node2;
      } else {
        this.head = node2;
        this.tail = node2;
      }
      ++this._length;
      return node2;
    }
    remove(node2) {
      if (!node2) {
        return;
      }
      if (node2.previous && node2.next) {
        node2.previous.next = node2.next;
        node2.next.previous = node2.previous;
      } else if (node2.previous) {
        node2.previous.next = null;
        this.tail = node2.previous;
      } else if (node2.next) {
        node2.next.previous = null;
        this.head = node2.next;
      } else {
        this.head = null;
        this.tail = null;
      }
      node2.next = null;
      node2.previous = null;
      --this._length;
    }
    splice(node2, nextNode) {
      if (node2 === nextNode) {
        return;
      }
      this.remove(nextNode);
      this._insert(node2, nextNode);
    }
    _insert(node2, nextNode) {
      const oldNodeNext = node2.next;
      node2.next = nextNode;
      if (this.tail === node2) {
        this.tail = nextNode;
      } else {
        oldNodeNext.previous = nextNode;
      }
      nextNode.next = oldNodeNext;
      nextNode.previous = node2;
      ++this._length;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-cache.js
  var TilesetCache = class {
    constructor() {
      this._list = void 0;
      this._sentinel = void 0;
      this._trimTiles = void 0;
      this._list = new DoublyLinkedList();
      this._sentinel = this._list.add("sentinel");
      this._trimTiles = false;
    }
    reset() {
      this._list.splice(this._list.tail, this._sentinel);
    }
    touch(tile) {
      const node2 = tile._cacheNode;
      if (node2) {
        this._list.splice(this._sentinel, node2);
      }
    }
    add(tileset, tile, addCallback) {
      if (!tile._cacheNode) {
        tile._cacheNode = this._list.add(tile);
        if (addCallback) {
          addCallback(tileset, tile);
        }
      }
    }
    unloadTile(tileset, tile, unloadCallback) {
      const node2 = tile._cacheNode;
      if (!node2) {
        return;
      }
      this._list.remove(node2);
      tile._cacheNode = null;
      if (unloadCallback) {
        unloadCallback(tileset, tile);
      }
    }
    unloadTiles(tileset, unloadCallback) {
      const trimTiles = this._trimTiles;
      this._trimTiles = false;
      const list = this._list;
      const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
      const sentinel = this._sentinel;
      let node2 = list.head;
      while (node2 !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
        const tile = node2.item;
        node2 = node2.next;
        this.unloadTile(tileset, tile, unloadCallback);
      }
    }
    trim() {
      this._trimTiles = true;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/transform-utils.js
  function calculateTransformProps(tileHeader, tile) {
    assert2(tileHeader);
    assert2(tile);
    const {
      rtcCenter,
      gltfUpAxis
    } = tile;
    const {
      computedTransform,
      boundingVolume: {
        center
      }
    } = tileHeader;
    let modelMatrix2 = new Matrix4(computedTransform);
    if (rtcCenter) {
      modelMatrix2.translate(rtcCenter);
    }
    switch (gltfUpAxis) {
      case "Z":
        break;
      case "Y":
        const rotationY = new Matrix4().rotateX(Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
        break;
      case "X":
        const rotationX = new Matrix4().rotateY(-Math.PI / 2);
        modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
        break;
      default:
        break;
    }
    if (tile.isQuantized) {
      modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
    }
    const cartesianOrigin = new Vector3(center);
    tile.cartesianModelMatrix = modelMatrix2;
    tile.cartesianOrigin = cartesianOrigin;
    const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
    const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
    const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
    tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
    tile.cartographicOrigin = cartographicOrigin;
    if (!tile.coordinateSystem) {
      tile.modelMatrix = tile.cartographicModelMatrix;
    }
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/frame-state.js
  var scratchVector11 = new Vector3();
  var scratchPosition3 = new Vector3();
  var cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);
  function getFrameState(viewport, frameNumber) {
    const {
      cameraDirection,
      cameraUp,
      height
    } = viewport;
    const {
      metersPerUnit
    } = viewport.distanceScales;
    const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
    const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
    const cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();
    const cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();
    commonSpacePlanesToWGS84(viewport);
    const ViewportClass = viewport.constructor;
    const {
      longitude,
      latitude,
      width,
      bearing,
      zoom
    } = viewport;
    const topDownViewport = new ViewportClass({
      longitude,
      latitude,
      height,
      width,
      bearing,
      zoom,
      pitch: 0
    });
    return {
      camera: {
        position: cameraPositionCartesian2,
        direction: cameraDirectionCartesian,
        up: cameraUpCartesian
      },
      viewport,
      topDownViewport,
      height,
      cullingVolume,
      frameNumber,
      sseDenominator: 1.15
    };
  }
  function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
    if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
      return [tiles, []];
    }
    const tuples = [];
    const {
      longitude: viewportLongitude,
      latitude: viewportLatitude
    } = frameState.viewport;
    for (const [index2, tile] of tiles.entries()) {
      const [longitude, latitude] = tile.header.mbs;
      const deltaLon = Math.abs(viewportLongitude - longitude);
      const deltaLat = Math.abs(viewportLatitude - latitude);
      const distance5 = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
      tuples.push([index2, distance5]);
    }
    const tuplesSorted = tuples.sort((a3, b2) => a3[1] - b2[1]);
    const selectedTiles = [];
    for (let i5 = 0; i5 < maximumTilesSelected; i5++) {
      selectedTiles.push(tiles[tuplesSorted[i5][0]]);
    }
    const unselectedTiles = [];
    for (let i5 = maximumTilesSelected; i5 < tuplesSorted.length; i5++) {
      unselectedTiles.push(tiles[tuplesSorted[i5][0]]);
    }
    return [selectedTiles, unselectedTiles];
  }
  function commonSpacePlanesToWGS84(viewport) {
    const frustumPlanes = viewport.getFrustumPlanes();
    const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
    const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
    const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
    let i5 = 0;
    cullingVolume.planes[i5++].fromPointNormal(nearCenterCartesian, scratchVector11.copy(nearCenterCartesian).subtract(cameraCartesian));
    for (const dir in frustumPlanes) {
      if (dir === "near") {
        continue;
      }
      const plane = frustumPlanes[dir];
      const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
      const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
      cullingVolume.planes[i5++].fromPointNormal(cartesianPos, scratchVector11.copy(nearCenterCartesian).subtract(cartesianPos));
    }
  }
  function closestPointOnPlane(plane, refPoint) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const distanceToRef = plane.normal.dot(refPoint);
    out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
    return out;
  }
  function worldToCartesian(viewport, point) {
    let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Vector3();
    const cartographicPos = viewport.unprojectPosition(point);
    return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/zoom.js
  var WGS84_RADIUS_X2 = 6378137;
  var WGS84_RADIUS_Y2 = 6378137;
  var WGS84_RADIUS_Z2 = 6356752314245179e-9;
  var scratchVector12 = new Vector3();
  function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
    if (boundingVolume instanceof OrientedBoundingBox) {
      const {
        halfAxes
      } = boundingVolume;
      const obbSize = getObbSize(halfAxes);
      return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
    } else if (boundingVolume instanceof BoundingSphere) {
      const {
        radius
      } = boundingVolume;
      return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
    } else if (boundingVolume.width && boundingVolume.height) {
      const {
        width,
        height
      } = boundingVolume;
      const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
      const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
      return (zoomX + zoomY) / 2;
    }
    return 1;
  }
  function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
    Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector12);
    const extentSize = Math.sqrt(Math.pow(scratchVector12[0] - cartesianCenter[0], 2) + Math.pow(scratchVector12[1] - cartesianCenter[1], 2) + Math.pow(scratchVector12[2] - cartesianCenter[2], 2));
    return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
  }
  function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
    const [xmin, ymin, xmax, ymax] = extent;
    return getZoomFromFullExtent({
      xmin,
      xmax,
      ymin,
      ymax,
      zmin: 0,
      zmax: 0
    }, cartorgraphicCenter, cartesianCenter);
  }
  function getObbSize(halfAxes) {
    halfAxes.getColumn(0, scratchVector12);
    const axeY = halfAxes.getColumn(1);
    const axeZ = halfAxes.getColumn(2);
    const farthestVertex = scratchVector12.add(axeY).add(axeZ);
    const size = farthestVertex.len();
    return size;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/constants.js
  var TILE_CONTENT_STATE = {
    UNLOADED: 0,
    LOADING: 1,
    PROCESSING: 2,
    READY: 3,
    EXPIRED: 4,
    FAILED: 5
  };
  var TILE_REFINEMENT = function(TILE_REFINEMENT2) {
    TILE_REFINEMENT2[TILE_REFINEMENT2["ADD"] = 1] = "ADD";
    TILE_REFINEMENT2[TILE_REFINEMENT2["REPLACE"] = 2] = "REPLACE";
    return TILE_REFINEMENT2;
  }({});
  var TILE_TYPE = function(TILE_TYPE2) {
    TILE_TYPE2["EMPTY"] = "empty";
    TILE_TYPE2["SCENEGRAPH"] = "scenegraph";
    TILE_TYPE2["POINTCLOUD"] = "pointcloud";
    TILE_TYPE2["MESH"] = "mesh";
    return TILE_TYPE2;
  }({});
  var TILESET_TYPE = function(TILESET_TYPE2) {
    TILESET_TYPE2["I3S"] = "I3S";
    TILESET_TYPE2["TILES3D"] = "TILES3D";
    return TILESET_TYPE2;
  }({});
  var LOD_METRIC_TYPE = function(LOD_METRIC_TYPE2) {
    LOD_METRIC_TYPE2["GEOMETRIC_ERROR"] = "geometricError";
    LOD_METRIC_TYPE2["MAX_SCREEN_THRESHOLD"] = "maxScreenThreshold";
    return LOD_METRIC_TYPE2;
  }({});
  var TILE3D_OPTIMIZATION_HINT = {
    NOT_COMPUTED: -1,
    USE_OPTIMIZATION: 1,
    SKIP_OPTIMIZATION: 0
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/bounding-volume.js
  function defined(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var scratchPoint = new Vector3();
  var scratchScale = new Vector3();
  var scratchNorthWest = new Vector3();
  var scratchSouthEast = new Vector3();
  var scratchCenter = new Vector3();
  var scratchXAxis = new Vector3();
  var scratchYAxis = new Vector3();
  var scratchZAxis = new Vector3();
  function createBoundingVolume(boundingVolumeHeader, transform2, result) {
    assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
    if (boundingVolumeHeader.box) {
      return createBox(boundingVolumeHeader.box, transform2, result);
    }
    if (boundingVolumeHeader.region) {
      return createObbFromRegion(boundingVolumeHeader.region);
    }
    if (boundingVolumeHeader.sphere) {
      return createSphere(boundingVolumeHeader.sphere, transform2, result);
    }
    throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
  }
  function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
    if (boundingVolumeHeader.box) {
      return orientedBoundingBoxToCartographicBounds(boundingVolume);
    }
    if (boundingVolumeHeader.region) {
      const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
      return [[degrees(west), degrees(south), minHeight], [degrees(east), degrees(north), maxHeight]];
    }
    if (boundingVolumeHeader.sphere) {
      return boundingSphereToCartographicBounds(boundingVolume);
    }
    throw new Error("Unkown boundingVolume type");
  }
  function createBox(box, transform2, result) {
    const center = new Vector3(box[0], box[1], box[2]);
    transform2.transform(center, center);
    let origin = [];
    if (box.length === 10) {
      const halfSize = box.slice(3, 6);
      const quaternion2 = new Quaternion();
      quaternion2.fromArray(box, 6);
      const x3 = new Vector3([1, 0, 0]);
      const y3 = new Vector3([0, 1, 0]);
      const z2 = new Vector3([0, 0, 1]);
      x3.transformByQuaternion(quaternion2);
      x3.scale(halfSize[0]);
      y3.transformByQuaternion(quaternion2);
      y3.scale(halfSize[1]);
      z2.transformByQuaternion(quaternion2);
      z2.scale(halfSize[2]);
      origin = [...x3.toArray(), ...y3.toArray(), ...z2.toArray()];
    } else {
      origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
    }
    const xAxis = transform2.transformAsVector(origin.slice(0, 3));
    const yAxis = transform2.transformAsVector(origin.slice(3, 6));
    const zAxis = transform2.transformAsVector(origin.slice(6, 9));
    const halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);
    if (defined(result)) {
      result.center = center;
      result.halfAxes = halfAxes;
      return result;
    }
    return new OrientedBoundingBox(center, halfAxes);
  }
  function createSphere(sphere, transform2, result) {
    const center = new Vector3(sphere[0], sphere[1], sphere[2]);
    transform2.transform(center, center);
    const scale7 = transform2.getScale(scratchScale);
    const uniformScale = Math.max(Math.max(scale7[0], scale7[1]), scale7[2]);
    const radius = sphere[3] * uniformScale;
    if (defined(result)) {
      result.center = center;
      result.radius = radius;
      return result;
    }
    return new BoundingSphere(center, radius);
  }
  function createObbFromRegion(region) {
    const [west, south, east, north, minHeight, maxHeight] = region;
    const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
    const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);
    Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);
    Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);
    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);
    Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);
    return createBox([...centerInCartesian, ...scratchXAxis.subtract(centerInCartesian), ...scratchYAxis.subtract(centerInCartesian), ...scratchZAxis.subtract(centerInCartesian)], new Matrix4());
  }
  function orientedBoundingBoxToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const {
      halfAxes
    } = boundingVolume;
    const xAxis = new Vector3(halfAxes.getColumn(0));
    const yAxis = new Vector3(halfAxes.getColumn(1));
    const zAxis = new Vector3(halfAxes.getColumn(2));
    for (let x3 = 0; x3 < 2; x3++) {
      for (let y3 = 0; y3 < 2; y3++) {
        for (let z2 = 0; z2 < 2; z2++) {
          scratchPoint.copy(boundingVolume.center);
          scratchPoint.add(xAxis);
          scratchPoint.add(yAxis);
          scratchPoint.add(zAxis);
          addToCartographicBounds(result, scratchPoint);
          zAxis.negate();
        }
        yAxis.negate();
      }
      xAxis.negate();
    }
    return result;
  }
  function boundingSphereToCartographicBounds(boundingVolume) {
    const result = emptyCartographicBounds();
    const {
      center,
      radius
    } = boundingVolume;
    const point = Ellipsoid.WGS84.scaleToGeodeticSurface(center, scratchPoint);
    let zAxis;
    if (point) {
      zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point);
    } else {
      zAxis = new Vector3(0, 0, 1);
    }
    let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);
    if (xAxis.len() > 0) {
      xAxis.normalize();
    } else {
      xAxis = new Vector3(0, 1, 0);
    }
    const yAxis = xAxis.clone().cross(zAxis);
    for (const axis of [xAxis, yAxis, zAxis]) {
      scratchScale.copy(axis).scale(radius);
      for (let dir = 0; dir < 2; dir++) {
        scratchPoint.copy(center);
        scratchPoint.add(scratchScale);
        addToCartographicBounds(result, scratchPoint);
        scratchScale.negate();
      }
    }
    return result;
  }
  function emptyCartographicBounds() {
    return [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];
  }
  function addToCartographicBounds(target, cartesian) {
    Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
    target[0][0] = Math.min(target[0][0], scratchPoint[0]);
    target[0][1] = Math.min(target[0][1], scratchPoint[1]);
    target[0][2] = Math.min(target[0][2], scratchPoint[2]);
    target[1][0] = Math.max(target[1][0], scratchPoint[0]);
    target[1][1] = Math.max(target[1][1], scratchPoint[1]);
    target[1][2] = Math.max(target[1][2], scratchPoint[2]);
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/tiles-3d-lod.js
  var scratchPositionNormal = new Vector3();
  var scratchCartographic = new Vector3();
  var scratchMatrix2 = new Matrix4();
  var scratchCenter2 = new Vector3();
  var scratchPosition4 = new Vector3();
  var scratchDirection = new Vector3();
  function fog(distanceToCamera, density) {
    const scalar = distanceToCamera * density;
    return 1 - Math.exp(-(scalar * scalar));
  }
  function getDynamicScreenSpaceError(tileset, distanceToCamera) {
    if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
      const density = tileset.dynamicScreenSpaceErrorComputedDensity;
      const factor = tileset.dynamicScreenSpaceErrorFactor;
      const dynamicError = fog(distanceToCamera, density) * factor;
      return dynamicError;
    }
    return 0;
  }
  function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
    const tileset = tile.tileset;
    const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
    const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
    if (lodMetricValue === 0) {
      return 0;
    }
    const distance5 = Math.max(tile._distanceToCamera, 1e-7);
    const {
      height,
      sseDenominator
    } = frameState;
    const {
      viewDistanceScale
    } = tileset.options;
    let error = lodMetricValue * height * (viewDistanceScale || 1) / (distance5 * sseDenominator);
    error -= getDynamicScreenSpaceError(tileset, distance5);
    return error;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/i3s-lod.js
  var cameraPositionCartesian = new Vector3();
  var toEye = new Vector3();
  var cameraPositionEnu = new Vector3();
  var extraVertexEnu = new Vector3();
  var projectedOriginVector = new Vector3();
  var enuToCartesianMatrix = new Matrix4();
  var cartesianToEnuMatrix = new Matrix4();
  function getLodStatus(tile, frameState) {
    if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
      return "DIG";
    }
    const screenSize = 2 * getProjectedRadius(tile, frameState);
    if (screenSize < 2) {
      return "OUT";
    }
    if (!tile.header.children || screenSize <= tile.lodMetricValue) {
      return "DRAW";
    } else if (tile.header.children) {
      return "DIG";
    }
    return "OUT";
  }
  function getProjectedRadius(tile, frameState) {
    const {
      topDownViewport: viewport
    } = frameState;
    const mbsLat = tile.header.mbs[1];
    const mbsLon = tile.header.mbs[0];
    const mbsZ = tile.header.mbs[2];
    const mbsR = tile.header.mbs[3];
    const mbsCenterCartesian = [...tile.boundingVolume.center];
    const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
    Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
    toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
    Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
    cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
    cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
    const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
    const extraZ = projection * projection / cameraPositionEnu[2];
    extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
    const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
    const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
    const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
    const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
    const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
    const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
    const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
    const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
    return projectedRadius;
  }

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/helpers/3d-tiles-options.js
  function get3dTilesOptions(tileset) {
    return {
      assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
    };
  }

  // ../../node_modules/@loaders.gl/tiles/dist/utils/managed-array.js
  var ManagedArray = class {
    constructor() {
      let length6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this._map = /* @__PURE__ */ new Map();
      this._array = void 0;
      this._length = void 0;
      this._array = new Array(length6);
      this._length = length6;
    }
    get length() {
      return this._length;
    }
    set length(length6) {
      this._length = length6;
      if (length6 > this._array.length) {
        this._array.length = length6;
      }
    }
    get values() {
      return this._array;
    }
    get(index2) {
      assert2(index2 < this._array.length);
      return this._array[index2];
    }
    set(index2, element) {
      assert2(index2 >= 0);
      if (index2 >= this.length) {
        this.length = index2 + 1;
      }
      if (this._map.has(this._array[index2])) {
        this._map.delete(this._array[index2]);
      }
      this._array[index2] = element;
      this._map.set(element, index2);
    }
    delete(element) {
      const index2 = this._map.get(element);
      if (index2 >= 0) {
        this._array.splice(index2, 1);
        this._map.delete(element);
        this.length--;
      }
    }
    peek() {
      return this._array[this._length - 1];
    }
    push(element) {
      if (!this._map.has(element)) {
        const index2 = this.length++;
        this._array[index2] = element;
        this._map.set(element, index2);
      }
    }
    pop() {
      const element = this._array[--this.length];
      this._map.delete(element);
      return element;
    }
    reserve(length6) {
      assert2(length6 >= 0);
      if (length6 > this._array.length) {
        this._array.length = length6;
      }
    }
    resize(length6) {
      assert2(length6 >= 0);
      this.length = length6;
    }
    trim(length6) {
      if (length6 === null || length6 === void 0) {
        length6 = this.length;
      }
      this._array.length = length6;
    }
    reset() {
      this._array = [];
      this._map = /* @__PURE__ */ new Map();
      this._length = 0;
    }
    find(target) {
      return this._map.has(target);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-traverser.js
  var DEFAULT_PROPS4 = {
    loadSiblings: false,
    skipLevelOfDetail: false,
    updateTransforms: true,
    onTraversalEnd: () => {
    },
    viewportTraversersMap: {},
    basePath: ""
  };
  var TilesetTraverser = class {
    traversalFinished(frameState) {
      return true;
    }
    constructor(options) {
      this.options = void 0;
      this.root = null;
      this.selectedTiles = {};
      this.requestedTiles = {};
      this.emptyTiles = {};
      this.lastUpdate = new Date().getTime();
      this.updateDebounceTime = 1e3;
      this._traversalStack = new ManagedArray();
      this._emptyTraversalStack = new ManagedArray();
      this._frameNumber = null;
      this.options = {
        ...DEFAULT_PROPS4,
        ...options
      };
    }
    traverse(root, frameState, options) {
      this.root = root;
      this.options = {
        ...this.options,
        ...options
      };
      this.reset();
      this.updateTile(root, frameState);
      this._frameNumber = frameState.frameNumber;
      this.executeTraversal(root, frameState);
    }
    reset() {
      this.requestedTiles = {};
      this.selectedTiles = {};
      this.emptyTiles = {};
      this._traversalStack.reset();
      this._emptyTraversalStack.reset();
    }
    executeTraversal(root, frameState) {
      const stack2 = this._traversalStack;
      root._selectionDepth = 1;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        let shouldRefine = false;
        if (this.canTraverse(tile, frameState)) {
          this.updateChildTiles(tile, frameState);
          shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
        }
        const parent = tile.parent;
        const parentRefines = Boolean(!parent || parent._shouldRefine);
        const stoppedRefining = !shouldRefine;
        if (!tile.hasRenderContent) {
          this.emptyTiles[tile.id] = tile;
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        } else if (tile.refine === TILE_REFINEMENT.ADD) {
          this.loadTile(tile, frameState);
          this.selectTile(tile, frameState);
        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
          this.loadTile(tile, frameState);
          if (stoppedRefining) {
            this.selectTile(tile, frameState);
          }
        }
        this.touchTile(tile, frameState);
        tile._shouldRefine = shouldRefine && parentRefines;
      }
      const newTime = new Date().getTime();
      if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
        this.lastUpdate = newTime;
        this.options.onTraversalEnd(frameState);
      }
    }
    updateChildTiles(tile, frameState) {
      const children = tile.children;
      for (const child of children) {
        this.updateTile(child, frameState);
      }
    }
    updateAndPushChildren(tile, frameState, stack2, depth) {
      const {
        loadSiblings,
        skipLevelOfDetail
      } = this.options;
      const children = tile.children;
      children.sort(this.compareDistanceToCamera.bind(this));
      const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
      let hasVisibleChild = false;
      let refines = true;
      for (const child of children) {
        child._selectionDepth = depth;
        if (child.isVisibleAndInRequestVolume) {
          if (stack2.find(child)) {
            stack2.delete(child);
          }
          stack2.push(child);
          hasVisibleChild = true;
        } else if (checkRefines || loadSiblings) {
          this.loadTile(child, frameState);
          this.touchTile(child, frameState);
        }
        if (checkRefines) {
          let childRefines;
          if (!child._inRequestVolume) {
            childRefines = false;
          } else if (!child.hasRenderContent) {
            childRefines = this.executeEmptyTraversal(child, frameState);
          } else {
            childRefines = child.contentAvailable;
          }
          refines = refines && childRefines;
          if (!refines) {
            return false;
          }
        }
      }
      if (!hasVisibleChild) {
        refines = false;
      }
      return refines;
    }
    updateTile(tile, frameState) {
      this.updateTileVisibility(tile, frameState);
    }
    selectTile(tile, frameState) {
      if (this.shouldSelectTile(tile)) {
        tile._selectedFrame = frameState.frameNumber;
        this.selectedTiles[tile.id] = tile;
      }
    }
    loadTile(tile, frameState) {
      if (this.shouldLoadTile(tile)) {
        tile._requestedFrame = frameState.frameNumber;
        tile._priority = tile._getPriority();
        this.requestedTiles[tile.id] = tile;
      }
    }
    touchTile(tile, frameState) {
      tile.tileset._cache.touch(tile);
      tile._touchedFrame = frameState.frameNumber;
    }
    canTraverse(tile, frameState) {
      let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let ignoreVisibility = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (!tile.hasChildren) {
        return false;
      }
      if (tile.hasTilesetContent) {
        return !tile.contentExpired;
      }
      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {
        return false;
      }
      return this.shouldRefine(tile, frameState, useParentMetric);
    }
    shouldLoadTile(tile) {
      return tile.hasUnloadedContent || tile.contentExpired;
    }
    shouldSelectTile(tile) {
      return tile.contentAvailable && !this.options.skipLevelOfDetail;
    }
    shouldRefine(tile, frameState) {
      let useParentMetric = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let screenSpaceError = tile._screenSpaceError;
      if (useParentMetric) {
        screenSpaceError = tile.getScreenSpaceError(frameState, true);
      }
      return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;
    }
    updateTileVisibility(tile, frameState) {
      const viewportIds = [];
      if (this.options.viewportTraversersMap) {
        for (const key in this.options.viewportTraversersMap) {
          const value = this.options.viewportTraversersMap[key];
          if (value === frameState.viewport.id) {
            viewportIds.push(key);
          }
        }
      } else {
        viewportIds.push(frameState.viewport.id);
      }
      tile.updateVisibility(frameState, viewportIds);
    }
    compareDistanceToCamera(b2, a3) {
      return b2._distanceToCamera - a3._distanceToCamera;
    }
    anyChildrenVisible(tile, frameState) {
      let anyVisible = false;
      for (const child of tile.children) {
        child.updateVisibility(frameState);
        anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
      }
      return anyVisible;
    }
    executeEmptyTraversal(root, frameState) {
      let allDescendantsLoaded = true;
      const stack2 = this._emptyTraversalStack;
      stack2.push(root);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, false);
        const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;
        if (!traverse && !tile.contentAvailable && !emptyLeaf) {
          allDescendantsLoaded = false;
        }
        this.updateTile(tile, frameState);
        if (!tile.isVisibleAndInRequestVolume) {
          this.loadTile(tile, frameState);
          this.touchTile(tile, frameState);
        }
        if (traverse) {
          const children = tile.children;
          for (const child of children) {
            stack2.push(child);
          }
        }
      }
      return allDescendantsLoaded;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tile-3d.js
  var scratchVector13 = new Vector3();
  function defined2(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var Tile3D = class {
    constructor(tileset, header, parentHeader) {
      let extendedId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      this.tileset = void 0;
      this.header = void 0;
      this.id = void 0;
      this.url = void 0;
      this.parent = void 0;
      this.refine = void 0;
      this.type = void 0;
      this.contentUrl = void 0;
      this.lodMetricType = "geometricError";
      this.lodMetricValue = 0;
      this.boundingVolume = null;
      this.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.gpuMemoryUsageInBytes = 0;
      this.children = [];
      this.depth = 0;
      this.viewportIds = [];
      this.transform = new Matrix4();
      this.extensions = null;
      this.implicitTiling = null;
      this.userData = {};
      this.computedTransform = void 0;
      this.hasEmptyContent = false;
      this.hasTilesetContent = false;
      this.traverser = new TilesetTraverser({});
      this._cacheNode = null;
      this._frameNumber = null;
      this._expireDate = null;
      this._expiredContent = null;
      this._boundingBox = void 0;
      this._distanceToCamera = 0;
      this._screenSpaceError = 0;
      this._visibilityPlaneMask = void 0;
      this._visible = void 0;
      this._contentBoundingVolume = void 0;
      this._viewerRequestVolume = void 0;
      this._initialTransform = new Matrix4();
      this._priority = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._selectionDepth = 0;
      this._touchedFrame = 0;
      this._centerZDepth = 0;
      this._shouldRefine = false;
      this._stackLength = 0;
      this._visitedFrame = 0;
      this._inRequestVolume = false;
      this._lodJudge = null;
      this.header = header;
      this.tileset = tileset;
      this.id = extendedId || header.id;
      this.url = header.url;
      this.parent = parentHeader;
      this.refine = this._getRefine(header.refine);
      this.type = header.type;
      this.contentUrl = header.contentUrl;
      this._initializeLodMetric(header);
      this._initializeTransforms(header);
      this._initializeBoundingVolumes(header);
      this._initializeContent(header);
      this._initializeRenderingState(header);
      Object.seal(this);
    }
    destroy() {
      this.header = null;
    }
    isDestroyed() {
      return this.header === null;
    }
    get selected() {
      return this._selectedFrame === this.tileset._frameNumber;
    }
    get isVisible() {
      return this._visible;
    }
    get isVisibleAndInRequestVolume() {
      return this._visible && this._inRequestVolume;
    }
    get hasRenderContent() {
      return !this.hasEmptyContent && !this.hasTilesetContent;
    }
    get hasChildren() {
      return this.children.length > 0 || this.header.children && this.header.children.length > 0;
    }
    get contentReady() {
      return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
    }
    get contentAvailable() {
      return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
    }
    get hasUnloadedContent() {
      return this.hasRenderContent && this.contentUnloaded;
    }
    get contentUnloaded() {
      return this.contentState === TILE_CONTENT_STATE.UNLOADED;
    }
    get contentExpired() {
      return this.contentState === TILE_CONTENT_STATE.EXPIRED;
    }
    get contentFailed() {
      return this.contentState === TILE_CONTENT_STATE.FAILED;
    }
    get distanceToCamera() {
      return this._distanceToCamera;
    }
    get screenSpaceError() {
      return this._screenSpaceError;
    }
    get boundingBox() {
      if (!this._boundingBox) {
        this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
      }
      return this._boundingBox;
    }
    getScreenSpaceError(frameState, useParentLodMetric) {
      switch (this.tileset.type) {
        case TILESET_TYPE.I3S:
          return getProjectedRadius(this, frameState);
        case TILESET_TYPE.TILES3D:
          return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
        default:
          throw new Error("Unsupported tileset type");
      }
    }
    unselect() {
      this._selectedFrame = 0;
    }
    _getGpuMemoryUsageInBytes() {
      return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
    }
    _getPriority() {
      const traverser = this.tileset._traverser;
      const {
        skipLevelOfDetail
      } = traverser.options;
      const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
      if (maySkipTile && !this.isVisible && this._visible !== void 0) {
        return -1;
      }
      if (this.tileset._frameNumber - this._touchedFrame >= 1) {
        return -1;
      }
      if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
        return -1;
      }
      const parent = this.parent;
      const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
      const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
      const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
      return Math.max(rootScreenSpaceError - screenSpaceError, 0);
    }
    async loadContent() {
      if (this.hasEmptyContent) {
        return false;
      }
      if (this.content) {
        return true;
      }
      const expired = this.contentExpired;
      if (expired) {
        this._expireDate = null;
      }
      this.contentState = TILE_CONTENT_STATE.LOADING;
      const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
      if (!requestToken) {
        this.contentState = TILE_CONTENT_STATE.UNLOADED;
        return false;
      }
      try {
        const contentUrl = this.tileset.getTileUrl(this.contentUrl);
        const loader = this.tileset.loader;
        const options = {
          ...this.tileset.loadOptions,
          [loader.id]: {
            ...this.tileset.loadOptions[loader.id],
            isTileset: this.type === "json",
            ...this._getLoaderSpecificOptions(loader.id)
          }
        };
        this.content = await load(contentUrl, loader, options);
        if (this.tileset.options.contentLoader) {
          await this.tileset.options.contentLoader(this);
        }
        if (this._isTileset()) {
          this.tileset._initializeTileHeaders(this.content, this);
        }
        this.contentState = TILE_CONTENT_STATE.READY;
        this._onContentLoaded();
        return true;
      } catch (error) {
        this.contentState = TILE_CONTENT_STATE.FAILED;
        throw error;
      } finally {
        requestToken.done();
      }
    }
    unloadContent() {
      if (this.content && this.content.destroy) {
        this.content.destroy();
      }
      this.content = null;
      if (this.header.content && this.header.content.destroy) {
        this.header.content.destroy();
      }
      this.header.content = null;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return true;
    }
    updateVisibility(frameState, viewportIds) {
      if (this._frameNumber === frameState.frameNumber) {
        return;
      }
      const parent = this.parent;
      const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
      if (this.tileset._traverser.options.updateTransforms) {
        const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
        this._updateTransform(parentTransform);
      }
      this._distanceToCamera = this.distanceToTile(frameState);
      this._screenSpaceError = this.getScreenSpaceError(frameState, false);
      this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
      this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
      this._inRequestVolume = this.insideViewerRequestVolume(frameState);
      this._frameNumber = frameState.frameNumber;
      this.viewportIds = viewportIds;
    }
    visibility(frameState, parentVisibilityPlaneMask) {
      const {
        cullingVolume: cullingVolume2
      } = frameState;
      const {
        boundingVolume
      } = this;
      return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
    }
    contentVisibility() {
      return true;
    }
    distanceToTile(frameState) {
      const boundingVolume = this.boundingVolume;
      return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
    }
    cameraSpaceZDepth(_ref) {
      let {
        camera
      } = _ref;
      const boundingVolume = this.boundingVolume;
      scratchVector13.subVectors(boundingVolume.center, camera.position);
      return camera.direction.dot(scratchVector13);
    }
    insideViewerRequestVolume(frameState) {
      const viewerRequestVolume = this._viewerRequestVolume;
      return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
    }
    updateExpiration() {
      if (defined2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
        const now = Date.now();
        if (Date.lessThan(this._expireDate, now)) {
          this.contentState = TILE_CONTENT_STATE.EXPIRED;
          this._expiredContent = this.content;
        }
      }
    }
    get extras() {
      return this.header.extras;
    }
    _initializeLodMetric(header) {
      if ("lodMetricType" in header) {
        this.lodMetricType = header.lodMetricType;
      } else {
        this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
        console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);
      }
      if ("lodMetricValue" in header) {
        this.lodMetricValue = header.lodMetricValue;
      } else {
        this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
        console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
      }
    }
    _initializeTransforms(tileHeader) {
      this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
      const parent = this.parent;
      const tileset = this.tileset;
      const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
      this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
      const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
      this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
    }
    _initializeBoundingVolumes(tileHeader) {
      this._contentBoundingVolume = null;
      this._viewerRequestVolume = null;
      this._updateBoundingVolume(tileHeader);
    }
    _initializeContent(tileHeader) {
      this.content = {
        _tileset: this.tileset,
        _tile: this
      };
      this.hasEmptyContent = true;
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      this.hasTilesetContent = false;
      if (tileHeader.contentUrl) {
        this.content = null;
        this.hasEmptyContent = false;
      }
    }
    _initializeRenderingState(header) {
      this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
      this._shouldRefine = false;
      this._distanceToCamera = 0;
      this._centerZDepth = 0;
      this._screenSpaceError = 0;
      this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
      this._visible = void 0;
      this._inRequestVolume = false;
      this._stackLength = 0;
      this._selectionDepth = 0;
      this._frameNumber = 0;
      this._touchedFrame = 0;
      this._visitedFrame = 0;
      this._selectedFrame = 0;
      this._requestedFrame = 0;
      this._priority = 0;
    }
    _getRefine(refine) {
      return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
    }
    _isTileset() {
      return this.contentUrl.indexOf(".json") !== -1;
    }
    _onContentLoaded() {
      switch (this.content && this.content.type) {
        case "vctr":
        case "geom":
          this.tileset._traverser.disableSkipLevelOfDetail = true;
          break;
        default:
      }
      if (this._isTileset()) {
        this.hasTilesetContent = true;
      } else {
        this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
      }
    }
    _updateBoundingVolume(header) {
      this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
      const content = header.content;
      if (!content) {
        return;
      }
      if (content.boundingVolume) {
        this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
      }
      if (header.viewerRequestVolume) {
        this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
      }
    }
    _updateTransform() {
      let parentTransform = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Matrix4();
      const computedTransform = parentTransform.clone().multiplyRight(this.transform);
      const didTransformChange = !computedTransform.equals(this.computedTransform);
      if (!didTransformChange) {
        return;
      }
      this.computedTransform = computedTransform;
      this._updateBoundingVolume(this.header);
    }
    _getLoaderSpecificOptions(loaderId) {
      switch (loaderId) {
        case "i3s":
          return {
            ...this.tileset.options.i3s,
            _tileOptions: {
              attributeUrls: this.header.attributeUrls,
              textureUrl: this.header.textureUrl,
              textureFormat: this.header.textureFormat,
              textureLoaderOptions: this.header.textureLoaderOptions,
              materialDefinition: this.header.materialDefinition,
              isDracoGeometry: this.header.isDracoGeometry,
              mbs: this.header.mbs
            },
            _tilesetOptions: {
              store: this.tileset.tileset.store,
              attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
              fields: this.tileset.tileset.fields
            },
            isTileHeader: false
          };
        case "3d-tiles":
        case "cesium-ion":
        default:
          return get3dTilesOptions(this.tileset.tileset);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-3d-tiles/tileset-3d-traverser.js
  var Tileset3DTraverser = class extends TilesetTraverser {
    compareDistanceToCamera(a3, b2) {
      return b2._distanceToCamera === 0 && a3._distanceToCamera === 0 ? b2._centerZDepth - a3._centerZDepth : b2._distanceToCamera - a3._distanceToCamera;
    }
    updateTileVisibility(tile, frameState) {
      super.updateTileVisibility(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        return;
      }
      const hasChildren = tile.children.length > 0;
      if (tile.hasTilesetContent && hasChildren) {
        const firstChild = tile.children[0];
        this.updateTileVisibility(firstChild, frameState);
        tile._visible = firstChild._visible;
        return;
      }
      if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
        tile._visible = false;
        return;
      }
      const replace = tile.refine === TILE_REFINEMENT.REPLACE;
      const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
      if (replace && useOptimization && hasChildren) {
        if (!this.anyChildrenVisible(tile, frameState)) {
          tile._visible = false;
          return;
        }
      }
    }
    meetsScreenSpaceErrorEarly(tile, frameState) {
      const {
        parent
      } = tile;
      if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
        return false;
      }
      return !this.shouldRefine(tile, frameState, true);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-pending-tiles-register.js
  var I3SPendingTilesRegister = class {
    constructor() {
      this.frameNumberMap = /* @__PURE__ */ new Map();
    }
    register(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
      const oldCount = viewportMap.get(frameNumber) || 0;
      viewportMap.set(frameNumber, oldCount + 1);
      this.frameNumberMap.set(viewportId, viewportMap);
    }
    deregister(viewportId, frameNumber) {
      const viewportMap = this.frameNumberMap.get(viewportId);
      if (!viewportMap) {
        return;
      }
      const oldCount = viewportMap.get(frameNumber) || 1;
      viewportMap.set(frameNumber, oldCount - 1);
    }
    isZero(viewportId, frameNumber) {
      var _this$frameNumberMap$;
      const count2 = ((_this$frameNumberMap$ = this.frameNumberMap.get(viewportId)) === null || _this$frameNumberMap$ === void 0 ? void 0 : _this$frameNumberMap$.get(frameNumber)) || 0;
      return count2 === 0;
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tile-manager.js
  var STATUS = {
    REQUESTED: "REQUESTED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR"
  };
  var I3STileManager = class {
    constructor() {
      this._statusMap = void 0;
      this.pendingTilesRegister = new I3SPendingTilesRegister();
      this._statusMap = {};
    }
    add(request, key, callback, frameState) {
      if (!this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = frameState;
        this._statusMap[key] = {
          request,
          callback,
          key,
          frameState,
          status: STATUS.REQUESTED
        };
        this.pendingTilesRegister.register(id, frameNumber);
        request().then((data) => {
          this._statusMap[key].status = STATUS.COMPLETED;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          this._statusMap[key].callback(data, frameState);
        }).catch((error) => {
          this._statusMap[key].status = STATUS.ERROR;
          const {
            frameNumber: actualFrameNumber,
            viewport: {
              id: id2
            }
          } = this._statusMap[key].frameState;
          this.pendingTilesRegister.deregister(id2, actualFrameNumber);
          callback(error);
        });
      }
    }
    update(key, frameState) {
      if (this._statusMap[key]) {
        const {
          frameNumber,
          viewport: {
            id
          }
        } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id, frameNumber);
        const {
          frameNumber: newFrameNumber,
          viewport: {
            id: newViewportId
          }
        } = frameState;
        this.pendingTilesRegister.register(newViewportId, newFrameNumber);
        this._statusMap[key].frameState = frameState;
      }
    }
    find(key) {
      return this._statusMap[key];
    }
    hasPendingTiles(viewportId, frameNumber) {
      return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tileset-traverser.js
  var I3STilesetTraverser = class extends TilesetTraverser {
    constructor(options) {
      super(options);
      this._tileManager = void 0;
      this._tileManager = new I3STileManager();
    }
    traversalFinished(frameState) {
      return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
    }
    shouldRefine(tile, frameState) {
      tile._lodJudge = getLodStatus(tile, frameState);
      return tile._lodJudge === "DIG";
    }
    updateChildTiles(tile, frameState) {
      const children = tile.header.children || [];
      const childTiles = tile.children;
      const tileset = tile.tileset;
      for (const child of children) {
        const extendedId = `${child.id}-${frameState.viewport.id}`;
        const childTile = childTiles && childTiles.find((t3) => t3.id === extendedId);
        if (!childTile) {
          let request = () => this._loadTile(child.id, tileset);
          const cachedRequest = this._tileManager.find(extendedId);
          if (!cachedRequest) {
            if (tileset.tileset.nodePages) {
              request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
            }
            this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
          } else {
            this._tileManager.update(extendedId, frameState);
          }
        } else if (childTile) {
          this.updateTile(childTile, frameState);
        }
      }
      return false;
    }
    async _loadTile(nodeId, tileset) {
      const {
        loader
      } = tileset;
      const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);
      const options = {
        ...tileset.loadOptions,
        i3s: {
          ...tileset.loadOptions.i3s,
          isTileHeader: true
        }
      };
      return await load(nodeUrl, loader, options);
    }
    _onTileLoad(header, tile, extendedId) {
      const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
      tile.children.push(childTile);
      const frameState = this._tileManager.find(childTile.id).frameState;
      this.updateTile(childTile, frameState);
      if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || new Date().getTime() - this.lastUpdate > this.updateDebounceTime)) {
        this.executeTraversal(childTile, frameState);
      }
    }
  };

  // ../../node_modules/@loaders.gl/tiles/dist/tileset/tileset-3d.js
  var DEFAULT_PROPS5 = {
    description: "",
    ellipsoid: Ellipsoid.WGS84,
    modelMatrix: new Matrix4(),
    throttleRequests: true,
    maxRequests: 64,
    maximumMemoryUsage: 32,
    memoryCacheOverflow: 1,
    maximumTilesSelected: 0,
    debounceTime: 0,
    onTileLoad: () => {
    },
    onTileUnload: () => {
    },
    onTileError: () => {
    },
    onTraversalComplete: (selectedTiles) => selectedTiles,
    contentLoader: void 0,
    viewDistanceScale: 1,
    maximumScreenSpaceError: 8,
    memoryAdjustedScreenSpaceError: false,
    loadTiles: true,
    updateTransforms: true,
    viewportTraversersMap: null,
    loadOptions: {
      fetch: {}
    },
    attributions: [],
    basePath: "",
    i3s: {}
  };
  var TILES_TOTAL = "Tiles In Tileset(s)";
  var TILES_IN_MEMORY = "Tiles In Memory";
  var TILES_IN_VIEW = "Tiles In View";
  var TILES_RENDERABLE = "Tiles To Render";
  var TILES_LOADED = "Tiles Loaded";
  var TILES_LOADING = "Tiles Loading";
  var TILES_UNLOADED = "Tiles Unloaded";
  var TILES_LOAD_FAILED = "Failed Tile Loads";
  var POINTS_COUNT = "Points/Vertices";
  var TILES_GPU_MEMORY = "Tile Memory Use";
  var MAXIMUM_SSE = "Maximum Screen Space Error";
  var Tileset3D = class {
    constructor(tileset, options) {
      this.options = void 0;
      this.loadOptions = void 0;
      this.type = void 0;
      this.tileset = void 0;
      this.loader = void 0;
      this.url = void 0;
      this.basePath = void 0;
      this.modelMatrix = void 0;
      this.ellipsoid = void 0;
      this.lodMetricType = void 0;
      this.lodMetricValue = void 0;
      this.refine = void 0;
      this.root = null;
      this.roots = {};
      this.asset = {};
      this.description = "";
      this.properties = void 0;
      this.extras = null;
      this.attributions = {};
      this.credits = {};
      this.stats = void 0;
      this.contentFormats = {
        draco: false,
        meshopt: false,
        dds: false,
        ktx2: false
      };
      this.cartographicCenter = null;
      this.cartesianCenter = null;
      this.zoom = 1;
      this.boundingVolume = null;
      this.dynamicScreenSpaceErrorComputedDensity = 0;
      this.maximumMemoryUsage = 32;
      this.gpuMemoryUsageInBytes = 0;
      this.memoryAdjustedScreenSpaceError = 0;
      this._cacheBytes = 0;
      this._cacheOverflowBytes = 0;
      this._frameNumber = 0;
      this._queryParams = {};
      this._extensionsUsed = [];
      this._tiles = {};
      this._pendingCount = 0;
      this.selectedTiles = [];
      this.traverseCounter = 0;
      this.geometricError = 0;
      this.lastUpdatedVieports = null;
      this._requestedTiles = [];
      this._emptyTiles = [];
      this.frameStateData = {};
      this._traverser = void 0;
      this._cache = new TilesetCache();
      this._requestScheduler = void 0;
      this.updatePromise = null;
      this.tilesetInitializationPromise = void 0;
      this.options = {
        ...DEFAULT_PROPS5,
        ...options
      };
      this.tileset = tileset;
      this.loader = tileset.loader;
      this.type = tileset.type;
      this.url = tileset.url;
      this.basePath = tileset.basePath || path_exports.dirname(this.url);
      this.modelMatrix = this.options.modelMatrix;
      this.ellipsoid = this.options.ellipsoid;
      this.lodMetricType = tileset.lodMetricType;
      this.lodMetricValue = tileset.lodMetricValue;
      this.refine = tileset.root.refine;
      this.loadOptions = this.options.loadOptions || {};
      this._traverser = this._initializeTraverser();
      this._requestScheduler = new RequestScheduler({
        throttleRequests: this.options.throttleRequests,
        maxRequests: this.options.maxRequests
      });
      this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;
      this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;
      this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;
      this.stats = new Stats({
        id: this.url
      });
      this._initializeStats();
      this.tilesetInitializationPromise = this._initializeTileSet(tileset);
    }
    destroy() {
      this._destroy();
    }
    isLoaded() {
      return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
    }
    get tiles() {
      return Object.values(this._tiles);
    }
    get frameNumber() {
      return this._frameNumber;
    }
    get queryParams() {
      return new URLSearchParams(this._queryParams).toString();
    }
    setProps(props) {
      this.options = {
        ...this.options,
        ...props
      };
    }
    getTileUrl(tilePath) {
      const isDataUrl = tilePath.startsWith("data:");
      if (isDataUrl) {
        return tilePath;
      }
      let tileUrl = tilePath;
      if (this.queryParams.length) {
        tileUrl = `${tilePath}${tilePath.includes("?") ? "&" : "?"}${this.queryParams}`;
      }
      return tileUrl;
    }
    hasExtension(extensionName) {
      return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);
    }
    update() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      this.tilesetInitializationPromise.then(() => {
        if (!viewports && this.lastUpdatedVieports) {
          viewports = this.lastUpdatedVieports;
        } else {
          this.lastUpdatedVieports = viewports;
        }
        if (viewports) {
          this.doUpdate(viewports);
        }
      });
    }
    async selectTiles() {
      let viewports = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      await this.tilesetInitializationPromise;
      if (viewports) {
        this.lastUpdatedVieports = viewports;
      }
      if (!this.updatePromise) {
        this.updatePromise = new Promise((resolve2) => {
          setTimeout(() => {
            if (this.lastUpdatedVieports) {
              this.doUpdate(this.lastUpdatedVieports);
            }
            resolve2(this._frameNumber);
            this.updatePromise = null;
          }, this.options.debounceTime);
        });
      }
      return this.updatePromise;
    }
    adjustScreenSpaceError() {
      if (this.gpuMemoryUsageInBytes < this._cacheBytes) {
        this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);
      } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {
        this.memoryAdjustedScreenSpaceError *= 1.02;
      }
    }
    doUpdate(viewports) {
      if ("loadTiles" in this.options && !this.options.loadTiles) {
        return;
      }
      if (this.traverseCounter > 0) {
        return;
      }
      const preparedViewports = viewports instanceof Array ? viewports : [viewports];
      this._cache.reset();
      this._frameNumber++;
      this.traverseCounter = preparedViewports.length;
      const viewportsToTraverse = [];
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (this._needTraverse(id)) {
          viewportsToTraverse.push(id);
        } else {
          this.traverseCounter--;
        }
      }
      for (const viewport of preparedViewports) {
        const id = viewport.id;
        if (!this.roots[id]) {
          this.roots[id] = this._initializeTileHeaders(this.tileset, null);
        }
        if (!viewportsToTraverse.includes(id)) {
          continue;
        }
        const frameState = getFrameState(viewport, this._frameNumber);
        this._traverser.traverse(this.roots[id], frameState, this.options);
      }
    }
    _needTraverse(viewportId) {
      let traverserId = viewportId;
      if (this.options.viewportTraversersMap) {
        traverserId = this.options.viewportTraversersMap[viewportId];
      }
      if (traverserId !== viewportId) {
        return false;
      }
      return true;
    }
    _onTraversalEnd(frameState) {
      const id = frameState.viewport.id;
      if (!this.frameStateData[id]) {
        this.frameStateData[id] = {
          selectedTiles: [],
          _requestedTiles: [],
          _emptyTiles: []
        };
      }
      const currentFrameStateData = this.frameStateData[id];
      const selectedTiles = Object.values(this._traverser.selectedTiles);
      const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
      currentFrameStateData.selectedTiles = filteredSelectedTiles;
      for (const tile of unselectedTiles) {
        tile.unselect();
      }
      currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
      currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
      this.traverseCounter--;
      if (this.traverseCounter > 0) {
        return;
      }
      this._updateTiles();
    }
    _updateTiles() {
      this.selectedTiles = [];
      this._requestedTiles = [];
      this._emptyTiles = [];
      for (const frameStateKey in this.frameStateData) {
        const frameStateDataValue = this.frameStateData[frameStateKey];
        this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
        this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
        this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
      }
      this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
      for (const tile of this.selectedTiles) {
        this._tiles[tile.id] = tile;
      }
      this._loadTiles();
      this._unloadTiles();
      this._updateStats();
    }
    _tilesChanged(oldSelectedTiles, selectedTiles) {
      if (oldSelectedTiles.length !== selectedTiles.length) {
        return true;
      }
      const set1 = new Set(oldSelectedTiles.map((t3) => t3.id));
      const set22 = new Set(selectedTiles.map((t3) => t3.id));
      let changed = oldSelectedTiles.filter((x3) => !set22.has(x3.id)).length > 0;
      changed = changed || selectedTiles.filter((x3) => !set1.has(x3.id)).length > 0;
      return changed;
    }
    _loadTiles() {
      for (const tile of this._requestedTiles) {
        if (tile.contentUnloaded) {
          this._loadTile(tile);
        }
      }
    }
    _unloadTiles() {
      this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
    }
    _updateStats() {
      let tilesRenderable = 0;
      let pointsRenderable = 0;
      for (const tile of this.selectedTiles) {
        if (tile.contentAvailable && tile.content) {
          tilesRenderable++;
          if (tile.content.pointCount) {
            pointsRenderable += tile.content.pointCount;
          } else {
            pointsRenderable += tile.content.vertexCount;
          }
        }
      }
      this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
      this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
      this.stats.get(POINTS_COUNT).count = pointsRenderable;
      this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;
    }
    async _initializeTileSet(tilesetJson) {
      if (this.type === TILESET_TYPE.I3S) {
        this.calculateViewPropsI3S();
        tilesetJson.root = await tilesetJson.root;
      }
      this.root = this._initializeTileHeaders(tilesetJson, null);
      if (this.type === TILESET_TYPE.TILES3D) {
        this._initializeTiles3DTileset(tilesetJson);
        this.calculateViewPropsTiles3D();
      }
      if (this.type === TILESET_TYPE.I3S) {
        this._initializeI3STileset();
      }
    }
    calculateViewPropsI3S() {
      var _this$tileset$store;
      const fullExtent = this.tileset.fullExtent;
      if (fullExtent) {
        const {
          xmin,
          xmax,
          ymin,
          ymax,
          zmin,
          zmax
        } = fullExtent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
        this.cartesianCenter = new Vector3();
        Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
        this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      const extent = (_this$tileset$store = this.tileset.store) === null || _this$tileset$store === void 0 ? void 0 : _this$tileset$store.extent;
      if (extent) {
        const [xmin, ymin, xmax, ymax] = extent;
        this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
        this.cartesianCenter = new Vector3();
        Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
        this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
        return;
      }
      console.warn("Extent is not defined in the tileset header");
      this.cartographicCenter = new Vector3();
      this.zoom = 1;
      return;
    }
    calculateViewPropsTiles3D() {
      const root = this.root;
      const {
        center
      } = root.boundingVolume;
      if (!center) {
        console.warn("center was not pre-calculated for the root tile");
        this.cartographicCenter = new Vector3();
        this.zoom = 1;
        return;
      }
      if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {
        this.cartographicCenter = new Vector3();
        Ellipsoid.WGS84.cartesianToCartographic(center, this.cartographicCenter);
      } else {
        this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
      }
      this.cartesianCenter = center;
      this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
    }
    _initializeStats() {
      this.stats.get(TILES_TOTAL);
      this.stats.get(TILES_LOADING);
      this.stats.get(TILES_IN_MEMORY);
      this.stats.get(TILES_IN_VIEW);
      this.stats.get(TILES_RENDERABLE);
      this.stats.get(TILES_LOADED);
      this.stats.get(TILES_UNLOADED);
      this.stats.get(TILES_LOAD_FAILED);
      this.stats.get(POINTS_COUNT);
      this.stats.get(TILES_GPU_MEMORY, "memory");
      this.stats.get(MAXIMUM_SSE);
    }
    _initializeTileHeaders(tilesetJson, parentTileHeader) {
      const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
      if (parentTileHeader) {
        parentTileHeader.children.push(rootTile);
        rootTile.depth = parentTileHeader.depth + 1;
      }
      if (this.type === TILESET_TYPE.TILES3D) {
        const stack2 = [];
        stack2.push(rootTile);
        while (stack2.length > 0) {
          const tile = stack2.pop();
          this.stats.get(TILES_TOTAL).incrementCount();
          const children = tile.header.children || [];
          for (const childHeader of children) {
            var _childTile$contentUrl;
            const childTile = new Tile3D(this, childHeader, tile);
            if ((_childTile$contentUrl = childTile.contentUrl) !== null && _childTile$contentUrl !== void 0 && _childTile$contentUrl.includes("?session=")) {
              const url = new URL(childTile.contentUrl);
              const session = url.searchParams.get("session");
              if (session) {
                this._queryParams.session = session;
              }
            }
            tile.children.push(childTile);
            childTile.depth = tile.depth + 1;
            stack2.push(childTile);
          }
        }
      }
      return rootTile;
    }
    _initializeTraverser() {
      let TraverserClass;
      const type = this.type;
      switch (type) {
        case TILESET_TYPE.TILES3D:
          TraverserClass = Tileset3DTraverser;
          break;
        case TILESET_TYPE.I3S:
          TraverserClass = I3STilesetTraverser;
          break;
        default:
          TraverserClass = TilesetTraverser;
      }
      return new TraverserClass({
        basePath: this.basePath,
        onTraversalEnd: this._onTraversalEnd.bind(this)
      });
    }
    _destroyTileHeaders(parentTile) {
      this._destroySubtree(parentTile);
    }
    async _loadTile(tile) {
      let loaded;
      try {
        this._onStartTileLoading();
        loaded = await tile.loadContent();
      } catch (error) {
        this._onTileLoadError(tile, error instanceof Error ? error : new Error("load failed"));
      } finally {
        this._onEndTileLoading();
        this._onTileLoad(tile, loaded);
      }
    }
    _onTileLoadError(tile, error) {
      this.stats.get(TILES_LOAD_FAILED).incrementCount();
      const message2 = error.message || error.toString();
      const url = tile.url;
      console.error(`A 3D tile failed to load: ${tile.url} ${message2}`);
      this.options.onTileError(tile, message2, url);
    }
    _onTileLoad(tile, loaded) {
      if (!loaded) {
        return;
      }
      if (this.type === TILESET_TYPE.I3S) {
        var _this$tileset, _this$tileset$nodePag;
        const nodesInNodePages = ((_this$tileset = this.tileset) === null || _this$tileset === void 0 ? void 0 : (_this$tileset$nodePag = _this$tileset.nodePagesTile) === null || _this$tileset$nodePag === void 0 ? void 0 : _this$tileset$nodePag.nodesInNodePages) || 0;
        this.stats.get(TILES_TOTAL).reset();
        this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
      }
      if (tile && tile.content) {
        calculateTransformProps(tile, tile.content);
      }
      this.updateContentTypes(tile);
      this._addTileToCache(tile);
      this.options.onTileLoad(tile);
    }
    updateContentTypes(tile) {
      if (this.type === TILESET_TYPE.I3S) {
        if (tile.header.isDracoGeometry) {
          this.contentFormats.draco = true;
        }
        switch (tile.header.textureFormat) {
          case "dds":
            this.contentFormats.dds = true;
            break;
          case "ktx2":
            this.contentFormats.ktx2 = true;
            break;
          default:
        }
      } else if (this.type === TILESET_TYPE.TILES3D) {
        var _tile$content;
        const {
          extensionsRemoved = []
        } = ((_tile$content = tile.content) === null || _tile$content === void 0 ? void 0 : _tile$content.gltf) || {};
        if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
          this.contentFormats.draco = true;
        }
        if (extensionsRemoved.includes("EXT_meshopt_compression")) {
          this.contentFormats.meshopt = true;
        }
        if (extensionsRemoved.includes("KHR_texture_basisu")) {
          this.contentFormats.ktx2 = true;
        }
      }
    }
    _onStartTileLoading() {
      this._pendingCount++;
      this.stats.get(TILES_LOADING).incrementCount();
    }
    _onEndTileLoading() {
      this._pendingCount--;
      this.stats.get(TILES_LOADING).decrementCount();
    }
    _addTileToCache(tile) {
      this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
    }
    _updateCacheStats(tile) {
      this.stats.get(TILES_LOADED).incrementCount();
      this.stats.get(TILES_IN_MEMORY).incrementCount();
      this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      if (this.options.memoryAdjustedScreenSpaceError) {
        this.adjustScreenSpaceError();
      }
    }
    _unloadTile(tile) {
      this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;
      this.stats.get(TILES_IN_MEMORY).decrementCount();
      this.stats.get(TILES_UNLOADED).incrementCount();
      this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
      this.options.onTileUnload(tile);
      tile.unloadContent();
    }
    _destroy() {
      const stack2 = [];
      if (this.root) {
        stack2.push(this.root);
      }
      while (stack2.length > 0) {
        const tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        this._destroyTile(tile);
      }
      this.root = null;
    }
    _destroySubtree(tile) {
      const root = tile;
      const stack2 = [];
      stack2.push(root);
      while (stack2.length > 0) {
        tile = stack2.pop();
        for (const child of tile.children) {
          stack2.push(child);
        }
        if (tile !== root) {
          this._destroyTile(tile);
        }
      }
      root.children = [];
    }
    _destroyTile(tile) {
      this._cache.unloadTile(this, tile);
      this._unloadTile(tile);
      tile.destroy();
    }
    _initializeTiles3DTileset(tilesetJson) {
      if (tilesetJson.queryString) {
        const searchParams = new URLSearchParams(tilesetJson.queryString);
        const queryParams = Object.fromEntries(searchParams.entries());
        this._queryParams = {
          ...this._queryParams,
          ...queryParams
        };
      }
      this.asset = tilesetJson.asset;
      if (!this.asset) {
        throw new Error("Tileset must have an asset property.");
      }
      if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1") {
        throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
      }
      if ("tilesetVersion" in this.asset) {
        this._queryParams.v = this.asset.tilesetVersion;
      }
      this.credits = {
        attributions: this.options.attributions || []
      };
      this.description = this.options.description || "";
      this.properties = tilesetJson.properties;
      this.geometricError = tilesetJson.geometricError;
      this._extensionsUsed = tilesetJson.extensionsUsed || [];
      this.extras = tilesetJson.extras;
    }
    _initializeI3STileset() {
      if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
        this._queryParams.token = this.loadOptions.i3s.token;
      }
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/version.js
  var VERSION12 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/constants.js
  var TILE3D_TYPE = {
    COMPOSITE: "cmpt",
    POINT_CLOUD: "pnts",
    BATCHED_3D_MODEL: "b3dm",
    INSTANCED_3D_MODEL: "i3dm",
    GEOMETRY: "geom",
    VECTOR: "vect",
    GLTF: "glTF"
  };
  var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-utils.js
  function getStringFromArrayBuffer(arrayBuffer2, byteOffset, byteLength) {
    assert2(arrayBuffer2 instanceof ArrayBuffer);
    const textDecoder = new TextDecoder("utf8");
    const typedArray = new Uint8Array(arrayBuffer2, byteOffset, byteLength);
    const string = textDecoder.decode(typedArray);
    return string;
  }
  function getMagicString4(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const dataView = new DataView(arrayBuffer2);
    return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/constants.js
  var GL_PRIMITIVE_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var GL_TYPE = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    DOUBLE: 5130
  };
  var GL2 = {
    ...GL_PRIMITIVE_MODE,
    ...GL_TYPE
  };

  // ../../node_modules/@loaders.gl/math/dist/geometry/gl/gl-type.js
  var GL_TYPE_TO_ARRAY_TYPE = {
    [GL_TYPE.DOUBLE]: Float64Array,
    [GL_TYPE.FLOAT]: Float32Array,
    [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
    [GL_TYPE.UNSIGNED_INT]: Uint32Array,
    [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
    [GL_TYPE.BYTE]: Int8Array,
    [GL_TYPE.SHORT]: Int16Array,
    [GL_TYPE.INT]: Int32Array
  };
  var NAME_TO_GL_TYPE = {
    DOUBLE: GL_TYPE.DOUBLE,
    FLOAT: GL_TYPE.FLOAT,
    UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
    UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
    UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
    BYTE: GL_TYPE.BYTE,
    SHORT: GL_TYPE.SHORT,
    INT: GL_TYPE.INT
  };
  var ERR_TYPE_CONVERSION = "Failed to convert GL type";
  var GLType = class {
    static fromTypedArray(arrayOrType) {
      arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
      for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
        const ArrayType2 = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (ArrayType2 === arrayOrType) {
          return glType;
        }
      }
      throw new Error(ERR_TYPE_CONVERSION);
    }
    static fromName(name13) {
      const glType = NAME_TO_GL_TYPE[name13];
      if (!glType) {
        throw new Error(ERR_TYPE_CONVERSION);
      }
      return glType;
    }
    static getArrayType(glType) {
      switch (glType) {
        case GL_TYPE.UNSIGNED_SHORT_5_6_5:
        case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
        case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
          return Uint16Array;
        default:
          const ArrayType2 = GL_TYPE_TO_ARRAY_TYPE[glType];
          if (!ArrayType2) {
            throw new Error(ERR_TYPE_CONVERSION);
          }
          return ArrayType2;
      }
    }
    static getByteSize(glType) {
      const ArrayType2 = GLType.getArrayType(glType);
      return ArrayType2.BYTES_PER_ELEMENT;
    }
    static validate(glType) {
      return Boolean(GLType.getArrayType(glType));
    }
    static createTypedArray(glType, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let length6 = arguments.length > 3 ? arguments[3] : void 0;
      if (length6 === void 0) {
        length6 = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);
      }
      const ArrayType2 = GLType.getArrayType(glType);
      return new ArrayType2(buffer, byteOffset, length6);
    }
  };

  // ../../node_modules/@loaders.gl/math/dist/geometry/utils/assert.js
  function assert11(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion failed. ${message2}`);
    }
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/colors/rgb565.js
  function decodeRGB565(rgb565) {
    let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const r5 = rgb565 >> 11 & 31;
    const g6 = rgb565 >> 5 & 63;
    const b5 = rgb565 & 31;
    target[0] = r5 << 3;
    target[1] = g6 << 2;
    target[2] = b5 << 3;
    return target;
  }

  // ../../node_modules/@loaders.gl/math/dist/geometry/compression/attribute-compression.js
  var RIGHT_SHIFT = 1 / 256;
  var scratchVector25 = new Vector2();
  var scratchVector35 = new Vector3();
  var scratchEncodeVector2 = new Vector2();
  var octEncodeScratch = new Vector2();
  var uint8ForceArray = new Uint8Array(1);
  function fromSNorm(value) {
    let rangeMaximum = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
    return clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
  }
  function signNotZero(value) {
    return value < 0 ? -1 : 1;
  }
  function octDecodeInRange(x3, y3, rangeMax, result) {
    assert11(result);
    if (x3 < 0 || x3 > rangeMax || y3 < 0 || y3 > rangeMax) {
      throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);
    }
    result.x = fromSNorm(x3, rangeMax);
    result.y = fromSNorm(y3, rangeMax);
    result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
    if (result.z < 0) {
      const oldVX = result.x;
      result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
      result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
    }
    return result.normalize();
  }
  function octDecode(x3, y3, result) {
    return octDecodeInRange(x3, y3, 255, result);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-feature-table.js
  var Tile3DFeatureTable = class {
    constructor(featureTableJson, featureTableBinary) {
      this.json = void 0;
      this.buffer = void 0;
      this.featuresLength = 0;
      this._cachedTypedArrays = {};
      this.json = featureTableJson;
      this.buffer = featureTableBinary;
    }
    getExtension(extensionName) {
      return this.json.extensions && this.json.extensions[extensionName];
    }
    hasProperty(propertyName) {
      return Boolean(this.json[propertyName]);
    }
    getGlobalProperty(propertyName) {
      let componentType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GL2.UNSIGNED_INT;
      let componentLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
      }
      return jsonValue;
    }
    getPropertyArray(propertyName, componentType, componentLength) {
      const jsonValue = this.json[propertyName];
      if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
        if ("componentType" in jsonValue) {
          componentType = GLType.fromName(jsonValue.componentType);
        }
        return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
      }
      return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
    }
    getProperty(propertyName, componentType, componentLength, featureId, result) {
      const jsonValue = this.json[propertyName];
      if (!jsonValue) {
        return jsonValue;
      }
      const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
      if (componentLength === 1) {
        return typedArray[featureId];
      }
      for (let i5 = 0; i5 < componentLength; ++i5) {
        result[i5] = typedArray[componentLength * featureId + i5];
      }
      return result;
    }
    _getTypedArrayFromBinary(propertyName, componentType, componentLength, count2, byteOffset) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count2 * componentLength);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
    _getTypedArrayFromArray(propertyName, componentType, array) {
      const cachedTypedArrays = this._cachedTypedArrays;
      let typedArray = cachedTypedArrays[propertyName];
      if (!typedArray) {
        typedArray = GLType.createTypedArray(componentType, array);
        cachedTypedArrays[propertyName] = typedArray;
      }
      return typedArray;
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/helpers/tile-3d-accessor-utils.js
  var COMPONENTS_PER_ATTRIBUTE = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var UNPACKER = {
    SCALAR: (values, i5) => values[i5],
    VEC2: (values, i5) => [values[2 * i5 + 0], values[2 * i5 + 1]],
    VEC3: (values, i5) => [values[3 * i5 + 0], values[3 * i5 + 1], values[3 * i5 + 2]],
    VEC4: (values, i5) => [values[4 * i5 + 0], values[4 * i5 + 1], values[4 * i5 + 2], values[4 * i5 + 3]],
    MAT2: (values, i5) => [values[4 * i5 + 0], values[4 * i5 + 1], values[4 * i5 + 2], values[4 * i5 + 3]],
    MAT3: (values, i5) => [values[9 * i5 + 0], values[9 * i5 + 1], values[9 * i5 + 2], values[9 * i5 + 3], values[9 * i5 + 4], values[9 * i5 + 5], values[9 * i5 + 6], values[9 * i5 + 7], values[9 * i5 + 8]],
    MAT4: (values, i5) => [values[16 * i5 + 0], values[16 * i5 + 1], values[16 * i5 + 2], values[16 * i5 + 3], values[16 * i5 + 4], values[16 * i5 + 5], values[16 * i5 + 6], values[16 * i5 + 7], values[16 * i5 + 8], values[16 * i5 + 9], values[16 * i5 + 10], values[16 * i5 + 11], values[16 * i5 + 12], values[16 * i5 + 13], values[16 * i5 + 14], values[16 * i5 + 15]]
  };
  var PACKER = {
    SCALAR: (x3, values, i5) => {
      values[i5] = x3;
    },
    VEC2: (x3, values, i5) => {
      values[2 * i5 + 0] = x3[0];
      values[2 * i5 + 1] = x3[1];
    },
    VEC3: (x3, values, i5) => {
      values[3 * i5 + 0] = x3[0];
      values[3 * i5 + 1] = x3[1];
      values[3 * i5 + 2] = x3[2];
    },
    VEC4: (x3, values, i5) => {
      values[4 * i5 + 0] = x3[0];
      values[4 * i5 + 1] = x3[1];
      values[4 * i5 + 2] = x3[2];
      values[4 * i5 + 3] = x3[3];
    },
    MAT2: (x3, values, i5) => {
      values[4 * i5 + 0] = x3[0];
      values[4 * i5 + 1] = x3[1];
      values[4 * i5 + 2] = x3[2];
      values[4 * i5 + 3] = x3[3];
    },
    MAT3: (x3, values, i5) => {
      values[9 * i5 + 0] = x3[0];
      values[9 * i5 + 1] = x3[1];
      values[9 * i5 + 2] = x3[2];
      values[9 * i5 + 3] = x3[3];
      values[9 * i5 + 4] = x3[4];
      values[9 * i5 + 5] = x3[5];
      values[9 * i5 + 6] = x3[6];
      values[9 * i5 + 7] = x3[7];
      values[9 * i5 + 8] = x3[8];
      values[9 * i5 + 9] = x3[9];
    },
    MAT4: (x3, values, i5) => {
      values[16 * i5 + 0] = x3[0];
      values[16 * i5 + 1] = x3[1];
      values[16 * i5 + 2] = x3[2];
      values[16 * i5 + 3] = x3[3];
      values[16 * i5 + 4] = x3[4];
      values[16 * i5 + 5] = x3[5];
      values[16 * i5 + 6] = x3[6];
      values[16 * i5 + 7] = x3[7];
      values[16 * i5 + 8] = x3[8];
      values[16 * i5 + 9] = x3[9];
      values[16 * i5 + 10] = x3[10];
      values[16 * i5 + 11] = x3[11];
      values[16 * i5 + 12] = x3[12];
      values[16 * i5 + 13] = x3[13];
      values[16 * i5 + 14] = x3[14];
      values[16 * i5 + 15] = x3[15];
    }
  };
  function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length6) {
    const {
      componentType
    } = tile3DAccessor;
    assert2(tile3DAccessor.componentType);
    const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
    const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
    const unpacker = UNPACKER[tile3DAccessor.type];
    const packer = PACKER[tile3DAccessor.type];
    byteOffset += tile3DAccessor.byteOffset;
    const values = GLType.createTypedArray(type, buffer, byteOffset, size * length6);
    return {
      values,
      type,
      size,
      unpacker,
      packer
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table-hierarchy.js
  var defined3 = (x3) => x3 !== void 0;
  function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
    if (!jsonHeader) {
      return null;
    }
    let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
    const legacyHierarchy = jsonHeader.HIERARCHY;
    if (legacyHierarchy) {
      console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
      jsonHeader.extensions = jsonHeader.extensions || {};
      jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
      hierarchy = legacyHierarchy;
    }
    if (!hierarchy) {
      return null;
    }
    return initializeHierarchyValues(hierarchy, binaryBody);
  }
  function initializeHierarchyValues(hierarchyJson, binaryBody) {
    let i5;
    let classId;
    let binaryAccessor;
    const instancesLength = hierarchyJson.instancesLength;
    const classes = hierarchyJson.classes;
    let classIds = hierarchyJson.classIds;
    let parentCounts = hierarchyJson.parentCounts;
    let parentIds = hierarchyJson.parentIds;
    let parentIdsLength = instancesLength;
    if (defined3(classIds.byteOffset)) {
      classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
      classIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(classIds);
      classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
    }
    let parentIndexes;
    if (defined3(parentCounts)) {
      if (defined3(parentCounts.byteOffset)) {
        parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
        parentCounts.type = AttributeType.SCALAR;
        binaryAccessor = getBinaryAccessor(parentCounts);
        parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
      }
      parentIndexes = new Uint16Array(instancesLength);
      parentIdsLength = 0;
      for (i5 = 0; i5 < instancesLength; ++i5) {
        parentIndexes[i5] = parentIdsLength;
        parentIdsLength += parentCounts[i5];
      }
    }
    if (defined3(parentIds) && defined3(parentIds.byteOffset)) {
      parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
      parentIds.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentIds);
      parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
    }
    const classesLength = classes.length;
    for (i5 = 0; i5 < classesLength; ++i5) {
      const classInstancesLength = classes[i5].length;
      const properties = classes[i5].instances;
      const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
      classes[i5].instances = combine(binaryProperties, properties);
    }
    const classCounts = new Array(classesLength).fill(0);
    const classIndexes = new Uint16Array(instancesLength);
    for (i5 = 0; i5 < instancesLength; ++i5) {
      classId = classIds[i5];
      classIndexes[i5] = classCounts[classId];
      ++classCounts[classId];
    }
    const hierarchy = {
      classes,
      classIds,
      classIndexes,
      parentCounts,
      parentIndexes,
      parentIds
    };
    validateHierarchy(hierarchy);
    return hierarchy;
  }
  function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
    if (!hierarchy) {
      return;
    }
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    if (parentIds) {
      return endConditionCallback(hierarchy, instanceIndex);
    }
    if (parentCounts > 0) {
      return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
    }
    return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
  }
  function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
    const classIds = hierarchy.classIds;
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const instancesLength = classIds.length;
    const visited = scratchVisited;
    visited.length = Math.max(visited.length, instancesLength);
    const visitedMarker = ++marker;
    const stack2 = scratchStack;
    stack2.length = 0;
    stack2.push(instanceIndex);
    while (stack2.length > 0) {
      instanceIndex = stack2.pop();
      if (visited[instanceIndex] === visitedMarker) {
        continue;
      }
      visited[instanceIndex] = visitedMarker;
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentCount = parentCounts[instanceIndex];
      const parentIndex = parentIndexes[instanceIndex];
      for (let i5 = 0; i5 < parentCount; ++i5) {
        const parentId = parentIds[parentIndex + i5];
        if (parentId !== instanceIndex) {
          stack2.push(parentId);
        }
      }
    }
    return null;
  }
  function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
    let hasParent = true;
    while (hasParent) {
      const result = endConditionCallback(hierarchy, instanceIndex);
      if (defined3(result)) {
        return result;
      }
      const parentId = hierarchy.parentIds[instanceIndex];
      hasParent = parentId !== instanceIndex;
      instanceIndex = parentId;
    }
    throw new Error("traverseHierarchySingleParent");
  }
  function validateHierarchy(hierarchy) {
    const scratchValidateStack = [];
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    for (let i5 = 0; i5 < instancesLength; ++i5) {
      validateInstance(hierarchy, i5, stack);
    }
  }
  function validateInstance(hierarchy, instanceIndex, stack2) {
    const parentCounts = hierarchy.parentCounts;
    const parentIds = hierarchy.parentIds;
    const parentIndexes = hierarchy.parentIndexes;
    const classIds = hierarchy.classIds;
    const instancesLength = classIds.length;
    if (!defined3(parentIds)) {
      return;
    }
    assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);
    assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
    stack2.push(instanceIndex);
    const parentCount = defined3(parentCounts) ? parentCounts[instanceIndex] : 1;
    const parentIndex = defined3(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
    for (let i5 = 0; i5 < parentCount; ++i5) {
      const parentId = parentIds[parentIndex + i5];
      if (parentId !== instanceIndex) {
        validateInstance(hierarchy, parentId, stack2);
      }
    }
    stack2.pop(instanceIndex);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table.js
  function defined4(x3) {
    return x3 !== void 0 && x3 !== null;
  }
  var clone6 = (x3, y3) => x3;
  var IGNORED_PROPERTY_FIELDS = {
    HIERARCHY: true,
    extensions: true,
    extras: true
  };
  var Tile3DBatchTableParser = class {
    constructor(json, binary, featureCount) {
      var _this$json;
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      this.json = void 0;
      this.binary = void 0;
      this.featureCount = void 0;
      this._extensions = void 0;
      this._properties = void 0;
      this._binaryProperties = void 0;
      this._hierarchy = void 0;
      assert2(featureCount >= 0);
      this.json = json || {};
      this.binary = binary;
      this.featureCount = featureCount;
      this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};
      this._properties = {};
      for (const propertyName in this.json) {
        if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
          this._properties[propertyName] = this.json[propertyName];
        }
      }
      this._binaryProperties = this._initializeBinaryProperties();
      if (options["3DTILES_batch_table_hierarchy"]) {
        this._hierarchy = initializeHierarchy(this, this.json, this.binary);
      }
    }
    getExtension(extensionName) {
      return this.json && this.json.extensions && this.json.extensions[extensionName];
    }
    memorySizeInBytes() {
      return 0;
    }
    isClass(batchId, className) {
      this._checkBatchId(batchId);
      assert2(typeof className === "string", className);
      if (this._hierarchy) {
        const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
          const classId = hierarchy.classIds[instanceIndex];
          const instanceClass = hierarchy.classes[classId];
          return instanceClass.name === className;
        });
        return defined4(result);
      }
      return false;
    }
    isExactClass(batchId, className) {
      assert2(typeof className === "string", className);
      return this.getExactClassName(batchId) === className;
    }
    getExactClassName(batchId) {
      this._checkBatchId(batchId);
      if (this._hierarchy) {
        const classId = this._hierarchy.classIds[batchId];
        const instanceClass = this._hierarchy.classes[classId];
        return instanceClass.name;
      }
      return void 0;
    }
    hasProperty(batchId, name13) {
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      return defined4(this._properties[name13]) || this._hasPropertyInHierarchy(batchId, name13);
    }
    getPropertyNames(batchId, results) {
      this._checkBatchId(batchId);
      results = defined4(results) ? results : [];
      results.length = 0;
      const propertyNames = Object.keys(this._properties);
      results.push(...propertyNames);
      if (this._hierarchy) {
        this._getPropertyNamesInHierarchy(batchId, results);
      }
      return results;
    }
    getProperty(batchId, name13) {
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name13];
        if (defined4(binaryProperty)) {
          return this._getBinaryProperty(binaryProperty, batchId);
        }
      }
      const propertyValues = this._properties[name13];
      if (defined4(propertyValues)) {
        return clone6(propertyValues[batchId], true);
      }
      if (this._hierarchy) {
        const hierarchyProperty = this._getHierarchyProperty(batchId, name13);
        if (defined4(hierarchyProperty)) {
          return hierarchyProperty;
        }
      }
      return void 0;
    }
    setProperty(batchId, name13, value) {
      const featureCount = this.featureCount;
      this._checkBatchId(batchId);
      assert2(typeof name13 === "string", name13);
      if (this._binaryProperties) {
        const binaryProperty = this._binaryProperties[name13];
        if (binaryProperty) {
          this._setBinaryProperty(binaryProperty, batchId, value);
          return;
        }
      }
      if (this._hierarchy) {
        if (this._setHierarchyProperty(this, batchId, name13, value)) {
          return;
        }
      }
      let propertyValues = this._properties[name13];
      if (!defined4(propertyValues)) {
        this._properties[name13] = new Array(featureCount);
        propertyValues = this._properties[name13];
      }
      propertyValues[batchId] = clone6(value, true);
    }
    _checkBatchId(batchId) {
      const valid = batchId >= 0 && batchId < this.featureCount;
      if (!valid) {
        throw new Error("batchId not in range [0, featureCount - 1].");
      }
    }
    _getBinaryProperty(binaryProperty, index2) {
      return binaryProperty.unpack(binaryProperty.typedArray, index2);
    }
    _setBinaryProperty(binaryProperty, index2, value) {
      binaryProperty.pack(value, binaryProperty.typedArray, index2);
    }
    _initializeBinaryProperties() {
      let binaryProperties = null;
      for (const name13 in this._properties) {
        const property = this._properties[name13];
        const binaryProperty = this._initializeBinaryProperty(name13, property);
        if (binaryProperty) {
          binaryProperties = binaryProperties || {};
          binaryProperties[name13] = binaryProperty;
        }
      }
      return binaryProperties;
    }
    _initializeBinaryProperty(name13, property) {
      if ("byteOffset" in property) {
        const tile3DAccessor = property;
        assert2(this.binary, `Property ${name13} requires a batch table binary.`);
        assert2(tile3DAccessor.type, `Property ${name13} requires a type.`);
        const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
        return {
          typedArray: accessor.values,
          componentCount: accessor.size,
          unpack: accessor.unpacker,
          pack: accessor.packer
        };
      }
      return null;
    }
    _hasPropertyInHierarchy(batchId, name13) {
      if (!this._hierarchy) {
        return false;
      }
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        return defined4(instances[name13]);
      });
      return defined4(result);
    }
    _getPropertyNamesInHierarchy(batchId, results) {
      traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instances = hierarchy.classes[classId].instances;
        for (const name13 in instances) {
          if (instances.hasOwnProperty(name13)) {
            if (results.indexOf(name13) === -1) {
              results.push(name13);
            }
          }
        }
      });
    }
    _getHierarchyProperty(batchId, name13) {
      return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name13];
        if (defined4(propertyValues)) {
          if (defined4(propertyValues.typedArray)) {
            return this._getBinaryProperty(propertyValues, indexInClass);
          }
          return clone6(propertyValues[indexInClass], true);
        }
        return null;
      });
    }
    _setHierarchyProperty(batchTable, batchId, name13, value) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        const indexInClass = hierarchy.classIndexes[instanceIndex];
        const propertyValues = instanceClass.instances[name13];
        if (defined4(propertyValues)) {
          assert2(instanceIndex === batchId, `Inherited property "${name13}" is read-only.`);
          if (defined4(propertyValues.typedArray)) {
            this._setBinaryProperty(propertyValues, indexInClass, value);
          } else {
            propertyValues[indexInClass] = clone6(value, true);
          }
          return true;
        }
        return false;
      });
      return defined4(result);
    }
  };

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-header.js
  var SIZEOF_UINT32 = 4;
  function parse3DTileHeaderSync(tile, arrayBuffer2) {
    let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const view = new DataView(arrayBuffer2);
    tile.magic = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.version = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    tile.byteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT32;
    if (tile.version !== 1) {
      throw new Error(`3D Tile Version ${tile.version} not supported`);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-tables.js
  var SIZEOF_UINT322 = 4;
  var DEPRECATION_WARNING = "b3dm tile in legacy format.";
  function parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset) {
    const view = new DataView(arrayBuffer2);
    let batchLength;
    tile.header = tile.header || {};
    let featureTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableJsonByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
    byteOffset += SIZEOF_UINT322;
    if (batchTableJsonByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322 * 2;
      batchLength = featureTableJsonByteLength;
      batchTableJsonByteLength = featureTableBinaryByteLength;
      batchTableBinaryByteLength = 0;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    } else if (batchTableBinaryByteLength >= 570425344) {
      byteOffset -= SIZEOF_UINT322;
      batchLength = batchTableJsonByteLength;
      batchTableJsonByteLength = featureTableJsonByteLength;
      batchTableBinaryByteLength = featureTableBinaryByteLength;
      featureTableJsonByteLength = 0;
      featureTableBinaryByteLength = 0;
      console.warn(DEPRECATION_WARNING);
    }
    tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
    tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
    tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
    tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
    tile.header.batchLength = batchLength;
    return byteOffset;
  }
  function parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options) {
    byteOffset = parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options);
    return byteOffset;
  }
  function parse3DTileFeatureTable(tile, arrayBuffer2, byteOffset, options) {
    const {
      featureTableJsonByteLength,
      featureTableBinaryByteLength,
      batchLength
    } = tile.header || {};
    tile.featureTableJson = {
      BATCH_LENGTH: batchLength || 0
    };
    if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {
      const featureTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, featureTableJsonByteLength);
      tile.featureTableJson = JSON.parse(featureTableString);
    }
    byteOffset += featureTableJsonByteLength || 0;
    tile.featureTableBinary = new Uint8Array(arrayBuffer2, byteOffset, featureTableBinaryByteLength);
    byteOffset += featureTableBinaryByteLength || 0;
    return byteOffset;
  }
  function parse3DTileBatchTable(tile, arrayBuffer2, byteOffset, options) {
    const {
      batchTableJsonByteLength,
      batchTableBinaryByteLength
    } = tile.header || {};
    if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {
      const batchTableString = getStringFromArrayBuffer(arrayBuffer2, byteOffset, batchTableJsonByteLength);
      tile.batchTableJson = JSON.parse(batchTableString);
      byteOffset += batchTableJsonByteLength;
      if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {
        tile.batchTableBinary = new Uint8Array(arrayBuffer2, byteOffset, batchTableBinaryByteLength);
        tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
        byteOffset += batchTableBinaryByteLength;
      }
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-colors.js
  function normalize3DTileColorAttribute(tile, colors, batchTable) {
    if (!colors && (!tile || !tile.batchIds || !batchTable)) {
      return null;
    }
    const {
      batchIds,
      isRGB565,
      pointCount = 0
    } = tile;
    if (batchIds && batchTable) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i5 = 0; i5 < pointCount; i5++) {
        const batchId = batchIds[i5];
        const dimensions = batchTable.getProperty(batchId, "dimensions");
        const color = dimensions.map((d2) => d2 * 255);
        colorArray[i5 * 3] = color[0];
        colorArray[i5 * 3 + 1] = color[1];
        colorArray[i5 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && isRGB565) {
      const colorArray = new Uint8ClampedArray(pointCount * 3);
      for (let i5 = 0; i5 < pointCount; i5++) {
        const color = decodeRGB565(colors[i5]);
        colorArray[i5 * 3] = color[0];
        colorArray[i5 * 3 + 1] = color[1];
        colorArray[i5 * 3 + 2] = color[2];
      }
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colorArray,
        size: 3,
        normalized: true
      };
    }
    if (colors && colors.length === pointCount * 3) {
      return {
        type: GL2.UNSIGNED_BYTE,
        value: colors,
        size: 3,
        normalized: true
      };
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors || new Uint8ClampedArray(),
      size: 4,
      normalized: true
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-normals.js
  var scratchNormal4 = new Vector3();
  function normalize3DTileNormalAttribute(tile, normals) {
    if (!normals) {
      return null;
    }
    if (tile.isOctEncoded16P) {
      const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);
      for (let i5 = 0; i5 < (tile.pointsLength || 0); i5++) {
        octDecode(normals[i5 * 2], normals[i5 * 2 + 1], scratchNormal4);
        scratchNormal4.toArray(decodedArray, i5 * 3);
      }
      return {
        type: GL2.FLOAT,
        size: 2,
        value: decodedArray
      };
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: normals
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-positions.js
  function normalize3DTilePositionAttribute(tile, positions, options) {
    if (!tile.isQuantized) {
      return positions;
    }
    if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
      tile.isQuantized = false;
      return decodeQuantizedPositions(tile, positions);
    }
    return {
      type: GL2.UNSIGNED_SHORT,
      value: positions,
      size: 3,
      normalized: true
    };
  }
  function decodeQuantizedPositions(tile, positions) {
    const scratchPosition5 = new Vector3();
    const decodedArray = new Float32Array(tile.pointCount * 3);
    for (let i5 = 0; i5 < tile.pointCount; i5++) {
      scratchPosition5.set(positions[i5 * 3], positions[i5 * 3 + 1], positions[i5 * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i5 * 3);
    }
    return decodedArray;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-point-cloud.js
  async function parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    initializeTile(tile);
    const {
      featureTable,
      batchTable
    } = parsePointCloudTables(tile);
    await parseDraco(tile, featureTable, batchTable, options, context);
    parsePositions(tile, featureTable, options);
    parseColors(tile, featureTable, batchTable);
    parseNormals(tile, featureTable);
    return byteOffset;
  }
  function initializeTile(tile) {
    tile.attributes = {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    tile.isQuantized = false;
    tile.isTranslucent = false;
    tile.isRGB565 = false;
    tile.isOctEncoded16P = false;
  }
  function parsePointCloudTables(tile) {
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
    if (!Number.isFinite(pointsLength)) {
      throw new Error("POINTS_LENGTH must be defined");
    }
    featureTable.featuresLength = pointsLength;
    tile.featuresLength = pointsLength;
    tile.pointsLength = pointsLength;
    tile.pointCount = pointsLength;
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = parseBatchIds(tile, featureTable);
    return {
      featureTable,
      batchTable
    };
  }
  function parsePositions(tile, featureTable, options) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.positions) {
      if (featureTable.hasProperty("POSITION")) {
        tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
        tile.isQuantized = true;
        tile.quantizedRange = (1 << 16) - 1;
        tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeScale) {
          throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!tile.quantizedVolumeOffset) {
          throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
      }
    }
    if (!tile.attributes.positions) {
      throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
    }
  }
  function parseColors(tile, featureTable, batchTable) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.colors) {
      let colors = null;
      if (featureTable.hasProperty("RGBA")) {
        colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
        tile.isTranslucent = true;
      } else if (featureTable.hasProperty("RGB")) {
        colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
      } else if (featureTable.hasProperty("RGB565")) {
        colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
        tile.isRGB565 = true;
      }
      tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
    }
    if (featureTable.hasProperty("CONSTANT_RGBA")) {
      tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
    }
  }
  function parseNormals(tile, featureTable) {
    tile.attributes = tile.attributes || {
      positions: null,
      colors: null,
      normals: null,
      batchIds: null
    };
    if (!tile.attributes.normals) {
      let normals = null;
      if (featureTable.hasProperty("NORMAL")) {
        normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
      } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
        normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
        tile.isOctEncoded16P = true;
      }
      tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
    }
  }
  function parseBatchIds(tile, featureTable) {
    let batchTable = null;
    if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
      tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
      if (tile.batchIds) {
        const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
        if (!batchFeatureLength) {
          throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
        }
        const {
          batchTableJson,
          batchTableBinary
        } = tile;
        batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
      }
    }
    return batchTable;
  }
  async function parseDraco(tile, featureTable, batchTable, options, context) {
    let dracoBuffer;
    let dracoFeatureTableProperties;
    let dracoBatchTableProperties;
    const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
    if (batchTableDraco) {
      dracoBatchTableProperties = batchTableDraco.properties;
    }
    const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
    if (featureTableDraco) {
      dracoFeatureTableProperties = featureTableDraco.properties;
      const dracoByteOffset = featureTableDraco.byteOffset;
      const dracoByteLength = featureTableDraco.byteLength;
      if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
        throw new Error("Draco properties, byteOffset, and byteLength must be defined");
      }
      dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
      tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
      tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
      tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
      tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
      tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
    }
    if (!dracoBuffer) {
      return true;
    }
    const dracoData = {
      buffer: dracoBuffer,
      properties: {
        ...dracoFeatureTableProperties,
        ...dracoBatchTableProperties
      },
      featureTableProperties: dracoFeatureTableProperties,
      batchTableProperties: dracoBatchTableProperties,
      dequantizeInShader: false
    };
    return await loadDraco(tile, dracoData, options, context);
  }
  async function loadDraco(tile, dracoData, options, context) {
    if (!context) {
      return;
    }
    const dracoOptions = {
      ...options,
      draco: {
        ...options === null || options === void 0 ? void 0 : options.draco,
        extraAttributes: dracoData.batchTableProperties || {}
      }
    };
    delete dracoOptions["3d-tiles"];
    const data = await parseFromContext(dracoData.buffer, DracoLoader2, dracoOptions, context);
    const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
    const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
    const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
    const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
    const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
    const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
    if (isQuantizedDraco) {
      const quantization = data.POSITION.data.quantization;
      const range = quantization.range;
      tile.quantizedVolumeScale = new Vector3(range, range, range);
      tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
      tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
      tile.isQuantizedDraco = true;
    }
    if (isOctEncodedDraco) {
      tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
      tile.isOctEncodedDraco = true;
    }
    const batchTableAttributes = {};
    if (dracoData.batchTableProperties) {
      for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
        if (data.attributes[attributeName] && data.attributes[attributeName].value) {
          batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
        }
      }
    }
    tile.attributes = {
      positions: decodedPositions,
      colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
      normals: decodedNormals,
      batchIds: decodedBatchIds,
      ...batchTableAttributes
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js
  var GLTF_FORMAT = {
    URI: 0,
    EMBEDDED: 1
  };
  function parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options) {
    tile.rotateYtoZ = true;
    const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;
    if (gltfByteLength === 0) {
      throw new Error("glTF byte length must be greater than 0.");
    }
    tile.gltfUpAxis = options !== null && options !== void 0 && options["3d-tiles"] && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer2, byteOffset, gltfByteLength);
    tile.gltfByteOffset = 0;
    tile.gltfByteLength = gltfByteLength;
    if (byteOffset % 4 === 0) {
    } else {
      console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
    }
    return (tile.byteOffset || 0) + (tile.byteLength || 0);
  }
  async function extractGLTF(tile, gltfFormat, options, context) {
    const tile3DOptions = (options === null || options === void 0 ? void 0 : options["3d-tiles"]) || {};
    extractGLTFBufferOrURL(tile, gltfFormat, options);
    if (tile3DOptions.loadGLTF) {
      if (!context) {
        return;
      }
      if (tile.gltfUrl) {
        const {
          fetch: fetch2
        } = context;
        const response = await fetch2(tile.gltfUrl, options);
        tile.gltfArrayBuffer = await response.arrayBuffer();
        tile.gltfByteOffset = 0;
      }
      if (tile.gltfArrayBuffer) {
        const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);
        tile.gltf = postProcessGLTF(gltfWithBuffers);
        tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
      }
    }
  }
  function extractGLTFBufferOrURL(tile, gltfFormat, options) {
    switch (gltfFormat) {
      case GLTF_FORMAT.URI:
        if (tile.gltfArrayBuffer) {
          const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
          const textDecoder = new TextDecoder();
          const gltfUrl = textDecoder.decode(gltfUrlBytes);
          tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
        }
        delete tile.gltfArrayBuffer;
        delete tile.gltfByteOffset;
        delete tile.gltfByteLength;
        break;
      case GLTF_FORMAT.EMBEDDED:
        break;
      default:
        throw new Error("b3dm: Illegal glTF format field");
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-batched-model.js
  async function parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    var _tile$gltf;
    byteOffset = parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
    const extensions = tile === null || tile === void 0 ? void 0 : (_tile$gltf = tile.gltf) === null || _tile$gltf === void 0 ? void 0 : _tile$gltf.extensions;
    if (extensions && extensions.CESIUM_RTC) {
      tile.rtcCenter = extensions.CESIUM_RTC.center;
    }
    return byteOffset;
  }
  function parseBatchedModel(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-instanced-model.js
  async function parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context) {
    byteOffset = parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context);
    await extractGLTF(tile, tile.gltfFormat || 0, options, context);
    return byteOffset;
  }
  function parseInstancedModel(tile, arrayBuffer2, byteOffset, options, context) {
    var _tile$header;
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    if (tile.version !== 1) {
      throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
    }
    byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.gltfFormat = view.getUint32(byteOffset, true);
    byteOffset += 4;
    byteOffset = parse3DTileTablesSync(tile, arrayBuffer2, byteOffset, options);
    byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer2, byteOffset, options);
    if (!(tile !== null && tile !== void 0 && (_tile$header = tile.header) !== null && _tile$header !== void 0 && _tile$header.featureTableJsonByteLength) || tile.header.featureTableJsonByteLength === 0) {
      throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
    }
    const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
    const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
    featureTable.featuresLength = instancesLength;
    if (!Number.isFinite(instancesLength)) {
      throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
    }
    tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
    tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
    const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
    extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
    return byteOffset;
  }
  function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
    const instances = new Array(instancesLength);
    const instancePosition = new Vector3();
    const instanceNormalRight = new Vector3();
    const instanceNormalUp = new Vector3();
    const instanceNormalForward = new Vector3();
    const instanceRotation = new Matrix3();
    const instanceQuaternion = new Quaternion();
    const instanceScale = new Vector3();
    const instanceTranslationRotationScale = {};
    const instanceTransform = new Matrix4();
    const scratch1 = [];
    const scratch2 = [];
    const scratch3 = [];
    const scratch4 = [];
    for (let i5 = 0; i5 < instancesLength; i5++) {
      let position;
      if (featureTable.hasProperty("POSITION")) {
        position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i5, instancePosition);
      } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
        position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i5, instancePosition);
        const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
        if (!quantizedVolumeOffset) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
        }
        const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
        if (!quantizedVolumeScale) {
          throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
        }
        const MAX_UNSIGNED_SHORT = 65535;
        for (let j2 = 0; j2 < 3; j2++) {
          position[j2] = position[j2] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j2] + quantizedVolumeOffset[j2];
        }
      }
      if (!position) {
        throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
      }
      instancePosition.copy(position);
      instanceTranslationRotationScale.translation = instancePosition;
      tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i5, scratch1);
      tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i5, scratch2);
      const hasCustomOrientation = false;
      if (tile.normalUp) {
        if (!tile.normalRight) {
          throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
        }
        tile.hasCustomOrientation = true;
      } else {
        tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, i5, scratch1);
        tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, i5, scratch2);
        if (tile.octNormalUp) {
          if (!tile.octNormalRight) {
            throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
          }
          throw new Error("i3dm: oct-encoded orientation not implemented");
        } else if (tile.eastNorthUp) {
          Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
          instanceTransform.getRotationMatrix3(instanceRotation);
        } else {
          instanceRotation.identity();
        }
      }
      if (hasCustomOrientation) {
        instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
        instanceRotation.setColumn(0, instanceNormalRight);
        instanceRotation.setColumn(1, instanceNormalUp);
        instanceRotation.setColumn(2, instanceNormalForward);
      }
      instanceQuaternion.fromMatrix3(instanceRotation);
      instanceTranslationRotationScale.rotation = instanceQuaternion;
      instanceScale.set(1, 1, 1);
      const scale7 = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i5, scratch3);
      if (Number.isFinite(scale7)) {
        instanceScale.multiplyByScalar(scale7);
      }
      const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i5, scratch1);
      if (nonUniformScale) {
        instanceScale.scale(nonUniformScale);
      }
      instanceTranslationRotationScale.scale = instanceScale;
      let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i5, scratch4);
      if (batchId === void 0) {
        batchId = i5;
      }
      const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
      instanceTransform.identity();
      instanceTransform.translate(instanceTranslationRotationScale.translation);
      instanceTransform.multiplyRight(rotationMatrix);
      instanceTransform.scale(instanceTranslationRotationScale.scale);
      const modelMatrix2 = instanceTransform.clone();
      instances[i5] = {
        modelMatrix: modelMatrix2,
        batchId
      };
    }
    tile.instances = instances;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-composite.js
  async function parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile2) {
    byteOffset = parse3DTileHeaderSync(tile, arrayBuffer2, byteOffset);
    const view = new DataView(arrayBuffer2);
    tile.tilesLength = view.getUint32(byteOffset, true);
    byteOffset += 4;
    tile.tiles = [];
    while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {
      const subtile = {
        shape: "tile3d"
      };
      tile.tiles.push(subtile);
      byteOffset = await parse3DTile2(arrayBuffer2, byteOffset, options, context, subtile);
    }
    return byteOffset;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-gltf.js
  async function parseGltf3DTile(tile, arrayBuffer2, options, context) {
    var _options$3dTiles, _options$3dTiles2;
    tile.rotateYtoZ = true;
    tile.gltfUpAxis = options !== null && options !== void 0 && (_options$3dTiles = options["3d-tiles"]) !== null && _options$3dTiles !== void 0 && _options$3dTiles.assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
    if (options !== null && options !== void 0 && (_options$3dTiles2 = options["3d-tiles"]) !== null && _options$3dTiles2 !== void 0 && _options$3dTiles2.loadGLTF) {
      if (!context) {
        return arrayBuffer2.byteLength;
      }
      const gltfWithBuffers = await parseFromContext(arrayBuffer2, GLTFLoader, options, context);
      tile.gltf = postProcessGLTF(gltfWithBuffers);
      tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
    } else {
      tile.gltfArrayBuffer = arrayBuffer2;
    }
    return arrayBuffer2.byteLength;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile.js
  async function parse3DTile(arrayBuffer2) {
    let byteOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    let tile = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      shape: "tile3d"
    };
    tile.byteOffset = byteOffset;
    tile.type = getMagicString4(arrayBuffer2, byteOffset);
    switch (tile.type) {
      case TILE3D_TYPE.COMPOSITE:
        return await parseComposite3DTile(tile, arrayBuffer2, byteOffset, options, context, parse3DTile);
      case TILE3D_TYPE.BATCHED_3D_MODEL:
        return await parseBatchedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.GLTF:
        return await parseGltf3DTile(tile, arrayBuffer2, options, context);
      case TILE3D_TYPE.INSTANCED_3D_MODEL:
        return await parseInstancedModel3DTile(tile, arrayBuffer2, byteOffset, options, context);
      case TILE3D_TYPE.POINT_CLOUD:
        return await parsePointCloud3DTile(tile, arrayBuffer2, byteOffset, options, context);
      default:
        throw new Error(`3DTileLoader: unknown type ${tile.type}`);
    }
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-subtree.js
  var SUBTREE_FILE_MAGIC = 1952609651;
  var SUBTREE_FILE_VERSION = 1;
  async function parse3DTilesSubtree(data, options, context) {
    const magic = new Uint32Array(data.slice(0, 4));
    if (magic[0] !== SUBTREE_FILE_MAGIC) {
      throw new Error("Wrong subtree file magic number");
    }
    const version = new Uint32Array(data.slice(4, 8));
    if (version[0] !== SUBTREE_FILE_VERSION) {
      throw new Error("Wrong subtree file verson, must be 1");
    }
    const jsonByteLength = parseUint64Value(data.slice(8, 16));
    const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
    const textDecoder = new TextDecoder("utf8");
    const string = textDecoder.decode(stringAttribute);
    const subtree = JSON.parse(string);
    const binaryByteLength = parseUint64Value(data.slice(16, 24));
    let internalBinaryBuffer = new ArrayBuffer(0);
    if (binaryByteLength) {
      internalBinaryBuffer = data.slice(24 + jsonByteLength);
    }
    await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);
    if (Array.isArray(subtree.contentAvailability)) {
      for (const contentAvailability of subtree.contentAvailability) {
        await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);
      }
    } else {
      await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);
    }
    await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);
    return subtree;
  }
  async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {
    const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;
    if (typeof bufferViewIndex !== "number") {
      return;
    }
    const bufferView = subtree.bufferViews[bufferViewIndex];
    const buffer = subtree.buffers[bufferView.buffer];
    if (!(context !== null && context !== void 0 && context.baseUrl)) {
      throw new Error("Url is not provided");
    }
    if (!context.fetch) {
      throw new Error("fetch is not provided");
    }
    if (buffer.uri) {
      const bufferUri = `${(context === null || context === void 0 ? void 0 : context.baseUrl) || ""}/${buffer.uri}`;
      const response = await context.fetch(bufferUri);
      const data = await response.arrayBuffer();
      availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
      return;
    }
    const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);
    availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);
  }
  function parseUint64Value(buffer) {
    const dataView = new DataView(buffer);
    const left = dataView.getUint32(0, true);
    const right = dataView.getUint32(4, true);
    return left + 2 ** 32 * right;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/tile-3d-subtree-loader.js
  var Tile3DSubtreeLoader = {
    id: "3d-tiles-subtree",
    name: "3D Tiles Subtree",
    module: "3d-tiles",
    version: VERSION12,
    extensions: ["subtree"],
    mimeTypes: ["application/octet-stream"],
    tests: ["subtree"],
    parse: parse3DTilesSubtree,
    options: {}
  };

  // ../../node_modules/@loaders.gl/3d-tiles/node_modules/long/index.js
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e3) {
  }
  function Long3(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long3.prototype.__isLong__;
  Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function ctz32(value) {
    var c2 = Math.clz32(value & -value);
    return value ? 31 - c2 : c2;
  }
  Long3.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache3;
    if (unsigned) {
      value >>>= 0;
      if (cache3 = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, 0, true);
      if (cache3)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache3 = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache3)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long3.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO4;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long3.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long3(lowBits, highBits, unsigned);
  }
  Long3.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str5, unsigned, radix) {
    if (str5.length === 0)
      throw Error("empty string");
    if (typeof unsigned === "number") {
      radix = unsigned;
      unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    if (str5 === "NaN" || str5 === "Infinity" || str5 === "+Infinity" || str5 === "-Infinity")
      return unsigned ? UZERO : ZERO4;
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p3;
    if ((p3 = str5.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p3 === 0) {
      return fromString(str5.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO4;
    for (var i5 = 0; i5 < str5.length; i5 += 8) {
      var size = Math.min(8, str5.length - i5), value = parseInt(str5.substring(i5, i5 + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long3.fromString = fromString;
  function fromValue(val2, unsigned) {
    if (typeof val2 === "number")
      return fromNumber(val2, unsigned);
    if (typeof val2 === "string")
      return fromString(val2, unsigned);
    return fromBits(val2.low, val2.high, typeof unsigned === "boolean" ? unsigned : val2.unsigned);
  }
  Long3.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO4 = fromInt(0);
  Long3.ZERO = ZERO4;
  var UZERO = fromInt(0, true);
  Long3.UZERO = UZERO;
  var ONE = fromInt(1);
  Long3.ONE = ONE;
  var UONE = fromInt(1, true);
  Long3.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long3.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long3.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long3.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long3.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div4 = this.div(radixLong), rem1 = div4.mul(radixLong).sub(this);
        return div4.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val2 = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val2 & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals7(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(other);
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(other) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(other) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate4() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add7(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract5(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply7(multiplier) {
    if (this.isZero())
      return this;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm["mul"](
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero())
      return this.unsigned ? UZERO : ZERO4;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO4;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO4;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide4(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO4;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO4)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO4;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO4;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log23 = Math.ceil(Math.log(approx) / Math.LN2), delta = log23 <= 48 ? 1 : pow_dbl(2, log23 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
  };
  LongPrototype.clz = LongPrototype.countLeadingZeros;
  LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
  };
  LongPrototype.ctz = LongPrototype.countTrailingZeros;
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32)
      return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b2;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b2 = 32 - numBits;
      return fromBits(this.low << numBits | this.high >>> b2, this.high << numBits | this.low >>> b2, this.unsigned);
    }
    numBits -= 32;
    b2 = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b2, this.low << numBits | this.high >>> b2, this.unsigned);
  };
  LongPrototype.rotl = LongPrototype.rotateLeft;
  LongPrototype.rotateRight = function rotateRight(numBits) {
    var b2;
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    if (numBits === 32)
      return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
      b2 = 32 - numBits;
      return fromBits(this.high << b2 | this.low >>> numBits, this.low << b2 | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b2 = 32 - numBits;
    return fromBits(this.low << b2 | this.high >>> numBits, this.high << b2 | this.low >>> numBits, this.unsigned);
  };
  LongPrototype.rotr = LongPrototype.rotateRight;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long3.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
  };
  Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long3(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long3(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  var long_default = Long3;

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-token-functions.js
  var MAXIMUM_TOKEN_LENGTH = 16;
  function getS2CellIdFromToken(token) {
    if (token === "X") {
      token = "";
    }
    const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
    return long_default.fromString(paddedToken, true, 16);
  }
  function getS2TokenFromCellId(cellId) {
    if (cellId.isZero()) {
      return "X";
    }
    let numZeroDigits = cellId.countTrailingZeros();
    const remainder = numZeroDigits % 4;
    numZeroDigits = (numZeroDigits - remainder) / 4;
    const trailingZeroHexChars = numZeroDigits;
    numZeroDigits *= 4;
    const x3 = cellId.shiftRightUnsigned(numZeroDigits);
    const hexString = x3.toString(16).replace(/0+$/, "");
    const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
    return zeroString + hexString;
  }
  function getS2ChildCellId(cellId, index2) {
    const newLsb = lsb(cellId).shiftRightUnsigned(2);
    const childCellId = cellId.add(long_default.fromNumber(2 * index2 + 1 - 4).multiply(newLsb));
    return childCellId;
  }
  function lsb(cellId) {
    return cellId.and(cellId.not().add(1));
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-geometry.js
  var FACE_BITS2 = 3;
  var MAX_LEVEL2 = 30;
  var POS_BITS2 = 2 * MAX_LEVEL2 + 1;
  var RADIAN_TO_DEGREE2 = 180 / Math.PI;
  function getS2CellFromQuadKey(hilbertQuadkey) {
    if (hilbertQuadkey.length === 0) {
      throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);
    }
    const parts = hilbertQuadkey.split("/");
    const face = parseInt(parts[0], 10);
    const position = parts[1];
    const maxLevel = position.length;
    let level = 0;
    const point = [0, 0];
    for (let i5 = maxLevel - 1; i5 >= 0; i5--) {
      level = maxLevel - i5;
      const bit = position[i5];
      let rx = 0;
      let ry = 0;
      if (bit === "1") {
        ry = 1;
      } else if (bit === "2") {
        rx = 1;
        ry = 1;
      } else if (bit === "3") {
        rx = 1;
      }
      const val2 = Math.pow(2, level - 1);
      rotateAndFlipQuadrant2(val2, point, rx, ry);
      point[0] += val2 * rx;
      point[1] += val2 * ry;
    }
    if (face % 2 === 1) {
      const t3 = point[0];
      point[0] = point[1];
      point[1] = t3;
    }
    return {
      face,
      ij: point,
      level
    };
  }
  function getS2QuadkeyFromCellId(cellId) {
    if (cellId.isZero()) {
      return "";
    }
    let bin = cellId.toString(2);
    while (bin.length < FACE_BITS2 + POS_BITS2) {
      bin = "0" + bin;
    }
    const lsbIndex = bin.lastIndexOf("1");
    const faceB = bin.substring(0, 3);
    const posB = bin.substring(3, lsbIndex);
    const levelN = posB.length / 2;
    const faceS = long_default.fromString(faceB, true, 2).toString(10);
    let posS = "";
    if (levelN !== 0) {
      posS = long_default.fromString(posB, true, 2).toString(4);
      while (posS.length < levelN) {
        posS = "0" + posS;
      }
    }
    return `${faceS}/${posS}`;
  }
  function IJToST2(ij, level, offsets) {
    const maxSize = 1 << level;
    return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
  }
  function singleSTtoUV2(st) {
    if (st >= 0.5) {
      return 1 / 3 * (4 * st * st - 1);
    }
    return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
  }
  function STToUV2(st) {
    return [singleSTtoUV2(st[0]), singleSTtoUV2(st[1])];
  }
  function FaceUVToXYZ2(face, _ref) {
    let [u3, v2] = _ref;
    switch (face) {
      case 0:
        return [1, u3, v2];
      case 1:
        return [-u3, 1, v2];
      case 2:
        return [-u3, -v2, 1];
      case 3:
        return [-1, -v2, -u3];
      case 4:
        return [v2, -1, -u3];
      case 5:
        return [v2, u3, -1];
      default:
        throw new Error("Invalid face");
    }
  }
  function XYZToLngLat2(_ref2) {
    let [x3, y3, z2] = _ref2;
    const lat = Math.atan2(z2, Math.sqrt(x3 * x3 + y3 * y3));
    const lng = Math.atan2(y3, x3);
    return [lng * RADIAN_TO_DEGREE2, lat * RADIAN_TO_DEGREE2];
  }
  function rotateAndFlipQuadrant2(n3, point, rx, ry) {
    if (ry === 0) {
      if (rx === 1) {
        point[0] = n3 - 1 - point[0];
        point[1] = n3 - 1 - point[1];
      }
      const x3 = point[0];
      point[0] = point[1];
      point[1] = x3;
    }
  }
  function getS2LngLatFromS2Cell(s2Cell) {
    const st = IJToST2(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
    const uv = STToUV2(st);
    const xyz = FaceUVToXYZ2(s2Cell.face, uv);
    return XYZToLngLat2(xyz);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-boundary.js
  var MAX_RESOLUTION2 = 100;
  function getS2BoundaryFlatFromS2Cell(s2cell) {
    const {
      face,
      ij,
      level
    } = s2cell;
    const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];
    const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
    const result = new Float64Array(4 * resolution * 2 + 2);
    let ptIndex = 0;
    let prevLng = 0;
    for (let i5 = 0; i5 < 4; i5++) {
      const offset = offsets[i5].slice(0);
      const nextOffset = offsets[i5 + 1];
      const stepI = (nextOffset[0] - offset[0]) / resolution;
      const stepJ = (nextOffset[1] - offset[1]) / resolution;
      for (let j2 = 0; j2 < resolution; j2++) {
        offset[0] += stepI;
        offset[1] += stepJ;
        const st = IJToST2(ij, level, offset);
        const uv = STToUV2(st);
        const xyz = FaceUVToXYZ2(face, uv);
        const lngLat = XYZToLngLat2(xyz);
        if (Math.abs(lngLat[1]) > 89.999) {
          lngLat[0] = prevLng;
        }
        const deltaLng = lngLat[0] - prevLng;
        lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
        result[ptIndex++] = lngLat[0];
        result[ptIndex++] = lngLat[1];
        prevLng = lngLat[0];
      }
    }
    result[ptIndex++] = result[0];
    result[ptIndex++] = result[1];
    return result;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-cell-utils.js
  function getS2Cell(tokenOrKey) {
    const key = getS2QuadKey2(tokenOrKey);
    const s2cell = getS2CellFromQuadKey(key);
    return s2cell;
  }
  function getS2QuadKey2(tokenOrKey) {
    if (tokenOrKey.indexOf("/") > 0) {
      return tokenOrKey;
    }
    const id = getS2CellIdFromToken(tokenOrKey);
    return getS2QuadkeyFromCellId(id);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-geometry-functions.js
  function getS2LngLat(s2Token) {
    const s2cell = getS2Cell(s2Token);
    return getS2LngLatFromS2Cell(s2cell);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-region.js
  function getS2Region(s2cell) {
    let region;
    if (s2cell.face === 2 || s2cell.face === 5) {
      let corners = null;
      let len4 = 0;
      for (let i5 = 0; i5 < 4; i5++) {
        const key = `${s2cell.face}/${i5}`;
        const cell = getS2Cell(key);
        const corns = getS2BoundaryFlatFromS2Cell(cell);
        if (typeof corners === "undefined" || corners === null)
          corners = new Float64Array(4 * corns.length);
        corners.set(corns, len4);
        len4 += corns.length;
      }
      region = get2DRegionFromS2Corners(corners);
    } else {
      const corners = getS2BoundaryFlatFromS2Cell(s2cell);
      region = get2DRegionFromS2Corners(corners);
    }
    return region;
  }
  function get2DRegionFromS2Corners(corners) {
    if (corners.length % 2 !== 0) {
      throw new Error("Invalid corners");
    }
    const longitudes = [];
    const latitudes = [];
    for (let i5 = 0; i5 < corners.length; i5 += 2) {
      longitudes.push(corners[i5]);
      latitudes.push(corners[i5 + 1]);
    }
    longitudes.sort((a3, b2) => a3 - b2);
    latitudes.sort((a3, b2) => a3 - b2);
    return {
      west: longitudes[0],
      east: longitudes[longitudes.length - 1],
      north: latitudes[latitudes.length - 1],
      south: latitudes[0]
    };
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-obb-points.js
  function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
    const min4 = (heightInfo === null || heightInfo === void 0 ? void 0 : heightInfo.minimumHeight) || 0;
    const max4 = (heightInfo === null || heightInfo === void 0 ? void 0 : heightInfo.maximumHeight) || 0;
    const s2cell = getS2Cell(tokenOrKey);
    const region = getS2Region(s2cell);
    const W = region.west;
    const S2 = region.south;
    const E = region.east;
    const N2 = region.north;
    const points = [];
    points.push(new Vector3(W, N2, min4));
    points.push(new Vector3(E, N2, min4));
    points.push(new Vector3(E, S2, min4));
    points.push(new Vector3(W, S2, min4));
    points.push(new Vector3(W, N2, max4));
    points.push(new Vector3(E, N2, max4));
    points.push(new Vector3(E, S2, max4));
    points.push(new Vector3(W, S2, max4));
    return points;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/utils/obb/s2-corners-to-obb.js
  function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
    const token = s2VolumeInfo.token;
    const heightInfo = {
      minimumHeight: s2VolumeInfo.minimumHeight,
      maximumHeight: s2VolumeInfo.maximumHeight
    };
    const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
    const center = getS2LngLat(token);
    const centerLng = center[0];
    const centerLat = center[1];
    const point = Ellipsoid.WGS84.cartographicToCartesian([centerLng, centerLat, heightInfo.maximumHeight]);
    const centerPointAdditional = new Vector3(point[0], point[1], point[2]);
    corners.push(centerPointAdditional);
    const obb = makeOrientedBoundingBoxFromPoints(corners);
    const box = [...obb.center, ...obb.halfAxes];
    return box;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
  var QUADTREE_DIVISION_COUNT = 4;
  var OCTREE_DIVISION_COUNT = 8;
  var SUBDIVISION_COUNT_MAP = {
    QUADTREE: QUADTREE_DIVISION_COUNT,
    OCTREE: OCTREE_DIVISION_COUNT
  };
  function getChildS2VolumeBox(s2VolumeBox, index2, subdivisionScheme) {
    if (s2VolumeBox !== null && s2VolumeBox !== void 0 && s2VolumeBox.box) {
      const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
      const childCellId = getS2ChildCellId(cellId, index2);
      const childToken = getS2TokenFromCellId(childCellId);
      const s2ChildVolumeInfo = {
        ...s2VolumeBox.s2VolumeInfo
      };
      s2ChildVolumeInfo.token = childToken;
      switch (subdivisionScheme) {
        case "OCTREE":
          const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
          const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
          const sizeZ = delta / 2;
          const midZ = s2VolumeInfo.minimumHeight + delta / 2;
          s2VolumeInfo.minimumHeight = midZ - sizeZ;
          s2VolumeInfo.maximumHeight = midZ + sizeZ;
          break;
        default:
          break;
      }
      const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
      const childS2VolumeBox = {
        box,
        s2VolumeInfo: s2ChildVolumeInfo
      };
      return childS2VolumeBox;
    }
    return void 0;
  }
  async function parseImplicitTiles(params) {
    const {
      implicitOptions,
      parentData = {
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      },
      childIndex = 0,
      s2VolumeBox,
      loaderOptions
    } = params;
    let {
      subtree,
      level = 0,
      globalData = {
        level: 0,
        mortonIndex: 0,
        x: 0,
        y: 0,
        z: 0
      }
    } = params;
    const {
      subdivisionScheme,
      subtreeLevels,
      maximumLevel,
      contentUrlTemplate,
      subtreesUriTemplate,
      basePath
    } = implicitOptions;
    const tile = {
      children: [],
      lodMetricValue: 0,
      contentUrl: ""
    };
    if (!maximumLevel) {
      dist_default.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);
      return tile;
    }
    const lev = level + globalData.level;
    if (lev > maximumLevel) {
      return tile;
    }
    const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
    const bitsPerTile = Math.log2(childrenPerTile);
    const childX = childIndex & 1;
    const childY = childIndex >> 1 & 1;
    const childZ = childIndex >> 2 & 1;
    const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);
    let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);
    let tileAvailabilityIndex = levelOffset + childTileMortonIndex;
    let childTileX = concatBits(parentData.x, childX, 1);
    let childTileY = concatBits(parentData.y, childY, 1);
    let childTileZ = concatBits(parentData.z, childZ, 1);
    let isChildSubtreeAvailable = false;
    if (level >= subtreeLevels) {
      isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);
    }
    const x3 = concatBits(globalData.x, childTileX, level);
    const y3 = concatBits(globalData.y, childTileY, level);
    const z2 = concatBits(globalData.z, childTileZ, level);
    if (isChildSubtreeAvailable) {
      const subtreePath = `${basePath}/${subtreesUriTemplate}`;
      const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x3, y3, z2);
      const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);
      subtree = childSubtree;
      globalData = {
        mortonIndex: childTileMortonIndex,
        x: childTileX,
        y: childTileY,
        z: childTileZ,
        level
      };
      childTileMortonIndex = 0;
      tileAvailabilityIndex = 0;
      childTileX = 0;
      childTileY = 0;
      childTileZ = 0;
      level = 0;
    }
    const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);
    if (!isTileAvailable) {
      return tile;
    }
    const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);
    if (isContentAvailable) {
      tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x3, y3, z2);
    }
    const childTileLevel = level + 1;
    const pData = {
      mortonIndex: childTileMortonIndex,
      x: childTileX,
      y: childTileY,
      z: childTileZ
    };
    for (let index2 = 0; index2 < childrenPerTile; index2++) {
      const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index2, subdivisionScheme);
      const childTileParsed = await parseImplicitTiles({
        subtree,
        implicitOptions,
        loaderOptions,
        parentData: pData,
        childIndex: index2,
        level: childTileLevel,
        globalData: {
          ...globalData
        },
        s2VolumeBox: childS2VolumeBox
      });
      if (childTileParsed.contentUrl || childTileParsed.children.length) {
        const globalLevel = lev + 1;
        const childCoordinates = {
          childTileX,
          childTileY,
          childTileZ
        };
        const formattedTile = formatTileData(childTileParsed, globalLevel, childCoordinates, implicitOptions, s2VolumeBox);
        tile.children.push(formattedTile);
      }
    }
    return tile;
  }
  function getAvailabilityResult(availabilityData, index2) {
    let availabilityObject;
    if (Array.isArray(availabilityData)) {
      availabilityObject = availabilityData[0];
      if (availabilityData.length > 1) {
        dist_default.once('Not supported extension "3DTILES_multiple_contents" has been detected');
      }
    } else {
      availabilityObject = availabilityData;
    }
    if ("constant" in availabilityObject) {
      return Boolean(availabilityObject.constant);
    }
    if (availabilityObject.explicitBitstream) {
      return getBooleanValueFromBitstream(index2, availabilityObject.explicitBitstream);
    }
    return false;
  }
  function formatTileData(tile, level, childCoordinates, options, s2VolumeBox) {
    const {
      basePath,
      refine,
      getRefine: getRefine2,
      lodMetricType,
      getTileType: getTileType2,
      rootLodMetricValue,
      rootBoundingVolume
    } = options;
    const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, "");
    const lodMetricValue = rootLodMetricValue / 2 ** level;
    const boundingVolume = s2VolumeBox !== null && s2VolumeBox !== void 0 && s2VolumeBox.box ? {
      box: s2VolumeBox.box
    } : rootBoundingVolume;
    const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(level, boundingVolume, childCoordinates);
    return {
      children: tile.children,
      contentUrl: tile.contentUrl,
      content: {
        uri
      },
      id: tile.contentUrl,
      refine: getRefine2(refine),
      type: getTileType2(tile),
      lodMetricType,
      lodMetricValue,
      geometricError: lodMetricValue,
      transform: tile.transform,
      boundingVolume: boundingVolumeForChildTile
    };
  }
  function calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {
    if (rootBoundingVolume.region) {
      const {
        childTileX,
        childTileY,
        childTileZ
      } = childCoordinates;
      const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
      const boundingVolumesCount = 2 ** level;
      const sizeX = (east - west) / boundingVolumesCount;
      const sizeY = (north - south) / boundingVolumesCount;
      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
      const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];
      const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];
      const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];
      return {
        region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
      };
    }
    if (rootBoundingVolume.box) {
      return rootBoundingVolume;
    }
    throw new Error(`Unsupported bounding volume type ${rootBoundingVolume}`);
  }
  function concatBits(higher, lower, shift) {
    return (higher << shift) + lower;
  }
  function replaceContentUrlTemplate(templateUrl, level, x3, y3, z2) {
    const mapUrl = generateMapUrl({
      level,
      x: x3,
      y: y3,
      z: z2
    });
    return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
  }
  function generateMapUrl(items) {
    const mapUrl = {};
    for (const key in items) {
      mapUrl[`{${key}}`] = items[key];
    }
    return mapUrl;
  }
  function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
    const byteIndex = Math.floor(availabilityIndex / 8);
    const bitIndex = availabilityIndex % 8;
    const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
    return bitValue === 1;
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-header.js
  function getTileType(tile) {
    let tileContentUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (!tileContentUrl) {
      return TILE_TYPE.EMPTY;
    }
    const contentUrl = tileContentUrl.split("?")[0];
    const fileExtension = contentUrl.split(".").pop();
    switch (fileExtension) {
      case "pnts":
        return TILE_TYPE.POINTCLOUD;
      case "i3dm":
      case "b3dm":
      case "glb":
      case "gltf":
        return TILE_TYPE.SCENEGRAPH;
      default:
        return fileExtension || TILE_TYPE.EMPTY;
    }
  }
  function getRefine(refine) {
    switch (refine) {
      case "REPLACE":
      case "replace":
        return TILE_REFINEMENT.REPLACE;
      case "ADD":
      case "add":
        return TILE_REFINEMENT.ADD;
      default:
        return refine;
    }
  }
  function resolveUri(uri, basePath) {
    const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
    if (urlSchemeRegex.test(basePath)) {
      const url = new URL(uri, `${basePath}/`);
      return decodeURI(url.toString());
    } else if (uri.startsWith("/")) {
      return uri;
    }
    return path_exports.resolve(basePath, uri);
  }
  function normalizeTileData(tile, basePath) {
    if (!tile) {
      return null;
    }
    let tileContentUrl;
    if (tile.content) {
      var _tile$content;
      const contentUri = tile.content.uri || ((_tile$content = tile.content) === null || _tile$content === void 0 ? void 0 : _tile$content.url);
      if (typeof contentUri !== "undefined") {
        tileContentUrl = resolveUri(contentUri, basePath);
      }
    }
    const tilePostprocessed = {
      ...tile,
      id: tileContentUrl,
      contentUrl: tileContentUrl,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: tile.geometricError,
      transformMatrix: tile.transform,
      type: getTileType(tile, tileContentUrl),
      refine: getRefine(tile.refine)
    };
    return tilePostprocessed;
  }
  async function normalizeTileHeaders(tileset, basePath, options) {
    let root = null;
    const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);
    if (rootImplicitTilingExtension && tileset.root) {
      root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);
    } else {
      root = normalizeTileData(tileset.root, basePath);
    }
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop() || {};
      const children = tile.children || [];
      const childrenPostprocessed = [];
      for (const childHeader of children) {
        const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
        let childHeaderPostprocessed;
        if (childImplicitTilingExtension) {
          childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);
        } else {
          childHeaderPostprocessed = normalizeTileData(childHeader, basePath);
        }
        if (childHeaderPostprocessed) {
          childrenPostprocessed.push(childHeaderPostprocessed);
          stack2.push(childHeaderPostprocessed);
        }
      }
      tile.children = childrenPostprocessed;
    }
    return root;
  }
  async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {
    var _tile$content2, _tileset$root, _tile$boundingVolume$;
    const {
      subdivisionScheme,
      maximumLevel,
      availableLevels,
      subtreeLevels,
      subtrees: {
        uri: subtreesUriTemplate
      }
    } = implicitTilingExtension;
    const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
    const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
    const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
    const tileContentUri = (_tile$content2 = tile.content) === null || _tile$content2 === void 0 ? void 0 : _tile$content2.uri;
    const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : "";
    const refine = tileset === null || tileset === void 0 ? void 0 : (_tileset$root = tileset.root) === null || _tileset$root === void 0 ? void 0 : _tileset$root.refine;
    const rootLodMetricValue = tile.geometricError;
    const s2VolumeInfo = (_tile$boundingVolume$ = tile.boundingVolume.extensions) === null || _tile$boundingVolume$ === void 0 ? void 0 : _tile$boundingVolume$["3DTILES_bounding_volume_S2"];
    if (s2VolumeInfo) {
      const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
      const s2VolumeBox = {
        box,
        s2VolumeInfo
      };
      tile.boundingVolume = s2VolumeBox;
    }
    const rootBoundingVolume = tile.boundingVolume;
    const implicitOptions = {
      contentUrlTemplate,
      subtreesUriTemplate,
      subdivisionScheme,
      subtreeLevels,
      maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,
      refine,
      basePath,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      rootLodMetricValue,
      rootBoundingVolume,
      getTileType,
      getRefine
    };
    return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);
  }
  async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {
    if (!tile) {
      return null;
    }
    const {
      children,
      contentUrl
    } = await parseImplicitTiles({
      subtree: rootSubtree,
      implicitOptions,
      loaderOptions
    });
    let tileContentUrl;
    let tileContent = null;
    if (contentUrl) {
      tileContentUrl = contentUrl;
      tileContent = {
        uri: contentUrl.replace(`${basePath}/`, "")
      };
    }
    const tilePostprocessed = {
      ...tile,
      id: tileContentUrl,
      contentUrl: tileContentUrl,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: tile.geometricError,
      transformMatrix: tile.transform,
      type: getTileType(tile, tileContentUrl),
      refine: getRefine(tile.refine),
      content: tileContent || tile.content,
      children
    };
    return tilePostprocessed;
  }
  function getImplicitTilingExtensionData(tile) {
    var _tile$extensions;
    return (tile === null || tile === void 0 ? void 0 : (_tile$extensions = tile.extensions) === null || _tile$extensions === void 0 ? void 0 : _tile$extensions["3DTILES_implicit_tiling"]) || (tile === null || tile === void 0 ? void 0 : tile.implicitTiling);
  }

  // ../../node_modules/@loaders.gl/3d-tiles/dist/tiles-3d-loader.js
  var Tiles3DLoader = {
    id: "3d-tiles",
    name: "3D Tiles",
    module: "3d-tiles",
    version: VERSION12,
    extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
    mimeTypes: ["application/octet-stream"],
    tests: ["cmpt", "pnts", "b3dm", "i3dm"],
    parse: parse4,
    options: {
      "3d-tiles": {
        loadGLTF: true,
        decodeQuantizedPositions: false,
        isTileset: "auto",
        assetGltfUpAxis: null
      }
    }
  };
  async function parse4(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let context = arguments.length > 2 ? arguments[2] : void 0;
    const loaderOptions = options["3d-tiles"] || {};
    let isTileset;
    if (loaderOptions.isTileset === "auto") {
      isTileset = (context === null || context === void 0 ? void 0 : context.url) && context.url.indexOf(".json") !== -1;
    } else {
      isTileset = loaderOptions.isTileset;
    }
    return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);
  }
  async function parseTileset(data, options, context) {
    var _tilesetJson$root;
    const tilesetJson = JSON.parse(new TextDecoder().decode(data));
    const tilesetUrl = (context === null || context === void 0 ? void 0 : context.url) || "";
    const basePath = getBaseUri(tilesetUrl);
    const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});
    const tilesetJsonPostprocessed = {
      ...tilesetJson,
      shape: "tileset3d",
      loader: Tiles3DLoader,
      url: tilesetUrl,
      queryString: (context === null || context === void 0 ? void 0 : context.queryString) || "",
      basePath,
      root: normalizedRoot || tilesetJson.root,
      type: TILESET_TYPE.TILES3D,
      lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
      lodMetricValue: ((_tilesetJson$root = tilesetJson.root) === null || _tilesetJson$root === void 0 ? void 0 : _tilesetJson$root.geometricError) || 0
    };
    return tilesetJsonPostprocessed;
  }
  async function parseTile(arrayBuffer2, options, context) {
    const tile = {
      content: {
        shape: "tile3d",
        featureIds: null
      }
    };
    const byteOffset = 0;
    await parse3DTile(arrayBuffer2, byteOffset, options, context, tile.content);
    return tile.content;
  }
  function getBaseUri(tilesetUrl) {
    return path_exports.dirname(tilesetUrl);
  }

  // ../geo-layers/src/tile-3d-layer/tile-3d-layer.ts
  var SINGLE_DATA = [0];
  var defaultProps30 = {
    getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
    pointSize: 1,
    data: "",
    loader: Tiles3DLoader,
    onTilesetLoad: { type: "function", value: (tileset3d) => {
    } },
    onTileLoad: { type: "function", value: (tileHeader) => {
    } },
    onTileUnload: { type: "function", value: (tileHeader) => {
    } },
    onTileError: { type: "function", value: (tile, message2, url) => {
    } },
    _getMeshColor: { type: "function", value: (tileHeader) => [255, 255, 255] }
  };
  var Tile3DLayer = class extends CompositeLayer {
    initializeState() {
      if ("onTileLoadFail" in this.props) {
        log_default.removed("onTileLoadFail", "onTileError")();
      }
      this.state = {
        layerMap: {},
        tileset3d: null,
        activeViewports: {},
        lastUpdatedViewports: null
      };
    }
    get isLoaded() {
      return Boolean(this.state?.tileset3d?.isLoaded() && super.isLoaded);
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState({ props, oldProps, changeFlags }) {
      if (props.data && props.data !== oldProps.data) {
        this._loadTileset(props.data);
      }
      if (changeFlags.viewportChanged) {
        const { activeViewports } = this.state;
        const viewportsNumber = Object.keys(activeViewports).length;
        if (viewportsNumber) {
          this._updateTileset(activeViewports);
          this.state.lastUpdatedViewports = activeViewports;
          this.state.activeViewports = {};
        }
      }
      if (changeFlags.propsChanged) {
        const { layerMap } = this.state;
        for (const key in layerMap) {
          layerMap[key].needsUpdate = true;
        }
      }
    }
    activateViewport(viewport) {
      const { activeViewports, lastUpdatedViewports } = this.state;
      this.internalState.viewport = viewport;
      activeViewports[viewport.id] = viewport;
      const lastViewport = lastUpdatedViewports?.[viewport.id];
      if (!lastViewport || !viewport.equals(lastViewport)) {
        this.setChangeFlags({ viewportChanged: true });
        this.setNeedsUpdate();
      }
    }
    getPickingInfo({ info, sourceLayer }) {
      const sourceTile = sourceLayer && sourceLayer.props.tile;
      if (info.picked) {
        info.object = sourceTile;
      }
      info.sourceTile = sourceTile;
      return info;
    }
    filterSubLayer({ layer, viewport }) {
      const { tile } = layer.props;
      const { id: viewportId } = viewport;
      return tile.selected && tile.viewportIds.includes(viewportId);
    }
    _updateAutoHighlight(info) {
      const sourceTile = info.sourceTile;
      const layerCache = this.state.layerMap[sourceTile?.id];
      if (layerCache && layerCache.layer) {
        layerCache.layer.updateAutoHighlight(info);
      }
    }
    async _loadTileset(tilesetUrl) {
      const { loadOptions = {} } = this.props;
      const loaders = this.props.loader || this.props.loaders;
      const loader = Array.isArray(loaders) ? loaders[0] : loaders;
      const options = { loadOptions: { ...loadOptions } };
      let actualTilesetUrl = tilesetUrl;
      if (loader.preload) {
        const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
        if (preloadOptions.url) {
          actualTilesetUrl = preloadOptions.url;
        }
        if (preloadOptions.headers) {
          options.loadOptions.fetch = {
            ...options.loadOptions.fetch,
            headers: preloadOptions.headers
          };
        }
        Object.assign(options, preloadOptions);
      }
      const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
      const tileset3d = new Tileset3D(tilesetJson, {
        onTileLoad: this._onTileLoad.bind(this),
        onTileUnload: this._onTileUnload.bind(this),
        onTileError: this.props.onTileError,
        ...options
      });
      this.setState({
        tileset3d,
        layerMap: {}
      });
      this._updateTileset(this.state.activeViewports);
      this.props.onTilesetLoad(tileset3d);
    }
    _onTileLoad(tileHeader) {
      const { lastUpdatedViewports } = this.state;
      this.props.onTileLoad(tileHeader);
      this._updateTileset(lastUpdatedViewports);
      this.setNeedsUpdate();
    }
    _onTileUnload(tileHeader) {
      delete this.state.layerMap[tileHeader.id];
      this.props.onTileUnload(tileHeader);
    }
    _updateTileset(viewports) {
      if (!viewports) {
        return;
      }
      const { tileset3d } = this.state;
      const { timeline } = this.context;
      const viewportsNumber = Object.keys(viewports).length;
      if (!timeline || !viewportsNumber || !tileset3d) {
        return;
      }
      tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
        const tilesetChanged = this.state.frameNumber !== frameNumber;
        if (tilesetChanged) {
          this.setState({ frameNumber });
        }
      });
    }
    _getSubLayer(tileHeader, oldLayer) {
      if (!tileHeader.content) {
        return null;
      }
      switch (tileHeader.type) {
        case TILE_TYPE.POINTCLOUD:
          return this._makePointCloudLayer(tileHeader, oldLayer);
        case TILE_TYPE.SCENEGRAPH:
          return this._make3DModelLayer(tileHeader);
        case TILE_TYPE.MESH:
          return this._makeSimpleMeshLayer(tileHeader, oldLayer);
        default:
          throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
      }
    }
    _makePointCloudLayer(tileHeader, oldLayer) {
      const { attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
      const { positions, normals, colors } = attributes;
      if (!positions) {
        return null;
      }
      const data = oldLayer && oldLayer.props.data || {
        header: {
          vertexCount: pointCount
        },
        attributes: {
          POSITION: positions,
          NORMAL: normals,
          COLOR_0: colors
        }
      };
      const { pointSize, getPointColor } = this.props;
      const SubLayerClass = this.getSubLayerClass("pointcloud", PointCloudLayer);
      return new SubLayerClass(
        {
          pointSize
        },
        this.getSubLayerProps({
          id: "pointcloud"
        }),
        {
          id: `${this.id}-pointcloud-${tileHeader.id}`,
          tile: tileHeader,
          data,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getColor: constantRGBA || getPointColor,
          _offset: 0
        }
      );
    }
    _make3DModelLayer(tileHeader) {
      const { gltf, instances, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
      const SubLayerClass = this.getSubLayerClass("scenegraph", ScenegraphLayer);
      return new SubLayerClass(
        {
          _lighting: "pbr"
        },
        this.getSubLayerProps({
          id: "scenegraph"
        }),
        {
          id: `${this.id}-scenegraph-${tileHeader.id}`,
          tile: tileHeader,
          data: instances || SINGLE_DATA,
          scenegraph: gltf,
          coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
          coordinateOrigin: cartographicOrigin,
          modelMatrix: modelMatrix2,
          getTransformMatrix: (instance) => instance.modelMatrix,
          getPosition: [0, 0, 0],
          _offset: 0
        }
      );
    }
    _makeSimpleMeshLayer(tileHeader, oldLayer) {
      const content = tileHeader.content;
      const {
        attributes,
        indices,
        modelMatrix: modelMatrix2,
        cartographicOrigin,
        coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,
        material,
        featureIds
      } = content;
      const { _getMeshColor } = this.props;
      const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
        topology: "triangle-list",
        attributes: getMeshGeometry(attributes),
        indices
      });
      const SubLayerClass = this.getSubLayerClass("mesh", MeshLayer);
      return new SubLayerClass(
        this.getSubLayerProps({
          id: "mesh"
        }),
        {
          id: `${this.id}-mesh-${tileHeader.id}`,
          tile: tileHeader,
          mesh: geometry,
          data: SINGLE_DATA,
          getColor: _getMeshColor(tileHeader),
          pbrMaterial: material,
          modelMatrix: modelMatrix2,
          coordinateOrigin: cartographicOrigin,
          coordinateSystem,
          featureIds,
          _offset: 0
        }
      );
    }
    renderLayers() {
      const { tileset3d, layerMap } = this.state;
      if (!tileset3d) {
        return null;
      }
      return tileset3d.tiles.map((tile) => {
        const layerCache = layerMap[tile.id] = layerMap[tile.id] || { tile };
        let { layer } = layerCache;
        if (tile.selected) {
          if (!layer) {
            layer = this._getSubLayer(tile);
          } else if (layerCache.needsUpdate) {
            layer = this._getSubLayer(tile, layer);
            layerCache.needsUpdate = false;
          }
        }
        layerCache.layer = layer;
        return layer;
      }).filter(Boolean);
    }
  };
  Tile3DLayer.defaultProps = defaultProps30;
  Tile3DLayer.layerName = "Tile3DLayer";
  function getMeshGeometry(contentAttributes) {
    const attributes = {};
    attributes.positions = {
      ...contentAttributes.positions,
      value: new Float32Array(contentAttributes.positions.value)
    };
    if (contentAttributes.normals) {
      attributes.normals = contentAttributes.normals;
    }
    if (contentAttributes.texCoords) {
      attributes.texCoords = contentAttributes.texCoords;
    }
    if (contentAttributes.colors) {
      attributes.colors = contentAttributes.colors;
    }
    if (contentAttributes.uvRegions) {
      attributes.uvRegions = contentAttributes.uvRegions;
    }
    return attributes;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js
  var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([["centerX", Float64Array.BYTES_PER_ELEMENT], ["centerY", Float64Array.BYTES_PER_ELEMENT], ["centerZ", Float64Array.BYTES_PER_ELEMENT], ["minHeight", Float32Array.BYTES_PER_ELEMENT], ["maxHeight", Float32Array.BYTES_PER_ELEMENT], ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT], ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT], ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]]);
  function decodeZigZag(value) {
    return value >> 1 ^ -(value & 1);
  }
  function decodeHeader(dataView) {
    let position = 0;
    const header = {};
    for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
      const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
      header[key] = getter.call(dataView, position, true);
      position += bytesCount;
    }
    return {
      header,
      headerEndPosition: position
    };
  }
  function decodeVertexData(dataView, headerEndPosition) {
    let position = headerEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = dataView.getUint32(position, true);
    const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
    const elementArrayLength = vertexCount * bytesPerArrayElement;
    const uArrayStartPosition = position;
    const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
    const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
    let u3 = 0;
    let v2 = 0;
    let height = 0;
    for (let i5 = 0; i5 < vertexCount; i5++) {
      u3 += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i5, true));
      v2 += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i5, true));
      height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i5, true));
      vertexData[i5] = u3;
      vertexData[i5 + vertexCount] = v2;
      vertexData[i5 + vertexCount * 2] = height;
    }
    position += elementArrayLength * 3;
    return {
      vertexData,
      vertexDataEndPosition: position
    };
  }
  function decodeIndex(buffer, position, indicesCount, bytesPerIndex) {
    let encoded = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    let indices;
    if (bytesPerIndex === 2) {
      indices = new Uint16Array(buffer, position, indicesCount);
    } else {
      indices = new Uint32Array(buffer, position, indicesCount);
    }
    if (!encoded) {
      return indices;
    }
    let highest = 0;
    for (let i5 = 0; i5 < indices.length; ++i5) {
      const code = indices[i5];
      indices[i5] = highest - code;
      if (code === 0) {
        ++highest;
      }
    }
    return indices;
  }
  function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
    let position = vertexDataEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    if (position % bytesPerIndex !== 0) {
      position += bytesPerIndex - position % bytesPerIndex;
    }
    const triangleCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const triangleIndicesCount = triangleCount * 3;
    const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
    position += triangleIndicesCount * bytesPerIndex;
    return {
      triangleIndicesEndPosition: position,
      triangleIndices
    };
  }
  function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
    let position = triangleIndicesEndPosition;
    const elementsPerVertex = 3;
    const vertexCount = vertexData.length / elementsPerVertex;
    const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
    const westVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
    position += westVertexCount * bytesPerIndex;
    const southVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
    position += southVertexCount * bytesPerIndex;
    const eastVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
    position += eastVertexCount * bytesPerIndex;
    const northVertexCount = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
    position += northVertexCount * bytesPerIndex;
    return {
      edgeIndicesEndPosition: position,
      westIndices,
      southIndices,
      eastIndices,
      northIndices
    };
  }
  function decodeVertexNormalsExtension(extensionDataView) {
    return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
  }
  function decodeWaterMaskExtension(extensionDataView) {
    return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
  }
  function decodeExtensions2(dataView, indicesEndPosition) {
    const extensions = {};
    if (dataView.byteLength <= indicesEndPosition) {
      return {
        extensions,
        extensionsEndPosition: indicesEndPosition
      };
    }
    let position = indicesEndPosition;
    while (position < dataView.byteLength) {
      const extensionId = dataView.getUint8(position, true);
      position += Uint8Array.BYTES_PER_ELEMENT;
      const extensionLength = dataView.getUint32(position, true);
      position += Uint32Array.BYTES_PER_ELEMENT;
      const extensionView = new DataView(dataView.buffer, position, extensionLength);
      switch (extensionId) {
        case 1: {
          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
          break;
        }
        case 2: {
          extensions.waterMask = decodeWaterMaskExtension(extensionView);
          break;
        }
        default: {
        }
      }
      position += extensionLength;
    }
    return {
      extensions,
      extensionsEndPosition: position
    };
  }
  var DECODING_STEPS = {
    header: 0,
    vertices: 1,
    triangleIndices: 2,
    edgeIndices: 3,
    extensions: 4
  };
  var DEFAULT_OPTIONS4 = {
    maxDecodingStep: DECODING_STEPS.extensions
  };
  function decode11(data, userOptions) {
    const options = Object.assign({}, DEFAULT_OPTIONS4, userOptions);
    const view = new DataView(data);
    const {
      header,
      headerEndPosition
    } = decodeHeader(view);
    if (options.maxDecodingStep < DECODING_STEPS.vertices) {
      return {
        header
      };
    }
    const {
      vertexData,
      vertexDataEndPosition
    } = decodeVertexData(view, headerEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
      return {
        header,
        vertexData
      };
    }
    const {
      triangleIndices,
      triangleIndicesEndPosition
    } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
      return {
        header,
        vertexData,
        triangleIndices
      };
    }
    const {
      westIndices,
      southIndices,
      eastIndices,
      northIndices,
      edgeIndicesEndPosition
    } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
    if (options.maxDecodingStep < DECODING_STEPS.extensions) {
      return {
        header,
        vertexData,
        triangleIndices,
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      };
    }
    const {
      extensions
    } = decodeExtensions2(view, edgeIndicesEndPosition);
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices,
      extensions
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js
  function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
    const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
    const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
    const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
    const newTriangles = new triangles.constructor(outsideEdges.length * 6);
    for (let i5 = 0; i5 < outsideEdges.length; i5++) {
      const edge = outsideEdges[i5];
      updateAttributesForNewEdge({
        edge,
        edgeIndex: i5,
        attributes,
        skirtHeight,
        newPosition,
        newTexcoord0,
        newTriangles
      });
    }
    attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
    attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
    const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
    return {
      attributes,
      triangles: resultTriangles
    };
  }
  function getOutsideEdgesFromTriangles(triangles) {
    const edges = [];
    for (let i5 = 0; i5 < triangles.length; i5 += 3) {
      edges.push([triangles[i5], triangles[i5 + 1]]);
      edges.push([triangles[i5 + 1], triangles[i5 + 2]]);
      edges.push([triangles[i5 + 2], triangles[i5]]);
    }
    edges.sort((a3, b2) => Math.min(...a3) - Math.min(...b2) || Math.max(...a3) - Math.max(...b2));
    const outsideEdges = [];
    let index2 = 0;
    while (index2 < edges.length) {
      var _edges, _edges2;
      if (edges[index2][0] === ((_edges = edges[index2 + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index2][1] === ((_edges2 = edges[index2 + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {
        index2 += 2;
      } else {
        outsideEdges.push(edges[index2]);
        index2++;
      }
    }
    return outsideEdges;
  }
  function getOutsideEdgesFromIndices(indices, position) {
    indices.westIndices.sort((a3, b2) => position[3 * a3 + 1] - position[3 * b2 + 1]);
    indices.eastIndices.sort((a3, b2) => position[3 * b2 + 1] - position[3 * a3 + 1]);
    indices.southIndices.sort((a3, b2) => position[3 * b2] - position[3 * a3]);
    indices.northIndices.sort((a3, b2) => position[3 * a3] - position[3 * b2]);
    const edges = [];
    for (const index2 in indices) {
      const indexGroup = indices[index2];
      for (let i5 = 0; i5 < indexGroup.length - 1; i5++) {
        edges.push([indexGroup[i5], indexGroup[i5 + 1]]);
      }
    }
    return edges;
  }
  function updateAttributesForNewEdge(_ref) {
    let {
      edge,
      edgeIndex,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    } = _ref;
    const positionsLength = attributes.POSITION.value.length;
    const vertex1Offset = edgeIndex * 2;
    const vertex2Offset = edgeIndex * 2 + 1;
    newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
    newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
    newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
    newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
    newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
    const triangle1Offset = edgeIndex * 2 * 3;
    newTriangles[triangle1Offset] = edge[0];
    newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 2] = edge[1];
    newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
    newTriangles[triangle1Offset + 4] = edge[0];
    newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js
  function parseQuantizedMesh(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      bounds
    } = options;
    const {
      header,
      vertexData,
      triangleIndices: originalTriangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    } = decode11(arrayBuffer2, DECODING_STEPS.triangleIndices);
    let triangleIndices = originalTriangleIndices;
    let attributes = getMeshAttributes(vertexData, header, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (options !== null && options !== void 0 && options.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
        westIndices,
        northIndices,
        eastIndices,
        southIndices
      });
      attributes = newAttributes;
      triangleIndices = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangleIndices.length,
        boundingBox
      },
      schema: void 0,
      topology: "triangle-list",
      mode: 4,
      indices: {
        value: triangleIndices,
        size: 1
      },
      attributes
    };
  }
  function getMeshAttributes(vertexData, header, bounds) {
    const {
      minHeight,
      maxHeight
    } = header;
    const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
    const xScale = maxX - minX;
    const yScale = maxY - minY;
    const zScale = maxHeight - minHeight;
    const nCoords = vertexData.length / 3;
    const positions = new Float32Array(nCoords * 3);
    const texCoords = new Float32Array(nCoords * 2);
    for (let i5 = 0; i5 < nCoords; i5++) {
      const x3 = vertexData[i5] / 32767;
      const y3 = vertexData[i5 + nCoords] / 32767;
      const z2 = vertexData[i5 + nCoords * 2] / 32767;
      positions[3 * i5 + 0] = x3 * xScale + minX;
      positions[3 * i5 + 1] = y3 * yScale + minY;
      positions[3 * i5 + 2] = z2 * zScale + minHeight;
      texCoords[2 * i5 + 0] = x3;
      texCoords[2 * i5 + 1] = y3;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }

  // ../../node_modules/@mapbox/martini/index.js
  var Martini = class {
    constructor(gridSize = 257) {
      this.gridSize = gridSize;
      const tileSize = gridSize - 1;
      if (tileSize & tileSize - 1)
        throw new Error(
          `Expected grid size to be 2^n+1, got ${gridSize}.`
        );
      this.numTriangles = tileSize * tileSize * 2 - 2;
      this.numParentTriangles = this.numTriangles - tileSize * tileSize;
      this.indices = new Uint32Array(this.gridSize * this.gridSize);
      this.coords = new Uint16Array(this.numTriangles * 4);
      for (let i5 = 0; i5 < this.numTriangles; i5++) {
        let id = i5 + 2;
        let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
        if (id & 1) {
          bx = by = cx = tileSize;
        } else {
          ax = ay = cy = tileSize;
        }
        while ((id >>= 1) > 1) {
          const mx = ax + bx >> 1;
          const my = ay + by >> 1;
          if (id & 1) {
            bx = ax;
            by = ay;
            ax = cx;
            ay = cy;
          } else {
            ax = bx;
            ay = by;
            bx = cx;
            by = cy;
          }
          cx = mx;
          cy = my;
        }
        const k2 = i5 * 4;
        this.coords[k2 + 0] = ax;
        this.coords[k2 + 1] = ay;
        this.coords[k2 + 2] = bx;
        this.coords[k2 + 3] = by;
      }
    }
    createTile(terrain) {
      return new Tile(terrain, this);
    }
  };
  var Tile = class {
    constructor(terrain, martini) {
      const size = martini.gridSize;
      if (terrain.length !== size * size)
        throw new Error(
          `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
        );
      this.terrain = terrain;
      this.martini = martini;
      this.errors = new Float32Array(terrain.length);
      this.update();
    }
    update() {
      const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
      const { terrain, errors } = this;
      for (let i5 = numTriangles - 1; i5 >= 0; i5--) {
        const k2 = i5 * 4;
        const ax = coords[k2 + 0];
        const ay = coords[k2 + 1];
        const bx = coords[k2 + 2];
        const by = coords[k2 + 3];
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        const cx = mx + my - ay;
        const cy = my + ax - mx;
        const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
        const middleIndex = my * size + mx;
        const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
        errors[middleIndex] = Math.max(errors[middleIndex], middleError);
        if (i5 < numParentTriangles) {
          const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
          const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
        }
      }
    }
    getMesh(maxError = 0) {
      const { gridSize: size, indices } = this.martini;
      const { errors } = this;
      let numVertices = 0;
      let numTriangles = 0;
      const max4 = size - 1;
      indices.fill(0);
      function countElements(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          countElements(cx, cy, ax, ay, mx, my);
          countElements(bx, by, cx, cy, mx, my);
        } else {
          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
          numTriangles++;
        }
      }
      countElements(0, 0, max4, max4, max4, 0);
      countElements(max4, max4, 0, 0, 0, max4);
      const vertices = new Uint16Array(numVertices * 2);
      const triangles = new Uint32Array(numTriangles * 3);
      let triIndex = 0;
      function processTriangle(ax, ay, bx, by, cx, cy) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
          processTriangle(cx, cy, ax, ay, mx, my);
          processTriangle(bx, by, cx, cy, mx, my);
        } else {
          const a3 = indices[ay * size + ax] - 1;
          const b2 = indices[by * size + bx] - 1;
          const c2 = indices[cy * size + cx] - 1;
          vertices[2 * a3] = ax;
          vertices[2 * a3 + 1] = ay;
          vertices[2 * b2] = bx;
          vertices[2 * b2 + 1] = by;
          vertices[2 * c2] = cx;
          vertices[2 * c2 + 1] = cy;
          triangles[triIndex++] = a3;
          triangles[triIndex++] = b2;
          triangles[triIndex++] = c2;
        }
      }
      processTriangle(0, 0, max4, max4, max4, 0);
      processTriangle(max4, max4, 0, 0, 0, max4);
      return { vertices, triangles };
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/lib/delatin/index.js
  var Delatin = class {
    constructor(data, width) {
      let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : width;
      this.data = data;
      this.width = width;
      this.height = height;
      this.coords = [];
      this.triangles = [];
      this._halfedges = [];
      this._candidates = [];
      this._queueIndices = [];
      this._queue = [];
      this._errors = [];
      this._rms = [];
      this._pending = [];
      this._pendingLen = 0;
      this._rmsSum = 0;
      const x1 = width - 1;
      const y1 = height - 1;
      const p0 = this._addPoint(0, 0);
      const p1 = this._addPoint(x1, 0);
      const p22 = this._addPoint(0, y1);
      const p3 = this._addPoint(x1, y1);
      const t0 = this._addTriangle(p3, p0, p22, -1, -1, -1);
      this._addTriangle(p0, p3, p1, t0, -1, -1);
      this._flush();
    }
    run() {
      let maxError = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      while (this.getMaxError() > maxError) {
        this.refine();
      }
    }
    refine() {
      this._step();
      this._flush();
    }
    getMaxError() {
      return this._errors[0];
    }
    getRMSD() {
      return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
    }
    heightAt(x3, y3) {
      return this.data[this.width * y3 + x3];
    }
    _flush() {
      const coords = this.coords;
      for (let i5 = 0; i5 < this._pendingLen; i5++) {
        const t3 = this._pending[i5];
        const a3 = 2 * this.triangles[t3 * 3 + 0];
        const b2 = 2 * this.triangles[t3 * 3 + 1];
        const c2 = 2 * this.triangles[t3 * 3 + 2];
        this._findCandidate(coords[a3], coords[a3 + 1], coords[b2], coords[b2 + 1], coords[c2], coords[c2 + 1], t3);
      }
      this._pendingLen = 0;
    }
    _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t3) {
      const minX = Math.min(p0x, p1x, p2x);
      const minY = Math.min(p0y, p1y, p2y);
      const maxX = Math.max(p0x, p1x, p2x);
      const maxY = Math.max(p0y, p1y, p2y);
      let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
      let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
      let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
      const a01 = p1y - p0y;
      const b01 = p0x - p1x;
      const a12 = p2y - p1y;
      const b12 = p1x - p2x;
      const a20 = p0y - p2y;
      const b20 = p2x - p0x;
      const a3 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
      const z0 = this.heightAt(p0x, p0y) / a3;
      const z1 = this.heightAt(p1x, p1y) / a3;
      const z2 = this.heightAt(p2x, p2y) / a3;
      let maxError = 0;
      let mx = 0;
      let my = 0;
      let rms = 0;
      for (let y3 = minY; y3 <= maxY; y3++) {
        let dx = 0;
        if (w00 < 0 && a12 !== 0) {
          dx = Math.max(dx, Math.floor(-w00 / a12));
        }
        if (w01 < 0 && a20 !== 0) {
          dx = Math.max(dx, Math.floor(-w01 / a20));
        }
        if (w02 < 0 && a01 !== 0) {
          dx = Math.max(dx, Math.floor(-w02 / a01));
        }
        let w0 = w00 + a12 * dx;
        let w1 = w01 + a20 * dx;
        let w2 = w02 + a01 * dx;
        let wasInside = false;
        for (let x3 = minX + dx; x3 <= maxX; x3++) {
          if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
            wasInside = true;
            const z3 = z0 * w0 + z1 * w1 + z2 * w2;
            const dz = Math.abs(z3 - this.heightAt(x3, y3));
            rms += dz * dz;
            if (dz > maxError) {
              maxError = dz;
              mx = x3;
              my = y3;
            }
          } else if (wasInside) {
            break;
          }
          w0 += a12;
          w1 += a20;
          w2 += a01;
        }
        w00 += b12;
        w01 += b20;
        w02 += b01;
      }
      if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
        maxError = 0;
      }
      this._candidates[2 * t3] = mx;
      this._candidates[2 * t3 + 1] = my;
      this._rms[t3] = rms;
      this._queuePush(t3, maxError, rms);
    }
    _step() {
      const t3 = this._queuePop();
      const e0 = t3 * 3 + 0;
      const e1 = t3 * 3 + 1;
      const e22 = t3 * 3 + 2;
      const p0 = this.triangles[e0];
      const p1 = this.triangles[e1];
      const p22 = this.triangles[e22];
      const ax = this.coords[2 * p0];
      const ay = this.coords[2 * p0 + 1];
      const bx = this.coords[2 * p1];
      const by = this.coords[2 * p1 + 1];
      const cx = this.coords[2 * p22];
      const cy = this.coords[2 * p22 + 1];
      const px = this._candidates[2 * t3];
      const py = this._candidates[2 * t3 + 1];
      const pn = this._addPoint(px, py);
      if (orient(ax, ay, bx, by, px, py) === 0) {
        this._handleCollinear(pn, e0);
      } else if (orient(bx, by, cx, cy, px, py) === 0) {
        this._handleCollinear(pn, e1);
      } else if (orient(cx, cy, ax, ay, px, py) === 0) {
        this._handleCollinear(pn, e22);
      } else {
        const h0 = this._halfedges[e0];
        const h1 = this._halfedges[e1];
        const h2 = this._halfedges[e22];
        const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
        const t1 = this._addTriangle(p1, p22, pn, h1, -1, t0 + 1);
        const t22 = this._addTriangle(p22, p0, pn, h2, t0 + 2, t1 + 1);
        this._legalize(t0);
        this._legalize(t1);
        this._legalize(t22);
      }
    }
    _addPoint(x3, y3) {
      const i5 = this.coords.length >> 1;
      this.coords.push(x3, y3);
      return i5;
    }
    _addTriangle(a3, b2, c2, ab, bc, ca) {
      let e3 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.triangles.length;
      const t3 = e3 / 3;
      this.triangles[e3 + 0] = a3;
      this.triangles[e3 + 1] = b2;
      this.triangles[e3 + 2] = c2;
      this._halfedges[e3 + 0] = ab;
      this._halfedges[e3 + 1] = bc;
      this._halfedges[e3 + 2] = ca;
      if (ab >= 0) {
        this._halfedges[ab] = e3 + 0;
      }
      if (bc >= 0) {
        this._halfedges[bc] = e3 + 1;
      }
      if (ca >= 0) {
        this._halfedges[ca] = e3 + 2;
      }
      this._candidates[2 * t3 + 0] = 0;
      this._candidates[2 * t3 + 1] = 0;
      this._queueIndices[t3] = -1;
      this._rms[t3] = 0;
      this._pending[this._pendingLen++] = t3;
      return e3;
    }
    _legalize(a3) {
      const b2 = this._halfedges[a3];
      if (b2 < 0) {
        return;
      }
      const a0 = a3 - a3 % 3;
      const b0 = b2 - b2 % 3;
      const al = a0 + (a3 + 1) % 3;
      const ar = a0 + (a3 + 2) % 3;
      const bl = b0 + (b2 + 2) % 3;
      const br = b0 + (b2 + 1) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a3];
      const pl = this.triangles[al];
      const p1 = this.triangles[bl];
      const coords = this.coords;
      if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
        return;
      }
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(a0 / 3);
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
      const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
      this._legalize(t0 + 1);
      this._legalize(t1 + 2);
    }
    _handleCollinear(pn, a3) {
      const a0 = a3 - a3 % 3;
      const al = a0 + (a3 + 1) % 3;
      const ar = a0 + (a3 + 2) % 3;
      const p0 = this.triangles[ar];
      const pr = this.triangles[a3];
      const pl = this.triangles[al];
      const hal = this._halfedges[al];
      const har = this._halfedges[ar];
      const b2 = this._halfedges[a3];
      if (b2 < 0) {
        const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
        const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
        this._legalize(t02 + 1);
        this._legalize(t12 + 2);
        return;
      }
      const b0 = b2 - b2 % 3;
      const bl = b0 + (b2 + 2) % 3;
      const br = b0 + (b2 + 1) % 3;
      const p1 = this.triangles[bl];
      const hbl = this._halfedges[bl];
      const hbr = this._halfedges[br];
      this._queueRemove(b0 / 3);
      const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
      const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
      const t22 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
      const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t22 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t22);
      this._legalize(t3);
    }
    _queuePush(t3, error, rms) {
      const i5 = this._queue.length;
      this._queueIndices[t3] = i5;
      this._queue.push(t3);
      this._errors.push(error);
      this._rmsSum += rms;
      this._queueUp(i5);
    }
    _queuePop() {
      const n3 = this._queue.length - 1;
      this._queueSwap(0, n3);
      this._queueDown(0, n3);
      return this._queuePopBack();
    }
    _queuePopBack() {
      const t3 = this._queue.pop();
      this._errors.pop();
      this._rmsSum -= this._rms[t3];
      this._queueIndices[t3] = -1;
      return t3;
    }
    _queueRemove(t3) {
      const i5 = this._queueIndices[t3];
      if (i5 < 0) {
        const it = this._pending.indexOf(t3);
        if (it !== -1) {
          this._pending[it] = this._pending[--this._pendingLen];
        } else {
          throw new Error("Broken triangulation (something went wrong).");
        }
        return;
      }
      const n3 = this._queue.length - 1;
      if (n3 !== i5) {
        this._queueSwap(i5, n3);
        if (!this._queueDown(i5, n3)) {
          this._queueUp(i5);
        }
      }
      this._queuePopBack();
    }
    _queueLess(i5, j2) {
      return this._errors[i5] > this._errors[j2];
    }
    _queueSwap(i5, j2) {
      const pi = this._queue[i5];
      const pj = this._queue[j2];
      this._queue[i5] = pj;
      this._queue[j2] = pi;
      this._queueIndices[pi] = j2;
      this._queueIndices[pj] = i5;
      const e3 = this._errors[i5];
      this._errors[i5] = this._errors[j2];
      this._errors[j2] = e3;
    }
    _queueUp(j0) {
      let j2 = j0;
      while (true) {
        const i5 = j2 - 1 >> 1;
        if (i5 === j2 || !this._queueLess(j2, i5)) {
          break;
        }
        this._queueSwap(i5, j2);
        j2 = i5;
      }
    }
    _queueDown(i0, n3) {
      let i5 = i0;
      while (true) {
        const j1 = 2 * i5 + 1;
        if (j1 >= n3 || j1 < 0) {
          break;
        }
        const j2 = j1 + 1;
        let j3 = j1;
        if (j2 < n3 && this._queueLess(j2, j1)) {
          j3 = j2;
        }
        if (!this._queueLess(j3, i5)) {
          break;
        }
        this._queueSwap(i5, j3);
        i5 = j3;
      }
      return i5 > i0;
    }
  };
  function orient(ax, ay, bx, by, cx, cy) {
    return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js
  function makeTerrainMeshFromImage(terrainImage, terrainOptions) {
    const {
      meshMaxError,
      bounds,
      elevationDecoder
    } = terrainOptions;
    const {
      data,
      width,
      height
    } = terrainImage;
    let terrain;
    let mesh;
    switch (terrainOptions.tesselator) {
      case "martini":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        break;
      case "delatin":
        terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        break;
      default:
        if (width === height && !(height & width - 1)) {
          terrain = getTerrain(data, width, height, elevationDecoder, "martini");
          mesh = getMartiniTileMesh(meshMaxError, width, terrain);
        } else {
          terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
          mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
        }
        break;
    }
    const {
      vertices
    } = mesh;
    let {
      triangles
    } = mesh;
    let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
    const boundingBox = getMeshBoundingBox(attributes);
    if (terrainOptions.skirtHeight) {
      const {
        attributes: newAttributes,
        triangles: newTriangles
      } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
      attributes = newAttributes;
      triangles = newTriangles;
    }
    return {
      loaderData: {
        header: {}
      },
      header: {
        vertexCount: triangles.length,
        boundingBox
      },
      mode: 4,
      indices: {
        value: Uint32Array.from(triangles),
        size: 1
      },
      attributes
    };
  }
  function getMartiniTileMesh(meshMaxError, width, terrain) {
    const gridSize = width + 1;
    const martini = new Martini(gridSize);
    const tile = martini.createTile(terrain);
    const {
      vertices,
      triangles
    } = tile.getMesh(meshMaxError);
    return {
      vertices,
      triangles
    };
  }
  function getDelatinTileMesh(meshMaxError, width, height, terrain) {
    const tin = new Delatin(terrain, width + 1, height + 1);
    tin.run(meshMaxError);
    const {
      coords,
      triangles
    } = tin;
    const vertices = coords;
    return {
      vertices,
      triangles
    };
  }
  function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
    const {
      rScaler,
      bScaler,
      gScaler,
      offset
    } = elevationDecoder;
    const terrain = new Float32Array((width + 1) * (height + 1));
    for (let i5 = 0, y3 = 0; y3 < height; y3++) {
      for (let x3 = 0; x3 < width; x3++, i5++) {
        const k2 = i5 * 4;
        const r3 = imageData[k2 + 0];
        const g2 = imageData[k2 + 1];
        const b2 = imageData[k2 + 2];
        terrain[i5 + y3] = r3 * rScaler + g2 * gScaler + b2 * bScaler + offset;
      }
    }
    if (tesselator === "martini") {
      for (let i5 = (width + 1) * width, x3 = 0; x3 < width; x3++, i5++) {
        terrain[i5] = terrain[i5 - width - 1];
      }
      for (let i5 = height, y3 = 0; y3 < height + 1; y3++, i5 += height + 1) {
        terrain[i5] = terrain[i5 - 1];
      }
    }
    return terrain;
  }
  function getMeshAttributes2(vertices, terrain, width, height, bounds) {
    const gridSize = width + 1;
    const numOfVerticies = vertices.length / 2;
    const positions = new Float32Array(numOfVerticies * 3);
    const texCoords = new Float32Array(numOfVerticies * 2);
    const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
    const xScale = (maxX - minX) / width;
    const yScale = (maxY - minY) / height;
    for (let i5 = 0; i5 < numOfVerticies; i5++) {
      const x3 = vertices[i5 * 2];
      const y3 = vertices[i5 * 2 + 1];
      const pixelIdx = y3 * gridSize + x3;
      positions[3 * i5 + 0] = x3 * xScale + minX;
      positions[3 * i5 + 1] = -y3 * yScale + maxY;
      positions[3 * i5 + 2] = terrain[pixelIdx];
      texCoords[2 * i5 + 0] = x3 / width;
      texCoords[2 * i5 + 1] = y3 / height;
    }
    return {
      POSITION: {
        value: positions,
        size: 3
      },
      TEXCOORD_0: {
        value: texCoords,
        size: 2
      }
    };
  }

  // ../../node_modules/@loaders.gl/terrain/dist/lib/utils/version.js
  var VERSION13 = true ? "4.1.4" : "latest";

  // ../../node_modules/@loaders.gl/terrain/dist/terrain-loader.js
  var TerrainLoader = {
    name: "Terrain",
    id: "terrain",
    module: "terrain",
    version: VERSION13,
    worker: true,
    extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
    mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
    options: {
      terrain: {
        tesselator: "auto",
        bounds: void 0,
        meshMaxError: 10,
        elevationDecoder: {
          rScaler: 1,
          gScaler: 0,
          bScaler: 0,
          offset: 0
        },
        skirtHeight: void 0
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/quantized-mesh-loader.js
  var QuantizedMeshLoader = {
    name: "Quantized Mesh",
    id: "quantized-mesh",
    module: "terrain",
    version: VERSION13,
    worker: true,
    extensions: ["terrain"],
    mimeTypes: ["application/vnd.quantized-mesh"],
    options: {
      "quantized-mesh": {
        bounds: [0, 0, 1, 1],
        skirtHeight: null
      }
    }
  };

  // ../../node_modules/@loaders.gl/terrain/dist/index.js
  var TerrainLoader2 = {
    ...TerrainLoader,
    parse: parseTerrain
  };
  async function parseTerrain(arrayBuffer2, options, context) {
    const loadImageOptions = {
      ...options,
      mimeType: "application/x.image",
      image: {
        ...options === null || options === void 0 ? void 0 : options.image,
        type: "data"
      }
    };
    const image = await parseFromContext(arrayBuffer2, [], loadImageOptions, context);
    const terrainOptions = {
      ...TerrainLoader2.options.terrain,
      ...options === null || options === void 0 ? void 0 : options.terrain
    };
    return makeTerrainMeshFromImage(image, terrainOptions);
  }
  var QuantizedMeshLoader2 = {
    ...QuantizedMeshLoader,
    parseSync: (arrayBuffer2, options) => parseQuantizedMesh(arrayBuffer2, options === null || options === void 0 ? void 0 : options["quantized-mesh"]),
    parse: async (arrayBuffer2, options) => parseQuantizedMesh(arrayBuffer2, options === null || options === void 0 ? void 0 : options["quantized-mesh"])
  };

  // ../geo-layers/src/terrain-layer/terrain-layer.ts
  var DUMMY_DATA = [1];
  var defaultProps31 = {
    ...TileLayer.defaultProps,
    elevationData: urlType,
    texture: { ...urlType, optional: true },
    meshMaxError: { type: "number", value: 4 },
    bounds: { type: "array", value: null, optional: true, compare: true },
    color: { type: "color", value: [255, 255, 255] },
    elevationDecoder: {
      type: "object",
      value: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      }
    },
    workerUrl: "",
    wireframe: false,
    material: true,
    loaders: [TerrainLoader]
  };
  function urlTemplateToUpdateTrigger(template) {
    if (Array.isArray(template)) {
      return template.join(";");
    }
    return template || "";
  }
  var TerrainLayer = class extends CompositeLayer {
    updateState({ props, oldProps }) {
      const elevationDataChanged = props.elevationData !== oldProps.elevationData;
      if (elevationDataChanged) {
        const { elevationData } = props;
        const isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes("{x}") && elevationData.includes("{y}"));
        this.setState({ isTiled });
      }
      const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
      if (!this.state.isTiled && shouldReload) {
        const terrain = this.loadTerrain(props);
        this.setState({ terrain });
      }
      if (props.workerUrl) {
        log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
      }
    }
    loadTerrain({
      elevationData,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    }) {
      if (!elevationData) {
        return null;
      }
      let loadOptions = this.getLoadOptions();
      loadOptions = {
        ...loadOptions,
        terrain: {
          skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
          ...loadOptions?.terrain,
          bounds,
          meshMaxError,
          elevationDecoder
        }
      };
      const { fetch: fetch2 } = this.props;
      return fetch2(elevationData, { propName: "elevationData", layer: this, loadOptions, signal });
    }
    getTiledTerrainData(tile) {
      const { elevationData, fetch: fetch2, texture, elevationDecoder, meshMaxError } = this.props;
      const { viewport } = this.context;
      const dataUrl = getURLFromTemplate(elevationData, tile);
      const textureUrl = texture && getURLFromTemplate(texture, tile);
      const { signal } = tile;
      let bottomLeft = [0, 0];
      let topRight = [0, 0];
      if (viewport.isGeospatial) {
        const bbox = tile.bbox;
        bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
        topRight = viewport.projectFlat([bbox.east, bbox.north]);
      } else {
        const bbox = tile.bbox;
        bottomLeft = [bbox.left, bbox.bottom];
        topRight = [bbox.right, bbox.top];
      }
      const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
      const terrain = this.loadTerrain({
        elevationData: dataUrl,
        bounds,
        elevationDecoder,
        meshMaxError,
        signal
      });
      const surface = textureUrl ? fetch2(textureUrl, { propName: "texture", layer: this, loaders: [], signal }).catch((_) => null) : Promise.resolve(null);
      return Promise.all([terrain, surface]);
    }
    renderSubLayers(props) {
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      const { color, wireframe, material } = this.props;
      const { data } = props;
      if (!data) {
        return null;
      }
      const [mesh, texture] = data;
      return new SubLayerClass(props, {
        data: DUMMY_DATA,
        mesh,
        texture,
        _instanced: false,
        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
        getPosition: (d2) => [0, 0, 0],
        getColor: color,
        wireframe,
        material
      });
    }
    onViewportLoad(tiles) {
      if (!tiles) {
        return;
      }
      const { zRange } = this.state;
      const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
        const bounds = arr[0].header.boundingBox;
        return bounds.map((bound) => bound[2]);
      });
      if (ranges.length === 0) {
        return;
      }
      const minZ = Math.min(...ranges.map((x3) => x3[0]));
      const maxZ = Math.max(...ranges.map((x3) => x3[1]));
      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
        this.setState({ zRange: [minZ, maxZ] });
      }
    }
    renderLayers() {
      const {
        color,
        material,
        elevationData,
        texture,
        wireframe,
        meshMaxError,
        elevationDecoder,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      } = this.props;
      if (this.state.isTiled) {
        return new TileLayer(
          this.getSubLayerProps({
            id: "tiles"
          }),
          {
            getTileData: this.getTiledTerrainData.bind(this),
            renderSubLayers: this.renderSubLayers.bind(this),
            updateTriggers: {
              getTileData: {
                elevationData: urlTemplateToUpdateTrigger(elevationData),
                texture: urlTemplateToUpdateTrigger(texture),
                meshMaxError,
                elevationDecoder
              }
            },
            onViewportLoad: this.onViewportLoad.bind(this),
            zRange: this.state.zRange || null,
            tileSize,
            maxZoom,
            minZoom,
            extent,
            maxRequests,
            onTileLoad,
            onTileUnload,
            onTileError,
            maxCacheSize,
            maxCacheByteSize,
            refinementStrategy
          }
        );
      }
      if (!elevationData) {
        return null;
      }
      const SubLayerClass = this.getSubLayerClass("mesh", SimpleMeshLayer);
      return new SubLayerClass(
        this.getSubLayerProps({
          id: "mesh"
        }),
        {
          data: DUMMY_DATA,
          mesh: this.state.terrain,
          texture,
          _instanced: false,
          getPosition: (d2) => [0, 0, 0],
          getColor: color,
          material,
          wireframe
        }
      );
    }
  };
  TerrainLayer.defaultProps = defaultProps31;
  TerrainLayer.layerName = "TerrainLayer";

  // ../extensions/src/utils/syntax-tags.ts
  var glsl = (s3) => `${s3}`;

  // ../extensions/src/brushing/shader-module.ts
  var vs9 = glsl`
  uniform bool brushing_enabled;
  uniform int brushing_target;
  uniform vec2 brushing_mousePos;
  uniform float brushing_radius;

  #ifdef NON_INSTANCED_MODEL
  in vec2 brushingTargets;
  #else
  in vec2 instanceBrushingTargets;
  #endif

  out float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing_enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing_mousePos);
    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);

    return distance <= brushing_radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`;
  var fs7 = glsl`
  uniform bool brushing_enabled;
  in float brushing_isVisible;
`;
  var TARGET = {
    source: 0,
    target: 1,
    custom: 2,
    source_target: 3
  };
  var inject = {
    "vs:DECKGL_FILTER_GL_POSITION": glsl`
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing_target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing_target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing_target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      #ifdef NON_INSTANCED_MODEL
      brushingTarget = brushingTargets;
      #else
      brushingTarget = instanceBrushingTargets;
      #endif
    }
    bool visible;
    if (brushing_target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `,
    "fs:DECKGL_FILTER_COLOR": `
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
  };
  var shader_module_default = {
    name: "brushing",
    dependencies: [project_default],
    vs: vs9,
    fs: fs7,
    inject,
    getUniforms: (opts) => {
      if (!opts || !("viewport" in opts)) {
        return {};
      }
      const {
        brushingEnabled = true,
        brushingRadius = 1e4,
        brushingTarget = "source",
        mousePosition,
        viewport
      } = opts;
      return {
        brushing_enabled: Boolean(
          brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)
        ),
        brushing_radius: brushingRadius,
        brushing_target: TARGET[brushingTarget] || 0,
        brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
      };
    }
  };

  // ../extensions/src/brushing/brushing-extension.ts
  var defaultProps32 = {
    getBrushingTarget: { type: "accessor", value: [0, 0] },
    brushingTarget: "source",
    brushingEnabled: true,
    brushingRadius: 1e4
  };
  var BrushingExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [shader_module_default]
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.add({
          brushingTargets: {
            size: 2,
            accessor: "getBrushingTarget",
            shaderAttributes: {
              brushingTargets: {
                divisor: 0
              },
              instanceBrushingTargets: {
                divisor: 1
              }
            }
          }
        });
      }
      const onMouseMove = () => {
        this.getCurrentLayer()?.setNeedsRedraw();
      };
      this.state.onMouseMove = onMouseMove;
      if (context.deck) {
        context.deck.eventManager.on({
          pointermove: onMouseMove,
          pointerleave: onMouseMove
        });
      }
    }
    finalizeState(context, extension) {
      if (context.deck) {
        const onMouseMove = this.state.onMouseMove;
        context.deck.eventManager.off({
          pointermove: onMouseMove,
          pointerleave: onMouseMove
        });
      }
    }
  };
  BrushingExtension.defaultProps = defaultProps32;
  BrushingExtension.extensionName = "BrushingExtension";

  // ../extensions/src/data-filter/shader-module.ts
  var vs10 = glsl`
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;
uniform ivec4 filter_categoryBitMask;

#ifdef NON_INSTANCED_MODEL
  #define DATAFILTER_ATTRIB filterValues
  #define DATAFILTER_ATTRIB_64LOW filterValues64Low
  #define DATACATEGORY_ATTRIB filterCategoryValues
#else
  #define DATAFILTER_ATTRIB instanceFilterValues
  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low
  #define DATACATEGORY_ATTRIB instanceFilterCategoryValues
#endif

in DATAFILTER_TYPE DATAFILTER_ATTRIB;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;

  uniform DATAFILTER_TYPE filter_min64High;
  uniform DATAFILTER_TYPE filter_max64High;
#endif
in DATACATEGORY_TYPE DATACATEGORY_ATTRIB;

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {
  if (filter_enabled) {
    if (filter_useSoftMargin) {
      dataFilter_value = dataFilter_reduceValue(
        smoothstep(filter_min, filter_softMin, valueFromMin) *
        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))
      );
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
      );
    }

    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
      int dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
      ivec2 dataFilter_masks = ivec2(
        filter_categoryBitMask[int(category.x / 32.0)],
        filter_categoryBitMask[int(category.y / 32.0) + 2]
      );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
      ivec3 dataFilter_masks = filter_categoryBitMask.xyz;
    #else // Four 32-bit masks
      ivec4 dataFilter_masks = filter_categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));
    dataFilter_bits = mod(floor(dataFilter_bits), 2.0);

    #if DATACATEGORY_CHANNELS == 1
      if(dataFilter_bits == 0.0) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;
    #endif
  } else {
    dataFilter_value = 1.0;
  }
}
`;
  var fs8 = glsl`
uniform bool filter_transformColor;
in float dataFilter_value;
`;
  function getUniforms6(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const {
      filterRange = [-1, 1],
      filterEnabled = true,
      filterTransformSize = true,
      filterTransformColor = true
    } = opts;
    const filterSoftRange = opts.filterSoftRange || filterRange;
    return {
      ...Number.isFinite(filterRange[0]) ? {
        filter_min: filterRange[0],
        filter_softMin: filterSoftRange[0],
        filter_softMax: filterSoftRange[1],
        filter_max: filterRange[1]
      } : {
        filter_min: filterRange.map((r3) => r3[0]),
        filter_softMin: filterSoftRange.map((r3) => r3[0]),
        filter_softMax: filterSoftRange.map((r3) => r3[1]),
        filter_max: filterRange.map((r3) => r3[1])
      },
      filter_enabled: filterEnabled,
      filter_useSoftMargin: Boolean(opts.filterSoftRange),
      filter_transformSize: filterEnabled && filterTransformSize,
      filter_transformColor: filterEnabled && filterTransformColor
    };
  }
  function getUniforms64(opts) {
    if (!opts || !("extensions" in opts)) {
      return {};
    }
    const uniforms = getUniforms6(opts);
    if (Number.isFinite(uniforms.filter_min)) {
      const min64High = Math.fround(uniforms.filter_min);
      uniforms.filter_min -= min64High;
      uniforms.filter_softMin -= min64High;
      uniforms.filter_min64High = min64High;
      const max64High = Math.fround(uniforms.filter_max);
      uniforms.filter_max -= max64High;
      uniforms.filter_softMax -= max64High;
      uniforms.filter_max64High = max64High;
    } else {
      const min64High = uniforms.filter_min.map(Math.fround);
      uniforms.filter_min = uniforms.filter_min.map((x3, i5) => x3 - min64High[i5]);
      uniforms.filter_softMin = uniforms.filter_softMin.map((x3, i5) => x3 - min64High[i5]);
      uniforms.filter_min64High = min64High;
      const max64High = uniforms.filter_max.map(Math.fround);
      uniforms.filter_max = uniforms.filter_max.map((x3, i5) => x3 - max64High[i5]);
      uniforms.filter_softMax = uniforms.filter_softMax.map((x3, i5) => x3 - max64High[i5]);
      uniforms.filter_max64High = max64High;
    }
    return uniforms;
  }
  var inject2 = {
    "vs:#main-start": glsl`
    #ifdef DATAFILTER_DOUBLE
      dataFilter_setValue(
        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,
        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,
        DATACATEGORY_ATTRIB
      );
    #else
      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);
    #endif
  `,
    "vs:#main-end": glsl`
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `,
    "vs:DECKGL_FILTER_SIZE": glsl`
    if (filter_transformSize) {
      size = size * dataFilter_value;
    }
  `,
    "fs:DECKGL_FILTER_COLOR": glsl`
    if (dataFilter_value == 0.0) discard;
    if (filter_transformColor) {
      color.a *= dataFilter_value;
    }
  `
  };
  var shaderModule = {
    name: "data-filter",
    vs: vs10,
    fs: fs8,
    inject: inject2,
    getUniforms: getUniforms6
  };
  var shaderModule64 = {
    name: "data-filter-fp64",
    vs: vs10,
    fs: fs8,
    inject: inject2,
    getUniforms: getUniforms64
  };

  // ../extensions/src/data-filter/aggregator.ts
  var AGGREGATE_VS = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
  var AGGREGATE_FS = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;
  var FLOAT_TARGET_FEATURES = [
    "float32-renderable-webgl",
    "texture-blend-float-webgl"
  ];
  function supportsFloatTarget(device) {
    return FLOAT_TARGET_FEATURES.every((feature) => device.features.has(feature));
  }
  function getFramebuffer4(device, useFloatTarget) {
    if (useFloatTarget) {
      return device.createFramebuffer({
        width: 1,
        height: 1,
        colorAttachments: [
          device.createTexture({
            format: "rgba32float",
            type: GLEnum.FLOAT,
            mipmaps: false
          })
        ]
      });
    }
    return device.createFramebuffer({
      width: 256,
      height: 64,
      colorAttachments: [device.createTexture({ format: "rgba8unorm", type: GLEnum.FLOAT, mipmaps: false })]
    });
  }
  function getModel(device, shaderOptions, useFloatTarget) {
    shaderOptions.defines.NON_INSTANCED_MODEL = 1;
    if (useFloatTarget) {
      shaderOptions.defines.FLOAT_TARGET = 1;
    }
    return new Model(device, {
      id: "data-filter-aggregation-model",
      vertexCount: 1,
      isInstanced: false,
      drawMode: GLEnum.POINTS,
      vs: AGGREGATE_VS,
      fs: AGGREGATE_FS,
      ...shaderOptions
    });
  }
  var parameters = {
    blend: true,
    blendFunc: [GLEnum.ONE, GLEnum.ONE, GLEnum.ONE, GLEnum.ONE],
    blendEquation: [GLEnum.FUNC_ADD, GLEnum.FUNC_ADD],
    depthTest: false
  };

  // ../extensions/src/data-filter/data-filter-extension.ts
  var defaultProps33 = {
    getFilterValue: { type: "accessor", value: 0 },
    getFilterCategory: { type: "accessor", value: 0 },
    onFilteredItemsChange: { type: "function", value: null, optional: true },
    filterEnabled: true,
    filterRange: [-1, 1],
    filterSoftRange: null,
    filterCategories: [0],
    filterTransformSize: true,
    filterTransformColor: true
  };
  var defaultOptions = {
    categorySize: 1,
    filterSize: 1,
    fp64: false,
    countItems: false
  };
  var DATA_TYPE_FROM_SIZE = {
    1: "float",
    2: "vec2",
    3: "vec3",
    4: "vec4"
  };
  var DataFilterExtension = class extends LayerExtension {
    constructor(opts = {}) {
      super({ ...defaultOptions, ...opts });
    }
    getShaders(extension) {
      const { categorySize, filterSize, fp64: fp642 } = extension.opts;
      return {
        modules: [fp642 ? shaderModule64 : shaderModule],
        defines: {
          DATACATEGORY_TYPE: DATA_TYPE_FROM_SIZE[categorySize],
          DATACATEGORY_CHANNELS: categorySize,
          DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
          DATAFILTER_DOUBLE: Boolean(fp642)
        }
      };
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      const { categorySize, filterSize, fp64: fp642 } = extension.opts;
      if (attributeManager) {
        attributeManager.add({
          filterValues: {
            size: filterSize,
            type: fp642 ? "float64" : "float32",
            accessor: "getFilterValue",
            shaderAttributes: {
              filterValues: {
                divisor: 0
              },
              instanceFilterValues: {
                divisor: 1
              }
            }
          },
          filterCategoryValues: {
            size: categorySize,
            accessor: "getFilterCategory",
            transform: categorySize === 1 ? (d2) => extension._getCategoryKey.call(this, d2, 0) : (d2) => d2.map((x3, i5) => extension._getCategoryKey.call(this, x3, i5)),
            shaderAttributes: {
              filterCategoryValues: {
                divisor: 0
              },
              instanceFilterCategoryValues: {
                divisor: 1
              }
            }
          }
        });
      }
      const { device } = this.context;
      if (attributeManager && extension.opts.countItems) {
        const useFloatTarget = supportsFloatTarget(device);
        attributeManager.add({
          filterIndices: {
            size: useFloatTarget ? 1 : 2,
            vertexOffset: 1,
            type: "unorm8",
            accessor: (object, { index: index2 }) => {
              const i5 = object && object.__source ? object.__source.index : index2;
              return useFloatTarget ? (i5 + 1) % 255 : [(i5 + 1) % 255, Math.floor(i5 / 255) % 255];
            },
            shaderAttributes: {
              filterPrevIndices: {
                vertexOffset: 0
              },
              filterIndices: {
                vertexOffset: 1
              }
            }
          }
        });
        const filterFBO = getFramebuffer4(device, useFloatTarget);
        const filterModel = getModel(
          device,
          extension.getShaders.call(this, extension),
          useFloatTarget
        );
        this.setState({ filterFBO, filterModel });
      }
    }
    updateState({ props, oldProps, changeFlags }, extension) {
      const attributeManager = this.getAttributeManager();
      const { categorySize } = extension.opts;
      if (this.state.filterModel) {
        const filterNeedsUpdate = attributeManager.attributes.filterValues.needsUpdate() || attributeManager.attributes.filterCategoryValues?.needsUpdate() || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories;
        if (filterNeedsUpdate) {
          this.setState({ filterNeedsUpdate });
        }
      }
      if (attributeManager?.attributes.filterCategoryValues) {
        const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual2(props.filterCategories, oldProps.filterCategories, 2);
        if (categoryBitMaskNeedsUpdate) {
          this.setState({ categoryBitMaskNeedsUpdate });
        }
        const resetCategories = changeFlags.dataChanged;
        if (resetCategories) {
          this.setState({
            categoryMap: Array(categorySize).fill(0).map(() => ({}))
          });
          attributeManager.attributes.filterCategoryValues.setNeedsUpdate("categoryMap");
        }
      }
    }
    draw(params, extension) {
      const filterFBO = this.state.filterFBO;
      const filterModel = this.state.filterModel;
      const filterNeedsUpdate = this.state.filterNeedsUpdate;
      const categoryBitMaskNeedsUpdate = this.state.categoryBitMaskNeedsUpdate;
      const { onFilteredItemsChange } = this.props;
      if (categoryBitMaskNeedsUpdate) {
        extension._updateCategoryBitMask.call(this, params, extension);
      }
      if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
        const {
          attributes: { filterValues, filterCategoryValues, filterIndices }
        } = this.getAttributeManager();
        filterModel.setVertexCount(this.getNumInstances());
        this.context.device.clearWebGL({ framebuffer: filterFBO, color: [0, 0, 0, 0] });
        filterModel.updateModuleSettings(params.moduleParameters);
        filterModel.setAttributes({
          ...filterValues.getValue(),
          ...filterCategoryValues?.getValue(),
          ...filterIndices?.getValue()
        });
        filterModel.setUniforms(params.uniforms);
        filterModel.device.withParametersWebGL(
          {
            framebuffer: filterFBO,
            ...parameters,
            viewport: [0, 0, filterFBO.width, filterFBO.height]
          },
          () => {
            filterModel.draw(this.context.renderPass);
          }
        );
        const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
        let count2 = 0;
        for (let i5 = 0; i5 < color.length; i5++) {
          count2 += color[i5];
        }
        onFilteredItemsChange({ id: this.id, count: count2 });
        this.state.filterNeedsUpdate = false;
      }
    }
    finalizeState() {
      const filterFBO = this.state.filterFBO;
      const filterModel = this.state.filterModel;
      filterFBO?.destroy();
      filterModel?.destroy();
    }
    _updateCategoryBitMask(params, extension) {
      const { categorySize } = extension.opts;
      const { filterCategories } = this.props;
      const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
      const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;
      const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
      for (let c2 = 0; c2 < categoryFilters.length; c2++) {
        const categoryFilter = categoryFilters[c2];
        for (const category of categoryFilter) {
          const key = extension._getCategoryKey.call(this, category, c2);
          if (key < maxCategories) {
            const channel = c2 * (maxCategories / 32) + Math.floor(key / 32);
            categoryBitMask[channel] += Math.pow(2, key % 32);
          } else {
            log_default.warn(`Exceeded maximum number of categories (${maxCategories})`)();
          }
        }
      }
      params.uniforms.filter_categoryBitMask = categoryBitMask;
      this.state.categoryBitMaskNeedsUpdate = false;
    }
    _getCategoryKey(category, channel) {
      const categoryMap = this.state.categoryMap[channel];
      if (!(category in categoryMap)) {
        categoryMap[category] = Object.keys(categoryMap).length;
      }
      return categoryMap[category];
    }
  };
  DataFilterExtension.defaultProps = defaultProps33;
  DataFilterExtension.extensionName = "DataFilterExtension";

  // ../extensions/src/fp64/project64.glsl.ts
  var project64_glsl_default = `
const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);

uniform vec2 project_uViewProjectionMatrixFP64[16];

// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {

#if defined(NVIDIA_FP64_WORKAROUND)
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
  out_val[1] = sum_fp64(PI_FP64,
    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
  return;
}

void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
  vec2 pos_fp64[2];
  mercatorProject_fp64(position_fp64, pos_fp64);
  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);

  return;
}

void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
  vec4 position64xy = vec4(
    position.x, position64xyLow.x,
    position.y, position64xyLow.y);

  project_position_fp64(position64xy, out_val);
}

vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
  vec2 vertex_pos_clipspace[4];
  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
    vertex_pos_clipspace);
  return vec4(
    vertex_pos_clipspace[0].x,
    vertex_pos_clipspace[1].x,
    vertex_pos_clipspace[2].x,
    vertex_pos_clipspace[3].x
    );
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
  // This is the local offset to the instance position
  vec2 offset64[4];
  vec4_fp64(vec4(offset, 0.0), offset64);

  float z = project_size(position.z);

  // Apply web mercator projection (depends on coordinate system imn use)
  vec2 projectedPosition64xy[2];
  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);

  vec2 commonPosition64[4];
  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
  commonPosition64[3] = vec2(1.0, 0.0);

  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);

  return project_common_position_to_clipspace_fp64(commonPosition64);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64xyLow, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(
    position, position64xyLow, offset, commonPosition
  );
}
`;

  // ../extensions/src/fp64/project64.ts
  var { fp64ify: fp64ify2, fp64ifyMatrix4: fp64ifyMatrix42 } = fp64;
  var project64_default = {
    name: "project64",
    dependencies: [project_default, fp64],
    vs: project64_glsl_default,
    getUniforms: getUniforms7
  };
  var getMemoizedUniforms = memoize(calculateUniforms);
  function getUniforms7(opts) {
    if (opts && "viewport" in opts) {
      const { viewProjectionMatrix, scale: scale7 } = opts.viewport;
      return getMemoizedUniforms({ viewProjectionMatrix, scale: scale7 });
    }
    return {};
  }
  function calculateUniforms({
    viewProjectionMatrix,
    scale: scale7
  }) {
    const glViewProjectionMatrixFP64 = fp64ifyMatrix42(viewProjectionMatrix);
    const scaleFP64 = fp64ify2(scale7);
    return {
      project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
      project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
      project64_uScale: scaleFP64
    };
  }

  // ../extensions/src/fp64/fp64-extension.ts
  var Fp64Extension = class extends LayerExtension {
    getShaders() {
      const { coordinateSystem } = this.props;
      if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
        throw new Error("fp64: coordinateSystem must be LNGLAT");
      }
      return {
        modules: [project64_default]
      };
    }
  };
  Fp64Extension.extensionName = "Fp64Extension";

  // ../extensions/src/path-style/shaders.glsl.ts
  var dashShaders = {
    inject: {
      "vs:#decl": `
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,
      "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
      "fs:#decl": `
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
in vec2 vDashArray;
in float vDashOffset;
`,
      "fs:#main-start": `
  float solidLength = vDashArray.x;
  float gapLength = vDashArray.y;
  float unitLength = solidLength + gapLength;

  float offset;

  if (unitLength > 0.0) {
    if (dashAlignMode == 0.0) {
      offset = vDashOffset;
    } else {
      unitLength = vPathLength / round(vPathLength / unitLength);
      offset = solidLength / 2.0;
    }

    float unitOffset = mod(vPathPosition.y + offset, unitLength);

    if (gapLength > 0.0 && unitOffset > solidLength) {
      if (capType <= 0.5) {
        if (!(dashGapPickable && bool(picking.isActive))) {
          discard;
        }
      } else {
        // caps are rounded, test the distance to solid ends
        float distToEnd = length(vec2(
          min(unitOffset - solidLength, unitLength - unitOffset),
          vPathPosition.x
        ));
        if (distToEnd > 1.0) {
          if (!(dashGapPickable && bool(picking.isActive))) {
            discard;
          }
        }
      }
    }
  }
`
    }
  };
  var offsetShaders = {
    inject: {
      "vs:#decl": `
in float instanceOffsets;
`,
      "vs:DECKGL_FILTER_SIZE": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  size *= offsetWidth;
`,
      "vs:#main-end": `
  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
  float offsetDir = sign(instanceOffsets);
  vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
  vPathPosition.y *= offsetWidth;
  vPathLength *= offsetWidth;
`,
      "fs:#main-start": `
  float isInside;
  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
  if (isInside == 0.0) {
    discard;
  }
`
    }
  };

  // ../extensions/src/path-style/path-style-extension.ts
  var defaultProps34 = {
    getDashArray: { type: "accessor", value: [0, 0] },
    getOffset: { type: "accessor", value: 0 },
    dashJustified: false,
    dashGapPickable: false
  };
  var PathStyleExtension = class extends LayerExtension {
    constructor({
      dash = false,
      offset = false,
      highPrecisionDash = false
    } = {}) {
      super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });
    }
    isEnabled(layer) {
      return "pathTesselator" in layer.state;
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      let result = {};
      if (extension.opts.dash) {
        result = mergeShaders(result, dashShaders);
      }
      if (extension.opts.offset) {
        result = mergeShaders(result, offsetShaders);
      }
      return result;
    }
    initializeState(context, extension) {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager || !extension.isEnabled(this)) {
        return;
      }
      if (extension.opts.dash) {
        attributeManager.addInstanced({
          instanceDashArrays: { size: 2, accessor: "getDashArray" },
          instanceDashOffsets: extension.opts.highPrecisionDash ? {
            size: 1,
            accessor: "getPath",
            transform: extension.getDashOffsets.bind(this)
          } : {
            size: 1,
            update: (attribute) => {
              attribute.constant = true;
              attribute.value = [0];
            }
          }
        });
      }
      if (extension.opts.offset) {
        attributeManager.addInstanced({
          instanceOffsets: { size: 1, accessor: "getOffset" }
        });
      }
    }
    updateState(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const uniforms = {};
      if (extension.opts.dash) {
        uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
        uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);
      }
      this.state.model?.setUniforms(uniforms);
    }
    getDashOffsets(path) {
      const result = [0];
      const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
      const isNested2 = Array.isArray(path[0]);
      const geometrySize = isNested2 ? path.length : path.length / positionSize;
      let p3;
      let prevP;
      for (let i5 = 0; i5 < geometrySize - 1; i5++) {
        p3 = isNested2 ? path[i5] : path.slice(i5 * positionSize, i5 * positionSize + positionSize);
        p3 = this.projectPosition(p3);
        if (i5 > 0) {
          result[i5] = result[i5 - 1] + vec3_exports.dist(prevP, p3);
        }
        prevP = p3;
      }
      result[geometrySize - 1] = 0;
      return result;
    }
  };
  PathStyleExtension.defaultProps = defaultProps34;
  PathStyleExtension.extensionName = "PathStyleExtension";

  // ../extensions/src/fill-style/shader-module.ts
  var patternVs = glsl`
#ifdef NON_INSTANCED_MODEL
  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets
#else
  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames
  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales
  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets
#endif

in vec4 FILL_PATTERN_FRAME_ATTRIB;
in float FILL_PATTERN_SCALE_ATTRIB;
in vec2 FILL_PATTERN_OFFSET_ATTRIB;

uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;

out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`;
  var patternFs = glsl`
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;

in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`;
  var inject3 = {
    "vs:DECKGL_FILTER_GL_POSITION": glsl`
    fill_uv = geometry.position.xy;
  `,
    "vs:DECKGL_FILTER_COLOR": glsl`
    if (fill_patternEnabled) {
      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);
      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;
      fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;
    }
  `,
    "fs:DECKGL_FILTER_COLOR": glsl`
    if (fill_patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill_patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `
  };
  function getPatternUniforms(opts, uniforms) {
    if (!opts) {
      return {};
    }
    if ("fillPatternTexture" in opts) {
      const { fillPatternTexture } = opts;
      return {
        fill_patternTexture: fillPatternTexture,
        fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
      };
    }
    if ("viewport" in opts) {
      const { fillPatternMask = true, fillPatternEnabled = true } = opts;
      const { project_uCommonOrigin: coordinateOriginCommon } = uniforms;
      const coordinateOriginCommon64Low = [
        fp64LowPart2(coordinateOriginCommon[0]),
        fp64LowPart2(coordinateOriginCommon[1])
      ];
      return {
        fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
        fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,
        fill_patternMask: fillPatternMask,
        fill_patternEnabled: fillPatternEnabled
      };
    }
    return {};
  }
  var patternShaders = {
    name: "fill-pattern",
    vs: patternVs,
    fs: patternFs,
    inject: inject3,
    dependencies: [project_default],
    getUniforms: getPatternUniforms
  };

  // ../extensions/src/fill-style/fill-style-extension.ts
  var defaultProps35 = {
    fillPatternEnabled: true,
    fillPatternAtlas: {
      type: "image",
      value: null,
      async: true,
      parameters: { lodMaxClamp: 0 }
    },
    fillPatternMapping: { type: "object", value: {}, async: true },
    fillPatternMask: true,
    getFillPattern: { type: "accessor", value: (d2) => d2.pattern },
    getFillPatternScale: { type: "accessor", value: 1 },
    getFillPatternOffset: { type: "accessor", value: [0, 0] }
  };
  var FillStyleExtension = class extends LayerExtension {
    constructor({ pattern = false } = {}) {
      super({ pattern });
    }
    isEnabled(layer) {
      return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
    }
    getShaders(extension) {
      if (!extension.isEnabled(this)) {
        return null;
      }
      return {
        modules: [extension.opts.pattern && patternShaders].filter(Boolean)
      };
    }
    initializeState(context, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const attributeManager = this.getAttributeManager();
      if (extension.opts.pattern) {
        attributeManager.add({
          fillPatternFrames: {
            size: 4,
            accessor: "getFillPattern",
            transform: extension.getPatternFrame.bind(this),
            shaderAttributes: {
              fillPatternFrames: {
                divisor: 0
              },
              instanceFillPatternFrames: {
                divisor: 1
              }
            }
          },
          fillPatternScales: {
            size: 1,
            accessor: "getFillPatternScale",
            defaultValue: 1,
            shaderAttributes: {
              fillPatternScales: {
                divisor: 0
              },
              instanceFillPatternScales: {
                divisor: 1
              }
            }
          },
          fillPatternOffsets: {
            size: 2,
            accessor: "getFillPatternOffset",
            shaderAttributes: {
              fillPatternOffsets: {
                divisor: 0
              },
              instanceFillPatternOffsets: {
                divisor: 1
              }
            }
          }
        });
      }
      this.setState({
        emptyTexture: this.context.device.createTexture({
          data: new Uint8Array(4),
          width: 1,
          height: 1
        })
      });
    }
    updateState({ props, oldProps }, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
        this.getAttributeManager().invalidate("getFillPattern");
      }
    }
    draw(params, extension) {
      if (!extension.isEnabled(this)) {
        return;
      }
      const { fillPatternAtlas } = this.props;
      this.setModuleParameters({
        fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
      });
    }
    finalizeState() {
      const emptyTexture = this.state.emptyTexture;
      emptyTexture?.delete();
    }
    getPatternFrame(name13) {
      const { fillPatternMapping } = this.getCurrentLayer().props;
      const def = fillPatternMapping && fillPatternMapping[name13];
      return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
    }
  };
  FillStyleExtension.defaultProps = defaultProps35;
  FillStyleExtension.extensionName = "FillStyleExtension";

  // ../extensions/src/clip/clip-extension.ts
  var defaultProps36 = {
    clipBounds: [0, 0, 1, 1],
    clipByInstance: void 0
  };
  var shaderFunction = glsl`
uniform vec4 clip_bounds;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`;
  var shaderModuleVs = {
    name: "clip-vs",
    vs: shaderFunction
  };
  var injectionVs = {
    "vs:#decl": glsl`
out float clip_isVisible;
`,
    "vs:DECKGL_FILTER_GL_POSITION": glsl`
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,
    "fs:#decl": glsl`
in float clip_isVisible;
`,
    "fs:DECKGL_FILTER_COLOR": glsl`
  if (clip_isVisible < 0.5) discard;
`
  };
  var shaderModuleFs = {
    name: "clip-fs",
    fs: shaderFunction
  };
  var injectionFs = {
    "vs:#decl": glsl`
out vec2 clip_commonPosition;
`,
    "vs:DECKGL_FILTER_GL_POSITION": glsl`
  clip_commonPosition = geometry.position.xy;
`,
    "fs:#decl": glsl`
in vec2 clip_commonPosition;
`,
    "fs:DECKGL_FILTER_COLOR": glsl`
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
  };
  var ClipExtension = class extends LayerExtension {
    getShaders() {
      let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.clipByInstance !== void 0) {
        clipByInstance = Boolean(this.props.clipByInstance);
      }
      this.state.clipByInstance = clipByInstance;
      return clipByInstance ? {
        modules: [shaderModuleVs],
        inject: injectionVs
      } : {
        modules: [shaderModuleFs],
        inject: injectionFs
      };
    }
    draw({ uniforms }) {
      const { clipBounds } = this.props;
      if (this.state.clipByInstance) {
        uniforms.clip_bounds = clipBounds;
      } else {
        const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
        const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
        uniforms.clip_bounds = [
          Math.min(corner0[0], corner1[0]),
          Math.min(corner0[1], corner1[1]),
          Math.max(corner0[0], corner1[0]),
          Math.max(corner0[1], corner1[1])
        ];
      }
    }
  };
  ClipExtension.defaultProps = defaultProps36;
  ClipExtension.extensionName = "ClipExtension";

  // ../extensions/src/collision-filter/shader-module.ts
  var vs11 = glsl`
#ifdef NON_INSTANCED_MODEL
in float collisionPriorities;
#else
in float instanceCollisionPriorities;
#endif

uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision_enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project_uViewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`;
  var inject4 = {
    "vs:#decl": glsl`
  float collision_fade = 1.0;
`,
    "vs:DECKGL_FILTER_GL_POSITION": glsl`
  if (collision_sort) {
    #ifdef NON_INSTANCED_MODEL
    float collisionPriority = collisionPriorities;
    #else
    float collisionPriority = instanceCollisionPriorities;
    #endif
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision_enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `,
    "vs:DECKGL_FILTER_COLOR": glsl`
  color.a *= collision_fade;
  `
  };
  var getCollisionUniforms = (opts, uniforms) => {
    if (!opts || !("dummyCollisionMap" in opts)) {
      return {};
    }
    const { collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
    return {
      collision_sort: Boolean(drawToCollisionMap),
      collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
    };
  };
  var shader_module_default2 = {
    name: "collision",
    dependencies: [project_default],
    vs: vs11,
    inject: inject4,
    getUniforms: getCollisionUniforms
  };

  // ../extensions/src/collision-filter/collision-filter-pass.ts
  var CollisionFilterPass = class extends LayersPass {
    renderCollisionMap(target, options) {
      const padding = 1;
      const clearColor = [0, 0, 0, 0];
      const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];
      this.render({ ...options, clearColor, scissorRect, target, pass: "collision" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return { ...layer.props.parameters, blend: false, depthRange: [0, 1], depthTest: true };
    }
    getModuleParameters() {
      return {
        drawToCollisionMap: true,
        picking: {
          isActive: 1,
          isAttribute: false
        },
        lightSources: {}
      };
    }
  };

  // ../extensions/src/collision-filter/collision-filter-effect.ts
  var DOWNSCALE = 2;
  var CollisionFilterEffect = class {
    constructor() {
      this.id = "collision-filter-effect";
      this.props = null;
      this.useInPicking = true;
      this.order = 1;
      this.channels = {};
      this.collisionFBOs = {};
    }
    setup(context) {
      this.context = context;
      const { device } = context;
      this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });
      this.collisionFilterPass = new CollisionFilterPass(device, { id: "default-collision-filter" });
    }
    preRender({
      effects: allEffects,
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking,
      preRenderStats = {}
    }) {
      const { device } = this.context;
      if (isPicking) {
        return;
      }
      const collisionLayers = layers.filter(
        ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled
      );
      if (collisionLayers.length === 0) {
        this.channels = {};
        return;
      }
      const effects = allEffects?.filter((e3) => e3.useInPicking && preRenderStats[e3.id]);
      const maskEffectRendered = preRenderStats["mask-effect"]?.didRender;
      const channels = this._groupByCollisionGroup(device, collisionLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
      for (const collisionGroup in channels) {
        const collisionFBO = this.collisionFBOs[collisionGroup];
        const renderInfo = channels[collisionGroup];
        const [width, height] = device.canvasContext.getPixelSize();
        collisionFBO.resize({
          width: width / DOWNSCALE,
          height: height / DOWNSCALE
        });
        this._render(renderInfo, {
          effects,
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
      }
    }
    _render(renderInfo, {
      effects,
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      const { collisionGroup } = renderInfo;
      const oldRenderInfo = this.channels[collisionGroup];
      if (!oldRenderInfo) {
        return;
      }
      const needsRender = viewportChanged || renderInfo === oldRenderInfo || !deepEqual2(oldRenderInfo.layers, renderInfo.layers, 1) || renderInfo.layerBounds.some((b2, i5) => !equals(b2, oldRenderInfo.layerBounds[i5])) || renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || renderInfo.layers.some((layer) => layer.props.transitions);
      this.channels[collisionGroup] = renderInfo;
      if (needsRender) {
        this.lastViewport = viewport;
        const collisionFBO = this.collisionFBOs[collisionGroup];
        this.collisionFilterPass.renderCollisionMap(collisionFBO, {
          pass: "collision-filter",
          isPicking: true,
          layers: renderInfo.layers,
          effects,
          layerFilter,
          viewports: viewport ? [viewport] : [],
          onViewportActive,
          views,
          moduleParameters: {
            dummyCollisionMap: this.dummyCollisionMap,
            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
          }
        });
      }
    }
    _groupByCollisionGroup(device, collisionLayers) {
      const channelMap = {};
      for (const layer of collisionLayers) {
        const { collisionGroup } = layer.props;
        let channelInfo = channelMap[collisionGroup];
        if (!channelInfo) {
          channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };
          channelMap[collisionGroup] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
        if (!layer.isLoaded) {
          channelInfo.allLayersLoaded = false;
        }
      }
      for (const collisionGroup of Object.keys(channelMap)) {
        if (!this.collisionFBOs[collisionGroup]) {
          this.createFBO(device, collisionGroup);
        }
        if (!this.channels[collisionGroup]) {
          this.channels[collisionGroup] = channelMap[collisionGroup];
        }
      }
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        if (!channelMap[collisionGroup]) {
          this.destroyFBO(collisionGroup);
        }
      }
      return channelMap;
    }
    getModuleParameters(layer) {
      const { collisionGroup } = layer.props;
      const { collisionFBOs, dummyCollisionMap } = this;
      return { collisionFBO: collisionFBOs[collisionGroup], dummyCollisionMap };
    }
    cleanup() {
      if (this.dummyCollisionMap) {
        this.dummyCollisionMap.delete();
        this.dummyCollisionMap = void 0;
      }
      this.channels = {};
      for (const collisionGroup of Object.keys(this.collisionFBOs)) {
        this.destroyFBO(collisionGroup);
      }
      this.collisionFBOs = {};
      this.lastViewport = void 0;
    }
    createFBO(device, collisionGroup) {
      const { width, height } = device.gl.canvas;
      const collisionMap = device.createTexture({
        format: "rgba8unorm",
        width,
        height,
        sampler: {
          minFilter: "nearest",
          magFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      });
      const depthStencilAttachment = device.createTexture({
        format: "depth16unorm",
        width,
        height,
        mipmaps: false,
        dataFormat: 6402,
        type: 5125
      });
      this.collisionFBOs[collisionGroup] = device.createFramebuffer({
        id: `collision-${collisionGroup}`,
        width,
        height,
        colorAttachments: [collisionMap],
        depthStencilAttachment
      });
    }
    destroyFBO(collisionGroup) {
      const fbo = this.collisionFBOs[collisionGroup];
      fbo.colorAttachments[0]?.destroy();
      fbo.depthStencilAttachment?.destroy();
      fbo.destroy();
      delete this.collisionFBOs[collisionGroup];
    }
  };

  // ../extensions/src/collision-filter/collision-filter-extension.ts
  var defaultProps37 = {
    getCollisionPriority: { type: "accessor", value: 0 },
    collisionEnabled: true,
    collisionGroup: { type: "string", value: "default" },
    collisionTestProps: {}
  };
  var CollisionFilterExtension = class extends LayerExtension {
    getShaders() {
      return { modules: [shader_module_default2] };
    }
    draw({ uniforms, context, moduleParameters }) {
      const { collisionEnabled } = this.props;
      const { collisionFBO, drawToCollisionMap } = moduleParameters;
      const enabled = collisionEnabled && Boolean(collisionFBO);
      uniforms.collision_enabled = enabled;
      if (drawToCollisionMap) {
        this.props = this.clone(this.props.collisionTestProps).props;
      }
    }
    initializeState(context, extension) {
      if (this.getAttributeManager() === null) {
        return;
      }
      this.context.deck?._addDefaultEffect(new CollisionFilterEffect());
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        collisionPriorities: {
          size: 1,
          accessor: "getCollisionPriority",
          shaderAttributes: {
            collisionPriorities: { divisor: 0 },
            instanceCollisionPriorities: { divisor: 1 }
          }
        }
      });
    }
    getNeedsPickingBuffer() {
      return this.props.collisionEnabled;
    }
  };
  CollisionFilterExtension.defaultProps = defaultProps37;
  CollisionFilterExtension.extensionName = "CollisionFilterExtension";

  // ../extensions/src/mask/shader-module.ts
  var vs12 = glsl`
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`;
  var fs9 = glsl`
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
  if (!mask_enabled) {
    return true;
  }
  vec4 maskColor = texture(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask_channel == 0) {
    maskValue = maskColor.r;
  } else if (mask_channel == 1) {
    maskValue = maskColor.g;
  } else if (mask_channel == 2) {
    maskValue = maskColor.b;
  } else if (mask_channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask_inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`;
  var inject5 = {
    "vs:#decl": glsl`
out vec2 mask_texCoords;
`,
    "vs:#main-end": glsl`
   vec4 mask_common_position;
   if (mask_maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`,
    "fs:#decl": glsl`
in vec2 mask_texCoords;
`,
    "fs:#main-start": glsl`
  if (mask_enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // fragColor = vec4(mask_texCoords, 0.0, 1.0);
    fragColor = texture(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`
  };
  var getMaskUniforms = (opts) => {
    if (opts && "maskMap" in opts) {
      return {
        mask_texture: opts.maskMap
      };
    }
    return {};
  };
  var shader_module_default3 = {
    name: "mask",
    dependencies: [project_default],
    vs: vs12,
    fs: fs9,
    inject: inject5,
    getUniforms: getMaskUniforms
  };

  // ../extensions/src/mask/mask-pass.ts
  var MASK_BLENDING = {
    blendColorOperation: "subtract",
    blendColorSrcFactor: "zero",
    blendColorDstFactor: "one",
    blendAlphaOperation: "subtract",
    blendAlphaSrcFactor: "zero",
    blendAlphaDstFactor: "one"
  };
  var MaskPass = class extends LayersPass {
    constructor(device, props) {
      super(device, props);
      const { mapSize = 2048 } = props;
      this.maskMap = device.createTexture({
        format: "rgba8unorm",
        width: mapSize,
        height: mapSize,
        sampler: {
          minFilter: "linear",
          magFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        }
      });
      this.fbo = device.createFramebuffer({
        id: "maskmap",
        width: mapSize,
        height: mapSize,
        colorAttachments: [this.maskMap]
      });
    }
    render(options) {
      const colorMask = 2 ** options.channel;
      const clearColor = [255, 255, 255, 255];
      super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: "mask" });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: true,
        depthTest: false,
        ...MASK_BLENDING
      };
    }
    shouldDrawLayer(layer) {
      return layer.props.operation.includes("mask");
    }
    delete() {
      this.fbo.delete();
      this.maskMap.delete();
    }
  };

  // ../extensions/src/utils/projection-utils.ts
  function joinLayerBounds(layers, viewport) {
    const bounds = [Infinity, Infinity, -Infinity, -Infinity];
    for (const layer of layers) {
      const layerBounds = layer.getBounds();
      if (layerBounds) {
        const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });
        const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });
        bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
        bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
        bounds[2] = Math.max(bounds[2], topRightCommon[0]);
        bounds[3] = Math.max(bounds[3], topRightCommon[1]);
      }
    }
    if (Number.isFinite(bounds[0])) {
      return bounds;
    }
    return null;
  }
  var MAX_VIEWPORT_SIZE = 2048;
  function makeViewport(opts) {
    const { bounds, viewport, border = 0 } = opts;
    const { isGeospatial } = viewport;
    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
      return null;
    }
    const centerWorld = viewport.unprojectPosition([
      (bounds[0] + bounds[2]) / 2,
      (bounds[1] + bounds[3]) / 2,
      0
    ]);
    let { width, height, zoom } = opts;
    if (zoom === void 0) {
      width = width - border * 2;
      height = height - border * 2;
      const scale7 = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
      zoom = Math.min(Math.log2(scale7), 20);
    } else if (!width || !height) {
      const scale7 = 2 ** zoom;
      width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale7);
      height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale7);
      const maxSize = MAX_VIEWPORT_SIZE - border * 2;
      if (width > maxSize || height > maxSize) {
        const r3 = maxSize / Math.max(width, height);
        width = Math.round(width * r3);
        height = Math.round(height * r3);
        zoom += Math.log2(r3);
      }
    }
    return isGeospatial ? new WebMercatorViewport2({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      longitude: centerWorld[0],
      latitude: centerWorld[1],
      zoom,
      orthographic: true
    }) : new OrthographicViewport({
      id: viewport.id,
      x: border,
      y: border,
      width,
      height,
      target: centerWorld,
      zoom,
      flipY: false
    });
  }
  function getViewportBounds(viewport, zRange) {
    let viewportBoundsWorld;
    if (zRange && zRange.length === 2) {
      const [minZ, maxZ] = zRange;
      const bounds0 = viewport.getBounds({ z: minZ });
      const bounds1 = viewport.getBounds({ z: maxZ });
      viewportBoundsWorld = [
        Math.min(bounds0[0], bounds1[0]),
        Math.min(bounds0[1], bounds1[1]),
        Math.max(bounds0[2], bounds1[2]),
        Math.max(bounds0[3], bounds1[3])
      ];
    } else {
      viewportBoundsWorld = viewport.getBounds();
    }
    const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
    const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
    return [
      viewportBottomLeftCommon[0],
      viewportBottomLeftCommon[1],
      viewportTopRightCommon[0],
      viewportTopRightCommon[1]
    ];
  }
  function getRenderBounds(layerBounds, viewport, zRange) {
    if (!layerBounds) {
      return [0, 0, 1, 1];
    }
    const viewportBounds = getViewportBounds(viewport, zRange);
    const paddedBounds = doubleBounds(viewportBounds);
    if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
      return layerBounds;
    }
    return [
      Math.max(layerBounds[0], paddedBounds[0]),
      Math.max(layerBounds[1], paddedBounds[1]),
      Math.min(layerBounds[2], paddedBounds[2]),
      Math.min(layerBounds[3], paddedBounds[3])
    ];
  }
  function doubleBounds(bounds) {
    const dx = bounds[2] - bounds[0];
    const dy = bounds[3] - bounds[1];
    const centerX = (bounds[0] + bounds[2]) / 2;
    const centerY = (bounds[1] + bounds[3]) / 2;
    return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
  }

  // ../extensions/src/mask/mask-effect.ts
  var MaskEffect = class {
    constructor() {
      this.id = "mask-effect";
      this.props = null;
      this.useInPicking = true;
      this.order = 0;
      this.channels = [];
      this.masks = null;
    }
    setup({ device }) {
      this.dummyMaskMap = device.createTexture({
        width: 1,
        height: 1
      });
      this.maskPass = new MaskPass(device, { id: "default-mask" });
      this.maskMap = this.maskPass.maskMap;
    }
    preRender({
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views,
      isPicking
    }) {
      let didRender = false;
      if (isPicking) {
        return { didRender };
      }
      const maskLayers = layers.filter((l3) => l3.props.visible && l3.props.operation.includes("mask"));
      if (maskLayers.length === 0) {
        this.masks = null;
        this.channels.length = 0;
        return { didRender };
      }
      this.masks = {};
      const channelMap = this._sortMaskChannels(maskLayers);
      const viewport = viewports[0];
      const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
      if (viewport.resolution !== void 0) {
        log_default.warn("MaskExtension is not supported in GlobeView")();
        return { didRender };
      }
      for (const maskId in channelMap) {
        const result = this._renderChannel(channelMap[maskId], {
          layerFilter,
          onViewportActive,
          views,
          viewport,
          viewportChanged
        });
        didRender ||= result;
      }
      return { didRender };
    }
    _renderChannel(channelInfo, {
      layerFilter,
      onViewportActive,
      views,
      viewport,
      viewportChanged
    }) {
      let didRender = false;
      const oldChannelInfo = this.channels[channelInfo.index];
      if (!oldChannelInfo) {
        return didRender;
      }
      const maskChanged = channelInfo === oldChannelInfo || channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some(
        (layer, i5) => layer !== oldChannelInfo.layers[i5] || layer.props.transitions
      ) || channelInfo.layerBounds.some((b2, i5) => b2 !== oldChannelInfo.layerBounds[i5]);
      channelInfo.bounds = oldChannelInfo.bounds;
      channelInfo.maskBounds = oldChannelInfo.maskBounds;
      this.channels[channelInfo.index] = channelInfo;
      if (maskChanged || viewportChanged) {
        this.lastViewport = viewport;
        const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
        channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
        if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
          const { maskPass, maskMap } = this;
          const maskViewport = layerBounds && makeViewport({
            bounds: channelInfo.bounds,
            viewport,
            width: maskMap.width,
            height: maskMap.height,
            border: 1
          });
          channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
          maskPass.render({
            pass: "mask",
            channel: channelInfo.index,
            layers: channelInfo.layers,
            layerFilter,
            viewports: maskViewport ? [maskViewport] : [],
            onViewportActive,
            views,
            moduleParameters: {
              devicePixelRatio: 1
            }
          });
          didRender = true;
        }
      }
      this.masks[channelInfo.id] = {
        index: channelInfo.index,
        bounds: channelInfo.maskBounds,
        coordinateOrigin: channelInfo.coordinateOrigin,
        coordinateSystem: channelInfo.coordinateSystem
      };
      return didRender;
    }
    _sortMaskChannels(maskLayers) {
      const channelMap = {};
      let channelCount = 0;
      for (const layer of maskLayers) {
        const { id } = layer.root;
        let channelInfo = channelMap[id];
        if (!channelInfo) {
          if (++channelCount > 4) {
            log_default.warn("Too many mask layers. The max supported is 4")();
            continue;
          }
          channelInfo = {
            id,
            index: this.channels.findIndex((c2) => c2?.id === id),
            layers: [],
            layerBounds: [],
            coordinateOrigin: layer.root.props.coordinateOrigin,
            coordinateSystem: layer.root.props.coordinateSystem
          };
          channelMap[id] = channelInfo;
        }
        channelInfo.layers.push(layer);
        channelInfo.layerBounds.push(layer.getBounds());
      }
      for (let i5 = 0; i5 < 4; i5++) {
        const channelInfo = this.channels[i5];
        if (!channelInfo || !(channelInfo.id in channelMap)) {
          this.channels[i5] = null;
        }
      }
      for (const maskId in channelMap) {
        const channelInfo = channelMap[maskId];
        if (channelInfo.index < 0) {
          channelInfo.index = this.channels.findIndex((c2) => !c2);
          this.channels[channelInfo.index] = channelInfo;
        }
      }
      return channelMap;
    }
    getModuleParameters() {
      return {
        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
        maskChannels: this.masks
      };
    }
    cleanup() {
      if (this.dummyMaskMap) {
        this.dummyMaskMap.delete();
        this.dummyMaskMap = void 0;
      }
      if (this.maskPass) {
        this.maskPass.delete();
        this.maskPass = void 0;
        this.maskMap = void 0;
      }
      this.lastViewport = void 0;
      this.masks = null;
      this.channels.length = 0;
    }
  };

  // ../extensions/src/mask/mask-extension.ts
  var defaultProps38 = {
    maskId: "",
    maskByInstance: void 0,
    maskInverted: false
  };
  var MaskExtension = class extends LayerExtension {
    initializeState() {
      this.context.deck?._addDefaultEffect(new MaskEffect());
    }
    getShaders() {
      let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
      if (this.props.maskByInstance !== void 0) {
        maskByInstance = Boolean(this.props.maskByInstance);
      }
      this.state.maskByInstance = maskByInstance;
      return {
        modules: [shader_module_default3]
      };
    }
    draw({ uniforms, context, moduleParameters }) {
      uniforms.mask_maskByInstance = this.state.maskByInstance;
      const { maskId, maskInverted } = this.props;
      const { maskChannels } = moduleParameters;
      const { viewport } = context;
      if (maskChannels && maskChannels[maskId]) {
        const { index: index2, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];
        let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];
        uniforms.mask_enabled = true;
        uniforms.mask_channel = index2;
        uniforms.mask_inverted = maskInverted;
        if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
          fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
        }
        const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };
        const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
        const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
        uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];
      } else {
        if (maskId) {
          log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
        }
        uniforms.mask_enabled = false;
      }
    }
  };
  MaskExtension.defaultProps = defaultProps38;
  MaskExtension.extensionName = "MaskExtension";

  // ../extensions/src/terrain/shader-module.ts
  var TERRAIN_MODE = {
    NONE: 0,
    WRITE_HEIGHT_MAP: 1,
    USE_HEIGHT_MAP: 2,
    USE_COVER: 3,
    USE_COVER_ONLY: 4,
    SKIP: 5
  };
  var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
  var terrainModule = {
    name: "terrain",
    dependencies: [project_default],
    inject: {
      "vs:#decl": glsl`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
out vec3 commonPos;
` + TERRAIN_MODE_CONSTANTS,
      "vs:#main-start": glsl`
if (terrain_mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`,
      "vs:DECKGL_FILTER_GL_POSITION": glsl`
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `,
      "fs:#decl": glsl`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
in vec3 commonPos;
` + TERRAIN_MODE_CONSTANTS,
      "fs:#main-start": glsl`
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `,
      "fs:DECKGL_FILTER_COLOR": glsl`
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
  vec4 pixel = texture(terrain_map, texCoords);
  if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `
    },
    getUniforms: (opts = {}, uniforms) => {
      if ("dummyHeightMap" in opts) {
        const {
          drawToTerrainHeightMap,
          heightMap,
          heightMapBounds,
          dummyHeightMap,
          terrainCover,
          useTerrainHeightMap,
          terrainSkipRender
        } = opts;
        const { project_uCommonOrigin } = uniforms;
        let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
        let sampler = dummyHeightMap;
        let bounds = null;
        if (drawToTerrainHeightMap) {
          mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
          bounds = heightMapBounds;
        } else if (useTerrainHeightMap && heightMap) {
          mode = TERRAIN_MODE.USE_HEIGHT_MAP;
          sampler = heightMap;
          bounds = heightMapBounds;
        } else if (terrainCover) {
          const isPicking = opts.picking?.isActive;
          const fbo = isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
          sampler = fbo?.colorAttachments[0].texture;
          if (isPicking) {
            mode = TERRAIN_MODE.SKIP;
          }
          if (sampler) {
            mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
            bounds = terrainCover.bounds;
          } else {
            sampler = dummyHeightMap;
          }
        }
        return {
          terrain_mode: mode,
          terrain_map: sampler,
          terrain_bounds: bounds ? [
            bounds[0] - project_uCommonOrigin[0],
            bounds[1] - project_uCommonOrigin[1],
            bounds[2] - bounds[0],
            bounds[3] - bounds[1]
          ] : [0, 0, 0, 0]
        };
      }
      return null;
    }
  };

  // ../extensions/src/terrain/utils.ts
  function createRenderTarget(device, opts) {
    return device.createFramebuffer({
      id: opts.id,
      colorAttachments: [
        device.createTexture({
          id: opts.id,
          ...opts.float && {
            format: "rgba32float",
            type: GLEnum.FLOAT
          },
          mipmaps: false,
          sampler: opts.interpolate === false ? {
            minFilter: "nearest",
            magFilter: "nearest"
          } : {
            minFilter: "linear",
            magFilter: "linear"
          }
        })
      ]
    });
  }

  // ../extensions/src/terrain/terrain-cover.ts
  var TerrainCover = class {
    constructor(targetLayer) {
      this.isDirty = true;
      this.renderViewport = null;
      this.bounds = null;
      this.layers = [];
      this.targetBounds = null;
      this.targetBoundsCommon = null;
      this.targetLayer = targetLayer;
      this.tile = getTile(targetLayer);
    }
    get id() {
      return this.targetLayer.id;
    }
    get isActive() {
      return Boolean(this.targetLayer.getCurrentLayer());
    }
    shouldUpdate({
      targetLayer,
      viewport,
      layers,
      layerNeedsRedraw
    }) {
      if (targetLayer) {
        this.targetLayer = targetLayer;
      }
      const sizeChanged = viewport ? this._updateViewport(viewport) : false;
      let layersChanged = layers ? this._updateLayers(layers) : false;
      if (layerNeedsRedraw) {
        for (const id of this.layers) {
          if (layerNeedsRedraw[id]) {
            layersChanged = true;
            break;
          }
        }
      }
      return layersChanged || sizeChanged;
    }
    _updateLayers(layers) {
      let needsRedraw = false;
      layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
      if (layers.length !== this.layers.length) {
        needsRedraw = true;
      } else {
        for (let i5 = 0; i5 < layers.length; i5++) {
          const id = layers[i5].id;
          if (id !== this.layers[i5]) {
            needsRedraw = true;
            break;
          }
        }
      }
      if (needsRedraw) {
        this.layers = layers.map((layer) => layer.id);
      }
      return needsRedraw;
    }
    _updateViewport(viewport) {
      const targetLayer = this.targetLayer;
      let shouldRedraw = false;
      if (this.tile && "boundingBox" in this.tile) {
        if (!this.targetBounds) {
          shouldRedraw = true;
          this.targetBounds = this.tile.boundingBox;
          const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
          const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
          this.targetBoundsCommon = [
            bottomLeftCommon[0],
            bottomLeftCommon[1],
            topRightCommon[0],
            topRightCommon[1]
          ];
        }
      } else if (this.targetBounds !== targetLayer.getBounds()) {
        shouldRedraw = true;
        this.targetBounds = targetLayer.getBounds();
        this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
      }
      if (!this.targetBoundsCommon) {
        return false;
      }
      const newZoom = Math.ceil(viewport.zoom + 0.5);
      if (this.tile) {
        this.bounds = this.targetBoundsCommon;
      } else {
        const oldZoom = this.renderViewport?.zoom;
        shouldRedraw = shouldRedraw || newZoom !== oldZoom;
        const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
        const oldBounds = this.bounds;
        shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x3, i5) => x3 !== oldBounds[i5]);
        this.bounds = newBounds;
      }
      if (shouldRedraw) {
        this.renderViewport = makeViewport({
          bounds: this.bounds,
          zoom: newZoom,
          viewport
        });
      }
      return shouldRedraw;
    }
    getRenderFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });
      }
      return this.fbo;
    }
    getPickingFramebuffer() {
      if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
        return null;
      }
      if (!this.pickingFbo) {
        this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {
          id: `${this.id}-picking`,
          interpolate: false
        });
      }
      return this.pickingFbo;
    }
    filterLayers(layers) {
      return layers.filter(({ id }) => this.layers.includes(id));
    }
    delete() {
      const { fbo, pickingFbo } = this;
      if (fbo) {
        fbo.colorAttachments[0].destroy();
        fbo.destroy();
      }
      if (pickingFbo) {
        pickingFbo.colorAttachments[0].destroy();
        pickingFbo.destroy();
      }
    }
  };
  function getIntersectingLayers(sourceTile, layers) {
    return layers.filter((layer) => {
      const tile = getTile(layer);
      if (tile) {
        return intersect2(sourceTile.boundingBox, tile.boundingBox);
      }
      return true;
    });
  }
  function getTile(layer) {
    while (layer) {
      const { tile } = layer.props;
      if (tile) {
        return tile;
      }
      layer = layer.parent;
    }
    return null;
  }
  function intersect2(b1, b2) {
    if (b1 && b2) {
      return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];
    }
    return false;
  }

  // ../extensions/src/terrain/terrain-pass.ts
  var TERRAIN_BLENDING = {
    blendColorOperation: "max",
    blendColorSrcFactor: "one",
    blendColorDstFactor: "one",
    blendAlphaOperation: "max",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one"
  };
  var TerrainPass = class extends LayersPass {
    getRenderableLayers(viewport, opts) {
      const { layers } = opts;
      const result = [];
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
      for (let i5 = 0; i5 < layers.length; i5++) {
        const layer = layers[i5];
        if (!layer.isComposite && drawParamsByIndex[i5].shouldDrawLayer) {
          result.push(layer);
        }
      }
      return result;
    }
    renderHeightMap(heightMap, opts) {
      const target = heightMap.getRenderFramebuffer();
      const viewport = heightMap.renderViewport;
      if (!target || !viewport) {
        return;
      }
      target.resize(viewport);
      this.render({
        ...opts,
        target,
        pass: "terrain-height-map",
        layers: opts.layers,
        viewports: [viewport],
        effects: [],
        clearColor: [0, 0, 0, 0]
      });
    }
    renderTerrainCover(terrainCover, opts) {
      const target = terrainCover.getRenderFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      target.resize(viewport);
      this.render({
        ...opts,
        target,
        pass: `terrain-cover-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport],
        clearColor: [0, 0, 0, 0]
      });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return {
        ...layer.props.parameters,
        blend: true,
        depthTest: false,
        ...layer.props.operation.includes("terrain") && TERRAIN_BLENDING
      };
    }
  };

  // ../extensions/src/terrain/terrain-picking-pass.ts
  var TerrainPickingPass = class extends PickLayersPass {
    constructor() {
      super(...arguments);
      this.drawParameters = {};
    }
    getRenderableLayers(viewport, opts) {
      const { layers } = opts;
      const result = [];
      this.drawParameters = {};
      this._resetColorEncoder(opts.pickZ);
      const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
      for (let i5 = 0; i5 < layers.length; i5++) {
        const layer = layers[i5];
        if (!layer.isComposite && drawParamsByIndex[i5].shouldDrawLayer) {
          result.push(layer);
          this.drawParameters[layer.id] = drawParamsByIndex[i5].layerParameters;
        }
      }
      return result;
    }
    renderTerrainCover(terrainCover, opts) {
      const target = terrainCover.getPickingFramebuffer();
      const viewport = terrainCover.renderViewport;
      if (!target || !viewport) {
        return;
      }
      const layers = terrainCover.filterLayers(opts.layers);
      const terrainLayer = terrainCover.targetLayer;
      if (terrainLayer.props.pickable) {
        layers.unshift(terrainLayer);
      }
      target.resize(viewport);
      this.render({
        ...opts,
        pickingFBO: target,
        pass: `terrain-cover-picking-${terrainCover.id}`,
        layers,
        effects: [],
        viewports: [viewport],
        cullRect: void 0,
        deviceRect: viewport,
        pickZ: false
      });
    }
    getLayerParameters(layer, layerIndex, viewport) {
      let parameters2;
      if (this.drawParameters[layer.id]) {
        parameters2 = this.drawParameters[layer.id];
      } else {
        parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
        parameters2.blend = true;
      }
      return { ...parameters2, depthTest: false };
    }
  };

  // ../extensions/src/terrain/height-map-builder.ts
  var MAP_MAX_SIZE = 2048;
  var HeightMapBuilder = class {
    constructor(device) {
      this.renderViewport = null;
      this.bounds = null;
      this.layers = [];
      this.layersBounds = [];
      this.layersBoundsCommon = null;
      this.lastViewport = null;
      this.device = device;
    }
    static isSupported(device) {
      return device.isTextureFormatRenderable("rgba32float");
    }
    getRenderFramebuffer() {
      if (!this.renderViewport) {
        return null;
      }
      if (!this.fbo) {
        this.fbo = createRenderTarget(this.device, { id: "height-map", float: true });
      }
      return this.fbo;
    }
    shouldUpdate({ layers, viewport }) {
      const layersChanged = layers.length !== this.layers.length || layers.some(
        (layer, i5) => layer !== this.layers[i5] || layer.props.transitions || layer.getBounds() !== this.layersBounds[i5]
      );
      if (layersChanged) {
        this.layers = layers;
        this.layersBounds = layers.map((layer) => layer.getBounds());
        this.layersBoundsCommon = joinLayerBounds(layers, viewport);
      }
      const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
      if (!this.layersBoundsCommon) {
        this.renderViewport = null;
      } else if (layersChanged || viewportChanged) {
        const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
        if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
          this.renderViewport = null;
          return false;
        }
        this.bounds = bounds;
        this.lastViewport = viewport;
        const scale7 = viewport.scale;
        const pixelWidth = (bounds[2] - bounds[0]) * scale7;
        const pixelHeight = (bounds[3] - bounds[1]) * scale7;
        this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
          bounds: [
            viewport.center[0] - 1,
            viewport.center[1] - 1,
            viewport.center[0] + 1,
            viewport.center[1] + 1
          ],
          zoom: viewport.zoom,
          width: Math.min(pixelWidth, MAP_MAX_SIZE),
          height: Math.min(pixelHeight, MAP_MAX_SIZE),
          viewport
        }) : null;
        return true;
      }
      return false;
    }
    delete() {
      if (this.fbo) {
        this.fbo.colorAttachments[0].delete();
        this.fbo.delete();
      }
    }
  };

  // ../extensions/src/terrain/terrain-effect.ts
  var TerrainEffect = class {
    constructor() {
      this.id = "terrain-effect";
      this.props = null;
      this.useInPicking = true;
      this.isPicking = false;
      this.isDrapingEnabled = false;
      this.terrainCovers = /* @__PURE__ */ new Map();
    }
    setup({ device, deck }) {
      this.dummyHeightMap = device.createTexture({
        width: 1,
        height: 1,
        data: new Uint8Array([0, 0, 0, 0])
      });
      this.terrainPass = new TerrainPass(device, { id: "terrain" });
      this.terrainPickingPass = new TerrainPickingPass(device, { id: "terrain-picking" });
      if (HeightMapBuilder.isSupported(device)) {
        this.heightMap = new HeightMapBuilder(device);
      } else {
        log_default.warn("Terrain offset mode is not supported by this browser")();
      }
      deck._addDefaultShaderModule(terrainModule);
    }
    preRender(opts) {
      if (opts.pickZ) {
        this.isDrapingEnabled = false;
        return;
      }
      const { viewports } = opts;
      const isPicking = opts.pass.startsWith("picking");
      this.isPicking = isPicking;
      this.isDrapingEnabled = true;
      const viewport = viewports[0];
      const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(
        viewport,
        opts
      );
      const terrainLayers = layers.filter((l3) => l3.props.operation.includes("terrain"));
      if (terrainLayers.length === 0) {
        return;
      }
      if (!isPicking) {
        const offsetLayers = layers.filter((l3) => l3.state.terrainDrawMode === "offset");
        if (offsetLayers.length > 0) {
          this._updateHeightMap(terrainLayers, viewport, opts);
        }
      }
      const drapeLayers = layers.filter((l3) => l3.state.terrainDrawMode === "drape");
      this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
    }
    getModuleParameters(layer) {
      const { terrainDrawMode } = layer.state;
      return {
        heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,
        heightMapBounds: this.heightMap?.bounds,
        dummyHeightMap: this.dummyHeightMap,
        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
        useTerrainHeightMap: terrainDrawMode === "offset",
        terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
      };
    }
    cleanup({ deck }) {
      if (this.dummyHeightMap) {
        this.dummyHeightMap.delete();
        this.dummyHeightMap = void 0;
      }
      if (this.heightMap) {
        this.heightMap.delete();
        this.heightMap = void 0;
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.delete();
      }
      this.terrainCovers.clear();
      deck._removeDefaultShaderModule(terrainModule);
    }
    _updateHeightMap(terrainLayers, viewport, opts) {
      if (!this.heightMap) {
        return;
      }
      const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });
      if (!shouldUpdate) {
        return;
      }
      this.terrainPass.renderHeightMap(this.heightMap, {
        ...opts,
        layers: terrainLayers,
        moduleParameters: {
          heightMapBounds: this.heightMap.bounds,
          dummyHeightMap: this.dummyHeightMap,
          devicePixelRatio: 1,
          drawToTerrainHeightMap: true
        }
      });
    }
    _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
      const layerNeedsRedraw = {};
      for (const layer of drapeLayers) {
        if (layer.state.terrainCoverNeedsRedraw) {
          layerNeedsRedraw[layer.id] = true;
          layer.state.terrainCoverNeedsRedraw = false;
        }
      }
      for (const terrainCover of this.terrainCovers.values()) {
        terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });
      }
      for (const layer of terrainLayers) {
        this._updateTerrainCover(layer, drapeLayers, viewport, opts);
      }
      if (!this.isPicking) {
        this._pruneTerrainCovers();
      }
    }
    _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
      const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
      let terrainCover = this.terrainCovers.get(terrainLayer.id);
      if (!terrainCover) {
        terrainCover = new TerrainCover(terrainLayer);
        this.terrainCovers.set(terrainLayer.id, terrainCover);
      }
      try {
        const isDirty = terrainCover.shouldUpdate({
          targetLayer: terrainLayer,
          viewport,
          layers: drapeLayers
        });
        if (this.isPicking || terrainCover.isDirty || isDirty) {
          renderPass.renderTerrainCover(terrainCover, {
            ...opts,
            layers: drapeLayers,
            moduleParameters: {
              dummyHeightMap: this.dummyHeightMap,
              terrainSkipRender: false,
              devicePixelRatio: 1
            }
          });
          if (!this.isPicking) {
            terrainCover.isDirty = false;
          }
        }
      } catch (err) {
        terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
      }
    }
    _pruneTerrainCovers() {
      const idsToRemove = [];
      for (const [id, terrainCover] of this.terrainCovers) {
        if (!terrainCover.isActive) {
          idsToRemove.push(id);
        }
      }
      for (const id of idsToRemove) {
        this.terrainCovers.delete(id);
      }
    }
  };

  // ../extensions/src/terrain/terrain-extension.ts
  var defaultProps39 = {
    terrainDrawMode: void 0
  };
  var TerrainExtension = class extends LayerExtension {
    getShaders() {
      return {
        modules: [terrainModule]
      };
    }
    initializeState() {
      this.context.deck?._addDefaultEffect(new TerrainEffect());
    }
    updateState(params) {
      const { props, oldProps } = params;
      if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && props.extruded === oldProps.extruded) {
        return;
      }
      let { terrainDrawMode } = props;
      if (!terrainDrawMode) {
        const is3d = this.props.extruded;
        const attributes = this.getAttributeManager()?.attributes;
        const hasAnchor = attributes && "instancePositions" in attributes;
        terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
      }
      this.setState({ terrainDrawMode });
    }
    onNeedsRedraw() {
      const state = this.state;
      if (state.terrainDrawMode === "drape") {
        state.terrainCoverNeedsRedraw = true;
      }
    }
  };
  TerrainExtension.defaultProps = defaultProps39;
  TerrainExtension.extensionName = "TerrainExtension";

  // ../../node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
  function flatGeojsonToBinary(features, geometryInfo, options) {
    const propArrayTypes = extractNumericPropTypes(features);
    const numericPropKeys = Object.keys(propArrayTypes).filter((k2) => propArrayTypes[k2] !== Array);
    return fillArrays(features, {
      propArrayTypes,
      ...geometryInfo
    }, {
      numericPropKeys: options && options.numericPropKeys || numericPropKeys,
      PositionDataType: options ? options.PositionDataType : Float32Array,
      triangulate: options ? options.triangulate : true
    });
  }
  function extractNumericPropTypes(features) {
    const propArrayTypes = {};
    for (const feature of features) {
      if (feature.properties) {
        for (const key in feature.properties) {
          const val2 = feature.properties[key];
          propArrayTypes[key] = deduceArrayType(val2, propArrayTypes[key]);
        }
      }
    }
    return propArrayTypes;
  }
  function fillArrays(features, geometryInfo, options) {
    const {
      pointPositionsCount,
      pointFeaturesCount,
      linePositionsCount,
      linePathsCount,
      lineFeaturesCount,
      polygonPositionsCount,
      polygonObjectsCount,
      polygonRingsCount,
      polygonFeaturesCount,
      propArrayTypes,
      coordLength
    } = geometryInfo;
    const {
      numericPropKeys = [],
      PositionDataType = Float32Array,
      triangulate = true
    } = options;
    const hasGlobalId = features[0] && "id" in features[0];
    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
    const points = {
      type: "Point",
      positions: new PositionDataType(pointPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
      featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const lines = {
      type: "LineString",
      pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
      positions: new PositionDataType(linePositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
      featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    const polygons = {
      type: "Polygon",
      polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
      primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
      positions: new PositionDataType(polygonPositionsCount * coordLength),
      globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
      featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
      numericProps: {},
      properties: [],
      fields: []
    };
    if (triangulate) {
      polygons.triangles = [];
    }
    for (const object of [points, lines, polygons]) {
      for (const propName of numericPropKeys) {
        const T2 = propArrayTypes[propName];
        object.numericProps[propName] = new T2(object.positions.length / coordLength);
      }
    }
    lines.pathIndices[linePathsCount] = linePositionsCount;
    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
    const indexMap = {
      pointPosition: 0,
      pointFeature: 0,
      linePosition: 0,
      linePath: 0,
      lineFeature: 0,
      polygonPosition: 0,
      polygonObject: 0,
      polygonRing: 0,
      polygonFeature: 0,
      feature: 0
    };
    for (const feature of features) {
      const geometry = feature.geometry;
      const properties = feature.properties || {};
      switch (geometry.type) {
        case "Point":
          handlePoint(geometry, points, indexMap, coordLength, properties);
          points.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            points.fields.push({
              id: feature.id
            });
          }
          indexMap.pointFeature++;
          break;
        case "LineString":
          handleLineString(geometry, lines, indexMap, coordLength, properties);
          lines.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            lines.fields.push({
              id: feature.id
            });
          }
          indexMap.lineFeature++;
          break;
        case "Polygon":
          handlePolygon(geometry, polygons, indexMap, coordLength, properties);
          polygons.properties.push(keepStringProperties(properties, numericPropKeys));
          if (hasGlobalId) {
            polygons.fields.push({
              id: feature.id
            });
          }
          indexMap.polygonFeature++;
          break;
        default:
          throw new Error("Invalid geometry type");
      }
      indexMap.feature++;
    }
    return makeAccessorObjects(points, lines, polygons, coordLength);
  }
  function handlePoint(geometry, points, indexMap, coordLength, properties) {
    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
    indexMap.pointPosition += nPositions;
  }
  function handleLineString(geometry, lines, indexMap, coordLength, properties) {
    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
    for (let i5 = 0, il = geometry.indices.length; i5 < il; ++i5) {
      const start = geometry.indices[i5];
      const end = i5 === il - 1 ? geometry.data.length : geometry.indices[i5 + 1];
      lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
      indexMap.linePosition += (end - start) / coordLength;
    }
  }
  function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
    const nPositions = geometry.data.length / coordLength;
    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
    for (let l3 = 0, ll = geometry.indices.length; l3 < ll; ++l3) {
      const startPosition = indexMap.polygonPosition;
      polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
      const areas = geometry.areas[l3];
      const indices = geometry.indices[l3];
      const nextIndices = geometry.indices[l3 + 1];
      for (let i5 = 0, il = indices.length; i5 < il; ++i5) {
        const start = indices[i5];
        const end = i5 === il - 1 ? nextIndices === void 0 ? geometry.data.length : nextIndices[0] : indices[i5 + 1];
        polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
        indexMap.polygonPosition += (end - start) / coordLength;
      }
      const endPosition = indexMap.polygonPosition;
      triangulatePolygon(polygons, areas, indices, {
        startPosition,
        endPosition,
        coordLength
      });
    }
  }
  function triangulatePolygon(polygons, areas, indices, _ref) {
    let {
      startPosition,
      endPosition,
      coordLength
    } = _ref;
    if (!polygons.triangles) {
      return;
    }
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.subarray(start, end);
    const offset = indices[0];
    const holes = indices.slice(1).map((n3) => (n3 - offset) / coordLength);
    const triangles = earcut(polygonPositions, holes, coordLength, areas);
    for (let t3 = 0, tl = triangles.length; t3 < tl; ++t3) {
      polygons.triangles.push(startPosition + triangles[t3]);
    }
  }
  function wrapProps(obj, size) {
    const returnObj = {};
    for (const key in obj) {
      returnObj[key] = {
        value: obj[key],
        size
      };
    }
    return returnObj;
  }
  function makeAccessorObjects(points, lines, polygons, coordLength) {
    const binaryFeatures = {
      shape: "binary-feature-collection",
      points: {
        ...points,
        positions: {
          value: points.positions,
          size: coordLength
        },
        globalFeatureIds: {
          value: points.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: points.featureIds,
          size: 1
        },
        numericProps: wrapProps(points.numericProps, 1)
      },
      lines: {
        ...lines,
        positions: {
          value: lines.positions,
          size: coordLength
        },
        pathIndices: {
          value: lines.pathIndices,
          size: 1
        },
        globalFeatureIds: {
          value: lines.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: lines.featureIds,
          size: 1
        },
        numericProps: wrapProps(lines.numericProps, 1)
      },
      polygons: {
        ...polygons,
        positions: {
          value: polygons.positions,
          size: coordLength
        },
        polygonIndices: {
          value: polygons.polygonIndices,
          size: 1
        },
        primitivePolygonIndices: {
          value: polygons.primitivePolygonIndices,
          size: 1
        },
        globalFeatureIds: {
          value: polygons.globalFeatureIds,
          size: 1
        },
        featureIds: {
          value: polygons.featureIds,
          size: 1
        },
        numericProps: wrapProps(polygons.numericProps, 1)
      }
    };
    if (binaryFeatures.polygons && polygons.triangles) {
      binaryFeatures.polygons.triangles = {
        value: new Uint32Array(polygons.triangles),
        size: 1
      };
    }
    return binaryFeatures;
  }
  function fillNumericProperties(object, properties, index2, length6) {
    for (const numericPropName in object.numericProps) {
      if (numericPropName in properties) {
        const value = properties[numericPropName];
        object.numericProps[numericPropName].fill(value, index2, index2 + length6);
      }
    }
  }
  function keepStringProperties(properties, numericKeys) {
    const props = {};
    for (const key in properties) {
      if (!numericKeys.includes(key)) {
        props[key] = properties[key];
      }
    }
    return props;
  }
  function deduceArrayType(x3, constructor) {
    if (constructor === Array || !Number.isFinite(x3)) {
      return Array;
    }
    return constructor === Float64Array || Math.fround(x3) !== x3 ? Float64Array : Float32Array;
  }

  // ../../node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
  function binaryToGeojson(data, options) {
    const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;
    if (globalFeatureId !== void 0) {
      return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);
  }
  function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data2 of dataArray) {
      let lastIndex = 0;
      let lastValue = data2.featureIds.value[0];
      for (let i5 = 0; i5 < data2.featureIds.value.length; i5++) {
        const currValue = data2.featureIds.value[i5];
        if (currValue === lastValue) {
          continue;
        }
        if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
          return parseFeature(data2, lastIndex, i5);
        }
        lastIndex = i5;
        lastValue = currValue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, data2.featureIds.value.length);
      }
    }
    throw new Error(`featureId:${globalFeatureId} not found`);
  }
  function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
  }
  function binaryToGeometry(data, startIndex, endIndex) {
    switch (data.type) {
      case "Point":
        return pointToGeoJson(data, startIndex, endIndex);
      case "LineString":
        return lineStringToGeoJson(data, startIndex, endIndex);
      case "Polygon":
        return polygonToGeoJson(data, startIndex, endIndex);
      default:
        const unexpectedInput = data;
        throw new Error(`Unsupported geometry type: ${unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type}`);
    }
  }
  function normalizeInput(data, type) {
    const features = [];
    if (data.points) {
      data.points.type = "Point";
      features.push(data.points);
    }
    if (data.lines) {
      data.lines.type = "LineString";
      features.push(data.lines);
    }
    if (data.polygons) {
      data.polygons.type = "Polygon";
      features.push(data.polygons);
    }
    return features;
  }
  function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray) {
      if (data.featureIds.value.length === 0) {
        continue;
      }
      let lastIndex = 0;
      let lastValue = data.featureIds.value[0];
      for (let i5 = 0; i5 < data.featureIds.value.length; i5++) {
        const currValue = data.featureIds.value[i5];
        if (currValue === lastValue) {
          continue;
        }
        features.push(parseFeature(data, lastIndex, i5));
        lastIndex = i5;
        lastValue = currValue;
      }
      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
  }
  function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return {
      type: "Feature",
      geometry,
      properties,
      ...fields
    };
  }
  function parseFields(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    return data.fields && data.fields[data.featureIds.value[startIndex]];
  }
  function parseProperties(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    let endIndex = arguments.length > 2 ? arguments[2] : void 0;
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for (const key in data.numericProps) {
      properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
  }
  function polygonToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const polygonIndices = data.polygonIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const multi = polygonIndices.length > 2;
    if (!multi) {
      const coordinates2 = [];
      for (let i5 = 0; i5 < primitivePolygonIndices.length - 1; i5++) {
        const startRingIndex = primitivePolygonIndices[i5];
        const endRingIndex = primitivePolygonIndices[i5 + 1];
        const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
        coordinates2.push(ringCoordinates);
      }
      return {
        type: "Polygon",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i5 = 0; i5 < polygonIndices.length - 1; i5++) {
      const startPolygonIndex = polygonIndices[i5];
      const endPolygonIndex = polygonIndices[i5 + 1];
      const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
      coordinates.push(polygonCoordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates
    };
  }
  function lineStringToGeoJson(data) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -Infinity;
    let endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
    const {
      positions
    } = data;
    const pathIndices = data.pathIndices.value.filter((x3) => x3 >= startIndex && x3 <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
      const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
      return {
        type: "LineString",
        coordinates: coordinates2
      };
    }
    const coordinates = [];
    for (let i5 = 0; i5 < pathIndices.length - 1; i5++) {
      const ringCoordinates = ringToGeoJson(positions, pathIndices[i5], pathIndices[i5 + 1]);
      coordinates.push(ringCoordinates);
    }
    return {
      type: "MultiLineString",
      coordinates
    };
  }
  function pointToGeoJson(data, startIndex, endIndex) {
    const {
      positions
    } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
      return {
        type: "MultiPoint",
        coordinates
      };
    }
    return {
      type: "Point",
      coordinates: coordinates[0]
    };
  }
  function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for (let j2 = startIndex; j2 < endIndex; j2++) {
      const coord = Array();
      for (let k2 = j2 * positions.size; k2 < (j2 + 1) * positions.size; k2++) {
        coord.push(Number(positions.value[k2]));
      }
      ringCoordinates.push(coord);
    }
    return ringCoordinates;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
  var import_pbf = __toESM(require_pbf(), 1);

  // ../../node_modules/@loaders.gl/mvt/dist/helpers/mapbox-util-functions.js
  function classifyRings(rings) {
    const len4 = rings.length;
    if (len4 <= 1)
      return [rings];
    const polygons = [];
    let polygon;
    let ccw;
    for (let i5 = 0; i5 < len4; i5++) {
      const area2 = signedArea(rings[i5]);
      if (area2 === 0)
        continue;
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon)
          polygons.push(polygon);
        polygon = [rings[i5]];
      } else if (polygon)
        polygon.push(rings[i5]);
    }
    if (polygon)
      polygons.push(polygon);
    return polygons;
  }
  function signedArea(ring) {
    let sum = 0;
    for (let i5 = 0, j2 = ring.length - 1, p1, p22; i5 < ring.length; j2 = i5++) {
      p1 = ring[i5];
      p22 = ring[j2];
      sum += (p22[0] - p1[0]) * (p1[1] + p22[1]);
    }
    return sum;
  }
  function readFeature(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-feature.js
  var VectorTileFeature = class {
    static get types() {
      return ["Unknown", "Point", "LineString", "Polygon"];
    }
    constructor(pbf, end, extent, keys, values) {
      this.properties = void 0;
      this.extent = void 0;
      this.type = void 0;
      this.id = void 0;
      this._pbf = void 0;
      this._geometry = void 0;
      this._keys = void 0;
      this._values = void 0;
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      pbf.readFields(readFeature, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length6 = 0;
      let x3 = 0;
      let y3 = 0;
      const lines = [];
      let line;
      while (pbf.pos < end) {
        if (length6 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length6 = cmdLen2 >> 3;
        }
        length6--;
        if (cmd2 === 1 || cmd2 === 2) {
          x3 += pbf.readSVarint();
          y3 += pbf.readSVarint();
          if (cmd2 === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x3, y3]);
        } else if (cmd2 === 7) {
          if (line) {
            line.push(line[0].slice());
          }
        } else {
          throw new Error(`unknown command ${cmd2}`);
        }
      }
      if (line)
        lines.push(line);
      return lines;
    }
    bbox() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      const end = pbf.readVarint() + pbf.pos;
      let cmd2 = 1;
      let length6 = 0;
      let x3 = 0;
      let y3 = 0;
      let x1 = Infinity;
      let x22 = -Infinity;
      let y1 = Infinity;
      let y22 = -Infinity;
      while (pbf.pos < end) {
        if (length6 <= 0) {
          const cmdLen2 = pbf.readVarint();
          cmd2 = cmdLen2 & 7;
          length6 = cmdLen2 >> 3;
        }
        length6--;
        if (cmd2 === 1 || cmd2 === 2) {
          x3 += pbf.readSVarint();
          y3 += pbf.readSVarint();
          if (x3 < x1)
            x1 = x3;
          if (x3 > x22)
            x22 = x3;
          if (y3 < y1)
            y1 = y3;
          if (y3 > y22)
            y22 = y3;
        } else if (cmd2 !== 7) {
          throw new Error(`unknown command ${cmd2}`);
        }
      }
      return [x1, y1, x22, y22];
    }
    _toGeoJSON(transform2) {
      let coords = this.loadGeometry();
      let type = VectorTileFeature.types[this.type];
      let i5;
      let j2;
      switch (this.type) {
        case 1:
          const points = [];
          for (i5 = 0; i5 < coords.length; i5++) {
            points[i5] = coords[i5][0];
          }
          coords = points;
          transform2(coords, this);
          break;
        case 2:
          for (i5 = 0; i5 < coords.length; i5++) {
            transform2(coords[i5], this);
          }
          break;
        case 3:
          coords = classifyRings(coords);
          for (i5 = 0; i5 < coords.length; i5++) {
            for (j2 = 0; j2 < coords[i5].length; j2++) {
              transform2(coords[i5][j2], this);
            }
          }
          break;
      }
      if (coords.length === 1) {
        coords = coords[0];
      } else {
        type = `Multi${type}`;
      }
      const result = {
        type: "Feature",
        geometry: {
          type,
          coordinates: coords
        },
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toGeoJSON(options) {
      if (typeof options === "function") {
        return this._toGeoJSON(options);
      }
      const {
        x: x3,
        y: y3,
        z: z2
      } = options;
      const size = this.extent * Math.pow(2, z2);
      const x0 = this.extent * x3;
      const y0 = this.extent * y3;
      function project2(line) {
        for (let j2 = 0; j2 < line.length; j2++) {
          const p3 = line[j2];
          p3[0] = (p3[0] + x0) * 360 / size - 180;
          const y22 = 180 - (p3[1] + y0) * 360 / size;
          p3[1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
        }
      }
      return this._toGeoJSON(project2);
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile-layer.js
  var VectorTileLayer = class {
    constructor(pbf, end) {
      this.version = void 0;
      this.name = void 0;
      this.extent = void 0;
      this.length = void 0;
      this._pbf = void 0;
      this._keys = void 0;
      this._values = void 0;
      this._features = void 0;
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer, this, end);
      this.length = this._features.length;
    }
    feature(i5) {
      if (i5 < 0 || i5 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i5];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
    }
  };
  function readLayer(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage(pbf));
    }
  }
  function readValueMessage(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/mapbox-vector-tile/vector-tile.js
  var VectorTile = class {
    constructor(pbf, end) {
      this.layers = void 0;
      this.layers = pbf.readFields(readTile, {}, end);
    }
  };
  function readTile(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/helpers/binary-util-functions.js
  function classifyRings2(geom) {
    const len4 = geom.indices.length;
    const type = "Polygon";
    if (len4 <= 1) {
      return {
        type,
        data: geom.data,
        areas: [[getPolygonSignedArea(geom.data)]],
        indices: [geom.indices]
      };
    }
    const areas = [];
    const polygons = [];
    let ringAreas = [];
    let polygon = [];
    let ccw;
    let offset = 0;
    for (let endIndex, i5 = 0, startIndex; i5 < len4; i5++) {
      startIndex = geom.indices[i5] - offset;
      endIndex = geom.indices[i5 + 1] - offset || geom.data.length;
      const shape = geom.data.slice(startIndex, endIndex);
      const area2 = getPolygonSignedArea(shape);
      if (area2 === 0) {
        const before = geom.data.slice(0, startIndex);
        const after = geom.data.slice(endIndex);
        geom.data = before.concat(after);
        offset += endIndex - startIndex;
        continue;
      }
      if (ccw === void 0)
        ccw = area2 < 0;
      if (ccw === area2 < 0) {
        if (polygon.length) {
          areas.push(ringAreas);
          polygons.push(polygon);
        }
        polygon = [startIndex];
        ringAreas = [area2];
      } else {
        ringAreas.push(area2);
        polygon.push(startIndex);
      }
    }
    if (ringAreas)
      areas.push(ringAreas);
    if (polygon.length)
      polygons.push(polygon);
    return {
      type,
      areas,
      indices: polygons,
      data: geom.data
    };
  }
  function project(data, x0, y0, size) {
    for (let j2 = 0, jl = data.length; j2 < jl; j2 += 2) {
      data[j2] = (data[j2] + x0) * 360 / size - 180;
      const y22 = 180 - (data[j2 + 1] + y0) * 360 / size;
      data[j2 + 1] = 360 / Math.PI * Math.atan(Math.exp(y22 * Math.PI / 180)) - 90;
    }
  }
  function readFeature2(tag, feature, pbf) {
    if (feature && pbf) {
      if (tag === 1)
        feature.id = pbf.readVarint();
      else if (tag === 2)
        readTag2(pbf, feature);
      else if (tag === 3)
        feature.type = pbf.readVarint();
      else if (tag === 4)
        feature._geometry = pbf.pos;
    }
  }
  function readTag2(pbf, feature) {
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const key = feature._keys[pbf.readVarint()];
      const value = feature._values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-feature.js
  var endPos;
  var cmd;
  var cmdLen;
  var length5;
  var x;
  var y;
  var i2;
  var VectorTileFeature2 = class {
    constructor(pbf, end, extent, keys, values, geometryInfo) {
      this.properties = void 0;
      this.extent = void 0;
      this.type = void 0;
      this.id = void 0;
      this._pbf = void 0;
      this._geometry = void 0;
      this._keys = void 0;
      this._values = void 0;
      this._geometryInfo = void 0;
      this.properties = {};
      this.extent = extent;
      this.type = 0;
      this.id = null;
      this._pbf = pbf;
      this._geometry = -1;
      this._keys = keys;
      this._values = values;
      this._geometryInfo = geometryInfo;
      pbf.readFields(readFeature2, this, end);
    }
    loadGeometry() {
      const pbf = this._pbf;
      pbf.pos = this._geometry;
      endPos = pbf.readVarint() + pbf.pos;
      cmd = 1;
      length5 = 0;
      x = 0;
      y = 0;
      i2 = 0;
      const indices = [];
      const data = [];
      while (pbf.pos < endPos) {
        if (length5 <= 0) {
          cmdLen = pbf.readVarint();
          cmd = cmdLen & 7;
          length5 = cmdLen >> 3;
        }
        length5--;
        if (cmd === 1 || cmd === 2) {
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            indices.push(i2);
          }
          data.push(x, y);
          i2 += 2;
        } else if (cmd === 7) {
          if (i2 > 0) {
            const start = indices[indices.length - 1];
            data.push(data[start], data[start + 1]);
            i2 += 2;
          }
        } else {
          throw new Error(`unknown command ${cmd}`);
        }
      }
      return {
        data,
        indices
      };
    }
    _toBinaryCoordinates(transform2) {
      const geom = this.loadGeometry();
      let geometry;
      transform2(geom.data, this);
      const coordLength = 2;
      switch (this.type) {
        case 1:
          this._geometryInfo.pointFeaturesCount++;
          this._geometryInfo.pointPositionsCount += geom.indices.length;
          geometry = {
            type: "Point",
            ...geom
          };
          break;
        case 2:
          this._geometryInfo.lineFeaturesCount++;
          this._geometryInfo.linePathsCount += geom.indices.length;
          this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
          geometry = {
            type: "LineString",
            ...geom
          };
          break;
        case 3:
          geometry = classifyRings2(geom);
          this._geometryInfo.polygonFeaturesCount++;
          this._geometryInfo.polygonObjectsCount += geometry.indices.length;
          for (const indices of geometry.indices) {
            this._geometryInfo.polygonRingsCount += indices.length;
          }
          this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
          break;
        default:
          throw new Error(`Invalid geometry type: ${this.type}`);
      }
      const result = {
        type: "Feature",
        geometry,
        properties: this.properties
      };
      if (this.id !== null) {
        result.id = this.id;
      }
      return result;
    }
    toBinaryCoordinates(options) {
      if (typeof options === "function") {
        return this._toBinaryCoordinates(options);
      }
      const {
        x: x3,
        y: y3,
        z: z2
      } = options;
      const size = this.extent * Math.pow(2, z2);
      const x0 = this.extent * x3;
      const y0 = this.extent * y3;
      return this._toBinaryCoordinates((data) => project(data, x0, y0, size));
    }
  };

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile-layer.js
  var VectorTileLayer2 = class {
    constructor(pbf, end) {
      this.version = void 0;
      this.name = void 0;
      this.extent = void 0;
      this.length = void 0;
      this._pbf = void 0;
      this._keys = void 0;
      this._values = void 0;
      this._features = void 0;
      this.version = 1;
      this.name = "";
      this.extent = 4096;
      this.length = 0;
      this._pbf = pbf;
      this._keys = [];
      this._values = [];
      this._features = [];
      pbf.readFields(readLayer2, this, end);
      this.length = this._features.length;
    }
    feature(i5, geometryInfo) {
      if (i5 < 0 || i5 >= this._features.length) {
        throw new Error("feature index out of bounds");
      }
      this._pbf.pos = this._features[i5];
      const end = this._pbf.readVarint() + this._pbf.pos;
      return new VectorTileFeature2(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
    }
  };
  function readLayer2(tag, layer, pbf) {
    if (layer && pbf) {
      if (tag === 15)
        layer.version = pbf.readVarint();
      else if (tag === 1)
        layer.name = pbf.readString();
      else if (tag === 5)
        layer.extent = pbf.readVarint();
      else if (tag === 2)
        layer._features.push(pbf.pos);
      else if (tag === 3)
        layer._keys.push(pbf.readString());
      else if (tag === 4)
        layer._values.push(readValueMessage2(pbf));
    }
  }
  function readValueMessage2(pbf) {
    let value = null;
    const end = pbf.readVarint() + pbf.pos;
    while (pbf.pos < end) {
      const tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }
    return value;
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/binary-vector-tile/vector-tile.js
  var VectorTile2 = class {
    constructor(pbf, end) {
      this.layers = void 0;
      this.layers = pbf.readFields(readTile2, {}, end);
    }
  };
  function readTile2(tag, layers, pbf) {
    if (tag === 3) {
      if (pbf) {
        const layer = new VectorTileLayer2(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length && layers) {
          layers[layer.name] = layer;
        }
      }
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
  function parseMVT(arrayBuffer2, options) {
    var _options$gis, _options$mvt;
    const mvtOptions = normalizeOptions2(options);
    const shape = (options === null || options === void 0 ? void 0 : (_options$gis = options.gis) === null || _options$gis === void 0 ? void 0 : _options$gis.format) || (options === null || options === void 0 ? void 0 : (_options$mvt = options.mvt) === null || _options$mvt === void 0 ? void 0 : _options$mvt.shape) || (options === null || options === void 0 ? void 0 : options.shape);
    switch (shape) {
      case "columnar-table":
        return {
          shape: "columnar-table",
          data: parseToBinary(arrayBuffer2, mvtOptions)
        };
      case "geojson-table": {
        const table = {
          shape: "geojson-table",
          type: "FeatureCollection",
          features: parseToGeojsonFeatures(arrayBuffer2, mvtOptions)
        };
        return table;
      }
      case "geojson":
        return parseToGeojsonFeatures(arrayBuffer2, mvtOptions);
      case "binary-geometry":
        return parseToBinary(arrayBuffer2, mvtOptions);
      case "binary":
        return parseToBinary(arrayBuffer2, mvtOptions);
      default:
        throw new Error(shape || "undefined shape");
    }
  }
  function parseToBinary(arrayBuffer2, options) {
    const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer2, options);
    const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
    binaryData.byteLength = arrayBuffer2.byteLength;
    return binaryData;
  }
  function parseToFlatGeoJson(arrayBuffer2, options) {
    const features = [];
    const geometryInfo = {
      coordLength: 2,
      pointPositionsCount: 0,
      pointFeaturesCount: 0,
      linePositionsCount: 0,
      linePathsCount: 0,
      lineFeaturesCount: 0,
      polygonPositionsCount: 0,
      polygonObjectsCount: 0,
      polygonRingsCount: 0,
      polygonFeaturesCount: 0
    };
    if (arrayBuffer2.byteLength <= 0) {
      return [features, geometryInfo];
    }
    const tile = new VectorTile2(new import_pbf.default(arrayBuffer2));
    const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i5 = 0; i5 < vectorTileLayer.length; i5++) {
        const vectorTileFeature = vectorTileLayer.feature(i5, geometryInfo);
        const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return [features, geometryInfo];
  }
  function parseToGeojsonFeatures(arrayBuffer2, options) {
    if (arrayBuffer2.byteLength <= 0) {
      return [];
    }
    const features = [];
    const tile = new VectorTile(new import_pbf.default(arrayBuffer2));
    const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
    selectedLayers.forEach((layerName) => {
      const vectorTileLayer = tile.layers[layerName];
      if (!vectorTileLayer) {
        return;
      }
      for (let i5 = 0; i5 < vectorTileLayer.length; i5++) {
        const vectorTileFeature = vectorTileLayer.feature(i5);
        const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
        features.push(decodedFeature);
      }
    });
    return features;
  }
  function normalizeOptions2(options) {
    var _options$mvt2;
    if (!(options !== null && options !== void 0 && options.mvt)) {
      throw new Error("mvt options required");
    }
    const wgs84Coordinates = ((_options$mvt2 = options.mvt) === null || _options$mvt2 === void 0 ? void 0 : _options$mvt2.coordinates) === "wgs84";
    const {
      tileIndex
    } = options.mvt;
    const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);
    if (wgs84Coordinates && !hasTileIndex) {
      throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
    }
    return options.mvt;
  }
  function getDecodedFeature(feature, options, layerName) {
    const decodedFeature = feature.toGeoJSON(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinates);
    if (options.layerProperty) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function getDecodedFeatureBinary(feature, options, layerName) {
    const decodedFeature = feature.toBinaryCoordinates(options.coordinates === "wgs84" ? options.tileIndex : transformToLocalCoordinatesBinary);
    if (options.layerProperty && decodedFeature.properties) {
      decodedFeature.properties[options.layerProperty] = layerName;
    }
    return decodedFeature;
  }
  function transformToLocalCoordinates(line, feature) {
    const {
      extent
    } = feature;
    for (let i5 = 0; i5 < line.length; i5++) {
      const p3 = line[i5];
      p3[0] /= extent;
      p3[1] /= extent;
    }
  }
  function transformToLocalCoordinatesBinary(data, feature) {
    const {
      extent
    } = feature;
    for (let i5 = 0, il = data.length; i5 < il; ++i5) {
      data[i5] /= extent;
    }
  }

  // ../../node_modules/@loaders.gl/mvt/dist/mvt-loader.js
  var VERSION14 = true ? "4.1.4" : "latest";
  var MVTWorkerLoader = {
    name: "Mapbox Vector Tile",
    id: "mvt",
    module: "mvt",
    version: VERSION14,
    extensions: ["mvt", "pbf"],
    mimeTypes: ["application/vnd.mapbox-vector-tile", "application/x-protobuf"],
    worker: true,
    category: "geometry",
    options: {
      mvt: {
        shape: "geojson",
        coordinates: "local",
        layerProperty: "layerName",
        layers: void 0,
        tileIndex: null
      }
    }
  };
  var MVTLoader = {
    ...MVTWorkerLoader,
    parse: async (arrayBuffer2, options) => parseMVT(arrayBuffer2, options),
    parseSync: parseMVT,
    binary: true
  };

  // ../geo-layers/src/mvt-layer/coordinate-transform.ts
  var availableTransformations = {
    Point,
    MultiPoint,
    LineString,
    MultiLineString,
    Polygon: Polygon2,
    MultiPolygon
  };
  function Point([pointX2, pointY2], [nw, se], viewport) {
    const x3 = lerp(nw[0], se[0], pointX2);
    const y3 = lerp(nw[1], se[1], pointY2);
    return viewport.unprojectFlat([x3, y3]);
  }
  function getPoints(geometry, bbox, viewport) {
    return geometry.map((g2) => Point(g2, bbox, viewport));
  }
  function MultiPoint(multiPoint, bbox, viewport) {
    return getPoints(multiPoint, bbox, viewport);
  }
  function LineString(line, bbox, viewport) {
    return getPoints(line, bbox, viewport);
  }
  function MultiLineString(multiLineString, bbox, viewport) {
    return multiLineString.map((lineString) => LineString(lineString, bbox, viewport));
  }
  function Polygon2(polygon, bbox, viewport) {
    return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
  }
  function MultiPolygon(multiPolygon, bbox, viewport) {
    return multiPolygon.map((polygon) => Polygon2(polygon, bbox, viewport));
  }
  function transform(geometry, bbox, viewport) {
    const nw = viewport.projectFlat([bbox.west, bbox.north]);
    const se = viewport.projectFlat([bbox.east, bbox.south]);
    const projectedBbox = [nw, se];
    return {
      ...geometry,
      coordinates: availableTransformations[geometry.type](
        geometry.coordinates,
        projectedBbox,
        viewport
      )
    };
  }

  // ../geo-layers/src/mvt-layer/find-index-binary.ts
  var GEOM_TYPES = ["points", "lines", "polygons"];
  function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
    for (const gt of GEOM_TYPES) {
      const index2 = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
      if (index2 >= 0) {
        return index2;
      }
    }
    return -1;
  }
  function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
    const featureIds = geomData.featureIds.value;
    if (!featureIds.length) {
      return -1;
    }
    let startFeatureIndex = 0;
    let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
    if (layerName) {
      const layerRange = getLayerRange(geomData, layerName);
      if (layerRange) {
        startFeatureIndex = layerRange[0];
        endFeatureIndex = layerRange[1] + 1;
      } else {
        return -1;
      }
    }
    let featureIndex = -1;
    if (uniqueIdProperty in geomData.numericProps) {
      const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(
        (x3, i5) => x3 === featureId && featureIds[i5] >= startFeatureIndex && featureIds[i5] < endFeatureIndex
      );
      return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
    } else if (uniqueIdProperty) {
      featureIndex = findIndex(
        geomData.properties,
        (elem) => elem[uniqueIdProperty] === featureId,
        startFeatureIndex,
        endFeatureIndex
      );
    } else if (geomData.fields) {
      featureIndex = findIndex(
        geomData.fields,
        (elem) => elem.id === featureId,
        startFeatureIndex,
        endFeatureIndex
      );
    }
    return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
  }
  function getLayerRange(geomData, layerName) {
    if (!geomData.__layers) {
      const layerNames = {};
      const { properties } = geomData;
      for (let i5 = 0; i5 < properties.length; i5++) {
        const { layerName: key } = properties[i5];
        if (!key) {
        } else if (layerNames[key]) {
          layerNames[key][1] = i5;
        } else {
          layerNames[key] = [i5, i5];
        }
      }
      geomData.__layers = layerNames;
    }
    return geomData.__layers[layerName];
  }
  function getGlobalFeatureId(geomData, featureIndex) {
    if (!geomData.__ids) {
      const result = [];
      const featureIds = geomData.featureIds.value;
      const globalFeatureIds = geomData.globalFeatureIds.value;
      for (let i5 = 0; i5 < featureIds.length; i5++) {
        result[featureIds[i5]] = globalFeatureIds[i5];
      }
      geomData.__ids = result;
    }
    return geomData.__ids[featureIndex];
  }
  function findIndex(array, predicate, startIndex, endIndex) {
    for (let i5 = startIndex; i5 < endIndex; i5++) {
      if (predicate(array[i5], i5)) {
        return i5;
      }
    }
    return -1;
  }

  // ../geo-layers/src/mvt-layer/mvt-layer.ts
  var WORLD_SIZE = 512;
  var defaultProps40 = {
    ...GeoJsonLayer.defaultProps,
    data: urlType,
    onDataLoad: { type: "function", value: null, optional: true, compare: false },
    uniqueIdProperty: "",
    highlightedFeatureId: null,
    loaders: [MVTWorkerLoader],
    binary: true
  };
  var MVTLayer = class extends TileLayer {
    initializeState() {
      super.initializeState();
      const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
      this.setState({
        binary,
        data: null,
        tileJSON: null,
        hoveredFeatureId: null,
        hoveredFeatureLayerName: null
      });
    }
    get isLoaded() {
      return Boolean(this.state?.data && super.isLoaded);
    }
    updateState({ props, oldProps, context, changeFlags }) {
      if (changeFlags.dataChanged) {
        this._updateTileData();
      }
      if (this.state?.data) {
        super.updateState({ props, oldProps, context, changeFlags });
        this._setWGS84PropertyForTiles();
      }
      const { highlightColor } = props;
      if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
        this.setState({ highlightColor });
      }
    }
    async _updateTileData() {
      let data = this.props.data;
      let tileJSON = null;
      if (typeof data === "string" && !isURLTemplate(data)) {
        const { onDataLoad, fetch: fetch2 } = this.props;
        this.setState({ data: null, tileJSON: null });
        try {
          tileJSON = await fetch2(data, { propName: "data", layer: this, loaders: [] });
        } catch (error) {
          this.raiseError(error, "loading TileJSON");
          data = null;
        }
        if (onDataLoad) {
          onDataLoad(tileJSON, { propName: "data", layer: this });
        }
      } else if (data && typeof data === "object" && "tilejson" in data) {
        tileJSON = data;
      }
      if (tileJSON) {
        data = tileJSON.tiles;
      }
      this.setState({ data, tileJSON });
    }
    _getTilesetOptions() {
      const opts = super._getTilesetOptions();
      const tileJSON = this.state.tileJSON;
      const { minZoom, maxZoom } = this.props;
      if (tileJSON) {
        if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
          opts.minZoom = tileJSON.minzoom;
        }
        if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
          opts.maxZoom = tileJSON.maxzoom;
        }
      }
      return opts;
    }
    renderLayers() {
      if (!this.state?.data)
        return null;
      return super.renderLayers();
    }
    getTileData(loadProps) {
      const { data, binary } = this.state;
      const { index: index2, signal } = loadProps;
      const url = getURLFromTemplate(data, loadProps);
      if (!url) {
        return Promise.reject("Invalid URL");
      }
      let loadOptions = this.getLoadOptions();
      const { fetch: fetch2 } = this.props;
      loadOptions = {
        ...loadOptions,
        mimeType: "application/x-protobuf",
        mvt: {
          ...loadOptions?.mvt,
          coordinates: this.context.viewport.resolution ? "wgs84" : "local",
          tileIndex: index2
        },
        gis: binary ? { format: "binary" } : {}
      };
      return fetch2(url, { propName: "data", layer: this, loadOptions, signal });
    }
    renderSubLayers(props) {
      const { x: x3, y: y3, z: z2 } = props.tile.index;
      const worldScale = Math.pow(2, z2);
      const xScale = WORLD_SIZE / worldScale;
      const yScale = -xScale;
      const xOffset = WORLD_SIZE * x3 / worldScale;
      const yOffset = WORLD_SIZE * (1 - y3 / worldScale);
      const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
      props.autoHighlight = false;
      if (!this.context.viewport.resolution) {
        props.modelMatrix = modelMatrix2;
        props.coordinateOrigin = [xOffset, yOffset, 0];
        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
        props.extensions = [...props.extensions || [], new ClipExtension()];
      }
      const subLayers = super.renderSubLayers(props);
      if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {
        log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
      }
      return subLayers;
    }
    _updateAutoHighlight(info) {
      const { uniqueIdProperty } = this.props;
      const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
      const hoveredFeature = info.object;
      let newHoveredFeatureId = null;
      let newHoveredFeatureLayerName = null;
      if (hoveredFeature) {
        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
        newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
      }
      let { highlightColor } = this.props;
      if (typeof highlightColor === "function") {
        highlightColor = highlightColor(info);
      }
      if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
        this.setState({
          highlightColor,
          hoveredFeatureId: newHoveredFeatureId,
          hoveredFeatureLayerName: newHoveredFeatureLayerName
        });
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const isWGS842 = Boolean(this.context.viewport.resolution);
      if (this.state.binary && info.index !== -1) {
        const { data } = params.sourceLayer.props;
        info.object = binaryToGeojson(data, {
          globalFeatureId: info.index
        });
      }
      if (info.object && !isWGS842) {
        info.object = transformTileCoordsToWGS84(
          info.object,
          info.tile.bbox,
          this.context.viewport
        );
      }
      return info;
    }
    getSubLayerPropsByTile(tile) {
      return {
        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
        highlightColor: this.state.highlightColor
      };
    }
    getHighlightedObjectIndex(tile) {
      const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
      const { uniqueIdProperty, highlightedFeatureId } = this.props;
      const data = tile.content;
      const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
      const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
      if (!isFeatureIdPresent) {
        return -1;
      }
      const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
      if (Array.isArray(data)) {
        return data.findIndex((feature) => {
          const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;
          const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;
          return isMatchingId && isMatchingLayer;
        });
      } else if (data && binary) {
        return findIndexBinary(
          data,
          uniqueIdProperty,
          featureIdToHighlight,
          isHighlighted ? "" : hoveredFeatureLayerName
        );
      }
      return -1;
    }
    _pickObjects(maxObjects) {
      const { deck, viewport } = this.context;
      const width = viewport.width;
      const height = viewport.height;
      const x3 = viewport.x;
      const y3 = viewport.y;
      const layerIds = [this.id];
      return deck.pickObjects({ x: x3, y: y3, width, height, layerIds, maxObjects });
    }
    getRenderedFeatures(maxFeatures = null) {
      const features = this._pickObjects(maxFeatures);
      const featureCache = /* @__PURE__ */ new Set();
      const renderedFeatures = [];
      for (const f4 of features) {
        const featureId = getFeatureUniqueId(f4.object, this.props.uniqueIdProperty);
        if (featureId === void 0) {
          renderedFeatures.push(f4.object);
        } else if (!featureCache.has(featureId)) {
          featureCache.add(featureId);
          renderedFeatures.push(f4.object);
        }
      }
      return renderedFeatures;
    }
    _setWGS84PropertyForTiles() {
      const propName = "dataInWGS84";
      const tileset = this.state.tileset;
      tileset.selectedTiles.forEach((tile) => {
        if (!tile.hasOwnProperty(propName)) {
          Object.defineProperty(tile, propName, {
            get: () => {
              if (!tile.content) {
                return null;
              }
              if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
                return [];
              }
              const { bbox } = tile;
              if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
                const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
                tile._contentWGS84 = content.map(
                  (feature) => transformTileCoordsToWGS84(feature, bbox, this.context.viewport)
                );
              }
              return tile._contentWGS84;
            }
          });
        }
      });
    }
  };
  MVTLayer.layerName = "MVTLayer";
  MVTLayer.defaultProps = defaultProps40;
  function getFeatureUniqueId(feature, uniqueIdProperty) {
    if (feature.properties && uniqueIdProperty) {
      return feature.properties[uniqueIdProperty];
    }
    if ("id" in feature) {
      return feature.id;
    }
    return void 0;
  }
  function getFeatureLayerName(feature) {
    return feature.properties?.layerName || null;
  }
  function isFeatureIdDefined(value) {
    return value !== void 0 && value !== null && value !== "";
  }
  function transformTileCoordsToWGS84(object, bbox, viewport) {
    const feature = {
      ...object,
      geometry: {
        type: object.geometry.type
      }
    };
    Object.defineProperty(feature.geometry, "coordinates", {
      get: () => {
        const wgs84Geom = transform(object.geometry, bbox, viewport);
        return wgs84Geom.coordinates;
      }
    });
    return feature;
  }

  // ../geo-layers/src/geohash-layer/geohash-utils.ts
  var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
  var BASE32_CODES_DICT = {};
  for (let i5 = 0; i5 < BASE32_CODES.length; i5++) {
    BASE32_CODES_DICT[BASE32_CODES.charAt(i5)] = i5;
  }
  var MIN_LAT = -90;
  var MAX_LAT = 90;
  var MIN_LON = -180;
  var MAX_LON = 180;
  function getGeohashBounds(geohash) {
    let isLon = true;
    let maxLat = MAX_LAT;
    let minLat = MIN_LAT;
    let maxLon = MAX_LON;
    let minLon = MIN_LON;
    let mid;
    let hashValue = 0;
    for (let i5 = 0, l3 = geohash.length; i5 < l3; i5++) {
      const code = geohash[i5].toLowerCase();
      hashValue = BASE32_CODES_DICT[code];
      for (let bits = 4; bits >= 0; bits--) {
        const bit = hashValue >> bits & 1;
        if (isLon) {
          mid = (maxLon + minLon) / 2;
          if (bit === 1) {
            minLon = mid;
          } else {
            maxLon = mid;
          }
        } else {
          mid = (maxLat + minLat) / 2;
          if (bit === 1) {
            minLat = mid;
          } else {
            maxLat = mid;
          }
        }
        isLon = !isLon;
      }
    }
    return [minLat, minLon, maxLat, maxLon];
  }
  function getGeohashPolygon(geohash) {
    const [s3, w2, n3, e3] = getGeohashBounds(geohash);
    return [e3, n3, e3, s3, w2, s3, w2, n3, e3, n3];
  }

  // ../geo-layers/src/geohash-layer/geohash-layer.ts
  var defaultProps41 = {
    getGeohash: { type: "accessor", value: (d2) => d2.geohash }
  };
  var GeohashLayer = class extends GeoCellLayer {
    indexToBounds() {
      const { data, getGeohash } = this.props;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x3, objectInfo) => getGeohashPolygon(getGeohash(x3, objectInfo))
      };
    }
  };
  GeohashLayer.layerName = "GeohashLayer";
  GeohashLayer.defaultProps = defaultProps41;

  // ../core/src/scripting/lumagl.ts
  var lumagl_exports = {};
  __export(lumagl_exports, {
    Buffer: () => Buffer2,
    BufferTransform: () => BufferTransform,
    CubeGeometry: () => CubeGeometry,
    Device: () => Device,
    Framebuffer: () => Framebuffer,
    Geometry: () => Geometry,
    GroupNode: () => GroupNode,
    Model: () => Model,
    ModelNode: () => ModelNode,
    ScenegraphNode: () => ScenegraphNode,
    SphereGeometry: () => SphereGeometry,
    Texture: () => Texture,
    TextureTransform: () => TextureTransform
  });

  // ../core/src/scripting/loadersgl.ts
  var loadersgl_exports = {};
  __export(loadersgl_exports, {
    fetchFile: () => fetchFile,
    load: () => load,
    parse: () => parse,
    registerLoaders: () => registerLoaders
  });

  // ../core/src/scripting/map-wrapper.ts
  var MapWrapper = class {
    constructor(props) {
      this.map = null;
      this.width = 0;
      this.height = 0;
      this.props = { ...props };
      this._initialize(this.props);
    }
    finalize() {
      this.map?.remove();
      this.map = null;
    }
    setProps(props) {
      const oldProps = this.props;
      const newProps = { ...this.props, ...props };
      this.props = newProps;
      if (!this.map) {
        return;
      }
      const needsRedraw = this._update(oldProps, newProps);
      if (needsRedraw) {
        this.redraw();
      }
    }
    redraw() {
      const map3 = this.map;
      if (map3.style) {
        if (map3._frame) {
          map3._frame.cancel();
          map3._frame = null;
        }
        map3._render();
      }
    }
    getMap() {
      return this.map;
    }
    _initialize(props) {
      const { mapLib, container } = props;
      mapLib.accessToken = props.mapboxApiAccessToken || "";
      this.map = new props.mapLib.Map({
        container,
        maxZoom: 24,
        ...props.mapOptions,
        ...viewStateToMapboxProps(props.viewState),
        style: props.mapStyle,
        interactive: false,
        trackResize: false
      });
      Object.defineProperty(container, "offsetWidth", { get: () => this.width });
      Object.defineProperty(container, "clientWidth", { get: () => this.width });
      Object.defineProperty(container, "offsetHeight", {
        get: () => this.height
      });
      Object.defineProperty(container, "clientHeight", {
        get: () => this.height
      });
      this.map.resize();
    }
    _update(oldProps, newProps) {
      const styleChanged = oldProps.mapStyle !== newProps.mapStyle;
      if (styleChanged) {
        this.map.setStyle(newProps.mapStyle);
      }
      const sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
      if (sizeChanged) {
        this.width = newProps.width;
        this.height = newProps.height;
        this.map.resize();
      }
      const oldViewState = oldProps.viewState;
      const newViewState = newProps.viewState;
      const viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing;
      if (viewportChanged) {
        this.map.jumpTo(viewStateToMapboxProps(newViewState));
      }
      return sizeChanged || viewportChanged;
    }
  };
  function viewStateToMapboxProps(viewState) {
    return {
      center: [viewState.longitude, viewState.latitude],
      zoom: viewState.zoom,
      bearing: viewState.bearing ?? 0,
      pitch: viewState.pitch ?? 0
    };
  }

  // ../core/src/scripting/deckgl.ts
  var CANVAS_STYLE = {
    position: "absolute",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  };
  function createCanvas2(props) {
    let { container = document.body } = props;
    if (typeof container === "string") {
      container = document.getElementById(container);
    }
    if (!container) {
      throw Error("Deck: container not found");
    }
    const containerStyle = window.getComputedStyle(container);
    if (containerStyle.position === "static") {
      container.style.position = "relative";
    }
    const mapCanvas = document.createElement("div");
    container.appendChild(mapCanvas);
    Object.assign(mapCanvas.style, CANVAS_STYLE);
    const deckCanvas = document.createElement("canvas");
    container.appendChild(deckCanvas);
    Object.assign(deckCanvas.style, CANVAS_STYLE);
    return { container, mapCanvas, deckCanvas };
  }
  var DeckGL = class extends Deck {
    constructor(props) {
      if (typeof document === "undefined") {
        throw Error("Deck can only be used in the browser");
      }
      const { mapCanvas, deckCanvas } = createCanvas2(props);
      const viewState = props.viewState || props.initialViewState;
      const isMap = Number.isFinite(viewState && viewState.latitude);
      const { map: map3 = globalThis.mapboxgl || globalThis.maplibregl } = props;
      super({ canvas: deckCanvas, ...props });
      if (map3 && map3.Map) {
        this._map = isMap && new MapWrapper({
          ...props,
          width: 0,
          height: 0,
          viewState,
          container: mapCanvas,
          mapLib: map3
        });
      } else {
        this._map = map3;
      }
    }
    getMapboxMap() {
      return this._map && this._map.getMap();
    }
    finalize() {
      if (this._map) {
        this._map.finalize();
      }
      super.finalize();
    }
    setProps(props) {
      if ("mapStyle" in props && this._map) {
        this._map.setProps({ mapStyle: props.mapStyle });
      }
      super.setProps(props);
    }
    _drawLayers(redrawReason, options) {
      if (this._map) {
        const viewport = this.getViewports()[0];
        if (viewport) {
          this._map.setProps({
            width: viewport.width,
            height: viewport.height,
            viewState: viewport
          });
        }
      }
      super._drawLayers(redrawReason, options);
    }
  };

  // ../core/bundle/index.ts
  globalThis.luma = globalThis.luma || {};
  globalThis.loaders = globalThis.loaders || {};
  Object.assign(globalThis.luma, lumagl_exports);
  Object.assign(globalThis.loaders, loadersgl_exports);

  // ../aggregation-layers/src/utils/aggregation-operation-utils.ts
  var AGGREGATION_OPERATION = {
    SUM: 1,
    MEAN: 2,
    MIN: 3,
    MAX: 4
  };
  function sumReducer(accu, cur) {
    return accu + cur;
  }
  function maxReducer(accu, cur) {
    return cur > accu ? cur : accu;
  }
  function minReducer(accu, cur) {
    return cur < accu ? cur : accu;
  }
  function getMean(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;
  }
  function getSum(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? pts.length * accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(sumReducer, 0) : null;
  }
  function getMax(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;
  }
  function getMin(pts, accessor) {
    if (Number.isFinite(accessor)) {
      return pts.length ? accessor : null;
    }
    const filtered = pts.map(accessor).filter(Number.isFinite);
    return filtered.length ? filtered.reduce(minReducer, Infinity) : null;
  }
  function getValueFunc(aggregation, accessor, context) {
    const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;
    accessor = wrapAccessor(accessor, context);
    switch (op) {
      case AGGREGATION_OPERATION.MIN:
        return (pts) => getMin(pts, accessor);
      case AGGREGATION_OPERATION.SUM:
        return (pts) => getSum(pts, accessor);
      case AGGREGATION_OPERATION.MEAN:
        return (pts) => getMean(pts, accessor);
      case AGGREGATION_OPERATION.MAX:
        return (pts) => getMax(pts, accessor);
      default:
        return null;
    }
  }
  function wrapAccessor(accessor, context = {}) {
    if (Number.isFinite(accessor)) {
      return accessor;
    }
    return (pt) => {
      context.index = pt.index;
      return accessor(pt.source, context);
    };
  }
  function wrapGetValueFunc(getValue2, context = {}) {
    return (pts) => {
      context.indices = pts.map((pt) => pt.index);
      return getValue2(
        pts.map((pt) => pt.source),
        context
      );
    };
  }

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.ts
  var DEFAULT_RUN_PARAMS = {
    projectPoints: false,
    viewport: null,
    createBufferObjects: true,
    moduleSettings: {}
  };
  var MAX_32_BIT_FLOAT = 3402823466e29;
  var MIN_BLEND_EQUATION = [GLEnum.MIN, GLEnum.FUNC_ADD];
  var MAX_BLEND_EQUATION = [GLEnum.MAX, GLEnum.FUNC_ADD];
  var MAX_MIN_BLEND_EQUATION = [GLEnum.MAX, GLEnum.MIN];
  var EQUATION_MAP = {
    [AGGREGATION_OPERATION.SUM]: GLEnum.FUNC_ADD,
    [AGGREGATION_OPERATION.MEAN]: GLEnum.FUNC_ADD,
    [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,
    [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION
  };
  var DEFAULT_WEIGHT_PARAMS = {
    size: 1,
    operation: AGGREGATION_OPERATION.SUM,
    needMin: false,
    needMax: false,
    combineMaxMin: false
  };
  var PIXEL_SIZE = 4;
  var MAX_MIN_TEXTURE_OPTS = {
    format: GLEnum.RGBA32F,
    type: GLEnum.FLOAT,
    border: 0,
    mipmaps: false,
    sampler: {
      minFilter: "nearest",
      magFilter: "nearest"
    },
    dataFormat: GLEnum.RGBA,
    width: 1,
    height: 1
  };

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.ts
  var aggregate_to_grid_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-vs

in vec3 positions;
in vec3 positions64Low;
in vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;

out vec3 vWeights;

vec2 project_to_pixel(vec4 pos) {
  vec4 result;
  pos.xy = pos.xy/pos.w;
  result = pos + vec4(translation, 0., 0.);
  result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
  return result.xy;
}

void main(void) {

  vWeights = weights;

  vec4 windowPos = vec4(positions, 1.);
  if (projectPoints) {
    windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
  }

  vec2 pos = project_to_pixel(windowPos);

  vec2 pixelXY64[2];
  pixelXY64[0] = vec2(pos.x, 0.);
  pixelXY64[1] = vec2(pos.y, 0.);

  // Transform (0,0):windowSize -> (0, 0): gridSize
  vec2 gridXY64[2];
  gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
  gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
  float x = floor(gridXY64[0].x);
  float y = floor(gridXY64[1].x);
  pos = vec2(x, y);

  // Transform (0,0):gridSize -> (-1, -1):(1,1)
  pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / gridSize;
  pos = pos + offset;

  gl_Position = vec4(pos, 0.0, 1.0);

  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.ts
  var aggregate_to_grid_fs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-fs

precision highp float;

in vec3 vWeights;

out vec4 fragColor;

void main(void) {
  fragColor = vec4(vWeights, 1.0);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.ts
  var aggregate_all_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64

in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;

void main(void) {
  // Map each position to single pixel
  vec2 pos = vec2(-1.0, -1.0);

  // Move to pixel center, pixel-size in screen sapce (2/gridSize) * 0.5 => 1/gridSize
  vec2 offset = 1.0 / vec2(gridSize);
  pos = pos + offset;

  gl_Position = vec4(pos, 0.0, 1.0);

  int yIndex = gl_InstanceID / gridSize[0];
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 yIndexFP64 = vec2(float(yIndex), 0.);
  vec2 xIndexFP64 = vec2(float(xIndex), 0.);
  vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
  vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);

  vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
  vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);

  vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.ts
  var aggregate_all_fs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs

precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
  vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  if (textureColor.a == 0.) {
    discard;
  }
  fragColor.rgb = textureColor.rgb;
  // if combineMinMax is true, use Alpha channel for first weights min value.
  fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`;

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/transform-mean-vs.glsl.ts
  var transform_mean_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-transform-mean-vs
in vec4 aggregationValues;
out vec4 meanValues;

void main()
{
  // TODO: Use 64-bit division ?? not needed given this is aggregation ??
  bool isCellValid = bool(aggregationValues.w > 0.);
  // aggregationValues:  XYZ contain aggregated values, W contains count
  meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
  meanValues.w = aggregationValues.w;

  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/utils/resource-utils.ts
  var DEFAULT_PARAMETERS = {
    minFilter: "nearest",
    magFilter: "nearest"
  };
  function getFloatTexture(device, opts) {
    const { width = 1, height = 1, data = null, parameters: parameters2 = DEFAULT_PARAMETERS } = opts;
    const texture = device.createTexture({
      data,
      format: "rgba32float",
      mipmaps: false,
      sampler: parameters2,
      width,
      height
    });
    return texture;
  }
  function getFramebuffer5(device, opts) {
    const { id, width = 1, height = 1, texture } = opts;
    const fb = device.createFramebuffer({
      id,
      width,
      height,
      colorAttachments: [texture]
    });
    return fb;
  }

  // ../aggregation-layers/src/utils/gpu-grid-aggregation/gpu-grid-aggregator.ts
  var BUFFER_NAMES = ["aggregationBuffer", "maxMinBuffer", "minBuffer", "maxBuffer"];
  var ARRAY_BUFFER_MAP = {
    maxData: "maxBuffer",
    minData: "minBuffer",
    maxMinData: "maxMinBuffer"
  };
  var REQUIRED_FEATURES = [
    "float32-renderable-webgl",
    "texture-blend-float-webgl"
  ];
  var GPUGridAggregator = class {
    constructor(device, props = {}) {
      this.state = {
        weightAttributes: {},
        textures: {},
        meanTextures: {},
        buffers: {},
        framebuffers: {},
        maxMinFramebuffers: {},
        minFramebuffers: {},
        maxFramebuffers: {},
        equations: {},
        shaderOptions: {},
        modelDirty: false,
        resources: {},
        results: {}
      };
      this.id = props.id || "gpu-grid-aggregator";
      this.device = device;
      const REQUIRED_FEATURES2 = [
        "float32-renderable-webgl"
      ];
      this._hasGPUSupport = REQUIRED_FEATURES2.every((feature) => device.features.has(feature));
      if (this._hasGPUSupport) {
        this._setupModels();
      }
    }
    static getAggregationData({
      aggregationData,
      maxData,
      minData,
      maxMinData,
      pixelIndex
    }) {
      const index2 = pixelIndex * PIXEL_SIZE;
      const results = {};
      if (aggregationData) {
        results.cellCount = aggregationData[index2 + 3];
        results.cellWeight = aggregationData[index2];
      }
      if (maxMinData) {
        results.maxCellWieght = maxMinData[0];
        results.minCellWeight = maxMinData[3];
      } else {
        if (maxData) {
          results.maxCellWieght = maxData[0];
          results.totalCount = maxData[3];
        }
        if (minData) {
          results.minCellWeight = minData[0];
          results.totalCount = minData[3];
        }
      }
      return results;
    }
    static getCellData({ countsData, size = 1 }) {
      const numCells = countsData.length / 4;
      const cellWeights = new Float32Array(numCells * size);
      const cellCounts = new Uint32Array(numCells);
      for (let i5 = 0; i5 < numCells; i5++) {
        for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {
          cellWeights[i5 * size + sizeIndex] = countsData[i5 * 4 + sizeIndex];
        }
        cellCounts[i5] = countsData[i5 * 4 + 3];
      }
      return { cellCounts, cellWeights };
    }
    static isSupported(device) {
      return REQUIRED_FEATURES.every((feature) => device.features.has(feature));
    }
    delete() {
      const { gridAggregationModel, allAggregationModel, meanTransform } = this;
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        meanTextures,
        resources
      } = this.state;
      gridAggregationModel?.destroy();
      allAggregationModel?.destroy();
      meanTransform?.destroy();
      deleteResources([
        framebuffers,
        textures,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        meanTextures,
        resources
      ]);
    }
    run(opts = {}) {
      this.setState({ results: {} });
      const aggregationParams = this._normalizeAggregationParams(opts);
      return this._runAggregation(aggregationParams);
    }
    getData(weightId) {
      const data = {};
      const results = this.state.results;
      if (!results[weightId].aggregationData) {
        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();
      }
      data.aggregationData = results[weightId].aggregationData;
      for (const arrayName in ARRAY_BUFFER_MAP) {
        const bufferName = ARRAY_BUFFER_MAP[arrayName];
        if (results[weightId][arrayName] || results[weightId][bufferName]) {
          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();
          data[arrayName] = results[weightId][arrayName];
        }
      }
      return data;
    }
    updateShaders(shaderOptions = {}) {
      this.setState({ shaderOptions, modelDirty: true });
    }
    _normalizeAggregationParams(opts) {
      const aggregationParams = { ...DEFAULT_RUN_PARAMS, ...opts };
      const { weights } = aggregationParams;
      if (weights) {
        aggregationParams.weights = normalizeWeightParams(weights);
      }
      return aggregationParams;
    }
    setState(updateObject) {
      Object.assign(this.state, updateObject);
    }
    _getAggregateData(opts) {
      const results = {};
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        resources
      } = this.state;
      const { weights } = opts;
      for (const id in weights) {
        results[id] = {};
        const { needMin, needMax, combineMaxMin } = weights[id];
        results[id].aggregationTexture = textures[id];
        results[id].aggregationBuffer = this.device.readPixelsToBufferWebGL(framebuffers[id], {
          target: weights[id].aggregationBuffer,
          sourceType: GLEnum.FLOAT
        });
        if (needMin && needMax && combineMaxMin) {
          results[id].maxMinBuffer = this.device.readPixelsToBufferWebGL(maxMinFramebuffers[id], {
            target: weights[id].maxMinBuffer,
            sourceType: GLEnum.FLOAT
          });
          results[id].maxMinTexture = resources[`${id}-maxMinTexture`];
        } else {
          if (needMin) {
            results[id].minBuffer = this.device.readPixelsToBufferWebGL(minFramebuffers[id], {
              target: weights[id].minBuffer,
              sourceType: GLEnum.FLOAT
            });
            results[id].minTexture = resources[`${id}-minTexture`];
          }
          if (needMax) {
            results[id].maxBuffer = this.device.readPixelsToBufferWebGL(maxFramebuffers[id], {
              target: weights[id].maxBuffer,
              sourceType: GLEnum.FLOAT
            });
            results[id].maxTexture = resources[`${id}-maxTexture`];
          }
        }
      }
      this._trackGPUResultBuffers(results, weights);
      return results;
    }
    _renderAggregateData(opts) {
      const {
        cellSize,
        projectPoints,
        attributes,
        moduleSettings,
        numCol,
        numRow,
        weights,
        translation,
        scaling
      } = opts;
      const { maxMinFramebuffers, minFramebuffers, maxFramebuffers } = this.state;
      const gridSize = [numCol, numRow];
      const parameters2 = {
        blend: true,
        depthTest: false,
        blendFunc: [GLEnum.ONE, GLEnum.ONE]
      };
      const uniforms = {
        cellSize,
        gridSize,
        projectPoints,
        translation,
        scaling
      };
      for (const id in weights) {
        const { needMin, needMax } = weights[id];
        const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
        this._renderToWeightsTexture({
          id,
          parameters: parameters2,
          moduleSettings,
          uniforms,
          gridSize,
          attributes,
          weights
        });
        if (combineMaxMin) {
          this._renderToMaxMinTexture({
            id,
            parameters: { ...parameters2, blendEquation: MAX_MIN_BLEND_EQUATION },
            gridSize,
            minOrMaxFb: maxMinFramebuffers[id],
            clearParams: { clearColor: [0, 0, 0, MAX_32_BIT_FLOAT] },
            combineMaxMin
          });
        } else {
          if (needMin) {
            this._renderToMaxMinTexture({
              id,
              parameters: { ...parameters2, blendEquation: MIN_BLEND_EQUATION },
              gridSize,
              minOrMaxFb: minFramebuffers[id],
              clearParams: { clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] },
              combineMaxMin
            });
          }
          if (needMax) {
            this._renderToMaxMinTexture({
              id,
              parameters: { ...parameters2, blendEquation: MAX_BLEND_EQUATION },
              gridSize,
              minOrMaxFb: maxFramebuffers[id],
              clearParams: { clearColor: [0, 0, 0, 0] },
              combineMaxMin
            });
          }
        }
      }
    }
    _renderToMaxMinTexture(opts) {
      const { id, gridSize, minOrMaxFb, combineMaxMin, clearParams = {} } = opts;
      const { framebuffers } = this.state;
      const { allAggregationModel } = this;
      this.device.withParametersWebGL(
        {
          ...clearParams,
          framebuffer: minOrMaxFb,
          viewport: [0, 0, gridSize[0], gridSize[1]]
        },
        () => {
          this.device.clearWebGL({ color: true });
          allAggregationModel.setUniforms({ gridSize, combineMaxMin });
          allAggregationModel.setBindings({ uSampler: framebuffers[id].texture });
          allAggregationModel.draw();
        }
      );
    }
    _renderToWeightsTexture(opts) {
      const { id, parameters: parameters2, moduleSettings, uniforms, gridSize, weights } = opts;
      const { framebuffers, equations, weightAttributes } = this.state;
      const { gridAggregationModel } = this;
      const { operation } = weights[id];
      const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];
      this.device.withParametersWebGL(
        {
          framebuffer: framebuffers[id],
          viewport: [0, 0, gridSize[0], gridSize[1]],
          clearColor
        },
        () => {
          this.device.clearWebGL({ color: true });
          const attributes = { weights: weightAttributes[id] };
          gridAggregationModel.draw({
            parameters: { ...parameters2, blendEquation: equations[id] },
            moduleSettings,
            uniforms,
            attributes
          });
        }
      );
      if (operation === AGGREGATION_OPERATION.MEAN) {
        const { meanTextures, textures } = this.state;
        const transformOptions = {
          _sourceTextures: { aggregationValues: meanTextures[id] },
          _targetTexture: textures[id],
          elementCount: textures[id].width * textures[id].height
        };
        if (this.meanTransform) {
          this.meanTransform.update(transformOptions);
        } else {
          this.meanTransform = getMeanTransform(this.device, transformOptions);
        }
        this.meanTransform.run({
          parameters: {
            blend: false,
            depthTest: false
          }
        });
        framebuffers[id].attach({ [GLEnum.COLOR_ATTACHMENT0]: textures[id] });
      }
    }
    _runAggregation(opts) {
      this._updateModels(opts);
      this._setupFramebuffers(opts);
      this._renderAggregateData(opts);
      const results = this._getAggregateData(opts);
      this.setState({ results });
      return results;
    }
    _setupFramebuffers(opts) {
      const {
        textures,
        framebuffers,
        maxMinFramebuffers,
        minFramebuffers,
        maxFramebuffers,
        meanTextures,
        equations
      } = this.state;
      const { weights } = opts;
      const { numCol, numRow } = opts;
      const framebufferSize = { width: numCol, height: numRow };
      for (const id in weights) {
        const { needMin, needMax, combineMaxMin, operation } = weights[id];
        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.device, { id: `${id}-texture`, width: numCol, height: numRow });
        textures[id].resize(framebufferSize);
        let texture = textures[id];
        if (operation === AGGREGATION_OPERATION.MEAN) {
          meanTextures[id] = meanTextures[id] || getFloatTexture(this.device, { id: `${id}-mean-texture`, width: numCol, height: numRow });
          meanTextures[id].resize(framebufferSize);
          texture = meanTextures[id];
        }
        if (framebuffers[id]) {
          framebuffers[id].attach({ [GLEnum.COLOR_ATTACHMENT0]: texture });
        } else {
          framebuffers[id] = getFramebuffer5(this.device, {
            id: `${id}-fb`,
            width: numCol,
            height: numRow,
            texture
          });
        }
        framebuffers[id].resize(framebufferSize);
        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP[AGGREGATION_OPERATION.SUM];
        if (needMin || needMax) {
          if (needMin && needMax && combineMaxMin) {
            if (!maxMinFramebuffers[id]) {
              texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);
              maxMinFramebuffers[id] = getFramebuffer5(this.device, { id: `${id}-maxMinFb`, texture });
            }
          } else {
            if (needMin) {
              if (!minFramebuffers[id]) {
                texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);
                minFramebuffers[id] = getFramebuffer5(this.device, {
                  id: `${id}-minFb`,
                  texture
                });
              }
            }
            if (needMax) {
              if (!maxFramebuffers[id]) {
                texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);
                maxFramebuffers[id] = getFramebuffer5(this.device, {
                  id: `${id}-maxFb`,
                  texture
                });
              }
            }
          }
        }
      }
    }
    _getMinMaxTexture(name13) {
      const { resources } = this.state;
      if (!resources[name13]) {
        resources[name13] = getFloatTexture(this.device, { id: "resourceName" });
      }
      return resources[name13];
    }
    _setupModels({ numCol = 0, numRow = 0 } = {}) {
      const { shaderOptions } = this.state;
      this.gridAggregationModel?.destroy();
      this.gridAggregationModel = getAggregationModel(this.device, shaderOptions);
      if (!this.allAggregationModel) {
        const instanceCount = numCol * numRow;
        this.allAggregationModel = getAllAggregationModel(this.device, instanceCount);
      }
    }
    _setupWeightAttributes(opts) {
      const { weightAttributes } = this.state;
      const { weights } = opts;
      for (const id in weights) {
        weightAttributes[id] = opts.attributes[id];
      }
    }
    _trackGPUResultBuffers(results, weights) {
      const { resources } = this.state;
      for (const id in results) {
        if (results[id]) {
          for (const bufferName of BUFFER_NAMES) {
            if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {
              const name13 = `gpu-result-${id}-${bufferName}`;
              if (resources[name13]) {
                resources[name13].delete();
              }
              resources[name13] = results[id][bufferName];
            }
          }
        }
      }
    }
    _updateModels(opts) {
      const { vertexCount, attributes, numCol, numRow } = opts;
      const { modelDirty } = this.state;
      if (modelDirty) {
        this._setupModels(opts);
        this.setState({ modelDirty: false });
      }
      this._setupWeightAttributes(opts);
      this.gridAggregationModel.setVertexCount(vertexCount);
      this.gridAggregationModel.setAttributes(attributes);
      this.allAggregationModel.setInstanceCount(numCol * numRow);
    }
  };
  function normalizeWeightParams(weights) {
    const result = {};
    for (const id in weights) {
      result[id] = { ...DEFAULT_WEIGHT_PARAMS, ...weights[id] };
    }
    return result;
  }
  function deleteResources(resources) {
    resources = Array.isArray(resources) ? resources : [resources];
    resources.forEach((obj) => {
      for (const name13 in obj) {
        obj[name13].delete();
      }
    });
  }
  function getAggregationModel(device, shaderOptions) {
    const shaders = mergeShaders(
      {
        vs: aggregate_to_grid_vs_glsl_default,
        fs: aggregate_to_grid_fs_glsl_default,
        modules: [fp64arithmetic, project32_default]
      },
      shaderOptions
    );
    return new Model(device, {
      id: "Grid-Aggregation-Model",
      vertexCount: 1,
      drawMode: GLEnum.POINTS,
      shaderAssembler: getShaderAssembler(),
      ...shaders
    });
  }
  function getAllAggregationModel(device, instanceCount) {
    return new Model(device, {
      id: "All-Aggregation-Model",
      vs: aggregate_all_vs_glsl_default,
      fs: aggregate_all_fs_glsl_default,
      modules: [fp64arithmetic],
      vertexCount: 1,
      topology: "point-list",
      isInstanced: true,
      instanceCount,
      attributes: {
        position: [0, 0]
      }
    });
  }
  function getMeanTransform(device, opts) {
    return new TextureTransform(device, {
      vs: transform_mean_vs_glsl_default,
      _targetTextureVarying: "meanValues",
      ...opts
    });
  }

  // ../aggregation-layers/src/utils/color-utils.ts
  var defaultColorRange = [
    [255, 255, 178],
    [254, 217, 118],
    [254, 178, 76],
    [253, 141, 60],
    [240, 59, 32],
    [189, 0, 38]
  ];
  function colorRangeToFlatArray(colorRange, normalize6 = false, ArrayType2 = Float32Array) {
    let flatArray;
    if (Number.isFinite(colorRange[0])) {
      flatArray = new ArrayType2(colorRange);
    } else {
      flatArray = new ArrayType2(colorRange.length * 4);
      let index2 = 0;
      for (let i5 = 0; i5 < colorRange.length; i5++) {
        const color = colorRange[i5];
        flatArray[index2++] = color[0];
        flatArray[index2++] = color[1];
        flatArray[index2++] = color[2];
        flatArray[index2++] = Number.isFinite(color[3]) ? color[3] : 255;
      }
    }
    if (normalize6) {
      for (let i5 = 0; i5 < flatArray.length; i5++) {
        flatArray[i5] /= 255;
      }
    }
    return flatArray;
  }

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts
  var screen_grid_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6

in vec3 positions;
in vec3 instancePositions;
in vec4 instanceCounts;
in vec3 instancePickingColors;

uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;

out vec4 vColor;
out float vSampleCount;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= domain.x && value <= domain.y) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  outColor = outColor / 255.;
  return outColor;
}

void main(void) {
  vSampleCount = instanceCounts.a;

  float weight = instanceCounts.r;
  float maxWeight = texture(maxTexture, vec2(0.5)).r;

  float step = weight / maxWeight;
  vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;

  vec2 domain = colorDomain;
  float domainMaxValid = float(colorDomain.y != 0.);
  domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
  vec4 rangeColor = quantizeScale(domain, colorRange, weight);

  float rangeMinMax = float(shouldUseMinMax);
  vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
  vColor = vec4(color.rgb, color.a * opacity);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`;

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts
  var screen_grid_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader

precision highp float;

in vec4 vColor;
in float vSampleCount;

out vec4 fragColor;

void main(void) {
  if (vSampleCount <= 0.0) {
    discard;
  }
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-cell-layer.ts
  var DEFAULT_MINCOLOR = [0, 0, 0, 0];
  var DEFAULT_MAXCOLOR = [0, 255, 0, 255];
  var COLOR_PROPS = ["minColor", "maxColor", "colorRange", "colorDomain"];
  var defaultProps42 = {
    cellSizePixels: { type: "number", value: 100, min: 1 },
    cellMarginPixels: { type: "number", value: 2, min: 0, max: 5 },
    colorDomain: null,
    colorRange: defaultColorRange
  };
  var ScreenGridCellLayer = class extends Layer {
    getShaders() {
      return { vs: screen_grid_layer_vertex_glsl_default, fs: screen_grid_layer_fragment_glsl_default, modules: [picking_default] };
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instancePositions: { size: 3, update: this.calculateInstancePositions },
        instanceCounts: { size: 4, noAlloc: true }
      });
      this.setState({
        model: this._getModel()
      });
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState(params) {
      super.updateState(params);
      const { oldProps, props, changeFlags } = params;
      const attributeManager = this.getAttributeManager();
      if (props.numInstances !== oldProps.numInstances) {
        attributeManager.invalidateAll();
      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {
        attributeManager.invalidate("instancePositions");
      }
      this._updateUniforms(oldProps, props, changeFlags);
    }
    draw({ uniforms }) {
      const { parameters: parameters2, maxTexture } = this.props;
      const minColor = this.props.minColor || DEFAULT_MINCOLOR;
      const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;
      const colorDomain = this.props.colorDomain || [1, 0];
      const model = this.state.model;
      model.setUniforms(uniforms);
      model.setBindings({
        maxTexture
      });
      model.setUniforms({
        minColor,
        maxColor,
        colorDomain
      });
      model.setParameters({
        depthWriteEnabled: false,
        ...parameters2
      });
      model.draw(this.context.renderPass);
    }
    calculateInstancePositions(attribute, { numInstances }) {
      const { width, height } = this.context.viewport;
      const { cellSizePixels } = this.props;
      const numCol = Math.ceil(width / cellSizePixels);
      const { value, size } = attribute;
      for (let i5 = 0; i5 < numInstances; i5++) {
        const x3 = i5 % numCol;
        const y3 = Math.floor(i5 / numCol);
        value[i5 * size + 0] = x3 * cellSizePixels / width * 2 - 1;
        value[i5 * size + 1] = 1 - y3 * cellSizePixels / height * 2;
        value[i5 * size + 2] = 0;
      }
    }
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new Geometry({
          topology: "triangle-list",
          attributes: {
            positions: new Float32Array([
              0,
              0,
              0,
              1,
              0,
              0,
              1,
              1,
              0,
              0,
              0,
              0,
              1,
              1,
              0,
              0,
              1,
              0
            ])
          }
        })
      });
    }
    _shouldUseMinMax() {
      const { minColor, maxColor, colorDomain, colorRange } = this.props;
      if (minColor || maxColor) {
        log_default.deprecated("ScreenGridLayer props: minColor and maxColor", "colorRange, colorDomain")();
        return true;
      }
      if (colorDomain || colorRange) {
        return false;
      }
      return true;
    }
    _updateUniforms(oldProps, props, changeFlags) {
      const model = this.state.model;
      if (COLOR_PROPS.some((key) => oldProps[key] !== props[key])) {
        model.setUniforms({ shouldUseMinMax: this._shouldUseMinMax() });
      }
      if (oldProps.colorRange !== props.colorRange) {
        model.setUniforms({ colorRange: colorRangeToFlatArray(props.colorRange) });
      }
      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
        const { width, height } = this.context.viewport;
        const { cellSizePixels, cellMarginPixels } = this.props;
        const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;
        const cellScale = new Float32Array([
          (cellSizePixels - margin) / width * 2,
          -(cellSizePixels - margin) / height * 2,
          1
        ]);
        model.setUniforms({ cellScale });
      }
    }
  };
  ScreenGridCellLayer.layerName = "ScreenGridCellLayer";
  ScreenGridCellLayer.defaultProps = defaultProps42;

  // ../aggregation-layers/src/utils/prop-utils.ts
  function filterProps(props, filterKeys) {
    const filteredProps = {};
    for (const key in props) {
      if (!filterKeys.includes(key)) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // ../aggregation-layers/src/aggregation-layer.ts
  var AggregationLayer = class extends CompositeLayer {
    initializeAggregationLayer(dimensions) {
      super.initializeState(this.context);
      this.setState({
        ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),
        dimensions
      });
    }
    updateState(opts) {
      super.updateState(opts);
      const { changeFlags } = opts;
      if (changeFlags.extensionsChanged) {
        const shaders = this.getShaders({});
        if (shaders && shaders.defines) {
          shaders.defines.NON_INSTANCED_MODEL = 1;
        }
        this.updateShaders(shaders);
      }
      this._updateAttributes();
    }
    updateAttributes(changedAttributes) {
      this.setState({ changedAttributes });
    }
    getAttributes() {
      return this.getAttributeManager().getAttributes();
    }
    getModuleSettings() {
      const { viewport, mousePosition, device } = this.context;
      const moduleSettings = Object.assign(Object.create(this.props), {
        viewport,
        mousePosition,
        picking: {
          isActive: 0
        },
        devicePixelRatio: device.canvasContext.cssToDeviceRatio()
      });
      return moduleSettings;
    }
    updateShaders(shaders) {
    }
    isAggregationDirty(updateOpts, params = {}) {
      const { props, oldProps, changeFlags } = updateOpts;
      const { compareAll = false, dimension } = params;
      const { ignoreProps } = this.state;
      const { props: dataProps, accessors = [] } = dimension;
      const { updateTriggersChanged } = changeFlags;
      if (changeFlags.dataChanged) {
        return true;
      }
      if (updateTriggersChanged) {
        if (updateTriggersChanged.all) {
          return true;
        }
        for (const accessor of accessors) {
          if (updateTriggersChanged[accessor]) {
            return true;
          }
        }
      }
      if (compareAll) {
        if (changeFlags.extensionsChanged) {
          return true;
        }
        return compareProps({
          oldProps,
          newProps: props,
          ignoreProps,
          propTypes: this.constructor._propTypes
        });
      }
      for (const name13 of dataProps) {
        if (props[name13] !== oldProps[name13]) {
          return true;
        }
      }
      return false;
    }
    isAttributeChanged(name13) {
      const { changedAttributes } = this.state;
      if (!name13) {
        return !isObjectEmpty4(changedAttributes);
      }
      return changedAttributes && changedAttributes[name13] !== void 0;
    }
    _getAttributeManager() {
      return new AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AggregationLayer.layerName = "AggregationLayer";
  function isObjectEmpty4(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // ../aggregation-layers/src/utils/scale-utils.js
  function getScale2(domain, range, scaleFunction) {
    const scale7 = scaleFunction;
    scale7.domain = () => domain;
    scale7.range = () => range;
    return scale7;
  }
  function getQuantizeScale(domain, range) {
    const scaleFunction = (value) => quantizeScale(domain, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function getLinearScale(domain, range) {
    const scaleFunction = (value) => linearScale(domain, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function getQuantileScale(domain, range) {
    const sortedDomain = domain.sort(ascending);
    let i5 = 0;
    const n3 = Math.max(1, range.length);
    const thresholds = new Array(n3 - 1);
    while (++i5 < n3) {
      thresholds[i5 - 1] = threshold(sortedDomain, i5 / n3);
    }
    const scaleFunction = (value) => thresholdsScale(thresholds, range, value);
    scaleFunction.thresholds = () => thresholds;
    return getScale2(domain, range, scaleFunction);
  }
  function ascending(a3, b2) {
    return a3 - b2;
  }
  function threshold(domain, fraction) {
    const domainLength = domain.length;
    if (fraction <= 0 || domainLength < 2) {
      return domain[0];
    }
    if (fraction >= 1) {
      return domain[domainLength - 1];
    }
    const domainFraction = (domainLength - 1) * fraction;
    const lowIndex = Math.floor(domainFraction);
    const low = domain[lowIndex];
    const high = domain[lowIndex + 1];
    return low + (high - low) * (domainFraction - lowIndex);
  }
  function bisectRight(a3, x3) {
    let lo = 0;
    let hi = a3.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (ascending(a3[mid], x3) > 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }
  function thresholdsScale(thresholds, range, value) {
    return range[bisectRight(thresholds, value)];
  }
  function ordinalScale(domain, domainMap, range, value) {
    const key = `${value}`;
    let d2 = domainMap.get(key);
    if (d2 === void 0) {
      d2 = domain.push(value);
      domainMap.set(key, d2);
    }
    return range[(d2 - 1) % range.length];
  }
  function getOrdinalScale(domain, range) {
    const domainMap = /* @__PURE__ */ new Map();
    const uniqueDomain = [];
    for (const d2 of domain) {
      const key = `${d2}`;
      if (!domainMap.has(key)) {
        domainMap.set(key, uniqueDomain.push(d2));
      }
    }
    const scaleFunction = (value) => ordinalScale(uniqueDomain, domainMap, range, value);
    return getScale2(domain, range, scaleFunction);
  }
  function quantizeScale(domain, range, value) {
    const domainRange = domain[1] - domain[0];
    if (domainRange <= 0) {
      log_default.warn("quantizeScale: invalid domain, returning range[0]")();
      return range[0];
    }
    const step = domainRange / range.length;
    const idx = Math.floor((value - domain[0]) / step);
    const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);
    return range[clampIdx];
  }
  function linearScale(domain, range, value) {
    return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
  }
  function notNullOrUndefined(d2) {
    return d2 !== void 0 && d2 !== null;
  }
  function unique(values) {
    const results = [];
    values.forEach((v2) => {
      if (!results.includes(v2) && notNullOrUndefined(v2)) {
        results.push(v2);
      }
    });
    return results;
  }
  function getTruthyValues(data, valueAccessor) {
    const values = typeof valueAccessor === "function" ? data.map(valueAccessor) : data;
    return values.filter(notNullOrUndefined);
  }
  function getQuantileDomain(data, valueAccessor) {
    return getTruthyValues(data, valueAccessor);
  }
  function getOrdinalDomain(data, valueAccessor) {
    return unique(getTruthyValues(data, valueAccessor));
  }
  function clamp3(value, min4, max4) {
    return Math.max(min4, Math.min(max4, value));
  }
  function getScaleFunctionByScaleType(scaleType) {
    switch (scaleType) {
      case "quantize":
        return getQuantizeScale;
      case "linear":
        return getLinearScale;
      case "quantile":
        return getQuantileScale;
      case "ordinal":
        return getOrdinalScale;
      default:
        return getQuantizeScale;
    }
  }

  // ../aggregation-layers/src/utils/bin-sorter.ts
  var defaultGetValue = (points) => points.length;
  var MAX_32_BIT_FLOAT2 = 3402823466e29;
  var defaultGetPoints = (bin) => bin.points;
  var defaultGetIndex = (bin) => bin.index;
  var ascending2 = (a3, b2) => a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
  var defaultProps43 = {
    getValue: defaultGetValue,
    getPoints: defaultGetPoints,
    getIndex: defaultGetIndex,
    filterData: null
  };
  var BinSorter = class {
    constructor(bins = [], props = defaultProps43) {
      this.aggregatedBins = this.getAggregatedBins(bins, props);
      this._updateMinMaxValues();
      this.binMap = this.getBinMap();
    }
    getAggregatedBins(bins, props) {
      const {
        getValue: getValue2 = defaultGetValue,
        getPoints: getPoints2 = defaultGetPoints,
        getIndex = defaultGetIndex,
        filterData
      } = props;
      const hasFilter = typeof filterData === "function";
      const binCount = bins.length;
      const aggregatedBins = [];
      let index2 = 0;
      for (let binIndex = 0; binIndex < binCount; binIndex++) {
        const bin = bins[binIndex];
        const points = getPoints2(bin);
        const i5 = getIndex(bin);
        const filteredPoints = hasFilter ? points.filter(filterData) : points;
        bin.filteredPoints = hasFilter ? filteredPoints : null;
        const value = filteredPoints.length ? getValue2(filteredPoints) : null;
        if (value !== null && value !== void 0) {
          aggregatedBins[index2] = {
            i: Number.isFinite(i5) ? i5 : binIndex,
            value,
            counts: filteredPoints.length
          };
          index2++;
        }
      }
      return aggregatedBins;
    }
    _percentileToIndex(percentileRange) {
      const len4 = this.sortedBins.length;
      if (len4 < 2) {
        return [0, 0];
      }
      const [lower, upper] = percentileRange.map((n3) => clamp3(n3, 0, 100));
      const lowerIdx = Math.ceil(lower / 100 * (len4 - 1));
      const upperIdx = Math.floor(upper / 100 * (len4 - 1));
      return [lowerIdx, upperIdx];
    }
    getBinMap() {
      const binMap = {};
      for (const bin of this.aggregatedBins) {
        binMap[bin.i] = bin;
      }
      return binMap;
    }
    _updateMinMaxValues() {
      let maxCount = 0;
      let maxValue = 0;
      let minValue = MAX_32_BIT_FLOAT2;
      let totalCount = 0;
      for (const x3 of this.aggregatedBins) {
        maxCount = maxCount > x3.counts ? maxCount : x3.counts;
        maxValue = maxValue > x3.value ? maxValue : x3.value;
        minValue = minValue < x3.value ? minValue : x3.value;
        totalCount += x3.counts;
      }
      this.maxCount = maxCount;
      this.maxValue = maxValue;
      this.minValue = minValue;
      this.totalCount = totalCount;
    }
    getValueRange(percentileRange) {
      if (!this.sortedBins) {
        this.sortedBins = this.aggregatedBins.sort((a3, b2) => ascending2(a3.value, b2.value));
      }
      if (!this.sortedBins.length) {
        return [];
      }
      let lowerIdx = 0;
      let upperIdx = this.sortedBins.length - 1;
      if (Array.isArray(percentileRange)) {
        const idxRange = this._percentileToIndex(percentileRange);
        lowerIdx = idxRange[0];
        upperIdx = idxRange[1];
      }
      return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
    }
    getValueDomainByScale(scale7, [lower = 0, upper = 100] = []) {
      if (!this.sortedBins) {
        this.sortedBins = this.aggregatedBins.sort((a3, b2) => ascending2(a3.value, b2.value));
      }
      if (!this.sortedBins.length) {
        return [];
      }
      const indexEdge = this._percentileToIndex([lower, upper]);
      return this._getScaleDomain(scale7, indexEdge);
    }
    _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {
      const bins = this.sortedBins;
      switch (scaleType) {
        case "quantize":
        case "linear":
          return [bins[lowerIdx].value, bins[upperIdx].value];
        case "quantile":
          return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), (d2) => d2.value);
        case "ordinal":
          return getOrdinalDomain(bins, (d2) => d2.value);
        default:
          return [bins[lowerIdx].value, bins[upperIdx].value];
      }
    }
  };

  // ../aggregation-layers/src/utils/grid-aggregation-utils.ts
  var R_EARTH = 6378e3;
  function toFinite(n3) {
    return Number.isFinite(n3) ? n3 : 0;
  }
  function getBoundingBox3(attributes, vertexCount) {
    const positions = attributes.positions.value;
    let yMin = Infinity;
    let yMax = -Infinity;
    let xMin = Infinity;
    let xMax = -Infinity;
    let y3;
    let x3;
    for (let i5 = 0; i5 < vertexCount; i5++) {
      x3 = positions[i5 * 3];
      y3 = positions[i5 * 3 + 1];
      yMin = y3 < yMin ? y3 : yMin;
      yMax = y3 > yMax ? y3 : yMax;
      xMin = x3 < xMin ? x3 : xMin;
      xMax = x3 > xMax ? x3 : xMax;
    }
    const boundingBox = {
      xMin: toFinite(xMin),
      xMax: toFinite(xMax),
      yMin: toFinite(yMin),
      yMax: toFinite(yMax)
    };
    return boundingBox;
  }
  function getTranslation2(boundingBox, gridOffset, coordinateSystem, viewport) {
    const { width, height } = viewport;
    const worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];
    log_default.assert(
      coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.DEFAULT
    );
    const { xMin, yMin } = boundingBox;
    return [
      -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),
      -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])
    ];
  }
  function alignToCell(inValue, cellSize) {
    const sign2 = inValue < 0 ? -1 : 1;
    let value = sign2 < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
    value = Math.floor(value / cellSize) * cellSize;
    return value * sign2;
  }
  function getGridOffset(boundingBox, cellSize, convertToMeters = true) {
    if (!convertToMeters) {
      return { xOffset: cellSize, yOffset: cellSize };
    }
    const { yMin, yMax } = boundingBox;
    const centerLat = (yMin + yMax) / 2;
    return calculateGridLatLonOffset(cellSize, centerLat);
  }
  function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {
    const gridOffset = getGridOffset(
      boundingBox,
      cellSize,
      coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN
    );
    const translation = getTranslation2(boundingBox, gridOffset, coordinateSystem, viewport);
    const { xMin, yMin, xMax, yMax } = boundingBox;
    const width = xMax - xMin + gridOffset.xOffset;
    const height = yMax - yMin + gridOffset.yOffset;
    const numCol = Math.ceil(width / gridOffset.xOffset);
    const numRow = Math.ceil(height / gridOffset.yOffset);
    return { gridOffset, translation, width, height, numCol, numRow };
  }
  function calculateGridLatLonOffset(cellSize, latitude) {
    const yOffset = calculateLatOffset(cellSize);
    const xOffset = calculateLonOffset(latitude, cellSize);
    return { yOffset, xOffset };
  }
  function calculateLatOffset(dy) {
    return dy / R_EARTH * (180 / Math.PI);
  }
  function calculateLonOffset(lat, dx) {
    return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
  }

  // ../aggregation-layers/src/cpu-grid-layer/grid-aggregator.ts
  function pointToDensityGridDataCPU(props, aggregationParams) {
    const hashInfo = pointsToGridHashing(props, aggregationParams);
    const result = getGridLayerDataFromGridHash(hashInfo);
    return {
      gridHash: hashInfo.gridHash,
      gridOffset: hashInfo.gridOffset,
      data: result
    };
  }
  function pointsToGridHashing(props, aggregationParams) {
    const { data = [], cellSize } = props;
    const { attributes, viewport, projectPoints, numInstances } = aggregationParams;
    const positions = attributes.positions.value;
    const { size } = attributes.positions.getAccessor();
    const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);
    const offsets = aggregationParams.posOffset || [180, 90];
    const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);
    if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
      return { gridHash: {}, gridOffset, offsets: [0, 0] };
    }
    const { width, height } = viewport;
    const numCol = Math.ceil(width / gridOffset.xOffset);
    const numRow = Math.ceil(height / gridOffset.yOffset);
    const gridHash = {};
    const { iterable, objectInfo } = createIterable(data);
    const position = new Array(3);
    for (const pt of iterable) {
      objectInfo.index++;
      position[0] = positions[objectInfo.index * size];
      position[1] = positions[objectInfo.index * size + 1];
      position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;
      const [x3, y3] = projectPoints ? viewport.project(position) : position;
      if (Number.isFinite(x3) && Number.isFinite(y3)) {
        const yIndex = Math.floor((y3 + offsets[1]) / gridOffset.yOffset);
        const xIndex = Math.floor((x3 + offsets[0]) / gridOffset.xOffset);
        if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {
          const key = `${yIndex}-${xIndex}`;
          gridHash[key] = gridHash[key] || { count: 0, points: [], lonIdx: xIndex, latIdx: yIndex };
          gridHash[key].count += 1;
          gridHash[key].points.push({
            source: pt,
            index: objectInfo.index
          });
        }
      }
    }
    return { gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1] };
  }
  function getGridLayerDataFromGridHash({
    gridHash,
    gridOffset,
    offsets
  }) {
    const data = new Array(Object.keys(gridHash).length);
    let i5 = 0;
    for (const key in gridHash) {
      const idxs = key.split("-");
      const latIdx = parseInt(idxs[0], 10);
      const lonIdx = parseInt(idxs[1], 10);
      const index2 = i5++;
      data[index2] = {
        index: index2,
        position: [
          offsets[0] + gridOffset.xOffset * lonIdx,
          offsets[1] + gridOffset.yOffset * latIdx
        ],
        ...gridHash[key]
      };
    }
    return data;
  }
  function getPositionBoundingBox(positionAttribute, numInstance) {
    const positions = positionAttribute.value;
    const { size } = positionAttribute.getAccessor();
    let yMin = Infinity;
    let yMax = -Infinity;
    let xMin = Infinity;
    let xMax = -Infinity;
    let y3;
    let x3;
    for (let i5 = 0; i5 < numInstance; i5++) {
      x3 = positions[i5 * size];
      y3 = positions[i5 * size + 1];
      if (Number.isFinite(x3) && Number.isFinite(y3)) {
        yMin = y3 < yMin ? y3 : yMin;
        yMax = y3 > yMax ? y3 : yMax;
        xMin = x3 < xMin ? x3 : xMin;
        xMax = x3 > xMax ? x3 : xMax;
      }
    }
    return { xMin, xMax, yMin, yMax };
  }

  // ../aggregation-layers/src/grid-aggregation-layer.ts
  var GridAggregationLayer = class extends AggregationLayer {
    initializeAggregationLayer({ dimensions }) {
      super.initializeAggregationLayer(dimensions);
      this.setState({
        layerData: {},
        gpuGridAggregator: new GPUGridAggregator(this.context.device, {
          id: `${this.id}-gpu-aggregator`
        }),
        cpuGridAggregator: pointToDensityGridDataCPU
      });
    }
    updateState(opts) {
      super.updateState(opts);
      this.updateAggregationState(opts);
      const { aggregationDataDirty, aggregationWeightsDirty, gpuAggregation } = this.state;
      if (this.getNumInstances() <= 0) {
        return;
      }
      let aggregationDirty = false;
      if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {
        this._updateAggregation(opts);
        aggregationDirty = true;
      }
      if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {
        this._updateWeightBins();
        this._uploadAggregationResults();
        aggregationDirty = true;
      }
      this.setState({ aggregationDirty });
    }
    finalizeState(context) {
      const { count: count2 } = this.state.weights;
      if (count2 && count2.aggregationBuffer) {
        count2.aggregationBuffer.delete();
      }
      this.state.gpuGridAggregator?.delete();
      super.finalizeState(context);
    }
    updateShaders(shaders) {
      if (this.state.gpuAggregation) {
        this.state.gpuGridAggregator.updateShaders(shaders);
      }
    }
    updateAggregationState(opts) {
      log_default.assert(false);
    }
    allocateResources(numRow, numCol) {
      if (this.state.numRow !== numRow || this.state.numCol !== numCol) {
        const dataBytes = numCol * numRow * 4 * 4;
        const { weights } = this.state;
        for (const name13 in weights) {
          const weight = weights[name13];
          if (weight.aggregationBuffer) {
            weight.aggregationBuffer.delete();
          }
          weight.aggregationBuffer = this.context.device.createBuffer({
            byteLength: dataBytes,
            accessor: {
              size: 4,
              type: GLEnum.FLOAT,
              divisor: 1
            }
          });
        }
      }
    }
    updateResults({ aggregationData, maxMinData, maxData, minData }) {
      const { count: count2 } = this.state.weights;
      if (count2) {
        count2.aggregationData = aggregationData;
        count2.maxMinData = maxMinData;
        count2.maxData = maxData;
        count2.minData = minData;
      }
    }
    _updateAggregation(opts) {
      const {
        cpuGridAggregator,
        gpuGridAggregator,
        gridOffset,
        posOffset,
        translation = [0, 0],
        scaling = [0, 0, 0],
        boundingBox,
        projectPoints,
        gpuAggregation,
        numCol,
        numRow
      } = this.state;
      const { props } = opts;
      const { viewport } = this.context;
      const attributes = this.getAttributes();
      const vertexCount = this.getNumInstances();
      if (!gpuAggregation) {
        const result = cpuGridAggregator(props, {
          gridOffset,
          projectPoints,
          attributes,
          viewport,
          posOffset,
          boundingBox
        });
        this.setState({
          layerData: result
        });
      } else {
        const { weights } = this.state;
        gpuGridAggregator.run({
          weights,
          cellSize: [gridOffset.xOffset, gridOffset.yOffset],
          numCol,
          numRow,
          translation,
          scaling,
          vertexCount,
          projectPoints,
          attributes,
          moduleSettings: this.getModuleSettings()
        });
      }
    }
    _updateWeightBins() {
      const { getValue: getValue2 } = this.state;
      const sortedBins = new BinSorter(this.state.layerData.data || [], { getValue: getValue2 });
      this.setState({ sortedBins });
    }
    _uploadAggregationResults() {
      const { numCol, numRow } = this.state;
      const { data } = this.state.layerData;
      const { aggregatedBins, minValue, maxValue, totalCount } = this.state.sortedBins;
      const ELEMENTCOUNT = 4;
      const aggregationSize = numCol * numRow * ELEMENTCOUNT;
      const aggregationData = new Float32Array(aggregationSize).fill(0);
      for (const bin of aggregatedBins) {
        const { lonIdx, latIdx } = data[bin.i];
        const { value, counts } = bin;
        const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;
        aggregationData[cellIndex] = value;
        aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;
      }
      const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);
      const maxData = new Float32Array([maxValue, 0, 0, totalCount]);
      const minData = new Float32Array([minValue, 0, 0, totalCount]);
      this.updateResults({ aggregationData, maxMinData, maxData, minData });
    }
  };
  GridAggregationLayer.layerName = "GridAggregationLayer";

  // ../aggregation-layers/src/screen-grid-layer/screen-grid-layer.ts
  var defaultProps44 = {
    ...ScreenGridCellLayer.defaultProps,
    getPosition: { type: "accessor", value: (d2) => d2.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: false,
    aggregation: "SUM"
  };
  var POSITION_ATTRIBUTE_NAME = "positions";
  var DIMENSIONS = {
    data: {
      props: ["cellSizePixels"]
    },
    weights: {
      props: ["aggregation"],
      accessors: ["getWeight"]
    }
  };
  var ScreenGridLayer = class extends GridAggregationLayer {
    initializeState() {
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS,
        getCellSize: (props) => props.cellSizePixels
      });
      const weights = {
        count: {
          size: 1,
          operation: AGGREGATION_OPERATION.SUM,
          needMax: true,
          maxTexture: getFloatTexture(this.context.device, { id: `${this.id}-max-texture` })
        }
      };
      this.setState({
        supported: true,
        projectPoints: true,
        weights,
        subLayerData: { attributes: {} },
        maxTexture: weights.count.maxTexture,
        positionAttributeName: "positions",
        posOffset: [0, 0],
        translation: [1, -1]
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME]: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        count: { size: 3, accessor: "getWeight" }
      });
    }
    shouldUpdateState({ changeFlags }) {
      return this.state.supported && changeFlags.somethingChanged;
    }
    updateState(opts) {
      super.updateState(opts);
    }
    renderLayers() {
      if (!this.state.supported) {
        return [];
      }
      const { maxTexture, numRow, numCol, weights } = this.state;
      const { updateTriggers } = this.props;
      const { aggregationBuffer } = weights.count;
      const CellLayerClass = this.getSubLayerClass("cells", ScreenGridCellLayer);
      return new CellLayerClass(
        this.props,
        this.getSubLayerProps({
          id: "cell-layer",
          updateTriggers
        }),
        {
          data: { attributes: { instanceCounts: aggregationBuffer } },
          maxTexture,
          numInstances: numRow * numCol
        }
      );
    }
    finalizeState(context) {
      super.finalizeState(context);
      const { aggregationBuffer, maxBuffer, maxTexture } = this.state;
      aggregationBuffer?.delete();
      maxBuffer?.delete();
      maxTexture?.delete();
    }
    getPickingInfo({ info }) {
      const { index: index2 } = info;
      if (index2 >= 0) {
        const { gpuGridAggregator, gpuAggregation, weights } = this.state;
        const aggregationResults = gpuAggregation ? gpuGridAggregator.getData("count") : weights.count;
        info.object = GPUGridAggregator.getAggregationData({
          pixelIndex: index2,
          ...aggregationResults
        });
      }
      return info;
    }
    updateResults({ aggregationData, maxData }) {
      const { count: count2 } = this.state.weights;
      count2.aggregationData = aggregationData;
      count2.aggregationBuffer.write(aggregationData);
      count2.maxData = maxData;
      count2.maxTexture.setImageData({ data: maxData });
    }
    updateAggregationState(opts) {
      const cellSize = opts.props.cellSizePixels;
      const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;
      const { viewportChanged } = opts.changeFlags;
      let gpuAggregation = opts.props.gpuAggregation;
      if (this.state.gpuAggregation !== opts.props.gpuAggregation) {
        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {
          log_default.warn("GPU Grid Aggregation not supported, falling back to CPU")();
          gpuAggregation = false;
        }
      }
      const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
      this.setState({
        gpuAggregation
      });
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);
      const { dimensions } = this.state;
      const { data, weights } = dimensions;
      const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {
        compareAll: gpuAggregation,
        dimension: data
      });
      const aggregationWeightsDirty = this.isAggregationDirty(opts, { dimension: weights });
      this.setState({
        aggregationDataDirty,
        aggregationWeightsDirty
      });
      const { viewport } = this.context;
      if (viewportChanged || cellSizeChanged) {
        const { width, height } = viewport;
        const numCol = Math.ceil(width / cellSize);
        const numRow = Math.ceil(height / cellSize);
        this.allocateResources(numRow, numCol);
        this.setState({
          scaling: [width / 2, -height / 2, 1],
          gridOffset: { xOffset: cellSize, yOffset: cellSize },
          width,
          height,
          numCol,
          numRow
        });
      }
      if (aggregationWeightsDirty) {
        this._updateAccessors(opts);
      }
      if (aggregationDataDirty || aggregationWeightsDirty) {
        this._resetResults();
      }
    }
    _updateAccessors(opts) {
      const { getWeight, aggregation, data } = opts.props;
      const { count: count2 } = this.state.weights;
      if (count2) {
        count2.getWeight = getWeight;
        count2.operation = AGGREGATION_OPERATION[aggregation];
      }
      this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });
    }
    _resetResults() {
      const { count: count2 } = this.state.weights;
      if (count2) {
        count2.aggregationData = null;
      }
    }
  };
  ScreenGridLayer.layerName = "ScreenGridLayer";
  ScreenGridLayer.defaultProps = defaultProps44;

  // ../aggregation-layers/src/utils/cpu-aggregator.ts
  function noop5() {
  }
  var dimensionSteps = ["getBins", "getDomain", "getScaleFunc"];
  var defaultDimensions = [
    {
      key: "fillColor",
      accessor: "getFillColor",
      pickingInfo: "colorValue",
      getBins: {
        triggers: {
          value: {
            prop: "getColorValue",
            updateTrigger: "getColorValue"
          },
          weight: {
            prop: "getColorWeight",
            updateTrigger: "getColorWeight"
          },
          aggregation: {
            prop: "colorAggregation"
          },
          filterData: {
            prop: "_filterData",
            updateTrigger: "_filterData"
          }
        }
      },
      getDomain: {
        triggers: {
          lowerPercentile: {
            prop: "lowerPercentile"
          },
          upperPercentile: {
            prop: "upperPercentile"
          },
          scaleType: {
            prop: "colorScaleType"
          }
        }
      },
      getScaleFunc: {
        triggers: {
          domain: { prop: "colorDomain" },
          range: { prop: "colorRange" }
        },
        onSet: {
          props: "onSetColorDomain"
        }
      },
      nullValue: [0, 0, 0, 0]
    },
    {
      key: "elevation",
      accessor: "getElevation",
      pickingInfo: "elevationValue",
      getBins: {
        triggers: {
          value: {
            prop: "getElevationValue",
            updateTrigger: "getElevationValue"
          },
          weight: {
            prop: "getElevationWeight",
            updateTrigger: "getElevationWeight"
          },
          aggregation: {
            prop: "elevationAggregation"
          },
          filterData: {
            prop: "_filterData",
            updateTrigger: "_filterData"
          }
        }
      },
      getDomain: {
        triggers: {
          lowerPercentile: {
            prop: "elevationLowerPercentile"
          },
          upperPercentile: {
            prop: "elevationUpperPercentile"
          },
          scaleType: {
            prop: "elevationScaleType"
          }
        }
      },
      getScaleFunc: {
        triggers: {
          domain: { prop: "elevationDomain" },
          range: { prop: "elevationRange" }
        },
        onSet: {
          props: "onSetElevationDomain"
        }
      },
      nullValue: -1
    }
  ];
  var defaultGetCellSize = (props) => props.cellSize;
  var CPUAggregator = class {
    constructor(opts) {
      this.state = {
        layerData: {
          data: void 0
        },
        dimensions: {}
      };
      this.changeFlags = {};
      this.dimensionUpdaters = {};
      this._getCellSize = opts.getCellSize || defaultGetCellSize;
      this._getAggregator = opts.getAggregator;
      this._addDimension(opts.dimensions || defaultDimensions);
    }
    static defaultDimensions() {
      return defaultDimensions;
    }
    updateState(opts, aggregationParams) {
      const { oldProps, props, changeFlags } = opts;
      this.updateGetValueFuncs(oldProps, props, changeFlags);
      const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);
      let aggregationDirty = false;
      if (changeFlags.dataChanged || reprojectNeeded) {
        this.getAggregatedData(props, aggregationParams);
        aggregationDirty = true;
      } else {
        const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];
        dimensionChanges.forEach((f4) => typeof f4 === "function" && f4());
        aggregationDirty = true;
      }
      this.setState({ aggregationDirty });
      return this.state;
    }
    setState(updateObject) {
      this.state = { ...this.state, ...updateObject };
    }
    setDimensionState(key, updateObject) {
      this.setState({
        dimensions: {
          ...this.state.dimensions,
          [key]: { ...this.state.dimensions[key], ...updateObject }
        }
      });
    }
    normalizeResult(result = {}) {
      if (result.hexagons) {
        return { data: result.hexagons, ...result };
      } else if (result.layerData) {
        return { data: result.layerData, ...result };
      }
      return result;
    }
    getAggregatedData(props, aggregationParams) {
      const aggregator = this._getAggregator(props);
      const result = aggregator(props, aggregationParams);
      this.setState({
        layerData: this.normalizeResult(result)
      });
      this.changeFlags = {
        layerData: true
      };
      this.getSortedBins(props);
    }
    updateGetValueFuncs(oldProps, props, changeFlags) {
      for (const key in this.dimensionUpdaters) {
        const { value, weight, aggregation } = this.dimensionUpdaters[key].getBins.triggers;
        let getValue2 = props[value.prop];
        const getValueChanged = this.needUpdateDimensionStep(
          this.dimensionUpdaters[key].getBins,
          oldProps,
          props,
          changeFlags
        );
        if (getValueChanged) {
          if (getValue2) {
            getValue2 = wrapGetValueFunc(getValue2, { data: props.data });
          } else {
            getValue2 = getValueFunc(props[aggregation.prop], props[weight.prop], { data: props.data });
          }
        }
        if (getValue2) {
          this.setDimensionState(key, { getValue: getValue2 });
        }
      }
    }
    needsReProjectPoints(oldProps, props, changeFlags) {
      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);
    }
    addDimension(dimensions) {
      this._addDimension(dimensions);
    }
    _addDimension(dimensions = []) {
      dimensions.forEach((dimension) => {
        const { key } = dimension;
        this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);
        this.state.dimensions[key] = {
          getValue: null,
          domain: null,
          sortedBins: null,
          scaleFunc: noop5
        };
      });
    }
    getDimensionUpdaters({ key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue }) {
      return {
        key,
        accessor,
        pickingInfo,
        getBins: { updater: this.getDimensionSortedBins.bind(this), ...getBins },
        getDomain: { updater: this.getDimensionValueDomain.bind(this), ...getDomain },
        getScaleFunc: { updater: this.getDimensionScale.bind(this), ...getScaleFunc },
        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)
      };
    }
    needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {
      return Object.values(dimensionStep.triggers).some((item) => {
        if (item.updateTrigger) {
          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);
        }
        return oldProps[item.prop] !== props[item.prop];
      });
    }
    getDimensionChanges(oldProps, props, changeFlags) {
      const updaters = [];
      for (const key in this.dimensionUpdaters) {
        const needUpdate = dimensionSteps.find(
          (step) => this.needUpdateDimensionStep(
            this.dimensionUpdaters[key][step],
            oldProps,
            props,
            changeFlags
          )
        );
        if (needUpdate) {
          updaters.push(
            this.dimensionUpdaters[key][needUpdate].updater.bind(
              this,
              props,
              this.dimensionUpdaters[key]
            )
          );
        }
      }
      return updaters.length ? updaters : null;
    }
    getUpdateTriggers(props) {
      const _updateTriggers = props.updateTriggers || {};
      const updateTriggers = {};
      for (const key in this.dimensionUpdaters) {
        const { accessor } = this.dimensionUpdaters[key];
        updateTriggers[accessor] = {};
        dimensionSteps.forEach((step) => {
          Object.values(this.dimensionUpdaters[key][step].triggers).forEach(
            ({ prop, updateTrigger }) => {
              if (updateTrigger) {
                const fromProp = _updateTriggers[updateTrigger];
                if (typeof fromProp === "object" && !Array.isArray(fromProp)) {
                  Object.assign(updateTriggers[accessor], fromProp);
                } else if (fromProp !== void 0) {
                  updateTriggers[accessor][prop] = fromProp;
                }
              } else {
                updateTriggers[accessor][prop] = props[prop];
              }
            }
          );
        });
      }
      return updateTriggers;
    }
    getSortedBins(props) {
      for (const key in this.dimensionUpdaters) {
        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);
      }
    }
    getDimensionSortedBins(props, dimensionUpdater) {
      const { key } = dimensionUpdater;
      const { getValue: getValue2 } = this.state.dimensions[key];
      const sortedBins = new BinSorter(this.state.layerData.data || [], {
        getValue: getValue2,
        filterData: props._filterData
      });
      this.setDimensionState(key, { sortedBins });
      this.getDimensionValueDomain(props, dimensionUpdater);
    }
    getDimensionValueDomain(props, dimensionUpdater) {
      const { getDomain, key } = dimensionUpdater;
      const {
        triggers: { lowerPercentile, upperPercentile, scaleType }
      } = getDomain;
      const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(
        props[scaleType.prop],
        [props[lowerPercentile.prop], props[upperPercentile.prop]]
      );
      this.setDimensionState(key, { valueDomain });
      this.getDimensionScale(props, dimensionUpdater);
    }
    getDimensionScale(props, dimensionUpdater) {
      const { key, getScaleFunc, getDomain } = dimensionUpdater;
      const { domain, range } = getScaleFunc.triggers;
      const { scaleType } = getDomain.triggers;
      const { onSet } = getScaleFunc;
      const dimensionRange = props[range.prop];
      const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
      const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);
      const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);
      if (typeof onSet === "object" && typeof props[onSet.props] === "function") {
        props[onSet.props](scaleFunc.domain());
      }
      this.setDimensionState(key, { scaleFunc });
    }
    getSubLayerDimensionAttribute(key, nullValue) {
      return (cell) => {
        const { sortedBins, scaleFunc } = this.state.dimensions[key];
        const bin = sortedBins.binMap[cell.index];
        if (bin && bin.counts === 0) {
          return nullValue;
        }
        const cv = bin && bin.value;
        const domain = scaleFunc.domain();
        const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];
        return isValueInDomain ? scaleFunc(cv) : nullValue;
      };
    }
    getSubLayerAccessors(props) {
      const accessors = {};
      for (const key in this.dimensionUpdaters) {
        const { accessor } = this.dimensionUpdaters[key];
        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);
      }
      return accessors;
    }
    getPickingInfo({ info }) {
      const isPicked = info.picked && info.index > -1;
      let object = null;
      if (isPicked) {
        const cell = this.state.layerData.data[info.index];
        const binInfo = {};
        for (const key in this.dimensionUpdaters) {
          const { pickingInfo } = this.dimensionUpdaters[key];
          const { sortedBins } = this.state.dimensions[key];
          const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
          binInfo[pickingInfo] = value;
        }
        object = Object.assign(binInfo, cell, {
          points: cell.filteredPoints || cell.points
        });
      }
      info.picked = Boolean(object);
      info.object = object;
      return info;
    }
    getAccessor(dimensionKey) {
      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
        return noop5;
      }
      return this.dimensionUpdaters[dimensionKey].attributeAccessor;
    }
  };

  // ../aggregation-layers/src/cpu-grid-layer/cpu-grid-layer.ts
  function nop() {
  }
  var defaultProps45 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: nop,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationScaleType: "linear",
    onSetElevationDomain: nop,
    gridAggregator: pointToDensityGridDataCPU,
    cellSize: { type: "number", min: 0, max: 1e3, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    extruded: false,
    material: true,
    _filterData: { type: "function", value: null, optional: true }
  };
  var CPUGridLayer = class extends AggregationLayer {
    initializeState() {
      const cpuAggregator = new CPUAggregator({
        getAggregator: (props) => props.gridAggregator,
        getCellSize: (props) => props.cellSize
      });
      this.state = {
        cpuAggregator,
        aggregatorState: cpuAggregator.state
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: { size: 3, type: "float64", accessor: "getPosition" }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      this.setState({
        aggregatorState: this.state.cpuAggregator.updateState(opts, {
          viewport: this.context.viewport,
          attributes: this.getAttributes(),
          numInstances: this.getNumInstances()
        })
      });
    }
    getPickingInfo({ info }) {
      return this.state.cpuAggregator.getPickingInfo({ info });
    }
    _onGetSublayerColor(cell) {
      return this.state.cpuAggregator.getAccessor("fillColor")(cell);
    }
    _onGetSublayerElevation(cell) {
      return this.state.cpuAggregator.getAccessor("elevation")(cell);
    }
    _getSublayerUpdateTriggers() {
      return this.state.cpuAggregator.getUpdateTriggers(this.props);
    }
    renderLayers() {
      const { elevationScale, extruded, cellSize, coverage, material, transitions } = this.props;
      const { cpuAggregator } = this.state;
      const SubLayerClass = this.getSubLayerClass("grid-cell", GridCellLayer);
      const updateTriggers = this._getSublayerUpdateTriggers();
      return new SubLayerClass(
        {
          cellSize,
          coverage,
          material,
          elevationScale,
          extruded,
          getFillColor: this._onGetSublayerColor.bind(this),
          getElevation: this._onGetSublayerElevation.bind(this),
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          }
        },
        this.getSubLayerProps({
          id: "grid-cell",
          updateTriggers
        }),
        {
          data: cpuAggregator.state.layerData.data
        }
      );
    }
  };
  CPUGridLayer.layerName = "CPUGridLayer";
  CPUGridLayer.defaultProps = defaultProps45;

  // ../../node_modules/d3-hexbin/src/hexbin.js
  var thirdPi = Math.PI / 3;
  var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];
  function pointX(d2) {
    return d2[0];
  }
  function pointY(d2) {
    return d2[1];
  }
  function hexbin_default() {
    var x0 = 0, y0 = 0, x1 = 1, y1 = 1, x3 = pointX, y3 = pointY, r3, dx, dy;
    function hexbin(points) {
      var binsById = {}, bins = [], i5, n3 = points.length;
      for (i5 = 0; i5 < n3; ++i5) {
        if (isNaN(px = +x3.call(null, point = points[i5], i5, points)) || isNaN(py = +y3.call(null, point, i5, points)))
          continue;
        var point, px, py, pj = Math.round(py = py / dy), pi = Math.round(px = px / dx - (pj & 1) / 2), py1 = py - pj;
        if (Math.abs(py1) * 3 > 1) {
          var px1 = px - pi, pi2 = pi + (px < pi ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi2, py2 = py - pj2;
          if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2)
            pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
        }
        var id = pi + "-" + pj, bin = binsById[id];
        if (bin)
          bin.push(point);
        else {
          bins.push(bin = binsById[id] = [point]);
          bin.x = (pi + (pj & 1) / 2) * dx;
          bin.y = pj * dy;
        }
      }
      return bins;
    }
    function hexagon(radius) {
      var x02 = 0, y02 = 0;
      return angles.map(function(angle3) {
        var x12 = Math.sin(angle3) * radius, y12 = -Math.cos(angle3) * radius, dx2 = x12 - x02, dy2 = y12 - y02;
        x02 = x12, y02 = y12;
        return [dx2, dy2];
      });
    }
    hexbin.hexagon = function(radius) {
      return "m" + hexagon(radius == null ? r3 : +radius).join("l") + "z";
    };
    hexbin.centers = function() {
      var centers = [], j2 = Math.round(y0 / dy), i5 = Math.round(x0 / dx);
      for (var y4 = j2 * dy; y4 < y1 + r3; y4 += dy, ++j2) {
        for (var x4 = i5 * dx + (j2 & 1) * dx / 2; x4 < x1 + dx / 2; x4 += dx) {
          centers.push([x4, y4]);
        }
      }
      return centers;
    };
    hexbin.mesh = function() {
      var fragment = hexagon(r3).slice(0, 4).join("l");
      return hexbin.centers().map(function(p3) {
        return "M" + p3 + "m" + fragment;
      }).join("");
    };
    hexbin.x = function(_) {
      return arguments.length ? (x3 = _, hexbin) : x3;
    };
    hexbin.y = function(_) {
      return arguments.length ? (y3 = _, hexbin) : y3;
    };
    hexbin.radius = function(_) {
      return arguments.length ? (r3 = +_, dx = r3 * 2 * Math.sin(thirdPi), dy = r3 * 1.5, hexbin) : r3;
    };
    hexbin.size = function(_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
    };
    hexbin.extent = function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
    };
    return hexbin.radius(1);
  }

  // ../aggregation-layers/src/hexagon-layer/hexagon-aggregator.ts
  function pointToHexbin(props, aggregationParams) {
    const { data, radius } = props;
    const { viewport, attributes } = aggregationParams;
    const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;
    const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);
    const screenPoints = [];
    const { iterable, objectInfo } = createIterable(data);
    const positions = attributes.positions.value;
    const { size } = attributes.positions.getAccessor();
    for (const object of iterable) {
      objectInfo.index++;
      const posIndex = objectInfo.index * size;
      const position = [positions[posIndex], positions[posIndex + 1]];
      const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);
      if (arrayIsFinite) {
        screenPoints.push({
          screenCoord: viewport.projectFlat(position),
          source: object,
          index: objectInfo.index
        });
      } else {
        log_default.warn("HexagonLayer: invalid position")();
      }
    }
    const newHexbin = hexbin_default().radius(radiusCommon).x((d2) => d2.screenCoord[0]).y((d2) => d2.screenCoord[1]);
    const hexagonBins = newHexbin(screenPoints);
    return {
      hexagons: hexagonBins.map((hex, index2) => ({
        position: viewport.unprojectFlat([hex.x, hex.y]),
        points: hex,
        index: index2
      })),
      radiusCommon
    };
  }
  function getPointsCenter(data, aggregationParams) {
    const { attributes } = aggregationParams;
    const positions = attributes.positions.value;
    const { size } = attributes.positions.getAccessor();
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let i5;
    for (i5 = 0; i5 < size * data.length; i5 += size) {
      const x3 = positions[i5];
      const y3 = positions[i5 + 1];
      const arrayIsFinite = Number.isFinite(x3) && Number.isFinite(y3);
      if (arrayIsFinite) {
        minX = Math.min(x3, minX);
        maxX = Math.max(x3, maxX);
        minY = Math.min(y3, minY);
        maxY = Math.max(y3, maxY);
      }
    }
    return [minX, minY, maxX, maxY].every(Number.isFinite) ? [(minX + maxX) / 2, (minY + maxY) / 2] : null;
  }
  function getRadiusInCommon(radius, viewport, center) {
    const { unitsPerMeter: unitsPerMeter2 } = viewport.getDistanceScales(center);
    return radius * unitsPerMeter2[0];
  }

  // ../aggregation-layers/src/hexagon-layer/hexagon-layer.ts
  function nop2() {
  }
  var defaultProps46 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", value: 0, min: 0, max: 100 },
    upperPercentile: { type: "number", value: 100, min: 0, max: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: nop2,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationLowerPercentile: { type: "number", value: 0, min: 0, max: 100 },
    elevationUpperPercentile: { type: "number", value: 100, min: 0, max: 100 },
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationScaleType: "linear",
    onSetElevationDomain: nop2,
    radius: { type: "number", value: 1e3, min: 1 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    extruded: false,
    hexagonAggregator: pointToHexbin,
    getPosition: { type: "accessor", value: (x3) => x3.position },
    material: true,
    _filterData: { type: "function", value: null, optional: true }
  };
  var HexagonLayer = class extends AggregationLayer {
    initializeState() {
      const cpuAggregator = new CPUAggregator({
        getAggregator: (props) => props.hexagonAggregator,
        getCellSize: (props) => props.radius
      });
      this.state = {
        cpuAggregator,
        aggregatorState: cpuAggregator.state,
        vertices: null
      };
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: { size: 3, type: "float64", accessor: "getPosition" }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      if (opts.changeFlags.propsOrDataChanged) {
        const aggregatorState = this.state.cpuAggregator.updateState(opts, {
          viewport: this.context.viewport,
          attributes: this.getAttributes()
        });
        if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {
          const { hexagonVertices } = aggregatorState.layerData || {};
          this.setState({
            vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)
          });
        }
        this.setState({
          aggregatorState
        });
      }
    }
    convertLatLngToMeterOffset(hexagonVertices) {
      const { viewport } = this.context;
      if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {
        const vertex0 = hexagonVertices[0];
        const vertex3 = hexagonVertices[3];
        const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];
        const centroidFlat = viewport.projectFlat(centroid);
        const { metersPerUnit } = viewport.getDistanceScales(centroid);
        const vertices = hexagonVertices.map((vt) => {
          const vtFlat = viewport.projectFlat(vt);
          return [
            (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],
            (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]
          ];
        });
        return vertices;
      }
      log_default.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")();
      return null;
    }
    getPickingInfo({ info }) {
      return this.state.cpuAggregator.getPickingInfo({ info });
    }
    _onGetSublayerColor(cell) {
      return this.state.cpuAggregator.getAccessor("fillColor")(cell);
    }
    _onGetSublayerElevation(cell) {
      return this.state.cpuAggregator.getAccessor("elevation")(cell);
    }
    _getSublayerUpdateTriggers() {
      return this.state.cpuAggregator.getUpdateTriggers(this.props);
    }
    renderLayers() {
      const { elevationScale, extruded, coverage, material, transitions } = this.props;
      const { aggregatorState, vertices } = this.state;
      const SubLayerClass = this.getSubLayerClass("hexagon-cell", ColumnLayer);
      const updateTriggers = this._getSublayerUpdateTriggers();
      const geometry = vertices ? { vertices, radius: 1 } : {
        radius: aggregatorState.layerData.radiusCommon || 1,
        radiusUnits: "common",
        angle: 90
      };
      return new SubLayerClass(
        {
          ...geometry,
          diskResolution: 6,
          elevationScale,
          extruded,
          coverage,
          material,
          getFillColor: this._onGetSublayerColor.bind(this),
          getElevation: this._onGetSublayerElevation.bind(this),
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          }
        },
        this.getSubLayerProps({
          id: "hexagon-cell",
          updateTriggers
        }),
        {
          data: aggregatorState.layerData.data
        }
      );
    }
  };
  HexagonLayer.layerName = "HexagonLayer";
  HexagonLayer.defaultProps = defaultProps46;

  // ../aggregation-layers/src/contour-layer/marching-squares-codes.ts
  var HALF = 0.5;
  var ONE6TH = 1 / 6;
  var OFFSET = {
    N: [0, HALF],
    E: [HALF, 0],
    S: [0, -HALF],
    W: [-HALF, 0],
    NE: [HALF, HALF],
    NW: [-HALF, HALF],
    SE: [HALF, -HALF],
    SW: [-HALF, -HALF]
  };
  var SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
  var SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
  var NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];
  var SW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF]
  ];
  var SE_TRAPEZOID = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var NE_TRAPEZOID = [
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
  var E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
  var W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
  var EW_RECTANGEL = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var SN_RECTANGEL = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];
  var SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
  var SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
  var NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];
  var NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
  var SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
  var NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];
  var S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
  var W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];
  var NE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
  ];
  var SW_HEPTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_HEPTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    OFFSET.N
  ];
  var SE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var OCTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var ISOLINES_CODE_OFFSET_MAP = {
    0: [],
    1: [[OFFSET.W, OFFSET.S]],
    2: [[OFFSET.S, OFFSET.E]],
    3: [[OFFSET.W, OFFSET.E]],
    4: [[OFFSET.N, OFFSET.E]],
    5: {
      0: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ]
    },
    6: [[OFFSET.N, OFFSET.S]],
    7: [[OFFSET.W, OFFSET.N]],
    8: [[OFFSET.W, OFFSET.N]],
    9: [[OFFSET.N, OFFSET.S]],
    10: {
      0: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ]
    },
    11: [[OFFSET.N, OFFSET.E]],
    12: [[OFFSET.W, OFFSET.E]],
    13: [[OFFSET.S, OFFSET.E]],
    14: [[OFFSET.W, OFFSET.S]],
    15: []
  };
  function ternaryToIndex(ternary) {
    return parseInt(ternary, 4);
  }
  var ISOBANDS_CODE_OFFSET_MAP = {
    [ternaryToIndex("0000")]: [],
    [ternaryToIndex("2222")]: [],
    [ternaryToIndex("2221")]: [SW_TRIANGLE],
    [ternaryToIndex("2212")]: [SE_TRIANGLE],
    [ternaryToIndex("2122")]: [NE_TRIANGLE],
    [ternaryToIndex("1222")]: [NW_TRIANGLE],
    [ternaryToIndex("0001")]: [SW_TRIANGLE],
    [ternaryToIndex("0010")]: [SE_TRIANGLE],
    [ternaryToIndex("0100")]: [NE_TRIANGLE],
    [ternaryToIndex("1000")]: [NW_TRIANGLE],
    [ternaryToIndex("2220")]: [SW_TRAPEZOID],
    [ternaryToIndex("2202")]: [SE_TRAPEZOID],
    [ternaryToIndex("2022")]: [NE_TRAPEZOID],
    [ternaryToIndex("0222")]: [NW_TRAPEZOID],
    [ternaryToIndex("0002")]: [SW_TRAPEZOID],
    [ternaryToIndex("0020")]: [SE_TRAPEZOID],
    [ternaryToIndex("0200")]: [NE_TRAPEZOID],
    [ternaryToIndex("2000")]: [NW_TRAPEZOID],
    [ternaryToIndex("0011")]: [S_RECTANGLE],
    [ternaryToIndex("0110")]: [E_RECTANGLE],
    [ternaryToIndex("1100")]: [N_RECTANGLE],
    [ternaryToIndex("1001")]: [W_RECTANGLE],
    [ternaryToIndex("2211")]: [S_RECTANGLE],
    [ternaryToIndex("2112")]: [E_RECTANGLE],
    [ternaryToIndex("1122")]: [N_RECTANGLE],
    [ternaryToIndex("1221")]: [W_RECTANGLE],
    [ternaryToIndex("2200")]: [EW_RECTANGEL],
    [ternaryToIndex("2002")]: [SN_RECTANGEL],
    [ternaryToIndex("0022")]: [EW_RECTANGEL],
    [ternaryToIndex("0220")]: [SN_RECTANGEL],
    [ternaryToIndex("1111")]: [SQUARE],
    [ternaryToIndex("1211")]: [SW_PENTAGON],
    [ternaryToIndex("2111")]: [SE_PENTAGON],
    [ternaryToIndex("1112")]: [NE_PENTAGON],
    [ternaryToIndex("1121")]: [NW_PENTAGON],
    [ternaryToIndex("1011")]: [SW_PENTAGON],
    [ternaryToIndex("0111")]: [SE_PENTAGON],
    [ternaryToIndex("1110")]: [NE_PENTAGON],
    [ternaryToIndex("1101")]: [NW_PENTAGON],
    [ternaryToIndex("1200")]: [NW_N_PENTAGON],
    [ternaryToIndex("0120")]: [NE_E_PENTAGON],
    [ternaryToIndex("0012")]: [SE_S_PENTAGON],
    [ternaryToIndex("2001")]: [SW_W_PENTAGON],
    [ternaryToIndex("1022")]: [NW_N_PENTAGON],
    [ternaryToIndex("2102")]: [NE_E_PENTAGON],
    [ternaryToIndex("2210")]: [SE_S_PENTAGON],
    [ternaryToIndex("0221")]: [SW_W_PENTAGON],
    [ternaryToIndex("1002")]: [NW_W_PENTAGON],
    [ternaryToIndex("2100")]: [NE_N_PENTAGON],
    [ternaryToIndex("0210")]: [SE_E_PENTAGON],
    [ternaryToIndex("0021")]: [SW_S_PENTAGON],
    [ternaryToIndex("1220")]: [NW_W_PENTAGON],
    [ternaryToIndex("0122")]: [NE_N_PENTAGON],
    [ternaryToIndex("2012")]: [SE_E_PENTAGON],
    [ternaryToIndex("2201")]: [SW_S_PENTAGON],
    [ternaryToIndex("0211")]: [S_HEXAGON],
    [ternaryToIndex("2110")]: [E_HEXAGON],
    [ternaryToIndex("1102")]: [N_HEXAGON],
    [ternaryToIndex("1021")]: [W_HEXAGON],
    [ternaryToIndex("2011")]: [S_HEXAGON],
    [ternaryToIndex("0112")]: [E_HEXAGON],
    [ternaryToIndex("1120")]: [N_HEXAGON],
    [ternaryToIndex("1201")]: [W_HEXAGON],
    [ternaryToIndex("2101")]: [SW_NE_HEXAGON],
    [ternaryToIndex("0121")]: [SW_NE_HEXAGON],
    [ternaryToIndex("1012")]: [NW_SE_HEXAGON],
    [ternaryToIndex("1210")]: [NW_SE_HEXAGON],
    [ternaryToIndex("0101")]: {
      0: [SW_TRIANGLE, NE_TRIANGLE],
      1: [SW_NE_HEXAGON],
      2: [SW_NE_HEXAGON]
    },
    [ternaryToIndex("1010")]: {
      0: [NW_TRIANGLE, SE_TRIANGLE],
      1: [NW_SE_HEXAGON],
      2: [NW_SE_HEXAGON]
    },
    [ternaryToIndex("2121")]: {
      0: [SW_NE_HEXAGON],
      1: [SW_NE_HEXAGON],
      2: [SW_TRIANGLE, NE_TRIANGLE]
    },
    [ternaryToIndex("1212")]: {
      0: [NW_SE_HEXAGON],
      1: [NW_SE_HEXAGON],
      2: [NW_TRIANGLE, SE_TRIANGLE]
    },
    [ternaryToIndex("2120")]: {
      0: [NE_HEPTAGON],
      1: [NE_HEPTAGON],
      2: [SW_TRAPEZOID, NE_TRIANGLE]
    },
    [ternaryToIndex("2021")]: {
      0: [SW_HEPTAGON],
      1: [SW_HEPTAGON],
      2: [SW_TRIANGLE, NE_TRAPEZOID]
    },
    [ternaryToIndex("1202")]: {
      0: [NW_HEPTAGON],
      1: [NW_HEPTAGON],
      2: [NW_TRIANGLE, SE_TRAPEZOID]
    },
    [ternaryToIndex("0212")]: {
      0: [SE_HEPTAGON],
      1: [SE_HEPTAGON],
      2: [SE_TRIANGLE, NW_TRAPEZOID]
    },
    [ternaryToIndex("0102")]: {
      0: [SW_TRAPEZOID, NE_TRIANGLE],
      1: [NE_HEPTAGON],
      2: [NE_HEPTAGON]
    },
    [ternaryToIndex("0201")]: {
      0: [SW_TRIANGLE, NE_TRAPEZOID],
      1: [SW_HEPTAGON],
      2: [SW_HEPTAGON]
    },
    [ternaryToIndex("1020")]: {
      0: [NW_TRIANGLE, SE_TRAPEZOID],
      1: [NW_HEPTAGON],
      2: [NW_HEPTAGON]
    },
    [ternaryToIndex("2010")]: {
      0: [SE_TRIANGLE, NW_TRAPEZOID],
      1: [SE_HEPTAGON],
      2: [SE_HEPTAGON]
    },
    [ternaryToIndex("2020")]: {
      0: [NW_TRAPEZOID, SE_TRAPEZOID],
      1: [OCTAGON],
      2: [SW_TRAPEZOID, NE_TRAPEZOID]
    },
    [ternaryToIndex("0202")]: {
      0: [NE_TRAPEZOID, SW_TRAPEZOID],
      1: [OCTAGON],
      2: [NW_TRAPEZOID, SE_TRAPEZOID]
    }
  };

  // ../aggregation-layers/src/contour-layer/marching-squares.ts
  var CONTOUR_TYPE = {
    ISO_LINES: 1,
    ISO_BANDS: 2
  };
  var DEFAULT_THRESHOLD_DATA = {
    zIndex: 0,
    zOffset: 5e-3
  };
  function getVertexCode(weight, threshold2) {
    if (Array.isArray(threshold2)) {
      if (weight < threshold2[0]) {
        return 0;
      }
      return weight < threshold2[1] ? 1 : 2;
    }
    return weight >= threshold2 ? 1 : 0;
  }
  function getCode(opts) {
    const { cellWeights, x: x3, y: y3, width, height } = opts;
    let threshold2 = opts.threshold;
    if (opts.thresholdValue) {
      log_default.deprecated("thresholdValue", "threshold")();
      threshold2 = opts.thresholdValue;
    }
    const isLeftBoundary = x3 < 0;
    const isRightBoundary = x3 >= width - 1;
    const isBottomBoundary = y3 < 0;
    const isTopBoundary = y3 >= height - 1;
    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
    const weights = {};
    const codes = {};
    if (isLeftBoundary || isTopBoundary) {
      codes.top = 0;
    } else {
      weights.top = cellWeights[(y3 + 1) * width + x3];
      codes.top = getVertexCode(weights.top, threshold2);
    }
    if (isRightBoundary || isTopBoundary) {
      codes.topRight = 0;
    } else {
      weights.topRight = cellWeights[(y3 + 1) * width + x3 + 1];
      codes.topRight = getVertexCode(weights.topRight, threshold2);
    }
    if (isRightBoundary || isBottomBoundary) {
      codes.right = 0;
    } else {
      weights.right = cellWeights[y3 * width + x3 + 1];
      codes.right = getVertexCode(weights.right, threshold2);
    }
    if (isLeftBoundary || isBottomBoundary) {
      codes.current = 0;
    } else {
      weights.current = cellWeights[y3 * width + x3];
      codes.current = getVertexCode(weights.current, threshold2);
    }
    const { top, topRight, right, current } = codes;
    let code = -1;
    if (Number.isFinite(threshold2)) {
      code = top << 3 | topRight << 2 | right << 1 | current;
    }
    if (Array.isArray(threshold2)) {
      code = top << 6 | topRight << 4 | right << 2 | current;
    }
    let meanCode = 0;
    if (!isBoundary) {
      meanCode = getVertexCode(
        (weights.top + weights.topRight + weights.right + weights.current) / 4,
        threshold2
      );
    }
    return { code, meanCode };
  }
  function getVertices(opts) {
    const { gridOrigin, cellSize, x: x3, y: y3, code, meanCode, type = CONTOUR_TYPE.ISO_LINES } = opts;
    const thresholdData = { ...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData };
    let offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const vZ = thresholdData.zIndex * thresholdData.zOffset;
    const rX = (x3 + 1) * cellSize[0];
    const rY = (y3 + 1) * cellSize[1];
    const refVertexX = gridOrigin[0] + rX;
    const refVertexY = gridOrigin[1] + rY;
    if (type === CONTOUR_TYPE.ISO_BANDS) {
      const polygons = [];
      offsets.forEach((polygonOffsets) => {
        const polygon = [];
        polygonOffsets.forEach((xyOffset) => {
          const vX = refVertexX + xyOffset[0] * cellSize[0];
          const vY = refVertexY + xyOffset[1] * cellSize[1];
          polygon.push([vX, vY, vZ]);
        });
        polygons.push(polygon);
      });
      return polygons;
    }
    const lines = [];
    offsets.forEach((xyOffsets) => {
      xyOffsets.forEach((offset) => {
        const vX = refVertexX + offset[0] * cellSize[0];
        const vY = refVertexY + offset[1] * cellSize[1];
        lines.push([vX, vY, vZ]);
      });
    });
    return lines;
  }

  // ../aggregation-layers/src/contour-layer/contour-utils.ts
  function generateContours({
    thresholdData,
    cellWeights,
    gridSize,
    gridOrigin,
    cellSize
  }) {
    const contourSegments = [];
    const contourPolygons = [];
    const width = gridSize[0];
    const height = gridSize[1];
    let segmentIndex = 0;
    let polygonIndex = 0;
    for (const data of thresholdData) {
      const { contour } = data;
      const { threshold: threshold2 } = contour;
      for (let x3 = -1; x3 < width; x3++) {
        for (let y3 = -1; y3 < height; y3++) {
          const { code, meanCode } = getCode({
            cellWeights,
            threshold: threshold2,
            x: x3,
            y: y3,
            width,
            height
          });
          const opts = {
            type: CONTOUR_TYPE.ISO_BANDS,
            gridOrigin,
            cellSize,
            x: x3,
            y: y3,
            width,
            height,
            code,
            meanCode,
            thresholdData: data
          };
          if (Array.isArray(threshold2)) {
            opts.type = CONTOUR_TYPE.ISO_BANDS;
            const polygons = getVertices(opts);
            for (const polygon of polygons) {
              contourPolygons[polygonIndex++] = {
                vertices: polygon,
                contour
              };
            }
          } else {
            opts.type = CONTOUR_TYPE.ISO_LINES;
            const vertices = getVertices(opts);
            for (let i5 = 0; i5 < vertices.length; i5 += 2) {
              contourSegments[segmentIndex++] = {
                start: vertices[i5],
                end: vertices[i5 + 1],
                contour
              };
            }
          }
        }
      }
    }
    return { contourSegments, contourPolygons };
  }

  // ../aggregation-layers/src/contour-layer/contour-layer.ts
  var DEFAULT_COLOR12 = [255, 255, 255, 255];
  var DEFAULT_STROKE_WIDTH = 1;
  var DEFAULT_THRESHOLD = 1;
  var defaultProps47 = {
    cellSize: { type: "number", min: 1, max: 1e3, value: 1e3 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: false,
    aggregation: "SUM",
    contours: {
      type: "object",
      value: [{ threshold: DEFAULT_THRESHOLD }],
      optional: true,
      compare: 3
    },
    zOffset: 5e-3
  };
  var POSITION_ATTRIBUTE_NAME2 = "positions";
  var DIMENSIONS2 = {
    data: {
      props: ["cellSize"]
    },
    weights: {
      props: ["aggregation"],
      accessors: ["getWeight"]
    }
  };
  var ContourLayer = class extends GridAggregationLayer {
    initializeState() {
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS2
      });
      this.setState({
        contourData: {},
        projectPoints: false,
        weights: {
          count: {
            size: 1,
            operation: AGGREGATION_OPERATION.SUM
          }
        }
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME2]: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        count: { size: 3, accessor: "getWeight" }
      });
    }
    updateState(opts) {
      super.updateState(opts);
      let contoursChanged = false;
      const { oldProps, props } = opts;
      const { aggregationDirty } = this.state;
      if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {
        contoursChanged = true;
        this._updateThresholdData(opts.props);
      }
      if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {
        this._generateContours();
      }
    }
    renderLayers() {
      const { contourSegments, contourPolygons } = this.state.contourData;
      const LinesSubLayerClass = this.getSubLayerClass("lines", LineLayer);
      const BandsSubLayerClass = this.getSubLayerClass("bands", SolidPolygonLayer);
      const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(
        this.getSubLayerProps({
          id: "lines"
        }),
        {
          data: this.state.contourData.contourSegments,
          getSourcePosition: (d2) => d2.start,
          getTargetPosition: (d2) => d2.end,
          getColor: (d2) => d2.contour.color || DEFAULT_COLOR12,
          getWidth: (d2) => d2.contour.strokeWidth || DEFAULT_STROKE_WIDTH
        }
      );
      const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(
        this.getSubLayerProps({
          id: "bands"
        }),
        {
          data: this.state.contourData.contourPolygons,
          getPolygon: (d2) => d2.vertices,
          getFillColor: (d2) => d2.contour.color || DEFAULT_COLOR12
        }
      );
      return [lineLayer, bandsLayer];
    }
    updateAggregationState(opts) {
      const { props, oldProps } = opts;
      const { cellSize, coordinateSystem } = props;
      const { viewport } = this.context;
      const cellSizeChanged = oldProps.cellSize !== cellSize;
      let gpuAggregation = props.gpuAggregation;
      if (this.state.gpuAggregation !== props.gpuAggregation) {
        if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {
          log_default.warn("GPU Grid Aggregation not supported, falling back to CPU")();
          gpuAggregation = false;
        }
      }
      const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
      this.setState({
        gpuAggregation
      });
      const { dimensions } = this.state;
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME2);
      const { data, weights } = dimensions;
      let { boundingBox } = this.state;
      if (positionsChanged) {
        boundingBox = getBoundingBox3(this.getAttributes(), this.getNumInstances());
        this.setState({ boundingBox });
      }
      if (positionsChanged || cellSizeChanged) {
        const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(
          boundingBox,
          cellSize,
          viewport,
          coordinateSystem
        );
        this.allocateResources(numRow, numCol);
        this.setState({
          gridOffset,
          boundingBox,
          translation,
          posOffset: translation.slice(),
          gridOrigin: [-1 * translation[0], -1 * translation[1]],
          width,
          height,
          numCol,
          numRow
        });
      }
      const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {
        dimension: data,
        compareAll: gpuAggregation
      });
      const aggregationWeightsDirty = this.isAggregationDirty(opts, {
        dimension: weights
      });
      if (aggregationWeightsDirty) {
        this._updateAccessors(opts);
      }
      if (aggregationDataDirty || aggregationWeightsDirty) {
        this._resetResults();
      }
      this.setState({
        aggregationDataDirty,
        aggregationWeightsDirty
      });
    }
    _updateAccessors(opts) {
      const { getWeight, aggregation, data } = opts.props;
      const { count: count2 } = this.state.weights;
      if (count2) {
        count2.getWeight = getWeight;
        count2.operation = AGGREGATION_OPERATION[aggregation];
      }
      this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });
    }
    _resetResults() {
      const { count: count2 } = this.state.weights;
      if (count2) {
        count2.aggregationData = null;
      }
    }
    _generateContours() {
      const { numCol, numRow, gridOrigin, gridOffset, thresholdData } = this.state;
      const { count: count2 } = this.state.weights;
      let { aggregationData } = count2;
      if (!aggregationData) {
        aggregationData = count2.aggregationBuffer.readSyncWebGL();
        count2.aggregationData = aggregationData;
      }
      const { cellWeights } = GPUGridAggregator.getCellData({ countsData: aggregationData });
      const contourData = generateContours({
        thresholdData,
        cellWeights,
        gridSize: [numCol, numRow],
        gridOrigin,
        cellSize: [gridOffset.xOffset, gridOffset.yOffset]
      });
      this.setState({ contourData });
    }
    _updateThresholdData(props) {
      const { contours, zOffset } = props;
      const count2 = contours.length;
      const thresholdData = new Array(count2);
      for (let i5 = 0; i5 < count2; i5++) {
        const contour = contours[i5];
        thresholdData[i5] = {
          contour,
          zIndex: contour.zIndex || i5,
          zOffset
        };
      }
      this.setState({ thresholdData });
    }
  };
  ContourLayer.layerName = "ContourLayer";
  ContourLayer.defaultProps = defaultProps47;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.ts
  var gpu_grid_cell_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6

in vec3 positions;
in vec3 normals;

in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;

// Custom uniforms
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;

uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;

// Domain uniforms
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;

layout(std140) uniform;
uniform ColorData
{
  vec4 maxMinCount;
} colorData;
uniform ElevationData
{
  vec4 maxMinCount;
} elevationData;

#define EPSILON 0.00001

// Result
out vec4 vColor;

vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
  vec4 outColor = vec4(0., 0., 0., 0.);
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    float domainRange = domain.y - domain.x;
    if (domainRange <= 0.) {
      outColor = colorRange[0];
    } else {
      float rangeCount = float(RANGE_COUNT);
      float rangeStep = domainRange / rangeCount;
      float idx = floor((value - domain.x) / rangeStep);
      idx = clamp(idx, 0., rangeCount - 1.);
      int intIdx = int(idx);
      outColor = colorRange[intIdx];
    }
  }
  return outColor;
}

float linearScale(vec2 domain, vec2 range, float value) {
  if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
    return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
  }
  return -1.;
}

void main(void) {
  vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
  vec4 color = quantizeScale(clrDomain, colorRange, colors.r);

  float elevation = 0.0;

  if (extruded) {
    vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
    elevation = linearScale(elvDomain, elevationRange, elevations.r);
    elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
  }

  // if aggregated color or elevation is 0 do not render
  float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
  float dotRadius = cellSize / 2. * coverage * shouldRender;

  int yIndex = (gl_InstanceID / gridSize[0]);
  int xIndex = gl_InstanceID - (yIndex * gridSize[0]);

  vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
  instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
  vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
  instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));

  vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
  vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
  geometry.worldPosition = centroidPosition;
  vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);

  // Light calculations
  // Worldspace is the linear space after Mercator projection

  vec3 normals_commonspace = project_normal(normals);

   if (extruded) {
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);
    vColor = vec4(lightColor, color.a * opacity) / 255.;
  } else {
    vColor = vec4(color.rgb, color.a * opacity) / 255.;
  }
}
`;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.ts
  var gpu_grid_cell_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;
  fragColor = picking_filterColor(fragColor);
}
`;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-cell-layer.ts
  var COLOR_DATA_UBO_INDEX = 0;
  var ELEVATION_DATA_UBO_INDEX = 1;
  var defaultProps48 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    elevationDomain: null,
    elevationRange: [0, 1e3],
    elevationScale: { type: "number", min: 0, value: 1 },
    gridSize: { type: "array", value: [1, 1] },
    gridOrigin: { type: "array", value: [0, 0] },
    gridOffset: { type: "array", value: [0, 0] },
    cellSize: { type: "number", min: 0, max: 1e3, value: 1e3 },
    offset: { type: "array", value: [1, 1] },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    extruded: true,
    material: true
  };
  var GPUGridCellLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: gpu_grid_cell_layer_vertex_glsl_default,
        fs: gpu_grid_cell_layer_fragment_glsl_default,
        modules: [project32_default, gouraudLighting, picking_default, fp64arithmetic]
      });
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        colors: {
          size: 4,
          noAlloc: true
        },
        elevations: {
          size: 4,
          noAlloc: true
        }
      });
      const model = this._getModel();
      this._setupUniformBuffer(model);
      this.setState({ model });
    }
    _getModel() {
      return new Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new CubeGeometry(),
        isInstanced: true
      });
    }
    draw({ uniforms }) {
      const {
        cellSize,
        offset,
        extruded,
        elevationScale,
        coverage,
        gridSize,
        gridOrigin,
        gridOffset,
        elevationRange,
        colorMaxMinBuffer,
        elevationMaxMinBuffer
      } = this.props;
      const model = this.state.model;
      const gridOriginLow = [fp64LowPart2(gridOrigin[0]), fp64LowPart2(gridOrigin[1])];
      const gridOffsetLow = [fp64LowPart2(gridOffset[0]), fp64LowPart2(gridOffset[1])];
      const domainUniforms = this.getDomainUniforms();
      const colorRange = colorRangeToFlatArray(this.props.colorRange);
      this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
      model.setUniforms(uniforms);
      model.setUniforms(domainUniforms);
      model.setUniforms({
        cellSize,
        offset,
        extruded,
        elevationScale,
        coverage,
        gridSize,
        gridOrigin,
        gridOriginLow,
        gridOffset,
        gridOffsetLow,
        colorRange,
        elevationRange
      });
      model.draw(this.context.renderPass);
      this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
    }
    bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
      colorMaxMinBuffer.bind({ target: GLEnum.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX });
      elevationMaxMinBuffer.bind({ target: GLEnum.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX });
    }
    unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
      colorMaxMinBuffer.unbind({ target: GLEnum.UNIFORM_BUFFER, index: COLOR_DATA_UBO_INDEX });
      elevationMaxMinBuffer.unbind({ target: GLEnum.UNIFORM_BUFFER, index: ELEVATION_DATA_UBO_INDEX });
    }
    getDomainUniforms() {
      const { colorDomain, elevationDomain } = this.props;
      const domainUniforms = {};
      if (colorDomain !== null) {
        domainUniforms.colorDomainValid = true;
        domainUniforms.colorDomain = colorDomain;
      } else {
        domainUniforms.colorDomainValid = false;
      }
      if (elevationDomain !== null) {
        domainUniforms.elevationDomainValid = true;
        domainUniforms.elevationDomain = elevationDomain;
      } else {
        domainUniforms.elevationDomainValid = false;
      }
      return domainUniforms;
    }
    _setupUniformBuffer(model) {
      const programHandle = model.pipeline.handle;
      const gl = this.context.gl;
      const colorIndex = gl.getUniformBlockIndex(programHandle, "ColorData");
      const elevationIndex = gl.getUniformBlockIndex(programHandle, "ElevationData");
      gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);
      gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);
    }
  };
  GPUGridCellLayer.layerName = "GPUGridCellLayer";
  GPUGridCellLayer.defaultProps = defaultProps48;

  // ../aggregation-layers/src/gpu-grid-layer/gpu-grid-layer.ts
  var defaultProps49 = {
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationScale: { type: "number", min: 0, value: 1 },
    cellSize: { type: "number", min: 1, max: 1e3, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x3) => x3.position },
    extruded: false,
    material: true
  };
  var DIMENSIONS3 = {
    data: {
      props: ["cellSize", "colorAggregation", "elevationAggregation"]
    }
  };
  var POSITION_ATTRIBUTE_NAME3 = "positions";
  var GPUGridLayer = class extends GridAggregationLayer {
    initializeState({ device }) {
      const isSupported = GPUGridAggregator.isSupported(device);
      if (!isSupported) {
        log_default.error("GPUGridLayer is not supported on this browser, use GridLayer instead")();
      }
      super.initializeAggregationLayer({
        dimensions: DIMENSIONS3
      });
      this.setState({
        gpuAggregation: false,
        projectPoints: false,
        isSupported,
        weights: {
          color: {
            needMin: true,
            needMax: true,
            combineMaxMin: true,
            maxMinBuffer: device.createBuffer({
              byteLength: 4 * 4,
              accessor: { size: 4, type: GLEnum.FLOAT, divisor: 1 }
            })
          },
          elevation: {
            needMin: true,
            needMax: true,
            combineMaxMin: true,
            maxMinBuffer: device.createBuffer({
              byteLength: 4 * 4,
              accessor: { size: 4, type: GLEnum.FLOAT, divisor: 1 }
            })
          }
        },
        positionAttributeName: "positions"
      });
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        [POSITION_ATTRIBUTE_NAME3]: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        color: { size: 3, accessor: "getColorWeight" },
        elevation: { size: 3, accessor: "getElevationWeight" }
      });
    }
    updateState(opts) {
      if (this.state.isSupported === false) {
        return;
      }
      super.updateState(opts);
      const { aggregationDirty } = this.state;
      if (aggregationDirty) {
        this.setState({
          gridHash: null
        });
      }
    }
    getHashKeyForIndex(index2) {
      const { numRow, numCol, boundingBox, gridOffset } = this.state;
      const gridSize = [numCol, numRow];
      const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
      const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
      const yIndex = Math.floor(index2 / gridSize[0]);
      const xIndex = index2 - yIndex * gridSize[0];
      const latIdx = Math.floor(
        (yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]
      );
      const lonIdx = Math.floor(
        (xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]
      );
      return `${latIdx}-${lonIdx}`;
    }
    getPositionForIndex(index2) {
      const { numRow, numCol, boundingBox, gridOffset } = this.state;
      const gridSize = [numCol, numRow];
      const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
      const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
      const yIndex = Math.floor(index2 / gridSize[0]);
      const xIndex = index2 - yIndex * gridSize[0];
      const yPos = yIndex * cellSize[1] + gridOrigin[1];
      const xPos = xIndex * cellSize[0] + gridOrigin[0];
      return [xPos, yPos];
    }
    getPickingInfo({ info, mode }) {
      const { index: index2 } = info;
      let object = null;
      if (index2 >= 0) {
        const gpuGridAggregator = this.state.gpuGridAggregator;
        const position = this.getPositionForIndex(index2);
        const colorInfo = GPUGridAggregator.getAggregationData({
          pixelIndex: index2,
          ...gpuGridAggregator.getData("color")
        });
        const elevationInfo = GPUGridAggregator.getAggregationData({
          pixelIndex: index2,
          ...gpuGridAggregator.getData("elevation")
        });
        object = {
          colorValue: colorInfo.cellWeight,
          elevationValue: elevationInfo.cellWeight,
          count: colorInfo.cellCount || elevationInfo.cellCount,
          position,
          totalCount: colorInfo.totalCount || elevationInfo.totalCount
        };
        if (mode !== "hover") {
          const { props } = this;
          let { gridHash } = this.state;
          if (!gridHash) {
            const { gridOffset, translation, boundingBox } = this.state;
            const { viewport } = this.context;
            const attributes = this.getAttributes();
            const cpuAggregation = pointToDensityGridDataCPU(props, {
              gridOffset,
              attributes,
              viewport,
              translation,
              boundingBox
            });
            gridHash = cpuAggregation.gridHash;
            this.setState({ gridHash });
          }
          const key = this.getHashKeyForIndex(index2);
          const cpuAggregationData = gridHash[key];
          Object.assign(object, cpuAggregationData);
        }
      }
      info.picked = Boolean(object);
      info.object = object;
      return info;
    }
    renderLayers() {
      if (!this.state.isSupported) {
        return null;
      }
      const {
        elevationScale,
        extruded,
        cellSize: cellSizeMeters,
        coverage,
        material,
        elevationRange,
        colorDomain,
        elevationDomain
      } = this.props;
      const { weights, numRow, numCol, gridOrigin, gridOffset } = this.state;
      const { color, elevation } = weights;
      const colorRange = colorRangeToFlatArray(this.props.colorRange);
      const SubLayerClass = this.getSubLayerClass("gpu-grid-cell", GPUGridCellLayer);
      return new SubLayerClass(
        {
          gridSize: [numCol, numRow],
          gridOrigin,
          gridOffset: [gridOffset.xOffset, gridOffset.yOffset],
          colorRange,
          elevationRange,
          colorDomain,
          elevationDomain,
          cellSize: cellSizeMeters,
          coverage,
          material,
          elevationScale,
          extruded
        },
        this.getSubLayerProps({
          id: "gpu-grid-cell"
        }),
        {
          data: {
            attributes: {
              colors: color.aggregationBuffer,
              elevations: elevation.aggregationBuffer
            }
          },
          colorMaxMinBuffer: color.maxMinBuffer,
          elevationMaxMinBuffer: elevation.maxMinBuffer,
          numInstances: numCol * numRow
        }
      );
    }
    finalizeState(context) {
      const { color, elevation } = this.state.weights;
      [color, elevation].forEach((weight) => {
        const { aggregationBuffer, maxMinBuffer } = weight;
        maxMinBuffer?.destroy();
        aggregationBuffer?.destroy();
      });
      super.finalizeState(context);
    }
    updateAggregationState(opts) {
      const { props, oldProps } = opts;
      const { cellSize, coordinateSystem } = props;
      const { viewport } = this.context;
      const cellSizeChanged = oldProps.cellSize !== cellSize;
      const { dimensions } = this.state;
      const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME3);
      const attributesChanged = positionsChanged || this.isAttributeChanged();
      let { boundingBox } = this.state;
      if (positionsChanged) {
        boundingBox = getBoundingBox3(this.getAttributes(), this.getNumInstances());
        this.setState({ boundingBox });
      }
      if (positionsChanged || cellSizeChanged) {
        const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(
          boundingBox,
          cellSize,
          viewport,
          coordinateSystem
        );
        this.allocateResources(numRow, numCol);
        this.setState({
          gridOffset,
          translation,
          gridOrigin: [-1 * translation[0], -1 * translation[1]],
          width,
          height,
          numCol,
          numRow
        });
      }
      const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {
        dimension: dimensions.data,
        compareAll: true
      });
      if (aggregationDataDirty) {
        this._updateAccessors(opts);
      }
      this.setState({
        aggregationDataDirty
      });
    }
    _updateAccessors(opts) {
      const { colorAggregation, elevationAggregation } = opts.props;
      const { color, elevation } = this.state.weights;
      color.operation = AGGREGATION_OPERATION[colorAggregation];
      elevation.operation = AGGREGATION_OPERATION[elevationAggregation];
    }
  };
  GPUGridLayer.layerName = "GPUGridLayer";
  GPUGridLayer.defaultProps = defaultProps49;

  // ../aggregation-layers/src/grid-layer/grid-layer.ts
  var defaultProps50 = {
    ...GPUGridLayer.defaultProps,
    ...CPUGridLayer.defaultProps,
    gpuAggregation: false
  };
  var GridLayer = class extends CompositeLayer {
    initializeState() {
      this.state = {
        useGPUAggregation: false
      };
    }
    updateState({ props }) {
      this.setState({
        useGPUAggregation: false
      });
    }
    renderLayers() {
      const { data, updateTriggers } = this.props;
      const id = this.state.useGPUAggregation ? "GPU" : "CPU";
      const LayerType = this.state.useGPUAggregation ? this.getSubLayerClass("GPU", GPUGridLayer) : this.getSubLayerClass("CPU", CPUGridLayer);
      return new LayerType(
        this.props,
        this.getSubLayerProps({
          id,
          updateTriggers
        }),
        {
          data
        }
      );
    }
    canUseGPUAggregation(props) {
      const {
        gpuAggregation,
        lowerPercentile,
        upperPercentile,
        getColorValue,
        getElevationValue,
        colorScaleType
      } = props;
      if (!gpuAggregation) {
        return false;
      }
      if (!GPUGridAggregator.isSupported(this.context.device)) {
        return false;
      }
      if (lowerPercentile !== 0 || upperPercentile !== 100) {
        return false;
      }
      if (getColorValue !== null || getElevationValue !== null) {
        return false;
      }
      if (colorScaleType === "quantile" || colorScaleType === "ordinal") {
        return false;
      }
      return true;
    }
  };
  GridLayer.layerName = "GridLayer";
  GridLayer.defaultProps = defaultProps50;

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer-utils.ts
  function getBounds2(points) {
    const x3 = points.map((p3) => p3[0]);
    const y3 = points.map((p3) => p3[1]);
    const xMin = Math.min.apply(null, x3);
    const xMax = Math.max.apply(null, x3);
    const yMin = Math.min.apply(null, y3);
    const yMax = Math.max.apply(null, y3);
    return [xMin, yMin, xMax, yMax];
  }
  function boundsContain(currentBounds, targetBounds) {
    if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
      return true;
    }
    return false;
  }
  var scratchArray2 = new Float32Array(12);
  function packVertices(points, dimensions = 2) {
    let index2 = 0;
    for (const point of points) {
      for (let i5 = 0; i5 < dimensions; i5++) {
        scratchArray2[index2++] = point[i5] || 0;
      }
    }
    return scratchArray2;
  }
  function scaleToAspectRatio(boundingBox, width, height) {
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const currentWidth = xMax - xMin;
    const currentHeight = yMax - yMin;
    let newWidth = currentWidth;
    let newHeight = currentHeight;
    if (currentWidth / currentHeight < width / height) {
      newWidth = width / height * currentHeight;
    } else {
      newHeight = height / width * currentWidth;
    }
    if (newWidth < width) {
      newWidth = width;
      newHeight = height;
    }
    const xCenter = (xMax + xMin) / 2;
    const yCenter = (yMax + yMin) / 2;
    return [
      xCenter - newWidth / 2,
      yCenter - newHeight / 2,
      xCenter + newWidth / 2,
      yCenter + newHeight / 2
    ];
  }
  function getTextureCoordinates(point, bounds) {
    const [xMin, yMin, xMax, yMax] = bounds;
    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
  }

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-vertex.glsl.ts
  var triangle_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader

uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;
uniform float aggregationMode;

in vec3 positions;
in vec2 texCoords;

out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
  vTexCoords = texCoords;
  vec4 maxTexture = texture(maxTexture, vec2(0.5));
  float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
  float minValue = maxValue * threshold;
  if (colorDomain[1] > 0.) {
    // if user specified custom domain use it.
    maxValue = colorDomain[1];
    minValue = colorDomain[0];
  }
  vIntensityMax = intensity / maxValue;
  vIntensityMin = intensity / minValue;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer-fragment.glsl.ts
  var triangle_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
uniform float aggregationMode;

in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;

out vec4 fragColor;

vec4 getLinearColor(float value) {
  float factor = clamp(value * vIntensityMax, 0., 1.);
  vec4 color = texture(colorTexture, vec2(factor, 0.5));
  color.a *= min(value * vIntensityMin, 1.0);
  return color;
}

void main(void) {
  vec4 weights = texture(weightsTexture, vTexCoords);
  float weight = weights.r;

  if (aggregationMode > 0.5) {
    weight /= max(1.0, weights.a);
  }

  // discard pixels with 0 weight.
  if (weight <= 0.) {
     discard;
  }

  vec4 linearColor = getLinearColor(weight);
  linearColor.a *= opacity;
  fragColor = linearColor;
}
`;

  // ../aggregation-layers/src/heatmap-layer/triangle-layer.ts
  var TriangleLayer = class extends Layer {
    getShaders() {
      return { vs: triangle_layer_vertex_glsl_default, fs: triangle_layer_fragment_glsl_default, modules: [project32_default] };
    }
    initializeState({ device }) {
      this.setState({ model: this._getModel(device) });
    }
    _getModel(device) {
      const { vertexCount, data, weightsTexture, maxTexture, colorTexture } = this.props;
      return new Model(device, {
        ...this.getShaders(),
        id: this.props.id,
        bindings: { weightsTexture, maxTexture, colorTexture },
        attributes: data.attributes,
        bufferLayout: [
          { name: "positions", format: "float32x3" },
          { name: "texCoords", format: "float32x2" }
        ],
        topology: "triangle-fan-webgl",
        vertexCount
      });
    }
    draw({ uniforms }) {
      const { model } = this.state;
      const { intensity, threshold: threshold2, aggregationMode, colorDomain } = this.props;
      model.setUniforms({
        ...uniforms,
        intensity,
        threshold: threshold2,
        aggregationMode,
        colorDomain
      });
      model.draw(this.context.renderPass);
    }
  };
  TriangleLayer.layerName = "TriangleLayer";

  // ../aggregation-layers/src/heatmap-layer/weights-vs.glsl.ts
  var weights_vs_glsl_default = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;

void main()
{
  weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);

  float radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
  gl_PointSize = radiusTexels * 2.;

  vec3 commonPosition = project_position(positions, positions64Low);

  // // map xy from commonBounds to [-1, 1]
  gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
  gl_Position.xy = (gl_Position.xy * 2.) - (1.);
  gl_Position.w = 1.0;
}
`;

  // ../aggregation-layers/src/heatmap-layer/weights-fs.glsl.ts
  var weights_fs_glsl_default = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
// Epanechnikov function, keeping for reference
// float epanechnikovKDE(float u) {
//   return 0.75 * (1.0 - u * u);
// }
float gaussianKDE(float u){
  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
  float dist = length(gl_PointCoord - vec2(0.5, 0.5));
  if (dist > 0.5) {
    discard;
  }
  fragColor = weightsTexture * gaussianKDE(2. * dist);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-vs.glsl.ts
  var max_vs_glsl_default = `#version 300 es
uniform sampler2D inTexture;
uniform float textureSize;
out vec4 outTexture;

void main()
{
  // Sample every pixel in texture
  int yIndex = gl_VertexID / int(textureSize);
  int xIndex = gl_VertexID - (yIndex * int(textureSize));
  vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;
  outTexture = texture(inTexture, uv);

  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // ../aggregation-layers/src/heatmap-layer/max-fs.glsl.ts
  var max_fs_glsl_default = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
  fragColor = outTexture;
  fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;

  // ../aggregation-layers/src/heatmap-layer/heatmap-layer.ts
  var RESOLUTION = 2;
  var TEXTURE_PROPS = {
    format: "rgba8unorm",
    mipmaps: false,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  var DEFAULT_COLOR_DOMAIN = [0, 0];
  var AGGREGATION_MODE = {
    SUM: 0,
    MEAN: 1
  };
  var defaultProps51 = {
    getPosition: { type: "accessor", value: (x3) => x3.position },
    getWeight: { type: "accessor", value: 1 },
    intensity: { type: "number", min: 0, value: 1 },
    radiusPixels: { type: "number", min: 1, max: 100, value: 50 },
    colorRange: defaultColorRange,
    threshold: { type: "number", min: 0, max: 1, value: 0.05 },
    colorDomain: { type: "array", value: null, optional: true },
    aggregation: "SUM",
    weightsTextureSize: { type: "number", min: 128, max: 2048, value: 2048 },
    debounceTimeout: { type: "number", min: 0, max: 1e3, value: 500 }
  };
  var FLOAT_TARGET_FEATURES2 = [
    "float32-renderable-webgl",
    "texture-blend-float-webgl"
  ];
  var DIMENSIONS4 = {
    data: {
      props: ["radiusPixels"]
    }
  };
  var HeatmapLayer = class extends AggregationLayer {
    initializeState() {
      super.initializeAggregationLayer(DIMENSIONS4);
      this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });
      this._setupTextureParams();
      this._setupAttributes();
      this._setupResources();
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState(opts) {
      super.updateState(opts);
      this._updateHeatmapState(opts);
    }
    _updateHeatmapState(opts) {
      const { props, oldProps } = opts;
      const changeFlags = this._getChangeFlags(opts);
      if (changeFlags.dataChanged || changeFlags.viewportChanged) {
        changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
        this._updateTextureRenderingBounds();
      }
      if (changeFlags.dataChanged || changeFlags.boundsChanged) {
        clearTimeout(this.state.updateTimer);
        this.setState({ isWeightMapDirty: true });
      } else if (changeFlags.viewportZoomChanged) {
        this._debouncedUpdateWeightmap();
      }
      if (props.colorRange !== oldProps.colorRange) {
        this._updateColorTexture(opts);
      }
      if (this.state.isWeightMapDirty) {
        this._updateWeightmap();
      }
      this.setState({ zoom: opts.context.viewport.zoom });
    }
    renderLayers() {
      const {
        weightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        maxWeightsTexture,
        colorTexture,
        colorDomain
      } = this.state;
      const { updateTriggers, intensity, threshold: threshold2, aggregation } = this.props;
      const TriangleLayerClass = this.getSubLayerClass("triangle", TriangleLayer);
      return new TriangleLayerClass(
        this.getSubLayerProps({
          id: "triangle-layer",
          updateTriggers
        }),
        {
          coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
          data: {
            attributes: {
              positions: triPositionBuffer,
              texCoords: triTexCoordBuffer
            }
          },
          vertexCount: 4,
          maxTexture: maxWeightsTexture,
          colorTexture,
          aggregationMode: AGGREGATION_MODE[aggregation] || 0,
          weightsTexture,
          intensity,
          threshold: threshold2,
          colorDomain
        }
      );
    }
    finalizeState(context) {
      super.finalizeState(context);
      const {
        weightsTransform,
        weightsTexture,
        maxWeightTransform,
        maxWeightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        colorTexture,
        updateTimer
      } = this.state;
      weightsTransform?.destroy();
      weightsTexture?.destroy();
      maxWeightTransform?.destroy();
      maxWeightsTexture?.destroy();
      triPositionBuffer?.destroy();
      triTexCoordBuffer?.destroy();
      colorTexture?.destroy();
      if (updateTimer) {
        clearTimeout(updateTimer);
      }
    }
    _getAttributeManager() {
      return new AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
    _getChangeFlags(opts) {
      const changeFlags = {};
      const { dimensions } = this.state;
      changeFlags.dataChanged = this.isAttributeChanged() && "attribute changed" || this.isAggregationDirty(opts, {
        compareAll: true,
        dimension: dimensions.data
      }) && "aggregation is dirty";
      changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
      const { zoom } = this.state;
      if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
        changeFlags.viewportZoomChanged = true;
      }
      return changeFlags;
    }
    _createTextures() {
      const { textureSize, format } = this.state;
      this.setState({
        weightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: textureSize,
          height: textureSize,
          format
        }),
        maxWeightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: 1,
          height: 1,
          format
        })
      });
    }
    _setupAttributes() {
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: { size: 3, type: "float64", accessor: "getPosition" },
        weights: { size: 1, accessor: "getWeight" }
      });
      this.setState({ positionAttributeName: "positions" });
    }
    _setupTextureParams() {
      const { device } = this.context;
      const { weightsTextureSize } = this.props;
      const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);
      const floatTargetSupport = FLOAT_TARGET_FEATURES2.every((feature) => device.features.has(feature));
      const format = floatTargetSupport ? "rgba32float" : "rgba8unorm";
      const weightsScale = floatTargetSupport ? 1 : 1 / 255;
      this.setState({ textureSize, format, weightsScale });
      if (!floatTargetSupport) {
        log_default.warn(
          `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`
        )();
      }
    }
    _createWeightsTransform(shaders) {
      let { weightsTransform } = this.state;
      const { weightsTexture } = this.state;
      const attributeManager = this.getAttributeManager();
      weightsTransform?.destroy();
      weightsTransform = new TextureTransform(this.context.device, {
        id: `${this.id}-weights-transform`,
        bufferLayout: attributeManager.getBufferLayouts(),
        vertexCount: 1,
        targetTexture: weightsTexture,
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "add",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        },
        topology: "point-list",
        ...shaders
      });
      this.setState({ weightsTransform });
    }
    _setupResources() {
      this._createTextures();
      const { device } = this.context;
      const { textureSize, weightsTexture, maxWeightsTexture } = this.state;
      const weightsTransformShaders = this.getShaders({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default
      });
      this._createWeightsTransform(weightsTransformShaders);
      const maxWeightsTransformShaders = this.getShaders({ vs: max_vs_glsl_default, fs: max_fs_glsl_default });
      const maxWeightTransform = new TextureTransform(device, {
        id: `${this.id}-max-weights-transform`,
        bindings: { inTexture: weightsTexture },
        uniforms: { textureSize },
        targetTexture: maxWeightsTexture,
        ...maxWeightsTransformShaders,
        vertexCount: textureSize * textureSize,
        topology: "point-list",
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "max",
          blendAlphaOperation: "max",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        }
      });
      this.setState({
        weightsTexture,
        maxWeightsTexture,
        maxWeightTransform,
        zoom: null,
        triPositionBuffer: device.createBuffer({ byteLength: 48 }),
        triTexCoordBuffer: device.createBuffer({ byteLength: 48 })
      });
    }
    updateShaders(shaderOptions) {
      this._createWeightsTransform({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default,
        ...shaderOptions
      });
    }
    _updateMaxWeightValue() {
      const { maxWeightTransform } = this.state;
      maxWeightTransform.run({
        parameters: { viewport: [0, 0, 1, 1] },
        clearColor: [0, 0, 0, 0]
      });
    }
    _updateBounds(forceUpdate = false) {
      const { viewport } = this.context;
      const viewportCorners = [
        viewport.unproject([0, 0]),
        viewport.unproject([viewport.width, 0]),
        viewport.unproject([viewport.width, viewport.height]),
        viewport.unproject([0, viewport.height])
      ].map((p3) => p3.map(Math.fround));
      const visibleWorldBounds = getBounds2(viewportCorners);
      const newState = { visibleWorldBounds, viewportCorners };
      let boundsChanged = false;
      if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
        const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
        const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
        if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          worldBounds[1] = Math.max(worldBounds[1], -85.051129);
          worldBounds[3] = Math.min(worldBounds[3], 85.051129);
          worldBounds[0] = Math.max(worldBounds[0], -360);
          worldBounds[2] = Math.min(worldBounds[2], 360);
        }
        const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
        newState.worldBounds = worldBounds;
        newState.normalizedCommonBounds = normalizedCommonBounds;
        boundsChanged = true;
      }
      this.setState(newState);
      return boundsChanged;
    }
    _updateTextureRenderingBounds() {
      const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;
      const { viewport } = this.context;
      triPositionBuffer.write(packVertices(viewportCorners, 3));
      const textureBounds = viewportCorners.map(
        (p3) => getTextureCoordinates(viewport.projectPosition(p3), normalizedCommonBounds)
      );
      triTexCoordBuffer.write(packVertices(textureBounds, 2));
    }
    _updateColorTexture(opts) {
      const { colorRange } = opts.props;
      let { colorTexture } = this.state;
      const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
      if (colorTexture && colorTexture?.width === colorRange.length) {
        colorTexture.setSubImageData({ data: colors });
      } else {
        colorTexture?.destroy();
        colorTexture = this.context.device.createTexture({
          ...TEXTURE_PROPS,
          data: colors,
          width: colorRange.length,
          height: 1
        });
      }
      this.setState({ colorTexture });
    }
    _updateWeightmap() {
      const { radiusPixels, colorDomain, aggregation } = this.props;
      const { worldBounds, textureSize, weightsScale } = this.state;
      const weightsTransform = this.state.weightsTransform;
      this.state.isWeightMapDirty = false;
      const commonBounds = this._worldToCommonBounds(worldBounds, {
        useLayerCoordinateSystem: true
      });
      if (colorDomain && aggregation === "SUM") {
        const { viewport } = this.context;
        const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
        this.state.colorDomain = colorDomain.map((x3) => x3 * metersPerPixel * weightsScale);
      } else {
        this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
      }
      const attributeManager = this.getAttributeManager();
      const attributes = attributeManager.getAttributes();
      const moduleSettings = this.getModuleSettings();
      const positions = attributes.positions.buffer;
      const uniforms = { radiusPixels, commonBounds, textureWidth: textureSize, weightsScale };
      const weights = attributes.weights.buffer;
      weightsTransform.model.setAttributes({ positions, weights });
      weightsTransform.model.setVertexCount(this.getNumInstances());
      weightsTransform.model.setUniforms(uniforms);
      weightsTransform.model.updateModuleSettings(moduleSettings);
      weightsTransform.run({
        parameters: { viewport: [0, 0, textureSize, textureSize] },
        clearColor: [0, 0, 0, 0]
      });
      this._updateMaxWeightValue();
    }
    _debouncedUpdateWeightmap(fromTimer = false) {
      let { updateTimer } = this.state;
      const { debounceTimeout } = this.props;
      if (fromTimer) {
        updateTimer = null;
        this._updateBounds(true);
        this._updateTextureRenderingBounds();
        this.setState({ isWeightMapDirty: true });
      } else {
        this.setState({ isWeightMapDirty: false });
        clearTimeout(updateTimer);
        updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
      }
      this.setState({ updateTimer });
    }
    _worldToCommonBounds(worldBounds, opts = {}) {
      const { useLayerCoordinateSystem = false } = opts;
      const [minLong, minLat, maxLong, maxLat] = worldBounds;
      const { viewport } = this.context;
      const { textureSize } = this.state;
      const { coordinateSystem } = this.props;
      const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);
      const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];
      const size = textureSize * RESOLUTION / viewport.scale;
      let bottomLeftCommon;
      let topRightCommon;
      if (useLayerCoordinateSystem && !offsetMode) {
        bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
        topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
      } else {
        bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
        topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
      }
      return scaleToAspectRatio(
        [
          bottomLeftCommon[0] - offsetOriginCommon[0],
          bottomLeftCommon[1] - offsetOriginCommon[1],
          topRightCommon[0] - offsetOriginCommon[0],
          topRightCommon[1] - offsetOriginCommon[1]
        ],
        size,
        size
      );
    }
    _commonToWorldBounds(commonBounds) {
      const [xMin, yMin, xMax, yMax] = commonBounds;
      const { viewport } = this.context;
      const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
      const topRightWorld = viewport.unprojectPosition([xMax, yMax]);
      return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
    }
  };
  HeatmapLayer.layerName = "HeatmapLayer";
  HeatmapLayer.defaultProps = defaultProps51;

  // ../google-maps/src/utils.ts
  var MAX_LATITUDE2 = 85.05113;
  function createDeckInstance(map3, overlay, deck, props) {
    if (deck) {
      if (deck.userData._googleMap === map3) {
        return deck;
      }
      destroyDeckInstance(deck);
    }
    const eventListeners = {
      click: null,
      rightclick: null,
      dblclick: null,
      mousemove: null,
      mouseout: null
    };
    const newDeck = new Deck({
      ...props,
      useDevicePixels: props.interleaved ? true : props.useDevicePixels,
      style: props.interleaved ? null : { pointerEvents: "none" },
      parent: getContainer2(overlay, props.style),
      views: new MapView({ repeat: true }),
      initialViewState: {
        longitude: 0,
        latitude: 0,
        zoom: 1
      },
      controller: false
    });
    for (const eventType in eventListeners) {
      eventListeners[eventType] = map3.addListener(
        eventType,
        (evt) => handleMouseEvent(newDeck, eventType, evt)
      );
    }
    newDeck.userData._googleMap = map3;
    newDeck.userData._eventListeners = eventListeners;
    return newDeck;
  }
  function getContainer2(overlay, style) {
    const container = document.createElement("div");
    container.style.position = "absolute";
    Object.assign(container.style, style);
    if ("getPanes" in overlay) {
      overlay.getPanes()?.overlayLayer.appendChild(container);
    } else {
      overlay.getMap()?.getDiv().appendChild(container);
    }
    return container;
  }
  function destroyDeckInstance(deck) {
    const { _eventListeners: eventListeners } = deck.userData;
    for (const eventType in eventListeners) {
      if (eventListeners[eventType]) {
        eventListeners[eventType].remove();
      }
    }
    deck.finalize();
  }
  function getViewPropsFromOverlay(map3, overlay) {
    const { width, height } = getMapSize(map3);
    const projection = overlay.getProjection();
    const bounds = map3.getBounds();
    if (!bounds) {
      return { width, height, left: 0, top: 0 };
    }
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    const topRight = projection.fromLatLngToDivPixel(ne);
    const bottomLeft = projection.fromLatLngToDivPixel(sw);
    const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);
    const centerH = new google.maps.LatLng(0, centerLngLat[0]);
    const centerContainerPx = projection.fromLatLngToContainerPixel(centerH);
    const centerDivPx = projection.fromLatLngToDivPixel(centerH);
    if (!topRight || !bottomLeft || !centerDivPx || !centerContainerPx) {
      return { width, height, left: 0, top: 0 };
    }
    const leftOffset = Math.round(centerDivPx.x - centerContainerPx.x);
    let topOffset = centerDivPx.y - centerContainerPx.y;
    const topLngLat = pixelToLngLat(projection, width / 2, 0);
    const bottomLngLat = pixelToLngLat(projection, width / 2, height);
    let latitude = centerLngLat[1];
    const longitude = centerLngLat[0];
    if (Math.abs(latitude) > MAX_LATITUDE2) {
      latitude = latitude > 0 ? MAX_LATITUDE2 : -MAX_LATITUDE2;
      const center = new google.maps.LatLng(latitude, longitude);
      const centerPx = projection.fromLatLngToContainerPixel(center);
      topOffset += centerPx.y - height / 2;
    }
    topOffset = Math.round(topOffset);
    const delta = new Vector2(topLngLat).sub(bottomLngLat);
    let bearing = 180 * delta.verticalAngle() / Math.PI;
    if (bearing < 0)
      bearing += 360;
    const heading = map3.getHeading() || 0;
    let zoom = map3.getZoom() - 1;
    let scale7;
    if (bearing === 0) {
      scale7 = height ? (bottomLeft.y - topRight.y) / height : 1;
    } else if (bearing === heading) {
      const viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();
      const mapDiagonal = new Vector2([width, -height]).len();
      scale7 = mapDiagonal ? viewDiagonal / mapDiagonal : 1;
    }
    zoom += Math.log2(scale7 || 1);
    return {
      width,
      height,
      left: leftOffset,
      top: topOffset,
      zoom,
      bearing,
      pitch: map3.getTilt(),
      latitude,
      longitude
    };
  }
  function getViewPropsFromCoordinateTransformer(map3, transformer) {
    const { width, height } = getMapSize(map3);
    const { center, heading: bearing, tilt: pitch, zoom } = transformer.getCameraParams();
    const fovy = 25;
    const aspect = height ? width / height : 1;
    const near = 0.75;
    const far = 3e14;
    const projectionMatrix = new Matrix4().perspective({
      fovy: fovy * Math.PI / 180,
      aspect,
      near,
      far
    });
    const focalDistance = 0.5 * projectionMatrix[5];
    return {
      width,
      height,
      viewState: {
        altitude: focalDistance,
        bearing,
        latitude: center.lat(),
        longitude: center.lng(),
        pitch,
        projectionMatrix,
        repeat: true,
        zoom: zoom - 1
      }
    };
  }
  function getMapSize(map3) {
    const container = map3.getDiv().firstChild;
    return {
      width: container.offsetWidth,
      height: container.offsetHeight
    };
  }
  function pixelToLngLat(projection, x3, y3) {
    const point = new google.maps.Point(x3, y3);
    const latLng = projection.fromContainerPixelToLatLng(point);
    return [latLng.lng(), latLng.lat()];
  }
  function getEventPixel(event, deck) {
    if (event.pixel) {
      return event.pixel;
    }
    const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);
    return {
      x: point[0],
      y: point[1]
    };
  }
  function handleMouseEvent(deck, type, event) {
    if (!deck.isInitialized) {
      return;
    }
    const mockEvent = {
      type,
      offsetCenter: getEventPixel(event, deck),
      srcEvent: event
    };
    switch (type) {
      case "click":
      case "rightclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 1;
        deck._onPointerDown(mockEvent);
        deck._onEvent(mockEvent);
        break;
      case "dblclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 2;
        deck._onEvent(mockEvent);
        break;
      case "mousemove":
        mockEvent.type = "pointermove";
        deck._onPointerMove(mockEvent);
        break;
      case "mouseout":
        mockEvent.type = "pointerleave";
        deck._onPointerMove(mockEvent);
        break;
      default:
        return;
    }
  }

  // ../google-maps/src/google-maps-overlay.ts
  var HIDE_ALL_LAYERS = () => false;
  var GL_STATE = {
    depthMask: true,
    depthTest: true,
    blend: true,
    blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
    blendEquation: GLEnum.FUNC_ADD
  };
  function noop6() {
  }
  var defaultProps52 = {
    interleaved: true
  };
  var GoogleMapsOverlay = class {
    constructor(props) {
      this.props = {};
      this._map = null;
      this._deck = null;
      this._overlay = null;
      this.setProps({ ...defaultProps52, ...props });
    }
    setMap(map3) {
      if (map3 === this._map) {
        return;
      }
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      if (this._map) {
        if (!map3 && this._map.getRenderingType() === VECTOR && this.props.interleaved) {
          this._overlay.requestRedraw();
        }
        this._overlay?.setMap(null);
        this._map = null;
      }
      if (map3) {
        this._map = map3;
        const renderingType = map3.getRenderingType();
        if (renderingType !== UNINITIALIZED) {
          this._createOverlay(map3);
        } else {
          map3.addListener("renderingtype_changed", () => {
            this._createOverlay(map3);
          });
        }
      }
    }
    setProps(props) {
      Object.assign(this.props, props);
      if (this._deck) {
        const canvas2 = this._deck.getCanvas();
        if (props.style && canvas2?.parentElement) {
          const parentStyle = canvas2.parentElement.style;
          Object.assign(parentStyle, props.style);
          props.style = null;
        }
        this._deck.setProps(props);
      }
    }
    pickObject(params) {
      return this._deck && this._deck.pickObject(params);
    }
    pickMultipleObjects(params) {
      return this._deck && this._deck.pickMultipleObjects(params);
    }
    pickObjects(params) {
      return this._deck && this._deck.pickObjects(params);
    }
    finalize() {
      this.setMap(null);
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _createOverlay(map3) {
      const { interleaved } = this.props;
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      const renderingType = map3.getRenderingType();
      if (renderingType === UNINITIALIZED) {
        return;
      }
      const isVectorMap = renderingType === VECTOR && google.maps.WebGLOverlayView;
      const OverlayView = isVectorMap ? google.maps.WebGLOverlayView : google.maps.OverlayView;
      const overlay = new OverlayView();
      if (overlay instanceof google.maps.WebGLOverlayView) {
        if (interleaved) {
          overlay.onAdd = noop6;
          overlay.onContextRestored = this._onContextRestored.bind(this);
          overlay.onDraw = this._onDrawVectorInterleaved.bind(this);
        } else {
          overlay.onAdd = this._onAdd.bind(this);
          overlay.onContextRestored = noop6;
          overlay.onDraw = this._onDrawVectorOverlay.bind(this);
        }
        overlay.onContextLost = this._onContextLost.bind(this);
      } else {
        overlay.onAdd = this._onAdd.bind(this);
        overlay.draw = this._onDrawRaster.bind(this);
      }
      overlay.onRemove = this._onRemove.bind(this);
      this._overlay = overlay;
      this._overlay.setMap(map3);
    }
    _onAdd() {
      this._deck = createDeckInstance(this._map, this._overlay, this._deck, this.props);
    }
    _onContextRestored({ gl }) {
      if (!this._map || !this._overlay) {
        return;
      }
      const _customRender = () => {
        if (this._overlay) {
          this._overlay.requestRedraw();
        }
      };
      const deck = createDeckInstance(this._map, this._overlay, this._deck, {
        gl,
        _customRender,
        ...this.props
      });
      this._deck = deck;
      const animationLoop = deck.animationLoop;
      animationLoop._renderFrame = () => {
        const ab = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
        const device = deck.device;
        device.withParametersWebGL({}, () => {
          animationLoop.props.onRender(animationLoop.animationProps);
        });
        gl.bindBuffer(gl.ARRAY_BUFFER, ab);
      };
    }
    _onContextLost() {
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _onRemove() {
      this._deck?.setProps({ layerFilter: HIDE_ALL_LAYERS });
    }
    _onDrawRaster() {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      const { width, height, left, top, ...rest } = getViewPropsFromOverlay(
        this._map,
        this._overlay
      );
      const canvas2 = deck.getCanvas();
      if (canvas2?.parentElement) {
        const parentStyle = canvas2.parentElement.style;
        parentStyle.left = `${left}px`;
        parentStyle.top = `${top}px`;
      }
      const altitude = 1e4;
      deck.setProps({
        width,
        height,
        viewState: { altitude, ...rest }
      });
      deck.redraw();
    }
    _onDrawVectorInterleaved({ gl, transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer),
        width: null,
        height: null
      });
      if (deck.isInitialized) {
        const device = deck.device;
        const _framebuffer = device.getParametersWebGL(GLEnum.FRAMEBUFFER_BINDING);
        deck.setProps({ _framebuffer });
        device.getCanvasContext().resize();
        deck.needsRedraw({ clearRedrawFlags: true });
        device.setParametersWebGL({
          viewport: [0, 0, gl.canvas.width, gl.canvas.height],
          scissor: [0, 0, gl.canvas.width, gl.canvas.height],
          stencilFunc: [gl.ALWAYS, 0, 255, gl.ALWAYS, 0, 255]
        });
        device.withParametersWebGL(GL_STATE, () => {
          deck._drawLayers("google-vector", {
            clearCanvas: false
          });
        });
      }
    }
    _onDrawVectorOverlay({ transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer)
      });
      deck.redraw();
    }
  };

  // ../mapbox/src/deck-utils.ts
  var TILE_SIZE6 = 512;
  var DEGREES_TO_RADIANS8 = Math.PI / 180;
  function getDeckInstance({
    map: map3,
    gl,
    deck
  }) {
    if (map3.__deck) {
      return map3.__deck;
    }
    const customRender = deck?.props._customRender;
    const onLoad = deck?.props.onLoad;
    const deckProps = getInterleavedProps({
      ...deck?.props,
      _customRender: () => {
        map3.triggerRepaint();
        customRender?.("");
      }
    });
    let deckInstance;
    if (!deck || deck.props.gl === gl) {
      Object.assign(deckProps, {
        gl,
        width: null,
        height: null,
        touchAction: "unset",
        viewState: getViewState(map3)
      });
      if (deck?.isInitialized) {
        watchMapMove(deck, map3);
      } else {
        deckProps.onLoad = () => {
          onLoad?.();
          watchMapMove(deckInstance, map3);
        };
      }
    }
    if (deck) {
      deckInstance = deck;
      deck.setProps(deckProps);
      deck.userData.isExternal = true;
    } else {
      deckInstance = new Deck(deckProps);
      map3.on("remove", () => {
        removeDeckInstance(map3);
      });
    }
    deckInstance.userData.mapboxLayers = /* @__PURE__ */ new Set();
    map3.__deck = deckInstance;
    map3.on("render", () => {
      if (deckInstance.isInitialized)
        afterRender(deckInstance, map3);
    });
    return deckInstance;
  }
  function watchMapMove(deck, map3) {
    const _handleMapMove = () => {
      if (deck.isInitialized) {
        onMapMove(deck, map3);
      } else {
        map3.off("move", _handleMapMove);
      }
    };
    map3.on("move", _handleMapMove);
  }
  function removeDeckInstance(map3) {
    map3.__deck?.finalize();
    map3.__deck = null;
  }
  function getInterleavedProps(currProps) {
    const nextProps = {
      ...currProps,
      parameters: {
        depthMask: true,
        depthTest: true,
        blend: true,
        blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true,
        depthFunc: GLEnum.LEQUAL,
        blendEquation: GLEnum.FUNC_ADD,
        ...currProps.parameters
      },
      views: currProps.views || [new MapView({ id: "mapbox" })]
    };
    return nextProps;
  }
  function addLayer(deck, layer) {
    deck.userData.mapboxLayers.add(layer);
    updateLayers(deck);
  }
  function removeLayer(deck, layer) {
    deck.userData.mapboxLayers.delete(layer);
    updateLayers(deck);
  }
  function updateLayer(deck, layer) {
    updateLayers(deck);
  }
  function drawLayer(deck, map3, layer) {
    let { currentViewport } = deck.userData;
    let clearStack = false;
    if (!currentViewport) {
      currentViewport = getViewport(deck, map3, true);
      deck.userData.currentViewport = currentViewport;
      clearStack = true;
    }
    if (!deck.isInitialized) {
      return;
    }
    deck._drawLayers("mapbox-repaint", {
      viewports: [currentViewport],
      layerFilter: ({ layer: deckLayer }) => layer.id === deckLayer.id || deckLayer.props.operation.includes("terrain"),
      clearStack,
      clearCanvas: false
    });
  }
  function getViewState(map3) {
    const { lng, lat } = map3.getCenter();
    const viewState = {
      longitude: (lng + 540) % 360 - 180,
      latitude: lat,
      zoom: map3.getZoom(),
      bearing: map3.getBearing(),
      pitch: map3.getPitch(),
      padding: map3.getPadding(),
      repeat: map3.getRenderWorldCopies()
    };
    if (map3.getTerrain?.()) {
      centerCameraOnTerrain(map3, viewState);
    }
    return viewState;
  }
  function centerCameraOnTerrain(map3, viewState) {
    if (map3.getFreeCameraOptions) {
      const { position } = map3.getFreeCameraOptions();
      if (!position || position.z === void 0) {
        return;
      }
      const height = map3.transform.height;
      const { longitude, latitude, pitch } = viewState;
      const cameraX = position.x * TILE_SIZE6;
      const cameraY = (1 - position.y) * TILE_SIZE6;
      const cameraZ = position.z * TILE_SIZE6;
      const center = lngLatToWorld([longitude, latitude]);
      const dx = cameraX - center[0];
      const dy = cameraY - center[1];
      const cameraToCenterDistanceGround = Math.sqrt(dx * dx + dy * dy);
      const pitchRadians = pitch * DEGREES_TO_RADIANS8;
      const altitudePixels = 1.5 * height;
      const scale7 = pitchRadians < 1e-3 ? altitudePixels * Math.cos(pitchRadians) / cameraZ : altitudePixels * Math.sin(pitchRadians) / cameraToCenterDistanceGround;
      viewState.zoom = Math.log2(scale7);
      const cameraZFromSurface = altitudePixels * Math.cos(pitchRadians) / scale7;
      const surfaceElevation = cameraZ - cameraZFromSurface;
      viewState.position = [0, 0, surfaceElevation / unitsPerMeter(latitude)];
    } else if (typeof map3.transform.elevation === "number") {
      viewState.position = [0, 0, map3.transform.elevation];
    }
  }
  function getViewport(deck, map3, useMapboxProjection = true) {
    return new WebMercatorViewport2({
      id: "mapbox",
      x: 0,
      y: 0,
      width: deck.width,
      height: deck.height,
      ...getViewState(map3),
      nearZMultiplier: useMapboxProjection ? 0.02 : 0.1,
      nearZ: map3.transform._nearZ / map3.transform.height,
      farZ: map3.transform._farZ / map3.transform.height
    });
  }
  function afterRender(deck, map3) {
    const { mapboxLayers, isExternal } = deck.userData;
    if (isExternal) {
      const mapboxLayerIds = Array.from(mapboxLayers, (layer) => layer.id);
      const deckLayers = flatten(deck.props.layers, Boolean);
      const hasNonMapboxLayers = deckLayers.some(
        (layer) => layer && !mapboxLayerIds.includes(layer.id)
      );
      let viewports = deck.getViewports();
      const mapboxViewportIdx = viewports.findIndex((vp) => vp.id === "mapbox");
      const hasNonMapboxViews = viewports.length > 1 || mapboxViewportIdx < 0;
      if (hasNonMapboxLayers || hasNonMapboxViews) {
        if (mapboxViewportIdx >= 0) {
          viewports = viewports.slice();
          viewports[mapboxViewportIdx] = getViewport(deck, map3, false);
        }
        deck._drawLayers("mapbox-repaint", {
          viewports,
          layerFilter: (params) => (!deck.props.layerFilter || deck.props.layerFilter(params)) && (params.viewport.id !== "mapbox" || !mapboxLayerIds.includes(params.layer.id)),
          clearCanvas: false
        });
      }
    }
    deck.userData.currentViewport = null;
  }
  function onMapMove(deck, map3) {
    deck.setProps({
      viewState: getViewState(map3)
    });
    deck.needsRedraw({ clearRedrawFlags: true });
  }
  function updateLayers(deck) {
    if (deck.userData.isExternal) {
      return;
    }
    const layers = [];
    deck.userData.mapboxLayers.forEach((deckLayer) => {
      const LayerType = deckLayer.props.type;
      const layer = new LayerType(deckLayer.props);
      layers.push(layer);
    });
    deck.setProps({ layers });
  }

  // ../mapbox/src/mapbox-layer.ts
  var MapboxLayer = class {
    constructor(props) {
      if (!props.id) {
        throw new Error("Layer must have an unique id");
      }
      this.id = props.id;
      this.type = "custom";
      this.renderingMode = props.renderingMode || "3d";
      this.map = null;
      this.deck = null;
      this.props = props;
    }
    onAdd(map3, gl) {
      this.map = map3;
      this.deck = getDeckInstance({ map: map3, gl, deck: this.props.deck });
      addLayer(this.deck, this);
    }
    onRemove() {
      if (this.deck) {
        removeLayer(this.deck, this);
      }
    }
    setProps(props) {
      Object.assign(this.props, props, { id: this.id });
      if (this.deck) {
        updateLayer(this.deck, this);
      }
    }
    render() {
      drawLayer(this.deck, this.map, this);
    }
  };

  // ../mapbox/src/resolve-layers.ts
  var UNDEFINED_BEFORE_ID = "__UNDEFINED__";
  function resolveLayers(map3, deck, oldLayers, newLayers) {
    if (!map3 || !deck || !map3.style || !map3.style._loaded) {
      return;
    }
    const layers = flatten(newLayers, Boolean);
    if (oldLayers !== newLayers) {
      const prevLayers = flatten(oldLayers, Boolean);
      const prevLayerIds = new Set(prevLayers.map((l3) => l3.id));
      for (const layer of layers) {
        prevLayerIds.delete(layer.id);
      }
      for (const id of prevLayerIds) {
        if (map3.getLayer(id)) {
          map3.removeLayer(id);
        }
      }
    }
    for (const layer of layers) {
      const mapboxLayer = map3.getLayer(layer.id);
      if (mapboxLayer) {
        mapboxLayer.implementation.setProps(layer.props);
      } else {
        map3.addLayer(
          new MapboxLayer({ id: layer.id, deck }),
          layer.props.beforeId
        );
      }
    }
    const mapLayers = map3.style._order;
    const layerGroups = {};
    for (const layer of layers) {
      let { beforeId } = layer.props;
      if (!beforeId || !mapLayers.includes(beforeId)) {
        beforeId = UNDEFINED_BEFORE_ID;
      }
      layerGroups[beforeId] = layerGroups[beforeId] || [];
      layerGroups[beforeId].push(layer.id);
    }
    for (const beforeId in layerGroups) {
      const layerGroup = layerGroups[beforeId];
      let lastLayerIndex = beforeId === UNDEFINED_BEFORE_ID ? mapLayers.length : mapLayers.indexOf(beforeId);
      let lastLayerId = beforeId === UNDEFINED_BEFORE_ID ? void 0 : beforeId;
      for (let i5 = layerGroup.length - 1; i5 >= 0; i5--) {
        const layerId = layerGroup[i5];
        const layerIndex = mapLayers.indexOf(layerId);
        if (layerIndex !== lastLayerIndex - 1) {
          map3.moveLayer(layerId, lastLayerId);
          if (layerIndex > lastLayerIndex) {
            lastLayerIndex++;
          }
        }
        lastLayerIndex--;
        lastLayerId = layerId;
      }
    }
  }

  // ../mapbox/src/mapbox-overlay.ts
  var MapboxOverlay = class {
    constructor(props) {
      this._handleStyleChange = () => {
        resolveLayers(this._map, this._deck, this._props.layers, this._props.layers);
      };
      this._updateContainerSize = () => {
        if (this._map && this._container) {
          const { clientWidth, clientHeight } = this._map.getContainer();
          Object.assign(this._container.style, {
            width: `${clientWidth}px`,
            height: `${clientHeight}px`
          });
        }
      };
      this._updateViewState = () => {
        const deck = this._deck;
        if (deck) {
          deck.setProps({ viewState: getViewState(this._map) });
          if (deck.isInitialized) {
            deck.redraw();
          }
        }
      };
      this._handleMouseEvent = (event) => {
        const deck = this._deck;
        if (!deck || !deck.isInitialized) {
          return;
        }
        const mockEvent = {
          type: event.type,
          offsetCenter: event.point,
          srcEvent: event
        };
        const lastDown = this._lastMouseDownPoint;
        if (!event.point && lastDown) {
          mockEvent.deltaX = event.originalEvent.clientX - lastDown.clientX;
          mockEvent.deltaY = event.originalEvent.clientY - lastDown.clientY;
          mockEvent.offsetCenter = {
            x: lastDown.x + mockEvent.deltaX,
            y: lastDown.y + mockEvent.deltaY
          };
        }
        switch (mockEvent.type) {
          case "mousedown":
            deck._onPointerDown(mockEvent);
            this._lastMouseDownPoint = {
              ...event.point,
              clientX: event.originalEvent.clientX,
              clientY: event.originalEvent.clientY
            };
            break;
          case "dragstart":
            mockEvent.type = "panstart";
            deck._onEvent(mockEvent);
            break;
          case "drag":
            mockEvent.type = "panmove";
            deck._onEvent(mockEvent);
            break;
          case "dragend":
            mockEvent.type = "panend";
            deck._onEvent(mockEvent);
            break;
          case "click":
            mockEvent.tapCount = 1;
            deck._onEvent(mockEvent);
            break;
          case "dblclick":
            mockEvent.type = "click";
            mockEvent.tapCount = 2;
            deck._onEvent(mockEvent);
            break;
          case "mousemove":
            mockEvent.type = "pointermove";
            deck._onPointerMove(mockEvent);
            break;
          case "mouseout":
            mockEvent.type = "pointerleave";
            deck._onPointerMove(mockEvent);
            break;
          default:
            return;
        }
      };
      const { interleaved = false, ...otherProps } = props;
      this._interleaved = interleaved;
      this._props = otherProps;
    }
    setProps(props) {
      if (this._interleaved && props.layers) {
        resolveLayers(this._map, this._deck, this._props.layers, props.layers);
      }
      Object.assign(this._props, props);
      if (this._deck) {
        this._deck.setProps(this._interleaved ? getInterleavedProps(this._props) : this._props);
      }
    }
    onAdd(map3) {
      this._map = map3;
      return this._interleaved ? this._onAddInterleaved(map3) : this._onAddOverlaid(map3);
    }
    _onAddOverlaid(map3) {
      const container = document.createElement("div");
      Object.assign(container.style, {
        position: "absolute",
        left: 0,
        top: 0,
        textAlign: "initial",
        pointerEvents: "none"
      });
      this._container = container;
      this._deck = new Deck({
        ...this._props,
        parent: container,
        viewState: getViewState(map3)
      });
      map3.on("resize", this._updateContainerSize);
      map3.on("render", this._updateViewState);
      map3.on("mousedown", this._handleMouseEvent);
      map3.on("dragstart", this._handleMouseEvent);
      map3.on("drag", this._handleMouseEvent);
      map3.on("dragend", this._handleMouseEvent);
      map3.on("mousemove", this._handleMouseEvent);
      map3.on("mouseout", this._handleMouseEvent);
      map3.on("click", this._handleMouseEvent);
      map3.on("dblclick", this._handleMouseEvent);
      this._updateContainerSize();
      return container;
    }
    _onAddInterleaved(map3) {
      const gl = map3.painter.context.gl;
      if (gl instanceof WebGLRenderingContext) {
        log_default.warn(
          "Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility"
        )();
      }
      this._deck = getDeckInstance({
        map: map3,
        gl,
        deck: new Deck({
          ...this._props,
          gl
        })
      });
      map3.on("styledata", this._handleStyleChange);
      resolveLayers(map3, this._deck, [], this._props.layers);
      return document.createElement("div");
    }
    onRemove() {
      const map3 = this._map;
      if (map3) {
        if (this._interleaved) {
          this._onRemoveInterleaved(map3);
        } else {
          this._onRemoveOverlaid(map3);
        }
      }
      this._deck = void 0;
      this._map = void 0;
      this._container = void 0;
    }
    _onRemoveOverlaid(map3) {
      map3.off("resize", this._updateContainerSize);
      map3.off("render", this._updateViewState);
      map3.off("mousedown", this._handleMouseEvent);
      map3.off("dragstart", this._handleMouseEvent);
      map3.off("drag", this._handleMouseEvent);
      map3.off("dragend", this._handleMouseEvent);
      map3.off("mousemove", this._handleMouseEvent);
      map3.off("mouseout", this._handleMouseEvent);
      map3.off("click", this._handleMouseEvent);
      map3.off("dblclick", this._handleMouseEvent);
      this._deck?.finalize();
    }
    _onRemoveInterleaved(map3) {
      map3.off("styledata", this._handleStyleChange);
      resolveLayers(map3, this._deck, this._props.layers, []);
      removeDeckInstance(map3);
    }
    getDefaultPosition() {
      return "top-left";
    }
    pickObject(params) {
      assert9(this._deck);
      return this._deck.pickObject(params);
    }
    pickMultipleObjects(params) {
      assert9(this._deck);
      return this._deck.pickMultipleObjects(params);
    }
    pickObjects(params) {
      assert9(this._deck);
      return this._deck.pickObjects(params);
    }
    finalize() {
      if (this._map) {
        this._map.removeControl(this);
      }
    }
    getCanvas() {
      if (!this._map) {
        return null;
      }
      return this._interleaved ? this._map.getCanvas() : this._deck.getCanvas();
    }
  };

  // ../../node_modules/preact/dist/preact.module.js
  var n2;
  var l2;
  var u;
  var t2;
  var i3;
  var o2;
  var r2;
  var f2;
  var e2;
  var c = {};
  var s2 = [];
  var a2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  var h = Array.isArray;
  function v(n3, l3) {
    for (var u3 in l3)
      n3[u3] = l3[u3];
    return n3;
  }
  function p2(n3) {
    var l3 = n3.parentNode;
    l3 && l3.removeChild(n3);
  }
  function y2(l3, u3, t3) {
    var i5, o3, r3, f4 = {};
    for (r3 in u3)
      "key" == r3 ? i5 = u3[r3] : "ref" == r3 ? o3 = u3[r3] : f4[r3] = u3[r3];
    if (arguments.length > 2 && (f4.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps)
      for (r3 in l3.defaultProps)
        void 0 === f4[r3] && (f4[r3] = l3.defaultProps[r3]);
    return d(l3, f4, i5, o3, null);
  }
  function d(n3, t3, i5, o3, r3) {
    var f4 = { type: n3, props: t3, key: i5, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r3 ? ++u : r3, __i: -1, __u: 0 };
    return null == r3 && null != l2.vnode && l2.vnode(f4), f4;
  }
  function g(n3) {
    return n3.children;
  }
  function b(n3, l3) {
    this.props = n3, this.context = l3;
  }
  function m(n3, l3) {
    if (null == l3)
      return n3.__ ? m(n3.__, n3.__i + 1) : null;
    for (var u3; l3 < n3.__k.length; l3++)
      if (null != (u3 = n3.__k[l3]) && null != u3.__e)
        return u3.__e;
    return "function" == typeof n3.type ? m(n3) : null;
  }
  function w(n3) {
    var l3, u3;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++)
        if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
          n3.__e = n3.__c.base = u3.__e;
          break;
        }
      return w(n3);
    }
  }
  function k(n3) {
    (!n3.__d && (n3.__d = true) && i3.push(n3) && !x2.__r++ || o2 !== l2.debounceRendering) && ((o2 = l2.debounceRendering) || r2)(x2);
  }
  function x2() {
    var n3, u3, t3, o3, r3, e3, c2, s3, a3;
    for (i3.sort(f2); n3 = i3.shift(); )
      n3.__d && (u3 = i3.length, o3 = void 0, e3 = (r3 = (t3 = n3).__v).__e, s3 = [], a3 = [], (c2 = t3.__P) && ((o3 = v({}, r3)).__v = r3.__v + 1, l2.vnode && l2.vnode(o3), L(c2, o3, r3, t3.__n, void 0 !== c2.ownerSVGElement, 32 & r3.__u ? [e3] : null, s3, null == e3 ? m(r3) : e3, !!(32 & r3.__u), a3), o3.__v = r3.__v, o3.__.__k[o3.__i] = o3, M(s3, o3, a3), o3.__e != e3 && w(o3)), i3.length > u3 && i3.sort(f2));
    x2.__r = 0;
  }
  function C(n3, l3, u3, t3, i5, o3, r3, f4, e3, a3, h2) {
    var v2, p3, y3, d2, _, g2 = t3 && t3.__k || s2, b2 = l3.length;
    for (u3.__d = e3, P(u3, l3, g2), e3 = u3.__d, v2 = 0; v2 < b2; v2++)
      null != (y3 = u3.__k[v2]) && "boolean" != typeof y3 && "function" != typeof y3 && (p3 = -1 === y3.__i ? c : g2[y3.__i] || c, y3.__i = v2, L(n3, y3, p3, i5, o3, r3, f4, e3, a3, h2), d2 = y3.__e, y3.ref && p3.ref != y3.ref && (p3.ref && z(p3.ref, null, y3), h2.push(y3.ref, y3.__c || d2, y3)), null == _ && null != d2 && (_ = d2), 65536 & y3.__u || p3.__k === y3.__k ? (d2 || p3.__e != e3 || (e3 = m(p3)), e3 = S(y3, e3, n3)) : "function" == typeof y3.type && void 0 !== y3.__d ? e3 = y3.__d : d2 && (e3 = d2.nextSibling), y3.__d = void 0, y3.__u &= -196609);
    u3.__d = e3, u3.__e = _;
  }
  function P(n3, l3, u3) {
    var t3, i5, o3, r3, f4, e3 = l3.length, c2 = u3.length, s3 = c2, a3 = 0;
    for (n3.__k = [], t3 = 0; t3 < e3; t3++)
      r3 = t3 + a3, null != (i5 = n3.__k[t3] = null == (i5 = l3[t3]) || "boolean" == typeof i5 || "function" == typeof i5 ? null : "string" == typeof i5 || "number" == typeof i5 || "bigint" == typeof i5 || i5.constructor == String ? d(null, i5, null, null, null) : h(i5) ? d(g, { children: i5 }, null, null, null) : void 0 === i5.constructor && i5.__b > 0 ? d(i5.type, i5.props, i5.key, i5.ref ? i5.ref : null, i5.__v) : i5) ? (i5.__ = n3, i5.__b = n3.__b + 1, f4 = H(i5, u3, r3, s3), i5.__i = f4, o3 = null, -1 !== f4 && (s3--, (o3 = u3[f4]) && (o3.__u |= 131072)), null == o3 || null === o3.__v ? (-1 == f4 && a3--, "function" != typeof i5.type && (i5.__u |= 65536)) : f4 !== r3 && (f4 === r3 + 1 ? a3++ : f4 > r3 ? s3 > e3 - r3 ? a3 += f4 - r3 : a3-- : f4 < r3 ? f4 == r3 - 1 && (a3 = f4 - r3) : a3 = 0, f4 !== t3 + a3 && (i5.__u |= 65536))) : (o3 = u3[r3]) && null == o3.key && o3.__e && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = m(o3)), N(o3, o3, false), u3[r3] = null, s3--);
    if (s3)
      for (t3 = 0; t3 < c2; t3++)
        null != (o3 = u3[t3]) && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = m(o3)), N(o3, o3));
  }
  function S(n3, l3, u3) {
    var t3, i5;
    if ("function" == typeof n3.type) {
      for (t3 = n3.__k, i5 = 0; t3 && i5 < t3.length; i5++)
        t3[i5] && (t3[i5].__ = n3, l3 = S(t3[i5], l3, u3));
      return l3;
    }
    n3.__e != l3 && (u3.insertBefore(n3.__e, l3 || null), l3 = n3.__e);
    do {
      l3 = l3 && l3.nextSibling;
    } while (null != l3 && 8 === l3.nodeType);
    return l3;
  }
  function H(n3, l3, u3, t3) {
    var i5 = n3.key, o3 = n3.type, r3 = u3 - 1, f4 = u3 + 1, e3 = l3[u3];
    if (null === e3 || e3 && i5 == e3.key && o3 === e3.type && 0 == (131072 & e3.__u))
      return u3;
    if (t3 > (null != e3 && 0 == (131072 & e3.__u) ? 1 : 0))
      for (; r3 >= 0 || f4 < l3.length; ) {
        if (r3 >= 0) {
          if ((e3 = l3[r3]) && 0 == (131072 & e3.__u) && i5 == e3.key && o3 === e3.type)
            return r3;
          r3--;
        }
        if (f4 < l3.length) {
          if ((e3 = l3[f4]) && 0 == (131072 & e3.__u) && i5 == e3.key && o3 === e3.type)
            return f4;
          f4++;
        }
      }
    return -1;
  }
  function I(n3, l3, u3) {
    "-" === l3[0] ? n3.setProperty(l3, null == u3 ? "" : u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || a2.test(l3) ? u3 : u3 + "px";
  }
  function T(n3, l3, u3, t3, i5) {
    var o3;
    n:
      if ("style" === l3)
        if ("string" == typeof u3)
          n3.style.cssText = u3;
        else {
          if ("string" == typeof t3 && (n3.style.cssText = t3 = ""), t3)
            for (l3 in t3)
              u3 && l3 in u3 || I(n3.style, l3, "");
          if (u3)
            for (l3 in u3)
              t3 && u3[l3] === t3[l3] || I(n3.style, l3, u3[l3]);
        }
      else if ("o" === l3[0] && "n" === l3[1])
        o3 = l3 !== (l3 = l3.replace(/(PointerCapture)$|Capture$/i, "$1")), l3 = l3.toLowerCase() in n3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + o3] = u3, u3 ? t3 ? u3.u = t3.u : (u3.u = Date.now(), n3.addEventListener(l3, o3 ? D : A, o3)) : n3.removeEventListener(l3, o3 ? D : A, o3);
      else {
        if (i5)
          l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && "rowSpan" !== l3 && "colSpan" !== l3 && "role" !== l3 && l3 in n3)
          try {
            n3[l3] = null == u3 ? "" : u3;
            break n;
          } catch (n4) {
          }
        "function" == typeof u3 || (null == u3 || false === u3 && "-" !== l3[4] ? n3.removeAttribute(l3) : n3.setAttribute(l3, u3));
      }
  }
  function A(n3) {
    if (this.l) {
      var u3 = this.l[n3.type + false];
      if (n3.t) {
        if (n3.t <= u3.u)
          return;
      } else
        n3.t = Date.now();
      return u3(l2.event ? l2.event(n3) : n3);
    }
  }
  function D(n3) {
    if (this.l)
      return this.l[n3.type + true](l2.event ? l2.event(n3) : n3);
  }
  function L(n3, u3, t3, i5, o3, r3, f4, e3, c2, s3) {
    var a3, p3, y3, d2, _, m2, w2, k2, x3, P2, S2, $, H2, I2, T2, A2 = u3.type;
    if (void 0 !== u3.constructor)
      return null;
    128 & t3.__u && (c2 = !!(32 & t3.__u), r3 = [e3 = u3.__e = t3.__e]), (a3 = l2.__b) && a3(u3);
    n:
      if ("function" == typeof A2)
        try {
          if (k2 = u3.props, x3 = (a3 = A2.contextType) && i5[a3.__c], P2 = a3 ? x3 ? x3.props.value : a3.__ : i5, t3.__c ? w2 = (p3 = u3.__c = t3.__c).__ = p3.__E : ("prototype" in A2 && A2.prototype.render ? u3.__c = p3 = new A2(k2, P2) : (u3.__c = p3 = new b(k2, P2), p3.constructor = A2, p3.render = O), x3 && x3.sub(p3), p3.props = k2, p3.state || (p3.state = {}), p3.context = P2, p3.__n = i5, y3 = p3.__d = true, p3.__h = [], p3._sb = []), null == p3.__s && (p3.__s = p3.state), null != A2.getDerivedStateFromProps && (p3.__s == p3.state && (p3.__s = v({}, p3.__s)), v(p3.__s, A2.getDerivedStateFromProps(k2, p3.__s))), d2 = p3.props, _ = p3.state, p3.__v = u3, y3)
            null == A2.getDerivedStateFromProps && null != p3.componentWillMount && p3.componentWillMount(), null != p3.componentDidMount && p3.__h.push(p3.componentDidMount);
          else {
            if (null == A2.getDerivedStateFromProps && k2 !== d2 && null != p3.componentWillReceiveProps && p3.componentWillReceiveProps(k2, P2), !p3.__e && (null != p3.shouldComponentUpdate && false === p3.shouldComponentUpdate(k2, p3.__s, P2) || u3.__v === t3.__v)) {
              for (u3.__v !== t3.__v && (p3.props = k2, p3.state = p3.__s, p3.__d = false), u3.__e = t3.__e, u3.__k = t3.__k, u3.__k.forEach(function(n4) {
                n4 && (n4.__ = u3);
              }), S2 = 0; S2 < p3._sb.length; S2++)
                p3.__h.push(p3._sb[S2]);
              p3._sb = [], p3.__h.length && f4.push(p3);
              break n;
            }
            null != p3.componentWillUpdate && p3.componentWillUpdate(k2, p3.__s, P2), null != p3.componentDidUpdate && p3.__h.push(function() {
              p3.componentDidUpdate(d2, _, m2);
            });
          }
          if (p3.context = P2, p3.props = k2, p3.__P = n3, p3.__e = false, $ = l2.__r, H2 = 0, "prototype" in A2 && A2.prototype.render) {
            for (p3.state = p3.__s, p3.__d = false, $ && $(u3), a3 = p3.render(p3.props, p3.state, p3.context), I2 = 0; I2 < p3._sb.length; I2++)
              p3.__h.push(p3._sb[I2]);
            p3._sb = [];
          } else
            do {
              p3.__d = false, $ && $(u3), a3 = p3.render(p3.props, p3.state, p3.context), p3.state = p3.__s;
            } while (p3.__d && ++H2 < 25);
          p3.state = p3.__s, null != p3.getChildContext && (i5 = v(v({}, i5), p3.getChildContext())), y3 || null == p3.getSnapshotBeforeUpdate || (m2 = p3.getSnapshotBeforeUpdate(d2, _)), C(n3, h(T2 = null != a3 && a3.type === g && null == a3.key ? a3.props.children : a3) ? T2 : [T2], u3, t3, i5, o3, r3, f4, e3, c2, s3), p3.base = u3.__e, u3.__u &= -161, p3.__h.length && f4.push(p3), w2 && (p3.__E = p3.__ = null);
        } catch (n4) {
          u3.__v = null, c2 || null != r3 ? (u3.__e = e3, u3.__u |= c2 ? 160 : 32, r3[r3.indexOf(e3)] = null) : (u3.__e = t3.__e, u3.__k = t3.__k), l2.__e(n4, u3, t3);
        }
      else
        null == r3 && u3.__v === t3.__v ? (u3.__k = t3.__k, u3.__e = t3.__e) : u3.__e = j(t3.__e, u3, t3, i5, o3, r3, f4, c2, s3);
    (a3 = l2.diffed) && a3(u3);
  }
  function M(n3, u3, t3) {
    u3.__d = void 0;
    for (var i5 = 0; i5 < t3.length; i5++)
      z(t3[i5], t3[++i5], t3[++i5]);
    l2.__c && l2.__c(u3, n3), n3.some(function(u4) {
      try {
        n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
          n4.call(u4);
        });
      } catch (n4) {
        l2.__e(n4, u4.__v);
      }
    });
  }
  function j(l3, u3, t3, i5, o3, r3, f4, e3, s3) {
    var a3, v2, y3, d2, _, g2, b2, w2 = t3.props, k2 = u3.props, x3 = u3.type;
    if ("svg" === x3 && (o3 = true), null != r3) {
      for (a3 = 0; a3 < r3.length; a3++)
        if ((_ = r3[a3]) && "setAttribute" in _ == !!x3 && (x3 ? _.localName === x3 : 3 === _.nodeType)) {
          l3 = _, r3[a3] = null;
          break;
        }
    }
    if (null == l3) {
      if (null === x3)
        return document.createTextNode(k2);
      l3 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", x3) : document.createElement(x3, k2.is && k2), r3 = null, e3 = false;
    }
    if (null === x3)
      w2 === k2 || e3 && l3.data === k2 || (l3.data = k2);
    else {
      if (r3 = r3 && n2.call(l3.childNodes), w2 = t3.props || c, !e3 && null != r3)
        for (w2 = {}, a3 = 0; a3 < l3.attributes.length; a3++)
          w2[(_ = l3.attributes[a3]).name] = _.value;
      for (a3 in w2)
        _ = w2[a3], "children" == a3 || ("dangerouslySetInnerHTML" == a3 ? y3 = _ : "key" === a3 || a3 in k2 || T(l3, a3, null, _, o3));
      for (a3 in k2)
        _ = k2[a3], "children" == a3 ? d2 = _ : "dangerouslySetInnerHTML" == a3 ? v2 = _ : "value" == a3 ? g2 = _ : "checked" == a3 ? b2 = _ : "key" === a3 || e3 && "function" != typeof _ || w2[a3] === _ || T(l3, a3, _, w2[a3], o3);
      if (v2)
        e3 || y3 && (v2.__html === y3.__html || v2.__html === l3.innerHTML) || (l3.innerHTML = v2.__html), u3.__k = [];
      else if (y3 && (l3.innerHTML = ""), C(l3, h(d2) ? d2 : [d2], u3, t3, i5, o3 && "foreignObject" !== x3, r3, f4, r3 ? r3[0] : t3.__k && m(t3, 0), e3, s3), null != r3)
        for (a3 = r3.length; a3--; )
          null != r3[a3] && p2(r3[a3]);
      e3 || (a3 = "value", void 0 !== g2 && (g2 !== l3[a3] || "progress" === x3 && !g2 || "option" === x3 && g2 !== w2[a3]) && T(l3, a3, g2, w2[a3], false), a3 = "checked", void 0 !== b2 && b2 !== l3[a3] && T(l3, a3, b2, w2[a3], false));
    }
    return l3;
  }
  function z(n3, u3, t3) {
    try {
      "function" == typeof n3 ? n3(u3) : n3.current = u3;
    } catch (n4) {
      l2.__e(n4, t3);
    }
  }
  function N(n3, u3, t3) {
    var i5, o3;
    if (l2.unmount && l2.unmount(n3), (i5 = n3.ref) && (i5.current && i5.current !== n3.__e || z(i5, null, u3)), null != (i5 = n3.__c)) {
      if (i5.componentWillUnmount)
        try {
          i5.componentWillUnmount();
        } catch (n4) {
          l2.__e(n4, u3);
        }
      i5.base = i5.__P = null, n3.__c = void 0;
    }
    if (i5 = n3.__k)
      for (o3 = 0; o3 < i5.length; o3++)
        i5[o3] && N(i5[o3], u3, t3 || "function" != typeof n3.type);
    t3 || null == n3.__e || p2(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
  }
  function O(n3, l3, u3) {
    return this.constructor(n3, u3);
  }
  function q(u3, t3, i5) {
    var o3, r3, f4, e3;
    l2.__ && l2.__(u3, t3), r3 = (o3 = "function" == typeof i5) ? null : i5 && i5.__k || t3.__k, f4 = [], e3 = [], L(t3, u3 = (!o3 && i5 || t3).__k = y2(g, null, [u3]), r3 || c, c, void 0 !== t3.ownerSVGElement, !o3 && i5 ? [i5] : r3 ? null : t3.firstChild ? n2.call(t3.childNodes) : null, f4, !o3 && i5 ? i5 : r3 ? r3.__e : t3.firstChild, o3, e3), M(f4, u3, e3);
  }
  n2 = s2.slice, l2 = { __e: function(n3, l3, u3, t3) {
    for (var i5, o3, r3; l3 = l3.__; )
      if ((i5 = l3.__c) && !i5.__)
        try {
          if ((o3 = i5.constructor) && null != o3.getDerivedStateFromError && (i5.setState(o3.getDerivedStateFromError(n3)), r3 = i5.__d), null != i5.componentDidCatch && (i5.componentDidCatch(n3, t3 || {}), r3 = i5.__d), r3)
            return i5.__E = i5;
        } catch (l4) {
          n3 = l4;
        }
    throw n3;
  } }, u = 0, t2 = function(n3) {
    return null != n3 && null == n3.constructor;
  }, b.prototype.setState = function(n3, l3) {
    var u3;
    u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n3 && (n3 = n3(v({}, u3), this.props)), n3 && v(u3, n3), null != n3 && this.__v && (l3 && this._sb.push(l3), k(this));
  }, b.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), k(this));
  }, b.prototype.render = g, i3 = [], r2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f2 = function(n3, l3) {
    return n3.__v.__b - l3.__v.__b;
  }, x2.__r = 0, e2 = 0;

  // ../../node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
  var f3 = 0;
  var i4 = Array.isArray;
  function u2(e3, t3, n3, o3, i5, u3) {
    var a3, c2, p3 = {};
    for (c2 in t3)
      "ref" == c2 ? a3 = t3[c2] : p3[c2] = t3[c2];
    var l3 = { type: e3, props: p3, key: n3, ref: a3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f3, __i: -1, __u: 0, __source: i5, __self: u3 };
    if ("function" == typeof e3 && (a3 = e3.defaultProps))
      for (c2 in a3)
        void 0 === p3[c2] && (p3[c2] = a3[c2]);
    return l2.vnode && l2.vnode(l3), l3;
  }

  // ../widgets/src/components.tsx
  var IconButton = (props) => {
    const { className, label, onClick } = props;
    return /* @__PURE__ */ u2("div", { className: "deck-widget-button", children: /* @__PURE__ */ u2(
      "button",
      {
        className: `deck-widget-icon-button ${className}`,
        type: "button",
        onClick,
        title: label,
        children: /* @__PURE__ */ u2("div", { className: "deck-widget-icon" })
      }
    ) });
  };
  var ButtonGroup = (props) => {
    const { children, orientation } = props;
    return /* @__PURE__ */ u2("div", { className: `deck-widget-button-group ${orientation}`, children });
  };
  var GroupedIconButton = (props) => {
    const { className, label, onClick } = props;
    return /* @__PURE__ */ u2(
      "button",
      {
        className: `deck-widget-icon-button ${className}`,
        type: "button",
        onClick,
        title: label,
        children: /* @__PURE__ */ u2("div", { className: "deck-widget-icon" })
      }
    );
  };

  // ../widgets/src/fullscreen-widget.tsx
  var FullscreenWidget = class {
    constructor(props) {
      this.id = "fullscreen";
      this.placement = "top-left";
      this.fullscreen = false;
      this.id = props.id || "fullscreen";
      this.placement = props.placement || "top-left";
      props.enterLabel = props.enterLabel || "Enter Fullscreen";
      props.exitLabel = props.exitLabel || "Exit Fullscreen";
      props.style = props.style || {};
      this.props = props;
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const el = document.createElement("div");
      el.classList.add("deck-widget", "deck-widget-fullscreen");
      if (className)
        el.classList.add(className);
      if (style) {
        Object.entries(style).map(([key, value]) => el.style.setProperty(key, value));
      }
      this.deck = deck;
      this.element = el;
      this.update();
      document.addEventListener("fullscreenchange", this.onFullscreenChange.bind(this));
      return el;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
      document.removeEventListener("fullscreenchange", this.onFullscreenChange.bind(this));
    }
    update() {
      const { enterLabel, exitLabel } = this.props;
      const el = this.element;
      if (!el) {
        return;
      }
      const ui = /* @__PURE__ */ u2(
        IconButton,
        {
          onClick: this.handleClick.bind(this),
          label: this.fullscreen ? exitLabel : enterLabel,
          className: this.fullscreen ? "deck-widget-fullscreen-exit" : "deck-widget-fullscreen-enter"
        }
      );
      q(ui, el);
    }
    setProps(props) {
      const oldProps = this.props;
      const el = this.element;
      if (el) {
        if (oldProps.className !== props.className) {
          if (oldProps.className)
            el.classList.remove(oldProps.className);
          if (props.className)
            el.classList.add(props.className);
        }
        if (!deepEqual2(oldProps.style, props.style, 1)) {
          if (oldProps.style) {
            Object.entries(oldProps.style).map(([key]) => el.style.removeProperty(key));
          }
          if (props.style) {
            Object.entries(props.style).map(
              ([key, value]) => el.style.setProperty(key, value)
            );
          }
        }
      }
      Object.assign(this.props, props);
    }
    getContainer() {
      return this.props.container || this.deck?.getCanvas()?.parentElement;
    }
    onFullscreenChange() {
      const prevFullscreen = this.fullscreen;
      const fullscreen = document.fullscreenElement === this.getContainer();
      if (prevFullscreen !== fullscreen) {
        this.fullscreen = !this.fullscreen;
      }
      this.update();
    }
    async handleClick() {
      if (this.fullscreen) {
        await this.exitFullscreen();
      } else {
        await this.requestFullscreen();
      }
      this.update();
    }
    async requestFullscreen() {
      const container = this.getContainer();
      if (container?.requestFullscreen) {
        await container.requestFullscreen({ navigationUI: "hide" });
      } else {
        this.togglePseudoFullscreen();
      }
    }
    async exitFullscreen() {
      if (document.exitFullscreen) {
        await document.exitFullscreen();
      } else {
        this.togglePseudoFullscreen();
      }
    }
    togglePseudoFullscreen() {
      this.getContainer()?.classList.toggle("deck-pseudo-fullscreen");
    }
  };

  // ../widgets/src/compass-widget.tsx
  var CompassWidget = class {
    constructor(props) {
      this.id = "compass";
      this.placement = "top-left";
      this.viewId = null;
      this.id = props.id || "compass";
      this.viewId = props.viewId || null;
      this.placement = props.placement || "top-left";
      props.transitionDuration = props.transitionDuration || 200;
      props.label = props.label || "Compass";
      props.style = props.style || {};
      this.props = props;
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    onViewportChange(viewport) {
      this.viewport = viewport;
      this.update();
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const element = document.createElement("div");
      element.classList.add("deck-widget", "deck-widget-compass");
      if (className)
        element.classList.add(className);
      if (style) {
        Object.entries(style).map(([key, value]) => element.style.setProperty(key, value));
      }
      this.deck = deck;
      this.element = element;
      this.update();
      return element;
    }
    getRotation() {
      if (this.viewport instanceof WebMercatorViewport2) {
        return [-this.viewport.bearing, this.viewport.pitch];
      } else if (this.viewport instanceof GlobeViewport) {
        return [0, Math.max(-80, Math.min(80, this.viewport.latitude))];
      }
      return [0, 0];
    }
    update() {
      const [rz, rx] = this.getRotation();
      const element = this.element;
      if (!element) {
        return;
      }
      const ui = /* @__PURE__ */ u2("div", { className: "deck-widget-button", style: { perspective: 100 }, children: /* @__PURE__ */ u2(
        "button",
        {
          type: "button",
          onClick: () => this.handleCompassReset(),
          label: this.props.label,
          style: { transform: `rotateX(${rx}deg)` },
          children: /* @__PURE__ */ u2("svg", { fill: "none", width: "100%", height: "100%", viewBox: "0 0 26 26", children: /* @__PURE__ */ u2("g", { transform: `rotate(${rz},13,13)`, children: [
            /* @__PURE__ */ u2(
              "path",
              {
                d: "M10 13.0001L12.9999 5L15.9997 13.0001H10Z",
                fill: "var(--icon-compass-north-color, #F05C44)"
              }
            ),
            /* @__PURE__ */ u2(
              "path",
              {
                d: "M16.0002 12.9999L13.0004 21L10.0005 12.9999H16.0002Z",
                fill: "var(--icon-compass-south-color, #C2C2CC)"
              }
            )
          ] }) })
        }
      ) });
      q(ui, element);
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    handleCompassReset() {
      const viewId = this.viewId || "default-view";
      if (this.viewport instanceof WebMercatorViewport2) {
        const nextViewState = {
          ...this.viewport,
          bearing: 0,
          ...this.getRotation()[0] === 0 ? { pitch: 0 } : {},
          transitionDuration: this.props.transitionDuration,
          transitionInterpolator: new FlyToInterpolator()
        };
        this.deck._onViewStateChange({ viewId, viewState: nextViewState, interactionState: {} });
      }
    }
  };

  // ../widgets/src/zoom-widget.tsx
  var ZoomWidget = class {
    constructor(props) {
      this.id = "zoom";
      this.placement = "top-left";
      this.orientation = "vertical";
      this.viewId = null;
      this.id = props.id || "zoom";
      this.viewId = props.viewId || null;
      this.placement = props.placement || "top-left";
      this.orientation = props.orientation || "vertical";
      props.transitionDuration = props.transitionDuration || 200;
      props.zoomInLabel = props.zoomInLabel || "Zoom In";
      props.zoomOutLabel = props.zoomOutLabel || "Zoom Out";
      props.style = props.style || {};
      this.props = props;
    }
    onAdd({ deck }) {
      const { style, className } = this.props;
      const element = document.createElement("div");
      element.classList.add("deck-widget", "deck-widget-zoom");
      if (className)
        element.classList.add(className);
      if (style) {
        Object.entries(style).map(([key, value]) => element.style.setProperty(key, value));
      }
      const ui = /* @__PURE__ */ u2(ButtonGroup, { orientation: this.orientation, children: [
        /* @__PURE__ */ u2(
          GroupedIconButton,
          {
            onClick: () => this.handleZoomIn(),
            label: this.props.zoomInLabel,
            className: "deck-widget-zoom-in"
          }
        ),
        /* @__PURE__ */ u2(
          GroupedIconButton,
          {
            onClick: () => this.handleZoomOut(),
            label: this.props.zoomOutLabel,
            className: "deck-widget-zoom-out"
          }
        )
      ] });
      q(ui, element);
      this.deck = deck;
      this.element = element;
      return element;
    }
    onRemove() {
      this.deck = void 0;
      this.element = void 0;
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    onViewportChange(viewport) {
      this.viewport = viewport;
    }
    handleZoom(nextZoom) {
      const viewId = this.viewId || "default-view";
      const nextViewState = {
        ...this.viewport,
        zoom: nextZoom,
        transitionDuration: this.props.transitionDuration,
        transitionInterpolator: new FlyToInterpolator()
      };
      this.deck._onViewStateChange({ viewId, viewState: nextViewState, interactionState: {} });
    }
    handleZoomIn() {
      if (this.viewport) {
        this.handleZoom(this.viewport.zoom + 1);
      }
    }
    handleZoomOut() {
      if (this.viewport) {
        this.handleZoom(this.viewport.zoom - 1);
      }
    }
  };

  // ../widgets/src/themes.ts
  var LightTheme = {
    "--button-background": "#fff",
    "--button-stroke": "rgba(255, 255, 255, 0.3)",
    "--button-inner-stroke": "unset",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25)",
    "--button-backdrop-filter": "unset",
    "--button-icon-idle": "rgba(97, 97, 102, 1)",
    "--button-icon-hover": "rgba(24, 24, 26, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var DarkTheme = {
    "--button-background": "rgba(18, 18, 20, 1)",
    "--button-stroke": "rgba(18, 18, 20, 0.30)",
    "--button-inner-stroke": "unset",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25)",
    "--button-backdrop-filter": "unset",
    "--button-icon-idle": "rgba(158, 157, 168, 1)",
    "--button-icon-hover": "rgba(215, 214, 229, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var LightGlassTheme = {
    "--button-background": "rgba(255, 255, 255, 0.6)",
    "--button-stroke": "rgba(255, 255, 255, 0.3)",
    "--button-inner-stroke": "1px solid rgba(255, 255, 255, 0.6)",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25), 0px 0px 8px 0px rgba(0, 0, 0, 0.1) inset",
    "--button-backdrop-filter": "blur(4px)",
    "--button-icon-idle": "rgba(97, 97, 102, 1)",
    "--button-icon-hover": "rgba(24, 24, 26, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };
  var DarkGlassTheme = {
    "--button-background": "rgba(18, 18, 20, 0.75)",
    "--button-stroke": "rgba(18, 18, 20, 0.30)",
    "--button-inner-stroke": "1px solid rgba(18, 18, 20, 0.75)",
    "--button-shadow": "0px 0px 8px 0px rgba(0, 0, 0, 0.25), 0px 0px 8px 0px rgba(0, 0, 0, 0.1) inset",
    "--button-backdrop-filter": "blur(4px)",
    "--button-icon-idle": "rgba(158, 157, 168, 1)",
    "--button-icon-hover": "rgba(215, 214, 229, 1)",
    "--icon-compass-north-color": "#F05C44",
    "--icon-compass-south-color": "#C2C2CC"
  };

  // bundle.ts
  var h3 = __toESM(require_h3_js(), 1);
  H3HexagonLayer._checkH3Lib = () => {
    const installHelp = 'include the <script src="https://unpkg.com/h3-js@^4.0.0"></script> tag before the deck.gl script tag. https://deck.gl/docs/api-reference/geo-layers/h3-hexagon-layer';
    if (!h3) {
      throw new Error(`To use H3 functionality, ${installHelp}`);
    } else if (h3.polyfill && !h3.polygonToCells) {
      throw new Error(`Incompatible h3-js version. ${installHelp}`);
    }
  };
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
