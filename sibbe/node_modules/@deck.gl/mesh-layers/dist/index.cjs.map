{
  "version": 3,
  "sources": ["index.js", "simple-mesh-layer/simple-mesh-layer.js", "utils/matrix.js", "simple-mesh-layer/simple-mesh-layer-vertex.glsl.js", "simple-mesh-layer/simple-mesh-layer-fragment.glsl.js", "scenegraph-layer/scenegraph-layer.js", "scenegraph-layer/gltf-utils.js", "scenegraph-layer/scenegraph-layer-vertex.glsl.js", "scenegraph-layer/scenegraph-layer-fragment.glsl.js"],
  "sourcesContent": ["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable max-len */\n// TODO - v9 - restore when luma.gl/gltf module is available again\nexport { default as SimpleMeshLayer } from \"./simple-mesh-layer/simple-mesh-layer.js\";\nexport { default as ScenegraphLayer } from \"./scenegraph-layer/scenegraph-layer.js\";\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Layer, project32, phongLighting, picking, log } from '@deck.gl/core';\nimport { Texture } from '@luma.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { MATRIX_ATTRIBUTES, shouldComposeModelMatrix } from \"../utils/matrix.js\";\nimport vs from \"./simple-mesh-layer-vertex.glsl.js\";\nimport fs from \"./simple-mesh-layer-fragment.glsl.js\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nfunction normalizeGeometryAttributes(attributes) {\n    const positionAttribute = attributes.positions || attributes.POSITION;\n    log.assert(positionAttribute, 'no \"postions\" or \"POSITION\" attribute in mesh');\n    const vertexCount = positionAttribute.value.length / positionAttribute.size;\n    let colorAttribute = attributes.COLOR_0 || attributes.colors;\n    if (!colorAttribute) {\n        colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };\n    }\n    let normalAttribute = attributes.NORMAL || attributes.normals;\n    if (!normalAttribute) {\n        normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };\n    }\n    let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;\n    if (!texCoordAttribute) {\n        texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };\n    }\n    return {\n        positions: positionAttribute,\n        colors: colorAttribute,\n        normals: normalAttribute,\n        texCoords: texCoordAttribute\n    };\n}\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n    if (data instanceof Geometry) {\n        // @ts-expect-error data.attributes is readonly\n        data.attributes = normalizeGeometryAttributes(data.attributes);\n        return data;\n    }\n    else if (data.attributes) {\n        return new Geometry({\n            ...data,\n            topology: 'triangle-list',\n            attributes: normalizeGeometryAttributes(data.attributes)\n        });\n    }\n    else {\n        return new Geometry({\n            topology: 'triangle-list',\n            attributes: normalizeGeometryAttributes(data)\n        });\n    }\n}\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    mesh: { type: 'object', value: null, async: true },\n    texture: { type: 'image', value: null, async: true },\n    sizeScale: { type: 'number', value: 1, min: 0 },\n    // _instanced is a hack to use world position instead of meter offsets in mesh\n    // TODO - formalize API\n    _instanced: true,\n    // NOTE(Tarek): Quick and dirty wireframe. Just draws\n    // the same mesh with LINE_STRIPS. Won't follow edges\n    // of the original mesh.\n    wireframe: false,\n    // Optional material for 'lighting' shader module\n    material: true,\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getColor: { type: 'accessor', value: DEFAULT_COLOR },\n    // yaw, pitch and roll are in degrees\n    // https://en.wikipedia.org/wiki/Euler_angles\n    // [pitch, yaw, roll]\n    getOrientation: { type: 'accessor', value: [0, 0, 0] },\n    getScale: { type: 'accessor', value: [1, 1, 1] },\n    getTranslation: { type: 'accessor', value: [0, 0, 0] },\n    // 4x4 matrix\n    getTransformMatrix: { type: 'accessor', value: [] },\n    textureParameters: { type: 'object', ignore: true, value: null }\n};\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer extends Layer {\n    static { this.defaultProps = defaultProps; }\n    static { this.layerName = 'SimpleMeshLayer'; }\n    getShaders() {\n        return super.getShaders({\n            vs,\n            fs,\n            modules: [project32, phongLighting, picking]\n        });\n    }\n    getBounds() {\n        if (this.props._instanced) {\n            return super.getBounds();\n        }\n        let result = this.state.positionBounds;\n        if (result) {\n            return result;\n        }\n        const { mesh } = this.props;\n        if (!mesh) {\n            return null;\n        }\n        // @ts-ignore Detect if mesh is generated by loaders.gl\n        result = mesh.header?.boundingBox;\n        if (!result) {\n            // Otherwise, calculate bounding box from positions\n            const { attributes } = getGeometry(mesh);\n            attributes.POSITION = attributes.POSITION || attributes.positions;\n            //@ts-expect-error\n            result = getMeshBoundingBox(attributes);\n        }\n        this.state.positionBounds = result;\n        return result;\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        // attributeManager is always defined in a primitive layer\n        attributeManager.addInstanced({\n            instancePositions: {\n                transition: true,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                size: 3,\n                accessor: 'getPosition'\n            },\n            instanceColors: {\n                type: 'unorm8',\n                transition: true,\n                size: this.props.colorFormat.length,\n                accessor: 'getColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceModelMatrix: MATRIX_ATTRIBUTES\n        });\n        this.setState({\n            // Avoid luma.gl's missing uniform warning\n            // TODO - add feature to luma.gl to specify ignored uniforms?\n            emptyTexture: this.context.device.createTexture({\n                data: new Uint8Array(4),\n                width: 1,\n                height: 1\n            })\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n            this.state.positionBounds = null;\n            this.state.model?.destroy();\n            if (props.mesh) {\n                this.state.model = this.getModel(props.mesh);\n                const attributes = props.mesh.attributes || props.mesh;\n                this.setState({\n                    hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n                });\n            }\n            // attributeManager is always defined in a primitive layer\n            this.getAttributeManager().invalidateAll();\n        }\n        if (props.texture !== oldProps.texture && props.texture instanceof Texture) {\n            this.setTexture(props.texture);\n        }\n        if (this.state.model) {\n            this.state.model.setTopology(this.props.wireframe ? 'line-strip' : 'triangle-list');\n        }\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.emptyTexture.delete();\n    }\n    draw({ uniforms }) {\n        const { model } = this.state;\n        if (!model) {\n            return;\n        }\n        const { viewport, renderPass } = this.context;\n        const { sizeScale, coordinateSystem, _instanced } = this.props;\n        model.setUniforms(uniforms);\n        model.setUniforms({\n            sizeScale,\n            composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n            flatShading: !this.state.hasNormals\n        });\n        model.draw(renderPass);\n    }\n    get isLoaded() {\n        return Boolean(this.state?.model && super.isLoaded);\n    }\n    getModel(mesh) {\n        const model = new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: getGeometry(mesh),\n            isInstanced: true\n        });\n        const { texture } = this.props;\n        const { emptyTexture } = this.state;\n        model.setBindings({\n            sampler: texture || emptyTexture\n        });\n        model.setUniforms({\n            hasTexture: Boolean(texture)\n        });\n        return model;\n    }\n    setTexture(texture) {\n        const { emptyTexture, model } = this.state;\n        // props.mesh may not be ready at this time.\n        // The sampler will be set when `getModel` is called\n        if (model) {\n            model.setBindings({\n                sampler: texture || emptyTexture\n            });\n            model.setUniforms({\n                hasTexture: Boolean(texture)\n            });\n        }\n    }\n}\n", "import { COORDINATE_SYSTEM, createIterable } from '@deck.gl/core';\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n    const pitch = orientation[0] * RADIAN_PER_DEGREE;\n    const yaw = orientation[1] * RADIAN_PER_DEGREE;\n    const roll = orientation[2] * RADIAN_PER_DEGREE;\n    const sr = Math.sin(roll);\n    const sp = Math.sin(pitch);\n    const sw = Math.sin(yaw);\n    const cr = Math.cos(roll);\n    const cp = Math.cos(pitch);\n    const cw = Math.cos(yaw);\n    const scx = scale[0];\n    const scy = scale[1];\n    const scz = scale[2];\n    targetMatrix[0] = scx * cw * cp; // 0,0\n    targetMatrix[1] = scx * sw * cp; // 1,0\n    targetMatrix[2] = scx * -sp; // 2,0\n    targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n    targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n    targetMatrix[5] = scy * cp * sr; // 2,1\n    targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n    targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n    targetMatrix[8] = scz * cp * cr; // 2,2\n}\nfunction getExtendedMat3FromMat4(mat4) {\n    mat4[0] = mat4[0];\n    mat4[1] = mat4[1];\n    mat4[2] = mat4[2];\n    mat4[3] = mat4[4];\n    mat4[4] = mat4[5];\n    mat4[5] = mat4[6];\n    mat4[6] = mat4[8];\n    mat4[7] = mat4[9];\n    mat4[8] = mat4[10];\n    mat4[9] = mat4[12];\n    mat4[10] = mat4[13];\n    mat4[11] = mat4[14];\n    return mat4.subarray(0, 12);\n}\nexport const MATRIX_ATTRIBUTES = {\n    size: 12,\n    accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n    shaderAttributes: {\n        instanceModelMatrixCol0: {\n            size: 3,\n            elementOffset: 0\n        },\n        instanceModelMatrixCol1: {\n            size: 3,\n            elementOffset: 3\n        },\n        instanceModelMatrixCol2: {\n            size: 3,\n            elementOffset: 6\n        },\n        instanceTranslation: {\n            size: 3,\n            elementOffset: 9\n        }\n    },\n    update(attribute, { startRow, endRow }) {\n        // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n        const { data, getOrientation, getScale, getTranslation, getTransformMatrix } = this.props;\n        const arrayMatrix = Array.isArray(getTransformMatrix);\n        const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n        const constantScale = Array.isArray(getScale);\n        const constantOrientation = Array.isArray(getOrientation);\n        const constantTranslation = Array.isArray(getTranslation);\n        const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n        if (hasMatrix) {\n            attribute.constant = constantMatrix;\n        }\n        else {\n            attribute.constant = constantOrientation && constantScale && constantTranslation;\n        }\n        const instanceModelMatrixData = attribute.value;\n        if (attribute.constant) {\n            let matrix;\n            if (hasMatrix) {\n                modelMatrix.set(getTransformMatrix);\n                matrix = getExtendedMat3FromMat4(modelMatrix);\n            }\n            else {\n                matrix = valueArray;\n                const orientation = getOrientation;\n                const scale = getScale;\n                calculateTransformMatrix(matrix, orientation, scale);\n                matrix.set(getTranslation, 9);\n            }\n            attribute.value = new Float32Array(matrix);\n        }\n        else {\n            let i = startRow * attribute.size;\n            const { iterable, objectInfo } = createIterable(data, startRow, endRow);\n            for (const object of iterable) {\n                objectInfo.index++;\n                let matrix;\n                if (hasMatrix) {\n                    modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));\n                    matrix = getExtendedMat3FromMat4(modelMatrix);\n                }\n                else {\n                    matrix = valueArray;\n                    const orientation = constantOrientation\n                        ? getOrientation\n                        : getOrientation(object, objectInfo);\n                    const scale = constantScale ? getScale : getScale(object, objectInfo);\n                    calculateTransformMatrix(matrix, orientation, scale);\n                    matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n                }\n                instanceModelMatrixData[i++] = matrix[0];\n                instanceModelMatrixData[i++] = matrix[1];\n                instanceModelMatrixData[i++] = matrix[2];\n                instanceModelMatrixData[i++] = matrix[3];\n                instanceModelMatrixData[i++] = matrix[4];\n                instanceModelMatrixData[i++] = matrix[5];\n                instanceModelMatrixData[i++] = matrix[6];\n                instanceModelMatrixData[i++] = matrix[7];\n                instanceModelMatrixData[i++] = matrix[8];\n                instanceModelMatrixData[i++] = matrix[9];\n                instanceModelMatrixData[i++] = matrix[10];\n                instanceModelMatrixData[i++] = matrix[11];\n            }\n        }\n    }\n};\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n    return (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n        (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial));\n}\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\nuniform float sizeScale;\nuniform bool composeModelMatrix;\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\ngeometry.uv = texCoords;\ngeometry.pickingColor = instancePickingColors;\nvTexCoord = texCoords;\ncameraPosition = project_uCameraPosition;\nvColor = vec4(colors * instanceColors.rgb, instanceColors.a);\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;\nif (composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\ngeometry.position = position_commonspace;\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\ngeometry.position = position_commonspace;\nnormals_commonspace = project_normal(instanceModelMatrix * normals);\n}\ngeometry.normal = normals_commonspace;\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\nprecision highp float;\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform bool flatShading;\nuniform float opacity;\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = vTexCoord;\nvec3 normal;\nif (flatShading) {\nnormal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n} else {\nnormal = normals_commonspace;\n}\nvec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;\nDECKGL_FILTER_COLOR(color, geometry);\nvec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\nfragColor = vec4(lightColor, color.a * opacity);\n}\n`;\n", "// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Layer, project32, picking, log } from '@deck.gl/core';\nimport { pbr } from '@luma.gl/shadertools';\nimport { ScenegraphNode, GroupNode, ModelNode } from '@luma.gl/engine';\nimport { createScenegraphsFromGLTF } from '@luma.gl/gltf';\nimport { GLTFLoader, postProcessGLTF } from '@loaders.gl/gltf';\nimport { waitForGLTFAssets } from \"./gltf-utils.js\";\nimport { MATRIX_ATTRIBUTES, shouldComposeModelMatrix } from \"../utils/matrix.js\";\nimport vs from \"./scenegraph-layer-vertex.glsl.js\";\nimport fs from \"./scenegraph-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst defaultProps = {\n    scenegraph: { type: 'object', value: null, async: true },\n    getScene: gltf => {\n        if (gltf && gltf.scenes) {\n            // gltf post processor replaces `gltf.scene` number with the scene `object`\n            return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n        }\n        return gltf;\n    },\n    getAnimator: scenegraph => scenegraph && scenegraph.animator,\n    _animations: null,\n    sizeScale: { type: 'number', value: 1, min: 0 },\n    sizeMinPixels: { type: 'number', min: 0, value: 0 },\n    sizeMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getColor: { type: 'accessor', value: DEFAULT_COLOR },\n    // flat or pbr\n    _lighting: 'flat',\n    // _lighting must be pbr for this to work\n    _imageBasedLightingEnvironment: undefined,\n    // yaw, pitch and roll are in degrees\n    // https://en.wikipedia.org/wiki/Euler_angles\n    // [pitch, yaw, roll]\n    getOrientation: { type: 'accessor', value: [0, 0, 0] },\n    getScale: { type: 'accessor', value: [1, 1, 1] },\n    getTranslation: { type: 'accessor', value: [0, 0, 0] },\n    // 4x4 matrix\n    getTransformMatrix: { type: 'accessor', value: [] },\n    loaders: [GLTFLoader]\n};\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer extends Layer {\n    static { this.defaultProps = defaultProps; }\n    static { this.layerName = 'ScenegraphLayer'; }\n    getShaders() {\n        const modules = [project32, picking];\n        if (this.props._lighting === 'pbr') {\n            modules.push(pbr);\n        }\n        return super.getShaders({ vs, fs, modules });\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        // attributeManager is always defined for primitive layers\n        attributeManager.addInstanced({\n            instancePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                accessor: 'getPosition',\n                transition: true\n            },\n            instanceColors: {\n                type: 'unorm8',\n                size: this.props.colorFormat.length,\n                accessor: 'getColor',\n                defaultValue: DEFAULT_COLOR,\n                transition: true\n            },\n            instanceModelMatrix: MATRIX_ATTRIBUTES\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps } = params;\n        if (props.scenegraph !== oldProps.scenegraph) {\n            this._updateScenegraph();\n        }\n        else if (props._animations !== oldProps._animations) {\n            this._applyAnimationsProp(this.state.animator, props._animations);\n        }\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        this.state.scenegraph?.destroy();\n    }\n    get isLoaded() {\n        return Boolean(this.state?.scenegraph && super.isLoaded);\n    }\n    _updateScenegraph() {\n        const props = this.props;\n        const { device } = this.context;\n        let scenegraphData = null;\n        if (props.scenegraph instanceof ScenegraphNode) {\n            // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n            scenegraphData = { scenes: [props.scenegraph] };\n        }\n        else if (props.scenegraph && typeof props.scenegraph === 'object') {\n            // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n            const gltf = props.scenegraph;\n            // Tiles3DLoader already processes GLTF\n            const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n            const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n            scenegraphData = { gltf: processedGLTF, ...gltfObjects };\n            waitForGLTFAssets(gltfObjects)\n                .then(() => {\n                this.setNeedsRedraw();\n            })\n                .catch(ex => {\n                this.raiseError(ex, 'loading glTF');\n            });\n        }\n        const options = { layer: this, device: this.context.device };\n        const scenegraph = props.getScene(scenegraphData, options);\n        const animator = props.getAnimator(scenegraphData, options);\n        if (scenegraph instanceof GroupNode) {\n            this.state.scenegraph?.destroy();\n            this._applyAnimationsProp(animator, props._animations);\n            const models = [];\n            scenegraph.traverse(node => {\n                if (node instanceof ModelNode) {\n                    models.push(node.model);\n                }\n            });\n            this.setState({ scenegraph, animator, models });\n            this.getAttributeManager().invalidateAll();\n        }\n        else if (scenegraph !== null) {\n            log.warn('invalid scenegraph:', scenegraph)();\n        }\n    }\n    _applyAnimationsProp(animator, animationsProp) {\n        if (!animator || !animationsProp) {\n            return;\n        }\n        const animations = animator.getAnimations();\n        // sort() to ensure '*' comes first so that other values can override\n        Object.keys(animationsProp)\n            .sort()\n            .forEach(key => {\n            // Key can be:\n            //  - number for index number\n            //  - name for animation name\n            //  - * to affect all animations\n            const value = animationsProp[key];\n            if (key === '*') {\n                animations.forEach(animation => {\n                    Object.assign(animation, value);\n                });\n            }\n            else if (Number.isFinite(Number(key))) {\n                const number = Number(key);\n                if (number >= 0 && number < animations.length) {\n                    Object.assign(animations[number], value);\n                }\n                else {\n                    log.warn(`animation ${key} not found`)();\n                }\n            }\n            else {\n                const findResult = animations.find(({ name }) => name === key);\n                if (findResult) {\n                    Object.assign(findResult, value);\n                }\n                else {\n                    log.warn(`animation ${key} not found`)();\n                }\n            }\n        });\n    }\n    _getModelOptions() {\n        const { _imageBasedLightingEnvironment } = this.props;\n        let env;\n        if (_imageBasedLightingEnvironment) {\n            if (typeof _imageBasedLightingEnvironment === 'function') {\n                env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });\n            }\n            else {\n                env = _imageBasedLightingEnvironment;\n            }\n        }\n        return {\n            imageBasedLightingEnvironment: env,\n            modelOptions: {\n                id: this.props.id,\n                isInstanced: true,\n                bufferLayout: this.getAttributeManager().getBufferLayouts(),\n                ...this.getShaders()\n            },\n            // tangents are not supported\n            useTangents: false\n        };\n    }\n    draw({ context }) {\n        if (!this.state.scenegraph)\n            return;\n        if (this.props._animations && this.state.animator) {\n            this.state.animator.animate(context.timeline.getTime());\n            this.setNeedsRedraw();\n        }\n        const { viewport, renderPass } = this.context;\n        const { sizeScale, sizeMinPixels, sizeMaxPixels, opacity, coordinateSystem } = this.props;\n        const numInstances = this.getNumInstances();\n        this.state.scenegraph.traverse((node, { worldMatrix }) => {\n            if (node instanceof ModelNode) {\n                const { model } = node;\n                model.setInstanceCount(numInstances);\n                model.setUniforms({\n                    sizeScale,\n                    opacity,\n                    sizeMinPixels,\n                    sizeMaxPixels,\n                    composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n                    sceneModelMatrix: worldMatrix,\n                    // Needed for PBR (TODO: find better way to get it)\n                    // eslint-disable-next-line camelcase\n                    u_Camera: model.uniforms.project_uCameraPosition\n                });\n                model.draw(renderPass);\n            }\n        });\n    }\n}\n", "export async function waitForGLTFAssets(gltfObjects) {\n    const remaining = [];\n    gltfObjects.scenes.forEach(scene => {\n        scene.traverse((modelNode) => {\n            // TODO v9 getUnforms() was removed, hack it with props.uniforms\n            Object.values(modelNode.model.uniforms).forEach((uniform) => {\n                if (uniform.loaded === false) {\n                    remaining.push(uniform);\n                }\n            });\n        });\n    });\n    return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\nasync function waitWhileCondition(condition) {\n    while (condition()) {\n        await new Promise(resolve => requestAnimationFrame(resolve));\n    }\n}\n", "export default `\\\n#version 300 es\n#define SHADER_NAME scenegraph-layer-vertex-shader\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform mat4 sceneModelMatrix;\nuniform bool composeModelMatrix;\nin vec3 positions;\n#ifdef HAS_UV\nin vec2 texCoords;\n#endif\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nin vec3 normals;\n#endif\n#endif\nout vec4 vColor;\n#ifndef MODULE_PBR\n#ifdef HAS_UV\nout vec2 vTEXCOORD_0;\n#endif\n#endif\nvoid main(void) {\n#if defined(HAS_UV) && !defined(MODULE_PBR)\nvTEXCOORD_0 = texCoords;\ngeometry.uv = texCoords;\n#endif\ngeometry.worldPosition = instancePositions;\ngeometry.pickingColor = instancePickingColors;\nmat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\nvec3 normal = vec3(0.0, 0.0, 1.0);\n#ifdef MODULE_PBR\n#ifdef HAS_NORMALS\nnormal = instanceModelMatrix * (sceneModelMatrix * vec4(normals, 0.0)).xyz;\n#endif\n#endif\nfloat originalSize = project_size_to_pixel(sizeScale);\nfloat clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);\nvec3 pos = (instanceModelMatrix * (sceneModelMatrix * vec4(positions, 1.0)).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;\nif(composeModelMatrix) {\nDECKGL_FILTER_SIZE(pos, geometry);\ngeometry.normal = project_normal(normal);\ngeometry.worldPosition += pos;\ngl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n}\nelse {\npos = project_size(pos);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\ngeometry.normal = project_normal(normal);\n}\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n#ifdef MODULE_PBR\npbr_vPosition = geometry.position.xyz;\n#ifdef HAS_NORMALS\npbr_vNormal = geometry.normal;\n#endif\n#ifdef HAS_UV\npbr_vUV = texCoords;\n#else\npbr_vUV = vec2(0., 0.);\n#endif\ngeometry.uv = pbr_vUV;\n#endif\nvColor = instanceColors;\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "export default `\\\n#version 300 es\n#define SHADER_NAME scenegraph-layer-fragment-shader\nuniform float opacity;\nin vec4 vColor;\nout vec4 fragColor;\n#ifndef MODULE_PBR\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nin vec2 vTEXCOORD_0;\nuniform sampler2D u_BaseColorSampler;\n#endif\n#endif\nvoid main(void) {\n#ifdef MODULE_PBR\nfragColor = vColor * pbr_filterColor(vec4(0));\ngeometry.uv = pbr_vUV;\n#else\n#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\nfragColor = vColor * texture(u_BaseColorSampler, vTEXCOORD_0);\ngeometry.uv = vTEXCOORD_0;\n#else\nfragColor = vColor;\n#endif\n#endif\nfragColor.a *= opacity;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_engine", "import_gltf", "DEFAULT_COLOR", "defaultProps"]
}
