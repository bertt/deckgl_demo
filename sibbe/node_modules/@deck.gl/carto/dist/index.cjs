"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  BASEMAP: () => basemap_default,
  CARTO_LAYERS: () => CARTO_LAYERS,
  CARTO_SOURCES: () => CARTO_SOURCES,
  CartoAPIError: () => CartoAPIError,
  H3TileLayer: () => H3TileLayer,
  QuadbinTileLayer: () => QuadbinTileLayer,
  RasterTileLayer: () => RasterTileLayer,
  SOURCE_DEFAULTS: () => SOURCE_DEFAULTS,
  VectorTileLayer: () => VectorTileLayer,
  _PointLabelLayer: () => PointLabelLayer,
  boundaryQuerySource: () => boundaryQuerySource,
  boundaryTableSource: () => boundaryTableSource,
  colorBins: () => colorBins,
  colorCategories: () => colorCategories,
  colorContinuous: () => colorContinuous,
  fetchMap: () => fetchMap,
  h3QuerySource: () => h3QuerySource,
  h3TableSource: () => h3TableSource,
  h3TilesetSource: () => h3TilesetSource,
  quadbinQuerySource: () => quadbinQuerySource,
  quadbinTableSource: () => quadbinTableSource,
  quadbinTilesetSource: () => quadbinTilesetSource,
  query: () => query,
  rasterSource: () => rasterSource,
  vectorQuerySource: () => vectorQuerySource,
  vectorTableSource: () => vectorTableSource,
  vectorTilesetSource: () => vectorTilesetSource
});
module.exports = __toCommonJS(dist_exports);

// dist/layers/h3-tile-layer.js
var import_core5 = require("@deck.gl/core");
var import_geo_layers3 = require("@deck.gl/geo-layers");

// dist/layers/h3-tileset-2d.js
var import_geo_layers = require("@deck.gl/geo-layers");
var import_h3_js = require("h3-js");
function getHexagonsInBoundingBox({ west, north, east, south }, resolution) {
  const longitudeSpan = Math.abs(east - west);
  if (longitudeSpan > 180) {
    const nSegments = Math.ceil(longitudeSpan / 180);
    let h3Indices2 = [];
    for (let s = 0; s < nSegments; s++) {
      const segmentEast = east + s * 180;
      const segmentWest = Math.min(segmentEast + 179.9999999, west);
      h3Indices2 = h3Indices2.concat(getHexagonsInBoundingBox({ west: segmentWest, north, east: segmentEast, south }, resolution));
    }
    return [...new Set(h3Indices2)];
  }
  const oversample = 2;
  const h3Indices = (0, import_h3_js.polygonToCells)([
    [
      [west, north],
      [west, south],
      [east, south],
      [east, north],
      [west, north]
    ]
  ], resolution + oversample, true);
  return oversample ? [...new Set(h3Indices.map((i) => (0, import_h3_js.cellToParent)(i, resolution)))] : h3Indices;
}
function tileToBoundingBox(index) {
  const coordinates = (0, import_h3_js.cellToBoundary)(index);
  const latitudes = coordinates.map((c) => c[0]);
  const longitudes = coordinates.map((c) => c[1]);
  const west = Math.min(...longitudes);
  const south = Math.min(...latitudes);
  const east = Math.max(...longitudes);
  const north = Math.max(...latitudes);
  return { west, south, east, north };
}
var BIAS = 2;
function getHexagonResolution(viewport, tileSize) {
  const zoomOffset = Math.log2(tileSize / 512);
  const hexagonScaleFactor = 2 / 3 * (viewport.zoom - zoomOffset);
  const latitudeScaleFactor = Math.log(1 / Math.cos(Math.PI * viewport.latitude / 180));
  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));
}
var H3Tileset2D = class extends import_geo_layers._Tileset2D {
  getTileIndices({ viewport, minZoom, maxZoom }) {
    if (viewport.latitude === void 0)
      return [];
    const [east, south, west, north] = viewport.getBounds();
    const { tileSize } = this.opts;
    let z = getHexagonResolution(viewport, tileSize);
    let indices;
    if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
      return [];
    }
    if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
      z = maxZoom;
      const center = (0, import_h3_js.latLngToCell)(viewport.latitude, viewport.longitude, maxZoom);
      indices = (0, import_h3_js.gridDisk)(center, 1);
    } else {
      indices = getHexagonsInBoundingBox({ west, north, east, south }, z);
    }
    return indices.map((i) => ({ i }));
  }
  getTileId({ i }) {
    return i;
  }
  getTileMetadata({ i }) {
    return { bbox: tileToBoundingBox(i) };
  }
  getTileZoom({ i }) {
    return (0, import_h3_js.getResolution)(i);
  }
  getParentIndex(index) {
    const resolution = (0, import_h3_js.getResolution)(index.i);
    const i = (0, import_h3_js.cellToParent)(index.i, resolution - 1);
    return { i };
  }
};

// dist/layers/spatial-index-tile-layer.js
var import_core2 = require("@loaders.gl/core");

// dist/layers/schema/fast-pbf.js
function readPackedTypedArray(TypedArray, pbf, obj) {
  const end = pbf.type === 2 ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
  obj.value = new TypedArray(pbf.buf.buffer.slice(pbf.pos, end));
  pbf.pos = end;
  return obj.value;
}

// dist/layers/schema/carto-raster-tile.js
var ARRAY_TYPES = {
  uint8: Uint8Array,
  uint16: Uint16Array,
  uint32: Uint32Array,
  uint64: BigUint64Array,
  int8: Int8Array,
  int16: Int16Array,
  int32: Int32Array,
  int64: BigInt64Array,
  float32: Float32Array,
  float64: Float64Array
};
var BandReader = class {
  static read(pbf, end) {
    return pbf.readFields(BandReader._readField, { name: "", type: "", data: null }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.name = pbf.readString();
    else if (tag === 2)
      obj.type = pbf.readString();
    else if (tag === 3) {
      const TypedArray = ARRAY_TYPES[obj.type];
      if (!TypedArray) {
        throw Error(`Invalid data type: ${obj.type}`);
      }
      obj.data = {};
      readPackedTypedArray(TypedArray, pbf, obj.data);
    }
  }
};
var TileReader = class {
  static read(pbf, end) {
    return pbf.readFields(TileReader._readField, { blockSize: 0, bands: [] }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.blockSize = pbf.readVarint();
    else if (tag === 2)
      obj.bands.push(BandReader.read(pbf, pbf.readVarint() + pbf.pos));
  }
};

// dist/layers/schema/tile-loader-utils.js
var import_pbf = __toESM(require("pbf"), 1);
function parsePbf(buffer, TileReader5) {
  const pbf = new import_pbf.default(buffer);
  const tile = TileReader5.read(pbf);
  return tile;
}

// dist/utils.js
var import_core = require("@deck.gl/core");
function assert(condition, message) {
  import_core.log.assert(condition, message);
}
function createBinaryProxy(data, index) {
  const { properties, numericProps } = data;
  return new Proxy(properties[index] || {}, {
    get(target, property) {
      if (property in numericProps) {
        return numericProps[property].value[index];
      }
      return target[property];
    },
    has(target, property) {
      return property in numericProps || property in target;
    }
  });
}
function getWorkerUrl(id4, version) {
  return `https://unpkg.com/@deck.gl/carto@${version}/dist/${id4}-worker.js`;
}
function scaleIdentity() {
  let unknown;
  function scale(x) {
    return x === null ? unknown : x;
  }
  scale.invert = scale;
  scale.domain = scale.range = (d) => d;
  scale.unknown = (u) => {
    if (u) {
      unknown = u;
    }
    return unknown;
  };
  scale.copy = () => {
    const scaleCopy = scaleIdentity();
    scaleCopy.unknown(unknown);
    return scaleCopy;
  };
  return scale;
}

// dist/layers/schema/carto-raster-tile-loader.js
var VERSION = true ? "9.0.6" : "latest";
var id = "cartoRasterTile";
var DEFAULT_OPTIONS = {
  cartoRasterTile: {
    workerUrl: getWorkerUrl(id, VERSION)
  }
};
var CartoRasterTileLoader = {
  name: "CARTO Raster Tile",
  version: VERSION,
  id,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-raster-tile"],
  category: "geometry",
  parse: async (arrayBuffer, options) => parseCartoRasterTile(arrayBuffer, options),
  parseSync: parseCartoRasterTile,
  worker: true,
  options: DEFAULT_OPTIONS
};
function parseCartoRasterTile(arrayBuffer, options) {
  if (!arrayBuffer)
    return null;
  const { bands, blockSize } = parsePbf(arrayBuffer, TileReader);
  const numericProps = {};
  for (let i = 0; i < bands.length; i++) {
    const { name, data } = bands[i];
    numericProps[name] = data;
  }
  return { blockSize, cells: { numericProps, properties: [] } };
}
var carto_raster_tile_loader_default = CartoRasterTileLoader;

// dist/layers/schema/carto-tile.js
var KeyValueObjectReader = class {
  static read(pbf, end) {
    return pbf.readFields(KeyValueObjectReader._readField, { key: "", value: null }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.key = pbf.readString();
    else if (tag === 2)
      obj.value = pbf.readString();
  }
};
var PropertiesReader = class {
  static read(pbf, end) {
    return pbf.readFields(PropertiesReader._readField, {}, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1) {
      const { key, value } = KeyValueObjectReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj[key] = value;
    }
  }
};
var DoublesReader = class {
  static read(pbf, end) {
    const { value, size } = pbf.readFields(DoublesReader._readField, { value: [], size: 0 }, end);
    return { value: new Float32Array(value), size };
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      readPackedTypedArray(Float64Array, pbf, obj);
    else if (tag === 2)
      obj.size = pbf.readVarint(true);
  }
};
var IntsReader = class {
  static read(pbf, end) {
    const { value, size } = pbf.readFields(IntsReader._readField, { value: [], size: 0 }, end);
    return { value: new Uint32Array(value), size };
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      pbf.readPackedVarint(obj.value);
    else if (tag === 2)
      obj.size = pbf.readVarint(true);
  }
};
var FieldsReader = class {
  static read(pbf, end) {
    return pbf.readFields(FieldsReader._readField, { id: 0 }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.id = pbf.readVarint();
  }
};
var NumericPropReader = class {
  static read(pbf, end) {
    return pbf.readFields(NumericPropReader._readField, { value: [] }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      readPackedTypedArray(Float64Array, pbf, obj);
  }
};
var NumericPropKeyValueReader = class {
  static read(pbf, end) {
    return pbf.readFields(NumericPropKeyValueReader._readField, { key: "", value: null }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.key = pbf.readString();
    else if (tag === 2)
      obj.value = NumericPropReader.read(pbf, pbf.readVarint() + pbf.pos);
  }
};
var PointsReader = class {
  static read(pbf, end) {
    return pbf.readFields(PointsReader._readField, {
      positions: null,
      globalFeatureIds: null,
      featureIds: null,
      properties: [],
      numericProps: {},
      fields: []
    }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 2)
      obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 3)
      obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 4)
      obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) {
      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj.numericProps[entry.key] = entry.value;
    } else if (tag === 6)
      obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
  }
};
var LinesReader = class {
  static read(pbf, end) {
    return pbf.readFields(LinesReader._readField, {
      positions: null,
      pathIndices: null,
      globalFeatureIds: null,
      featureIds: null,
      properties: [],
      numericProps: {},
      fields: []
    }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 2)
      obj.pathIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 3)
      obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 4)
      obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 5)
      obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 6) {
      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj.numericProps[entry.key] = entry.value;
    } else if (tag === 7)
      obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
  }
};
var PolygonsReader = class {
  static read(pbf, end) {
    return pbf.readFields(PolygonsReader._readField, {
      positions: null,
      polygonIndices: null,
      globalFeatureIds: null,
      featureIds: null,
      primitivePolygonIndices: null,
      triangles: null,
      properties: [],
      numericProps: {},
      fields: []
    }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 2)
      obj.polygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 3)
      obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 4)
      obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 5)
      obj.primitivePolygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 6)
      obj.triangles = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 7)
      obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 8) {
      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj.numericProps[entry.key] = entry.value;
    } else if (tag === 9)
      obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
  }
};
var TileReader2 = class {
  static read(pbf, end) {
    return pbf.readFields(TileReader2._readField, { points: null, lines: null, polygons: null }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.points = PointsReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 2)
      obj.lines = LinesReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 3)
      obj.polygons = PolygonsReader.read(pbf, pbf.readVarint() + pbf.pos);
  }
};

// dist/layers/schema/carto-spatial-tile.js
var IndicesReader = class {
  static read(pbf, end) {
    return pbf.readFields(IndicesReader._readField, { value: [] }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      readPackedTypedArray(BigUint64Array, pbf, obj);
  }
};
var CellsReader = class {
  static read(pbf, end) {
    return pbf.readFields(CellsReader._readField, { indices: null, properties: [], numericProps: {} }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.indices = IndicesReader.read(pbf, pbf.readVarint() + pbf.pos);
    else if (tag === 2)
      obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) {
      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj.numericProps[entry.key] = entry.value;
    }
  }
};
var TileReader3 = class {
  static read(pbf, end) {
    return pbf.readFields(TileReader3._readField, { scheme: 0, cells: null }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.scheme = pbf.readVarint();
    else if (tag === 2)
      obj.cells = CellsReader.read(pbf, pbf.readVarint() + pbf.pos);
  }
};

// dist/layers/schema/spatialjson-utils.js
var import_quadbin = require("quadbin");
function binaryToSpatialjson(binary) {
  const { cells, scheme } = binary;
  const count = cells.indices.value.length;
  const spatial = [];
  for (let i = 0; i < count; i++) {
    const id4 = scheme === "h3" ? (0, import_quadbin.bigIntToHex)(cells.indices.value[i]) : cells.indices.value[i];
    const properties = { ...cells.properties[i] };
    for (const key of Object.keys(cells.numericProps)) {
      properties[key] = cells.numericProps[key].value[i];
    }
    spatial.push({ id: id4, properties });
  }
  return spatial;
}

// dist/layers/schema/carto-spatial-tile-loader.js
var VERSION2 = true ? "9.0.6" : "latest";
var id2 = "cartoSpatialTile";
var DEFAULT_OPTIONS2 = {
  cartoSpatialTile: {
    scheme: "quadbin",
    workerUrl: getWorkerUrl(id2, VERSION2)
  }
};
var CartoSpatialTileLoader = {
  name: "CARTO Spatial Tile",
  version: VERSION2,
  id: id2,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-spatial-tile"],
  category: "geometry",
  parse: async (arrayBuffer, options) => parseCartoSpatialTile(arrayBuffer, options),
  parseSync: parseCartoSpatialTile,
  worker: true,
  options: DEFAULT_OPTIONS2
};
function parseCartoSpatialTile(arrayBuffer, options) {
  var _a;
  if (!arrayBuffer)
    return null;
  const tile = parsePbf(arrayBuffer, TileReader3);
  const { cells } = tile;
  const scheme = (_a = options == null ? void 0 : options.cartoSpatialTile) == null ? void 0 : _a.scheme;
  const data = { cells, scheme };
  return binaryToSpatialjson(data);
}
var carto_spatial_tile_loader_default = CartoSpatialTileLoader;

// dist/layers/spatial-index-tile-layer.js
var import_geo_layers2 = require("@deck.gl/geo-layers");

// dist/constants.js
var DEFAULT_TILE_SIZE = 512;
var DEFAULT_TILE_RESOLUTION = 0.5;
var DEFAULT_AGGREGATION_RES_LEVEL_H3 = 4;
var DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN = 6;

// dist/layers/spatial-index-tile-layer.js
(0, import_core2.registerLoaders)([carto_raster_tile_loader_default, carto_spatial_tile_loader_default]);
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
var defaultProps = {
  tileSize: DEFAULT_TILE_SIZE
};
var _SpatialIndexTileLayer = class extends import_geo_layers2.TileLayer {
  _updateAutoHighlight(info) {
    const { hoveredFeatureId } = this.state;
    const hoveredFeature = info.object;
    let newHoveredFeatureId = null;
    if (hoveredFeature) {
      newHoveredFeatureId = hoveredFeature.id;
    }
    if (hoveredFeatureId !== newHoveredFeatureId) {
      let { highlightColor } = this.props;
      if (typeof highlightColor === "function") {
        highlightColor = highlightColor(info);
      }
      this.setState({
        highlightColor,
        hoveredFeatureId: newHoveredFeatureId
      });
    }
  }
  getSubLayerPropsByTile(tile) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(tile) {
    const { hoveredFeatureId } = this.state;
    const data = tile.content;
    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId);
    if (!isFeatureIdPresent || !Array.isArray(data) || !this._featureInTile(tile, hoveredFeatureId)) {
      return -1;
    }
    return data.findIndex((feature) => feature.id === hoveredFeatureId);
  }
  _featureInTile(tile, featureId) {
    const tileset = this.state.tileset;
    const tileZoom = tileset.getTileZoom(tile.index);
    const KEY = tile.index.q ? "q" : "i";
    let featureIndex = { [KEY]: featureId };
    let featureZoom = tileset.getTileZoom(featureIndex);
    while (!(featureZoom <= tileZoom)) {
      featureIndex = tileset.getParentIndex(featureIndex);
      featureZoom = tileset.getTileZoom(featureIndex);
    }
    return featureIndex[KEY] === tile.index[KEY];
  }
};
var SpatialIndexTileLayer = _SpatialIndexTileLayer;
(() => {
  _SpatialIndexTileLayer.layerName = "SpatialIndexTileLayer";
})();
(() => {
  _SpatialIndexTileLayer.defaultProps = defaultProps;
})();

// dist/layers/utils.js
var import_core3 = require("@deck.gl/core");
var import_core4 = require("@deck.gl/core");
function injectAccessToken(loadOptions, accessToken) {
  var _a, _b, _c;
  if (!((_b = (_a = loadOptions == null ? void 0 : loadOptions.fetch) == null ? void 0 : _a.headers) == null ? void 0 : _b.Authorization)) {
    loadOptions.fetch = {
      ...loadOptions.fetch,
      headers: { ...(_c = loadOptions.fetch) == null ? void 0 : _c.headers, Authorization: `Bearer ${accessToken}` }
    };
  }
}
function mergeBoundaryData(geometry, properties) {
  const mapping = {};
  for (const { geoid, ...rest } of properties.properties) {
    if (geoid in mapping) {
      import_core3.log.warn("Duplicate geoid key in boundary mapping, using first occurance")();
    } else {
      mapping[geoid] = rest;
    }
  }
  for (const type of ["points", "lines", "polygons"]) {
    const geom = geometry[type];
    if (geom.positions.value.length === 0) {
      continue;
    }
    geom.properties = geom.properties.map(({ geoid }) => mapping[geoid]);
    const { positions, globalFeatureIds } = geom;
    let indices = null;
    if (type === "lines")
      indices = geom.pathIndices.value;
    if (type === "polygons")
      indices = geom.polygonIndices.value;
    const length = positions.value.length / positions.size;
    for (const key in properties.numericProps) {
      const sourceProp = properties.numericProps[key].value;
      const TypedArray = sourceProp.constructor;
      const destProp = new TypedArray(length);
      geom.numericProps[key] = { value: destProp, size: 1 };
      if (!indices) {
        for (let i = 0; i < length; i++) {
          const featureId = globalFeatureIds.value[i];
          destProp[i] = sourceProp[featureId];
        }
      } else {
        for (let i = 0; i < indices.length - 1; i++) {
          const startIndex = indices[i];
          const endIndex = indices[i + 1];
          const featureId = globalFeatureIds.value[startIndex];
          destProp.fill(sourceProp[featureId], startIndex, endIndex);
        }
      }
    }
  }
  return geometry;
}
var TilejsonPropType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "object" && Array.isArray(value.tiles) && value.tiles.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    return (0, import_core4._deepEqual)(value1, value2, 2);
  },
  async: true
};

// dist/layers/h3-tile-layer.js
var renderSubLayers = (props) => {
  const { data } = props;
  const { index } = props.tile;
  if (!data || !data.length)
    return null;
  return new import_geo_layers3.H3HexagonLayer(props, {
    getHexagon: (d) => d.id,
    centerHexagon: index,
    highPrecision: true
  });
};
var defaultProps2 = {
  data: TilejsonPropType,
  tileSize: DEFAULT_TILE_SIZE
};
var _H3TileLayer = class extends import_core5.CompositeLayer {
  initializeState() {
    import_geo_layers3.H3HexagonLayer._checkH3Lib();
  }
  getLoadOptions() {
    const loadOptions = super.getLoadOptions() || {};
    const tileJSON = this.props.data;
    injectAccessToken(loadOptions, tileJSON.accessToken);
    loadOptions.cartoSpatialTile = { ...loadOptions.cartoSpatialTile, scheme: "h3" };
    return loadOptions;
  }
  renderLayers() {
    const tileJSON = this.props.data;
    if (!tileJSON)
      return null;
    const { tiles: data } = tileJSON;
    let { minresolution, maxresolution } = tileJSON;
    if (this.props.minZoom) {
      minresolution = Math.max(minresolution, getHexagonResolution({ zoom: this.props.minZoom, latitude: 0 }, this.props.tileSize));
    }
    if (this.props.maxZoom) {
      maxresolution = Math.min(maxresolution, getHexagonResolution({ zoom: this.props.maxZoom, latitude: 0 }, this.props.tileSize));
    }
    return [
      new SpatialIndexTileLayer(this.props, {
        id: `h3-tile-layer-${this.props.id}`,
        data,
        TilesetClass: H3Tileset2D,
        renderSubLayers,
        minZoom: minresolution,
        maxZoom: maxresolution,
        loadOptions: this.getLoadOptions()
      })
    ];
  }
};
var H3TileLayer = _H3TileLayer;
(() => {
  _H3TileLayer.layerName = "H3TileLayer";
})();
(() => {
  _H3TileLayer.defaultProps = defaultProps2;
})();

// dist/layers/point-label-layer.js
var import_core6 = require("@deck.gl/core");
var import_layers = require("@deck.gl/layers");
var [LEFT, TOP, RIGHT, BOTTOM] = [0, 1, 2, 3];
var _EnhancedTextBackgroundLayer = class extends import_layers._TextBackgroundLayer {
  getShaders() {
    const shaders = super.getShaders();
    let vs = shaders.vs;
    vs = vs.replaceAll("padding.", "_padding.");
    vs = vs.replace("void main(void) {", "void main(void) {\n  vec4 _padding = padding + instancePixelOffsets.xyxy * vec4(1.0, 1.0, -1.0, -1.0);");
    return { ...shaders, vs };
  }
};
var EnhancedTextBackgroundLayer = _EnhancedTextBackgroundLayer;
(() => {
  _EnhancedTextBackgroundLayer.layerName = "EnhancedTextBackgroundLayer";
})();
var _EnhancedTextLayer = class extends import_layers.TextLayer {
  filterSubLayer({ layer, renderPass }) {
    const background = layer.id.includes("primary-background");
    if (renderPass === "collision") {
      return background;
    }
    return !background;
  }
};
var EnhancedTextLayer = _EnhancedTextLayer;
(() => {
  _EnhancedTextLayer.layerName = "EnhancedTextLayer";
})();
var defaultProps3 = {
  ...import_layers.TextLayer.defaultProps,
  getRadius: { type: "accessor", value: 1 },
  radiusScale: { type: "number", min: 0, value: 1 }
};
var _PointLabelLayer = class extends import_core6.CompositeLayer {
  calculatePixelOffset(secondary) {
    const { getTextAnchor: anchor, getAlignmentBaseline: alignment, getRadius, getSecondaryText, radiusScale, secondarySizeScale, sizeScale } = this.props;
    const xMult = anchor === "middle" ? 0 : anchor === "start" ? 1 : -1;
    const yMult = alignment === "center" ? 0 : alignment === "bottom" ? 1 : -1;
    const xPadding = sizeScale / 4;
    const yPadding = sizeScale * (1 + 1 / 4);
    const secondaryOffset = 0.6 * (1 - yMult) * sizeScale;
    let yOffset = secondary ? secondaryOffset : 0;
    if (anchor === "middle" && alignment === "top" && getSecondaryText) {
      yOffset -= secondaryOffset;
      yOffset -= secondarySizeScale;
      yOffset += sizeScale;
    }
    const radiusPadding = 1 + 1 / 4;
    return typeof getRadius === "function" ? (d, info) => {
      const r = (info ? getRadius(d, info) : 1) * radiusScale * radiusPadding;
      return [xMult * (r + xPadding), yMult * (r + yPadding) + yOffset];
    } : [
      xMult * (getRadius * radiusScale * radiusPadding + xPadding),
      yMult * (getRadius * radiusScale * radiusPadding + yPadding) + yOffset
    ];
  }
  calculateBackgroundPadding() {
    const { getTextAnchor: anchor, getAlignmentBaseline: alignment, sizeScale } = this.props;
    const paddingX = 12 * sizeScale;
    const paddingY = 3 * sizeScale;
    const backgroundPadding = [0, 0, 0, 0];
    if (alignment === "top") {
      backgroundPadding[TOP] = paddingY;
    } else if (alignment === "bottom") {
      backgroundPadding[BOTTOM] = paddingY;
    } else {
      backgroundPadding[TOP] = 0.5 * paddingY;
      backgroundPadding[BOTTOM] = 0.5 * paddingY;
    }
    if (anchor === "start") {
      backgroundPadding[LEFT] = paddingX;
    } else if (anchor === "end") {
      backgroundPadding[RIGHT] = paddingX;
    } else {
      backgroundPadding[LEFT] = 0.5 * paddingX;
      backgroundPadding[RIGHT] = 0.5 * paddingX;
    }
    return backgroundPadding;
  }
  renderTextLayer(id4, { updateTriggers: updateTriggersOverride = {}, ...props }) {
    const { data, characterSet, fontFamily, fontSettings, fontWeight, outlineColor, outlineWidth, sizeScale, radiusScale, getAlignmentBaseline, getColor, getPosition, getTextAnchor, updateTriggers } = this.props;
    return new EnhancedTextLayer(this.getSubLayerProps({
      id: id4,
      data,
      characterSet,
      fontFamily,
      fontSettings,
      fontWeight,
      outlineColor,
      outlineWidth,
      sizeScale,
      getAlignmentBaseline,
      getColor,
      getPosition,
      getTextAnchor,
      updateTriggers: {
        ...updateTriggers,
        ...updateTriggersOverride,
        getPixelOffset: [
          updateTriggers.getRadius,
          updateTriggers.getTextAnchor,
          updateTriggers.getAlignmentBaseline,
          radiusScale,
          sizeScale
        ]
      }
    }), {
      getSize: 1,
      _subLayerProps: { background: { type: EnhancedTextBackgroundLayer } }
    }, props);
  }
  renderLayers() {
    const { getText, getSecondaryColor, getSecondaryText, secondaryOutlineColor, secondarySizeScale, updateTriggers } = this.props;
    const getPixelOffset = this.calculatePixelOffset(false);
    const backgroundPadding = this.calculateBackgroundPadding();
    const out = [
      this.renderTextLayer(`${updateTriggers.getText}-primary`, {
        backgroundPadding,
        getText,
        getPixelOffset,
        background: true
      }),
      Boolean(getSecondaryText) && this.renderTextLayer(`${updateTriggers.getSecondaryText}-secondary`, {
        getText: getSecondaryText,
        getPixelOffset: this.calculatePixelOffset(true),
        getAlignmentBaseline: "top",
        ...getSecondaryColor && { getColor: getSecondaryColor },
        ...secondarySizeScale && { sizeScale: secondarySizeScale },
        ...secondaryOutlineColor && { outlineColor: secondaryOutlineColor }
      })
    ];
    return out;
  }
};
var PointLabelLayer = _PointLabelLayer;
(() => {
  _PointLabelLayer.layerName = "PointLabelLayer";
})();
(() => {
  _PointLabelLayer.defaultProps = defaultProps3;
})();

// dist/layers/quadbin-tile-layer.js
var import_core7 = require("@deck.gl/core");

// dist/layers/quadbin-layer.js
var import_geo_layers4 = require("@deck.gl/geo-layers");

// dist/layers/quadbin-utils.js
var import_web_mercator = require("@math.gl/web-mercator");
var import_quadbin2 = require("quadbin");
var TILE_SIZE = 512;
function quadbinToOffset(quadbin) {
  const { x, y, z } = (0, import_quadbin2.cellToTile)(quadbin);
  const scale = TILE_SIZE / (1 << z);
  return [x * scale, TILE_SIZE - y * scale, scale];
}
function quadbinToWorldBounds(quadbin, coverage) {
  const [xOffset, yOffset, scale] = quadbinToOffset(quadbin);
  return [
    [xOffset, yOffset],
    [xOffset + coverage * scale, yOffset - coverage * scale]
  ];
}
function getQuadbinPolygon(quadbin, coverage = 1) {
  const [topLeft, bottomRight] = quadbinToWorldBounds(quadbin, coverage);
  const [w, n] = (0, import_web_mercator.worldToLngLat)(topLeft);
  const [e, s] = (0, import_web_mercator.worldToLngLat)(bottomRight);
  return [e, n, e, s, w, s, w, n, e, n];
}

// dist/layers/quadbin-layer.js
var defaultProps4 = {
  getQuadbin: { type: "accessor", value: (d) => d.quadbin }
};
var _QuadbinLayer = class extends import_geo_layers4._GeoCellLayer {
  indexToBounds() {
    const { data, extruded, getQuadbin } = this.props;
    const coverage = extruded ? 0.99 : 1;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getQuadbinPolygon(getQuadbin(x, objectInfo), coverage),
      updateTriggers: { getPolygon: coverage }
    };
  }
};
var QuadbinLayer = _QuadbinLayer;
(() => {
  _QuadbinLayer.layerName = "QuadbinLayer";
})();
(() => {
  _QuadbinLayer.defaultProps = defaultProps4;
})();

// dist/layers/quadbin-tileset-2d.js
var import_geo_layers5 = require("@deck.gl/geo-layers");
var import_quadbin3 = require("quadbin");
var QuadbinTileset2D = class extends import_geo_layers5._Tileset2D {
  getTileIndices(opts) {
    return super.getTileIndices(opts).map(import_quadbin3.tileToCell).map((q) => ({ q, i: (0, import_quadbin3.bigIntToHex)(q) }));
  }
  getTileId({ q, i }) {
    return i || (0, import_quadbin3.bigIntToHex)(q);
  }
  getTileMetadata({ q }) {
    return super.getTileMetadata((0, import_quadbin3.cellToTile)(q));
  }
  getTileZoom({ q }) {
    return Number((0, import_quadbin3.getResolution)(q));
  }
  getParentIndex({ q }) {
    return { q: (0, import_quadbin3.cellToParent)(q) };
  }
};

// dist/layers/quadbin-tile-layer.js
var import_quadbin4 = require("quadbin");
var renderSubLayers2 = (props) => {
  const { data } = props;
  if (!data || !data.length)
    return null;
  const isBigInt = typeof data[0].id === "bigint";
  return new QuadbinLayer(props, {
    getQuadbin: isBigInt ? (d) => d.id : (d) => (0, import_quadbin4.hexToBigInt)(d.id)
  });
};
var defaultProps5 = {
  data: TilejsonPropType,
  tileSize: DEFAULT_TILE_SIZE
};
var _QuadbinTileLayer = class extends import_core7.CompositeLayer {
  getLoadOptions() {
    const loadOptions = super.getLoadOptions() || {};
    const tileJSON = this.props.data;
    injectAccessToken(loadOptions, tileJSON.accessToken);
    loadOptions.cartoSpatialTile = { ...loadOptions.cartoSpatialTile, scheme: "quadbin" };
    return loadOptions;
  }
  renderLayers() {
    const tileJSON = this.props.data;
    if (!tileJSON)
      return null;
    const { tiles: data, maxresolution: maxZoom } = tileJSON;
    return [
      new SpatialIndexTileLayer(this.props, {
        id: `quadbin-tile-layer-${this.props.id}`,
        data,
        TilesetClass: QuadbinTileset2D,
        renderSubLayers: renderSubLayers2,
        maxZoom,
        loadOptions: this.getLoadOptions()
      })
    ];
  }
};
var QuadbinTileLayer = _QuadbinTileLayer;
(() => {
  _QuadbinTileLayer.layerName = "QuadbinTileLayer";
})();
(() => {
  _QuadbinTileLayer.defaultProps = defaultProps5;
})();

// dist/layers/raster-tile-layer.js
var import_core9 = require("@deck.gl/core");

// dist/layers/raster-layer.js
var import_core8 = require("@deck.gl/core");
var import_layers2 = require("@deck.gl/layers");

// dist/layers/raster-layer-vertex.glsl.js
var raster_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME raster-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float widthScale;
uniform vec3 offset;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
vec2 common_position = offset.xy;
float scale = offset.z;
int yIndex = - (gl_InstanceID / BLOCK_WIDTH);
int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);
common_position += scale * vec2(float(xIndex), float(yIndex));
vec4 color = isStroke ? instanceLineColors : instanceFillColors;
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float cellWidth = coverage * scale;
geometry.position = vec4(common_position, 0.0, 1.0);
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
geometry.position.xyz -= project_uCommonOrigin;
}
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
} else if (stroked) {
float halfOffset = project_pixel_size(widthScale) / cellWidth;
if (isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
geometry.pickingColor = instancePickingColors;
vec2 offset = (vec2(0.5) + positions.xy * strokeOffsetRatio) * cellWidth * shouldRender;
vec3 pos = vec3(offset, project_size(elevation));
DECKGL_FILTER_SIZE(pos, geometry);
geometry.position.xyz += pos;
gl_Position = project_common_position_to_clipspace(geometry.position);
geometry.normal = project_normal(normals);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded && !isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// dist/layers/raster-layer.js
var defaultProps6 = {
  ...import_layers2.ColumnLayer.defaultProps,
  extruded: false,
  diskResolution: 4,
  vertices: [
    [-0.5, -0.5],
    [0.5, -0.5],
    [0.5, 0.5],
    [-0.5, 0.5]
  ]
};
var _RasterColumnLayer = class extends import_layers2.ColumnLayer {
  getShaders() {
    const shaders = super.getShaders();
    const data = this.props.data;
    const BLOCK_WIDTH = data.data.blockSize ?? Math.sqrt(data.length);
    return { ...shaders, defines: { ...shaders.defines, BLOCK_WIDTH }, vs: raster_layer_vertex_glsl_default };
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: "getElevation"
      },
      instanceFillColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getFillColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: true,
        accessor: "getLineColor",
        defaultValue: [255, 255, 255, 255]
      }
    });
  }
};
var RasterColumnLayer = _RasterColumnLayer;
(() => {
  _RasterColumnLayer.layerName = "RasterColumnLayer";
})();
var _RasterLayer = class extends import_core8.CompositeLayer {
  renderLayers() {
    const { data, getElevation, getFillColor, getLineColor, getLineWidth, tileIndex, updateTriggers } = this.props;
    if (!data || !tileIndex)
      return null;
    const blockSize = data.blockSize ?? 0;
    const [xOffset, yOffset, scale] = quadbinToOffset(tileIndex);
    const offset = [xOffset, yOffset, scale / blockSize];
    const CellLayer = this.getSubLayerClass("column", RasterColumnLayer);
    return new CellLayer(this.props, this.getSubLayerProps({
      id: "cell",
      updateTriggers,
      getElevation: this.getSubLayerAccessor(getElevation),
      getFillColor: this.getSubLayerAccessor(getFillColor),
      getLineColor: this.getSubLayerAccessor(getLineColor),
      getLineWidth: this.getSubLayerAccessor(getLineWidth)
    }), {
      data: {
        data,
        length: blockSize * blockSize
      },
      offset
    });
  }
  getSubLayerAccessor(accessor) {
    if (typeof accessor !== "function") {
      return super.getSubLayerAccessor(accessor);
    }
    return (object, info) => {
      const { data, index } = info;
      const binaryData = data.data;
      const proxy = createBinaryProxy(binaryData.cells, index);
      return accessor({ properties: proxy }, info);
    };
  }
};
var RasterLayer = _RasterLayer;
(() => {
  _RasterLayer.layerName = "RasterLayer";
})();
(() => {
  _RasterLayer.defaultProps = defaultProps6;
})();

// dist/layers/raster-tile-layer.js
var renderSubLayers3 = (props) => {
  var _a, _b;
  const tileIndex = (_b = (_a = props.tile) == null ? void 0 : _a.index) == null ? void 0 : _b.q;
  if (!tileIndex)
    return null;
  return new RasterLayer(props, { tileIndex });
};
var defaultProps7 = {
  data: TilejsonPropType,
  tileSize: DEFAULT_TILE_SIZE
};
var _RasterTileLayer = class extends import_core9.CompositeLayer {
  getLoadOptions() {
    const loadOptions = super.getLoadOptions() || {};
    const tileJSON = this.props.data;
    injectAccessToken(loadOptions, tileJSON.accessToken);
    return loadOptions;
  }
  renderLayers() {
    const tileJSON = this.props.data;
    if (!tileJSON)
      return null;
    const { tiles: data, minzoom: minZoom, maxzoom: maxZoom } = tileJSON;
    return [
      new SpatialIndexTileLayer(this.props, {
        id: `raster-tile-layer-${this.props.id}`,
        data,
        TilesetClass: QuadbinTileset2D,
        renderSubLayers: renderSubLayers3,
        minZoom,
        maxZoom,
        loadOptions: this.getLoadOptions()
      })
    ];
  }
};
var RasterTileLayer = _RasterTileLayer;
(() => {
  _RasterTileLayer.layerName = "RasterTileLayer";
})();
(() => {
  _RasterTileLayer.defaultProps = defaultProps7;
})();

// dist/layers/vector-tile-layer.js
var import_core10 = require("@loaders.gl/core");

// dist/layers/schema/carto-properties-tile.js
var TileReader4 = class {
  static read(pbf, end) {
    return pbf.readFields(TileReader4._readField, { properties: [], numericProps: {} }, end);
  }
  static _readField(tag, obj, pbf) {
    if (tag === 1)
      obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 2) {
      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
      obj.numericProps[entry.key] = entry.value;
    }
  }
};

// dist/layers/schema/carto-properties-tile-loader.js
var CartoPropertiesTileLoader = {
  name: "CARTO Properties Tile",
  version: "1",
  id: "cartoPropertiesTile",
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-properties-tile"],
  category: "geometry",
  worker: false,
  parse: async (arrayBuffer, options) => parseCartoPropertiesTile(arrayBuffer, options),
  parseSync: parseCartoPropertiesTile,
  options: {}
};
function parseCartoPropertiesTile(arrayBuffer, options) {
  if (!arrayBuffer)
    return null;
  return parsePbf(arrayBuffer, TileReader4);
}
var carto_properties_tile_loader_default = CartoPropertiesTileLoader;

// dist/layers/schema/carto-vector-tile-loader.js
var import_earcut = __toESM(require("earcut"), 1);
var VERSION3 = true ? "9.0.6" : "latest";
var id3 = "cartoVectorTile";
var DEFAULT_OPTIONS3 = {
  cartoVectorTile: {
    workerUrl: getWorkerUrl(id3, VERSION3)
  }
};
var CartoVectorTileLoader = {
  name: "CARTO Vector Tile",
  version: VERSION3,
  id: id3,
  module: "carto",
  extensions: ["pbf"],
  mimeTypes: ["application/vnd.carto-vector-tile"],
  category: "geometry",
  parse: async (arrayBuffer, options) => parseCartoVectorTile(arrayBuffer, options),
  parseSync: parseCartoVectorTile,
  worker: true,
  options: DEFAULT_OPTIONS3
};
function triangulatePolygon(polygons, target, { startPosition, endPosition, indices }) {
  const coordLength = polygons.positions.size;
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.value.subarray(start, end);
  const holes = indices.slice(1).map((n) => n - startPosition);
  const triangles = (0, import_earcut.default)(polygonPositions, holes, coordLength);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    target.push(startPosition + triangles[t]);
  }
}
function triangulate(polygons) {
  const { polygonIndices, primitivePolygonIndices } = polygons;
  const triangles = [];
  let rangeStart = 0;
  for (let i = 0; i < polygonIndices.value.length - 1; i++) {
    const startPosition = polygonIndices.value[i];
    const endPosition = polygonIndices.value[i + 1];
    const rangeEnd = primitivePolygonIndices.value.indexOf(endPosition);
    const indices = primitivePolygonIndices.value.subarray(rangeStart, rangeEnd);
    rangeStart = rangeEnd;
    triangulatePolygon(polygons, triangles, { startPosition, endPosition, indices });
  }
  polygons.triangles = { value: new Uint32Array(triangles), size: 1 };
}
function parseCartoVectorTile(arrayBuffer, options) {
  if (!arrayBuffer)
    return null;
  const tile = parsePbf(arrayBuffer, TileReader2);
  if (tile.polygons && !tile.polygons.triangles) {
    triangulate(tile.polygons);
  }
  return tile;
}
var carto_vector_tile_loader_default = CartoVectorTileLoader;

// dist/layers/vector-tile-layer.js
var import_extensions = require("@deck.gl/extensions");
var import_geo_layers6 = require("@deck.gl/geo-layers");
var import_layers3 = require("@deck.gl/layers");
var import_gis = require("@loaders.gl/gis");
(0, import_core10.registerLoaders)([carto_properties_tile_loader_default, carto_vector_tile_loader_default]);
var defaultProps8 = {
  ...import_geo_layers6.MVTLayer.defaultProps,
  data: TilejsonPropType,
  dataComparator: TilejsonPropType.equal,
  tileSize: DEFAULT_TILE_SIZE
};
var _VectorTileLayer = class extends import_geo_layers6.MVTLayer {
  constructor(...propObjects) {
    super(...propObjects);
  }
  initializeState() {
    super.initializeState();
    this.setState({ binary: true });
  }
  updateState(parameters) {
    const { props } = parameters;
    if (props.data) {
      super.updateState(parameters);
      const formatTiles = new URL(props.data.tiles[0]).searchParams.get("formatTiles");
      const mvt = formatTiles === "mvt";
      this.setState({ mvt });
    }
  }
  getLoadOptions() {
    const loadOptions = super.getLoadOptions() || {};
    const tileJSON = this.props.data;
    injectAccessToken(loadOptions, tileJSON.accessToken);
    loadOptions.gis = { format: "binary" };
    return loadOptions;
  }
  async getTileData(tile) {
    const tileJSON = this.props.data;
    const { tiles, properties_tiles } = tileJSON;
    const url = (0, import_geo_layers6._getURLFromTemplate)(tiles, tile);
    if (!url) {
      return Promise.reject("Invalid URL");
    }
    const loadOptions = this.getLoadOptions();
    const { fetch: fetch2 } = this.props;
    const { signal } = tile;
    const geometryFetch = fetch2(url, { propName: "data", layer: this, loadOptions, signal });
    if (!properties_tiles) {
      return await geometryFetch;
    }
    const propertiesUrl = (0, import_geo_layers6._getURLFromTemplate)(properties_tiles, tile);
    if (!propertiesUrl) {
      return Promise.reject("Invalid properties URL");
    }
    const attributesFetch = fetch2(propertiesUrl, {
      propName: "data",
      layer: this,
      loadOptions,
      signal
    });
    const [geometry, attributes] = await Promise.all([geometryFetch, attributesFetch]);
    if (!geometry)
      return null;
    return attributes ? mergeBoundaryData(geometry, attributes) : geometry;
  }
  renderSubLayers(props) {
    if (props.data === null) {
      return null;
    }
    if (this.state.mvt) {
      return super.renderSubLayers(props);
    }
    const tileBbox = props.tile.bbox;
    const { west, south, east, north } = tileBbox;
    const subLayerProps = {
      ...props,
      autoHighlight: false,
      extensions: [new import_extensions.ClipExtension(), ...props.extensions || []],
      clipBounds: [west, south, east, north]
    };
    const subLayer = new import_layers3.GeoJsonLayer(subLayerProps);
    return subLayer;
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    if (this.state.binary && info.index !== -1) {
      const { data } = params.sourceLayer.props;
      info.object = (0, import_gis.binaryToGeojson)(data, {
        globalFeatureId: info.index
      });
    }
    return info;
  }
};
var VectorTileLayer = _VectorTileLayer;
(() => {
  _VectorTileLayer.layerName = "VectorTileLayer";
})();
(() => {
  _VectorTileLayer.defaultProps = defaultProps8;
})();

// dist/basemap.js
var baseUrl = "https://basemaps.cartocdn.com/gl/{basemap}-gl-style/style.json";
var basemap_default = {
  VOYAGER: baseUrl.replace("{basemap}", "voyager"),
  POSITRON: baseUrl.replace("{basemap}", "positron"),
  DARK_MATTER: baseUrl.replace("{basemap}", "dark-matter"),
  VOYAGER_NOLABELS: baseUrl.replace("{basemap}", "voyager-nolabels"),
  POSITRON_NOLABELS: baseUrl.replace("{basemap}", "positron-nolabels"),
  DARK_MATTER_NOLABELS: baseUrl.replace("{basemap}", "dark-matter-nolabels")
};

// dist/style/color-bins-style.js
var import_d3_scale = require("d3-scale");

// dist/style/palette.js
var cartoColors = __toESM(require("cartocolor"), 1);
var DEFAULT_PALETTE = "PurpOr";
var NULL_COLOR = [204, 204, 204];
var OTHERS_COLOR = [119, 119, 119];
function getPalette(name, numCategories) {
  const palette = cartoColors[name];
  let paletteIndex = numCategories;
  assert(palette, `Palette "${name}" not found. Expected a CARTOColors string`);
  const palettesColorVariants = Object.keys(palette).filter((p) => p !== "tags").map(Number);
  const longestPaletteIndex = Math.max(...palettesColorVariants);
  const smallestPaletteIndex = Math.min(...palettesColorVariants);
  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {
    paletteIndex = longestPaletteIndex;
  } else if (numCategories < smallestPaletteIndex) {
    paletteIndex = smallestPaletteIndex;
  }
  let colors = palette[paletteIndex];
  if (palette.tags && palette.tags.includes("qualitative")) {
    colors = colors.slice(0, -1);
  }
  return colors.map((c) => hexToRgb(c));
}
function hexToRgb(hex) {
  let result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
  if (result) {
    return [
      parseInt(result[1] + result[1], 16),
      parseInt(result[2] + result[2], 16),
      parseInt(result[3] + result[3], 16),
      255
    ];
  }
  result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
  if (result) {
    return [
      parseInt(result[1] + result[1], 16),
      parseInt(result[2] + result[2], 16),
      parseInt(result[3] + result[3], 16),
      parseInt(result[4] + result[4], 16)
    ];
  }
  result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (result) {
    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];
  }
  result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  assert(result, `Hexadecimal color "${hex}" was not parsed correctly`);
  return [
    parseInt(result[1], 16),
    parseInt(result[2], 16),
    parseInt(result[3], 16),
    parseInt(result[4], 16)
  ];
}

// dist/style/utils.js
var ALLOWED_ATTR_TYPES = Object.freeze(["function", "string"]);
function getAttrValue(attr, d) {
  var _a;
  assert(typeof d === "object", 'Expected "data" to be an object');
  assert(ALLOWED_ATTR_TYPES.includes(typeof attr), 'Expected "attr" to be a function or string');
  if (typeof attr === "function") {
    return attr(d);
  }
  return (_a = d == null ? void 0 : d.properties) == null ? void 0 : _a[attr];
}

// dist/style/color-bins-style.js
function colorBins({ attr, domain, colors = DEFAULT_PALETTE, nullColor = NULL_COLOR }) {
  assert(Array.isArray(domain), 'Expected "domain" to be an array of numbers');
  const palette = typeof colors === "string" ? getPalette(colors, domain.length + 1) : colors;
  const color = (0, import_d3_scale.scaleThreshold)().domain(domain).range(palette);
  return (d) => {
    const value = getAttrValue(attr, d);
    return typeof value === "number" && Number.isFinite(value) ? color(value) : nullColor;
  };
}

// dist/style/color-categories-style.js
function colorCategories({ attr, domain, colors = DEFAULT_PALETTE, nullColor = NULL_COLOR, othersColor = OTHERS_COLOR }) {
  assert(Array.isArray(domain), 'Expected "domain" to be an array of numbers or strings');
  const colorsByCategory = {};
  const palette = typeof colors === "string" ? getPalette(colors, domain.length) : colors;
  for (const [i, c] of domain.entries()) {
    colorsByCategory[c] = palette[i];
  }
  return (d) => {
    const value = getAttrValue(attr, d);
    return typeof value === "number" && Number.isFinite(value) || typeof value === "string" ? colorsByCategory[value] || othersColor : nullColor;
  };
}

// dist/style/color-continuous-style.js
var import_d3_scale2 = require("d3-scale");
function colorContinuous({ attr, domain, colors = DEFAULT_PALETTE, nullColor = NULL_COLOR }) {
  assert(Array.isArray(domain), 'Expected "domain" to be an array of numbers');
  const palette = typeof colors === "string" ? getPalette(colors, domain.length) : colors;
  const color = (0, import_d3_scale2.scaleLinear)().domain(domain).range(palette);
  return (d) => {
    const value = getAttrValue(attr, d);
    return typeof value === "number" && Number.isFinite(value) ? color(value) : nullColor;
  };
}

// dist/api/carto-api-error.js
var CartoAPIError = class extends Error {
  constructor(error, errorContext, response) {
    let responseString = "Failed to connect";
    if (response) {
      responseString = "Server returned: ";
      if (response.status === 400) {
        responseString += "Bad request";
      } else if (response.status === 401 || response.status === 403) {
        responseString += "Unauthorized access";
      } else if (response.status === 404) {
        responseString += "Not found";
      } else {
        responseString += "Error";
      }
      responseString += ` (${response.status}):`;
    }
    responseString += ` ${error.message || error}`;
    let message = `${errorContext.requestType} API request failed`;
    message += `
${responseString}`;
    for (const key of Object.keys(errorContext)) {
      if (key === "requestType")
        continue;
      message += `
${formatErrorKey(key)}: ${errorContext[key]}`;
    }
    message += "\n";
    super(message);
    this.name = "CartoAPIError";
    this.response = response;
    this.error = error;
    this.errorContext = errorContext;
  }
};
function formatErrorKey(key) {
  return key.replace(/([A-Z])/g, " $1").replace(/^./, (s) => s.toUpperCase());
}

// dist/api/common.js
var DEFAULT_API_BASE_URL = "https://gcp-us-east1.api.carto.com";
var DEFAULT_CLIENT = "deck-gl-carto";
var V3_MINOR_VERSION = "3.4";
var MAX_GET_LENGTH = 8192;
var DEFAULT_PARAMETERS = {
  v: V3_MINOR_VERSION
};
var DEFAULT_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};

// dist/api/endpoints.js
function joinPath(...args) {
  return args.map((part) => part.endsWith("/") ? part.slice(0, -1) : part).join("/");
}
function buildV3Path(apiBaseUrl, version, endpoint, ...rest) {
  return joinPath(apiBaseUrl, version, endpoint, ...rest);
}
function buildPublicMapUrl({ apiBaseUrl, cartoMapId }) {
  return buildV3Path(apiBaseUrl, "v3", "maps", "public", cartoMapId);
}
function buildStatsUrl({ attribute, apiBaseUrl, connectionName, source, type }) {
  if (type === "query") {
    return buildV3Path(apiBaseUrl, "v3", "stats", connectionName, attribute);
  }
  return buildV3Path(apiBaseUrl, "v3", "stats", connectionName, source, attribute);
}
function buildSourceUrl({ apiBaseUrl, connectionName, endpoint }) {
  return buildV3Path(apiBaseUrl, "v3", "maps", connectionName, endpoint);
}
function buildQueryUrl({ apiBaseUrl, connectionName }) {
  return buildV3Path(apiBaseUrl, "v3", "sql", connectionName, "query");
}

// dist/api/request-with-parameters.js
function encodeParameter(name, value) {
  return `${name}=${encodeURIComponent(value)}`;
}
var REQUEST_CACHE = /* @__PURE__ */ new Map();
async function requestWithParameters({ baseUrl: baseUrl2, parameters, headers: customHeaders, errorContext }) {
  const key = createCacheKey(baseUrl2, parameters || {}, customHeaders || {});
  if (REQUEST_CACHE.has(key)) {
    return REQUEST_CACHE.get(key);
  }
  const url = parameters ? createURLWithParameters(baseUrl2, parameters) : baseUrl2;
  const headers = { ...DEFAULT_HEADERS, ...customHeaders };
  const fetchPromise = url.length > MAX_GET_LENGTH ? fetch(baseUrl2, { method: "POST", body: JSON.stringify(parameters), headers }) : fetch(url, { headers });
  let response;
  const jsonPromise = fetchPromise.then((_response) => {
    response = _response;
    return response.json();
  }).then((json) => {
    if (!response || !response.ok) {
      throw new Error(json.error);
    }
    return json;
  }).catch((error) => {
    REQUEST_CACHE.delete(key);
    throw new CartoAPIError(error, errorContext, response);
  });
  REQUEST_CACHE.set(key, jsonPromise);
  return jsonPromise;
}
function createCacheKey(baseUrl2, parameters, headers) {
  const parameterEntries = Object.entries(parameters).sort(([a], [b]) => a > b ? 1 : -1);
  const headerEntries = Object.entries(headers).sort(([a], [b]) => a > b ? 1 : -1);
  return JSON.stringify({ baseUrl: baseUrl2, parameters: parameterEntries, headers: headerEntries });
}
function createURLWithParameters(baseUrl2, parameters) {
  const encodedParameters = Object.entries({ ...DEFAULT_PARAMETERS, ...parameters }).map(([key, value]) => {
    return encodeParameter(key, value);
  });
  return `${baseUrl2}?${encodedParameters.join("&")}`;
}

// dist/sources/base-source.js
var SOURCE_DEFAULTS = {
  apiBaseUrl: DEFAULT_API_BASE_URL,
  clientId: DEFAULT_CLIENT,
  format: "tilejson",
  headers: {}
};
async function baseSource(endpoint, options, urlParameters) {
  const { accessToken, connectionName, cache, ...optionalOptions } = options;
  const mergedOptions = { ...SOURCE_DEFAULTS, accessToken, connectionName, endpoint };
  for (const key in optionalOptions) {
    if (optionalOptions[key]) {
      mergedOptions[key] = optionalOptions[key];
    }
  }
  const baseUrl2 = buildSourceUrl(mergedOptions);
  const { clientId, format } = mergedOptions;
  const headers = { Authorization: `Bearer ${options.accessToken}`, ...options.headers };
  const parameters = { client: clientId, ...urlParameters };
  const errorContext = {
    requestType: "Map instantiation",
    connection: options.connectionName,
    type: endpoint,
    source: JSON.stringify(parameters, void 0, 2)
  };
  const mapInstantiation = await requestWithParameters({
    baseUrl: baseUrl2,
    parameters,
    headers,
    errorContext
  });
  const dataUrl = mapInstantiation[format].url[0];
  if (cache) {
    cache.value = parseInt(new URL(dataUrl).searchParams.get("cache") || "", 10);
  }
  errorContext.requestType = "Map data";
  if (format === "tilejson") {
    const json = await requestWithParameters({
      baseUrl: dataUrl,
      headers,
      errorContext
    });
    if (accessToken) {
      json.accessToken = accessToken;
    }
    return json;
  }
  return await requestWithParameters({
    baseUrl: dataUrl,
    headers,
    errorContext
  });
}

// dist/sources/boundary-query-source.js
var boundaryQuerySource = async function(options) {
  const { columns, filters, tilesetTableName, matchingColumn = "id", propertiesSqlQuery, queryParameters } = options;
  const urlParameters = {
    tilesetTableName,
    matchingColumn,
    propertiesSqlQuery
  };
  if (columns) {
    urlParameters.columns = columns.join(",");
  }
  if (filters) {
    urlParameters.filters = JSON.stringify(filters);
  }
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  return baseSource("boundary", options, urlParameters);
};

// dist/sources/boundary-table-source.js
var boundaryTableSource = async function(options) {
  const { filters, tilesetTableName, columns, matchingColumn = "id", propertiesTableName } = options;
  const urlParameters = {
    tilesetTableName,
    matchingColumn,
    propertiesTableName
  };
  if (columns) {
    urlParameters.columns = columns.join(",");
  }
  if (filters) {
    urlParameters.filters = JSON.stringify(filters);
  }
  return baseSource("boundary", options, urlParameters);
};

// dist/sources/h3-query-source.js
var h3QuerySource = async function(options) {
  const { aggregationExp, aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3, sqlQuery, spatialDataColumn = "h3", queryParameters } = options;
  const urlParameters = {
    aggregationExp,
    spatialDataColumn,
    spatialDataType: "h3",
    q: sqlQuery
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  return baseSource("query", options, urlParameters);
};

// dist/sources/h3-table-source.js
var h3TableSource = async function(options) {
  const { aggregationExp, aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3, spatialDataColumn = "h3", tableName } = options;
  const urlParameters = {
    aggregationExp,
    name: tableName,
    spatialDataColumn,
    spatialDataType: "h3"
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  return baseSource("table", options, urlParameters);
};

// dist/sources/h3-tileset-source.js
var h3TilesetSource = async function(options) {
  const { tableName } = options;
  const urlParameters = { name: tableName };
  return baseSource("tileset", options, urlParameters);
};

// dist/sources/raster-source.js
var rasterSource = async function(options) {
  const { tableName } = options;
  const urlParameters = { name: tableName };
  return baseSource("raster", options, urlParameters);
};

// dist/sources/quadbin-query-source.js
var quadbinQuerySource = async function(options) {
  const { aggregationExp, aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN, sqlQuery, spatialDataColumn = "quadbin", queryParameters } = options;
  const urlParameters = {
    aggregationExp,
    q: sqlQuery,
    spatialDataColumn,
    spatialDataType: "quadbin"
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  return baseSource("query", options, urlParameters);
};

// dist/sources/quadbin-table-source.js
var quadbinTableSource = async function(options) {
  const { aggregationExp, aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN, spatialDataColumn = "quadbin", tableName } = options;
  const urlParameters = {
    aggregationExp,
    name: tableName,
    spatialDataColumn,
    spatialDataType: "quadbin"
  };
  if (aggregationResLevel) {
    urlParameters.aggregationResLevel = String(aggregationResLevel);
  }
  return baseSource("table", options, urlParameters);
};

// dist/sources/quadbin-tileset-source.js
var quadbinTilesetSource = async function(options) {
  const { tableName } = options;
  const urlParameters = { name: tableName };
  return baseSource("tileset", options, urlParameters);
};

// dist/sources/vector-query-source.js
var vectorQuerySource = async function(options) {
  const { columns, filters, spatialDataColumn = "geom", sqlQuery, tileResolution = DEFAULT_TILE_RESOLUTION, queryParameters } = options;
  const urlParameters = {
    spatialDataColumn,
    spatialDataType: "geo",
    tileResolution: tileResolution.toString(),
    q: sqlQuery
  };
  if (columns) {
    urlParameters.columns = columns.join(",");
  }
  if (filters) {
    urlParameters.filters = JSON.stringify(filters);
  }
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  return baseSource("query", options, urlParameters);
};

// dist/sources/vector-table-source.js
var vectorTableSource = async function(options) {
  const { columns, filters, spatialDataColumn = "geom", tableName, tileResolution = DEFAULT_TILE_RESOLUTION } = options;
  const urlParameters = {
    name: tableName,
    spatialDataColumn,
    spatialDataType: "geo",
    tileResolution: tileResolution.toString()
  };
  if (columns) {
    urlParameters.columns = columns.join(",");
  }
  if (filters) {
    urlParameters.filters = JSON.stringify(filters);
  }
  return baseSource("table", options, urlParameters);
};

// dist/sources/vector-tileset-source.js
var vectorTilesetSource = async function(options) {
  const { tableName } = options;
  const urlParameters = { name: tableName };
  return baseSource("tileset", options, urlParameters);
};

// dist/api/parse-map.js
var import_constants12 = require("@luma.gl/constants");
var import_core11 = require("@deck.gl/core");

// dist/api/layer-map.js
var import_d3_array = require("d3-array");
var import_d3_color = require("d3-color");
var import_d3_scale3 = require("d3-scale");
var import_d3_format = require("d3-format");
var import_moment_timezone = __toESM(require("moment-timezone"), 1);
var import_aggregation_layers = require("@deck.gl/aggregation-layers");
var import_layers4 = require("@deck.gl/layers");
var import_geo_layers7 = require("@deck.gl/geo-layers");
var SCALE_FUNCS = {
  linear: import_d3_scale3.scaleLinear,
  ordinal: import_d3_scale3.scaleOrdinal,
  log: import_d3_scale3.scaleLog,
  point: import_d3_scale3.scalePoint,
  quantile: import_d3_scale3.scaleQuantile,
  quantize: import_d3_scale3.scaleQuantize,
  sqrt: import_d3_scale3.scaleSqrt,
  custom: import_d3_scale3.scaleThreshold,
  identity: scaleIdentity
};
function identity(v) {
  return v;
}
var UNKNOWN_COLOR = "#868d91";
var AGGREGATION = {
  average: "MEAN",
  maximum: "MAX",
  minimum: "MIN",
  sum: "SUM"
};
var OPACITY_MAP = {
  getFillColor: "opacity",
  getLineColor: "strokeOpacity",
  getTextColor: "opacity"
};
var AGGREGATION_FUNC = {
  "count unique": (values, accessor) => (0, import_d3_array.groupSort)(values, (v) => v.length, accessor).length,
  median: import_d3_array.median,
  mode: (values, accessor) => (0, import_d3_array.groupSort)(values, (v) => v.length, accessor).pop(),
  stddev: import_d3_array.deviation,
  variance: import_d3_array.variance
};
var hexToRGBA = (c) => {
  const { r, g, b, opacity } = (0, import_d3_color.rgb)(c);
  return [r, g, b, 255 * opacity];
};
var sharedPropMap = {
  color: "getFillColor",
  isVisible: "visible",
  label: "cartoLabel",
  textLabel: {
    alignment: "getTextAlignmentBaseline",
    anchor: "getTextAnchor",
    color: "getTextColor",
    size: "getTextSize"
  },
  visConfig: {
    enable3d: "extruded",
    elevationScale: "elevationScale",
    filled: "filled",
    strokeColor: "getLineColor",
    stroked: "stroked",
    thickness: "getLineWidth",
    radius: "getPointRadius",
    wireframe: "wireframe"
  }
};
var customMarkersPropsMap = {
  color: "getIconColor",
  visConfig: {
    radius: "getIconSize"
  }
};
var aggregationVisConfig = {
  colorAggregation: (x) => ({ colorAggregation: AGGREGATION[x] || AGGREGATION.sum }),
  colorRange: (x) => ({ colorRange: x.colors.map(hexToRGBA) }),
  coverage: "coverage",
  elevationPercentile: ["elevationLowerPercentile", "elevationUpperPercentile"],
  percentile: ["lowerPercentile", "upperPercentile"]
};
var defaultProps9 = {
  lineMiterLimit: 2,
  lineWidthUnits: "pixels",
  pointRadiusUnits: "pixels",
  rounded: true,
  wrapLongitude: false
};
function mergePropMaps(a = {}, b = {}) {
  return { ...a, ...b, visConfig: { ...a.visConfig, ...b.visConfig } };
}
function getLayer(type, config, dataset) {
  var _a, _b;
  let basePropMap = sharedPropMap;
  if ((_a = config.visConfig) == null ? void 0 : _a.customMarkers) {
    basePropMap = mergePropMaps(sharedPropMap, customMarkersPropsMap);
  }
  if (type === "mvt" || type === "tileset" || type === "h3" || type === "quadbin") {
    return getTileLayer(dataset, basePropMap);
  }
  const geoColumn = dataset == null ? void 0 : dataset.geoColumn;
  const getPosition = (d) => d[geoColumn].coordinates;
  const hexagonId = (_b = config.columns) == null ? void 0 : _b.hex_id;
  const layerTypeDefs = {
    point: {
      Layer: import_layers4.GeoJsonLayer,
      propMap: {
        columns: {
          altitude: (x) => ({ parameters: { depthTest: Boolean(x) } })
        },
        visConfig: { outline: "stroked" }
      }
    },
    geojson: {
      Layer: import_layers4.GeoJsonLayer
    },
    grid: {
      Layer: import_aggregation_layers.CPUGridLayer,
      propMap: { visConfig: { ...aggregationVisConfig, worldUnitSize: (x) => ({ cellSize: 1e3 * x }) } },
      defaultProps: { getPosition }
    },
    heatmap: {
      Layer: import_aggregation_layers.HeatmapLayer,
      propMap: { visConfig: { ...aggregationVisConfig, radius: "radiusPixels" } },
      defaultProps: { getPosition }
    },
    hexagon: {
      Layer: import_aggregation_layers.HexagonLayer,
      propMap: { visConfig: { ...aggregationVisConfig, worldUnitSize: (x) => ({ radius: 1e3 * x }) } },
      defaultProps: { getPosition }
    },
    hexagonId: {
      Layer: import_geo_layers7.H3HexagonLayer,
      propMap: { visConfig: { coverage: "coverage" } },
      defaultProps: { getHexagon: (d) => d[hexagonId], stroked: false }
    }
  };
  const layer = layerTypeDefs[type];
  assert(layer, `Unsupported layer type: ${type}`);
  return {
    ...layer,
    propMap: mergePropMaps(basePropMap, layer.propMap),
    defaultProps: { ...defaultProps9, ...layer.defaultProps }
  };
}
function layerFromTileDataset(scheme, type) {
  if (type === "raster") {
    return RasterTileLayer;
  }
  if (scheme === "h3") {
    return H3TileLayer;
  }
  if (scheme === "quadbin") {
    return QuadbinTileLayer;
  }
  return VectorTileLayer;
}
function getTileLayer(dataset, basePropMap) {
  const { aggregationExp, aggregationResLevel, data: { scheme } } = dataset;
  return {
    Layer: layerFromTileDataset(scheme),
    propMap: basePropMap,
    defaultProps: {
      ...defaultProps9,
      ...aggregationExp && { aggregationExp },
      ...aggregationResLevel && { aggregationResLevel },
      uniqueIdProperty: "geoid"
    }
  };
}
function domainFromAttribute(attribute, scaleType, scaleLength) {
  if (scaleType === "ordinal" || scaleType === "point") {
    return attribute.categories.map((c) => c.category).filter((c) => c !== void 0 && c !== null);
  }
  if (scaleType === "quantile" && attribute.quantiles) {
    return attribute.quantiles.global ? attribute.quantiles.global[scaleLength] : attribute.quantiles[scaleLength];
  }
  let { min } = attribute;
  if (scaleType === "log" && min === 0) {
    min = 1e-5;
  }
  return [min, attribute.max];
}
function domainFromValues(values, scaleType) {
  if (scaleType === "ordinal" || scaleType === "point") {
    return (0, import_d3_array.groupSort)(values, (g) => -g.length, (d) => d);
  } else if (scaleType === "quantile") {
    return values.sort((a, b) => a - b);
  } else if (scaleType === "log") {
    const [d0, d1] = (0, import_d3_array.extent)(values);
    return [d0 === 0 ? 1e-5 : d0, d1];
  }
  return (0, import_d3_array.extent)(values);
}
function calculateDomain(data, name, scaleType, scaleLength) {
  if (data.tilestats) {
    const { attributes } = data.tilestats.layers[0];
    const attribute = attributes.find((a) => a.attribute === name);
    return domainFromAttribute(attribute, scaleType, scaleLength);
  } else if (data.features) {
    const values = data.features.map(({ properties }) => properties[name]);
    return domainFromValues(values, scaleType);
  } else if (Array.isArray(data) && data[0][name] !== void 0) {
    const values = data.map((properties) => properties[name]);
    return domainFromValues(values, scaleType);
  }
  return [0, 1];
}
function normalizeAccessor(accessor, data) {
  if (data.features || data.tilestats) {
    return (object, info) => {
      if (object) {
        return accessor(object.properties || object.__source.object.properties);
      }
      const { data: data2, index } = info;
      const proxy = createBinaryProxy(data2, index);
      return accessor(proxy);
    };
  }
  return accessor;
}
function opacityToAlpha(opacity) {
  return opacity !== void 0 ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;
}
function getAccessorKeys(name, aggregation) {
  let keys = [name];
  if (aggregation) {
    keys = keys.concat([aggregation, aggregation.toUpperCase()].map((a) => `${name}_${a}`));
  }
  return keys;
}
function findAccessorKey(keys, properties) {
  for (const key of keys) {
    if (key in properties) {
      return [key];
    }
  }
  throw new Error(`Could not find property for any accessor key: ${keys}`);
}
function getColorValueAccessor({ name }, colorAggregation, data) {
  const aggregator = AGGREGATION_FUNC[colorAggregation];
  const accessor = (values) => aggregator(values, (p) => p[name]);
  return normalizeAccessor(accessor, data);
}
function getColorAccessor({ name, colorColumn }, scaleType, { aggregation, range }, opacity, data) {
  const scale = calculateLayerScale(colorColumn || name, scaleType, range, data);
  const alpha = opacityToAlpha(opacity);
  let accessorKeys = getAccessorKeys(name, aggregation);
  const accessor = (properties) => {
    if (!(accessorKeys[0] in properties)) {
      accessorKeys = findAccessorKey(accessorKeys, properties);
    }
    const propertyValue = properties[accessorKeys[0]];
    const { r, g, b } = (0, import_d3_color.rgb)(scale(propertyValue));
    return [r, g, b, propertyValue === null ? 0 : alpha];
  };
  return normalizeAccessor(accessor, data);
}
function calculateLayerScale(name, scaleType, range, data) {
  const scale = SCALE_FUNCS[scaleType]();
  let domain = [];
  let scaleColor = [];
  if (scaleType !== "identity") {
    const { colorMap, colors } = range;
    if (Array.isArray(colorMap)) {
      colorMap.forEach(([value, color]) => {
        domain.push(value);
        scaleColor.push(color);
      });
    } else {
      domain = calculateDomain(data, name, scaleType, colors.length);
      scaleColor = colors;
    }
    if (scaleType === "ordinal") {
      domain = domain.slice(0, scaleColor.length);
    }
  }
  scale.domain(domain);
  scale.range(scaleColor);
  scale.unknown(UNKNOWN_COLOR);
  return scale;
}
var FALLBACK_ICON = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNTAiLz4NCjwvc3ZnPg==";
function getIconUrlAccessor(field, range, { fallbackUrl, maxIconSize, useMaskedIcons }, data) {
  const urlToUnpackedIcon = (url) => ({
    id: `${url}@@${maxIconSize}`,
    url,
    width: maxIconSize,
    height: maxIconSize,
    mask: useMaskedIcons
  });
  let unknownValue = fallbackUrl || FALLBACK_ICON;
  if (range == null ? void 0 : range.othersMarker) {
    unknownValue = range.othersMarker;
  }
  const unknownIcon = urlToUnpackedIcon(unknownValue);
  if (!range || !field) {
    return () => unknownIcon;
  }
  const mapping = {};
  for (const { value, markerUrl } of range.markerMap) {
    if (markerUrl) {
      mapping[value] = urlToUnpackedIcon(markerUrl);
    }
  }
  const accessor = (properties) => {
    const propertyValue = properties[field.name];
    return mapping[propertyValue] || unknownIcon;
  };
  return normalizeAccessor(accessor, data);
}
function getMaxMarkerSize(visConfig, visualChannels) {
  const { radiusRange, radius } = visConfig;
  const { radiusField, sizeField } = visualChannels;
  const field = radiusField || sizeField;
  return Math.ceil(radiusRange && field ? radiusRange[1] : radius);
}
function negateAccessor(accessor) {
  return typeof accessor === "function" ? (d, i) => -accessor(d, i) : -accessor;
}
function getSizeAccessor({ name }, scaleType, aggregation, range, data) {
  const scale = scaleType ? SCALE_FUNCS[scaleType]() : identity;
  if (scaleType) {
    if (aggregation !== "count") {
      scale.domain(calculateDomain(data, name, scaleType));
    }
    scale.range(range);
  }
  let accessorKeys = getAccessorKeys(name, aggregation);
  const accessor = (properties) => {
    if (!(accessorKeys[0] in properties)) {
      accessorKeys = findAccessorKey(accessorKeys, properties);
    }
    const propertyValue = properties[accessorKeys[0]];
    return scale(propertyValue);
  };
  return normalizeAccessor(accessor, data);
}
var FORMATS = {
  date: (s) => import_moment_timezone.default.utc(s).format("MM/DD/YY HH:mm:ssa"),
  integer: (0, import_d3_format.format)("i"),
  float: (0, import_d3_format.format)(".5f"),
  timestamp: (s) => import_moment_timezone.default.utc(s).format("X"),
  default: String
};
function getTextAccessor({ name, type }, data) {
  const format = FORMATS[type] || FORMATS.default;
  const accessor = (properties) => {
    return format(properties[name]);
  };
  return normalizeAccessor(accessor, data);
}

// dist/api/parse-map.js
var import_extensions2 = require("@deck.gl/extensions");
var collisionFilterExtension = new import_extensions2.CollisionFilterExtension();
function parseMap(json) {
  const { keplerMapConfig, datasets, token } = json;
  assert(keplerMapConfig.version === "v1", "Only support Kepler v1");
  const { mapState, mapStyle } = keplerMapConfig.config;
  const { layers, layerBlending, interactionConfig } = keplerMapConfig.config.visState;
  return {
    id: json.id,
    title: json.title,
    description: json.description,
    createdAt: json.createdAt,
    updatedAt: json.updatedAt,
    initialViewState: mapState,
    mapStyle,
    token,
    layers: layers.reverse().map(({ id: id4, type, config, visualChannels }) => {
      try {
        const { dataId } = config;
        const dataset = datasets.find((d) => d.id === dataId);
        assert(dataset, `No dataset matching dataId: ${dataId}`);
        const { data } = dataset;
        assert(data, `No data loaded for dataId: ${dataId}`);
        const { Layer, propMap, defaultProps: defaultProps10 } = getLayer(type, config, dataset);
        const styleProps = createStyleProps(config, propMap);
        return new Layer({
          id: id4,
          data,
          ...defaultProps10,
          ...createInteractionProps(interactionConfig),
          ...styleProps,
          ...createChannelProps(id4, type, config, visualChannels, data),
          ...createParametersProp(layerBlending, styleProps.parameters || {}),
          ...createLoadOptions(token)
        });
      } catch (e) {
        import_core11.log.error(e.message)();
        return void 0;
      }
    })
  };
}
function createParametersProp(layerBlending, parameters) {
  if (layerBlending === "additive") {
    parameters.blendFunc = [770, 772];
    parameters.blendEquation = 32774;
  } else if (layerBlending === "subtractive") {
    parameters.blendFunc = [1, 775, 770, 772];
    parameters.blendEquation = [32778, 32774];
  }
  return Object.keys(parameters).length ? { parameters } : {};
}
function createInteractionProps(interactionConfig) {
  const pickable = interactionConfig && interactionConfig.tooltip.enabled;
  return {
    autoHighlight: pickable,
    pickable
  };
}
function mapProps(source, target, mapping) {
  for (const sourceKey in mapping) {
    const sourceValue = source[sourceKey];
    const targetKey = mapping[sourceKey];
    if (sourceValue === void 0) {
      continue;
    }
    if (typeof targetKey === "string") {
      target[targetKey] = sourceValue;
    } else if (typeof targetKey === "function") {
      const [key, value] = Object.entries(targetKey(sourceValue))[0];
      target[key] = value;
    } else if (typeof targetKey === "object") {
      mapProps(sourceValue, target, targetKey);
    }
  }
}
function createStyleProps(config, mapping) {
  const result = {};
  mapProps(config, result, mapping);
  if (result.stroked && !result.getLineColor) {
    result.getLineColor = result.getFillColor;
  }
  for (const colorAccessor in OPACITY_MAP) {
    if (Array.isArray(result[colorAccessor])) {
      const color = [...result[colorAccessor]];
      const opacityKey = OPACITY_MAP[colorAccessor];
      const opacity = config.visConfig[opacityKey];
      color[3] = opacityToAlpha(opacity);
      result[colorAccessor] = color;
    }
  }
  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];
  return result;
}
function createChannelProps(id4, type, config, visualChannels, data) {
  var _a;
  const { colorField, colorScale, radiusField, radiusScale, sizeField, sizeScale, strokeColorField, strokeColorScale } = visualChannels;
  let { heightField, heightScale } = visualChannels;
  if (type === "hexagonId") {
    heightField = sizeField;
    heightScale = sizeScale;
  }
  const { textLabel, visConfig } = config;
  const result = {};
  if (type === "grid" || type === "hexagon") {
    result.colorScaleType = colorScale;
    if (colorField) {
      const { colorAggregation } = config.visConfig;
      if (!AGGREGATION[colorAggregation]) {
        result.getColorValue = getColorValueAccessor(colorField, colorAggregation, data);
      } else {
        result.getColorWeight = (d) => d[colorField.name];
      }
    }
  } else if (colorField) {
    const { colorAggregation: aggregation, colorRange: range } = visConfig;
    result.getFillColor = getColorAccessor(
      colorField,
      colorScale,
      { aggregation, range },
      visConfig.opacity,
      data
    );
  }
  if (type === "point") {
    const altitude = (_a = config.columns) == null ? void 0 : _a.altitude;
    if (altitude) {
      result.dataTransform = (data2) => {
        data2.features.forEach(({ geometry, properties }) => {
          const { type: type2, coordinates } = geometry;
          if (type2 === "Point") {
            coordinates[2] = properties[altitude];
          }
        });
        return data2;
      };
    }
  }
  if (radiusField || sizeField) {
    result.getPointRadius = getSizeAccessor(
      radiusField || sizeField,
      radiusScale || sizeScale,
      visConfig.sizeAggregation,
      visConfig.radiusRange || visConfig.sizeRange,
      data
    );
  }
  if (strokeColorField) {
    const fallbackOpacity = type === "point" ? visConfig.opacity : 1;
    const opacity = visConfig.strokeOpacity !== void 0 ? visConfig.strokeOpacity : fallbackOpacity;
    const { strokeColorAggregation: aggregation, strokeColorRange: range } = visConfig;
    result.getLineColor = getColorAccessor(
      strokeColorField,
      strokeColorScale,
      { aggregation, range },
      opacity,
      data
    );
  }
  if (heightField && visConfig.enable3d) {
    result.getElevation = getSizeAccessor(
      heightField,
      heightScale,
      visConfig.heightAggregation,
      visConfig.heightRange || visConfig.sizeRange,
      data
    );
  }
  if (visConfig.customMarkers) {
    const maxIconSize = getMaxMarkerSize(visConfig, visualChannels);
    const { getPointRadius, getFillColor } = result;
    const { customMarkersUrl, customMarkersRange, filled: useMaskedIcons } = visConfig;
    result.pointType = "icon";
    result.getIcon = getIconUrlAccessor(visualChannels.customMarkersField, customMarkersRange, { fallbackUrl: customMarkersUrl, maxIconSize, useMaskedIcons }, data);
    result._subLayerProps = {
      "points-icon": {
        loadOptions: {
          image: {
            type: "imagebitmap"
          },
          imagebitmap: {
            resizeWidth: maxIconSize,
            resizeHeight: maxIconSize,
            resizeQuality: "high"
          }
        }
      }
    };
    if (getFillColor && useMaskedIcons) {
      result.getIconColor = getFillColor;
    }
    if (getPointRadius) {
      result.getIconSize = getPointRadius;
    }
    if (visualChannels.rotationField) {
      result.getIconAngle = negateAccessor(getSizeAccessor(visualChannels.rotationField, void 0, null, void 0, data));
    }
  } else if (type === "point" || type === "tileset") {
    result.pointType = "circle";
  }
  if (textLabel && textLabel.length && textLabel[0].field) {
    const [mainLabel, secondaryLabel] = textLabel;
    const collisionGroup = id4;
    ({
      alignment: result.getTextAlignmentBaseline,
      anchor: result.getTextAnchor,
      color: result.getTextColor,
      outlineColor: result.textOutlineColor,
      size: result.textSizeScale
    } = mainLabel);
    const { color: getSecondaryColor, field: secondaryField, outlineColor: secondaryOutlineColor, size: secondarySizeScale } = secondaryLabel || {};
    result.getText = mainLabel.field && getTextAccessor(mainLabel.field, data);
    const getSecondaryText = secondaryField && getTextAccessor(secondaryField, data);
    result.pointType = `${result.pointType}+text`;
    result.textCharacterSet = "auto";
    result.textFontFamily = "Inter, sans";
    result.textFontSettings = { sdf: true };
    result.textFontWeight = 600;
    result.textOutlineWidth = 3;
    result._subLayerProps = {
      ...result._subLayerProps,
      "points-text": {
        type: PointLabelLayer,
        extensions: [collisionFilterExtension],
        collisionEnabled: true,
        collisionGroup,
        ...result.getPointRadius ? { getRadius: result.getPointRadius } : { radiusScale: visConfig.radius },
        ...secondaryField && {
          getSecondaryText,
          getSecondaryColor,
          secondarySizeScale,
          secondaryOutlineColor
        }
      }
    };
  }
  return result;
}
function createLoadOptions(accessToken) {
  return {
    loadOptions: { fetch: { headers: { Authorization: `Bearer ${accessToken}` } } }
  };
}

// dist/api/fetch-map.js
async function _fetchMapDataset(dataset, accessToken, apiBaseUrl, clientId, headers) {
  const { aggregationExp, aggregationResLevel, connectionName, columns, format, geoColumn, source, type, queryParameters } = dataset;
  const cache = {};
  const globalOptions = {
    accessToken,
    apiBaseUrl,
    cache,
    clientId,
    connectionName,
    format,
    headers
  };
  if (type === "tileset") {
    dataset.data = await vectorTilesetSource({ ...globalOptions, tableName: source });
  } else {
    const [spatialDataType, spatialDataColumn] = geoColumn ? geoColumn.split(":") : ["geom"];
    if (spatialDataType === "geom") {
      const options = { ...globalOptions, spatialDataColumn };
      if (type === "table") {
        dataset.data = await vectorTableSource({ ...options, columns, tableName: source });
      } else if (type === "query") {
        dataset.data = await vectorQuerySource({
          ...options,
          columns,
          sqlQuery: source,
          queryParameters
        });
      }
    } else if (spatialDataType === "h3") {
      const options = { ...globalOptions, aggregationExp, aggregationResLevel, spatialDataColumn };
      if (type === "table") {
        dataset.data = await h3TableSource({ ...options, tableName: source });
      } else if (type === "query") {
        dataset.data = await h3QuerySource({ ...options, sqlQuery: source, queryParameters });
      }
    } else if (spatialDataType === "quadbin") {
      const options = { ...globalOptions, aggregationExp, aggregationResLevel, spatialDataColumn };
      if (type === "table") {
        dataset.data = await quadbinTableSource({ ...options, tableName: source });
      } else if (type === "query") {
        dataset.data = await quadbinQuerySource({ ...options, sqlQuery: source, queryParameters });
      }
    }
  }
  let cacheChanged = true;
  if (cache.value) {
    cacheChanged = dataset.cache !== cache.value;
    dataset.cache = cache.value;
  }
  return cacheChanged;
}
async function _fetchTilestats(attribute, dataset, accessToken, apiBaseUrl) {
  const { connectionName, data, id: id4, source, type, queryParameters } = dataset;
  const errorContext = {
    requestType: "Tile stats",
    connection: connectionName,
    type,
    source
  };
  if (!("tilestats" in data)) {
    throw new CartoAPIError(new Error(`Invalid dataset for tilestats: ${id4}`), errorContext);
  }
  const baseUrl2 = buildStatsUrl({ attribute, apiBaseUrl, ...dataset });
  const client = new URLSearchParams(data.tiles[0]).get("client");
  const headers = { Authorization: `Bearer ${accessToken}` };
  const parameters = {};
  if (client) {
    parameters.client = client;
  }
  if (type === "query") {
    parameters.q = source;
    if (queryParameters) {
      parameters.queryParameters = JSON.stringify(queryParameters);
    }
  }
  const stats = await requestWithParameters({
    baseUrl: baseUrl2,
    headers,
    parameters,
    errorContext
  });
  const { attributes } = data.tilestats.layers[0];
  const index = attributes.findIndex((d) => d.attribute === attribute);
  attributes[index] = stats;
  return true;
}
async function fillInMapDatasets({ datasets, token }, clientId, apiBaseUrl, headers) {
  const promises = datasets.map((dataset) => _fetchMapDataset(dataset, token, apiBaseUrl, clientId, headers));
  return await Promise.all(promises);
}
async function fillInTileStats({ datasets, keplerMapConfig, token }, apiBaseUrl) {
  var _a;
  const attributes = [];
  const { layers } = keplerMapConfig.config.visState;
  for (const layer of layers) {
    for (const channel of Object.keys(layer.visualChannels)) {
      const attribute = (_a = layer.visualChannels[channel]) == null ? void 0 : _a.name;
      if (attribute) {
        const dataset = datasets.find((d) => d.id === layer.config.dataId);
        if (dataset && dataset.type !== "tileset" && dataset.data.tilestats) {
          attributes.push({ attribute, dataset });
        }
      }
    }
  }
  const filteredAttributes = [];
  for (const a of attributes) {
    if (!filteredAttributes.find(({ attribute, dataset }) => attribute === a.attribute && dataset === a.dataset)) {
      filteredAttributes.push(a);
    }
  }
  const promises = filteredAttributes.map(({ attribute, dataset }) => _fetchTilestats(attribute, dataset, token, apiBaseUrl));
  return await Promise.all(promises);
}
async function fetchMap({ apiBaseUrl = DEFAULT_API_BASE_URL, cartoMapId, clientId = DEFAULT_CLIENT, headers = {}, autoRefresh, onNewData }) {
  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: "XXXX-XXXX-XXXX"})');
  assert(apiBaseUrl, "Must define apiBaseUrl");
  if (autoRefresh || onNewData) {
    assert(onNewData, "Must define `onNewData` when using autoRefresh");
    assert(typeof onNewData === "function", "`onNewData` must be a function");
    assert(typeof autoRefresh === "number" && autoRefresh > 0, "`autoRefresh` must be a positive number");
  }
  const baseUrl2 = buildPublicMapUrl({ apiBaseUrl, cartoMapId });
  const errorContext = { requestType: "Public map", mapId: cartoMapId };
  const map = await requestWithParameters({ baseUrl: baseUrl2, headers, errorContext });
  let stopAutoRefresh;
  if (autoRefresh) {
    const intervalId = setInterval(async () => {
      const changed = await fillInMapDatasets(map, clientId, apiBaseUrl, {
        ...headers,
        "If-Modified-Since": new Date().toUTCString()
      });
      if (onNewData && changed.some((v) => v === true)) {
        onNewData(parseMap(map));
      }
    }, autoRefresh * 1e3);
    stopAutoRefresh = () => {
      clearInterval(intervalId);
    };
  }
  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(({ type }) => type === "geojson" || type === "point");
  const geojsonDatasetIds = geojsonLayers.map(({ config }) => config.dataId);
  map.datasets.forEach((dataset) => {
    if (geojsonDatasetIds.includes(dataset.id)) {
      const { config } = geojsonLayers.find(({ config: config2 }) => config2.dataId === dataset.id);
      dataset.format = "geojson";
      if (!dataset.geoColumn && config.columns.geojson) {
        dataset.geoColumn = config.columns.geojson;
      }
    }
  });
  await fillInMapDatasets(map, clientId, apiBaseUrl, headers);
  await fillInTileStats(map, apiBaseUrl);
  const out = { ...parseMap(map), ...{ stopAutoRefresh } };
  const textLayers = out.layers.filter((layer) => {
    const pointType = layer.props.pointType || "";
    return pointType.includes("text");
  });
  if (textLayers.length && window.FontFace && !document.fonts.check("12px Inter")) {
    const font = new FontFace("Inter", "url(https://fonts.gstatic.com/s/inter/v12/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7W0Q5nw.woff2)");
    await font.load().then((f) => document.fonts.add(f));
  }
  return out;
}

// dist/api/query.js
var query = async function(options) {
  const { apiBaseUrl = SOURCE_DEFAULTS.apiBaseUrl, connectionName, sqlQuery, queryParameters } = options;
  const urlParameters = { q: sqlQuery };
  if (queryParameters) {
    urlParameters.queryParameters = JSON.stringify(queryParameters);
  }
  const baseUrl2 = buildQueryUrl({ apiBaseUrl, connectionName });
  const headers = { Authorization: `Bearer ${options.accessToken}`, ...options.headers };
  const errorContext = {
    requestType: "SQL",
    connection: options.connectionName,
    type: "query",
    source: JSON.stringify(urlParameters, void 0, 2)
  };
  return await requestWithParameters({
    baseUrl: baseUrl2,
    parameters: urlParameters,
    headers,
    errorContext
  });
};

// dist/index.js
var CARTO_LAYERS = {
  H3TileLayer,
  _PointLabelLayer: PointLabelLayer,
  QuadbinTileLayer,
  RasterTileLayer,
  VectorTileLayer
};
var CARTO_SOURCES = {
  boundaryQuerySource,
  boundaryTableSource,
  h3QuerySource,
  h3TableSource,
  h3TilesetSource,
  rasterSource,
  quadbinQuerySource,
  quadbinTableSource,
  quadbinTilesetSource,
  vectorQuerySource,
  vectorTableSource,
  vectorTilesetSource
};
//# sourceMappingURL=index.cjs.map
