export default `\
#version 300 es
#define SHADER_NAME raster-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float widthScale;
uniform vec3 offset;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
vec2 common_position = offset.xy;
float scale = offset.z;
int yIndex = - (gl_InstanceID / BLOCK_WIDTH);
int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);
common_position += scale * vec2(float(xIndex), float(yIndex));
vec4 color = isStroke ? instanceLineColors : instanceFillColors;
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float cellWidth = coverage * scale;
geometry.position = vec4(common_position, 0.0, 1.0);
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
geometry.position.xyz -= project_uCommonOrigin;
}
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
} else if (stroked) {
float halfOffset = project_pixel_size(widthScale) / cellWidth;
if (isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
geometry.pickingColor = instancePickingColors;
vec2 offset = (vec2(0.5) + positions.xy * strokeOffsetRatio) * cellWidth * shouldRender;
vec3 pos = vec3(offset, project_size(elevation));
DECKGL_FILTER_SIZE(pos, geometry);
geometry.position.xyz += pos;
gl_Position = project_common_position_to_clipspace(geometry.position);
geometry.normal = project_normal(normals);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded && !isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;
