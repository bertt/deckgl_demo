import { CompositeLayer } from '@deck.gl/core';
import { ColumnLayer } from '@deck.gl/layers';
import { quadbinToOffset } from "./quadbin-utils.js";
import vs from "./raster-layer-vertex.glsl.js";
import { createBinaryProxy } from "../utils.js";
const defaultProps = {
    ...ColumnLayer.defaultProps,
    extruded: false,
    diskResolution: 4,
    vertices: [
        [-0.5, -0.5],
        [0.5, -0.5],
        [0.5, 0.5],
        [-0.5, 0.5]
    ]
};
// Modified ColumnLayer with custom vertex shader
class RasterColumnLayer extends ColumnLayer {
    static { this.layerName = 'RasterColumnLayer'; }
    getShaders() {
        const shaders = super.getShaders();
        const data = this.props.data;
        const BLOCK_WIDTH = data.data.blockSize ?? Math.sqrt(data.length);
        return { ...shaders, defines: { ...shaders.defines, BLOCK_WIDTH }, vs };
    }
    initializeState() {
        // Only add attributes needed by shader
        const attributeManager = this.getAttributeManager();
        /* eslint-disable max-len */
        attributeManager.addInstanced({
            instanceElevations: {
                size: 1,
                transition: true,
                accessor: 'getElevation'
            },
            instanceFillColors: {
                size: this.props.colorFormat.length,
                type: 'unorm8',
                transition: true,
                accessor: 'getFillColor',
                defaultValue: [0, 0, 0, 255]
            },
            instanceLineColors: {
                size: this.props.colorFormat.length,
                type: 'unorm8',
                transition: true,
                accessor: 'getLineColor',
                defaultValue: [255, 255, 255, 255]
            }
        });
    }
}
// Adapter layer around RasterColumnLayer that converts data & accessors into correct format
export default class RasterLayer extends CompositeLayer {
    static { this.layerName = 'RasterLayer'; }
    static { this.defaultProps = defaultProps; }
    renderLayers() {
        // Rendering props underlying layer
        const { data, getElevation, getFillColor, getLineColor, getLineWidth, tileIndex, updateTriggers } = this.props;
        if (!data || !tileIndex)
            return null;
        const blockSize = data.blockSize ?? 0;
        const [xOffset, yOffset, scale] = quadbinToOffset(tileIndex);
        const offset = [xOffset, yOffset, scale / blockSize];
        // Filled Column Layer
        const CellLayer = this.getSubLayerClass('column', RasterColumnLayer);
        return new CellLayer(this.props, this.getSubLayerProps({
            id: 'cell',
            updateTriggers,
            getElevation: this.getSubLayerAccessor(getElevation),
            getFillColor: this.getSubLayerAccessor(getFillColor),
            getLineColor: this.getSubLayerAccessor(getLineColor),
            getLineWidth: this.getSubLayerAccessor(getLineWidth)
        }), {
            data: {
                data, // Pass through data for getSubLayerAccessor()
                length: blockSize * blockSize
            },
            offset
        });
    }
    getSubLayerAccessor(accessor) {
        if (typeof accessor !== 'function') {
            return super.getSubLayerAccessor(accessor);
        }
        // Proxy values back in standard feature format
        return (object, info) => {
            const { data, index } = info;
            const binaryData = data.data;
            const proxy = createBinaryProxy(binaryData.cells, index);
            // @ts-ignore (TS2349) accessor is always function
            return accessor({ properties: proxy }, info);
        };
    }
}
