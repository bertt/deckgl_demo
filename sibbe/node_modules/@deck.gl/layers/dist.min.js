(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var Ji=Object.create;var Ht=Object.defineProperty;var qi=Object.getOwnPropertyDescriptor;var Qi=Object.getOwnPropertyNames;var tn=Object.getPrototypeOf,en=Object.prototype.hasOwnProperty;var Kt=(o,t)=>()=>(t||o((t={exports:{}}).exports,t),t.exports),on=(o,t)=>{for(var e in t)Ht(o,e,{get:t[e],enumerable:!0})},Zt=(o,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Qi(t))!en.call(o,n)&&n!==e&&Ht(o,n,{get:()=>t[n],enumerable:!(i=qi(t,n))||i.enumerable});return o},j=(o,t,e)=>(Zt(o,t,"default"),e&&Zt(e,t,"default")),P=(o,t,e)=>(e=o!=null?Ji(tn(o)):{},Zt(t||!o||!o.__esModule?Ht(e,"default",{value:o,enumerable:!0}):e,o)),nn=o=>Zt(Ht({},"__esModule",{value:!0}),o);var L=Kt(($s,Ke)=>{Ke.exports=globalThis.deck});var I=Kt((Ys,Xe)=>{Xe.exports=globalThis.luma});var go=Kt((Sa,fo)=>{fo.exports=globalThis.loaders});var ii=Kt((Wl,Be)=>{"use strict";Be.exports=ge;Be.exports.default=ge;function ge(o,t,e){e=e||2;var i=t&&t.length,n=i?t[0]*e:o.length,s=ti(o,0,n,e,!0),r=[];if(!s||s.next===s.prev)return r;var a,l,c,u,f,d,g;if(i&&(s=us(o,t,s,e)),o.length>80*e){a=c=o[0],l=u=o[1];for(var p=e;p<n;p+=e)f=o[p],d=o[p+1],f<a&&(a=f),d<l&&(l=d),f>c&&(c=f),d>u&&(u=d);g=Math.max(c-a,u-l),g=g!==0?32767/g:0}return bt(s,r,e,a,l,g,0),r}function ti(o,t,e,i,n){var s,r;if(n===Ge(o,t,e,i)>0)for(s=t;s<e;s+=i)r=Qo(s,o[s],o[s+1],r);else for(s=e-i;s>=t;s-=i)r=Qo(s,o[s],o[s+1],r);return r&&pe(r,r.next)&&(Ot(r),r=r.next),r}function et(o,t){if(!o)return o;t||(t=o);var e=o,i;do if(i=!1,!e.steiner&&(pe(e,e.next)||S(e.prev,e,e.next)===0)){if(Ot(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function bt(o,t,e,i,n,s,r){if(o){!r&&s&&hs(o,i,n,s);for(var a=o,l,c;o.prev!==o.next;){if(l=o.prev,c=o.next,s?as(o,i,n,s):rs(o)){t.push(l.i/e|0),t.push(o.i/e|0),t.push(c.i/e|0),Ot(o),o=c.next,a=c.next;continue}if(o=c,o===a){r?r===1?(o=ls(et(o),t,e),bt(o,t,e,i,n,s,2)):r===2&&cs(o,t,e,i,n,s):bt(et(o),t,e,i,n,s,1);break}}}}function rs(o){var t=o.prev,e=o,i=o.next;if(S(t,e,i)>=0)return!1;for(var n=t.x,s=e.x,r=i.x,a=t.y,l=e.y,c=i.y,u=n<s?n<r?n:r:s<r?s:r,f=a<l?a<c?a:c:l<c?l:c,d=n>s?n>r?n:r:s>r?s:r,g=a>l?a>c?a:c:l>c?l:c,p=i.next;p!==t;){if(p.x>=u&&p.x<=d&&p.y>=f&&p.y<=g&&ut(n,a,s,l,r,c,p.x,p.y)&&S(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function as(o,t,e,i){var n=o.prev,s=o,r=o.next;if(S(n,s,r)>=0)return!1;for(var a=n.x,l=s.x,c=r.x,u=n.y,f=s.y,d=r.y,g=a<l?a<c?a:c:l<c?l:c,p=u<f?u<d?u:d:f<d?f:d,h=a>l?a>c?a:c:l>c?l:c,m=u>f?u>d?u:d:f>d?f:d,y=We(g,p,t,e,i),_=We(h,m,t,e,i),x=o.prevZ,v=o.nextZ;x&&x.z>=y&&v&&v.z<=_;){if(x.x>=g&&x.x<=h&&x.y>=p&&x.y<=m&&x!==n&&x!==r&&ut(a,u,l,f,c,d,x.x,x.y)&&S(x.prev,x,x.next)>=0||(x=x.prevZ,v.x>=g&&v.x<=h&&v.y>=p&&v.y<=m&&v!==n&&v!==r&&ut(a,u,l,f,c,d,v.x,v.y)&&S(v.prev,v,v.next)>=0))return!1;v=v.nextZ}for(;x&&x.z>=y;){if(x.x>=g&&x.x<=h&&x.y>=p&&x.y<=m&&x!==n&&x!==r&&ut(a,u,l,f,c,d,x.x,x.y)&&S(x.prev,x,x.next)>=0)return!1;x=x.prevZ}for(;v&&v.z<=_;){if(v.x>=g&&v.x<=h&&v.y>=p&&v.y<=m&&v!==n&&v!==r&&ut(a,u,l,f,c,d,v.x,v.y)&&S(v.prev,v,v.next)>=0)return!1;v=v.nextZ}return!0}function ls(o,t,e){var i=o;do{var n=i.prev,s=i.next.next;!pe(n,s)&&ei(n,i,i.next,s)&&zt(n,s)&&zt(s,n)&&(t.push(n.i/e|0),t.push(i.i/e|0),t.push(s.i/e|0),Ot(i),Ot(i.next),i=o=s),i=i.next}while(i!==o);return et(i)}function cs(o,t,e,i,n,s){var r=o;do{for(var a=r.next.next;a!==r.prev;){if(r.i!==a.i&&ys(r,a)){var l=oi(r,a);r=et(r,r.next),l=et(l,l.next),bt(r,t,e,i,n,s,0),bt(l,t,e,i,n,s,0);return}a=a.next}r=r.next}while(r!==o)}function us(o,t,e,i){var n=[],s,r,a,l,c;for(s=0,r=t.length;s<r;s++)a=t[s]*i,l=s<r-1?t[s+1]*i:o.length,c=ti(o,a,l,i,!1),c===c.next&&(c.steiner=!0),n.push(xs(c));for(n.sort(fs),s=0;s<n.length;s++)e=ds(n[s],e);return e}function fs(o,t){return o.x-t.x}function ds(o,t){var e=gs(o,t);if(!e)return t;var i=oi(e,o);return et(i,i.next),et(e,e.next)}function gs(o,t){var e=t,i=o.x,n=o.y,s=-1/0,r;do{if(n<=e.y&&n>=e.next.y&&e.next.y!==e.y){var a=e.x+(n-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(a<=i&&a>s&&(s=a,r=e.x<e.next.x?e:e.next,a===i))return r}e=e.next}while(e!==t);if(!r)return null;var l=r,c=r.x,u=r.y,f=1/0,d;e=r;do i>=e.x&&e.x>=c&&i!==e.x&&ut(n<u?i:s,n,c,u,n<u?s:i,n,e.x,e.y)&&(d=Math.abs(n-e.y)/(i-e.x),zt(e,o)&&(d<f||d===f&&(e.x>r.x||e.x===r.x&&ps(r,e)))&&(r=e,f=d)),e=e.next;while(e!==l);return r}function ps(o,t){return S(o.prev,o,t.prev)<0&&S(t.next,o,o.next)<0}function hs(o,t,e,i){var n=o;do n.z===0&&(n.z=We(n.x,n.y,t,e,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==o);n.prevZ.nextZ=null,n.prevZ=null,ms(n)}function ms(o){var t,e,i,n,s,r,a,l,c=1;do{for(e=o,o=null,s=null,r=0;e;){for(r++,i=e,a=0,t=0;t<c&&(a++,i=i.nextZ,!!i);t++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||e.z<=i.z)?(n=e,e=e.nextZ,a--):(n=i,i=i.nextZ,l--),s?s.nextZ=n:o=n,n.prevZ=s,s=n;e=i}s.nextZ=null,c*=2}while(r>1);return o}function We(o,t,e,i,n){return o=(o-e)*n|0,t=(t-i)*n|0,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function xs(o){var t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function ut(o,t,e,i,n,s,r,a){return(n-r)*(t-a)>=(o-r)*(s-a)&&(o-r)*(i-a)>=(e-r)*(t-a)&&(e-r)*(s-a)>=(n-r)*(i-a)}function ys(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!vs(o,t)&&(zt(o,t)&&zt(t,o)&&Ps(o,t)&&(S(o.prev,o,t.prev)||S(o,t.prev,t))||pe(o,t)&&S(o.prev,o,o.next)>0&&S(t.prev,t,t.next)>0)}function S(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function pe(o,t){return o.x===t.x&&o.y===t.y}function ei(o,t,e,i){var n=de(S(o,t,e)),s=de(S(o,t,i)),r=de(S(e,i,o)),a=de(S(e,i,t));return!!(n!==s&&r!==a||n===0&&fe(o,e,t)||s===0&&fe(o,i,t)||r===0&&fe(e,o,i)||a===0&&fe(e,t,i))}function fe(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function de(o){return o>0?1:o<0?-1:0}function vs(o,t){var e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&ei(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function zt(o,t){return S(o.prev,o,o.next)<0?S(o,t,o.next)>=0&&S(o,o.prev,t)>=0:S(o,t,o.prev)<0||S(o,o.next,t)<0}function Ps(o,t){var e=o,i=!1,n=(o.x+t.x)/2,s=(o.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&n<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==o);return i}function oi(o,t){var e=new Ue(o.i,o.x,o.y),i=new Ue(t.i,t.x,t.y),n=o.next,s=t.prev;return o.next=t,t.prev=o,e.next=n,n.prev=e,i.next=e,e.prev=i,s.next=i,i.prev=s,i}function Qo(o,t,e,i){var n=new Ue(o,t,e);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function Ot(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function Ue(o,t,e){this.i=o,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}ge.deviation=function(o,t,e,i){var n=t&&t.length,s=n?t[0]*e:o.length,r=Math.abs(Ge(o,0,s,e));if(n)for(var a=0,l=t.length;a<l;a++){var c=t[a]*e,u=a<l-1?t[a+1]*e:o.length;r-=Math.abs(Ge(o,c,u,e))}var f=0;for(a=0;a<i.length;a+=3){var d=i[a]*e,g=i[a+1]*e,p=i[a+2]*e;f+=Math.abs((o[d]-o[p])*(o[g+1]-o[d+1])-(o[d]-o[g])*(o[p+1]-o[d+1]))}return r===0&&f===0?0:Math.abs((f-r)/r)};function Ge(o,t,e,i){for(var n=0,s=t,r=e-i;s<e;s+=i)n+=(o[r]-o[s])*(o[s+1]+o[r+1]),r=s;return n}ge.flatten=function(o){for(var t=o[0][0].length,e={vertices:[],holes:[],dimensions:t},i=0,n=0;n<o.length;n++){for(var s=0;s<o[n].length;s++)for(var r=0;r<t;r++)e.vertices.push(o[n][s][r]);n>0&&(i+=o[n-1].length,e.holes.push(i))}return e}});var Bt={};on(Bt,{ArcLayer:()=>xt,BitmapLayer:()=>vt,ColumnLayer:()=>tt,GeoJsonLayer:()=>Gt,GridCellLayer:()=>Et,IconLayer:()=>W,LineLayer:()=>Ct,PathLayer:()=>G,PointCloudLayer:()=>Lt,PolygonLayer:()=>Dt,ScatterplotLayer:()=>q,SolidPolygonLayer:()=>B,TextLayer:()=>rt,_MultiIconLayer:()=>it,_TextBackgroundLayer:()=>st});var R={},$e=P(L(),1);j(R,P(L(),1));if(!$e.Layer)throw new Error("@deck.gl/core is not found");j(Bt,R);var V=P(L(),1),qe=P(I(),1),Qe=P(I(),1);var Ye=`#version 300 es
#define SHADER_NAME arc-layer-vertex-shader
in vec3 positions;
in vec4 instanceSourceColors;
in vec4 instanceTargetColors;
in vec3 instanceSourcePositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions;
in vec3 instanceTargetPositions64Low;
in vec3 instancePickingColors;
in float instanceWidths;
in float instanceHeights;
in float instanceTilts;
uniform bool greatCircle;
uniform bool useShortestPath;
uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
out float isValid;
float paraboloid(float distance, float sourceZ, float targetZ, float ratio) {
float deltaZ = targetZ - sourceZ;
float dh = distance * instanceHeights;
if (dh == 0.0) {
return sourceZ + deltaZ * ratio;
}
float unitZ = deltaZ / dh;
float p2 = unitZ * unitZ + 1.0;
float dir = step(deltaZ, 0.0);
float z0 = mix(sourceZ, targetZ, dir);
float r = mix(ratio, 1.0 - ratio, dir);
return sqrt(r * (p2 - r)) * dh + z0;
}
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
float getSegmentRatio(float index) {
return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}
vec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {
float distance = length(source.xy - target.xy);
float z = paraboloid(distance, source.z, target.z, segmentRatio);
float tiltAngle = radians(instanceTilts);
vec2 tiltDirection = normalize(target.xy - source.xy);
vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);
return vec3(
mix(source.xy, target.xy, segmentRatio) + tilt,
z * cos(tiltAngle)
);
}
float getAngularDist (vec2 source, vec2 target) {
vec2 sourceRadians = radians(source);
vec2 targetRadians = radians(target);
vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);
vec2 shd_sq = sin_half_delta * sin_half_delta;
float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;
return 2.0 * asin(sqrt(a));
}
vec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {
vec2 lngLat;
if(abs(angularDist - PI) < 0.001) {
lngLat = (1.0 - t) * source.xy + t * target.xy;
} else {
float a = sin((1.0 - t) * angularDist);
float b = sin(t * angularDist);
vec3 p = source3D.yxz * a + target3D.yxz * b;
lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));
}
float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);
return vec3(lngLat, z);
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
float segmentIndex = positions.x;
float segmentRatio = getSegmentRatio(segmentIndex);
float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));
float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));
float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
isValid = 1.0;
uv = vec2(segmentRatio, positions.y);
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
vec4 curr;
vec4 next;
vec3 source;
vec3 target;
if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));
target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));
float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);
vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);
vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);
vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);
if (abs(currPos.x - prevPos.x) > 180.0) {
indexDir = -1.0;
isValid = 0.0;
} else if (abs(currPos.x - nextPos.x) > 180.0) {
indexDir = 1.0;
isValid = 0.0;
}
nextPos = indexDir < 0.0 ? prevPos : nextPos;
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
if (isValid == 0.0) {
nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;
float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);
currPos = mix(currPos, nextPos, t);
segmentRatio = mix(segmentRatio, nextSegmentRatio, t);
}
vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);
vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);
curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);
next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));
} else {
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
if (useShortestPath) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng > 180.) target_world.x -= 360.;
if (deltaLng < -180.) source_world.x -= 360.;
}
source = project_position(source_world, instanceSourcePositions64Low);
target = project_position(target_world, instanceTargetPositions64Low);
float antiMeridianX = 0.0;
if (useShortestPath) {
if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;
}
float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);
if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {
isValid = 0.0;
indexDir = sign(segmentRatio - thresholdRatio);
segmentRatio = thresholdRatio;
}
}
nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;
vec3 currPos = interpolateFlat(source, target, segmentRatio);
vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);
if (useShortestPath) {
if (nextPos.x < antiMeridianX) {
currPos.x += TILE_SIZE;
nextPos.x += TILE_SIZE;
}
}
curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
next = project_common_position_to_clipspace(vec4(nextPos, 1.0));
geometry.position = vec4(currPos, 1.0);
}
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(curr, geometry);
gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);
vColor = vec4(color.rgb, color.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Je=`#version 300 es
#define SHADER_NAME arc-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
in float isValid;
out vec4 fragColor;
void main(void) {
if (isValid == 0.0) {
discard;
}
fragColor = vColor;
geometry.uv = uv;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var $t=[0,0,0,255],sn={getSourcePosition:{type:"accessor",value:o=>o.sourcePosition},getTargetPosition:{type:"accessor",value:o=>o.targetPosition},getSourceColor:{type:"accessor",value:$t},getTargetColor:{type:"accessor",value:$t},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}},Xt=class extends V.Layer{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:Ye,fs:Je,modules:[V.project32,V.picking]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:$t},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:$t},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(t){super.updateState(t);let{props:e,oldProps:i,changeFlags:n}=t;(n.extensionsChanged||e.numSegments!==i.numSegments)&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){let{widthUnits:e,widthScale:i,widthMinPixels:n,widthMaxPixels:s,greatCircle:r,wrapLongitude:a}=this.props,l=this.state.model;l.setUniforms(t),l.setUniforms({greatCircle:r,widthUnits:V.UNIT[e],widthScale:i,widthMinPixels:n,widthMaxPixels:s,useShortestPath:a}),l.draw(this.context.renderPass)}_getModel(){let{numSegments:t}=this.props,e=[];for(let n=0;n<t;n++)e=e.concat([n,1,0,n,-1,0]);let i=new Qe.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new qe.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(e)}}}),isInstanced:!0});return i.setUniforms({numSegments:t}),i}},xt=Xt;(()=>{Xt.layerName="ArcLayer"})(),(()=>{Xt.defaultProps=sn})();var k=P(L(),1),lo=P(I(),1);var or=1/Math.PI*180,ir=1/180*Math.PI,rn={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...rn}};var an=globalThis.mathgl.config;function to(o){return Array.isArray(o)||ArrayBuffer.isView(o)&&!(o instanceof DataView)}function lt(o,t,e){return to(o)?o.map((i,n)=>lt(i,t[n],e)):e*t+(1-e)*o}function Yt(o,t){if(!o)throw new Error(t||"@math.gl/web-mercator: assertion failed.")}var Y=Math.PI,fn=Y/4,eo=Y/180,Ir=180/Y,oo=512;function J(o){let[t,e]=o;Yt(Number.isFinite(t)),Yt(Number.isFinite(e)&&e>=-90&&e<=90,"invalid latitude");let i=t*eo,n=e*eo,s=oo*(i+Y)/(2*Y),r=oo*(Y+Math.log(Math.tan(fn+n*.5)))/(2*Y);return[s,r]}var Dr=Math.PI/180;var Sn=new Uint32Array([0,2,1,0,3,2]),wn=new Float32Array([0,1,0,0,1,0,1,1]);function ze(o,t){if(!t)return Mn(o);let e=Math.max(Math.abs(o[0][0]-o[3][0]),Math.abs(o[1][0]-o[2][0])),i=Math.max(Math.abs(o[1][1]-o[0][1]),Math.abs(o[2][1]-o[3][1])),n=Math.ceil(e/t)+1,s=Math.ceil(i/t)+1,r=(n-1)*(s-1)*6,a=new Uint32Array(r),l=new Float32Array(n*s*2),c=new Float64Array(n*s*3),u=0,f=0;for(let d=0;d<n;d++){let g=d/(n-1);for(let p=0;p<s;p++){let h=p/(s-1),m=Tn(o,g,h);c[u*3+0]=m[0],c[u*3+1]=m[1],c[u*3+2]=m[2]||0,l[u*2+0]=g,l[u*2+1]=1-h,d>0&&p>0&&(a[f++]=u-s,a[f++]=u-s-1,a[f++]=u-1,a[f++]=u-s,a[f++]=u-1,a[f++]=u),u++}}return{vertexCount:r,positions:c,indices:a,texCoords:l}}function Mn(o){let t=new Float64Array(12);for(let e=0;e<o.length;e++)t[e*3+0]=o[e][0],t[e*3+1]=o[e][1],t[e*3+2]=o[e][2]||0;return{vertexCount:6,positions:t,indices:Sn,texCoords:wn}}function Tn(o,t,e){return lt(lt(o[0],o[1],e),lt(o[3],o[2],e),t)}var so=`#version 300 es
#define SHADER_NAME bitmap-layer-vertex-shader

in vec2 texCoords;
in vec3 positions;
in vec3 positions64Low;

out vec2 vTexCoord;
out vec2 vTexPos;

uniform float coordinateConversion;

const vec3 pickingColor = vec3(1.0, 0.0, 0.0);

void main(void) {
  geometry.worldPosition = positions;
  geometry.uv = texCoords;
  geometry.pickingColor = pickingColor;

  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vTexCoord = texCoords;

  if (coordinateConversion < -0.5) {
    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;
  } else if (coordinateConversion > 0.5) {
    vTexPos = geometry.worldPosition.xy;
  }

  vec4 color = vec4(0.0);
  DECKGL_FILTER_COLOR(color, geometry);
}
`;var In=`
vec3 packUVsIntoRGB(vec2 uv) {
  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction
  vec2 uv8bit = floor(uv * 256.);

  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits
  // Scale and clamp to 0-1 range
  vec2 uvFraction = fract(uv * 256.);
  vec2 uvFraction4bit = floor(uvFraction * 16.);

  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates
  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;

  return vec3(uv8bit, fractions) / 255.;
}
`,ro=`#version 300 es
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

in vec2 vTexCoord;
in vec2 vTexPos;

out vec4 fragColor;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

uniform float coordinateConversion;
uniform vec4 bounds;

/* projection utils */
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / PI / 2.0;

// from degrees to Web Mercator
vec2 lnglat_to_mercator(vec2 lnglat) {
  float x = lnglat.x;
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// from Web Mercator to degrees
vec2 mercator_to_lnglat(vec2 xy) {
  xy /= WORLD_SCALE;
  return degrees(vec2(
    xy.x - PI,
    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5
  ));
}
/* End projection utils */

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  if (transparentColor.a == 0.0) {
    return vec4(color, alpha);
  }
  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);
  float highLightRatio = alpha / blendedAlpha;
  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);
  return vec4(blendedRGB, blendedAlpha);
}

vec2 getUV(vec2 pos) {
  return vec2(
    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),
    (pos.y - bounds[3]) / (bounds[1] - bounds[3])
  );
}

${In}

void main(void) {
  vec2 uv = vTexCoord;
  if (coordinateConversion < -0.5) {
    vec2 lnglat = mercator_to_lnglat(vTexPos);
    uv = getUV(lnglat);
  } else if (coordinateConversion > 0.5) {
    vec2 commonPos = lnglat_to_mercator(vTexPos);
    uv = getUV(commonPos);
  }
  vec4 bitmapColor = texture(bitmapTexture, uv);

  fragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  geometry.uv = uv;
  DECKGL_FILTER_COLOR(fragColor, geometry);

  if (bool(picking.isActive) && !bool(picking.isAttribute)) {
    // Since instance information is not used, we can use picking color for pixel index
    fragColor.rgb = packUVsIntoRGB(uv);
  }
}
`;var En={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:k.COORDINATE_SYSTEM.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]},textureParameters:{type:"object",ignore:!0,value:null}},Jt=class extends k.Layer{getShaders(){return super.getShaders({vs:so,fs:ro,modules:[k.project32,k.picking]})}initializeState(){let t=this.getAttributeManager();t.remove(["instancePickingColors"]);let e=!0;t.add({indices:{size:1,isIndexed:!0,update:i=>i.value=this.state.mesh.indices,noAlloc:e},positions:{size:3,type:"float64",fp64:this.use64bitPositions(),update:i=>i.value=this.state.mesh.positions,noAlloc:e},texCoords:{size:2,update:i=>i.value=this.state.mesh.texCoords,noAlloc:e}})}updateState({props:t,oldProps:e,changeFlags:i}){let n=this.getAttributeManager();if(i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),n.invalidateAll()),t.bounds!==e.bounds){let s=this.state.mesh,r=this._createMesh();this.state.model.setVertexCount(r.vertexCount);for(let a in r)s&&s[a]!==r[a]&&n.invalidate(a);this.setState({mesh:r,...this._getCoordinateUniforms()})}else t._imageCoordinateSystem!==e._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(t){let{image:e}=this.props,i=t.info;if(!i.color||!e)return i.bitmap=null,i;let{width:n,height:s}=e;i.index=0;let r=An(i.color);return i.bitmap={size:{width:n,height:s},uv:r,pixel:[Math.floor(r[0]*n),Math.floor(r[1]*s)]},i}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(t){super._updateAutoHighlight({...t,color:this.encodePickingColor(0)})}_createMesh(){let{bounds:t}=this.props,e=t;return ao(t)&&(e=[[t[0],t[1]],[t[0],t[3]],[t[2],t[3]],[t[2],t[1]]]),ze(e,this.context.viewport.resolution)}_getModel(){return new lo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-list",isInstanced:!1})}draw(t){let{uniforms:e,moduleParameters:i}=t,{model:n,coordinateConversion:s,bounds:r,disablePicking:a}=this.state,{image:l,desaturate:c,transparentColor:u,tintColor:f}=this.props;i.picking.isActive&&a||l&&n&&(n.setUniforms(e),n.setBindings({bitmapTexture:l}),n.setUniforms({desaturate:c,transparentColor:u.map(d=>d/255),tintColor:f.slice(0,3).map(d=>d/255),coordinateConversion:s,bounds:r}),n.draw(this.context.renderPass))}_getCoordinateUniforms(){let{LNGLAT:t,CARTESIAN:e,DEFAULT:i}=k.COORDINATE_SYSTEM,{_imageCoordinateSystem:n}=this.props;if(n!==i){let{bounds:s}=this.props;if(!ao(s))throw new Error("_imageCoordinateSystem only supports rectangular bounds");let r=this.context.viewport.resolution?t:e;if(n=n===t?t:e,n===t&&r===e)return{coordinateConversion:-1,bounds:s};if(n===e&&r===t){let a=J([s[0],s[1]]),l=J([s[2],s[3]]);return{coordinateConversion:1,bounds:[a[0],a[1],l[0],l[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}},vt=Jt;(()=>{Jt.layerName="BitmapLayer"})(),(()=>{Jt.defaultProps=En})();function An(o){let[t,e,i]=o,n=(i&240)/256,s=(i&15)/16;return[(t+s)/256,(e+n)/256]}function ao(o){return Number.isFinite(o[0])}var F=P(L(),1),Qt=P(I(),1);var co=`#version 300 es
#define SHADER_NAME icon-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceSizes;
in float instanceAngles;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec4 instanceIconFrames;
in float instanceColorModes;
in vec2 instanceOffsets;
in vec2 instancePixelOffset;
uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;
uniform int sizeUnits;
out float vColorMode;
out vec4 vColor;
out vec2 vTextureCoords;
out vec2 uv;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = angle * PI / 180.0;
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vec2 iconSize = instanceIconFrames.zw;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;
vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
pixelOffset += instancePixelOffset;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vTextureCoords = mix(
instanceIconFrames.xy,
instanceIconFrames.xy + iconSize,
(positions.xy + 1.0) / 2.0
) / iconsTextureDim;
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
vColorMode = instanceColorModes;
}
`;var uo=`#version 300 es
#define SHADER_NAME icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float alphaCutoff;
in float vColorMode;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec4 texColor = texture(iconsTexture, vTextureCoords);
vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
float a = texColor.a * opacity * vColor.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color, a);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var xo=P(go(),1),yo=P(L(),1),bn=1024,zn=4,po=()=>{},ho={minFilter:"linear",mipmapFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"},On={x:0,y:0,width:0,height:0};function Rn(o){return Math.pow(2,Math.ceil(Math.log2(o)))}function Fn(o,t,e,i){let n=Math.min(e/t.width,i/t.height),s=Math.floor(t.width*n),r=Math.floor(t.height*n);return n===1?{data:t,width:s,height:r}:(o.canvas.height=r,o.canvas.width=s,o.clearRect(0,0,s,r),o.drawImage(t,0,0,t.width,t.height,0,0,s,r),{data:o.canvas,width:s,height:r})}function Pt(o){return o&&(o.id||o.url)}function Dn(o,t,e,i){let{width:n,height:s,device:r}=o,a=r.createTexture({format:"rgba8unorm",width:t,height:e,sampler:i}),l=r.createCommandEncoder();return l.copyTextureToTexture({source:o,destination:a,width:n,height:s}),l.finish(),o.destroy(),a}function mo(o,t,e){for(let i=0;i<t.length;i++){let{icon:n,xOffset:s}=t[i],r=Pt(n);o[r]={...n,x:s,y:e}}}function Nn({icons:o,buffer:t,mapping:e={},xOffset:i=0,yOffset:n=0,rowHeight:s=0,canvasWidth:r}){let a=[];for(let l=0;l<o.length;l++){let c=o[l],u=Pt(c);if(!e[u]){let{height:f,width:d}=c;i+d+t>r&&(mo(e,a,n),i=0,n=s+n+t,s=0,a=[]),a.push({icon:c,xOffset:i}),i=i+d+t,s=Math.max(s,f)}}return a.length>0&&mo(e,a,n),{mapping:e,rowHeight:s,xOffset:i,yOffset:n,canvasWidth:r,canvasHeight:Rn(s+n+t)}}function kn(o,t,e){if(!o||!t)return null;e=e||{};let i={},{iterable:n,objectInfo:s}=(0,yo.createIterable)(o);for(let r of n){s.index++;let a=t(r,s),l=Pt(a);if(!a)throw new Error("Icon is missing.");if(!a.url)throw new Error("Icon url is missing.");!i[l]&&(!e[l]||a.url!==e[l].url)&&(i[l]={...a,source:r,sourceIndex:s.index})}return i}var _t=class{constructor(t,{onUpdate:e=po,onError:i=po}){this._loadOptions=null,this._texture=null,this._externalTexture=null,this._mapping={},this._textureParameters=null,this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=zn,this._canvasWidth=bn,this._canvasHeight=0,this._canvas=null,this.device=t,this.onUpdate=e,this.onError=i}finalize(){this._texture?.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){let e=this._autoPacking?Pt(t):t;return this._mapping[e]||On}setProps({loadOptions:t,autoPacking:e,iconAtlas:i,iconMapping:n,textureParameters:s}){t&&(this._loadOptions=t),e!==void 0&&(this._autoPacking=e),n&&(this._mapping=n),i&&(this._texture?.delete(),this._texture=null,this._externalTexture=i),s&&(this._textureParameters=s)}get isLoaded(){return this._pendingCount===0}packIcons(t,e){if(!this._autoPacking||typeof document>"u")return;let i=Object.values(kn(t,e,this._mapping)||{});if(i.length>0){let{mapping:n,xOffset:s,yOffset:r,rowHeight:a,canvasHeight:l}=Nn({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=a,this._mapping=n,this._xOffset=s,this._yOffset=r,this._canvasHeight=l,this._texture||(this._texture=this.device.createTexture({format:"rgba8unorm",width:this._canvasWidth,height:this._canvasHeight,sampler:this._textureParameters||ho})),this._texture.height!==this._canvasHeight&&(this._texture=Dn(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||ho)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(t){let e=this._canvas.getContext("2d",{willReadFrequently:!0});for(let i of t)this._pendingCount++,(0,xo.load)(i.url,this._loadOptions).then(n=>{let s=Pt(i),r=this._mapping[s],{x:a,y:l,width:c,height:u}=r,{data:f,width:d,height:g}=Fn(e,n,c,u);this._texture.setSubImageData({data:f,x:a+(c-d)/2,y:l+(u-g)/2,width:d,height:g}),r.width=d,r.height=g,this._texture.generateMipmap(),this.onUpdate()}).catch(n=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:n})}).finally(()=>{this._pendingCount--})}};var vo=[0,0,0,255],Wn={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:o=>o.position},getIcon:{type:"accessor",value:o=>o.icon},getColor:{type:"accessor",value:vo},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,optional:!0},textureParameters:{type:"object",ignore:!0,value:null}},qt=class extends F.Layer{getShaders(){return super.getShaders({vs:co,fs:uo,modules:[F.project32,F.picking]})}initializeState(){this.state={iconManager:new _t(this.context.device,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})},this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:"uint8",accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:vo},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(t){super.updateState(t);let{props:e,oldProps:i,changeFlags:n}=t,s=this.getAttributeManager(),{iconAtlas:r,iconMapping:a,data:l,getIcon:c,textureParameters:u}=e,{iconManager:f}=this.state;if(typeof r=="string")return;let d=r||this.internalState.isAsyncPropLoading("iconAtlas");f.setProps({loadOptions:e.loadOptions,autoPacking:!d,iconAtlas:r,iconMapping:d?a:null,textureParameters:u}),d?i.iconMapping!==e.iconMapping&&s.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&f.packIcons(l,c),n.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),s.invalidateAll())}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(t){super.finalizeState(t),this.state.iconManager.finalize()}draw({uniforms:t}){let{sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,sizeUnits:s,billboard:r,alphaCutoff:a}=this.props,{iconManager:l}=this.state,c=l.getTexture();if(c){let u=this.state.model;u.setBindings({iconsTexture:c}),u.setUniforms(t),u.setUniforms({iconsTextureDim:[c.width,c.height],sizeUnits:F.UNIT[s],sizeScale:e,sizeMinPixels:i,sizeMaxPixels:n,billboard:r,alphaCutoff:a}),u.draw(this.context.renderPass)}}_getModel(){let t=[-1,-1,1,-1,-1,1,1,1];return new Qt.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Qt.Geometry({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array(t)}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){let e=this.getCurrentLayer()?.props.onIconError;e?e(t):F.log.error(t.error.message)()}getInstanceOffset(t){let{width:e,height:i,anchorX:n=e/2,anchorY:s=i/2}=this.state.iconManager.getIconMapping(t);return[e/2-n,i/2-s]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){let{x:e,y:i,width:n,height:s}=this.state.iconManager.getIconMapping(t);return[e,i,n,s]}},W=qt;(()=>{qt.defaultProps=Wn})(),(()=>{qt.layerName="IconLayer"})();var Z=P(L(),1),Co=P(I(),1),Lo=P(I(),1);var Po=`#version 300 es
#define SHADER_NAME line-layer-vertex-shader
in vec3 positions;
in vec3 instanceSourcePositions;
in vec3 instanceTargetPositions;
in vec3 instanceSourcePositions64Low;
in vec3 instanceTargetPositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in float instanceWidths;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float useShortestPath;
uniform int widthUnits;
out vec4 vColor;
out vec2 uv;
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);
return dir_screenspace * offset_direction * width / 2.0;
}
vec3 splitLine(vec3 a, vec3 b, float x) {
float t = (x - a.x) / (b.x - a.x);
return vec3(x, mix(a.yz, b.yz, t));
}
void main(void) {
geometry.worldPosition = instanceSourcePositions;
geometry.worldPositionAlt = instanceTargetPositions;
vec3 source_world = instanceSourcePositions;
vec3 target_world = instanceTargetPositions;
vec3 source_world_64low = instanceSourcePositions64Low;
vec3 target_world_64low = instanceTargetPositions64Low;
if (useShortestPath > 0.5 || useShortestPath < -0.5) {
source_world.x = mod(source_world.x + 180., 360.0) - 180.;
target_world.x = mod(target_world.x + 180., 360.0) - 180.;
float deltaLng = target_world.x - source_world.x;
if (deltaLng * useShortestPath > 180.) {
source_world.x += 360. * useShortestPath;
source_world = splitLine(source_world, target_world, 180. * useShortestPath);
source_world_64low = vec3(0.0);
} else if (deltaLng * useShortestPath < -180.) {
target_world.x += 360. * useShortestPath;
target_world = splitLine(source_world, target_world, 180. * useShortestPath);
target_world_64low = vec3(0.0);
} else if (useShortestPath < 0.) {
gl_Position = vec4(0.);
return;
}
}
vec4 source_commonspace;
vec4 target_commonspace;
vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);
vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);
float segmentIndex = positions.x;
vec4 p = mix(source, target, segmentIndex);
geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);
uv = positions.xy;
geometry.uv = uv;
geometry.pickingColor = instancePickingColors;
float widthPixels = clamp(
project_size_to_pixel(instanceWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels
);
vec3 offset = vec3(
getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),
0.0);
DECKGL_FILTER_SIZE(offset, geometry);
DECKGL_FILTER_GL_POSITION(p, geometry);
gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var _o=`#version 300 es
#define SHADER_NAME line-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Un=[0,0,0,255],Gn={getSourcePosition:{type:"accessor",value:o=>o.sourcePosition},getTargetPosition:{type:"accessor",value:o=>o.targetPosition},getColor:{type:"accessor",value:Un},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}},te=class extends Z.Layer{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:Po,fs:_o,modules:[Z.project32,Z.picking]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){let{widthUnits:e,widthScale:i,widthMinPixels:n,widthMaxPixels:s,wrapLongitude:r}=this.props,a=this.state.model;a.setUniforms(t),a.setUniforms({widthUnits:Z.UNIT[e],widthScale:i,widthMinPixels:n,widthMaxPixels:s,useShortestPath:r?1:0}),a.draw(this.context.renderPass),r&&(a.setUniforms({useShortestPath:-1}),a.draw(this.context.renderPass))}_getModel(){let t=[0,-1,0,0,1,0,1,-1,0,1,1,0];return new Lo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Co.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(t)}}}),isInstanced:!0})}},Ct=te;(()=>{te.layerName="LineLayer"})(),(()=>{te.defaultProps=Gn})();var D=P(L(),1),oe=P(I(),1);var So=`#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var wo=`#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Mo=[0,0,0,255],To=[0,0,1],Bn={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:o=>o.position},getNormal:{type:"accessor",value:To},getColor:{type:"accessor",value:Mo},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};function jn(o){let{header:t,attributes:e}=o;if(!(!t||!e)&&(o.length=t.vertexCount,e.POSITION&&(e.instancePositions=e.POSITION),e.NORMAL&&(e.instanceNormals=e.NORMAL),e.COLOR_0)){let{size:i,value:n}=e.COLOR_0;e.instanceColors={size:i,type:"unorm8",value:n}}}var ee=class extends D.Layer{getShaders(){return super.getShaders({vs:So,fs:wo,modules:[D.project32,D.gouraudLighting,D.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:To},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getColor",defaultValue:Mo}})}updateState(t){let{changeFlags:e,props:i}=t;super.updateState(t),e.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll()),e.dataChanged&&jn(i.data)}draw({uniforms:t}){let{pointSize:e,sizeUnits:i}=this.props,n=this.state.model;n.setUniforms(t),n.setUniforms({sizeUnits:D.UNIT[i],radiusPixels:e}),n.draw(this.context.renderPass)}_getModel(){let t=[];for(let e=0;e<3;e++){let i=e/3*Math.PI*2;t.push(Math.cos(i)*2,Math.sin(i)*2,0)}return new oe.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new oe.Geometry({topology:"triangle-list",attributes:{positions:new Float32Array(t)}}),isInstanced:!0})}},Lt=ee;(()=>{ee.layerName="PointCloudLayer"})(),(()=>{ee.defaultProps=Bn})();var U=P(L(),1),bo=P(I(),1),zo=P(I(),1);var Io=`#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;
uniform bool antialiasing;
uniform bool billboard;
uniform int radiusUnits;
uniform int lineWidthUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),
radiusMinPixels, radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),
lineWidthMinPixels, lineWidthMaxPixels
);
outerRadiusPixels += stroked * lineWidthPixels / 2.0;
float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
if (billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;var Eo=`#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
uniform bool filled;
uniform float stroked;
uniform bool antialiasing;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (stroked > 0.5) {
float isLine = antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (filled) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (!filled) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Ao=[0,0,0,255],Vn={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:o=>o.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:Ao},getLineColor:{type:"accessor",value:Ao},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}},ie=class extends U.Layer{getShaders(){return super.getShaders({vs:Io,fs:Eo,modules:[U.project32,U.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){let{radiusUnits:e,radiusScale:i,radiusMinPixels:n,radiusMaxPixels:s,stroked:r,filled:a,billboard:l,antialiasing:c,lineWidthUnits:u,lineWidthScale:f,lineWidthMinPixels:d,lineWidthMaxPixels:g}=this.props,p=this.state.model;p.setUniforms(t),p.setUniforms({stroked:r?1:0,filled:a,billboard:l,antialiasing:c,radiusUnits:U.UNIT[e],radiusScale:i,radiusMinPixels:n,radiusMaxPixels:s,lineWidthUnits:U.UNIT[u],lineWidthScale:f,lineWidthMinPixels:d,lineWidthMaxPixels:g}),p.draw(this.context.renderPass)}_getModel(){let t=[-1,-1,0,1,-1,0,-1,1,0,1,1,0];return new zo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new bo.Geometry({topology:"triangle-strip",attributes:{positions:{size:3,value:new Float32Array(t)}}}),isInstanced:!0})}},q=ie;(()=>{ie.defaultProps=Vn})(),(()=>{ie.layerName="ScatterplotLayer"})();var b=P(L(),1),De=P(I(),1);var Wo=P(L(),1),Uo=P(I(),1);var ct={CLOCKWISE:1,COUNTER_CLOCKWISE:-1};function Q(o,t,e={}){return Oo(o,e)!==t?(Zn(o,e),!0):!1}function Oo(o,t={}){return Math.sign(ne(o,t))}var Oe={x:0,y:1,z:2};function ne(o,t={}){let{start:e=0,end:i=o.length,plane:n="xy"}=t,s=t.size||2,r=0,a=Oe[n[0]],l=Oe[n[1]];for(let c=e,u=i-s;c<i;c+=s)r+=(o[c+a]-o[u+a])*(o[c+l]+o[u+l]),u=c;return r/2}function Zn(o,t){let{start:e=0,end:i=o.length,size:n=2}=t,s=(i-e)/n,r=Math.floor(s/2);for(let a=0;a<r;++a){let l=e+a*n,c=e+(s-1-a)*n;for(let u=0;u<n;++u){let f=o[l+u];o[l+u]=o[c+u],o[c+u]=f}}}function A(o,t){let e=t.length,i=o.length;if(i>0){let n=!0;for(let s=0;s<e;s++)if(o[i-e+s]!==t[s]){n=!1;break}if(n)return!1}for(let n=0;n<e;n++)o[i+n]=t[n];return!0}function St(o,t){let e=t.length;for(let i=0;i<e;i++)o[i]=t[i]}function H(o,t,e,i,n=[]){let s=i+t*e;for(let r=0;r<e;r++)n[r]=o[s+r];return n}function se(o,t,e,i,n=[]){let s,r;if(e&8)s=(i[3]-o[1])/(t[1]-o[1]),r=3;else if(e&4)s=(i[1]-o[1])/(t[1]-o[1]),r=1;else if(e&2)s=(i[2]-o[0])/(t[0]-o[0]),r=2;else if(e&1)s=(i[0]-o[0])/(t[0]-o[0]),r=0;else return null;for(let a=0;a<o.length;a++)n[a]=(r&1)===a?i[r]:s*(t[a]-o[a])+o[a];return n}function wt(o,t){let e=0;return o[0]<t[0]?e|=1:o[0]>t[2]&&(e|=2),o[1]<t[1]?e|=4:o[1]>t[3]&&(e|=8),e}function Mt(o,t){let{size:e=2,broken:i=!1,gridResolution:n=10,gridOffset:s=[0,0],startIndex:r=0,endIndex:a=o.length}=t||{},l=(a-r)/e,c=[],u=[c],f=H(o,0,e,r),d,g,p=Do(f,n,s,[]),h=[];A(c,f);for(let m=1;m<l;m++){for(d=H(o,m,e,r,d),g=wt(d,p);g;){se(f,d,g,p,h);let y=wt(h,p);y&&(se(f,h,y,p,h),g=y),A(c,h),St(f,h),$n(p,n,g),i&&c.length>e&&(c=[],u.push(c),A(c,f)),g=wt(d,p)}A(c,d),St(f,d)}return i?u:u[0]}var Ro=0,Kn=1;function Tt(o,t=null,e){if(!o.length)return[];let{size:i=2,gridResolution:n=10,gridOffset:s=[0,0],edgeTypes:r=!1}=e||{},a=[],l=[{pos:o,types:r?new Array(o.length/i).fill(Kn):null,holes:t||[]}],c=[[],[]],u=[];for(;l.length;){let{pos:f,types:d,holes:g}=l.shift();Xn(f,i,g[0]||f.length,c),u=Do(c[0],n,s,u);let p=wt(c[1],u);if(p){let h=Fo(f,d,i,0,g[0]||f.length,u,p),m={pos:h[0].pos,types:h[0].types,holes:[]},y={pos:h[1].pos,types:h[1].types,holes:[]};l.push(m,y);for(let _=0;_<g.length;_++)h=Fo(f,d,i,g[_],g[_+1]||f.length,u,p),h[0]&&(m.holes.push(m.pos.length),m.pos=re(m.pos,h[0].pos),r&&(m.types=re(m.types,h[0].types))),h[1]&&(y.holes.push(y.pos.length),y.pos=re(y.pos,h[1].pos),r&&(y.types=re(y.types,h[1].types)))}else{let h={positions:f};r&&(h.edgeTypes=d),g.length&&(h.holeIndices=g),a.push(h)}}return a}function Fo(o,t,e,i,n,s,r){let a=(n-i)/e,l=[],c=[],u=[],f=[],d=[],g,p,h,m=H(o,a-1,e,i),y=Math.sign(r&8?m[1]-s[3]:m[0]-s[2]),_=t&&t[a-1],x=0,v=0;for(let C=0;C<a;C++)g=H(o,C,e,i,g),p=Math.sign(r&8?g[1]-s[3]:g[0]-s[2]),h=t&&t[i/e+C],p&&y&&y!==p&&(se(m,g,r,s,d),A(l,d)&&u.push(_),A(c,d)&&f.push(_)),p<=0?(A(l,g)&&u.push(h),x-=p):u.length&&(u[u.length-1]=Ro),p>=0?(A(c,g)&&f.push(h),v+=p):f.length&&(f[f.length-1]=Ro),St(m,g),y=p,_=h;return[x?{pos:l,types:t&&u}:null,v?{pos:c,types:t&&f}:null]}function Do(o,t,e,i){let n=Math.floor((o[0]-e[0])/t)*t+e[0],s=Math.floor((o[1]-e[1])/t)*t+e[1];return i[0]=n,i[1]=s,i[2]=n+t,i[3]=s+t,i}function $n(o,t,e){e&8?(o[1]+=t,o[3]+=t):e&4?(o[1]-=t,o[3]-=t):e&2?(o[0]+=t,o[2]+=t):e&1&&(o[0]-=t,o[2]-=t)}function Xn(o,t,e,i){let n=1/0,s=-1/0,r=1/0,a=-1/0;for(let l=0;l<e;l+=t){let c=o[l],u=o[l+1];n=c<n?c:n,s=c>s?c:s,r=u<r?u:r,a=u>a?u:a}return i[0][0]=n,i[0][1]=r,i[1][0]=s,i[1][1]=a,i}function re(o,t){for(let e=0;e<t.length;e++)o.push(t[e]);return o}var Yn=85.051129;function Re(o,t){let{size:e=2,startIndex:i=0,endIndex:n=o.length,normalize:s=!0}=t||{},r=o.slice(i,n);No(r,e,0,n-i);let a=Mt(r,{size:e,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(s)for(let l of a)ko(l,e);return a}function Fe(o,t=null,e){let{size:i=2,normalize:n=!0,edgeTypes:s=!1}=e||{};t=t||[];let r=[],a=[],l=0,c=0;for(let f=0;f<=t.length;f++){let d=t[f]||o.length,g=c,p=Jn(o,i,l,d);for(let h=p;h<d;h++)r[c++]=o[h];for(let h=l;h<p;h++)r[c++]=o[h];No(r,i,g,c),qn(r,i,g,c,e?.maxLatitude),l=d,a[f]=c}a.pop();let u=Tt(r,a,{size:i,gridResolution:360,gridOffset:[-180,-180],edgeTypes:s});if(n)for(let f of u)ko(f.positions,i);return u}function Jn(o,t,e,i){let n=-1,s=-1;for(let r=e+1;r<i;r+=t){let a=Math.abs(o[r]);a>n&&(n=a,s=r-1)}return s}function qn(o,t,e,i,n=Yn){let s=o[e],r=o[i-t];if(Math.abs(s-r)>180){let a=H(o,0,t,e);a[0]+=Math.round((r-s)/360)*360,A(o,a),a[1]=Math.sign(a[1])*n,A(o,a),a[0]=s,A(o,a)}}function No(o,t,e,i){let n=o[0],s;for(let r=e;r<i;r+=t){s=o[r];let a=s-n;(a>180||a<-180)&&(s-=Math.round(a/360)*360),o[r]=n=s}}function ko(o,t){let e,i=o.length/t;for(let s=0;s<i&&(e=o[s*t],(e+180)%360===0);s++);let n=-Math.round(e/360)*360;if(n!==0)for(let s=0;s<i;s++)o[s*t]+=n}var It=class extends Uo.Geometry{constructor(t){let{indices:e,attributes:i}=ts(t);super({...t,indices:e,attributes:i})}};function ts(o){let{radius:t,height:e=1,nradial:i=10}=o,{vertices:n}=o;n&&(Wo.log.assert(n.length>=i),n=n.flatMap(g=>[g[0],g[1]]),Q(n,ct.COUNTER_CLOCKWISE));let s=e>0,r=i+1,a=s?r*3+1:i,l=Math.PI*2/i,c=new Uint16Array(s?i*3*2:0),u=new Float32Array(a*3),f=new Float32Array(a*3),d=0;if(s){for(let g=0;g<r;g++){let p=g*l,h=g%i,m=Math.sin(p),y=Math.cos(p);for(let _=0;_<2;_++)u[d+0]=n?n[h*2]:y*t,u[d+1]=n?n[h*2+1]:m*t,u[d+2]=(1/2-_)*e,f[d+0]=n?n[h*2]:y,f[d+1]=n?n[h*2+1]:m,d+=3}u[d+0]=u[d-3],u[d+1]=u[d-2],u[d+2]=u[d-1],d+=3}for(let g=s?0:1;g<r;g++){let p=Math.floor(g/2)*Math.sign(.5-g%2),h=p*l,m=(p+i)%i,y=Math.sin(h),_=Math.cos(h);u[d+0]=n?n[m*2]:_*t,u[d+1]=n?n[m*2+1]:y*t,u[d+2]=e/2,f[d+2]=1,d+=3}if(s){let g=0;for(let p=0;p<i;p++)c[g++]=p*2+0,c[g++]=p*2+2,c[g++]=p*2+0,c[g++]=p*2+1,c[g++]=p*2+1,c[g++]=p*2+3}return{indices:c,attributes:{POSITION:{size:3,value:u},NORMAL:{size:3,value:f}}}}var Go=`#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool stroked;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform int radiusUnits;
uniform int widthUnits;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
} else if (stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
if (isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = radius * coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;
if (radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded && !isStroke) {
#ifdef FLAT_SHADING
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Bo=`#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
uniform vec3 project_uCameraPosition;
uniform bool extruded;
uniform bool isStroke;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
#ifdef FLAT_SHADING
if (extruded && !isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ae=[0,0,0,255],es={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,flatShading:!1,getPosition:{type:"accessor",value:o=>o.position},getFillColor:{type:"accessor",value:ae},getLineColor:{type:"accessor",value:ae},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}},le=class extends b.Layer{getShaders(){let t={},{flatShading:e}=this.props;return e&&(t.FLAT_SHADING=1),super.getShaders({vs:Go,fs:Bo,defines:t,modules:[b.project32,e?b.phongLighting:b.gouraudLighting,b.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getFillColor",defaultValue:ae},instanceLineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getLineColor",defaultValue:ae},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(t){super.updateState(t);let{props:e,oldProps:i,changeFlags:n}=t,s=n.extensionsChanged||e.flatShading!==i.flatShading;s&&(this.state.models?.forEach(a=>a.destroy()),this.setState(this._getModels()),this.getAttributeManager().invalidateAll());let r=this.getNumInstances();this.state.fillModel.setInstanceCount(r),this.state.wireframeModel.setInstanceCount(r),(s||e.diskResolution!==i.diskResolution||e.vertices!==i.vertices||(e.extruded||e.stroked)!==(i.extruded||i.stroked))&&this._updateGeometry(e)}getGeometry(t,e,i){let n=new It({radius:1,height:i?2:0,vertices:e,nradial:t}),s=0;if(e)for(let r=0;r<t;r++){let a=e[r],l=Math.sqrt(a[0]*a[0]+a[1]*a[1]);s+=l/t}else s=1;return this.setState({edgeDistance:Math.cos(Math.PI/t)*s}),n}_getModels(){let t=this.getShaders(),e=this.getAttributeManager().getBufferLayouts(),i=new De.Model(this.context.device,{...t,id:`${this.props.id}-fill`,bufferLayout:e,isInstanced:!0}),n=new De.Model(this.context.device,{...t,id:`${this.props.id}-wireframe`,bufferLayout:e,isInstanced:!0});return{fillModel:i,wireframeModel:n,models:[n,i]}}_updateGeometry({diskResolution:t,vertices:e,extruded:i,stroked:n}){let s=this.getGeometry(t,e,i||n);this.setState({fillVertexCount:s.attributes.POSITION.value.length/3});let r=this.state.fillModel,a=this.state.wireframeModel;r.setGeometry(s),r.setTopology("triangle-strip"),r.setIndexBuffer(null),a.setGeometry(s),a.setTopology("line-list")}draw({uniforms:t}){let{lineWidthUnits:e,lineWidthScale:i,lineWidthMinPixels:n,lineWidthMaxPixels:s,radiusUnits:r,elevationScale:a,extruded:l,filled:c,stroked:u,wireframe:f,offset:d,coverage:g,radius:p,angle:h}=this.props,m=this.state.fillModel,y=this.state.wireframeModel,{fillVertexCount:_,edgeDistance:x}=this.state,v={...t,radius:p,angle:h/180*Math.PI,offset:d,extruded:l,stroked:u,coverage:g,elevationScale:a,edgeDistance:x,radiusUnits:b.UNIT[r],widthUnits:b.UNIT[e],widthScale:i,widthMinPixels:n,widthMaxPixels:s};l&&f&&(y.setUniforms(v),y.setUniforms({isStroke:!0}),y.draw(this.context.renderPass)),m.setUniforms(v),c&&(m.setVertexCount(_),m.setUniforms({isStroke:!1}),m.draw(this.context.renderPass)),!l&&u&&(m.setVertexCount(_*2/3),m.setUniforms({isStroke:!0}),m.draw(this.context.renderPass))}},tt=le;(()=>{le.layerName="ColumnLayer"})(),(()=>{le.defaultProps=es})();var jo=P(L(),1),Vo=P(I(),1);var os={cellSize:{type:"number",min:0,value:1e3},offset:{type:"array",value:[1,1]}},ce=class extends tt{_updateGeometry(){let t=new Vo.CubeGeometry;this.state.fillModel.setGeometry(t)}draw({uniforms:t}){let{elevationScale:e,extruded:i,offset:n,coverage:s,cellSize:r,angle:a,radiusUnits:l}=this.props,c=this.state.fillModel;c.setUniforms(t),c.setUniforms({radius:r/2,radiusUnits:jo.UNIT[l],angle:a,offset:n,extruded:i,coverage:s,elevationScale:e,edgeDistance:1,isStroke:!1}),c.draw(this.context.renderPass)}},Et=ce;(()=>{ce.layerName="GridCellLayer"})(),(()=>{ce.defaultProps=os})();var K=P(L(),1),Yo=P(I(),1),Jo=P(I(),1);var Ko=P(L(),1);function Zo(o,t,e,i){let n;if(Array.isArray(o[0])){let s=o.length*t;n=new Array(s);for(let r=0;r<o.length;r++)for(let a=0;a<t;a++)n[r*t+a]=o[r][a]||0}else n=o;return e?Mt(n,{size:t,gridResolution:e}):i?Re(n,{size:t}):n}var is=1,ns=2,Ne=4,At=class extends Ko.Tesselator{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?Zo(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(Ho(t)){let i=0;for(let n of t)i+=this.getGeometrySize(n);return i}let e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(e.geometrySize!==0)if(t&&Ho(t))for(let i of t){let n=this.getGeometrySize(i);e.geometrySize=n,this.updateGeometryAttributes(i,e),e.vertexStart+=n}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){let i=this.attributes.segmentTypes,n=t?this.isClosed(t):!1,{vertexStart:s,geometrySize:r}=e;i.fill(0,s,s+r),n?(i[s]=Ne,i[s+r-2]=Ne):(i[s]+=is,i[s+r-2]+=ns),i[s+r-1]=Ne}_updatePositions(t,e){let{positions:i}=this.attributes;if(!i||!t)return;let{vertexStart:n,geometrySize:s}=e,r=new Array(3);for(let a=n,l=0;l<s;a++,l++)this.getPointOnPath(t,l,r),i[a*3]=r[0],i[a*3+1]=r[1],i[a*3+2]=r[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i=[]){let{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);let s=e*n;return i[0]=t[s],i[1]=t[s+1],i[2]=n===3&&t[s+2]||0,i}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);let{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(e===2||t[2]===t[i+2])}};function Ho(o){return Array.isArray(o[0])}var $o=`#version 300 es
#define SHADER_NAME path-layer-vertex-shader
in vec2 positions;
in float instanceTypes;
in vec3 instanceStartPositions;
in vec3 instanceEndPositions;
in vec3 instanceLeftPositions;
in vec3 instanceRightPositions;
in vec3 instanceLeftPositions64Low;
in vec3 instanceStartPositions64Low;
in vec3 instanceEndPositions64Low;
in vec3 instanceRightPositions64Low;
in float instanceStrokeWidths;
in vec4 instanceColors;
in vec3 instancePickingColors;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float capType;
uniform float miterLimit;
uniform bool billboard;
uniform int widthUnits;
uniform float opacity;
out vec4 vColor;
out vec2 vCornerOffset;
out float vMiterLength;
out vec2 vPathPosition;
out float vPathLength;
out float vJointType;
const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);
float flipIfTrue(bool flag) {
return -(float(flag) * 2. - 1.);
}
vec3 getLineJoinOffset(
vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
vec2 width
) {
bool isEnd = positions.x > 0.0;
float sideOfPath = positions.y;
float isJoint = float(sideOfPath == 0.0);
vec3 deltaA3 = (currPoint - prevPoint);
vec3 deltaB3 = (nextPoint - currPoint);
mat3 rotationMatrix;
bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);
if (needsRotation) {
deltaA3 = deltaA3 * rotationMatrix;
deltaB3 = deltaB3 * rotationMatrix;
}
vec2 deltaA = deltaA3.xy / width;
vec2 deltaB = deltaB3.xy / width;
float lenA = length(deltaA);
float lenB = length(deltaB);
vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);
vec2 perpA = vec2(-dirA.y, dirA.x);
vec2 perpB = vec2(-dirB.y, dirB.x);
vec2 tangent = dirA + dirB;
tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
vec2 miterVec = vec2(-tangent.y, tangent.x);
vec2 dir = isEnd ? dirA : dirB;
vec2 perp = isEnd ? perpA : perpB;
float L = isEnd ? lenA : lenB;
float sinHalfA = abs(dot(miterVec, perp));
float cosHalfA = abs(dot(dirA, miterVec));
float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);
float cornerPosition = sideOfPath * turnDirection;
float miterSize = 1.0 / max(sinHalfA, EPSILON);
miterSize = mix(
min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),
miterSize,
step(0.0, cornerPosition)
);
vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))
* (sideOfPath + isJoint * turnDirection);
bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));
bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));
bool isCap = isStartCap || isEndCap;
if (isCap) {
offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);
vJointType = capType;
} else {
vJointType = jointType;
}
vPathLength = L;
vCornerOffset = offsetVec;
vMiterLength = dot(vCornerOffset, miterVec * turnDirection);
vMiterLength = isCap ? isJoint : vMiterLength;
vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);
vPathPosition = vec2(
dot(offsetFromStartOfPath, perp),
dot(offsetFromStartOfPath, dir)
);
geometry.uv = vPathPosition;
float isValid = step(instanceTypes, 3.5);
vec3 offset = vec3(offsetVec * width * isValid, 0.0);
if (needsRotation) {
offset = rotationMatrix * offset;
}
return offset;
}
void clipLine(inout vec4 position, vec4 refPosition) {
if (position.w < EPSILON) {
float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
position = refPosition + (position - refPosition) * r;
}
}
void main() {
geometry.pickingColor = instancePickingColors;
vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
float isEnd = positions.x;
vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);
vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);
vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);
geometry.worldPosition = currPosition;
vec2 widthPixels = vec2(clamp(
project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),
widthMinPixels, widthMaxPixels) / 2.0);
vec3 width;
if (billboard) {
vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);
vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);
vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);
clipLine(prevPositionScreen, currPositionScreen);
clipLine(nextPositionScreen, currPositionScreen);
clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));
width = vec3(widthPixels, 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(
prevPositionScreen.xyz / prevPositionScreen.w,
currPositionScreen.xyz / currPositionScreen.w,
nextPositionScreen.xyz / nextPositionScreen.w,
project_pixel_size_to_clipspace(width.xy)
);
DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);
gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);
} else {
prevPosition = project_position(prevPosition, prevPosition64Low);
currPosition = project_position(currPosition, currPosition64Low);
nextPosition = project_position(nextPosition, nextPosition64Low);
width = vec3(project_pixel_size(widthPixels), 0.0);
DECKGL_FILTER_SIZE(width, geometry);
vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);
geometry.position = vec4(currPosition + offset, 1.0);
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Xo=`#version 300 es
#define SHADER_NAME path-layer-fragment-shader
precision highp float;
uniform float miterLimit;
in vec4 vColor;
in vec2 vCornerOffset;
in float vMiterLength;
in vec2 vPathPosition;
in float vPathLength;
in float vJointType;
out vec4 fragColor;
void main(void) {
geometry.uv = vPathPosition;
if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {
if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {
discard;
}
if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {
discard;
}
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var qo=[0,0,0,255],ss={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:o=>o.path},getColor:{type:"accessor",value:qo},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},ke={enter:(o,t)=>t.length?t.subarray(t.length-o.length):o},ue=class extends K.Layer{getShaders(){return super.getShaders({vs:$o,fs:Xo,modules:[K.project32,K.picking]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){this.getAttributeManager().addInstanced({vertexPositions:{size:3,vertexOffset:1,type:"float64",fp64:this.use64bitPositions(),transition:ke,accessor:"getPath",update:this.calculatePositions,noAlloc:!0,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:"uint8",update:this.calculateSegmentTypes,noAlloc:!0},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:ke,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:"unorm8",accessor:"getColor",transition:ke,defaultValue:qo},instancePickingColors:{size:4,type:"uint8",accessor:(i,{index:n,target:s})=>this.encodePickingColor(i&&i.__source?i.__source.index:n,s)}}),this.setState({pathTesselator:new At({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);let{props:e,changeFlags:i}=t,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){let{pathTesselator:r}=this.state,a=e.data.attributes||{};r.updateGeometry({data:e.data,geometryBuffer:a.getPath,buffers:a,normalize:!e._pathType,loop:e._pathType==="loop",getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:r.instanceCount,startIndices:r.vertexStarts}),i.dataChanged||n.invalidateAll()}i.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),n.invalidateAll())}getPickingInfo(t){let e=super.getPickingInfo(t),{index:i}=e,n=this.props.data;return n[0]&&n[0].__source&&(e.object=n.find(s=>s.__source.index===i)),e}disablePickingIndex(t){let e=this.props.data;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else super.disablePickingIndex(t)}draw({uniforms:t}){let{jointRounded:e,capRounded:i,billboard:n,miterLimit:s,widthUnits:r,widthScale:a,widthMinPixels:l,widthMaxPixels:c}=this.props,u=this.state.model;u.setUniforms(t),u.setUniforms({jointType:Number(e),capType:Number(i),billboard:n,widthUnits:K.UNIT[r],widthScale:a,miterLimit:s,widthMinPixels:l,widthMaxPixels:c}),u.draw(this.context.renderPass)}_getModel(){let t=[0,1,2,1,4,2,1,3,4,3,5,4],e=[0,0,0,-1,0,1,1,-1,1,1,1,0];return new Jo.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Yo.Geometry({topology:"triangle-list",attributes:{indices:new Uint16Array(t),positions:{value:new Float32Array(e),size:2}}}),isInstanced:!0})}calculatePositions(t){let{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){let{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}},G=ue;(()=>{ue.defaultProps=ss})(),(()=>{ue.layerName="PathLayer"})();var dt=P(L(),1);var z=P(L(),1),ot=P(I(),1);var li=P(ii(),1);var he=ct.CLOCKWISE,ni=ct.COUNTER_CLOCKWISE,$={isClosed:!0};function _s(o){if(o=o&&o.positions||o,!Array.isArray(o)&&!ArrayBuffer.isView(o))throw new Error("invalid polygon")}function ft(o){return"positions"in o?o.positions:o}function Rt(o){return"holeIndices"in o?o.holeIndices:null}function Cs(o){return Array.isArray(o[0])}function Ls(o){return o.length>=1&&o[0].length>=2&&Number.isFinite(o[0][0])}function Ss(o){let t=o[0],e=o[o.length-1];return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]}function ws(o,t,e,i){for(let n=0;n<t;n++)if(o[e+n]!==o[i-t+n])return!1;return!0}function si(o,t,e,i,n){let s=t,r=e.length;for(let a=0;a<r;a++)for(let l=0;l<i;l++)o[s++]=e[a][l]||0;if(!Ss(e))for(let a=0;a<i;a++)o[s++]=e[0][a]||0;return $.start=t,$.end=s,$.size=i,Q(o,n,$),s}function ri(o,t,e,i,n=0,s,r){s=s||e.length;let a=s-n;if(a<=0)return t;let l=t;for(let c=0;c<a;c++)o[l++]=e[n+c];if(!ws(e,i,n,s))for(let c=0;c<i;c++)o[l++]=e[n+c];return $.start=t,$.end=l,$.size=i,Q(o,r,$),l}function me(o,t){_s(o);let e=[],i=[];if("positions"in o){let{positions:n,holeIndices:s}=o;if(s){let r=0;for(let a=0;a<=s.length;a++)r=ri(e,r,n,t,s[a-1],s[a],a===0?he:ni),i.push(r);return i.pop(),{positions:e,holeIndices:i}}o=n}if(!Cs(o))return ri(e,0,o,t,0,e.length,he),e;if(!Ls(o)){let n=0;for(let[s,r]of o.entries())n=si(e,n,r,t,s===0?he:ni),i.push(n);return i.pop(),{positions:e,holeIndices:i}}return si(e,0,o,t,he),e}function je(o,t,e){let i=o.length/3,n=0;for(let s=0;s<i;s++){let r=(s+1)%i;n+=o[s*3+t]*o[r*3+e],n-=o[r*3+t]*o[s*3+e]}return Math.abs(n/2)}function ai(o,t,e,i){let n=o.length/3;for(let s=0;s<n;s++){let r=s*3,a=o[r+0],l=o[r+1],c=o[r+2];o[r+t]=a,o[r+e]=l,o[r+i]=c}}function ci(o,t,e,i){let n=Rt(o);n&&(n=n.map(a=>a/t));let s=ft(o),r=i&&t===3;if(e){let a=s.length;s=s.slice();let l=[];for(let c=0;c<a;c+=t){l[0]=s[c],l[1]=s[c+1],r&&(l[2]=s[c+2]);let u=e(l);s[c]=u[0],s[c+1]=u[1],r&&(s[c+2]=u[2])}}if(r){let a=je(s,0,1),l=je(s,0,2),c=je(s,1,2);if(!a&&!l&&!c)return[];a>l&&a>c||(l>c?(e||(s=s.slice()),ai(s,0,2,1)):(e||(s=s.slice()),ai(s,2,0,1)))}return(0,li.default)(s,n,t)}var di=P(L(),1);var Ft=class extends di.Tesselator{constructor(t){let{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint16Array,size:1},indices:{type:i,size:1}}})}get(t){let{attributes:e}=this;return t==="indices"?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);let e=this.buffers.indices;if(e)this.vertexCount=(e.value||e).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(t){if(this.normalize){let e=me(t,this.positionSize);return this.opts.resolution?Tt(ft(e),Rt(e),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?Fe(ft(e),Rt(e),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):e}return t}getGeometrySize(t){if(fi(t)){let e=0;for(let i of t)e+=this.getGeometrySize(i);return e}return ft(t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):null}updateGeometryAttributes(t,e){if(t&&fi(t))for(let i of t){let n=this.getGeometrySize(i);e.geometrySize=n,this.updateGeometryAttributes(i,e),e.vertexStart+=n,e.indexStart=this.indexStarts[e.geometryIndex+1]}else{let i=t;this._updateIndices(i,e),this._updatePositions(i,e),this._updateVertexValid(i,e)}}_updateIndices(t,{geometryIndex:e,vertexStart:i,indexStart:n}){let{attributes:s,indexStarts:r,typedArrayManager:a}=this,l=s.indices;if(!l||!t)return;let c=n,u=ci(t,this.positionSize,this.opts.preproject,this.opts.full3d);l=a.allocate(l,n+u.length,{copy:!0});for(let f=0;f<u.length;f++)l[c++]=u[f]+i;r[e+1]=n+u.length,s.indices=l}_updatePositions(t,{vertexStart:e,geometrySize:i}){let{attributes:{positions:n},positionSize:s}=this;if(!n||!t)return;let r=ft(t);for(let a=e,l=0;l<i;a++,l++){let c=r[l*s],u=r[l*s+1],f=s>2?r[l*s+2]:0;n[a*3]=c,n[a*3+1]=u,n[a*3+2]=f}}_updateVertexValid(t,{vertexStart:e,geometrySize:i}){let{positionSize:n}=this,s=this.attributes.vertexValid,r=t&&Rt(t);if(t&&t.edgeTypes?s.set(t.edgeTypes,e):s.fill(1,e,e+i),r)for(let a=0;a<r.length;a++)s[e+r[a]/n-1]=0;s[e+i-1]=0}};function fi(o){return Array.isArray(o)&&o.length>0&&!Number.isFinite(o[0])}var xe=`uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;
out vec4 vColor;
struct PolygonProps {
vec4 fillColors;
vec4 lineColors;
vec3 positions;
vec3 positions64Low;
vec3 pickingColors;
vec3 normal;
float elevations;
};
vec3 project_offset_normal(vec3 vector) {
if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {
return normalize(vector * project_uCommonUnitsPerWorldUnit);
}
return project_normal(vector);
}
void calculatePosition(PolygonProps props) {
vec3 pos = props.positions;
vec3 pos64Low = props.positions64Low;
vec3 normal = props.normal;
vec4 colors = isWireframe ? props.lineColors : props.fillColors;
geometry.worldPosition = props.positions;
geometry.pickingColor = props.pickingColors;
if (extruded) {
pos.z += props.elevations * elevationScale;
}
gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (extruded) {
#ifdef IS_SIDE_VERTEX
normal = project_offset_normal(normal);
#else
normal = project_normal(normal);
#endif
geometry.normal = normal;
vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, colors.a * opacity);
} else {
vColor = vec4(colors.rgb, colors.a * opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var gi=`#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader
in vec3 vertexPositions;
in vec3 vertexPositions64Low;
in float elevations;
in vec4 fillColors;
in vec4 lineColors;
in vec3 pickingColors;
${xe}
void main(void) {
PolygonProps props;
props.positions = vertexPositions;
props.positions64Low = vertexPositions64Low;
props.elevations = elevations;
props.fillColors = fillColors;
props.lineColors = lineColors;
props.pickingColors = pickingColors;
props.normal = vec3(0.0, 0.0, 1.0);
calculatePosition(props);
}
`;var pi=`#version 300 es
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX
in vec2 positions;
in vec3 instancePositions;
in vec3 instanceNextPositions;
in vec3 instancePositions64Low;
in vec3 instanceNextPositions64Low;
in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
in float instanceVertexValid;
${xe}
void main(void) {
if(instanceVertexValid < 0.5){
gl_Position = vec4(0.);
return;
}
PolygonProps props;
vec3 pos;
vec3 pos64Low;
vec3 nextPos;
vec3 nextPos64Low;
#if RING_WINDING_ORDER_CW == 1
pos = instancePositions;
pos64Low = instancePositions64Low;
nextPos = instanceNextPositions;
nextPos64Low = instanceNextPositions64Low;
#else
pos = instanceNextPositions;
pos64Low = instanceNextPositions64Low;
nextPos = instancePositions;
nextPos64Low = instancePositions64Low;
#endif
props.positions = mix(pos, nextPos, positions.x);
props.positions64Low = mix(pos64Low, nextPos64Low, positions.x);
props.normal = vec3(
pos.y - nextPos.y + (pos64Low.y - nextPos64Low.y),
nextPos.x - pos.x + (nextPos64Low.x - pos64Low.x),
0.0);
props.elevations = instanceElevations * positions.y;
props.fillColors = instanceFillColors;
props.lineColors = instanceLineColors;
props.pickingColors = instancePickingColors;
calculatePosition(props);
}
`;var hi=`#version 300 es
#define SHADER_NAME solid-polygon-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ve=[0,0,0,255],Ms={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:o=>o.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:ve},getLineColor:{type:"accessor",value:ve},material:!0},ye={enter:(o,t)=>t.length?t.subarray(t.length-o.length):o},Pe=class extends z.Layer{getShaders(t){return super.getShaders({vs:t==="top"?gi:pi,fs:hi,defines:{RING_WINDING_ORDER_CW:!this.props._normalize&&this.props._windingOrder==="CCW"?0:1},modules:[z.project32,z.gouraudLighting,z.picking]})}get wrapLongitude(){return!1}getBounds(){return this.getAttributeManager()?.getBounds(["vertexPositions"])}initializeState(){let{viewport:t}=this.context,{coordinateSystem:e}=this.props,{_full3d:i}=this.props;t.isGeospatial&&e===z.COORDINATE_SYSTEM.DEFAULT&&(e=z.COORDINATE_SYSTEM.LNGLAT);let n;e===z.COORDINATE_SYSTEM.LNGLAT&&(i?n=t.projectPosition.bind(t):n=t.projectFlat.bind(t)),this.setState({numInstances:0,polygonTesselator:new Ft({preproject:n,fp64:this.use64bitPositions(),IndexType:Uint32Array})});let s=this.getAttributeManager(),r=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},vertexPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:ye,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{instancePositions:{vertexOffset:0,divisor:1},instanceNextPositions:{vertexOffset:1,divisor:1}}},instanceVertexValid:{size:1,type:"uint16",divisor:1,update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,transition:ye,accessor:"getElevation",shaderAttributes:{instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:"unorm8",transition:ye,accessor:"getFillColor",defaultValue:ve,shaderAttributes:{instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:"unorm8",transition:ye,accessor:"getLineColor",defaultValue:ve,shaderAttributes:{instanceLineColors:{divisor:1}}},pickingColors:{size:4,type:"uint8",accessor:(a,{index:l,target:c})=>this.encodePickingColor(a&&a.__source?a.__source.index:l,c),shaderAttributes:{instancePickingColors:{divisor:1}}}})}getPickingInfo(t){let e=super.getPickingInfo(t),{index:i}=e,n=this.props.data;return n[0]&&n[0].__source&&(e.object=n.find(s=>s.__source.index===i)),e}disablePickingIndex(t){let e=this.props.data;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else super.disablePickingIndex(t)}draw({uniforms:t}){let{extruded:e,filled:i,wireframe:n,elevationScale:s}=this.props,{topModel:r,sideModel:a,wireframeModel:l,polygonTesselator:c}=this.state,u={...t,extruded:Boolean(e),elevationScale:s};l&&n&&(l.setInstanceCount(c.instanceCount-1),l.setUniforms(u),l.draw(this.context.renderPass)),a&&i&&(a.setInstanceCount(c.instanceCount-1),a.setUniforms(u),a.draw(this.context.renderPass)),r&&i&&(r.setVertexCount(c.vertexCount),r.setUniforms(u),r.draw(this.context.renderPass))}updateState(t){super.updateState(t),this.updateGeometry(t);let{props:e,oldProps:i,changeFlags:n}=t,s=this.getAttributeManager();(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(this.state.models?.forEach(a=>a.destroy()),this.setState(this._getModels()),s.invalidateAll())}updateGeometry({props:t,oldProps:e,changeFlags:i}){if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPolygon)){let{polygonTesselator:s}=this.state,r=t.data.attributes||{};s.updateGeometry({data:t.data,normalize:t._normalize,geometryBuffer:r.getPolygon,buffers:r,getGeometry:t.getPolygon,positionFormat:t.positionFormat,wrapLongitude:t.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:i.dataChanged,full3d:t._full3d}),this.setState({numInstances:s.instanceCount,startIndices:s.vertexStarts}),i.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(){let{id:t,filled:e,extruded:i}=this.props,n,s,r,a=this.getAttributeManager().getBufferLayouts();if(e){let l=this.getShaders("top");l.defines.NON_INSTANCED_MODEL=1,n=new ot.Model(this.context.device,{...l,id:`${t}-top`,topology:"triangle-list",uniforms:{isWireframe:!1},bufferLayout:a,isIndexed:!0,userData:{excludeAttributes:{instanceVertexValid:!0}}})}return i&&(s=new ot.Model(this.context.device,{...this.getShaders("side"),id:`${t}-side`,bufferLayout:a,uniforms:{isWireframe:!1},geometry:new ot.Geometry({topology:"triangle-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,1,1,0,1])}}}),isInstanced:1,userData:{excludeAttributes:{indices:!0}}}),r=new ot.Model(this.context.device,{...this.getShaders("side"),id:`${t}-wireframe`,bufferLayout:a,uniforms:{isWireframe:!0},geometry:new ot.Geometry({topology:"line-strip",attributes:{positions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),isInstanced:1,userData:{excludeAttributes:{indices:!0}}})),{models:[s,r,n].filter(Boolean),topModel:n,sideModel:s,wireframeModel:r}}calculateIndices(t){let{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){let{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}},B=Pe;(()=>{Pe.defaultProps=Ms})(),(()=>{Pe.layerName="SolidPolygonLayer"})();function _e({data:o,getIndex:t,dataRange:e,replace:i}){let{startRow:n=0,endRow:s=1/0}=e,r=o.length,a=r,l=r;for(let d=0;d<r;d++){let g=t(o[d]);if(a>d&&g>=n&&(a=d),g>=s){l=d;break}}let c=a,f=l-a!==i.length?o.slice(l):void 0;for(let d=0;d<i.length;d++)o[c++]=i[d];if(f){for(let d=0;d<f.length;d++)o[c++]=f[d];o.length=c}return{startRow:a,endRow:a+i.length}}var mi=[0,0,0,255],Ts=[0,0,0,255],Is={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:o=>o.polygon},getFillColor:{type:"accessor",value:Ts},getLineColor:{type:"accessor",value:mi},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0},Ce=class extends dt.CompositeLayer{initializeState(){this.state={paths:[],pathsDiff:null},this.props.getLineDashArray&&dt.log.removed("getLineDashArray","PathStyleExtension")()}updateState({changeFlags:t}){let e=t.dataChanged||t.updateTriggersChanged&&(t.updateTriggersChanged.all||t.updateTriggersChanged.getPolygon);if(e&&Array.isArray(t.dataChanged)){let i=this.state.paths.slice(),n=t.dataChanged.map(s=>_e({data:i,getIndex:r=>r.__source.index,dataRange:s,replace:this._getPaths(s)}));this.setState({paths:i,pathsDiff:n})}else e&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(t={}){let{data:e,getPolygon:i,positionFormat:n,_normalize:s}=this.props,r=[],a=n==="XY"?2:3,{startRow:l,endRow:c}=t,{iterable:u,objectInfo:f}=(0,dt.createIterable)(e,l,c);for(let d of u){f.index++;let g=i(d,f);s&&(g=me(g,a));let{holeIndices:p}=g,h=g.positions||g;if(p)for(let m=0;m<=p.length;m++){let y=h.slice(p[m-1]||0,p[m]||h.length);r.push(this.getSubLayerRow({path:y},d,f.index))}else r.push(this.getSubLayerRow({path:h},d,f.index))}return r}renderLayers(){let{data:t,_dataDiff:e,stroked:i,filled:n,extruded:s,wireframe:r,_normalize:a,_windingOrder:l,elevationScale:c,transitions:u,positionFormat:f}=this.props,{lineWidthUnits:d,lineWidthScale:g,lineWidthMinPixels:p,lineWidthMaxPixels:h,lineJointRounded:m,lineMiterLimit:y,lineDashJustified:_}=this.props,{getFillColor:x,getLineColor:v,getLineWidth:C,getLineDashArray:M,getElevation:N,getPolygon:O,updateTriggers:T,material:jt}=this.props,{paths:at,pathsDiff:E}=this.state,w=this.getSubLayerClass("fill",B),be=this.getSubLayerClass("stroke",G),Vt=this.shouldRenderSubLayer("fill",at)&&new w({_dataDiff:e,extruded:s,elevationScale:c,filled:n,wireframe:r,_normalize:a,_windingOrder:l,getElevation:N,getFillColor:x,getLineColor:s&&r?v:mi,material:jt,transitions:u},this.getSubLayerProps({id:"fill",updateTriggers:T&&{getPolygon:T.getPolygon,getElevation:T.getElevation,getFillColor:T.getFillColor,lineColors:s&&r,getLineColor:T.getLineColor}}),{data:t,positionFormat:f,getPolygon:O}),Xi=!s&&i&&this.shouldRenderSubLayer("stroke",at)&&new be({_dataDiff:E&&(()=>E),widthUnits:d,widthScale:g,widthMinPixels:p,widthMaxPixels:h,jointRounded:m,miterLimit:y,dashJustified:_,_pathType:"loop",transitions:u&&{getWidth:u.getLineWidth,getColor:u.getLineColor,getPath:u.getPolygon},getColor:this.getSubLayerAccessor(v),getWidth:this.getSubLayerAccessor(C),getDashArray:this.getSubLayerAccessor(M)},this.getSubLayerProps({id:"stroke",updateTriggers:T&&{getWidth:T.getLineWidth,getColor:T.getLineColor,getDashArray:T.getLineDashArray}}),{data:at,positionFormat:f,getPath:Yi=>Yi.path});return[!s&&Vt,Xi,s&&Vt]}},Dt=Ce;(()=>{Ce.layerName="PolygonLayer"})(),(()=>{Ce.defaultProps=Is})();var $i=P(L(),1);function xi(o,t){if(!o)return null;let e="startIndices"in o?o.startIndices[t]:t,i=o.featureIds.value[e];return e!==-1?Es(o,i,e):null}function Es(o,t,e){let i={properties:{...o.properties[t]}};for(let n in o.numericProps)i.properties[n]=o.numericProps[n].value[e];return i}function yi(o,t){let e={points:null,lines:null,polygons:null};for(let i in e){let n=o[i].globalFeatureIds.value;e[i]=new Uint8ClampedArray(n.length*3);let s=[];for(let r=0;r<n.length;r++)t(n[r],s),e[i][r*3+0]=s[0],e[i][r*3+1]=s[1],e[i][r*3+2]=s[2]}return e}var pt=P(L(),1);var _i=P(L(),1);var vi=`#version 300 es
#define SHADER_NAME multi-icon-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D iconsTexture;
uniform float gamma;
uniform bool sdf;
uniform float alphaCutoff;
uniform float sdfBuffer;
uniform float outlineBuffer;
uniform vec4 outlineColor;
in vec4 vColor;
in vec2 vTextureCoords;
in vec2 uv;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
if (!bool(picking.isActive)) {
float alpha = texture(iconsTexture, vTextureCoords).a;
vec4 color = vColor;
if (sdf) {
float distance = alpha;
alpha = smoothstep(sdfBuffer - gamma, sdfBuffer + gamma, distance);
if (outlineBuffer > 0.0) {
float inFill = alpha;
float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);
color = mix(outlineColor, vColor, inFill);
alpha = inBorder;
}
}
float a = alpha * color.a;
if (a < alphaCutoff) {
discard;
}
fragColor = vec4(color.rgb, a * opacity);
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Ve=192/256,Pi=[],As={getIconOffsets:{type:"accessor",value:o=>o.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}},Le=class extends W{getShaders(){return{...super.getShaders(),fs:vi}}initializeState(){super.initializeState(),this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:"uint8",size:3,accessor:(e,{index:i,target:n})=>this.encodePickingColor(i,n)}})}updateState(t){super.updateState(t);let{props:e,oldProps:i}=t,{outlineColor:n}=e;n!==i.outlineColor&&(n=n.map(s=>s/255),n[3]=Number.isFinite(n[3])?n[3]:1,this.setState({outlineColor:n})),!e.sdf&&e.outlineWidth&&_i.log.warn(`${this.id}: fontSettings.sdf is required to render outline`)()}draw(t){let{sdf:e,smoothing:i,outlineWidth:n}=this.props,{outlineColor:s}=this.state,r=n?Math.max(i,Ve*(1-n)):-1;if(t.uniforms={...t.uniforms,sdfBuffer:Ve,outlineBuffer:r,gamma:i,sdf:Boolean(e),outlineColor:s},super.draw(t),e&&n){let{iconManager:a}=this.state,l=a.getTexture(),c=this.state.model;l&&(c.setUniforms({outlineBuffer:Ve}),c.draw(this.context.renderPass))}}getInstanceOffset(t){return t?Array.from(t).flatMap(e=>super.getInstanceOffset(e)):Pi}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).flatMap(e=>super.getInstanceIconFrame(e)):Pi}},it=Le;(()=>{Le.defaultProps=As})(),(()=>{Le.layerName="MultiIconLayer"})();var Nt=class{constructor({fontSize:t=24,buffer:e=3,radius:i=8,cutoff:n=.25,fontFamily:s="sans-serif",fontWeight:r="normal",fontStyle:a="normal"}={}){this.buffer=e,this.cutoff=n,this.radius=i;let l=this.size=t+e*4,c=this._createCanvas(l),u=this.ctx=c.getContext("2d",{willReadFrequently:!0});u.font=`${a} ${r} ${t}px ${s}`,u.textBaseline="alphabetic",u.textAlign="left",u.fillStyle="black",this.gridOuter=new Float64Array(l*l),this.gridInner=new Float64Array(l*l),this.f=new Float64Array(l),this.z=new Float64Array(l+1),this.v=new Uint16Array(l)}_createCanvas(t){let e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){let{width:e,actualBoundingBoxAscent:i,actualBoundingBoxDescent:n,actualBoundingBoxLeft:s,actualBoundingBoxRight:r}=this.ctx.measureText(t),a=Math.ceil(i),l=0,c=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(r-s))),u=Math.min(this.size-this.buffer,a+Math.ceil(n)),f=c+2*this.buffer,d=u+2*this.buffer,g=Math.max(f*d,0),p=new Uint8ClampedArray(g),h={data:p,width:f,height:d,glyphWidth:c,glyphHeight:u,glyphTop:a,glyphLeft:l,glyphAdvance:e};if(c===0||u===0)return h;let{ctx:m,buffer:y,gridInner:_,gridOuter:x}=this;m.clearRect(y,y,c,u),m.fillText(t,y,y+a);let v=m.getImageData(y,y,c,u);x.fill(1e20,0,g),_.fill(0,0,g);for(let C=0;C<u;C++)for(let M=0;M<c;M++){let N=v.data[4*(C*c+M)+3]/255;if(N===0)continue;let O=(C+y)*f+M+y;if(N===1)x[O]=0,_[O]=1e20;else{let T=.5-N;x[O]=T>0?T*T:0,_[O]=T<0?T*T:0}}Ci(x,0,0,f,d,f,this.f,this.v,this.z),Ci(_,y,y,c,u,f,this.f,this.v,this.z);for(let C=0;C<g;C++){let M=Math.sqrt(x[C])-Math.sqrt(_[C]);p[C]=Math.round(255-255*(M/this.radius+this.cutoff))}return h}};function Ci(o,t,e,i,n,s,r,a,l){for(let c=t;c<t+i;c++)Li(o,e*s+c,s,n,r,a,l);for(let c=e;c<e+n;c++)Li(o,c*s+t,1,i,r,a,l)}function Li(o,t,e,i,n,s,r){s[0]=0,r[0]=-1e20,r[1]=1e20,n[0]=o[t];for(let a=1,l=0,c=0;a<i;a++){n[a]=o[t+a*e];let u=a*a;do{let f=s[l];c=(n[a]-n[f]+u-f*f)/(a-f)/2}while(c<=r[l]&&--l>-1);l++,s[l]=a,r[l]=c,r[l+1]=1e20}for(let a=0,l=0;a<i;a++){for(;r[l+1]<a;)l++;let c=s[l],u=a-c;o[t+a*e]=n[c]+u*u}}var Ri=P(L(),1);var Si=P(L(),1),bs=32,zs=[];function Os(o){return Math.pow(2,Math.ceil(Math.log2(o)))}function wi({characterSet:o,getFontWidth:t,fontHeight:e,buffer:i,maxCanvasWidth:n,mapping:s={},xOffset:r=0,yOffset:a=0}){let l=0,c=r,u=e+i*2;for(let f of o)if(!s[f]){let d=t(f);c+d+i*2>n&&(c=0,l++),s[f]={x:c+i,y:a+l*u+i,width:d,height:u,layoutWidth:d,layoutHeight:e},c+=d+i*2}return{mapping:s,xOffset:c,yOffset:a+l*u,canvasHeight:Os(a+(l+1)*u)}}function Mi(o,t,e,i){let n=0;for(let s=t;s<e;s++){let r=o[s];n+=i[r]?.layoutWidth||0}return n}function Ti(o,t,e,i,n,s){let r=t,a=0;for(let l=t;l<e;l++){let c=Mi(o,l,l+1,n);a+c>i&&(r<l&&s.push(l),r=l,a=0),a+=c}return a}function Rs(o,t,e,i,n,s){let r=t,a=t,l=t,c=0;for(let u=t;u<e;u++)if((o[u]===" "||o[u+1]===" "||u+1===e)&&(l=u+1),l>a){let f=Mi(o,a,l,n);c+f>i&&(r<a&&(s.push(a),r=a,c=0),f>i&&(f=Ti(o,a,l,i,n,s),r=s[s.length-1])),a=l,c+=f}return c}function Fs(o,t,e,i,n=0,s){s===void 0&&(s=o.length);let r=[];return t==="break-all"?Ti(o,n,s,e,i,r):Rs(o,n,s,e,i,r),r}function Ds(o,t,e,i,n,s){let r=0,a=0;for(let l=t;l<e;l++){let c=o[l],u=i[c];u?(a||(a=u.layoutHeight),n[l]=r+u.layoutWidth/2,r+=u.layoutWidth):(Si.log.warn(`Missing character: ${c} (${c.codePointAt(0)})`)(),n[l]=r,r+=bs)}s[0]=r,s[1]=a}function Ii(o,t,e,i,n){let s=Array.from(o),r=s.length,a=new Array(r),l=new Array(r),c=new Array(r),u=(e==="break-word"||e==="break-all")&&isFinite(i)&&i>0,f=[0,0],d=[0,0],g=0,p=0,h=0;for(let m=0;m<=r;m++){let y=s[m];if((y===`
`||m===r)&&(h=m),h>p){let _=u?Fs(s,e,i,n,p,h):zs;for(let x=0;x<=_.length;x++){let v=x===0?p:_[x-1],C=x<_.length?_[x]:h;Ds(s,v,C,n,a,d);for(let M=v;M<C;M++){let N=s[M],O=n[N]?.layoutOffsetY||0;l[M]=g+d[1]/2+O,c[M]=d[0]}g=g+d[1]*t,f[0]=Math.max(f[0],d[0])}p=h}y===`
`&&(a[p]=0,l[p]=0,c[p]=0,p++)}return f[1]=g,{x:a,y:l,rowWidth:c,size:f}}function Ei({value:o,length:t,stride:e,offset:i,startIndices:n,characterSet:s}){let r=o.BYTES_PER_ELEMENT,a=e?e/r:1,l=i?i/r:0,c=n[t]||Math.ceil((o.length-l)/a),u=s&&new Set,f=new Array(t),d=o;if(a>1||l>0){let g=o.constructor;d=new g(c);for(let p=0;p<c;p++)d[p]=o[p*a+l]}for(let g=0;g<t;g++){let p=n[g],h=n[g+1]||c,m=d.subarray(p,h);f[g]=String.fromCodePoint.apply(null,m),u&&m.forEach(u.add,u)}if(u)for(let g of u)s.add(String.fromCodePoint(g));return{texts:f,characterCount:c}}var gt=class{constructor(t=5){this._cache={},this._order=[],this.limit=t}get(t){let e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(delete this._cache[t],this._deleteOrder(t))}_deleteOrder(t){let e=this._order.indexOf(t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}};function Ns(){let o=[];for(let t=32;t<128;t++)o.push(String.fromCharCode(t));return o}var nt={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:Ns(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},Ai=1024,bi=.9,zi=1.2,Fi=3,Se=new gt(Fi);function ks(o,t){let e;typeof t=="string"?e=new Set(Array.from(t)):e=new Set(t);let i=Se.get(o);if(!i)return e;for(let n in i.mapping)e.has(n)&&e.delete(n);return e}function Ws(o,t){for(let e=0;e<o.length;e++)t.data[4*e+3]=o[e]}function Oi(o,t,e,i){o.font=`${i} ${e}px ${t}`,o.fillStyle="#000",o.textBaseline="alphabetic",o.textAlign="left"}function Di(o){Ri.log.assert(Number.isFinite(o)&&o>=Fi,"Invalid cache limit"),Se=new gt(o)}var kt=class{constructor(){this.props={...nt}}get atlas(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){let{fontSize:t,buffer:e}=this.props;return(t*zi+e*2)/t}setProps(t={}){Object.assign(this.props,t),this._key=this._getKey();let e=ks(this._key,this.props.characterSet),i=Se.get(this._key);if(i&&e.size===0){this._atlas!==i&&(this._atlas=i);return}let n=this._generateFontAtlas(e,i);this._atlas=n,Se.set(this._key,n)}_generateFontAtlas(t,e){let{fontFamily:i,fontWeight:n,fontSize:s,buffer:r,sdf:a,radius:l,cutoff:c}=this.props,u=e&&e.data;u||(u=document.createElement("canvas"),u.width=Ai);let f=u.getContext("2d",{willReadFrequently:!0});Oi(f,i,s,n);let{mapping:d,canvasHeight:g,xOffset:p,yOffset:h}=wi({getFontWidth:m=>f.measureText(m).width,fontHeight:s*zi,buffer:r,characterSet:t,maxCanvasWidth:Ai,...e&&{mapping:e.mapping,xOffset:e.xOffset,yOffset:e.yOffset}});if(u.height!==g){let m=f.getImageData(0,0,u.width,u.height);u.height=g,f.putImageData(m,0,0)}if(Oi(f,i,s,n),a){let m=new Nt({fontSize:s,buffer:r,radius:l,cutoff:c,fontFamily:i,fontWeight:`${n}`});for(let y of t){let{data:_,width:x,height:v,glyphTop:C}=m.draw(y);d[y].width=x,d[y].layoutOffsetY=s*bi-C;let M=f.createImageData(x,v);Ws(_,M),f.putImageData(M,d[y].x,d[y].y)}}else for(let m of t)f.fillText(m,d[m].x,d[m].y+r+s*bi);return{xOffset:p,yOffset:h,mapping:d,data:u,width:u.width,height:u.height}}_getKey(){let{fontFamily:t,fontWeight:e,fontSize:i,buffer:n,sdf:s,radius:r,cutoff:a}=this.props;return s?`${t} ${e} ${i} ${n} ${r} ${a}`:`${t} ${e} ${i} ${n}`}};var X=P(L(),1),Wi=P(I(),1),Ui=P(I(),1);var Ni=`#version 300 es
#define SHADER_NAME text-background-layer-vertex-shader
in vec2 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceRects;
in float instanceSizes;
in float instanceAngles;
in vec2 instancePixelOffsets;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
uniform bool billboard;
uniform float opacity;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec4 padding;
uniform int sizeUnits;
out vec4 vFillColor;
out vec4 vLineColor;
out float vLineWidth;
out vec2 uv;
out vec2 dimensions;
vec2 rotate_by_angle(vec2 vertex, float angle) {
float angle_radian = radians(angle);
float cos_angle = cos(angle_radian);
float sin_angle = sin(angle_radian);
mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
return rotationMatrix * vertex;
}
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = positions;
geometry.pickingColor = instancePickingColors;
uv = positions;
vLineWidth = instanceLineWidths;
float sizePixels = clamp(
project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),
sizeMinPixels, sizeMaxPixels
);
dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;
vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);
pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);
pixelOffset += instancePixelOffsets;
pixelOffset.y *= -1.0;
if (billboard)  {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = vec3(pixelOffset, 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
DECKGL_FILTER_SIZE(offset_common, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`;var ki=`#version 300 es
#define SHADER_NAME text-background-layer-fragment-shader
precision highp float;
uniform bool stroked;
in vec4 vFillColor;
in vec4 vLineColor;
in float vLineWidth;
in vec2 uv;
in vec2 dimensions;
out vec4 fragColor;
void main(void) {
geometry.uv = uv;
vec2 pixelPosition = uv * dimensions;
if (stroked) {
float distToEdge = min(
min(pixelPosition.x, dimensions.x - pixelPosition.x),
min(pixelPosition.y, dimensions.y - pixelPosition.y)
);
float isBorder = smoothedge(distToEdge, vLineWidth);
fragColor = mix(vFillColor, vLineColor, isBorder);
} else {
fragColor = vFillColor;
}
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Us={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:o=>o.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}},we=class extends X.Layer{getShaders(){return super.getShaders({vs:Ni,fs:ki,modules:[X.project32,X.picking]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,type:"unorm8",accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,type:"unorm8",accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t);let{changeFlags:e}=t;e.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){let{billboard:e,sizeScale:i,sizeUnits:n,sizeMinPixels:s,sizeMaxPixels:r,getLineWidth:a}=this.props,{padding:l}=this.props;l.length<4&&(l=[l[0],l[1],l[0],l[1]]);let c=this.state.model;c.setUniforms(t),c.setUniforms({billboard:e,stroked:Boolean(a),padding:l,sizeUnits:X.UNIT[n],sizeScale:i,sizeMinPixels:s,sizeMaxPixels:r}),c.draw(this.context.renderPass)}_getModel(){let t=[0,0,1,0,1,1,0,1];return new Ui.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Wi.Geometry({topology:"triangle-fan-webgl",vertexCount:4,attributes:{positions:{size:2,value:new Float32Array(t)}}}),isInstanced:!0})}},st=we;(()=>{we.defaultProps=Us})(),(()=>{we.layerName="TextBackgroundLayer"})();var Gi={start:1,middle:0,end:-1},Bi={top:1,center:0,bottom:-1},Ze=[0,0,0,255],Gs=1,Bs={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:Ze},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:nt.characterSet},fontFamily:nt.fontFamily,fontWeight:nt.fontWeight,lineHeight:Gs,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:Ze},fontSettings:{type:"object",value:{},compare:1},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:o=>o.text},getPosition:{type:"accessor",value:o=>o.position},getColor:{type:"accessor",value:Ze},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}},Me=class extends pt.CompositeLayer{constructor(){super(...arguments),this.getBoundingRect=(t,e)=>{let{size:[i,n]}=this.transformParagraph(t,e),{fontSize:s}=this.state.fontAtlasManager.props;i/=s,n/=s;let{getTextAnchor:r,getAlignmentBaseline:a}=this.props,l=Gi[typeof r=="function"?r(t,e):r],c=Bi[typeof a=="function"?a(t,e):a];return[(l-1)*i/2,(c-1)*n/2,i,n]},this.getIconOffsets=(t,e)=>{let{getTextAnchor:i,getAlignmentBaseline:n}=this.props,{x:s,y:r,rowWidth:a,size:[l,c]}=this.transformParagraph(t,e),u=Gi[typeof i=="function"?i(t,e):i],f=Bi[typeof n=="function"?n(t,e):n],d=s.length,g=new Array(d*2),p=0;for(let h=0;h<d;h++){let m=(1-u)*(l-a[h])/2;g[p++]=(u-1)*l/2+m+s[h],g[p++]=(f-1)*c/2+r[h]}return g}}initializeState(){this.state={styleVersion:0,fontAtlasManager:new kt},this.props.maxWidth>0&&pt.log.warn("v8.9 breaking change: TextLayer maxWidth is now relative to text size")()}updateState(t){let{props:e,oldProps:i,changeFlags:n}=t;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText(),(this._updateFontAtlas()||e.lineHeight!==i.lineHeight||e.wordBreak!==i.wordBreak||e.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo({info:t}){return t.object=t.index>=0?this.props.data[t.index]:null,t}_updateFontAtlas(){let{fontSettings:t,fontFamily:e,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:s}=this.state,r={...t,characterSet:s,fontFamily:e,fontWeight:i};if(!n.mapping)return n.setProps(r),!0;for(let a in r)if(r[a]!==n.props[a])return n.setProps(r),!0;return!1}_updateText(){let{data:t,characterSet:e}=this.props,i=t.attributes?.getText,{getText:n}=this.props,s=t.startIndices,r,a=e==="auto"&&new Set;if(i&&s){let{texts:l,characterCount:c}=Ei({...ArrayBuffer.isView(i)?{value:i}:i,length:t.length,startIndices:s,characterSet:a});r=c,n=(u,{index:f})=>l[f]}else{let{iterable:l,objectInfo:c}=(0,pt.createIterable)(t);s=[0],r=0;for(let u of l){c.index++;let f=Array.from(n(u,c)||"");a&&f.forEach(a.add,a),r+=f.length,s.push(r)}}this.setState({getText:n,startIndices:s,numInstances:r,characterSet:a||e})}transformParagraph(t,e){let{fontAtlasManager:i}=this.state,n=i.mapping,s=this.state.getText,{wordBreak:r,lineHeight:a,maxWidth:l}=this.props,c=s(t,e)||"";return Ii(c,a,r,l*i.props.fontSize,n)}renderLayers(){let{startIndices:t,numInstances:e,getText:i,fontAtlasManager:{scale:n,atlas:s,mapping:r},styleVersion:a}=this.state,{data:l,_dataDiff:c,getPosition:u,getColor:f,getSize:d,getAngle:g,getPixelOffset:p,getBackgroundColor:h,getBorderColor:m,getBorderWidth:y,backgroundPadding:_,background:x,billboard:v,fontSettings:C,outlineWidth:M,outlineColor:N,sizeScale:O,sizeUnits:T,sizeMinPixels:jt,sizeMaxPixels:at,transitions:E,updateTriggers:w}=this.props,be=this.getSubLayerClass("characters",it),Vt=this.getSubLayerClass("background",st);return[x&&new Vt({getFillColor:h,getLineColor:m,getLineWidth:y,padding:_,getPosition:u,getSize:d,getAngle:g,getPixelOffset:p,billboard:v,sizeScale:O,sizeUnits:T,sizeMinPixels:jt,sizeMaxPixels:at,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getSize:E.getSize,getFillColor:E.getBackgroundColor,getLineColor:E.getBorderColor,getLineWidth:E.getBorderWidth,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:w.getPosition,getAngle:w.getAngle,getSize:w.getSize,getFillColor:w.getBackgroundColor,getLineColor:w.getBorderColor,getLineWidth:w.getBorderWidth,getPixelOffset:w.getPixelOffset,getBoundingRect:{getText:w.getText,getTextAnchor:w.getTextAnchor,getAlignmentBaseline:w.getAlignmentBaseline,styleVersion:a}}}),{data:l.attributes&&l.attributes.background?{length:l.length,attributes:l.attributes.background}:l,_dataDiff:c,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new be({sdf:C.sdf,smoothing:Number.isFinite(C.smoothing)?C.smoothing:nt.smoothing,outlineWidth:M/(C.radius||nt.radius),outlineColor:N,iconAtlas:s,iconMapping:r,getPosition:u,getColor:f,getSize:d,getAngle:g,getPixelOffset:p,billboard:v,sizeScale:O*n,sizeUnits:T,sizeMinPixels:jt*n,sizeMaxPixels:at*n,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getColor:E.getColor,getSize:E.getSize,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{all:w.getText,getPosition:w.getPosition,getAngle:w.getAngle,getColor:w.getColor,getSize:w.getSize,getPixelOffset:w.getPixelOffset,getIconOffsets:{getTextAnchor:w.getTextAnchor,getAlignmentBaseline:w.getAlignmentBaseline,styleVersion:a}}}),{data:l,_dataDiff:c,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(t){Di(t)}},rt=Me;(()=>{Me.defaultProps=Bs})(),(()=>{Me.layerName="TextLayer"})();var Wt={circle:{type:q,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:W,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:rt,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},Ut={type:G,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},Te={type:B,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function ht({type:o,props:t}){let e={};for(let i in t)e[i]=o.defaultProps[t[i]];return e}function Ie(o,t){let{transitions:e,updateTriggers:i}=o.props,n={updateTriggers:{},transitions:e&&{getPosition:e.geometry}};for(let s in t){let r=t[s],a=o.props[s];s.startsWith("get")&&(a=o.getSubLayerAccessor(a),n.updateTriggers[r]=i[s],e&&(n.transitions[r]=e[s])),n[r]=a}return n}var mt=P(L(),1);function Vi(o){if(Array.isArray(o))return o;switch(mt.log.assert(o.type,"GeoJSON does not have type"),o.type){case"Feature":return[o];case"FeatureCollection":return mt.log.assert(Array.isArray(o.features),"GeoJSON does not have features array"),o.features;default:return[{geometry:o}]}}function He(o,t,e={}){let i={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:n=0,endRow:s=o.length}=e;for(let r=n;r<s;r++){let a=o[r],{geometry:l}=a;if(l)if(l.type==="GeometryCollection"){mt.log.assert(Array.isArray(l.geometries),"GeoJSON does not have geometries array");let{geometries:c}=l;for(let u=0;u<c.length;u++){let f=c[u];ji(f,i,t,a,r)}}else ji(l,i,t,a,r)}return i}function ji(o,t,e,i,n){let{type:s,coordinates:r}=o,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:u}=t;if(!Vs(s,r)){mt.log.warn(`${s} coordinates are malformed`)();return}switch(s){case"Point":a.push(e({geometry:o},i,n));break;case"MultiPoint":r.forEach(f=>{a.push(e({geometry:{type:"Point",coordinates:f}},i,n))});break;case"LineString":l.push(e({geometry:o},i,n));break;case"MultiLineString":r.forEach(f=>{l.push(e({geometry:{type:"LineString",coordinates:f}},i,n))});break;case"Polygon":c.push(e({geometry:o},i,n)),r.forEach(f=>{u.push(e({geometry:{type:"LineString",coordinates:f}},i,n))});break;case"MultiPolygon":r.forEach(f=>{c.push(e({geometry:{type:"Polygon",coordinates:f}},i,n)),f.forEach(d=>{u.push(e({geometry:{type:"LineString",coordinates:d}},i,n))})});break;default:}}var js={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function Vs(o,t){let e=js[o];for(mt.log.assert(e,`Unknown GeoJSON type ${o}`);t&&--e>0;)t=t[0];return t&&Number.isFinite(t[0])}function Zi(){return{points:{},lines:{},polygons:{},polygonsOutline:{}}}function Ee(o){return o.geometry.coordinates}function Hi(o,t){let e=Zi(),{pointFeatures:i,lineFeatures:n,polygonFeatures:s,polygonOutlineFeatures:r}=o;return e.points.data=i,e.points._dataDiff=t.pointFeatures&&(()=>t.pointFeatures),e.points.getPosition=Ee,e.lines.data=n,e.lines._dataDiff=t.lineFeatures&&(()=>t.lineFeatures),e.lines.getPath=Ee,e.polygons.data=s,e.polygons._dataDiff=t.polygonFeatures&&(()=>t.polygonFeatures),e.polygons.getPolygon=Ee,e.polygonsOutline.data=r,e.polygonsOutline._dataDiff=t.polygonOutlineFeatures&&(()=>t.polygonOutlineFeatures),e.polygonsOutline.getPath=Ee,e}function Ki(o,t){let e=Zi(),{points:i,lines:n,polygons:s}=o,r=yi(o,t);return e.points.data={length:i.positions.value.length/i.positions.size,attributes:{...i.attributes,getPosition:i.positions,instancePickingColors:{size:3,value:r.points}},properties:i.properties,numericProps:i.numericProps,featureIds:i.featureIds},e.lines.data={length:n.pathIndices.value.length-1,startIndices:n.pathIndices.value,attributes:{...n.attributes,getPath:n.positions,instancePickingColors:{size:3,value:r.lines}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},e.lines._pathType="open",e.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},e.polygons._normalize=!1,s.triangles&&(e.polygons.data.attributes.indices=s.triangles.value),e.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},e.polygonsOutline._pathType="open",e}var Zs=["points","linestrings","polygons"],Hs={...ht(Wt.circle),...ht(Wt.icon),...ht(Wt.text),...ht(Ut),...ht(Te),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:o=>o.properties.icon},getText:{type:"accessor",value:o=>o.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}},Ae=class extends $i.CompositeLayer{initializeState(){this.state={layerProps:{},features:{},featuresDiff:{}}}updateState({props:t,changeFlags:e}){if(!e.dataChanged)return;let{data:i}=this.props,n=i&&"points"in i&&"polygons"in i&&"lines"in i;this.setState({binary:n}),n?this._updateStateBinary({props:t,changeFlags:e}):this._updateStateJSON({props:t,changeFlags:e})}_updateStateBinary({props:t,changeFlags:e}){let i=Ki(t.data,this.encodePickingColor);this.setState({layerProps:i})}_updateStateJSON({props:t,changeFlags:e}){let i=Vi(t.data),n=this.getSubLayerRow.bind(this),s={},r={};if(Array.isArray(e.dataChanged)){let l=this.state.features;for(let c in l)s[c]=l[c].slice(),r[c]=[];for(let c of e.dataChanged){let u=He(i,n,c);for(let f in l)r[f].push(_e({data:s[f],getIndex:d=>d.__source.index,dataRange:c,replace:u[f]}))}}else s=He(i,n);let a=Hi(s,r);this.setState({features:s,featuresDiff:r,layerProps:a})}getPickingInfo(t){let e=super.getPickingInfo(t),{index:i,sourceLayer:n}=e;return e.featureType=Zs.find(s=>n.id.startsWith(`${this.id}-${s}-`)),i>=0&&n.id.startsWith(`${this.id}-points-text`)&&this.state.binary&&(e.index=this.props.data.points.globalFeatureIds.value[i]),e}_updateAutoHighlight(t){let e=`${this.id}-points-`,i=t.featureType==="points";for(let n of this.getSubLayers())n.id.startsWith(e)===i&&n.updateAutoHighlight(t)}_renderPolygonLayer(){let{extruded:t,wireframe:e}=this.props,{layerProps:i}=this.state,n="polygons-fill",s=this.shouldRenderSubLayer(n,i.polygons?.data)&&this.getSubLayerClass(n,Te.type);if(s){let r=Ie(this,Te.props),a=t&&e;return a||delete r.getLineColor,r.updateTriggers.lineColors=a,new s(r,this.getSubLayerProps({id:n,updateTriggers:r.updateTriggers}),i.polygons)}return null}_renderLineLayers(){let{extruded:t,stroked:e}=this.props,{layerProps:i}=this.state,n="polygons-stroke",s="linestrings",r=!t&&e&&this.shouldRenderSubLayer(n,i.polygonsOutline?.data)&&this.getSubLayerClass(n,Ut.type),a=this.shouldRenderSubLayer(s,i.lines?.data)&&this.getSubLayerClass(s,Ut.type);if(r||a){let l=Ie(this,Ut.props);return[r&&new r(l,this.getSubLayerProps({id:n,updateTriggers:l.updateTriggers}),i.polygonsOutline),a&&new a(l,this.getSubLayerProps({id:s,updateTriggers:l.updateTriggers}),i.lines)]}return null}_renderPointLayers(){let{pointType:t}=this.props,{layerProps:e,binary:i}=this.state,{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=e.points.data.findIndex(a=>a.__source.index===n));let s=new Set(t.split("+")),r=[];for(let a of s){let l=`points-${a}`,c=Wt[a],u=c&&this.shouldRenderSubLayer(l,e.points?.data)&&this.getSubLayerClass(l,c.type);if(u){let f=Ie(this,c.props),d=e.points;if(a==="text"&&i){let{instancePickingColors:g,...p}=d.data.attributes;d={...d,data:{...d.data,attributes:p}}}r.push(new u(f,this.getSubLayerProps({id:l,updateTriggers:f.updateTriggers,highlightedObjectIndex:n}),d))}}return r}renderLayers(){let{extruded:t}=this.props,e=this._renderPolygonLayer(),i=this._renderLineLayers(),n=this._renderPointLayers();return[!t&&e,i,n,t&&e]}getSubLayerAccessor(t){let{binary:e}=this.state;return!e||typeof t!="function"?super.getSubLayerAccessor(t):(i,n)=>{let{data:s,index:r}=n,a=xi(s,r);return t(a,n)}}},Gt=Ae;(()=>{Ae.layerName="GeoJsonLayer"})(),(()=>{Ae.defaultProps=Hs})();return nn(Bt);})();
      return __exports__;
      });
