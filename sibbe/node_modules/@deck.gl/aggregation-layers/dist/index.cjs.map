{
  "version": 3,
  "sources": ["index.js", "screen-grid-layer/screen-grid-layer.js", "utils/gpu-grid-aggregation/gpu-grid-aggregator.js", "utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js", "utils/aggregation-operation-utils.js", "utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js", "utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js", "utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js", "utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js", "utils/gpu-grid-aggregation/transform-mean-vs.glsl.js", "utils/resource-utils.js", "screen-grid-layer/screen-grid-cell-layer.js", "utils/color-utils.js", "screen-grid-layer/screen-grid-layer-vertex.glsl.js", "screen-grid-layer/screen-grid-layer-fragment.glsl.js", "grid-aggregation-layer.js", "aggregation-layer.js", "utils/prop-utils.js", "utils/scale-utils.js", "utils/bin-sorter.js", "cpu-grid-layer/grid-aggregator.js", "utils/grid-aggregation-utils.js", "cpu-grid-layer/cpu-grid-layer.js", "utils/cpu-aggregator.js", "hexagon-layer/hexagon-layer.js", "hexagon-layer/hexagon-aggregator.js", "contour-layer/contour-layer.js", "contour-layer/marching-squares.js", "contour-layer/marching-squares-codes.js", "contour-layer/contour-utils.js", "grid-layer/grid-layer.js", "gpu-grid-layer/gpu-grid-layer.js", "gpu-grid-layer/gpu-grid-cell-layer.js", "gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js", "gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js", "heatmap-layer/heatmap-layer-utils.js", "heatmap-layer/heatmap-layer.js", "heatmap-layer/triangle-layer.js", "heatmap-layer/triangle-layer-vertex.glsl.js", "heatmap-layer/triangle-layer-fragment.glsl.js", "heatmap-layer/weights-vs.glsl.js", "heatmap-layer/weights-fs.glsl.js", "heatmap-layer/max-vs.glsl.js", "heatmap-layer/max-fs.glsl.js"],
  "sourcesContent": ["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport { default as ScreenGridLayer } from \"./screen-grid-layer/screen-grid-layer.js\";\nexport { default as CPUGridLayer } from \"./cpu-grid-layer/cpu-grid-layer.js\";\nexport { default as HexagonLayer } from \"./hexagon-layer/hexagon-layer.js\";\nexport { default as ContourLayer } from \"./contour-layer/contour-layer.js\";\nexport { default as GridLayer } from \"./grid-layer/grid-layer.js\";\nexport { default as GPUGridLayer } from \"./gpu-grid-layer/gpu-grid-layer.js\";\nexport { AGGREGATION_OPERATION } from \"./utils/aggregation-operation-utils.js\";\n// experimental export\nexport { default as HeatmapLayer } from \"./heatmap-layer/heatmap-layer.js\";\nexport { default as _GPUGridAggregator } from \"./utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nexport { default as _CPUAggregator } from \"./utils/cpu-aggregator.js\";\nexport { default as _AggregationLayer } from \"./aggregation-layer.js\";\nexport { default as _BinSorter } from \"./utils/bin-sorter.js\";\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from \"../utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nimport { AGGREGATION_OPERATION, getValueFunc } from \"../utils/aggregation-operation-utils.js\";\nimport ScreenGridCellLayer from \"./screen-grid-cell-layer.js\";\nimport GridAggregationLayer from \"../grid-aggregation-layer.js\";\nimport { getFloatTexture } from \"../utils/resource-utils.js\";\nconst defaultProps = {\n    ...ScreenGridCellLayer.defaultProps,\n    getPosition: { type: 'accessor', value: (d) => d.position },\n    getWeight: { type: 'accessor', value: 1 },\n    gpuAggregation: false, // TODO(v9): Re-enable GPU aggregation.\n    aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n    data: {\n        props: ['cellSizePixels']\n    },\n    weights: {\n        props: ['aggregation'],\n        accessors: ['getWeight']\n    }\n};\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer extends GridAggregationLayer {\n    static { this.layerName = 'ScreenGridLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        super.initializeAggregationLayer({\n            dimensions: DIMENSIONS,\n            // @ts-expect-error\n            getCellSize: props => props.cellSizePixels // TODO\n        });\n        const weights = {\n            count: {\n                size: 1,\n                operation: AGGREGATION_OPERATION.SUM,\n                needMax: true,\n                maxTexture: getFloatTexture(this.context.device, { id: `${this.id}-max-texture` })\n            }\n        };\n        this.setState({\n            supported: true,\n            projectPoints: true, // aggregation in screen space\n            weights,\n            subLayerData: { attributes: {} },\n            maxTexture: weights.count.maxTexture,\n            positionAttributeName: 'positions',\n            posOffset: [0, 0],\n            translation: [1, -1]\n        });\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            [POSITION_ATTRIBUTE_NAME]: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            // this attribute is used in gpu aggregation path only\n            count: { size: 3, accessor: 'getWeight' }\n        });\n    }\n    shouldUpdateState({ changeFlags }) {\n        return this.state.supported && changeFlags.somethingChanged;\n    }\n    updateState(opts) {\n        super.updateState(opts);\n    }\n    renderLayers() {\n        if (!this.state.supported) {\n            return [];\n        }\n        const { maxTexture, numRow, numCol, weights } = this.state;\n        const { updateTriggers } = this.props;\n        const { aggregationBuffer } = weights.count;\n        const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n        return new CellLayerClass(this.props, this.getSubLayerProps({\n            id: 'cell-layer',\n            updateTriggers\n        }), {\n            data: { attributes: { instanceCounts: aggregationBuffer } },\n            maxTexture,\n            numInstances: numRow * numCol\n        });\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        const { aggregationBuffer, maxBuffer, maxTexture } = this.state;\n        aggregationBuffer?.delete();\n        maxBuffer?.delete();\n        maxTexture?.delete();\n    }\n    getPickingInfo({ info }) {\n        const { index } = info;\n        if (index >= 0) {\n            const { gpuGridAggregator, gpuAggregation, weights } = this.state;\n            // Get count aggregation results\n            const aggregationResults = gpuAggregation\n                ? gpuGridAggregator.getData('count')\n                : weights.count;\n            // Each instance (one cell) is aggregated into single pixel,\n            // Get current instance's aggregation details.\n            info.object = GPUGridAggregator.getAggregationData({\n                pixelIndex: index,\n                ...aggregationResults\n            });\n        }\n        return info;\n    }\n    // Aggregation Overrides\n    updateResults({ aggregationData, maxData }) {\n        const { count } = this.state.weights;\n        count.aggregationData = aggregationData;\n        count.aggregationBuffer.write(aggregationData);\n        count.maxData = maxData;\n        count.maxTexture.setImageData({ data: maxData });\n    }\n    /* eslint-disable complexity, max-statements */\n    updateAggregationState(opts) {\n        const cellSize = opts.props.cellSizePixels;\n        const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n        const { viewportChanged } = opts.changeFlags;\n        let gpuAggregation = opts.props.gpuAggregation;\n        if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n            if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {\n                log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n                gpuAggregation = false;\n            }\n        }\n        const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n        this.setState({\n            gpuAggregation\n        });\n        const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n        const { dimensions } = this.state;\n        const { data, weights } = dimensions;\n        const aggregationDataDirty = positionsChanged ||\n            gpuAggregationChanged ||\n            viewportChanged ||\n            this.isAggregationDirty(opts, {\n                compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n                dimension: data\n            });\n        const aggregationWeightsDirty = this.isAggregationDirty(opts, { dimension: weights });\n        this.setState({\n            aggregationDataDirty,\n            aggregationWeightsDirty\n        });\n        const { viewport } = this.context;\n        if (viewportChanged || cellSizeChanged) {\n            const { width, height } = viewport;\n            const numCol = Math.ceil(width / cellSize);\n            const numRow = Math.ceil(height / cellSize);\n            this.allocateResources(numRow, numCol);\n            this.setState({\n                // transformation from clipspace to screen(pixel) space\n                scaling: [width / 2, -height / 2, 1],\n                gridOffset: { xOffset: cellSize, yOffset: cellSize },\n                width,\n                height,\n                numCol,\n                numRow\n            });\n        }\n        if (aggregationWeightsDirty) {\n            this._updateAccessors(opts);\n        }\n        if (aggregationDataDirty || aggregationWeightsDirty) {\n            this._resetResults();\n        }\n    }\n    /* eslint-enable complexity, max-statements */\n    // Private\n    _updateAccessors(opts) {\n        const { getWeight, aggregation, data } = opts.props;\n        const { count } = this.state.weights;\n        if (count) {\n            count.getWeight = getWeight;\n            count.operation = AGGREGATION_OPERATION[aggregation];\n        }\n        this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });\n    }\n    _resetResults() {\n        const { count } = this.state.weights;\n        if (count) {\n            count.aggregationData = null;\n        }\n    }\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Model, TextureTransform } from '@luma.gl/engine';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { GL } from '@luma.gl/constants';\nimport { project32, _mergeShaders as mergeShaders, getShaderAssembler } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from \"./gpu-grid-aggregator-constants.js\";\nimport { AGGREGATION_OPERATION } from \"../aggregation-operation-utils.js\";\nimport AGGREGATE_TO_GRID_VS from \"./aggregate-to-grid-vs.glsl.js\";\nimport AGGREGATE_TO_GRID_FS from \"./aggregate-to-grid-fs.glsl.js\";\nimport AGGREGATE_ALL_VS from \"./aggregate-all-vs.glsl.js\";\nimport AGGREGATE_ALL_FS from \"./aggregate-all-fs.glsl.js\";\nimport TRANSFORM_MEAN_VS from \"./transform-mean-vs.glsl.js\";\nimport { getFloatTexture, getFramebuffer } from \"./../resource-utils.js\";\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n    maxData: 'maxBuffer',\n    minData: 'minBuffer',\n    maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [\n    'float32-renderable-webgl',\n    'texture-blend-float-webgl'\n];\nexport default class GPUGridAggregator {\n    // Decode and return aggregation data of given pixel.\n    static getAggregationData({ aggregationData, maxData, minData, maxMinData, pixelIndex }) {\n        const index = pixelIndex * PIXEL_SIZE;\n        const results = {};\n        if (aggregationData) {\n            results.cellCount = aggregationData[index + 3];\n            results.cellWeight = aggregationData[index];\n        }\n        if (maxMinData) {\n            results.maxCellWieght = maxMinData[0];\n            results.minCellWeight = maxMinData[3];\n        }\n        else {\n            if (maxData) {\n                results.maxCellWieght = maxData[0];\n                results.totalCount = maxData[3];\n            }\n            if (minData) {\n                results.minCellWeight = minData[0];\n                results.totalCount = minData[3];\n            }\n        }\n        return results;\n    }\n    // Decodes and retuns counts and weights of all cells\n    static getCellData({ countsData, size = 1 }) {\n        const numCells = countsData.length / 4;\n        const cellWeights = new Float32Array(numCells * size);\n        const cellCounts = new Uint32Array(numCells);\n        for (let i = 0; i < numCells; i++) {\n            // weights in RGB channels\n            for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n                cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n            }\n            // count in Alpha channel\n            cellCounts[i] = countsData[i * 4 + 3];\n        }\n        return { cellCounts, cellWeights };\n    }\n    static isSupported(device) {\n        return REQUIRED_FEATURES.every(feature => device.features.has(feature));\n    }\n    constructor(device, props = {}) {\n        // DEBUG ONLY\n        // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n        //   if (aggregationBuffer) {\n        //     console.log('Aggregation Data:');\n        //     const agrData = aggregationBuffer.getData();\n        //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n        //       if (agrData[index + 3] > 0) {\n        //         console.log(\n        //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n        //             agrData[index + 2]\n        //           } count: ${agrData[index + 3]}`\n        //         );\n        //         limit--;\n        //       }\n        //     }\n        //   }\n        //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n        //   for (const key in obj) {\n        //     if (obj[key]) {\n        //       const data = obj[key].getData();\n        //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n        //     }\n        //   }\n        // }\n        this.state = {\n            // per weight GPU resources\n            weightAttributes: {},\n            textures: {},\n            meanTextures: {},\n            buffers: {},\n            framebuffers: {},\n            maxMinFramebuffers: {},\n            minFramebuffers: {},\n            maxFramebuffers: {},\n            equations: {},\n            shaderOptions: {},\n            modelDirty: false,\n            // common resources to be deleted\n            resources: {},\n            // results\n            results: {}\n        };\n        this.id = props.id || 'gpu-grid-aggregator';\n        this.device = device;\n        const REQUIRED_FEATURES = [\n            'float32-renderable-webgl' // render to float texture\n        ];\n        this._hasGPUSupport = REQUIRED_FEATURES.every(feature => device.features.has(feature));\n        if (this._hasGPUSupport) {\n            this._setupModels();\n        }\n    }\n    // Delete owned resources.\n    delete() {\n        const { gridAggregationModel, allAggregationModel, meanTransform } = this;\n        const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources } = this.state;\n        gridAggregationModel?.destroy();\n        allAggregationModel?.destroy();\n        meanTransform?.destroy();\n        deleteResources([\n            framebuffers,\n            textures,\n            maxMinFramebuffers,\n            minFramebuffers,\n            maxFramebuffers,\n            meanTextures,\n            resources\n        ]);\n    }\n    // Perform aggregation and retun the results\n    run(opts = {}) {\n        // reset results\n        this.setState({ results: {} });\n        const aggregationParams = this._normalizeAggregationParams(opts);\n        return this._runAggregation(aggregationParams);\n    }\n    // Reads aggregation data into JS Array object\n    // For WebGL1, data is available in JS Array objects already.\n    // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n    getData(weightId) {\n        const data = {};\n        const results = this.state.results;\n        if (!results[weightId].aggregationData) {\n            // cache the results if reading from the buffer (WebGL2 path)\n            results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n        }\n        data.aggregationData = results[weightId].aggregationData;\n        // Check for optional results\n        for (const arrayName in ARRAY_BUFFER_MAP) {\n            const bufferName = ARRAY_BUFFER_MAP[arrayName];\n            if (results[weightId][arrayName] || results[weightId][bufferName]) {\n                // cache the result\n                results[weightId][arrayName] =\n                    results[weightId][arrayName] || results[weightId][bufferName].getData();\n                data[arrayName] = results[weightId][arrayName];\n            }\n        }\n        return data;\n    }\n    updateShaders(shaderOptions = {}) {\n        this.setState({ shaderOptions, modelDirty: true });\n    }\n    // PRIVATE\n    _normalizeAggregationParams(opts) {\n        const aggregationParams = { ...DEFAULT_RUN_PARAMS, ...opts };\n        const { weights } = aggregationParams;\n        if (weights) {\n            aggregationParams.weights = normalizeWeightParams(weights);\n        }\n        return aggregationParams;\n    }\n    // Update priveate state\n    setState(updateObject) {\n        Object.assign(this.state, updateObject);\n    }\n    // GPU Aggregation methods\n    _getAggregateData(opts) {\n        const results = {};\n        const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, resources } = this.state;\n        const { weights } = opts;\n        for (const id in weights) {\n            results[id] = {};\n            const { needMin, needMax, combineMaxMin } = weights[id];\n            results[id].aggregationTexture = textures[id];\n            results[id].aggregationBuffer = this.device.readPixelsToBufferWebGL(framebuffers[id], {\n                target: weights[id].aggregationBuffer, // update if a buffer is provided\n                sourceType: 5126\n            });\n            if (needMin && needMax && combineMaxMin) {\n                results[id].maxMinBuffer = this.device.readPixelsToBufferWebGL(maxMinFramebuffers[id], {\n                    target: weights[id].maxMinBuffer, // update if a buffer is provided\n                    sourceType: 5126\n                });\n                results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n            }\n            else {\n                if (needMin) {\n                    results[id].minBuffer = this.device.readPixelsToBufferWebGL(minFramebuffers[id], {\n                        target: weights[id].minBuffer, // update if a buffer is provided\n                        sourceType: 5126\n                    });\n                    results[id].minTexture = resources[`${id}-minTexture`];\n                }\n                if (needMax) {\n                    results[id].maxBuffer = this.device.readPixelsToBufferWebGL(maxFramebuffers[id], {\n                        target: weights[id].maxBuffer, // update if a buffer is provided\n                        sourceType: 5126\n                    });\n                    results[id].maxTexture = resources[`${id}-maxTexture`];\n                }\n            }\n        }\n        this._trackGPUResultBuffers(results, weights);\n        return results;\n    }\n    _renderAggregateData(opts) {\n        const { cellSize, projectPoints, attributes, moduleSettings, numCol, numRow, weights, translation, scaling } = opts;\n        const { maxMinFramebuffers, minFramebuffers, maxFramebuffers } = this.state;\n        const gridSize = [numCol, numRow];\n        const parameters = {\n            blend: true,\n            depthTest: false,\n            blendFunc: [1, 1]\n        };\n        const uniforms = {\n            cellSize,\n            gridSize,\n            projectPoints,\n            translation,\n            scaling\n        };\n        for (const id in weights) {\n            const { needMin, needMax } = weights[id];\n            const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n            this._renderToWeightsTexture({\n                id,\n                parameters,\n                moduleSettings,\n                uniforms,\n                gridSize,\n                attributes,\n                weights\n            });\n            if (combineMaxMin) {\n                this._renderToMaxMinTexture({\n                    id,\n                    parameters: { ...parameters, blendEquation: MAX_MIN_BLEND_EQUATION },\n                    gridSize,\n                    minOrMaxFb: maxMinFramebuffers[id],\n                    clearParams: { clearColor: [0, 0, 0, MAX_32_BIT_FLOAT] },\n                    combineMaxMin\n                });\n            }\n            else {\n                if (needMin) {\n                    this._renderToMaxMinTexture({\n                        id,\n                        parameters: { ...parameters, blendEquation: MIN_BLEND_EQUATION },\n                        gridSize,\n                        minOrMaxFb: minFramebuffers[id],\n                        clearParams: { clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] },\n                        combineMaxMin\n                    });\n                }\n                if (needMax) {\n                    this._renderToMaxMinTexture({\n                        id,\n                        parameters: { ...parameters, blendEquation: MAX_BLEND_EQUATION },\n                        gridSize,\n                        minOrMaxFb: maxFramebuffers[id],\n                        clearParams: { clearColor: [0, 0, 0, 0] },\n                        combineMaxMin\n                    });\n                }\n            }\n        }\n    }\n    // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n    _renderToMaxMinTexture(opts) {\n        const { id, gridSize, minOrMaxFb, combineMaxMin, clearParams = {} } = opts;\n        const { framebuffers } = this.state;\n        const { allAggregationModel } = this;\n        this.device.withParametersWebGL({\n            ...clearParams,\n            framebuffer: minOrMaxFb,\n            viewport: [0, 0, gridSize[0], gridSize[1]]\n        }, () => {\n            this.device.clearWebGL({ color: true });\n            // allAggregationModel.setParameters(parameters);\n            allAggregationModel.setUniforms({ gridSize, combineMaxMin });\n            allAggregationModel.setBindings({ uSampler: framebuffers[id].texture });\n            allAggregationModel.draw();\n            // TODO - we need to create a render pass for the aggregation\n            // allAggregationModel.draw(renderPass);\n        });\n    }\n    // render all data points to aggregate weights\n    _renderToWeightsTexture(opts) {\n        const { id, parameters, moduleSettings, uniforms, gridSize, weights } = opts;\n        const { framebuffers, equations, weightAttributes } = this.state;\n        const { gridAggregationModel } = this;\n        const { operation } = weights[id];\n        const clearColor = operation === AGGREGATION_OPERATION.MIN\n            ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            : [0, 0, 0, 0];\n        this.device.withParametersWebGL({\n            framebuffer: framebuffers[id],\n            viewport: [0, 0, gridSize[0], gridSize[1]],\n            clearColor\n        }, () => {\n            this.device.clearWebGL({ color: true });\n            const attributes = { weights: weightAttributes[id] };\n            gridAggregationModel.draw({\n                parameters: { ...parameters, blendEquation: equations[id] },\n                moduleSettings,\n                uniforms,\n                attributes\n            });\n        });\n        if (operation === AGGREGATION_OPERATION.MEAN) {\n            const { meanTextures, textures } = this.state;\n            const transformOptions = {\n                _sourceTextures: { aggregationValues: meanTextures[id] }, // contains aggregated data\n                _targetTexture: textures[id], // store mean values,\n                elementCount: textures[id].width * textures[id].height\n            };\n            if (this.meanTransform) {\n                this.meanTransform.update(transformOptions);\n            }\n            else {\n                this.meanTransform = getMeanTransform(this.device, transformOptions);\n            }\n            this.meanTransform.run({\n                parameters: {\n                    blend: false,\n                    depthTest: false\n                }\n            });\n            // update framebuffer with mean results so device.readPixelsToBufferWebGL returns mean values\n            framebuffers[id].attach({ [36064]: textures[id] });\n        }\n    }\n    _runAggregation(opts) {\n        this._updateModels(opts);\n        this._setupFramebuffers(opts);\n        this._renderAggregateData(opts);\n        const results = this._getAggregateData(opts);\n        this.setState({ results });\n        return results;\n    }\n    // set up framebuffer for each weight\n    /* eslint-disable complexity, max-depth, max-statements*/\n    _setupFramebuffers(opts) {\n        const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, equations } = this.state;\n        const { weights } = opts;\n        const { numCol, numRow } = opts;\n        const framebufferSize = { width: numCol, height: numRow };\n        for (const id in weights) {\n            const { needMin, needMax, combineMaxMin, operation } = weights[id];\n            textures[id] =\n                weights[id].aggregationTexture ||\n                    textures[id] ||\n                    getFloatTexture(this.device, { id: `${id}-texture`, width: numCol, height: numRow });\n            textures[id].resize(framebufferSize);\n            let texture = textures[id];\n            if (operation === AGGREGATION_OPERATION.MEAN) {\n                // For MEAN, we first aggregatet into a temp texture\n                meanTextures[id] =\n                    meanTextures[id] ||\n                        getFloatTexture(this.device, { id: `${id}-mean-texture`, width: numCol, height: numRow });\n                meanTextures[id].resize(framebufferSize);\n                texture = meanTextures[id];\n            }\n            if (framebuffers[id]) {\n                framebuffers[id].attach({ [36064]: texture });\n            }\n            else {\n                framebuffers[id] = getFramebuffer(this.device, {\n                    id: `${id}-fb`,\n                    width: numCol,\n                    height: numRow,\n                    texture\n                });\n            }\n            framebuffers[id].resize(framebufferSize);\n            equations[id] = EQUATION_MAP[operation] || EQUATION_MAP[AGGREGATION_OPERATION.SUM];\n            // For min/max framebuffers will use default size 1X1\n            if (needMin || needMax) {\n                if (needMin && needMax && combineMaxMin) {\n                    if (!maxMinFramebuffers[id]) {\n                        texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n                        maxMinFramebuffers[id] = getFramebuffer(this.device, { id: `${id}-maxMinFb`, texture });\n                    }\n                }\n                else {\n                    if (needMin) {\n                        if (!minFramebuffers[id]) {\n                            texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n                            minFramebuffers[id] = getFramebuffer(this.device, {\n                                id: `${id}-minFb`,\n                                texture\n                            });\n                        }\n                    }\n                    if (needMax) {\n                        if (!maxFramebuffers[id]) {\n                            texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n                            maxFramebuffers[id] = getFramebuffer(this.device, {\n                                id: `${id}-maxFb`,\n                                texture\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /* eslint-enable complexity, max-depth, max-statements */\n    _getMinMaxTexture(name) {\n        const { resources } = this.state;\n        if (!resources[name]) {\n            resources[name] = getFloatTexture(this.device, { id: 'resourceName' });\n        }\n        return resources[name];\n    }\n    _setupModels({ numCol = 0, numRow = 0 } = {}) {\n        const { shaderOptions } = this.state;\n        this.gridAggregationModel?.destroy();\n        this.gridAggregationModel = getAggregationModel(this.device, shaderOptions);\n        if (!this.allAggregationModel) {\n            const instanceCount = numCol * numRow;\n            this.allAggregationModel = getAllAggregationModel(this.device, instanceCount);\n        }\n    }\n    // set up buffers for all weights\n    _setupWeightAttributes(opts) {\n        const { weightAttributes } = this.state;\n        const { weights } = opts;\n        for (const id in weights) {\n            weightAttributes[id] = opts.attributes[id];\n        }\n    }\n    /** GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion. */\n    /* eslint-disable max-depth */\n    _trackGPUResultBuffers(results, weights) {\n        const { resources } = this.state;\n        for (const id in results) {\n            if (results[id]) {\n                for (const bufferName of BUFFER_NAMES) {\n                    if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n                        // No result buffer is provided in weights object, `device.readPixelsToBufferWebGL` has created a new Buffer object\n                        // collect the new buffer for garabge collection\n                        const name = `gpu-result-${id}-${bufferName}`;\n                        if (resources[name]) {\n                            resources[name].delete();\n                        }\n                        resources[name] = results[id][bufferName];\n                    }\n                }\n            }\n        }\n    }\n    /* eslint-enable max-depth */\n    _updateModels(opts) {\n        const { vertexCount, attributes, numCol, numRow } = opts;\n        const { modelDirty } = this.state;\n        if (modelDirty) {\n            this._setupModels(opts);\n            this.setState({ modelDirty: false });\n        }\n        // this maps color/elevation to weight name.\n        this._setupWeightAttributes(opts);\n        this.gridAggregationModel.setVertexCount(vertexCount);\n        this.gridAggregationModel.setAttributes(attributes);\n        this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n}\n// HELPER METHODS\nfunction normalizeWeightParams(weights) {\n    const result = {};\n    for (const id in weights) {\n        result[id] = { ...DEFAULT_WEIGHT_PARAMS, ...weights[id] };\n    }\n    return result;\n}\nfunction deleteResources(resources) {\n    resources = Array.isArray(resources) ? resources : [resources];\n    resources.forEach(obj => {\n        for (const name in obj) {\n            obj[name].delete();\n        }\n    });\n}\nfunction getAggregationModel(device, shaderOptions) {\n    const shaders = mergeShaders({\n        vs: AGGREGATE_TO_GRID_VS,\n        fs: AGGREGATE_TO_GRID_FS,\n        modules: [fp64arithmetic, project32]\n    }, shaderOptions);\n    return new Model(device, {\n        id: 'Grid-Aggregation-Model',\n        vertexCount: 1,\n        drawMode: 0,\n        shaderAssembler: getShaderAssembler(),\n        ...shaders\n    });\n}\nfunction getAllAggregationModel(device, instanceCount) {\n    return new Model(device, {\n        id: 'All-Aggregation-Model',\n        vs: AGGREGATE_ALL_VS,\n        fs: AGGREGATE_ALL_FS,\n        modules: [fp64arithmetic],\n        vertexCount: 1,\n        topology: 'point-list',\n        isInstanced: true,\n        instanceCount,\n        attributes: {\n            // @ts-expect-error\n            position: [0, 0]\n        }\n    });\n}\nfunction getMeanTransform(device, opts) {\n    return new TextureTransform(device, {\n        vs: TRANSFORM_MEAN_VS,\n        _targetTextureVarying: 'meanValues',\n        ...opts\n    });\n}\n", "import { GL } from '@luma.gl/constants';\nimport { AGGREGATION_OPERATION } from \"../aggregation-operation-utils.js\";\nexport const DEFAULT_RUN_PARAMS = {\n    projectPoints: false,\n    viewport: null,\n    createBufferObjects: true,\n    moduleSettings: {}\n};\nexport const MAX_32_BIT_FLOAT = 3.402823466e38;\nexport const MIN_BLEND_EQUATION = [32775, 32774];\nexport const MAX_BLEND_EQUATION = [32776, 32774];\nexport const MAX_MIN_BLEND_EQUATION = [32776, 32775];\nexport const EQUATION_MAP = {\n    [AGGREGATION_OPERATION.SUM]: 32774,\n    [AGGREGATION_OPERATION.MEAN]: 32774,\n    [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,\n    [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION\n};\nexport const ELEMENTCOUNT = 4;\nexport const DEFAULT_WEIGHT_PARAMS = {\n    size: 1,\n    operation: AGGREGATION_OPERATION.SUM,\n    needMin: false,\n    needMax: false,\n    combineMaxMin: false\n};\nexport const PIXEL_SIZE = 4; // RGBA32F\nexport const WEIGHT_SIZE = 3;\nexport const MAX_MIN_TEXTURE_OPTS = {\n    format: 34836,\n    type: 5126,\n    border: 0,\n    mipmaps: false,\n    sampler: {\n        minFilter: 'nearest',\n        magFilter: 'nearest'\n    },\n    dataFormat: 6408,\n    width: 1,\n    height: 1\n};\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport const AGGREGATION_OPERATION = {\n    SUM: 1,\n    MEAN: 2,\n    MIN: 3,\n    MAX: 4\n};\nfunction sumReducer(accu, cur) {\n    return accu + cur;\n}\nfunction maxReducer(accu, cur) {\n    return cur > accu ? cur : accu;\n}\nfunction minReducer(accu, cur) {\n    return cur < accu ? cur : accu;\n}\nexport function getMean(pts, accessor) {\n    if (Number.isFinite(accessor)) {\n        return pts.length ? accessor : null;\n    }\n    const filtered = pts.map(accessor).filter(Number.isFinite);\n    return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;\n}\nexport function getSum(pts, accessor) {\n    if (Number.isFinite(accessor)) {\n        return pts.length ? pts.length * accessor : null;\n    }\n    const filtered = pts.map(accessor).filter(Number.isFinite);\n    return filtered.length ? filtered.reduce(sumReducer, 0) : null;\n}\nexport function getMax(pts, accessor) {\n    if (Number.isFinite(accessor)) {\n        return pts.length ? accessor : null;\n    }\n    const filtered = pts.map(accessor).filter(Number.isFinite);\n    return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;\n}\nexport function getMin(pts, accessor) {\n    if (Number.isFinite(accessor)) {\n        return pts.length ? accessor : null;\n    }\n    const filtered = pts.map(accessor).filter(Number.isFinite);\n    return filtered.length ? filtered.reduce(minReducer, Infinity) : null;\n}\n// Function to convert from aggregation/accessor props (like colorAggregation and getColorWeight) to getValue prop (like getColorValue)\nexport function getValueFunc(aggregation, accessor, context) {\n    const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;\n    accessor = wrapAccessor(accessor, context);\n    switch (op) {\n        case AGGREGATION_OPERATION.MIN:\n            return pts => getMin(pts, accessor);\n        case AGGREGATION_OPERATION.SUM:\n            return pts => getSum(pts, accessor);\n        case AGGREGATION_OPERATION.MEAN:\n            return pts => getMean(pts, accessor);\n        case AGGREGATION_OPERATION.MAX:\n            return pts => getMax(pts, accessor);\n        default:\n            return null;\n    }\n}\nfunction wrapAccessor(accessor, context = {}) {\n    if (Number.isFinite(accessor)) {\n        return accessor;\n    }\n    return pt => {\n        context.index = pt.index;\n        return accessor(pt.source, context);\n    };\n}\nexport function wrapGetValueFunc(getValue, context = {}) {\n    return pts => {\n        context.indices = pts.map(pt => pt.index);\n        return getValue(pts.map(pt => pt.source), context);\n    };\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-to-grid-vs\nin vec3 positions;\nin vec3 positions64Low;\nin vec3 weights;\nuniform vec2 cellSize;\nuniform vec2 gridSize;\nuniform bool projectPoints;\nuniform vec2 translation;\nuniform vec3 scaling;\nout vec3 vWeights;\nvec2 project_to_pixel(vec4 pos) {\nvec4 result;\npos.xy = pos.xy/pos.w;\nresult = pos + vec4(translation, 0., 0.);\nresult.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;\nreturn result.xy;\n}\nvoid main(void) {\nvWeights = weights;\nvec4 windowPos = vec4(positions, 1.);\nif (projectPoints) {\nwindowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));\n}\nvec2 pos = project_to_pixel(windowPos);\nvec2 pixelXY64[2];\npixelXY64[0] = vec2(pos.x, 0.);\npixelXY64[1] = vec2(pos.y, 0.);\nvec2 gridXY64[2];\ngridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));\ngridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));\nfloat x = floor(gridXY64[0].x);\nfloat y = floor(gridXY64[1].x);\npos = vec2(x, y);\npos = (pos * (2., 2.) / (gridSize)) - (1., 1.);\nvec2 offset = 1.0 / gridSize;\npos = pos + offset;\ngl_Position = vec4(pos, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-to-grid-fs\nprecision highp float;\nin vec3 vWeights;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vec4(vWeights, 1.0);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-vs-64\nin vec2 position;\nuniform ivec2 gridSize;\nout vec2 vTextureCoord;\nvoid main(void) {\nvec2 pos = vec2(-1.0, -1.0);\nvec2 offset = 1.0 / vec2(gridSize);\npos = pos + offset;\ngl_Position = vec4(pos, 0.0, 1.0);\nint yIndex = gl_InstanceID / gridSize[0];\nint xIndex = gl_InstanceID - (yIndex * gridSize[0]);\nvec2 yIndexFP64 = vec2(float(yIndex), 0.);\nvec2 xIndexFP64 = vec2(float(xIndex), 0.);\nvec2 gridSizeYFP64 = vec2(gridSize[1], 0.);\nvec2 gridSizeXFP64 = vec2(gridSize[0], 0.);\nvec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);\nvec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);\nvTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);\ngl_PointSize = 1.0;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-all-fs\nprecision highp float;\nin vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform bool combineMaxMin;\nout vec4 fragColor;\nvoid main(void) {\nvec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));\nif (textureColor.a == 0.) {\ndiscard;\n}\nfragColor.rgb = textureColor.rgb;\nfragColor.a = combineMaxMin ? textureColor.r : textureColor.a;\n}\n`;\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-transform-mean-vs\nin vec4 aggregationValues;\nout vec4 meanValues;\nvoid main()\n{\nbool isCellValid = bool(aggregationValues.w > 0.);\nmeanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);\nmeanValues.w = aggregationValues.w;\ngl_PointSize = 1.0;\n}\n`;\n", "const DEFAULT_PARAMETERS = {\n    minFilter: 'nearest',\n    magFilter: 'nearest'\n};\n// TODO - not working\nexport function getFloatTexture(device, opts) {\n    const { width = 1, height = 1, data = null, parameters = DEFAULT_PARAMETERS } = opts;\n    const texture = device.createTexture({\n        data,\n        format: 'rgba32float', // device.info.type === 'webgl2' ? 'rgba32float' : GL.RGBA,\n        // type: GL.FLOAT,\n        // border: 0,\n        mipmaps: false,\n        sampler: parameters,\n        // dataFormat: GL.RGBA,\n        width,\n        height\n        // ts-expect-error\n        // unpackFlipY\n    });\n    return texture;\n}\nexport function getFramebuffer(device, opts) {\n    const { id, width = 1, height = 1, texture } = opts;\n    const fb = device.createFramebuffer({\n        id,\n        width,\n        height,\n        colorAttachments: [texture]\n    });\n    return fb;\n}\nexport function getFloatArray(array, size, fillValue = 0) {\n    if (!array || array.length < size) {\n        return new Float32Array(size).fill(fillValue);\n    }\n    return array;\n}\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from \"../utils/color-utils.js\";\nimport vs from \"./screen-grid-layer-vertex.glsl.js\";\nimport fs from \"./screen-grid-layer-fragment.glsl.js\";\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = ['minColor', 'maxColor', 'colorRange', 'colorDomain'];\nconst defaultProps = {\n    cellSizePixels: { type: 'number', value: 100, min: 1 },\n    cellMarginPixels: { type: 'number', value: 2, min: 0, max: 5 },\n    colorDomain: null,\n    colorRange: defaultColorRange\n};\nexport default class ScreenGridCellLayer extends Layer {\n    static { this.layerName = 'ScreenGridCellLayer'; }\n    static { this.defaultProps = defaultProps; }\n    getShaders() {\n        return { vs, fs, modules: [picking] };\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        attributeManager.addInstanced({\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            instancePositions: { size: 3, update: this.calculateInstancePositions },\n            instanceCounts: { size: 4, noAlloc: true }\n        });\n        this.setState({\n            model: this._getModel()\n        });\n    }\n    shouldUpdateState({ changeFlags }) {\n        // 'instanceCounts' buffer contetns change on viewport change.\n        return changeFlags.somethingChanged;\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { oldProps, props, changeFlags } = params;\n        const attributeManager = this.getAttributeManager();\n        if (props.numInstances !== oldProps.numInstances) {\n            attributeManager.invalidateAll();\n        }\n        else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n            attributeManager.invalidate('instancePositions');\n        }\n        this._updateUniforms(oldProps, props, changeFlags);\n    }\n    draw({ uniforms }) {\n        const { parameters, maxTexture } = this.props;\n        const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n        const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n        // If colorDomain not specified we use default domain [1, maxCount]\n        // maxCount value will be sampled form maxTexture in vertex shader.\n        const colorDomain = this.props.colorDomain || [1, 0];\n        const model = this.state.model;\n        model.setUniforms(uniforms);\n        model.setBindings({\n            maxTexture\n        });\n        model.setUniforms({\n            minColor,\n            maxColor,\n            colorDomain\n        });\n        model.setParameters({\n            depthWriteEnabled: false,\n            // How to specify depth mask in WebGPU?\n            // depthMask: false,\n            ...parameters\n        });\n        model.draw(this.context.renderPass);\n    }\n    calculateInstancePositions(attribute, { numInstances }) {\n        const { width, height } = this.context.viewport;\n        const { cellSizePixels } = this.props;\n        const numCol = Math.ceil(width / cellSizePixels);\n        const { value, size } = attribute;\n        for (let i = 0; i < numInstances; i++) {\n            const x = i % numCol;\n            const y = Math.floor(i / numCol);\n            value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n            value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n            value[i * size + 2] = 0;\n        }\n    }\n    // Private Methods\n    _getModel() {\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-list',\n                attributes: {\n                    // prettier-ignore\n                    positions: new Float32Array([\n                        0, 0, 0,\n                        1, 0, 0,\n                        1, 1, 0,\n                        0, 0, 0,\n                        1, 1, 0,\n                        0, 1, 0,\n                    ])\n                }\n            })\n        });\n    }\n    _shouldUseMinMax() {\n        const { minColor, maxColor, colorDomain, colorRange } = this.props;\n        if (minColor || maxColor) {\n            log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n            return true;\n        }\n        // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n        // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n        if (colorDomain || colorRange) {\n            return false;\n        }\n        // None specified, use default minColor and maxColor\n        return true;\n    }\n    _updateUniforms(oldProps, props, changeFlags) {\n        const model = this.state.model;\n        if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n            model.setUniforms({ shouldUseMinMax: this._shouldUseMinMax() });\n        }\n        if (oldProps.colorRange !== props.colorRange) {\n            model.setUniforms({ colorRange: colorRangeToFlatArray(props.colorRange) });\n        }\n        if (oldProps.cellMarginPixels !== props.cellMarginPixels ||\n            oldProps.cellSizePixels !== props.cellSizePixels ||\n            changeFlags.viewportChanged) {\n            const { width, height } = this.context.viewport;\n            const { cellSizePixels, cellMarginPixels } = this.props;\n            const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n            const cellScale = new Float32Array([\n                ((cellSizePixels - margin) / width) * 2,\n                (-(cellSizePixels - margin) / height) * 2,\n                1\n            ]);\n            model.setUniforms({ cellScale });\n        }\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport const defaultColorRange = [\n    [255, 255, 178],\n    [254, 217, 118],\n    [254, 178, 76],\n    [253, 141, 60],\n    [240, 59, 32],\n    [189, 0, 38]\n];\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {\n    let flatArray;\n    if (Number.isFinite(colorRange[0])) {\n        // its already a flat array.\n        flatArray = new ArrayType(colorRange);\n    }\n    else {\n        // flatten it\n        flatArray = new ArrayType(colorRange.length * 4);\n        let index = 0;\n        for (let i = 0; i < colorRange.length; i++) {\n            const color = colorRange[i];\n            flatArray[index++] = color[0];\n            flatArray[index++] = color[1];\n            flatArray[index++] = color[2];\n            flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n        }\n    }\n    if (normalize) {\n        for (let i = 0; i < flatArray.length; i++) {\n            flatArray[i] /= 255;\n        }\n    }\n    return flatArray;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec3 positions;\nin vec3 instancePositions;\nin vec4 instanceCounts;\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform vec3 cellScale;\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 colorDomain;\nuniform bool shouldUseMinMax;\nuniform sampler2D maxTexture;\nout vec4 vColor;\nout float vSampleCount;\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\nvec4 outColor = vec4(0., 0., 0., 0.);\nif (value >= domain.x && value <= domain.y) {\nfloat domainRange = domain.y - domain.x;\nif (domainRange <= 0.) {\noutColor = colorRange[0];\n} else {\nfloat rangeCount = float(RANGE_COUNT);\nfloat rangeStep = domainRange / rangeCount;\nfloat idx = floor((value - domain.x) / rangeStep);\nidx = clamp(idx, 0., rangeCount - 1.);\nint intIdx = int(idx);\noutColor = colorRange[intIdx];\n}\n}\noutColor = outColor / 255.;\nreturn outColor;\n}\nvoid main(void) {\nvSampleCount = instanceCounts.a;\nfloat weight = instanceCounts.r;\nfloat maxWeight = texture(maxTexture, vec2(0.5)).r;\nfloat step = weight / maxWeight;\nvec4 minMaxColor = mix(minColor, maxColor, step) / 255.;\nvec2 domain = colorDomain;\nfloat domainMaxValid = float(colorDomain.y != 0.);\ndomain.y = mix(maxWeight, colorDomain.y, domainMaxValid);\nvec4 rangeColor = quantizeScale(domain, colorRange, weight);\nfloat rangeMinMax = float(shouldUseMinMax);\nvec4 color = mix(rangeColor, minMaxColor, rangeMinMax);\nvColor = vec4(color.rgb, color.a * opacity);\npicking_setPickingColor(instancePickingColors);\ngl_Position = vec4(instancePositions + positions * cellScale, 1.);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* fragment shader for the grid-layer */\nexport default `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin float vSampleCount;\nout vec4 fragColor;\nvoid main(void) {\nif (vSampleCount <= 0.0) {\ndiscard;\n}\nfragColor = vColor;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { GL } from '@luma.gl/constants';\nimport { log } from '@deck.gl/core';\nimport AggregationLayer from \"./aggregation-layer.js\";\nimport GPUGridAggregator from \"./utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nimport BinSorter from \"./utils/bin-sorter.js\";\nimport { pointToDensityGridDataCPU } from \"./cpu-grid-layer/grid-aggregator.js\";\nexport default class GridAggregationLayer extends AggregationLayer {\n    static { this.layerName = 'GridAggregationLayer'; }\n    initializeAggregationLayer({ dimensions }) {\n        super.initializeAggregationLayer(dimensions);\n        this.setState({\n            // CPU aggregation results\n            layerData: {},\n            gpuGridAggregator: new GPUGridAggregator(this.context.device, {\n                id: `${this.id}-gpu-aggregator`\n            }),\n            cpuGridAggregator: pointToDensityGridDataCPU\n        });\n    }\n    updateState(opts) {\n        // get current attributes\n        super.updateState(opts);\n        this.updateAggregationState(opts);\n        const { aggregationDataDirty, aggregationWeightsDirty, gpuAggregation } = this.state;\n        if (this.getNumInstances() <= 0) {\n            return;\n        }\n        let aggregationDirty = false;\n        // CPU aggregation is two steps\n        // 1. Create bins (based on cellSize and position) 2. Aggregate weights for each bin\n        // For GPU aggregation both above steps are combined into one step\n        // step-1\n        if (aggregationDataDirty || (gpuAggregation && aggregationWeightsDirty)) {\n            this._updateAggregation(opts);\n            aggregationDirty = true;\n        }\n        // step-2 (Applicalbe for CPU aggregation only)\n        if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {\n            this._updateWeightBins();\n            this._uploadAggregationResults();\n            aggregationDirty = true;\n        }\n        this.setState({ aggregationDirty });\n    }\n    finalizeState(context) {\n        const { count } = this.state.weights;\n        if (count && count.aggregationBuffer) {\n            count.aggregationBuffer.delete();\n        }\n        this.state.gpuGridAggregator?.delete();\n        super.finalizeState(context);\n    }\n    updateShaders(shaders) {\n        if (this.state.gpuAggregation) {\n            this.state.gpuGridAggregator.updateShaders(shaders);\n        }\n    }\n    // Methods that can be overriden by subclasses for customizations\n    updateAggregationState(opts) {\n        // Sublayers should implement this method.\n        log.assert(false);\n    }\n    allocateResources(numRow, numCol) {\n        if (this.state.numRow !== numRow || this.state.numCol !== numCol) {\n            const dataBytes = numCol * numRow * 4 * 4;\n            const { weights } = this.state;\n            for (const name in weights) {\n                const weight = weights[name];\n                if (weight.aggregationBuffer) {\n                    weight.aggregationBuffer.delete();\n                }\n                weight.aggregationBuffer = this.context.device.createBuffer({\n                    byteLength: dataBytes,\n                    // @ts-expect-error legacy\n                    accessor: {\n                        size: 4,\n                        type: 5126,\n                        divisor: 1\n                    }\n                });\n            }\n        }\n    }\n    updateResults({ aggregationData, maxMinData, maxData, minData }) {\n        const { count } = this.state.weights;\n        if (count) {\n            count.aggregationData = aggregationData;\n            count.maxMinData = maxMinData;\n            count.maxData = maxData;\n            count.minData = minData;\n        }\n    }\n    // Private\n    _updateAggregation(opts) {\n        const { cpuGridAggregator, gpuGridAggregator, gridOffset, posOffset, translation = [0, 0], scaling = [0, 0, 0], boundingBox, projectPoints, gpuAggregation, numCol, numRow } = this.state;\n        const { props } = opts;\n        const { viewport } = this.context;\n        const attributes = this.getAttributes();\n        const vertexCount = this.getNumInstances();\n        if (!gpuAggregation) {\n            const result = cpuGridAggregator(props, {\n                gridOffset,\n                projectPoints,\n                attributes,\n                viewport,\n                posOffset,\n                boundingBox\n            });\n            this.setState({\n                layerData: result\n            });\n        }\n        else {\n            const { weights } = this.state;\n            gpuGridAggregator.run({\n                weights,\n                cellSize: [gridOffset.xOffset, gridOffset.yOffset],\n                numCol,\n                numRow,\n                translation,\n                scaling,\n                vertexCount,\n                projectPoints,\n                attributes,\n                moduleSettings: this.getModuleSettings()\n            });\n        }\n    }\n    _updateWeightBins() {\n        const { getValue } = this.state;\n        const sortedBins = new BinSorter(this.state.layerData.data || [], { getValue });\n        this.setState({ sortedBins });\n    }\n    _uploadAggregationResults() {\n        const { numCol, numRow } = this.state;\n        const { data } = this.state.layerData;\n        const { aggregatedBins, minValue, maxValue, totalCount } = this.state.sortedBins;\n        const ELEMENTCOUNT = 4;\n        const aggregationSize = numCol * numRow * ELEMENTCOUNT;\n        const aggregationData = new Float32Array(aggregationSize).fill(0);\n        for (const bin of aggregatedBins) {\n            const { lonIdx, latIdx } = data[bin.i];\n            const { value, counts } = bin;\n            const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;\n            aggregationData[cellIndex] = value;\n            aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;\n        }\n        const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);\n        const maxData = new Float32Array([maxValue, 0, 0, totalCount]);\n        const minData = new Float32Array([minValue, 0, 0, totalCount]);\n        this.updateResults({ aggregationData, maxMinData, maxData, minData });\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { CompositeLayer, AttributeManager, _compareProps as compareProps } from '@deck.gl/core';\nimport { filterProps } from \"./utils/prop-utils.js\";\nexport default class AggregationLayer extends CompositeLayer {\n    static { this.layerName = 'AggregationLayer'; }\n    initializeAggregationLayer(dimensions) {\n        super.initializeState(this.context);\n        this.setState({\n            // Layer props , when changed doesn't require updating aggregation\n            ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),\n            dimensions\n        });\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        const { changeFlags } = opts;\n        if (changeFlags.extensionsChanged) {\n            const shaders = this.getShaders({});\n            if (shaders && shaders.defines) {\n                shaders.defines.NON_INSTANCED_MODEL = 1;\n            }\n            this.updateShaders(shaders);\n        }\n        // Explictly call to update attributes as 'CompositeLayer' doesn't call this\n        this._updateAttributes();\n    }\n    updateAttributes(changedAttributes) {\n        // Super classes, can refer to state.changedAttributes to determine what\n        // attributes changed\n        this.setState({ changedAttributes });\n    }\n    getAttributes() {\n        return this.getAttributeManager().getAttributes();\n    }\n    getModuleSettings() {\n        // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\n        // For aggregation layers this is called during updateState to update aggregation data\n        // NOTE: it is similar to LayerPass._getModuleParameters() but doesn't inlcude `effects` it is not needed for aggregation\n        const { viewport, mousePosition, device } = this.context;\n        const moduleSettings = Object.assign(Object.create(this.props), {\n            viewport,\n            mousePosition,\n            picking: {\n                isActive: 0\n            },\n            // @ts-expect-error TODO - assuming WebGL context\n            devicePixelRatio: device.canvasContext.cssToDeviceRatio()\n        });\n        return moduleSettings;\n    }\n    updateShaders(shaders) {\n        // Default implemention is empty, subclasses can update their Model objects if needed\n    }\n    /**\n     * Checks if aggregation is dirty\n     * @param {Object} updateOpts - object {props, oldProps, changeFlags}\n     * @param {Object} params - object {dimension, compareAll}\n     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\n     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\n     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\n     **/\n    isAggregationDirty(updateOpts, params = {}) {\n        const { props, oldProps, changeFlags } = updateOpts;\n        const { compareAll = false, dimension } = params;\n        const { ignoreProps } = this.state;\n        const { props: dataProps, accessors = [] } = dimension;\n        const { updateTriggersChanged } = changeFlags;\n        if (changeFlags.dataChanged) {\n            return true;\n        }\n        if (updateTriggersChanged) {\n            if (updateTriggersChanged.all) {\n                return true;\n            }\n            for (const accessor of accessors) {\n                if (updateTriggersChanged[accessor]) {\n                    return true;\n                }\n            }\n        }\n        if (compareAll) {\n            if (changeFlags.extensionsChanged) {\n                return true;\n            }\n            // Compare non layer props too (like extension props)\n            // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\n            return compareProps({\n                oldProps,\n                newProps: props,\n                ignoreProps,\n                propTypes: this.constructor._propTypes\n            });\n        }\n        // Compare props of the dimension\n        for (const name of dataProps) {\n            if (props[name] !== oldProps[name]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks if an attribute is changed\n     * @param {String} name - name of the attribute\n     * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\n     *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\n     **/\n    isAttributeChanged(name) {\n        const { changedAttributes } = this.state;\n        if (!name) {\n            // if name not specified return true if any attribute is changed\n            return !isObjectEmpty(changedAttributes);\n        }\n        return changedAttributes && changedAttributes[name] !== undefined;\n    }\n    // Private\n    // override Composite layer private method to create AttributeManager instance\n    _getAttributeManager() {\n        return new AttributeManager(this.context.device, {\n            id: this.props.id,\n            stats: this.context.stats\n        });\n    }\n}\n// Helper methods\n// Returns true if given object is empty, false otherwise.\nfunction isObjectEmpty(obj) {\n    let isEmpty = true;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const key in obj) {\n        isEmpty = false;\n        break;\n    }\n    return isEmpty;\n}\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport function filterProps(props, filterKeys) {\n    const filteredProps = {};\n    for (const key in props) {\n        if (!filterKeys.includes(key)) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { log } from '@deck.gl/core';\n// a scale function wrapper just like d3-scales\nexport function getScale(domain, range, scaleFunction) {\n    const scale = scaleFunction;\n    scale.domain = () => domain;\n    scale.range = () => range;\n    return scale;\n}\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\n// return a quantize scale function\nexport function getQuantizeScale(domain, range) {\n    const scaleFunction = value => quantizeScale(domain, range, value);\n    return getScale(domain, range, scaleFunction);\n}\n// return a linear scale function\nexport function getLinearScale(domain, range) {\n    const scaleFunction = value => linearScale(domain, range, value);\n    return getScale(domain, range, scaleFunction);\n}\nexport function getQuantileScale(domain, range) {\n    // calculate threshold\n    const sortedDomain = domain.sort(ascending);\n    let i = 0;\n    const n = Math.max(1, range.length);\n    const thresholds = new Array(n - 1);\n    while (++i < n) {\n        thresholds[i - 1] = threshold(sortedDomain, i / n);\n    }\n    const scaleFunction = value => thresholdsScale(thresholds, range, value);\n    scaleFunction.thresholds = () => thresholds;\n    return getScale(domain, range, scaleFunction);\n}\nfunction ascending(a, b) {\n    return a - b;\n}\nfunction threshold(domain, fraction) {\n    const domainLength = domain.length;\n    if (fraction <= 0 || domainLength < 2) {\n        return domain[0];\n    }\n    if (fraction >= 1) {\n        return domain[domainLength - 1];\n    }\n    const domainFraction = (domainLength - 1) * fraction;\n    const lowIndex = Math.floor(domainFraction);\n    const low = domain[lowIndex];\n    const high = domain[lowIndex + 1];\n    return low + (high - low) * (domainFraction - lowIndex);\n}\nfunction bisectRight(a, x) {\n    let lo = 0;\n    let hi = a.length;\n    while (lo < hi) {\n        const mid = (lo + hi) >>> 1;\n        if (ascending(a[mid], x) > 0) {\n            hi = mid;\n        }\n        else {\n            lo = mid + 1;\n        }\n    }\n    return lo;\n}\n// return a quantize scale function\nfunction thresholdsScale(thresholds, range, value) {\n    return range[bisectRight(thresholds, value)];\n}\n// ordinal Scale\nfunction ordinalScale(domain, domainMap, range, value) {\n    const key = `${value}`;\n    let d = domainMap.get(key);\n    if (d === undefined) {\n        // update the domain\n        d = domain.push(value);\n        domainMap.set(key, d);\n    }\n    return range[(d - 1) % range.length];\n}\nexport function getOrdinalScale(domain, range) {\n    const domainMap = new Map();\n    const uniqueDomain = [];\n    for (const d of domain) {\n        const key = `${d}`;\n        if (!domainMap.has(key)) {\n            domainMap.set(key, uniqueDomain.push(d));\n        }\n    }\n    const scaleFunction = value => ordinalScale(uniqueDomain, domainMap, range, value);\n    return getScale(domain, range, scaleFunction);\n}\n// Quantize scale is similar to linear scales,\n// except it uses a discrete rather than continuous range\nexport function quantizeScale(domain, range, value) {\n    const domainRange = domain[1] - domain[0];\n    if (domainRange <= 0) {\n        log.warn('quantizeScale: invalid domain, returning range[0]')();\n        return range[0];\n    }\n    const step = domainRange / range.length;\n    const idx = Math.floor((value - domain[0]) / step);\n    const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);\n    return range[clampIdx];\n}\n// Linear scale maps continuous domain to continuous range\nexport function linearScale(domain, range, value) {\n    return ((value - domain[0]) / (domain[1] - domain[0])) * (range[1] - range[0]) + range[0];\n}\n// get scale domains\nfunction notNullOrUndefined(d) {\n    return d !== undefined && d !== null;\n}\nexport function unique(values) {\n    const results = [];\n    values.forEach(v => {\n        if (!results.includes(v) && notNullOrUndefined(v)) {\n            results.push(v);\n        }\n    });\n    return results;\n}\nfunction getTruthyValues(data, valueAccessor) {\n    const values = typeof valueAccessor === 'function' ? data.map(valueAccessor) : data;\n    return values.filter(notNullOrUndefined);\n}\nexport function getLinearDomain(data, valueAccessor) {\n    const sorted = getTruthyValues(data, valueAccessor).sort();\n    return sorted.length ? [sorted[0], sorted[sorted.length - 1]] : [0, 0];\n}\nexport function getQuantileDomain(data, valueAccessor) {\n    return getTruthyValues(data, valueAccessor);\n}\nexport function getOrdinalDomain(data, valueAccessor) {\n    return unique(getTruthyValues(data, valueAccessor));\n}\nexport function getScaleDomain(scaleType, data, valueAccessor) {\n    switch (scaleType) {\n        case 'quantize':\n        case 'linear':\n            return getLinearDomain(data, valueAccessor);\n        case 'quantile':\n            return getQuantileDomain(data, valueAccessor);\n        case 'ordinal':\n            return getOrdinalDomain(data, valueAccessor);\n        default:\n            return getLinearDomain(data, valueAccessor);\n    }\n}\nexport function clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nexport function getScaleFunctionByScaleType(scaleType) {\n    switch (scaleType) {\n        case 'quantize':\n            return getQuantizeScale;\n        case 'linear':\n            return getLinearScale;\n        case 'quantile':\n            return getQuantileScale;\n        case 'ordinal':\n            return getOrdinalScale;\n        default:\n            return getQuantizeScale;\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// getValue takes an array of points returns a value to sort the bins on.\n// by default it returns the number of points\n// this is where to pass in a function to color the bins by\n// avg/mean/max of specific value of the point\nconst defaultGetValue = points => points.length;\nimport { clamp, getQuantileDomain, getOrdinalDomain } from \"./scale-utils.js\";\nconst MAX_32_BIT_FLOAT = 3.402823466e38;\n// access array of points in each bin\nconst defaultGetPoints = bin => bin.points;\n// access index of each bin\nconst defaultGetIndex = bin => bin.index;\n// d3-scending\nconst ascending = (a, b) => (a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN);\nconst defaultProps = {\n    getValue: defaultGetValue,\n    getPoints: defaultGetPoints,\n    getIndex: defaultGetIndex,\n    filterData: null\n};\nexport default class BinSorter {\n    constructor(bins = [], props = defaultProps) {\n        this.aggregatedBins = this.getAggregatedBins(bins, props);\n        this._updateMinMaxValues();\n        this.binMap = this.getBinMap();\n    }\n    /**\n     * Get an array of object with aggregated values and index of bins\n     * Array object will be sorted by value optionally.\n     * @param {Array} bins\n     * @param {Function} getValue\n     * @return {Array} array of values and index lookup\n     */\n    getAggregatedBins(bins, props) {\n        const { getValue = defaultGetValue, getPoints = defaultGetPoints, getIndex = defaultGetIndex, filterData } = props;\n        const hasFilter = typeof filterData === 'function';\n        const binCount = bins.length;\n        const aggregatedBins = [];\n        let index = 0;\n        for (let binIndex = 0; binIndex < binCount; binIndex++) {\n            const bin = bins[binIndex];\n            const points = getPoints(bin);\n            const i = getIndex(bin);\n            const filteredPoints = hasFilter ? points.filter(filterData) : points;\n            bin.filteredPoints = hasFilter ? filteredPoints : null;\n            const value = filteredPoints.length ? getValue(filteredPoints) : null;\n            if (value !== null && value !== undefined) {\n                // filter bins if value is null or undefined\n                aggregatedBins[index] = {\n                    i: Number.isFinite(i) ? i : binIndex,\n                    value,\n                    counts: filteredPoints.length\n                };\n                index++;\n            }\n        }\n        return aggregatedBins;\n    }\n    _percentileToIndex(percentileRange) {\n        const len = this.sortedBins.length;\n        if (len < 2) {\n            return [0, 0];\n        }\n        const [lower, upper] = percentileRange.map(n => clamp(n, 0, 100));\n        const lowerIdx = Math.ceil((lower / 100) * (len - 1));\n        const upperIdx = Math.floor((upper / 100) * (len - 1));\n        return [lowerIdx, upperIdx];\n    }\n    /**\n     * Get a mapping from cell/hexagon index to sorted bin\n     * This is used to retrieve bin value for color calculation\n     * @return {Object} bin index to aggregatedBins\n     */\n    getBinMap() {\n        const binMap = {};\n        for (const bin of this.aggregatedBins) {\n            binMap[bin.i] = bin;\n        }\n        return binMap;\n    }\n    // Private\n    /**\n     * Get ths max count of all bins\n     */\n    _updateMinMaxValues() {\n        let maxCount = 0;\n        let maxValue = 0;\n        let minValue = MAX_32_BIT_FLOAT;\n        let totalCount = 0;\n        for (const x of this.aggregatedBins) {\n            maxCount = maxCount > x.counts ? maxCount : x.counts;\n            maxValue = maxValue > x.value ? maxValue : x.value;\n            minValue = minValue < x.value ? minValue : x.value;\n            totalCount += x.counts;\n        }\n        this.maxCount = maxCount;\n        this.maxValue = maxValue;\n        this.minValue = minValue;\n        this.totalCount = totalCount;\n    }\n    /**\n     * Get range of values of all bins\n     * @param {Number[]} range\n     * @param {Number} range[0] - lower bound\n     * @param {Number} range[1] - upper bound\n     * @return {Array} array of new value range\n     */\n    getValueRange(percentileRange) {\n        if (!this.sortedBins) {\n            this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n        }\n        if (!this.sortedBins.length) {\n            // @ts-expect-error\n            return [];\n        }\n        let lowerIdx = 0;\n        let upperIdx = this.sortedBins.length - 1;\n        if (Array.isArray(percentileRange)) {\n            const idxRange = this._percentileToIndex(percentileRange);\n            lowerIdx = idxRange[0];\n            upperIdx = idxRange[1];\n        }\n        return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];\n    }\n    getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {\n        if (!this.sortedBins) {\n            this.sortedBins = this.aggregatedBins.sort((a, b) => ascending(a.value, b.value));\n        }\n        if (!this.sortedBins.length) {\n            return [];\n        }\n        const indexEdge = this._percentileToIndex([lower, upper]);\n        return this._getScaleDomain(scale, indexEdge);\n    }\n    _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {\n        const bins = this.sortedBins;\n        switch (scaleType) {\n            case 'quantize':\n            case 'linear':\n                return [bins[lowerIdx].value, bins[upperIdx].value];\n            case 'quantile':\n                return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), d => d.value);\n            case 'ordinal':\n                return getOrdinalDomain(bins, d => d.value);\n            default:\n                return [bins[lowerIdx].value, bins[upperIdx].value];\n        }\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { createIterable } from '@deck.gl/core';\nimport { getGridOffset } from \"../utils/grid-aggregation-utils.js\";\n/**\n * Calculate density grid from an array of points\n * @param {Object} props - object containing :\n * @param {Iterable} [props.data] - data objects to be aggregated\n * @param {Integer} [props.cellSize] - size of the grid cell\n *\n * @param {Object} aggregationParams - object containing :\n * @param {Object} gridOffset - {xOffset, yOffset} cell size in meters\n * @param {Integer} width - width of the grid\n * @param {Integer} height - height of the grid\n * @param {Boolean} projectPoints - `true` if doing screen space projection, `false` otherwise\n * @param {Array} attributes - attributes array containing position values\n * @param {Viewport} viewport - viewport to be used for projection\n * @param {Array} posOffset - [xOffset, yOffset] offset to be applied to positions to get cell index\n * @param {Object} boundingBox - {xMin, yMin, xMax, yMax} bounding box of input data\n *\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(props, aggregationParams) {\n    const hashInfo = pointsToGridHashing(props, aggregationParams);\n    const result = getGridLayerDataFromGridHash(hashInfo);\n    return {\n        gridHash: hashInfo.gridHash,\n        gridOffset: hashInfo.gridOffset,\n        data: result\n    };\n}\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable-next-line max-statements, complexity */\nfunction pointsToGridHashing(props, aggregationParams) {\n    const { data = [], cellSize } = props;\n    const { attributes, viewport, projectPoints, numInstances } = aggregationParams;\n    const positions = attributes.positions.value;\n    const { size } = attributes.positions.getAccessor();\n    const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);\n    const offsets = aggregationParams.posOffset || [180, 90];\n    const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);\n    if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n        return { gridHash: {}, gridOffset, offsets: [0, 0] };\n    }\n    const { width, height } = viewport;\n    const numCol = Math.ceil(width / gridOffset.xOffset);\n    const numRow = Math.ceil(height / gridOffset.yOffset);\n    // calculate count per cell\n    const gridHash = {};\n    const { iterable, objectInfo } = createIterable(data);\n    const position = new Array(3);\n    for (const pt of iterable) {\n        objectInfo.index++;\n        position[0] = positions[objectInfo.index * size];\n        position[1] = positions[objectInfo.index * size + 1];\n        position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;\n        const [x, y] = projectPoints ? viewport.project(position) : position;\n        if (Number.isFinite(x) && Number.isFinite(y)) {\n            const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);\n            const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);\n            if (!projectPoints ||\n                // when doing screen space agggregation (projectPoints = true), filter points outside of the viewport range.\n                (xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow)) {\n                const key = `${yIndex}-${xIndex}`;\n                gridHash[key] = gridHash[key] || { count: 0, points: [], lonIdx: xIndex, latIdx: yIndex };\n                gridHash[key].count += 1;\n                gridHash[key].points.push({\n                    source: pt,\n                    index: objectInfo.index\n                });\n            }\n        }\n    }\n    return { gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1] };\n}\n/* eslint-enable max-statements, complexity */\nfunction getGridLayerDataFromGridHash({ gridHash, gridOffset, offsets }) {\n    const data = new Array(Object.keys(gridHash).length);\n    let i = 0;\n    for (const key in gridHash) {\n        const idxs = key.split('-');\n        const latIdx = parseInt(idxs[0], 10);\n        const lonIdx = parseInt(idxs[1], 10);\n        const index = i++;\n        data[index] = {\n            index,\n            position: [\n                offsets[0] + gridOffset.xOffset * lonIdx,\n                offsets[1] + gridOffset.yOffset * latIdx\n            ],\n            ...gridHash[key]\n        };\n    }\n    return data;\n}\n// Calculate bounding box of position attribute\nfunction getPositionBoundingBox(positionAttribute, numInstance) {\n    // TODO - value might not exist (e.g. attribute transition)\n    const positions = positionAttribute.value;\n    const { size } = positionAttribute.getAccessor();\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let y;\n    let x;\n    for (let i = 0; i < numInstance; i++) {\n        x = positions[i * size];\n        y = positions[i * size + 1];\n        if (Number.isFinite(x) && Number.isFinite(y)) {\n            yMin = y < yMin ? y : yMin;\n            yMax = y > yMax ? y : yMax;\n            xMin = x < xMin ? x : xMin;\n            xMax = x > xMax ? x : xMax;\n        }\n    }\n    return { xMin, xMax, yMin, yMax };\n}\n", "import { log, COORDINATE_SYSTEM } from '@deck.gl/core';\nconst R_EARTH = 6378000;\nfunction toFinite(n) {\n    return Number.isFinite(n) ? n : 0;\n}\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable-next-line max-statements */\nexport function getBoundingBox(attributes, vertexCount) {\n    // TODO - value might not exist (e.g. attribute transition)\n    const positions = attributes.positions.value;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let y;\n    let x;\n    for (let i = 0; i < vertexCount; i++) {\n        x = positions[i * 3];\n        y = positions[i * 3 + 1];\n        yMin = y < yMin ? y : yMin;\n        yMax = y > yMax ? y : yMax;\n        xMin = x < xMin ? x : xMin;\n        xMax = x > xMax ? x : xMax;\n    }\n    const boundingBox = {\n        xMin: toFinite(xMin),\n        xMax: toFinite(xMax),\n        yMin: toFinite(yMin),\n        yMax: toFinite(yMax)\n    };\n    return boundingBox;\n}\n/* eslint-enable max-statements */\n// Returns XY translation for positions to peform aggregation in +ve sapce\nfunction getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {\n    const { width, height } = viewport;\n    // Origin to define grid\n    // DEFAULT coordinate system is treated as LNGLAT\n    const worldOrigin = coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];\n    // Other coordinate systems not supported/verified yet\n    log.assert(coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n        coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n        coordinateSystem === COORDINATE_SYSTEM.DEFAULT);\n    const { xMin, yMin } = boundingBox;\n    return [\n        // Align origin to match grid cell boundaries in CPU and GPU aggregations\n        -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),\n        -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])\n    ];\n}\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n    const sign = inValue < 0 ? -1 : 1;\n    let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n    value = Math.floor(value / cellSize) * cellSize;\n    return value * sign;\n}\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} boundingBox - {xMin, yMin, xMax, yMax} contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @param {boolean, optional} converToDegrees - when true offsets are converted from meters to lng/lat (degree) space\n * @returns {xOffset, yOffset} - cellSize size\n */\nexport function getGridOffset(boundingBox, cellSize, convertToMeters = true) {\n    if (!convertToMeters) {\n        return { xOffset: cellSize, yOffset: cellSize };\n    }\n    const { yMin, yMax } = boundingBox;\n    const centerLat = (yMin + yMax) / 2;\n    return calculateGridLatLonOffset(cellSize, centerLat);\n}\nexport function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {\n    const gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== COORDINATE_SYSTEM.CARTESIAN);\n    const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);\n    const { xMin, yMin, xMax, yMax } = boundingBox;\n    const width = xMax - xMin + gridOffset.xOffset;\n    const height = yMax - yMin + gridOffset.yOffset;\n    const numCol = Math.ceil(width / gridOffset.xOffset);\n    const numRow = Math.ceil(height / gridOffset.yOffset);\n    return { gridOffset, translation, width, height, numCol, numRow };\n}\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n    const yOffset = calculateLatOffset(cellSize);\n    const xOffset = calculateLonOffset(latitude, cellSize);\n    return { yOffset, xOffset };\n}\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n    return (dy / R_EARTH) * (180 / Math.PI);\n}\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n    return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { GridCellLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from \"../utils/color-utils.js\";\nimport { pointToDensityGridDataCPU } from \"./grid-aggregator.js\";\nimport CPUAggregator from \"../utils/cpu-aggregator.js\";\nimport AggregationLayer from \"../aggregation-layer.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() { }\nconst defaultProps = {\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorValue: { type: 'accessor', value: null }, // default value is calculated from `getColorWeight` and `colorAggregation`\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    lowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    upperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    colorScaleType: 'quantize',\n    onSetColorDomain: nop,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationValue: { type: 'accessor', value: null }, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationLowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    elevationUpperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    elevationScaleType: 'linear',\n    onSetElevationDomain: nop,\n    gridAggregator: pointToDensityGridDataCPU,\n    // grid\n    cellSize: { type: 'number', min: 0, max: 1000, value: 1000 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    extruded: false,\n    // Optional material for 'lighting' shader module\n    material: true,\n    // data filter\n    _filterData: { type: 'function', value: null, optional: true }\n};\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on CPU. */\nexport default class CPUGridLayer extends AggregationLayer {\n    static { this.layerName = 'CPUGridLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        const cpuAggregator = new CPUAggregator({\n            getAggregator: props => props.gridAggregator,\n            getCellSize: props => props.cellSize\n        });\n        this.state = {\n            cpuAggregator,\n            aggregatorState: cpuAggregator.state\n        };\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: { size: 3, type: 'float64', accessor: 'getPosition' }\n        });\n        // color and elevation attributes can't be added as attributes\n        // they are calcualted using 'getValue' accessor that takes an array of pints.\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        this.setState({\n            // make a copy of the internal state of cpuAggregator for testing\n            aggregatorState: this.state.cpuAggregator.updateState(opts, {\n                viewport: this.context.viewport,\n                attributes: this.getAttributes(),\n                numInstances: this.getNumInstances()\n            })\n        });\n    }\n    getPickingInfo({ info }) {\n        return this.state.cpuAggregator.getPickingInfo({ info });\n    }\n    // create a method for testing\n    _onGetSublayerColor(cell) {\n        return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n    }\n    // create a method for testing\n    _onGetSublayerElevation(cell) {\n        return this.state.cpuAggregator.getAccessor('elevation')(cell);\n    }\n    _getSublayerUpdateTriggers() {\n        return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n    renderLayers() {\n        const { elevationScale, extruded, cellSize, coverage, material, transitions } = this.props;\n        const { cpuAggregator } = this.state;\n        const SubLayerClass = this.getSubLayerClass('grid-cell', GridCellLayer);\n        const updateTriggers = this._getSublayerUpdateTriggers();\n        return new SubLayerClass({\n            cellSize,\n            coverage,\n            material,\n            elevationScale,\n            extruded,\n            getFillColor: this._onGetSublayerColor.bind(this),\n            getElevation: this._onGetSublayerElevation.bind(this),\n            transitions: transitions && {\n                getFillColor: transitions.getColorValue || transitions.getColorWeight,\n                getElevation: transitions.getElevationValue || transitions.getElevationWeight\n            }\n        }, this.getSubLayerProps({\n            id: 'grid-cell',\n            updateTriggers\n        }), {\n            data: cpuAggregator.state.layerData.data\n        });\n    }\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from \"./bin-sorter.js\";\nimport { getScaleFunctionByScaleType } from \"./scale-utils.js\";\nimport { getValueFunc, wrapGetValueFunc } from \"./aggregation-operation-utils.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() { }\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n    {\n        key: 'fillColor',\n        accessor: 'getFillColor',\n        pickingInfo: 'colorValue',\n        getBins: {\n            triggers: {\n                value: {\n                    prop: 'getColorValue',\n                    updateTrigger: 'getColorValue'\n                },\n                weight: {\n                    prop: 'getColorWeight',\n                    updateTrigger: 'getColorWeight'\n                },\n                aggregation: {\n                    prop: 'colorAggregation'\n                },\n                filterData: {\n                    prop: '_filterData',\n                    updateTrigger: '_filterData'\n                }\n            }\n        },\n        getDomain: {\n            triggers: {\n                lowerPercentile: {\n                    prop: 'lowerPercentile'\n                },\n                upperPercentile: {\n                    prop: 'upperPercentile'\n                },\n                scaleType: {\n                    prop: 'colorScaleType'\n                }\n            }\n        },\n        getScaleFunc: {\n            triggers: {\n                domain: { prop: 'colorDomain' },\n                range: { prop: 'colorRange' }\n            },\n            onSet: {\n                props: 'onSetColorDomain'\n            }\n        },\n        nullValue: [0, 0, 0, 0]\n    },\n    {\n        key: 'elevation',\n        accessor: 'getElevation',\n        pickingInfo: 'elevationValue',\n        getBins: {\n            triggers: {\n                value: {\n                    prop: 'getElevationValue',\n                    updateTrigger: 'getElevationValue'\n                },\n                weight: {\n                    prop: 'getElevationWeight',\n                    updateTrigger: 'getElevationWeight'\n                },\n                aggregation: {\n                    prop: 'elevationAggregation'\n                },\n                filterData: {\n                    prop: '_filterData',\n                    updateTrigger: '_filterData'\n                }\n            }\n        },\n        getDomain: {\n            triggers: {\n                lowerPercentile: {\n                    prop: 'elevationLowerPercentile'\n                },\n                upperPercentile: {\n                    prop: 'elevationUpperPercentile'\n                },\n                scaleType: {\n                    prop: 'elevationScaleType'\n                }\n            }\n        },\n        getScaleFunc: {\n            triggers: {\n                domain: { prop: 'elevationDomain' },\n                range: { prop: 'elevationRange' }\n            },\n            onSet: {\n                props: 'onSetElevationDomain'\n            }\n        },\n        nullValue: -1\n    }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n    constructor(opts) {\n        this.state = {\n            layerData: {\n                data: undefined\n            },\n            dimensions: {\n            // color: {\n            //   getValue: null,\n            //   domain: null,\n            //   sortedBins: null,\n            //   scaleFunc: noop\n            // },\n            // elevation: {\n            //   getValue: null,\n            //   domain: null,\n            //   sortedBins: null,\n            //   scaleFunc: noop\n            // }\n            }\n        };\n        this.changeFlags = {};\n        this.dimensionUpdaters = {};\n        this._getCellSize = opts.getCellSize || defaultGetCellSize;\n        this._getAggregator = opts.getAggregator;\n        this._addDimension(opts.dimensions || defaultDimensions);\n    }\n    static defaultDimensions() {\n        return defaultDimensions;\n    }\n    updateState(opts, aggregationParams) {\n        const { oldProps, props, changeFlags } = opts;\n        this.updateGetValueFuncs(oldProps, props, changeFlags);\n        const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n        let aggregationDirty = false;\n        if (changeFlags.dataChanged || reprojectNeeded) {\n            // project data into bin and aggregate wegiths per bin\n            this.getAggregatedData(props, aggregationParams);\n            aggregationDirty = true;\n        }\n        else {\n            const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n            // this here is layer\n            dimensionChanges.forEach(f => typeof f === 'function' && f());\n            aggregationDirty = true;\n        }\n        this.setState({ aggregationDirty });\n        return this.state;\n    }\n    // Update private state\n    setState(updateObject) {\n        this.state = { ...this.state, ...updateObject };\n    }\n    // Update private state.dimensions\n    setDimensionState(key, updateObject) {\n        this.setState({\n            dimensions: {\n                ...this.state.dimensions,\n                [key]: { ...this.state.dimensions[key], ...updateObject }\n            }\n        });\n    }\n    normalizeResult(result = {}) {\n        // support previous hexagonAggregator API\n        if (result.hexagons) {\n            return { data: result.hexagons, ...result };\n        }\n        else if (result.layerData) {\n            return { data: result.layerData, ...result };\n        }\n        return result;\n    }\n    getAggregatedData(props, aggregationParams) {\n        const aggregator = this._getAggregator(props);\n        const result = aggregator(props, aggregationParams);\n        this.setState({\n            layerData: this.normalizeResult(result)\n        });\n        this.changeFlags = {\n            layerData: true\n        };\n        this.getSortedBins(props);\n    }\n    updateGetValueFuncs(oldProps, props, changeFlags) {\n        for (const key in this.dimensionUpdaters) {\n            const { value, weight, aggregation } = this.dimensionUpdaters[key].getBins.triggers;\n            let getValue = props[value.prop];\n            const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n            if (getValueChanged) {\n                if (getValue) {\n                    getValue = wrapGetValueFunc(getValue, { data: props.data });\n                }\n                else {\n                    // If `getValue` is not provided from props, build it with aggregation and weight.\n                    getValue = getValueFunc(props[aggregation.prop], props[weight.prop], { data: props.data });\n                }\n            }\n            if (getValue) {\n                this.setDimensionState(key, { getValue });\n            }\n        }\n    }\n    needsReProjectPoints(oldProps, props, changeFlags) {\n        return (this._getCellSize(oldProps) !== this._getCellSize(props) ||\n            this._getAggregator(oldProps) !== this._getAggregator(props) ||\n            (changeFlags.updateTriggersChanged &&\n                (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition)));\n    }\n    // Adds dimensions\n    addDimension(dimensions) {\n        this._addDimension(dimensions);\n    }\n    _addDimension(dimensions = []) {\n        dimensions.forEach(dimension => {\n            const { key } = dimension;\n            this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n            this.state.dimensions[key] = {\n                getValue: null,\n                domain: null,\n                sortedBins: null,\n                scaleFunc: noop\n            };\n        });\n    }\n    getDimensionUpdaters({ key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue }) {\n        return {\n            key,\n            accessor,\n            pickingInfo,\n            getBins: { updater: this.getDimensionSortedBins.bind(this), ...getBins },\n            getDomain: { updater: this.getDimensionValueDomain.bind(this), ...getDomain },\n            getScaleFunc: { updater: this.getDimensionScale.bind(this), ...getScaleFunc },\n            attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n        };\n    }\n    needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n        // whether need to update current dimension step\n        // dimension step is the value, domain, scaleFunction of each dimension\n        // each step is an object with properties links to layer prop and whether the prop is\n        // controlled by updateTriggers\n        // getBins: {\n        //   value: {\n        //     prop: 'getElevationValue',\n        //     updateTrigger: 'getElevationValue'\n        //   },\n        //   weight: {\n        //     prop: 'getElevationWeight',\n        //     updateTrigger: 'getElevationWeight'\n        //   },\n        //   aggregation: {\n        //     prop: 'elevationAggregation'\n        //   }\n        // }\n        return Object.values(dimensionStep.triggers).some((item) => {\n            if (item.updateTrigger) {\n                // check based on updateTriggers change first\n                // if data has changed, always update value\n                return (changeFlags.dataChanged ||\n                    (changeFlags.updateTriggersChanged &&\n                        (changeFlags.updateTriggersChanged.all ||\n                            changeFlags.updateTriggersChanged[item.updateTrigger])));\n            }\n            // fallback to direct comparison\n            return oldProps[item.prop] !== props[item.prop];\n        });\n    }\n    getDimensionChanges(oldProps, props, changeFlags) {\n        // const {dimensionUpdaters} = this.state;\n        const updaters = [];\n        // get dimension to be updated\n        for (const key in this.dimensionUpdaters) {\n            // return the first triggered updater for each dimension\n            const needUpdate = dimensionSteps.find(step => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));\n            if (needUpdate) {\n                updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));\n            }\n        }\n        return updaters.length ? updaters : null;\n    }\n    getUpdateTriggers(props) {\n        const _updateTriggers = props.updateTriggers || {};\n        const updateTriggers = {};\n        for (const key in this.dimensionUpdaters) {\n            const { accessor } = this.dimensionUpdaters[key];\n            // fold dimension triggers into each accessor\n            updateTriggers[accessor] = {};\n            dimensionSteps.forEach(step => {\n                Object.values(this.dimensionUpdaters[key][step].triggers).forEach(({ prop, updateTrigger }) => {\n                    if (updateTrigger) {\n                        // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n                        // and updateTriggers is passed in from layer prop\n                        // fold the updateTriggers into accessor\n                        const fromProp = _updateTriggers[updateTrigger];\n                        if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                            // if updateTrigger is an object spread it\n                            Object.assign(updateTriggers[accessor], fromProp);\n                        }\n                        else if (fromProp !== undefined) {\n                            updateTriggers[accessor][prop] = fromProp;\n                        }\n                    }\n                    else {\n                        // if prop is not based on updateTrigger\n                        updateTriggers[accessor][prop] = props[prop];\n                    }\n                });\n            });\n        }\n        return updateTriggers;\n    }\n    getSortedBins(props) {\n        for (const key in this.dimensionUpdaters) {\n            this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n        }\n    }\n    getDimensionSortedBins(props, dimensionUpdater) {\n        const { key } = dimensionUpdater;\n        const { getValue } = this.state.dimensions[key];\n        const sortedBins = new BinSorter(this.state.layerData.data || [], {\n            getValue,\n            filterData: props._filterData\n        });\n        this.setDimensionState(key, { sortedBins });\n        this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n    getDimensionValueDomain(props, dimensionUpdater) {\n        const { getDomain, key } = dimensionUpdater;\n        const { triggers: { lowerPercentile, upperPercentile, scaleType } } = getDomain;\n        const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n        this.setDimensionState(key, { valueDomain });\n        this.getDimensionScale(props, dimensionUpdater);\n    }\n    getDimensionScale(props, dimensionUpdater) {\n        const { key, getScaleFunc, getDomain } = dimensionUpdater;\n        const { domain, range } = getScaleFunc.triggers;\n        const { scaleType } = getDomain.triggers;\n        const { onSet } = getScaleFunc;\n        const dimensionRange = props[range.prop];\n        const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n        const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n        const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n        if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n            props[onSet.props](scaleFunc.domain());\n        }\n        this.setDimensionState(key, { scaleFunc });\n    }\n    getSubLayerDimensionAttribute(key, nullValue) {\n        return cell => {\n            const { sortedBins, scaleFunc } = this.state.dimensions[key];\n            const bin = sortedBins.binMap[cell.index];\n            if (bin && bin.counts === 0) {\n                // no points left in bin after filtering\n                return nullValue;\n            }\n            const cv = bin && bin.value;\n            const domain = scaleFunc.domain();\n            const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n            // if cell value is outside domain, set alpha to 0\n            return isValueInDomain ? scaleFunc(cv) : nullValue;\n        };\n    }\n    getSubLayerAccessors(props) {\n        const accessors = {};\n        for (const key in this.dimensionUpdaters) {\n            const { accessor } = this.dimensionUpdaters[key];\n            accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n        }\n        return accessors;\n    }\n    getPickingInfo({ info }) {\n        const isPicked = info.picked && info.index > -1;\n        let object = null;\n        if (isPicked) {\n            // const {sortedColorBins, sortedElevationBins} = this.state;\n            // @ts-expect-error\n            const cell = this.state.layerData.data[info.index];\n            const binInfo = {};\n            for (const key in this.dimensionUpdaters) {\n                const { pickingInfo } = this.dimensionUpdaters[key];\n                const { sortedBins } = this.state.dimensions[key];\n                const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n                binInfo[pickingInfo] = value;\n            }\n            object = Object.assign(binInfo, cell, {\n                points: cell.filteredPoints || cell.points\n            });\n        }\n        // override object with picked cell\n        info.picked = Boolean(object);\n        info.object = object;\n        return info;\n    }\n    getAccessor(dimensionKey) {\n        if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n            return noop;\n        }\n        return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { log } from '@deck.gl/core';\nimport { ColumnLayer } from '@deck.gl/layers';\nimport { defaultColorRange } from \"../utils/color-utils.js\";\nimport { pointToHexbin } from \"./hexagon-aggregator.js\";\nimport CPUAggregator from \"../utils/cpu-aggregator.js\";\nimport AggregationLayer from \"../aggregation-layer.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction nop() { }\nconst defaultProps = {\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorValue: { type: 'accessor', value: null }, // default value is calcuated from `getColorWeight` and `colorAggregation`\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    lowerPercentile: { type: 'number', value: 0, min: 0, max: 100 },\n    upperPercentile: { type: 'number', value: 100, min: 0, max: 100 },\n    colorScaleType: 'quantize',\n    onSetColorDomain: nop,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationValue: { type: 'accessor', value: null }, // default value is calcuated from `getElevationWeight` and `elevationAggregation`\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationLowerPercentile: { type: 'number', value: 0, min: 0, max: 100 },\n    elevationUpperPercentile: { type: 'number', value: 100, min: 0, max: 100 },\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    elevationScaleType: 'linear',\n    onSetElevationDomain: nop,\n    radius: { type: 'number', value: 1000, min: 1 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    extruded: false,\n    hexagonAggregator: pointToHexbin,\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    // Optional material for 'lighting' shader module\n    material: true,\n    // data filter\n    _filterData: { type: 'function', value: null, optional: true }\n};\n/** Aggregates data into a hexagon-based heatmap. The color and height of a hexagon are determined based on the objects it contains. */\nexport default class HexagonLayer extends AggregationLayer {\n    static { this.layerName = 'HexagonLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        const cpuAggregator = new CPUAggregator({\n            getAggregator: props => props.hexagonAggregator,\n            getCellSize: props => props.radius\n        });\n        this.state = {\n            cpuAggregator,\n            aggregatorState: cpuAggregator.state,\n            vertices: null\n        };\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: { size: 3, type: 'float64', accessor: 'getPosition' }\n        });\n        // color and elevation attributes can't be added as attributes\n        // they are calculated using 'getValue' accessor that takes an array of pints.\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        if (opts.changeFlags.propsOrDataChanged) {\n            const aggregatorState = this.state.cpuAggregator.updateState(opts, {\n                viewport: this.context.viewport,\n                attributes: this.getAttributes()\n            });\n            if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {\n                // if user provided custom aggregator and returns hexagonVertices,\n                // Need to recalculate radius and angle based on vertices\n                // @ts-expect-error\n                const { hexagonVertices } = aggregatorState.layerData || {};\n                this.setState({\n                    vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)\n                });\n            }\n            this.setState({\n                // make a copy of the internal state of cpuAggregator for testing\n                aggregatorState\n            });\n        }\n    }\n    convertLatLngToMeterOffset(hexagonVertices) {\n        const { viewport } = this.context;\n        if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {\n            // get centroid of hexagons\n            const vertex0 = hexagonVertices[0];\n            const vertex3 = hexagonVertices[3];\n            const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];\n            const centroidFlat = viewport.projectFlat(centroid);\n            const { metersPerUnit } = viewport.getDistanceScales(centroid);\n            // offset all points by centroid to meter offset\n            const vertices = hexagonVertices.map(vt => {\n                const vtFlat = viewport.projectFlat(vt);\n                return [\n                    (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],\n                    (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]\n                ];\n            });\n            return vertices;\n        }\n        log.error('HexagonLayer: hexagonVertices needs to be an array of 6 points')();\n        return null;\n    }\n    getPickingInfo({ info }) {\n        return this.state.cpuAggregator.getPickingInfo({ info });\n    }\n    // create a method for testing\n    _onGetSublayerColor(cell) {\n        return this.state.cpuAggregator.getAccessor('fillColor')(cell);\n    }\n    // create a method for testing\n    _onGetSublayerElevation(cell) {\n        return this.state.cpuAggregator.getAccessor('elevation')(cell);\n    }\n    _getSublayerUpdateTriggers() {\n        return this.state.cpuAggregator.getUpdateTriggers(this.props);\n    }\n    renderLayers() {\n        const { elevationScale, extruded, coverage, material, transitions } = this.props;\n        const { aggregatorState, vertices } = this.state;\n        const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n        const updateTriggers = this._getSublayerUpdateTriggers();\n        const geometry = vertices\n            ? { vertices, radius: 1 }\n            : {\n                // default geometry\n                // @ts-expect-error TODO - undefined property?\n                radius: aggregatorState.layerData.radiusCommon || 1,\n                radiusUnits: 'common',\n                angle: 90\n            };\n        return new SubLayerClass({\n            ...geometry,\n            diskResolution: 6,\n            elevationScale,\n            extruded,\n            coverage,\n            material,\n            getFillColor: this._onGetSublayerColor.bind(this),\n            getElevation: this._onGetSublayerElevation.bind(this),\n            transitions: transitions && {\n                getFillColor: transitions.getColorValue || transitions.getColorWeight,\n                getElevation: transitions.getElevationValue || transitions.getElevationWeight\n            }\n        }, this.getSubLayerProps({\n            id: 'hexagon-cell',\n            updateTriggers\n        }), {\n            data: aggregatorState.layerData.data\n        });\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { hexbin } from 'd3-hexbin';\nimport { createIterable, log } from '@deck.gl/core';\n/**\n * Use d3-hexbin to performs hexagonal binning from geo points to hexagons\n * @param {Iterable} data - array of points\n * @param {Number} radius - hexagon radius in meter\n * @param {function} getPosition - get points lon lat\n * @param {Object} viewport - current viewport object\n\n * @return {Object} - hexagons and countRange\n */\nexport function pointToHexbin(props, aggregationParams) {\n    const { data, radius } = props;\n    const { viewport, attributes } = aggregationParams;\n    // get hexagon radius in mercator world unit\n    const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;\n    const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);\n    // add world space coordinates to points\n    const screenPoints = [];\n    const { iterable, objectInfo } = createIterable(data);\n    const positions = attributes.positions.value;\n    const { size } = attributes.positions.getAccessor();\n    for (const object of iterable) {\n        objectInfo.index++;\n        const posIndex = objectInfo.index * size;\n        const position = [positions[posIndex], positions[posIndex + 1]];\n        const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);\n        if (arrayIsFinite) {\n            screenPoints.push({\n                screenCoord: viewport.projectFlat(position),\n                source: object,\n                index: objectInfo.index\n            });\n        }\n        else {\n            log.warn('HexagonLayer: invalid position')();\n        }\n    }\n    const newHexbin = hexbin()\n        .radius(radiusCommon)\n        .x(d => d.screenCoord[0])\n        .y(d => d.screenCoord[1]);\n    const hexagonBins = newHexbin(screenPoints);\n    return {\n        hexagons: hexagonBins.map((hex, index) => ({\n            position: viewport.unprojectFlat([hex.x, hex.y]),\n            points: hex,\n            index\n        })),\n        radiusCommon\n    };\n}\n/**\n * Get the bounding box of all data points\n */\nexport function getPointsCenter(data, aggregationParams) {\n    const { attributes } = aggregationParams;\n    const positions = attributes.positions.value;\n    const { size } = attributes.positions.getAccessor();\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let i;\n    for (i = 0; i < size * data.length; i += size) {\n        const x = positions[i];\n        const y = positions[i + 1];\n        const arrayIsFinite = Number.isFinite(x) && Number.isFinite(y);\n        if (arrayIsFinite) {\n            minX = Math.min(x, minX);\n            maxX = Math.max(x, maxX);\n            minY = Math.min(y, minY);\n            maxY = Math.max(y, maxY);\n        }\n    }\n    // return center\n    return [minX, minY, maxX, maxY].every(Number.isFinite)\n        ? [(minX + maxX) / 2, (minY + maxY) / 2]\n        : null;\n}\n/**\n * Get radius in mercator world space coordinates from meter\n * @param {Number} radius - in meter\n * @param {Object} viewport - current viewport object\n * @param {Array<Number>} center - data center\n\n * @return {Number} radius in mercator world spcae coordinates\n */\nexport function getRadiusInCommon(radius, viewport, center) {\n    const { unitsPerMeter } = viewport.getDistanceScales(center);\n    // x, y distance should be the same\n    return radius * unitsPerMeter[0];\n}\n", "// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { LineLayer, SolidPolygonLayer } from '@deck.gl/layers';\nimport { generateContours } from \"./contour-utils.js\";\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from \"../utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nimport { AGGREGATION_OPERATION, getValueFunc } from \"../utils/aggregation-operation-utils.js\";\nimport { getBoundingBox, getGridParams } from \"../utils/grid-aggregation-utils.js\";\nimport GridAggregationLayer from \"../grid-aggregation-layer.js\";\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_THRESHOLD = 1;\nconst defaultProps = {\n    // grid aggregation\n    cellSize: { type: 'number', min: 1, max: 1000, value: 1000 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getWeight: { type: 'accessor', value: 1 },\n    gpuAggregation: false, // TODO(v9): Re-enable GPU aggregation.\n    aggregation: 'SUM',\n    // contour lines\n    contours: {\n        type: 'object',\n        value: [{ threshold: DEFAULT_THRESHOLD }],\n        optional: true,\n        compare: 3\n    },\n    zOffset: 0.005\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n    data: {\n        props: ['cellSize']\n    },\n    weights: {\n        props: ['aggregation'],\n        accessors: ['getWeight']\n    }\n};\n/** Aggregate data into iso-lines or iso-bands for a given threshold and cell size. */\nexport default class ContourLayer extends GridAggregationLayer {\n    static { this.layerName = 'ContourLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        super.initializeAggregationLayer({\n            dimensions: DIMENSIONS\n        });\n        this.setState({\n            contourData: {},\n            projectPoints: false,\n            weights: {\n                count: {\n                    size: 1,\n                    operation: AGGREGATION_OPERATION.SUM\n                }\n            }\n        });\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            [POSITION_ATTRIBUTE_NAME]: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            // this attribute is used in gpu aggregation path only\n            count: { size: 3, accessor: 'getWeight' }\n        });\n    }\n    updateState(opts) {\n        super.updateState(opts);\n        let contoursChanged = false;\n        const { oldProps, props } = opts;\n        const { aggregationDirty } = this.state;\n        if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {\n            contoursChanged = true;\n            this._updateThresholdData(opts.props);\n        }\n        if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {\n            this._generateContours();\n        }\n    }\n    renderLayers() {\n        const { contourSegments, contourPolygons } = this.state.contourData;\n        const LinesSubLayerClass = this.getSubLayerClass('lines', LineLayer);\n        const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n        // Contour lines layer\n        const lineLayer = contourSegments &&\n            contourSegments.length > 0 &&\n            new LinesSubLayerClass(this.getSubLayerProps({\n                id: 'lines'\n            }), {\n                data: this.state.contourData.contourSegments,\n                getSourcePosition: d => d.start,\n                getTargetPosition: d => d.end,\n                getColor: d => d.contour.color || DEFAULT_COLOR,\n                getWidth: d => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH\n            });\n        // Contour bands layer\n        const bandsLayer = contourPolygons &&\n            contourPolygons.length > 0 &&\n            new BandsSubLayerClass(this.getSubLayerProps({\n                id: 'bands'\n            }), {\n                data: this.state.contourData.contourPolygons,\n                getPolygon: d => d.vertices,\n                getFillColor: d => d.contour.color || DEFAULT_COLOR\n            });\n        return [lineLayer, bandsLayer];\n    }\n    // Aggregation Overrides\n    /* eslint-disable max-statements, complexity */\n    updateAggregationState(opts) {\n        const { props, oldProps } = opts;\n        const { cellSize, coordinateSystem } = props;\n        const { viewport } = this.context;\n        const cellSizeChanged = oldProps.cellSize !== cellSize;\n        let gpuAggregation = props.gpuAggregation;\n        if (this.state.gpuAggregation !== props.gpuAggregation) {\n            if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {\n                log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n                gpuAggregation = false;\n            }\n        }\n        const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n        this.setState({\n            gpuAggregation\n        });\n        const { dimensions } = this.state;\n        const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n        const { data, weights } = dimensions;\n        let { boundingBox } = this.state;\n        if (positionsChanged) {\n            boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n            this.setState({ boundingBox });\n        }\n        if (positionsChanged || cellSizeChanged) {\n            const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n            this.allocateResources(numRow, numCol);\n            this.setState({\n                gridOffset,\n                boundingBox,\n                translation,\n                posOffset: translation.slice(), // Used for CPU aggregation, to offset points\n                gridOrigin: [-1 * translation[0], -1 * translation[1]],\n                width,\n                height,\n                numCol,\n                numRow\n            });\n        }\n        const aggregationDataDirty = positionsChanged ||\n            gpuAggregationChanged ||\n            this.isAggregationDirty(opts, {\n                dimension: data,\n                compareAll: gpuAggregation // check for all (including extentions props) when using gpu aggregation\n            });\n        const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n            dimension: weights\n        });\n        if (aggregationWeightsDirty) {\n            this._updateAccessors(opts);\n        }\n        if (aggregationDataDirty || aggregationWeightsDirty) {\n            this._resetResults();\n        }\n        this.setState({\n            aggregationDataDirty,\n            aggregationWeightsDirty\n        });\n    }\n    /* eslint-enable max-statements, complexity */\n    // Private (Aggregation)\n    _updateAccessors(opts) {\n        const { getWeight, aggregation, data } = opts.props;\n        const { count } = this.state.weights;\n        if (count) {\n            count.getWeight = getWeight;\n            count.operation = AGGREGATION_OPERATION[aggregation];\n        }\n        this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });\n    }\n    _resetResults() {\n        const { count } = this.state.weights;\n        if (count) {\n            count.aggregationData = null;\n        }\n    }\n    // Private (Contours)\n    _generateContours() {\n        const { numCol, numRow, gridOrigin, gridOffset, thresholdData } = this.state;\n        const { count } = this.state.weights;\n        let { aggregationData } = count;\n        if (!aggregationData) {\n            // @ts-ignore\n            aggregationData = count.aggregationBuffer.readSyncWebGL();\n            count.aggregationData = aggregationData;\n        }\n        const { cellWeights } = GPUGridAggregator.getCellData({ countsData: aggregationData });\n        const contourData = generateContours({\n            thresholdData,\n            cellWeights,\n            gridSize: [numCol, numRow],\n            gridOrigin,\n            cellSize: [gridOffset.xOffset, gridOffset.yOffset]\n        });\n        // contourData contains both iso-lines and iso-bands if requested.\n        this.setState({ contourData });\n    }\n    _updateThresholdData(props) {\n        const { contours, zOffset } = props;\n        const count = contours.length;\n        const thresholdData = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const contour = contours[i];\n            thresholdData[i] = {\n                contour,\n                zIndex: contour.zIndex || i,\n                zOffset\n            };\n        }\n        this.setState({ thresholdData });\n    }\n}\n", "// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\nimport { log } from '@deck.gl/core';\nimport { ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP } from \"./marching-squares-codes.js\";\nexport const CONTOUR_TYPE = {\n    ISO_LINES: 1,\n    ISO_BANDS: 2\n};\nconst DEFAULT_THRESHOLD_DATA = {\n    zIndex: 0,\n    zOffset: 0.005\n};\n// Utility methods\nfunction getVertexCode(weight, threshold) {\n    // threshold must be a single value or a range (array of size 2)\n    // Iso-bands\n    if (Array.isArray(threshold)) {\n        if (weight < threshold[0]) {\n            return 0;\n        }\n        return weight < threshold[1] ? 1 : 2;\n    }\n    // Iso-lines\n    return weight >= threshold ? 1 : 0;\n}\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts) {\n    // Assumptions\n    // Origin is on bottom-left , and X increase to right, Y to top\n    // When processing one cell, we process 4 cells, by extending row to top and on column to right\n    // to create a 2X2 cell grid\n    const { cellWeights, x, y, width, height } = opts;\n    let threshold = opts.threshold;\n    if (opts.thresholdValue) {\n        log.deprecated('thresholdValue', 'threshold')();\n        threshold = opts.thresholdValue;\n    }\n    const isLeftBoundary = x < 0;\n    const isRightBoundary = x >= width - 1;\n    const isBottomBoundary = y < 0;\n    const isTopBoundary = y >= height - 1;\n    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n    const weights = {};\n    const codes = {};\n    // TOP\n    if (isLeftBoundary || isTopBoundary) {\n        codes.top = 0;\n    }\n    else {\n        weights.top = cellWeights[(y + 1) * width + x];\n        codes.top = getVertexCode(weights.top, threshold);\n    }\n    // TOP-RIGHT\n    if (isRightBoundary || isTopBoundary) {\n        codes.topRight = 0;\n    }\n    else {\n        weights.topRight = cellWeights[(y + 1) * width + x + 1];\n        codes.topRight = getVertexCode(weights.topRight, threshold);\n    }\n    // RIGHT\n    if (isRightBoundary || isBottomBoundary) {\n        codes.right = 0;\n    }\n    else {\n        weights.right = cellWeights[y * width + x + 1];\n        codes.right = getVertexCode(weights.right, threshold);\n    }\n    // CURRENT\n    if (isLeftBoundary || isBottomBoundary) {\n        codes.current = 0;\n    }\n    else {\n        weights.current = cellWeights[y * width + x];\n        codes.current = getVertexCode(weights.current, threshold);\n    }\n    const { top, topRight, right, current } = codes;\n    let code = -1;\n    if (Number.isFinite(threshold)) {\n        code = (top << 3) | (topRight << 2) | (right << 1) | current;\n    }\n    if (Array.isArray(threshold)) {\n        code = (top << 6) | (topRight << 4) | (right << 2) | current;\n    }\n    let meanCode = 0;\n    // meanCode is only needed for saddle cases, and they should\n    // only occur when we are not processing a cell on boundary\n    // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n    if (!isBoundary) {\n        meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold);\n    }\n    return { code, meanCode };\n}\n/* eslint-enable complexity, max-statements*/\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getVertices(opts) {\n    const { gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES } = opts;\n    const thresholdData = { ...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData };\n    let offsets = type === CONTOUR_TYPE.ISO_BANDS\n        ? ISOBANDS_CODE_OFFSET_MAP[code]\n        : ISOLINES_CODE_OFFSET_MAP[code];\n    // handle saddle cases\n    if (!Array.isArray(offsets)) {\n        offsets = offsets[meanCode];\n    }\n    // Reference vertex is at top-right move to top-right corner\n    const vZ = thresholdData.zIndex * thresholdData.zOffset;\n    const rX = (x + 1) * cellSize[0];\n    const rY = (y + 1) * cellSize[1];\n    const refVertexX = gridOrigin[0] + rX;\n    const refVertexY = gridOrigin[1] + rY;\n    // offsets format\n    // ISO_LINES: [[1A, 1B], [2A, 2B]],\n    // ISO_BANDS: [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n    // vertices format\n    // ISO_LINES: [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n    // ISO_BANDS:  => confirms to SolidPolygonLayer's simple polygon format\n    //      [\n    //        [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n    //        ...\n    //      ]\n    if (type === CONTOUR_TYPE.ISO_BANDS) {\n        const polygons = [];\n        offsets.forEach(polygonOffsets => {\n            const polygon = [];\n            polygonOffsets.forEach(xyOffset => {\n                const vX = refVertexX + xyOffset[0] * cellSize[0];\n                const vY = refVertexY + xyOffset[1] * cellSize[1];\n                polygon.push([vX, vY, vZ]);\n            });\n            polygons.push(polygon);\n        });\n        return polygons;\n    }\n    // default case is ISO_LINES\n    const lines = [];\n    offsets.forEach(xyOffsets => {\n        xyOffsets.forEach(offset => {\n            const vX = refVertexX + offset[0] * cellSize[0];\n            const vY = refVertexY + offset[1] * cellSize[1];\n            lines.push([vX, vY, vZ]);\n        });\n    });\n    return lines;\n}\n", "// Code to Offsets Map needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n// Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\nconst HALF = 0.5;\nconst ONE6TH = 1 / 6;\nconst OFFSET = {\n    N: [0, HALF], // NORTH\n    E: [HALF, 0], // EAST\n    S: [0, -HALF], // SOUTH\n    W: [-HALF, 0], // WEST\n    // CORNERS\n    NE: [HALF, HALF],\n    NW: [-HALF, HALF],\n    SE: [HALF, -HALF],\n    SW: [-HALF, -HALF]\n};\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\n// Triangles\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\n// Trapezoids\nconst SW_TRAPEZOID = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF]\n];\nconst SE_TRAPEZOID = [\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH]\n];\nconst NE_TRAPEZOID = [\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\nconst NW_TRAPEZOID = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Rectangles\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\nconst EW_RECTANGEL = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH]\n];\nconst SN_RECTANGEL = [\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Square\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\n// Pentagons\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\n// Hexagon\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\n// Heptagon (7-sided)\nconst NE_HEPTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    OFFSET.E,\n    OFFSET.NE,\n    OFFSET.N\n];\nconst SW_HEPTAGON = [\n    OFFSET.W,\n    OFFSET.SW,\n    OFFSET.S,\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\nconst NW_HEPTAGON = [\n    OFFSET.NW,\n    OFFSET.W,\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    OFFSET.N\n];\nconst SE_HEPTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    OFFSET.S,\n    OFFSET.SE,\n    OFFSET.E,\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Octagon\nconst OCTAGON = [\n    [-HALF, ONE6TH],\n    [-HALF, -ONE6TH],\n    [-ONE6TH, -HALF],\n    [ONE6TH, -HALF],\n    [HALF, -ONE6TH],\n    [HALF, ONE6TH],\n    [ONE6TH, HALF],\n    [-ONE6TH, HALF]\n];\n// Note: above wiki page invertes white/black dots for generating the code, we don't\nexport const ISOLINES_CODE_OFFSET_MAP = {\n    // key is equal to the code of 4 vertices (invert the code specified in wiki)\n    // value can be an array or an Object\n    // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\n    // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\n    //  key: code of mean value (0 or 1)\n    //  value: Array , as above defines one or two line segments\n    0: [],\n    1: [[OFFSET.W, OFFSET.S]],\n    2: [[OFFSET.S, OFFSET.E]],\n    3: [[OFFSET.W, OFFSET.E]],\n    4: [[OFFSET.N, OFFSET.E]],\n    5: {\n        0: [\n            [OFFSET.W, OFFSET.S],\n            [OFFSET.N, OFFSET.E]\n        ],\n        1: [\n            [OFFSET.W, OFFSET.N],\n            [OFFSET.S, OFFSET.E]\n        ]\n    },\n    6: [[OFFSET.N, OFFSET.S]],\n    7: [[OFFSET.W, OFFSET.N]],\n    8: [[OFFSET.W, OFFSET.N]],\n    9: [[OFFSET.N, OFFSET.S]],\n    10: {\n        0: [\n            [OFFSET.W, OFFSET.N],\n            [OFFSET.S, OFFSET.E]\n        ],\n        1: [\n            [OFFSET.W, OFFSET.S],\n            [OFFSET.N, OFFSET.E]\n        ]\n    },\n    11: [[OFFSET.N, OFFSET.E]],\n    12: [[OFFSET.W, OFFSET.E]],\n    13: [[OFFSET.S, OFFSET.E]],\n    14: [[OFFSET.W, OFFSET.S]],\n    15: []\n};\nfunction ternaryToIndex(ternary) {\n    return parseInt(ternary, 4);\n}\nexport const ISOBANDS_CODE_OFFSET_MAP = {\n    // Below list of cases, follow the same order as in above mentioned wiki page.\n    // Each case has its code on first commented line // T,TR,R,C\n    // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\n    // final code is binary representation of above code , where takes 2 digits\n    // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\n    // no contours\n    [ternaryToIndex('0000')]: [],\n    [ternaryToIndex('2222')]: [],\n    // single triangle\n    [ternaryToIndex('2221')]: [SW_TRIANGLE],\n    [ternaryToIndex('2212')]: [SE_TRIANGLE],\n    [ternaryToIndex('2122')]: [NE_TRIANGLE],\n    [ternaryToIndex('1222')]: [NW_TRIANGLE],\n    [ternaryToIndex('0001')]: [SW_TRIANGLE],\n    [ternaryToIndex('0010')]: [SE_TRIANGLE],\n    [ternaryToIndex('0100')]: [NE_TRIANGLE],\n    [ternaryToIndex('1000')]: [NW_TRIANGLE],\n    // single trapezoid\n    [ternaryToIndex('2220')]: [SW_TRAPEZOID],\n    [ternaryToIndex('2202')]: [SE_TRAPEZOID],\n    [ternaryToIndex('2022')]: [NE_TRAPEZOID],\n    [ternaryToIndex('0222')]: [NW_TRAPEZOID],\n    [ternaryToIndex('0002')]: [SW_TRAPEZOID],\n    [ternaryToIndex('0020')]: [SE_TRAPEZOID],\n    [ternaryToIndex('0200')]: [NE_TRAPEZOID],\n    [ternaryToIndex('2000')]: [NW_TRAPEZOID],\n    // single rectangle\n    [ternaryToIndex('0011')]: [S_RECTANGLE],\n    [ternaryToIndex('0110')]: [E_RECTANGLE],\n    [ternaryToIndex('1100')]: [N_RECTANGLE],\n    [ternaryToIndex('1001')]: [W_RECTANGLE],\n    [ternaryToIndex('2211')]: [S_RECTANGLE],\n    [ternaryToIndex('2112')]: [E_RECTANGLE],\n    [ternaryToIndex('1122')]: [N_RECTANGLE],\n    [ternaryToIndex('1221')]: [W_RECTANGLE],\n    [ternaryToIndex('2200')]: [EW_RECTANGEL],\n    [ternaryToIndex('2002')]: [SN_RECTANGEL],\n    [ternaryToIndex('0022')]: [EW_RECTANGEL],\n    [ternaryToIndex('0220')]: [SN_RECTANGEL],\n    // single square\n    // 1111\n    [ternaryToIndex('1111')]: [SQUARE],\n    // single pentagon\n    [ternaryToIndex('1211')]: [SW_PENTAGON],\n    [ternaryToIndex('2111')]: [SE_PENTAGON],\n    [ternaryToIndex('1112')]: [NE_PENTAGON],\n    [ternaryToIndex('1121')]: [NW_PENTAGON],\n    [ternaryToIndex('1011')]: [SW_PENTAGON],\n    [ternaryToIndex('0111')]: [SE_PENTAGON],\n    [ternaryToIndex('1110')]: [NE_PENTAGON],\n    [ternaryToIndex('1101')]: [NW_PENTAGON],\n    [ternaryToIndex('1200')]: [NW_N_PENTAGON],\n    [ternaryToIndex('0120')]: [NE_E_PENTAGON],\n    [ternaryToIndex('0012')]: [SE_S_PENTAGON],\n    [ternaryToIndex('2001')]: [SW_W_PENTAGON],\n    [ternaryToIndex('1022')]: [NW_N_PENTAGON],\n    [ternaryToIndex('2102')]: [NE_E_PENTAGON],\n    [ternaryToIndex('2210')]: [SE_S_PENTAGON],\n    [ternaryToIndex('0221')]: [SW_W_PENTAGON],\n    [ternaryToIndex('1002')]: [NW_W_PENTAGON],\n    [ternaryToIndex('2100')]: [NE_N_PENTAGON],\n    [ternaryToIndex('0210')]: [SE_E_PENTAGON],\n    [ternaryToIndex('0021')]: [SW_S_PENTAGON],\n    [ternaryToIndex('1220')]: [NW_W_PENTAGON],\n    [ternaryToIndex('0122')]: [NE_N_PENTAGON],\n    [ternaryToIndex('2012')]: [SE_E_PENTAGON],\n    [ternaryToIndex('2201')]: [SW_S_PENTAGON],\n    // single hexagon\n    [ternaryToIndex('0211')]: [S_HEXAGON],\n    [ternaryToIndex('2110')]: [E_HEXAGON],\n    [ternaryToIndex('1102')]: [N_HEXAGON],\n    [ternaryToIndex('1021')]: [W_HEXAGON],\n    [ternaryToIndex('2011')]: [S_HEXAGON],\n    [ternaryToIndex('0112')]: [E_HEXAGON],\n    [ternaryToIndex('1120')]: [N_HEXAGON],\n    [ternaryToIndex('1201')]: [W_HEXAGON],\n    [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\n    [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\n    [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\n    [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\n    // 6-sided polygons based on mean weight\n    // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\n    [ternaryToIndex('0101')]: {\n        0: [SW_TRIANGLE, NE_TRIANGLE],\n        1: [SW_NE_HEXAGON],\n        2: [SW_NE_HEXAGON]\n    },\n    [ternaryToIndex('1010')]: {\n        0: [NW_TRIANGLE, SE_TRIANGLE],\n        1: [NW_SE_HEXAGON],\n        2: [NW_SE_HEXAGON]\n    },\n    [ternaryToIndex('2121')]: {\n        0: [SW_NE_HEXAGON],\n        1: [SW_NE_HEXAGON],\n        2: [SW_TRIANGLE, NE_TRIANGLE]\n    },\n    [ternaryToIndex('1212')]: {\n        0: [NW_SE_HEXAGON],\n        1: [NW_SE_HEXAGON],\n        2: [NW_TRIANGLE, SE_TRIANGLE]\n    },\n    // 7-sided polygons based on mean weight\n    [ternaryToIndex('2120')]: {\n        0: [NE_HEPTAGON],\n        1: [NE_HEPTAGON],\n        2: [SW_TRAPEZOID, NE_TRIANGLE]\n    },\n    [ternaryToIndex('2021')]: {\n        0: [SW_HEPTAGON],\n        1: [SW_HEPTAGON],\n        2: [SW_TRIANGLE, NE_TRAPEZOID]\n    },\n    [ternaryToIndex('1202')]: {\n        0: [NW_HEPTAGON],\n        1: [NW_HEPTAGON],\n        2: [NW_TRIANGLE, SE_TRAPEZOID]\n    },\n    [ternaryToIndex('0212')]: {\n        0: [SE_HEPTAGON],\n        1: [SE_HEPTAGON],\n        2: [SE_TRIANGLE, NW_TRAPEZOID]\n    },\n    [ternaryToIndex('0102')]: {\n        0: [SW_TRAPEZOID, NE_TRIANGLE],\n        1: [NE_HEPTAGON],\n        2: [NE_HEPTAGON]\n    },\n    [ternaryToIndex('0201')]: {\n        0: [SW_TRIANGLE, NE_TRAPEZOID],\n        1: [SW_HEPTAGON],\n        2: [SW_HEPTAGON]\n    },\n    [ternaryToIndex('1020')]: {\n        0: [NW_TRIANGLE, SE_TRAPEZOID],\n        1: [NW_HEPTAGON],\n        2: [NW_HEPTAGON]\n    },\n    [ternaryToIndex('2010')]: {\n        0: [SE_TRIANGLE, NW_TRAPEZOID],\n        1: [SE_HEPTAGON],\n        2: [SE_HEPTAGON]\n    },\n    // 8-sided polygons based on mean weight\n    [ternaryToIndex('2020')]: {\n        0: [NW_TRAPEZOID, SE_TRAPEZOID],\n        1: [OCTAGON],\n        2: [SW_TRAPEZOID, NE_TRAPEZOID]\n    },\n    [ternaryToIndex('0202')]: {\n        0: [NE_TRAPEZOID, SW_TRAPEZOID],\n        1: [OCTAGON],\n        2: [NW_TRAPEZOID, SE_TRAPEZOID]\n    }\n};\n", "import { getCode, getVertices, CONTOUR_TYPE } from \"./marching-squares.js\";\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({ thresholdData, cellWeights, gridSize, gridOrigin, cellSize }) {\n    const contourSegments = [];\n    const contourPolygons = [];\n    const width = gridSize[0];\n    const height = gridSize[1];\n    let segmentIndex = 0;\n    let polygonIndex = 0;\n    for (const data of thresholdData) {\n        const { contour } = data;\n        const { threshold } = contour;\n        for (let x = -1; x < width; x++) {\n            for (let y = -1; y < height; y++) {\n                // Get the MarchingSquares code based on neighbor cell weights.\n                const { code, meanCode } = getCode({\n                    cellWeights,\n                    threshold,\n                    x,\n                    y,\n                    width,\n                    height\n                });\n                const opts = {\n                    type: CONTOUR_TYPE.ISO_BANDS,\n                    gridOrigin,\n                    cellSize,\n                    x,\n                    y,\n                    width,\n                    height,\n                    code,\n                    meanCode,\n                    thresholdData: data\n                };\n                if (Array.isArray(threshold)) {\n                    opts.type = CONTOUR_TYPE.ISO_BANDS;\n                    const polygons = getVertices(opts);\n                    for (const polygon of polygons) {\n                        contourPolygons[polygonIndex++] = {\n                            vertices: polygon,\n                            contour\n                        };\n                    }\n                }\n                else {\n                    // Get the intersection vertices based on MarchingSquares code.\n                    opts.type = CONTOUR_TYPE.ISO_LINES;\n                    const vertices = getVertices(opts);\n                    for (let i = 0; i < vertices.length; i += 2) {\n                        contourSegments[segmentIndex++] = {\n                            start: vertices[i],\n                            end: vertices[i + 1],\n                            contour\n                        };\n                    }\n                }\n            }\n        }\n    }\n    return { contourSegments, contourPolygons };\n}\n/* eslint-enable max-depth */\n", "import { CompositeLayer } from '@deck.gl/core';\nimport GPUGridAggregator from \"../utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nimport GPUGridLayer from \"../gpu-grid-layer/gpu-grid-layer.js\";\nimport CPUGridLayer from \"../cpu-grid-layer/cpu-grid-layer.js\";\nconst defaultProps = {\n    ...GPUGridLayer.defaultProps,\n    ...CPUGridLayer.defaultProps,\n    gpuAggregation: false\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer extends CompositeLayer {\n    static { this.layerName = 'GridLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        this.state = {\n            useGPUAggregation: false // TODO(v9): Re-enable GPU aggregation.\n        };\n    }\n    updateState({ props }) {\n        this.setState({\n            // TODO(v9): Re-enable GPU aggregation.\n            // useGPUAggregation: this.canUseGPUAggregation(props)\n            useGPUAggregation: false\n        });\n    }\n    renderLayers() {\n        const { data, updateTriggers } = this.props;\n        const id = this.state.useGPUAggregation ? 'GPU' : 'CPU';\n        const LayerType = this.state.useGPUAggregation\n            ? this.getSubLayerClass('GPU', GPUGridLayer)\n            : this.getSubLayerClass('CPU', CPUGridLayer);\n        return new LayerType(this.props, this.getSubLayerProps({\n            id,\n            updateTriggers\n        }), {\n            data\n        });\n    }\n    // Private methods\n    canUseGPUAggregation(props) {\n        const { gpuAggregation, lowerPercentile, upperPercentile, getColorValue, getElevationValue, colorScaleType } = props;\n        if (!gpuAggregation) {\n            // cpu aggregation is requested\n            return false;\n        }\n        if (!GPUGridAggregator.isSupported(this.context.device)) {\n            return false;\n        }\n        if (lowerPercentile !== 0 || upperPercentile !== 100) {\n            // percentile calculations requires sorting not supported on GPU\n            return false;\n        }\n        if (getColorValue !== null || getElevationValue !== null) {\n            // accessor for custom color or elevation calculation is specified\n            return false;\n        }\n        if (colorScaleType === 'quantile' || colorScaleType === 'ordinal') {\n            // quantile and ordinal scales are not supported on GPU\n            return false;\n        }\n        return true;\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { GL } from '@luma.gl/constants';\nimport { log } from '@deck.gl/core';\nimport GPUGridAggregator from \"../utils/gpu-grid-aggregation/gpu-grid-aggregator.js\";\nimport { AGGREGATION_OPERATION } from \"../utils/aggregation-operation-utils.js\";\nimport { defaultColorRange, colorRangeToFlatArray } from \"../utils/color-utils.js\";\nimport GPUGridCellLayer from \"./gpu-grid-cell-layer.js\";\nimport { pointToDensityGridDataCPU } from \"./../cpu-grid-layer/grid-aggregator.js\";\nimport GridAggregationLayer from \"../grid-aggregation-layer.js\";\nimport { getBoundingBox, getGridParams } from \"../utils/grid-aggregation-utils.js\";\nconst defaultProps = {\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    // grid\n    cellSize: { type: 'number', min: 1, max: 1000, value: 1000 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    extruded: false,\n    // Optional material for 'lighting' shader module\n    material: true\n};\n// This layer only perform GPU aggregation, no need to seperate data and weight props\n// aggregation will be dirty when any of the props are changed.\nconst DIMENSIONS = {\n    data: {\n        props: ['cellSize', 'colorAggregation', 'elevationAggregation']\n    }\n    // rest of the changes are detected by `state.attributesChanged`\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\n/** Aggregate data into a grid-based heatmap. Aggregation is performed on GPU. */\nexport default class GPUGridLayer extends GridAggregationLayer {\n    static { this.layerName = 'GPUGridLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState({ device }) {\n        const isSupported = GPUGridAggregator.isSupported(device);\n        if (!isSupported) {\n            log.error('GPUGridLayer is not supported on this browser, use GridLayer instead')();\n        }\n        super.initializeAggregationLayer({\n            dimensions: DIMENSIONS\n        });\n        this.setState({\n            gpuAggregation: false, // TODO(v9): Re-enable GPU aggregation.\n            projectPoints: false, // aggregation in world space\n            isSupported,\n            weights: {\n                color: {\n                    needMin: true,\n                    needMax: true,\n                    combineMaxMin: true,\n                    maxMinBuffer: device.createBuffer({\n                        byteLength: 4 * 4,\n                        // @ts-expect-error webgl-legacy\n                        accessor: { size: 4, type: 5126, divisor: 1 }\n                    })\n                },\n                elevation: {\n                    needMin: true,\n                    needMax: true,\n                    combineMaxMin: true,\n                    maxMinBuffer: device.createBuffer({\n                        byteLength: 4 * 4,\n                        // @ts-expect-error\n                        accessor: { size: 4, type: 5126, divisor: 1 }\n                    })\n                }\n            },\n            positionAttributeName: 'positions'\n        });\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            [POSITION_ATTRIBUTE_NAME]: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            color: { size: 3, accessor: 'getColorWeight' },\n            elevation: { size: 3, accessor: 'getElevationWeight' }\n        });\n    }\n    updateState(opts) {\n        if (this.state.isSupported === false) {\n            // Skip update, layer not supported\n            return;\n        }\n        super.updateState(opts);\n        const { aggregationDirty } = this.state;\n        if (aggregationDirty) {\n            // reset cached CPU Aggregation results (used for picking)\n            this.setState({\n                gridHash: null\n            });\n        }\n    }\n    getHashKeyForIndex(index) {\n        const { numRow, numCol, boundingBox, gridOffset } = this.state;\n        const gridSize = [numCol, numRow];\n        const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n        const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n        const yIndex = Math.floor(index / gridSize[0]);\n        const xIndex = index - yIndex * gridSize[0];\n        // This will match the index to the hash-key to access aggregation data from CPU aggregation results.\n        const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);\n        const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);\n        return `${latIdx}-${lonIdx}`;\n    }\n    getPositionForIndex(index) {\n        const { numRow, numCol, boundingBox, gridOffset } = this.state;\n        const gridSize = [numCol, numRow];\n        const gridOrigin = [boundingBox.xMin, boundingBox.yMin];\n        const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n        const yIndex = Math.floor(index / gridSize[0]);\n        const xIndex = index - yIndex * gridSize[0];\n        const yPos = yIndex * cellSize[1] + gridOrigin[1];\n        const xPos = xIndex * cellSize[0] + gridOrigin[0];\n        return [xPos, yPos];\n    }\n    getPickingInfo({ info, mode }) {\n        const { index } = info;\n        let object = null;\n        if (index >= 0) {\n            const gpuGridAggregator = this.state.gpuGridAggregator;\n            const position = this.getPositionForIndex(index);\n            const colorInfo = GPUGridAggregator.getAggregationData({\n                pixelIndex: index,\n                ...gpuGridAggregator.getData('color')\n            });\n            const elevationInfo = GPUGridAggregator.getAggregationData({\n                pixelIndex: index,\n                ...gpuGridAggregator.getData('elevation')\n            });\n            object = {\n                colorValue: colorInfo.cellWeight,\n                elevationValue: elevationInfo.cellWeight,\n                count: colorInfo.cellCount || elevationInfo.cellCount,\n                position,\n                totalCount: colorInfo.totalCount || elevationInfo.totalCount\n            };\n            if (mode !== 'hover') {\n                // perform CPU aggregation for full list of points for each cell\n                const { props } = this;\n                let { gridHash } = this.state;\n                if (!gridHash) {\n                    const { gridOffset, translation, boundingBox } = this.state;\n                    const { viewport } = this.context;\n                    const attributes = this.getAttributes();\n                    const cpuAggregation = pointToDensityGridDataCPU(props, {\n                        gridOffset,\n                        attributes,\n                        viewport,\n                        translation,\n                        boundingBox\n                    });\n                    gridHash = cpuAggregation.gridHash;\n                    this.setState({ gridHash });\n                }\n                const key = this.getHashKeyForIndex(index);\n                const cpuAggregationData = gridHash[key];\n                Object.assign(object, cpuAggregationData);\n            }\n        }\n        // override object with picked cell\n        info.picked = Boolean(object);\n        info.object = object;\n        return info;\n    }\n    renderLayers() {\n        if (!this.state.isSupported) {\n            return null;\n        }\n        const { elevationScale, extruded, cellSize: cellSizeMeters, coverage, material, elevationRange, colorDomain, elevationDomain } = this.props;\n        const { weights, numRow, numCol, gridOrigin, gridOffset } = this.state;\n        const { color, elevation } = weights;\n        const colorRange = colorRangeToFlatArray(this.props.colorRange);\n        const SubLayerClass = this.getSubLayerClass('gpu-grid-cell', GPUGridCellLayer);\n        return new SubLayerClass({\n            gridSize: [numCol, numRow],\n            gridOrigin,\n            gridOffset: [gridOffset.xOffset, gridOffset.yOffset],\n            colorRange,\n            elevationRange,\n            colorDomain,\n            elevationDomain,\n            cellSize: cellSizeMeters,\n            coverage,\n            material,\n            elevationScale,\n            extruded\n        }, this.getSubLayerProps({\n            id: 'gpu-grid-cell'\n        }), {\n            data: {\n                attributes: {\n                    colors: color.aggregationBuffer,\n                    elevations: elevation.aggregationBuffer\n                }\n            },\n            colorMaxMinBuffer: color.maxMinBuffer,\n            elevationMaxMinBuffer: elevation.maxMinBuffer,\n            numInstances: numCol * numRow\n        });\n    }\n    finalizeState(context) {\n        const { color, elevation } = this.state.weights;\n        [color, elevation].forEach(weight => {\n            const { aggregationBuffer, maxMinBuffer } = weight;\n            maxMinBuffer?.destroy();\n            aggregationBuffer?.destroy();\n        });\n        super.finalizeState(context);\n    }\n    // Aggregation Overrides\n    updateAggregationState(opts) {\n        const { props, oldProps } = opts;\n        const { cellSize, coordinateSystem } = props;\n        const { viewport } = this.context;\n        const cellSizeChanged = oldProps.cellSize !== cellSize;\n        const { dimensions } = this.state;\n        const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n        // any attribute changed\n        const attributesChanged = positionsChanged || this.isAttributeChanged();\n        let { boundingBox } = this.state;\n        if (positionsChanged) {\n            boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());\n            this.setState({ boundingBox });\n        }\n        if (positionsChanged || cellSizeChanged) {\n            const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);\n            this.allocateResources(numRow, numCol);\n            this.setState({\n                gridOffset,\n                translation,\n                gridOrigin: [-1 * translation[0], -1 * translation[1]],\n                width,\n                height,\n                numCol,\n                numRow\n            });\n        }\n        const aggregationDataDirty = attributesChanged ||\n            this.isAggregationDirty(opts, {\n                dimension: dimensions.data,\n                compareAll: true\n            });\n        if (aggregationDataDirty) {\n            this._updateAccessors(opts);\n        }\n        this.setState({\n            aggregationDataDirty\n        });\n    }\n    // Private\n    _updateAccessors(opts) {\n        const { colorAggregation, elevationAggregation } = opts.props;\n        const { color, elevation } = this.state.weights;\n        color.operation = AGGREGATION_OPERATION[colorAggregation];\n        elevation.operation = AGGREGATION_OPERATION[elevationAggregation];\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Layer, fp64LowPart, project32, gouraudLighting, picking } from '@deck.gl/core';\nimport { CubeGeometry } from '@luma.gl/engine';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { Model } from '@luma.gl/engine';\nimport { GL } from '@luma.gl/constants';\nimport { defaultColorRange, colorRangeToFlatArray } from \"../utils/color-utils.js\";\nimport vs from \"./gpu-grid-cell-layer-vertex.glsl.js\";\nimport fs from \"./gpu-grid-cell-layer-fragment.glsl.js\";\nconst COLOR_DATA_UBO_INDEX = 0;\nconst ELEVATION_DATA_UBO_INDEX = 1;\nconst defaultProps = {\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    // grid\n    gridSize: { type: 'array', value: [1, 1] },\n    gridOrigin: { type: 'array', value: [0, 0] },\n    gridOffset: { type: 'array', value: [0, 0] },\n    cellSize: { type: 'number', min: 0, max: 1000, value: 1000 },\n    offset: { type: 'array', value: [1, 1] },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    extruded: true,\n    material: true // Use lighting module defaults\n};\nexport default class GPUGridCellLayer extends Layer {\n    static { this.layerName = 'GPUGridCellLayer'; }\n    static { this.defaultProps = defaultProps; }\n    getShaders() {\n        return super.getShaders({\n            vs,\n            fs,\n            modules: [project32, gouraudLighting, picking, fp64arithmetic]\n        });\n    }\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        attributeManager.addInstanced({\n            colors: {\n                size: 4,\n                noAlloc: true\n            },\n            elevations: {\n                size: 4,\n                noAlloc: true\n            }\n        });\n        const model = this._getModel();\n        this._setupUniformBuffer(model);\n        this.setState({ model });\n    }\n    _getModel() {\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            geometry: new CubeGeometry(),\n            isInstanced: true\n        });\n    }\n    draw({ uniforms }) {\n        const { cellSize, offset, extruded, elevationScale, coverage, gridSize, gridOrigin, gridOffset, elevationRange, colorMaxMinBuffer, elevationMaxMinBuffer } = this.props;\n        const model = this.state.model;\n        const gridOriginLow = [fp64LowPart(gridOrigin[0]), fp64LowPart(gridOrigin[1])];\n        const gridOffsetLow = [fp64LowPart(gridOffset[0]), fp64LowPart(gridOffset[1])];\n        const domainUniforms = this.getDomainUniforms();\n        const colorRange = colorRangeToFlatArray(this.props.colorRange);\n        this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n        model.setUniforms(uniforms);\n        model.setUniforms(domainUniforms);\n        model.setUniforms({\n            cellSize,\n            offset,\n            extruded,\n            elevationScale,\n            coverage,\n            gridSize,\n            gridOrigin,\n            gridOriginLow,\n            gridOffset,\n            gridOffsetLow,\n            colorRange,\n            elevationRange\n        });\n        model.draw(this.context.renderPass);\n        this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);\n    }\n    bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n        colorMaxMinBuffer.bind({ target: 35345, index: COLOR_DATA_UBO_INDEX });\n        elevationMaxMinBuffer.bind({ target: 35345, index: ELEVATION_DATA_UBO_INDEX });\n    }\n    unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {\n        colorMaxMinBuffer.unbind({ target: 35345, index: COLOR_DATA_UBO_INDEX });\n        elevationMaxMinBuffer.unbind({ target: 35345, index: ELEVATION_DATA_UBO_INDEX });\n    }\n    getDomainUniforms() {\n        const { colorDomain, elevationDomain } = this.props;\n        const domainUniforms = {};\n        if (colorDomain !== null) {\n            domainUniforms.colorDomainValid = true;\n            domainUniforms.colorDomain = colorDomain;\n        }\n        else {\n            domainUniforms.colorDomainValid = false;\n        }\n        if (elevationDomain !== null) {\n            domainUniforms.elevationDomainValid = true;\n            domainUniforms.elevationDomain = elevationDomain;\n        }\n        else {\n            domainUniforms.elevationDomainValid = false;\n        }\n        return domainUniforms;\n    }\n    _setupUniformBuffer(model) {\n        // @ts-expect-error TODO v9 This code is not portable to WebGPU\n        const programHandle = model.pipeline.handle;\n        const gl = this.context.gl;\n        const colorIndex = gl.getUniformBlockIndex(programHandle, 'ColorData');\n        const elevationIndex = gl.getUniformBlockIndex(programHandle, 'ElevationData');\n        gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);\n        gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Inspired by screen-grid-layer vertex shader in deck.gl\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-vertex-shader\n#define RANGE_COUNT 6\nin vec3 positions;\nin vec3 normals;\nin vec4 colors;\nin vec4 elevations;\nin vec3 instancePickingColors;\nuniform vec2 offset;\nuniform bool extruded;\nuniform float cellSize;\nuniform float coverage;\nuniform float opacity;\nuniform float elevationScale;\nuniform ivec2 gridSize;\nuniform vec2 gridOrigin;\nuniform vec2 gridOriginLow;\nuniform vec2 gridOffset;\nuniform vec2 gridOffsetLow;\nuniform vec4 colorRange[RANGE_COUNT];\nuniform vec2 elevationRange;\nuniform vec2 colorDomain;\nuniform bool colorDomainValid;\nuniform vec2 elevationDomain;\nuniform bool elevationDomainValid;\nlayout(std140) uniform;\nuniform ColorData\n{\nvec4 maxMinCount;\n} colorData;\nuniform ElevationData\n{\nvec4 maxMinCount;\n} elevationData;\n#define EPSILON 0.00001\nout vec4 vColor;\nvec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {\nvec4 outColor = vec4(0., 0., 0., 0.);\nif (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\nfloat domainRange = domain.y - domain.x;\nif (domainRange <= 0.) {\noutColor = colorRange[0];\n} else {\nfloat rangeCount = float(RANGE_COUNT);\nfloat rangeStep = domainRange / rangeCount;\nfloat idx = floor((value - domain.x) / rangeStep);\nidx = clamp(idx, 0., rangeCount - 1.);\nint intIdx = int(idx);\noutColor = colorRange[intIdx];\n}\n}\nreturn outColor;\n}\nfloat linearScale(vec2 domain, vec2 range, float value) {\nif (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {\nreturn ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;\n}\nreturn -1.;\n}\nvoid main(void) {\nvec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);\nvec4 color = quantizeScale(clrDomain, colorRange, colors.r);\nfloat elevation = 0.0;\nif (extruded) {\nvec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);\nelevation = linearScale(elvDomain, elevationRange, elevations.r);\nelevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;\n}\nfloat shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);\nfloat dotRadius = cellSize / 2. * coverage * shouldRender;\nint yIndex = (gl_InstanceID / gridSize[0]);\nint xIndex = gl_InstanceID - (yIndex * gridSize[0]);\nvec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));\ninstancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));\nvec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));\ninstancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));\nvec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);\nvec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);\ngeometry.worldPosition = centroidPosition;\nvec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);\npicking_setPickingColor(instancePickingColors);\ngl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\nvec3 normals_commonspace = project_normal(normals);\nif (extruded) {\nvec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);\nvColor = vec4(lightColor, color.a * opacity) / 255.;\n} else {\nvColor = vec4(color.rgb, color.a * opacity) / 255.;\n}\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME gpu-grid-cell-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nout vec4 fragColor;\nvoid main(void) {\nfragColor = vColor;\nfragColor = picking_filterColor(fragColor);\n}\n`;\n", "export function getBounds(points) {\n    // Now build bounding box in world space (aligned to world coordiante system)\n    const x = points.map(p => p[0]);\n    const y = points.map(p => p[1]);\n    const xMin = Math.min.apply(null, x);\n    const xMax = Math.max.apply(null, x);\n    const yMin = Math.min.apply(null, y);\n    const yMax = Math.max.apply(null, y);\n    return [xMin, yMin, xMax, yMax];\n}\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds, targetBounds) {\n    if (targetBounds[0] >= currentBounds[0] &&\n        targetBounds[2] <= currentBounds[2] &&\n        targetBounds[1] >= currentBounds[1] &&\n        targetBounds[3] <= currentBounds[3]) {\n        return true;\n    }\n    return false;\n}\nconst scratchArray = new Float32Array(12);\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points, dimensions = 2) {\n    let index = 0;\n    for (const point of points) {\n        for (let i = 0; i < dimensions; i++) {\n            scratchArray[index++] = point[i] || 0;\n        }\n    }\n    return scratchArray;\n}\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox, width, height) {\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const currentWidth = xMax - xMin;\n    const currentHeight = yMax - yMin;\n    let newWidth = currentWidth;\n    let newHeight = currentHeight;\n    if (currentWidth / currentHeight < width / height) {\n        // expand bounding box width\n        newWidth = (width / height) * currentHeight;\n    }\n    else {\n        newHeight = (height / width) * currentWidth;\n    }\n    if (newWidth < width) {\n        newWidth = width;\n        newHeight = height;\n    }\n    const xCenter = (xMax + xMin) / 2;\n    const yCenter = (yMax + yMin) / 2;\n    return [\n        xCenter - newWidth / 2,\n        yCenter - newHeight / 2,\n        xCenter + newWidth / 2,\n        yCenter + newHeight / 2\n    ];\n}\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point, bounds) {\n    const [xMin, yMin, xMax, yMax] = bounds;\n    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* global setTimeout clearTimeout */\nimport { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates } from \"./heatmap-layer-utils.js\";\nimport { TextureTransform } from '@luma.gl/engine';\nimport { AttributeManager, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport TriangleLayer from \"./triangle-layer.js\";\nimport AggregationLayer from \"../aggregation-layer.js\";\nimport { defaultColorRange, colorRangeToFlatArray } from \"../utils/color-utils.js\";\nimport weightsVs from \"./weights-vs.glsl.js\";\nimport weightsFs from \"./weights-fs.glsl.js\";\nimport maxVs from \"./max-vs.glsl.js\";\nimport maxFs from \"./max-fs.glsl.js\";\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS = {\n    format: 'rgba8unorm',\n    mipmaps: false,\n    sampler: {\n        minFilter: 'linear',\n        magFilter: 'linear',\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge'\n    }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n    SUM: 0,\n    MEAN: 1\n};\nconst defaultProps = {\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getWeight: { type: 'accessor', value: 1 },\n    intensity: { type: 'number', min: 0, value: 1 },\n    radiusPixels: { type: 'number', min: 1, max: 100, value: 50 },\n    colorRange: defaultColorRange,\n    threshold: { type: 'number', min: 0, max: 1, value: 0.05 },\n    colorDomain: { type: 'array', value: null, optional: true },\n    // 'SUM' or 'MEAN'\n    aggregation: 'SUM',\n    weightsTextureSize: { type: 'number', min: 128, max: 2048, value: 2048 },\n    debounceTimeout: { type: 'number', min: 0, max: 1000, value: 500 }\n};\nconst FLOAT_TARGET_FEATURES = [\n    'float32-renderable-webgl', // ability to render to float texture\n    'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\nconst DIMENSIONS = {\n    data: {\n        props: ['radiusPixels']\n    }\n};\n/** Visualizes the spatial distribution of data. */\nexport default class HeatmapLayer extends AggregationLayer {\n    static { this.layerName = 'HeatmapLayer'; }\n    static { this.defaultProps = defaultProps; }\n    initializeState() {\n        super.initializeAggregationLayer(DIMENSIONS);\n        this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });\n        this._setupTextureParams();\n        this._setupAttributes();\n        this._setupResources();\n    }\n    shouldUpdateState({ changeFlags }) {\n        // Need to be updated when viewport changes\n        return changeFlags.somethingChanged;\n    }\n    /* eslint-disable max-statements,complexity */\n    updateState(opts) {\n        super.updateState(opts);\n        this._updateHeatmapState(opts);\n    }\n    _updateHeatmapState(opts) {\n        const { props, oldProps } = opts;\n        const changeFlags = this._getChangeFlags(opts);\n        if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n            // if data is changed, do not debounce and immediately update the weight map\n            changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n            this._updateTextureRenderingBounds();\n        }\n        if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n            // Update weight map immediately\n            clearTimeout(this.state.updateTimer);\n            this.setState({ isWeightMapDirty: true });\n        }\n        else if (changeFlags.viewportZoomChanged) {\n            // Update weight map when zoom stops\n            this._debouncedUpdateWeightmap();\n        }\n        if (props.colorRange !== oldProps.colorRange) {\n            this._updateColorTexture(opts);\n        }\n        if (this.state.isWeightMapDirty) {\n            this._updateWeightmap();\n        }\n        this.setState({ zoom: opts.context.viewport.zoom });\n    }\n    renderLayers() {\n        const { weightsTexture, triPositionBuffer, triTexCoordBuffer, maxWeightsTexture, colorTexture, colorDomain } = this.state;\n        const { updateTriggers, intensity, threshold, aggregation } = this.props;\n        const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n        return new TriangleLayerClass(this.getSubLayerProps({\n            id: 'triangle-layer',\n            updateTriggers\n        }), {\n            // position buffer is filled with world coordinates generated from viewport.unproject\n            // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n            coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n            data: {\n                attributes: {\n                    positions: triPositionBuffer,\n                    texCoords: triTexCoordBuffer\n                }\n            },\n            vertexCount: 4,\n            maxTexture: maxWeightsTexture,\n            colorTexture,\n            aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n            weightsTexture,\n            intensity,\n            threshold,\n            colorDomain\n        });\n    }\n    finalizeState(context) {\n        super.finalizeState(context);\n        const { weightsTransform, weightsTexture, maxWeightTransform, maxWeightsTexture, triPositionBuffer, triTexCoordBuffer, colorTexture, updateTimer } = this.state;\n        weightsTransform?.destroy();\n        weightsTexture?.destroy();\n        maxWeightTransform?.destroy();\n        maxWeightsTexture?.destroy();\n        triPositionBuffer?.destroy();\n        triTexCoordBuffer?.destroy();\n        colorTexture?.destroy();\n        if (updateTimer) {\n            clearTimeout(updateTimer);\n        }\n    }\n    // PRIVATE\n    // override Composite layer private method to create AttributeManager instance\n    _getAttributeManager() {\n        return new AttributeManager(this.context.device, {\n            id: this.props.id,\n            stats: this.context.stats\n        });\n    }\n    _getChangeFlags(opts) {\n        const changeFlags = {};\n        const { dimensions } = this.state;\n        changeFlags.dataChanged =\n            (this.isAttributeChanged() && 'attribute changed') || // if any attribute is changed\n                (this.isAggregationDirty(opts, {\n                    compareAll: true,\n                    dimension: dimensions.data\n                }) &&\n                    'aggregation is dirty');\n        changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n        const { zoom } = this.state;\n        if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n            changeFlags.viewportZoomChanged = true;\n        }\n        return changeFlags;\n    }\n    _createTextures() {\n        const { textureSize, format } = this.state;\n        this.setState({\n            weightsTexture: this.context.device.createTexture({\n                ...TEXTURE_PROPS,\n                width: textureSize,\n                height: textureSize,\n                format\n            }),\n            maxWeightsTexture: this.context.device.createTexture({\n                ...TEXTURE_PROPS,\n                width: 1,\n                height: 1,\n                format\n            })\n        });\n    }\n    _setupAttributes() {\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: { size: 3, type: 'float64', accessor: 'getPosition' },\n            weights: { size: 1, accessor: 'getWeight' }\n        });\n        this.setState({ positionAttributeName: 'positions' });\n    }\n    _setupTextureParams() {\n        const { device } = this.context;\n        const { weightsTextureSize } = this.props;\n        const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n        const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n        const format = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n        const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n        this.setState({ textureSize, format, weightsScale });\n        if (!floatTargetSupport) {\n            log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();\n        }\n    }\n    _createWeightsTransform(shaders) {\n        let { weightsTransform } = this.state;\n        const { weightsTexture } = this.state;\n        const attributeManager = this.getAttributeManager();\n        weightsTransform?.destroy();\n        weightsTransform = new TextureTransform(this.context.device, {\n            id: `${this.id}-weights-transform`,\n            bufferLayout: attributeManager.getBufferLayouts(),\n            vertexCount: 1,\n            targetTexture: weightsTexture,\n            parameters: {\n                depthWriteEnabled: false,\n                blendColorOperation: 'add',\n                blendColorSrcFactor: 'one',\n                blendColorDstFactor: 'one',\n                blendAlphaSrcFactor: 'one',\n                blendAlphaDstFactor: 'one'\n            },\n            topology: 'point-list',\n            ...shaders\n        });\n        this.setState({ weightsTransform });\n    }\n    _setupResources() {\n        this._createTextures();\n        const { device } = this.context;\n        const { textureSize, weightsTexture, maxWeightsTexture } = this.state;\n        const weightsTransformShaders = this.getShaders({\n            vs: weightsVs,\n            fs: weightsFs\n        });\n        this._createWeightsTransform(weightsTransformShaders);\n        const maxWeightsTransformShaders = this.getShaders({ vs: maxVs, fs: maxFs });\n        const maxWeightTransform = new TextureTransform(device, {\n            id: `${this.id}-max-weights-transform`,\n            bindings: { inTexture: weightsTexture },\n            uniforms: { textureSize },\n            targetTexture: maxWeightsTexture,\n            ...maxWeightsTransformShaders,\n            vertexCount: textureSize * textureSize,\n            topology: 'point-list',\n            parameters: {\n                depthWriteEnabled: false,\n                blendColorOperation: 'max',\n                blendAlphaOperation: 'max',\n                blendColorSrcFactor: 'one',\n                blendColorDstFactor: 'one',\n                blendAlphaSrcFactor: 'one',\n                blendAlphaDstFactor: 'one'\n            }\n        });\n        this.setState({\n            weightsTexture,\n            maxWeightsTexture,\n            maxWeightTransform,\n            zoom: null,\n            triPositionBuffer: device.createBuffer({ byteLength: 48 }),\n            triTexCoordBuffer: device.createBuffer({ byteLength: 48 })\n        });\n    }\n    // overwrite super class method to update transform model\n    updateShaders(shaderOptions) {\n        // shader params (modules, injects) changed, update model object\n        this._createWeightsTransform({\n            vs: weightsVs,\n            fs: weightsFs,\n            ...shaderOptions\n        });\n    }\n    _updateMaxWeightValue() {\n        const { maxWeightTransform } = this.state;\n        maxWeightTransform.run({\n            parameters: { viewport: [0, 0, 1, 1] },\n            clearColor: [0, 0, 0, 0]\n        });\n    }\n    // Computes world bounds area that needs to be processed for generate heatmap\n    _updateBounds(forceUpdate = false) {\n        const { viewport } = this.context;\n        // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n        // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n        const viewportCorners = [\n            viewport.unproject([0, 0]),\n            viewport.unproject([viewport.width, 0]),\n            viewport.unproject([viewport.width, viewport.height]),\n            viewport.unproject([0, viewport.height])\n        ].map(p => p.map(Math.fround));\n        // #1: get world bounds for current viewport extends\n        const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n        const newState = { visibleWorldBounds, viewportCorners };\n        let boundsChanged = false;\n        if (forceUpdate ||\n            !this.state.worldBounds ||\n            !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n            // #2 : convert world bounds to common (Flat) bounds\n            // #3 : extend common bounds to match aspect ratio with viewport\n            const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n            // #4 :convert aligned common bounds to world bounds\n            const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n            // Clip webmercator projection limits\n            if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n                worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n                worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n                worldBounds[0] = Math.max(worldBounds[0], -360);\n                worldBounds[2] = Math.min(worldBounds[2], 360);\n            }\n            // #5: now convert world bounds to common using Layer's coordiante system and origin\n            const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n            newState.worldBounds = worldBounds;\n            newState.normalizedCommonBounds = normalizedCommonBounds;\n            boundsChanged = true;\n        }\n        this.setState(newState);\n        return boundsChanged;\n    }\n    _updateTextureRenderingBounds() {\n        // Just render visible portion of the texture\n        const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;\n        const { viewport } = this.context;\n        triPositionBuffer.write(packVertices(viewportCorners, 3));\n        const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n        triTexCoordBuffer.write(packVertices(textureBounds, 2));\n    }\n    _updateColorTexture(opts) {\n        const { colorRange } = opts.props;\n        let { colorTexture } = this.state;\n        const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n        if (colorTexture && colorTexture?.width === colorRange.length) {\n            // TODO(v9): Unclear whether `setSubImageData` is a public API, or what to use if not.\n            colorTexture.setSubImageData({ data: colors });\n        }\n        else {\n            colorTexture?.destroy();\n            colorTexture = this.context.device.createTexture({\n                ...TEXTURE_PROPS,\n                data: colors,\n                width: colorRange.length,\n                height: 1\n            });\n        }\n        this.setState({ colorTexture });\n    }\n    _updateWeightmap() {\n        const { radiusPixels, colorDomain, aggregation } = this.props;\n        const { worldBounds, textureSize, weightsScale } = this.state;\n        const weightsTransform = this.state.weightsTransform;\n        this.state.isWeightMapDirty = false;\n        // convert world bounds to common using Layer's coordiante system and origin\n        const commonBounds = this._worldToCommonBounds(worldBounds, {\n            useLayerCoordinateSystem: true\n        });\n        if (colorDomain && aggregation === 'SUM') {\n            // scale color domain to weight per pixel\n            const { viewport } = this.context;\n            const metersPerPixel = (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n                textureSize;\n            this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n        }\n        else {\n            this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n        }\n        const attributeManager = this.getAttributeManager();\n        const attributes = attributeManager.getAttributes();\n        const moduleSettings = this.getModuleSettings();\n        const positions = attributes.positions.buffer;\n        const uniforms = { radiusPixels, commonBounds, textureWidth: textureSize, weightsScale };\n        const weights = attributes.weights.buffer;\n        weightsTransform.model.setAttributes({ positions, weights });\n        weightsTransform.model.setVertexCount(this.getNumInstances());\n        weightsTransform.model.setUniforms(uniforms);\n        weightsTransform.model.updateModuleSettings(moduleSettings);\n        weightsTransform.run({\n            parameters: { viewport: [0, 0, textureSize, textureSize] },\n            clearColor: [0, 0, 0, 0]\n        });\n        this._updateMaxWeightValue();\n    }\n    _debouncedUpdateWeightmap(fromTimer = false) {\n        let { updateTimer } = this.state;\n        const { debounceTimeout } = this.props;\n        if (fromTimer) {\n            updateTimer = null;\n            // update\n            this._updateBounds(true);\n            this._updateTextureRenderingBounds();\n            this.setState({ isWeightMapDirty: true });\n        }\n        else {\n            this.setState({ isWeightMapDirty: false });\n            clearTimeout(updateTimer);\n            updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n        }\n        this.setState({ updateTimer });\n    }\n    // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n    // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n    // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n    _worldToCommonBounds(worldBounds, opts = {}) {\n        const { useLayerCoordinateSystem = false } = opts;\n        const [minLong, minLat, maxLong, maxLat] = worldBounds;\n        const { viewport } = this.context;\n        const { textureSize } = this.state;\n        const { coordinateSystem } = this.props;\n        const offsetMode = useLayerCoordinateSystem &&\n            (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n                coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n        const offsetOriginCommon = offsetMode\n            ? viewport.projectPosition(this.props.coordinateOrigin)\n            : [0, 0];\n        const size = (textureSize * RESOLUTION) / viewport.scale;\n        let bottomLeftCommon;\n        let topRightCommon;\n        // Y-axis is flipped between World and Common bounds\n        if (useLayerCoordinateSystem && !offsetMode) {\n            bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n            topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n        }\n        else {\n            bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n            topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n        }\n        // Ignore z component\n        return scaleToAspectRatio([\n            bottomLeftCommon[0] - offsetOriginCommon[0],\n            bottomLeftCommon[1] - offsetOriginCommon[1],\n            topRightCommon[0] - offsetOriginCommon[0],\n            topRightCommon[1] - offsetOriginCommon[1]\n        ], size, size);\n    }\n    // input commonBounds: [xMin, yMin, xMax, yMax]\n    // output worldBounds: [minLong, minLat, maxLong, maxLat]\n    _commonToWorldBounds(commonBounds) {\n        const [xMin, yMin, xMax, yMax] = commonBounds;\n        const { viewport } = this.context;\n        const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n        const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n        return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n    }\n}\n", "// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { Model } from '@luma.gl/engine';\nimport { Layer, project32 } from '@deck.gl/core';\nimport vs from \"./triangle-layer-vertex.glsl.js\";\nimport fs from \"./triangle-layer-fragment.glsl.js\";\nexport default class TriangleLayer extends Layer {\n    static { this.layerName = 'TriangleLayer'; }\n    getShaders() {\n        return { vs, fs, modules: [project32] };\n    }\n    initializeState({ device }) {\n        this.setState({ model: this._getModel(device) });\n    }\n    _getModel(device) {\n        const { vertexCount, data, weightsTexture, maxTexture, colorTexture } = this.props;\n        return new Model(device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bindings: { weightsTexture, maxTexture, colorTexture },\n            attributes: data.attributes,\n            bufferLayout: [\n                { name: 'positions', format: 'float32x3' },\n                { name: 'texCoords', format: 'float32x2' }\n            ],\n            topology: 'triangle-fan-webgl',\n            vertexCount\n        });\n    }\n    draw({ uniforms }) {\n        const { model } = this.state;\n        const { intensity, threshold, aggregationMode, colorDomain } = this.props;\n        model.setUniforms({\n            ...uniforms,\n            intensity,\n            threshold,\n            aggregationMode,\n            colorDomain\n        });\n        model.draw(this.context.renderPass);\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Inspired by screen-grid-layer vertex shader in deck.gl\nexport default `\\\n#version 300 es\n#define SHADER_NAME heatp-map-layer-vertex-shader\nuniform sampler2D maxTexture;\nuniform float intensity;\nuniform vec2 colorDomain;\nuniform float threshold;\nuniform float aggregationMode;\nin vec3 positions;\nin vec2 texCoords;\nout vec2 vTexCoords;\nout float vIntensityMin;\nout float vIntensityMax;\nvoid main(void) {\ngl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\nvTexCoords = texCoords;\nvec4 maxTexture = texture(maxTexture, vec2(0.5));\nfloat maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\nfloat minValue = maxValue * threshold;\nif (colorDomain[1] > 0.) {\nmaxValue = colorDomain[1];\nminValue = colorDomain[0];\n}\nvIntensityMax = intensity / maxValue;\nvIntensityMin = intensity / minValue;\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\n#version 300 es\n#define SHADER_NAME triangle-layer-fragment-shader\nprecision highp float;\nuniform float opacity;\nuniform sampler2D weightsTexture;\nuniform sampler2D colorTexture;\nuniform float aggregationMode;\nin vec2 vTexCoords;\nin float vIntensityMin;\nin float vIntensityMax;\nout vec4 fragColor;\nvec4 getLinearColor(float value) {\nfloat factor = clamp(value * vIntensityMax, 0., 1.);\nvec4 color = texture(colorTexture, vec2(factor, 0.5));\ncolor.a *= min(value * vIntensityMin, 1.0);\nreturn color;\n}\nvoid main(void) {\nvec4 weights = texture(weightsTexture, vTexCoords);\nfloat weight = weights.r;\nif (aggregationMode > 0.5) {\nweight /= max(1.0, weights.a);\n}\nif (weight <= 0.) {\ndiscard;\n}\nvec4 linearColor = getLinearColor(weight);\nlinearColor.a *= opacity;\nfragColor = linearColor;\n}\n`;\n", "export default `\\\n#version 300 es\nin vec3 positions;\nin vec3 positions64Low;\nin float weights;\nout vec4 weightsTexture;\nuniform float radiusPixels;\nuniform float textureWidth;\nuniform vec4 commonBounds;\nuniform float weightsScale;\nvoid main()\n{\nweightsTexture = vec4(weights * weightsScale, 0., 0., 1.);\nfloat radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);\ngl_PointSize = radiusTexels * 2.;\nvec3 commonPosition = project_position(positions, positions64Low);\ngl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;\ngl_Position.xy = (gl_Position.xy * 2.) - (1.);\ngl_Position.w = 1.0;\n}\n`;\n", "export default `\\\n#version 300 es\nin vec4 weightsTexture;\nout vec4 fragColor;\nfloat gaussianKDE(float u){\nreturn pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(0.5, 0.5));\nif (dist > 0.5) {\ndiscard;\n}\nfragColor = weightsTexture * gaussianKDE(2. * dist);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "export default `\\\n#version 300 es\nuniform sampler2D inTexture;\nuniform float textureSize;\nout vec4 outTexture;\nvoid main()\n{\nint yIndex = gl_VertexID / int(textureSize);\nint xIndex = gl_VertexID - (yIndex * int(textureSize));\nvec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;\noutTexture = texture(inTexture, uv);\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n`;\n", "export default `\\\n#version 300 es\nin vec4 outTexture;\nout vec4 fragColor;\nvoid main() {\nfragColor = outTexture;\nfragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n"],
  "mappings": "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",
  "names": ["import_core", "import_constants", "REQUIRED_FEATURES", "mergeShaders", "import_engine", "import_core", "import_constants", "import_core", "import_core", "compareProps", "import_core", "MAX_32_BIT_FLOAT", "ascending", "defaultProps", "import_core", "import_core", "defaultProps", "defaultProps", "import_core", "import_layers", "import_core", "nop", "defaultProps", "import_layers", "import_core", "threshold", "threshold", "import_core", "defaultProps", "POSITION_ATTRIBUTE_NAME", "DIMENSIONS", "import_core", "import_constants", "import_core", "import_core", "import_engine", "import_shadertools", "import_constants", "defaultProps", "defaultProps", "DIMENSIONS", "POSITION_ATTRIBUTE_NAME", "defaultProps", "import_engine", "import_core", "import_engine", "import_core", "threshold", "defaultProps", "DIMENSIONS", "threshold"]
}
