"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// dist/index.js
var dist_exports = {};
__export(dist_exports, {
  AGGREGATION_OPERATION: () => AGGREGATION_OPERATION,
  CPUGridLayer: () => CPUGridLayer,
  ContourLayer: () => ContourLayer,
  GPUGridLayer: () => GPUGridLayer,
  GridLayer: () => GridLayer,
  HeatmapLayer: () => HeatmapLayer,
  HexagonLayer: () => HexagonLayer,
  ScreenGridLayer: () => ScreenGridLayer,
  _AggregationLayer: () => AggregationLayer,
  _BinSorter: () => BinSorter,
  _CPUAggregator: () => CPUAggregator,
  _GPUGridAggregator: () => GPUGridAggregator
});
module.exports = __toCommonJS(dist_exports);

// dist/screen-grid-layer/screen-grid-layer.js
var import_core8 = require("@deck.gl/core");

// dist/utils/gpu-grid-aggregation/gpu-grid-aggregator.js
var import_engine = require("@luma.gl/engine");
var import_shadertools = require("@luma.gl/shadertools");
var import_constants2 = require("@luma.gl/constants");
var import_core = require("@deck.gl/core");

// dist/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js
var import_constants = require("@luma.gl/constants");

// dist/utils/aggregation-operation-utils.js
var AGGREGATION_OPERATION = {
  SUM: 1,
  MEAN: 2,
  MIN: 3,
  MAX: 4
};
function sumReducer(accu, cur) {
  return accu + cur;
}
function maxReducer(accu, cur) {
  return cur > accu ? cur : accu;
}
function minReducer(accu, cur) {
  return cur < accu ? cur : accu;
}
function getMean(pts, accessor) {
  if (Number.isFinite(accessor)) {
    return pts.length ? accessor : null;
  }
  const filtered = pts.map(accessor).filter(Number.isFinite);
  return filtered.length ? filtered.reduce(sumReducer, 0) / filtered.length : null;
}
function getSum(pts, accessor) {
  if (Number.isFinite(accessor)) {
    return pts.length ? pts.length * accessor : null;
  }
  const filtered = pts.map(accessor).filter(Number.isFinite);
  return filtered.length ? filtered.reduce(sumReducer, 0) : null;
}
function getMax(pts, accessor) {
  if (Number.isFinite(accessor)) {
    return pts.length ? accessor : null;
  }
  const filtered = pts.map(accessor).filter(Number.isFinite);
  return filtered.length ? filtered.reduce(maxReducer, -Infinity) : null;
}
function getMin(pts, accessor) {
  if (Number.isFinite(accessor)) {
    return pts.length ? accessor : null;
  }
  const filtered = pts.map(accessor).filter(Number.isFinite);
  return filtered.length ? filtered.reduce(minReducer, Infinity) : null;
}
function getValueFunc(aggregation, accessor, context) {
  const op = AGGREGATION_OPERATION[aggregation] || AGGREGATION_OPERATION.SUM;
  accessor = wrapAccessor(accessor, context);
  switch (op) {
    case AGGREGATION_OPERATION.MIN:
      return (pts) => getMin(pts, accessor);
    case AGGREGATION_OPERATION.SUM:
      return (pts) => getSum(pts, accessor);
    case AGGREGATION_OPERATION.MEAN:
      return (pts) => getMean(pts, accessor);
    case AGGREGATION_OPERATION.MAX:
      return (pts) => getMax(pts, accessor);
    default:
      return null;
  }
}
function wrapAccessor(accessor, context = {}) {
  if (Number.isFinite(accessor)) {
    return accessor;
  }
  return (pt) => {
    context.index = pt.index;
    return accessor(pt.source, context);
  };
}
function wrapGetValueFunc(getValue, context = {}) {
  return (pts) => {
    context.indices = pts.map((pt) => pt.index);
    return getValue(pts.map((pt) => pt.source), context);
  };
}

// dist/utils/gpu-grid-aggregation/gpu-grid-aggregator-constants.js
var DEFAULT_RUN_PARAMS = {
  projectPoints: false,
  viewport: null,
  createBufferObjects: true,
  moduleSettings: {}
};
var MAX_32_BIT_FLOAT = 3402823466e29;
var MIN_BLEND_EQUATION = [32775, 32774];
var MAX_BLEND_EQUATION = [32776, 32774];
var MAX_MIN_BLEND_EQUATION = [32776, 32775];
var EQUATION_MAP = {
  [AGGREGATION_OPERATION.SUM]: 32774,
  [AGGREGATION_OPERATION.MEAN]: 32774,
  [AGGREGATION_OPERATION.MIN]: MIN_BLEND_EQUATION,
  [AGGREGATION_OPERATION.MAX]: MAX_BLEND_EQUATION
};
var DEFAULT_WEIGHT_PARAMS = {
  size: 1,
  operation: AGGREGATION_OPERATION.SUM,
  needMin: false,
  needMax: false,
  combineMaxMin: false
};
var PIXEL_SIZE = 4;

// dist/utils/gpu-grid-aggregation/aggregate-to-grid-vs.glsl.js
var aggregate_to_grid_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-vs
in vec3 positions;
in vec3 positions64Low;
in vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;
out vec3 vWeights;
vec2 project_to_pixel(vec4 pos) {
vec4 result;
pos.xy = pos.xy/pos.w;
result = pos + vec4(translation, 0., 0.);
result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
return result.xy;
}
void main(void) {
vWeights = weights;
vec4 windowPos = vec4(positions, 1.);
if (projectPoints) {
windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
}
vec2 pos = project_to_pixel(windowPos);
vec2 pixelXY64[2];
pixelXY64[0] = vec2(pos.x, 0.);
pixelXY64[1] = vec2(pos.y, 0.);
vec2 gridXY64[2];
gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
float x = floor(gridXY64[0].x);
float y = floor(gridXY64[1].x);
pos = vec2(x, y);
pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);
vec2 offset = 1.0 / gridSize;
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;

// dist/utils/gpu-grid-aggregation/aggregate-to-grid-fs.glsl.js
var aggregate_to_grid_fs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-fs
precision highp float;
in vec3 vWeights;
out vec4 fragColor;
void main(void) {
fragColor = vec4(vWeights, 1.0);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// dist/utils/gpu-grid-aggregation/aggregate-all-vs.glsl.js
var aggregate_all_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64
in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;
void main(void) {
vec2 pos = vec2(-1.0, -1.0);
vec2 offset = 1.0 / vec2(gridSize);
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
int yIndex = gl_InstanceID / gridSize[0];
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 yIndexFP64 = vec2(float(yIndex), 0.);
vec2 xIndexFP64 = vec2(float(xIndex), 0.);
vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);
vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);
vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
gl_PointSize = 1.0;
}
`;

// dist/utils/gpu-grid-aggregation/aggregate-all-fs.glsl.js
var aggregate_all_fs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs
precision highp float;
in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
if (textureColor.a == 0.) {
discard;
}
fragColor.rgb = textureColor.rgb;
fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`;

// dist/utils/gpu-grid-aggregation/transform-mean-vs.glsl.js
var transform_mean_vs_glsl_default = `#version 300 es
#define SHADER_NAME gpu-aggregation-transform-mean-vs
in vec4 aggregationValues;
out vec4 meanValues;
void main()
{
bool isCellValid = bool(aggregationValues.w > 0.);
meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
meanValues.w = aggregationValues.w;
gl_PointSize = 1.0;
}
`;

// dist/utils/resource-utils.js
var DEFAULT_PARAMETERS = {
  minFilter: "nearest",
  magFilter: "nearest"
};
function getFloatTexture(device, opts) {
  const { width = 1, height = 1, data = null, parameters = DEFAULT_PARAMETERS } = opts;
  const texture = device.createTexture({
    data,
    format: "rgba32float",
    mipmaps: false,
    sampler: parameters,
    width,
    height
  });
  return texture;
}
function getFramebuffer(device, opts) {
  const { id, width = 1, height = 1, texture } = opts;
  const fb = device.createFramebuffer({
    id,
    width,
    height,
    colorAttachments: [texture]
  });
  return fb;
}

// dist/utils/gpu-grid-aggregation/gpu-grid-aggregator.js
var BUFFER_NAMES = ["aggregationBuffer", "maxMinBuffer", "minBuffer", "maxBuffer"];
var ARRAY_BUFFER_MAP = {
  maxData: "maxBuffer",
  minData: "minBuffer",
  maxMinData: "maxMinBuffer"
};
var REQUIRED_FEATURES = [
  "float32-renderable-webgl",
  "texture-blend-float-webgl"
];
var GPUGridAggregator = class {
  static getAggregationData({ aggregationData, maxData, minData, maxMinData, pixelIndex }) {
    const index = pixelIndex * PIXEL_SIZE;
    const results = {};
    if (aggregationData) {
      results.cellCount = aggregationData[index + 3];
      results.cellWeight = aggregationData[index];
    }
    if (maxMinData) {
      results.maxCellWieght = maxMinData[0];
      results.minCellWeight = maxMinData[3];
    } else {
      if (maxData) {
        results.maxCellWieght = maxData[0];
        results.totalCount = maxData[3];
      }
      if (minData) {
        results.minCellWeight = minData[0];
        results.totalCount = minData[3];
      }
    }
    return results;
  }
  static getCellData({ countsData, size = 1 }) {
    const numCells = countsData.length / 4;
    const cellWeights = new Float32Array(numCells * size);
    const cellCounts = new Uint32Array(numCells);
    for (let i = 0; i < numCells; i++) {
      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {
        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];
      }
      cellCounts[i] = countsData[i * 4 + 3];
    }
    return { cellCounts, cellWeights };
  }
  static isSupported(device) {
    return REQUIRED_FEATURES.every((feature) => device.features.has(feature));
  }
  constructor(device, props = {}) {
    this.state = {
      weightAttributes: {},
      textures: {},
      meanTextures: {},
      buffers: {},
      framebuffers: {},
      maxMinFramebuffers: {},
      minFramebuffers: {},
      maxFramebuffers: {},
      equations: {},
      shaderOptions: {},
      modelDirty: false,
      resources: {},
      results: {}
    };
    this.id = props.id || "gpu-grid-aggregator";
    this.device = device;
    const REQUIRED_FEATURES2 = [
      "float32-renderable-webgl"
    ];
    this._hasGPUSupport = REQUIRED_FEATURES2.every((feature) => device.features.has(feature));
    if (this._hasGPUSupport) {
      this._setupModels();
    }
  }
  delete() {
    const { gridAggregationModel, allAggregationModel, meanTransform } = this;
    const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources } = this.state;
    gridAggregationModel == null ? void 0 : gridAggregationModel.destroy();
    allAggregationModel == null ? void 0 : allAggregationModel.destroy();
    meanTransform == null ? void 0 : meanTransform.destroy();
    deleteResources([
      framebuffers,
      textures,
      maxMinFramebuffers,
      minFramebuffers,
      maxFramebuffers,
      meanTextures,
      resources
    ]);
  }
  run(opts = {}) {
    this.setState({ results: {} });
    const aggregationParams = this._normalizeAggregationParams(opts);
    return this._runAggregation(aggregationParams);
  }
  getData(weightId) {
    const data = {};
    const results = this.state.results;
    if (!results[weightId].aggregationData) {
      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();
    }
    data.aggregationData = results[weightId].aggregationData;
    for (const arrayName in ARRAY_BUFFER_MAP) {
      const bufferName = ARRAY_BUFFER_MAP[arrayName];
      if (results[weightId][arrayName] || results[weightId][bufferName]) {
        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();
        data[arrayName] = results[weightId][arrayName];
      }
    }
    return data;
  }
  updateShaders(shaderOptions = {}) {
    this.setState({ shaderOptions, modelDirty: true });
  }
  _normalizeAggregationParams(opts) {
    const aggregationParams = { ...DEFAULT_RUN_PARAMS, ...opts };
    const { weights } = aggregationParams;
    if (weights) {
      aggregationParams.weights = normalizeWeightParams(weights);
    }
    return aggregationParams;
  }
  setState(updateObject) {
    Object.assign(this.state, updateObject);
  }
  _getAggregateData(opts) {
    const results = {};
    const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, resources } = this.state;
    const { weights } = opts;
    for (const id in weights) {
      results[id] = {};
      const { needMin, needMax, combineMaxMin } = weights[id];
      results[id].aggregationTexture = textures[id];
      results[id].aggregationBuffer = this.device.readPixelsToBufferWebGL(framebuffers[id], {
        target: weights[id].aggregationBuffer,
        sourceType: 5126
      });
      if (needMin && needMax && combineMaxMin) {
        results[id].maxMinBuffer = this.device.readPixelsToBufferWebGL(maxMinFramebuffers[id], {
          target: weights[id].maxMinBuffer,
          sourceType: 5126
        });
        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];
      } else {
        if (needMin) {
          results[id].minBuffer = this.device.readPixelsToBufferWebGL(minFramebuffers[id], {
            target: weights[id].minBuffer,
            sourceType: 5126
          });
          results[id].minTexture = resources[`${id}-minTexture`];
        }
        if (needMax) {
          results[id].maxBuffer = this.device.readPixelsToBufferWebGL(maxFramebuffers[id], {
            target: weights[id].maxBuffer,
            sourceType: 5126
          });
          results[id].maxTexture = resources[`${id}-maxTexture`];
        }
      }
    }
    this._trackGPUResultBuffers(results, weights);
    return results;
  }
  _renderAggregateData(opts) {
    const { cellSize, projectPoints, attributes, moduleSettings, numCol, numRow, weights, translation, scaling } = opts;
    const { maxMinFramebuffers, minFramebuffers, maxFramebuffers } = this.state;
    const gridSize = [numCol, numRow];
    const parameters = {
      blend: true,
      depthTest: false,
      blendFunc: [1, 1]
    };
    const uniforms = {
      cellSize,
      gridSize,
      projectPoints,
      translation,
      scaling
    };
    for (const id in weights) {
      const { needMin, needMax } = weights[id];
      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;
      this._renderToWeightsTexture({
        id,
        parameters,
        moduleSettings,
        uniforms,
        gridSize,
        attributes,
        weights
      });
      if (combineMaxMin) {
        this._renderToMaxMinTexture({
          id,
          parameters: { ...parameters, blendEquation: MAX_MIN_BLEND_EQUATION },
          gridSize,
          minOrMaxFb: maxMinFramebuffers[id],
          clearParams: { clearColor: [0, 0, 0, MAX_32_BIT_FLOAT] },
          combineMaxMin
        });
      } else {
        if (needMin) {
          this._renderToMaxMinTexture({
            id,
            parameters: { ...parameters, blendEquation: MIN_BLEND_EQUATION },
            gridSize,
            minOrMaxFb: minFramebuffers[id],
            clearParams: { clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] },
            combineMaxMin
          });
        }
        if (needMax) {
          this._renderToMaxMinTexture({
            id,
            parameters: { ...parameters, blendEquation: MAX_BLEND_EQUATION },
            gridSize,
            minOrMaxFb: maxFramebuffers[id],
            clearParams: { clearColor: [0, 0, 0, 0] },
            combineMaxMin
          });
        }
      }
    }
  }
  _renderToMaxMinTexture(opts) {
    const { id, gridSize, minOrMaxFb, combineMaxMin, clearParams = {} } = opts;
    const { framebuffers } = this.state;
    const { allAggregationModel } = this;
    this.device.withParametersWebGL({
      ...clearParams,
      framebuffer: minOrMaxFb,
      viewport: [0, 0, gridSize[0], gridSize[1]]
    }, () => {
      this.device.clearWebGL({ color: true });
      allAggregationModel.setUniforms({ gridSize, combineMaxMin });
      allAggregationModel.setBindings({ uSampler: framebuffers[id].texture });
      allAggregationModel.draw();
    });
  }
  _renderToWeightsTexture(opts) {
    const { id, parameters, moduleSettings, uniforms, gridSize, weights } = opts;
    const { framebuffers, equations, weightAttributes } = this.state;
    const { gridAggregationModel } = this;
    const { operation } = weights[id];
    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];
    this.device.withParametersWebGL({
      framebuffer: framebuffers[id],
      viewport: [0, 0, gridSize[0], gridSize[1]],
      clearColor
    }, () => {
      this.device.clearWebGL({ color: true });
      const attributes = { weights: weightAttributes[id] };
      gridAggregationModel.draw({
        parameters: { ...parameters, blendEquation: equations[id] },
        moduleSettings,
        uniforms,
        attributes
      });
    });
    if (operation === AGGREGATION_OPERATION.MEAN) {
      const { meanTextures, textures } = this.state;
      const transformOptions = {
        _sourceTextures: { aggregationValues: meanTextures[id] },
        _targetTexture: textures[id],
        elementCount: textures[id].width * textures[id].height
      };
      if (this.meanTransform) {
        this.meanTransform.update(transformOptions);
      } else {
        this.meanTransform = getMeanTransform(this.device, transformOptions);
      }
      this.meanTransform.run({
        parameters: {
          blend: false,
          depthTest: false
        }
      });
      framebuffers[id].attach({ [36064]: textures[id] });
    }
  }
  _runAggregation(opts) {
    this._updateModels(opts);
    this._setupFramebuffers(opts);
    this._renderAggregateData(opts);
    const results = this._getAggregateData(opts);
    this.setState({ results });
    return results;
  }
  _setupFramebuffers(opts) {
    const { textures, framebuffers, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, equations } = this.state;
    const { weights } = opts;
    const { numCol, numRow } = opts;
    const framebufferSize = { width: numCol, height: numRow };
    for (const id in weights) {
      const { needMin, needMax, combineMaxMin, operation } = weights[id];
      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.device, { id: `${id}-texture`, width: numCol, height: numRow });
      textures[id].resize(framebufferSize);
      let texture = textures[id];
      if (operation === AGGREGATION_OPERATION.MEAN) {
        meanTextures[id] = meanTextures[id] || getFloatTexture(this.device, { id: `${id}-mean-texture`, width: numCol, height: numRow });
        meanTextures[id].resize(framebufferSize);
        texture = meanTextures[id];
      }
      if (framebuffers[id]) {
        framebuffers[id].attach({ [36064]: texture });
      } else {
        framebuffers[id] = getFramebuffer(this.device, {
          id: `${id}-fb`,
          width: numCol,
          height: numRow,
          texture
        });
      }
      framebuffers[id].resize(framebufferSize);
      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP[AGGREGATION_OPERATION.SUM];
      if (needMin || needMax) {
        if (needMin && needMax && combineMaxMin) {
          if (!maxMinFramebuffers[id]) {
            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);
            maxMinFramebuffers[id] = getFramebuffer(this.device, { id: `${id}-maxMinFb`, texture });
          }
        } else {
          if (needMin) {
            if (!minFramebuffers[id]) {
              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);
              minFramebuffers[id] = getFramebuffer(this.device, {
                id: `${id}-minFb`,
                texture
              });
            }
          }
          if (needMax) {
            if (!maxFramebuffers[id]) {
              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);
              maxFramebuffers[id] = getFramebuffer(this.device, {
                id: `${id}-maxFb`,
                texture
              });
            }
          }
        }
      }
    }
  }
  _getMinMaxTexture(name) {
    const { resources } = this.state;
    if (!resources[name]) {
      resources[name] = getFloatTexture(this.device, { id: "resourceName" });
    }
    return resources[name];
  }
  _setupModels({ numCol = 0, numRow = 0 } = {}) {
    var _a;
    const { shaderOptions } = this.state;
    (_a = this.gridAggregationModel) == null ? void 0 : _a.destroy();
    this.gridAggregationModel = getAggregationModel(this.device, shaderOptions);
    if (!this.allAggregationModel) {
      const instanceCount = numCol * numRow;
      this.allAggregationModel = getAllAggregationModel(this.device, instanceCount);
    }
  }
  _setupWeightAttributes(opts) {
    const { weightAttributes } = this.state;
    const { weights } = opts;
    for (const id in weights) {
      weightAttributes[id] = opts.attributes[id];
    }
  }
  _trackGPUResultBuffers(results, weights) {
    const { resources } = this.state;
    for (const id in results) {
      if (results[id]) {
        for (const bufferName of BUFFER_NAMES) {
          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {
            const name = `gpu-result-${id}-${bufferName}`;
            if (resources[name]) {
              resources[name].delete();
            }
            resources[name] = results[id][bufferName];
          }
        }
      }
    }
  }
  _updateModels(opts) {
    const { vertexCount, attributes, numCol, numRow } = opts;
    const { modelDirty } = this.state;
    if (modelDirty) {
      this._setupModels(opts);
      this.setState({ modelDirty: false });
    }
    this._setupWeightAttributes(opts);
    this.gridAggregationModel.setVertexCount(vertexCount);
    this.gridAggregationModel.setAttributes(attributes);
    this.allAggregationModel.setInstanceCount(numCol * numRow);
  }
};
function normalizeWeightParams(weights) {
  const result = {};
  for (const id in weights) {
    result[id] = { ...DEFAULT_WEIGHT_PARAMS, ...weights[id] };
  }
  return result;
}
function deleteResources(resources) {
  resources = Array.isArray(resources) ? resources : [resources];
  resources.forEach((obj) => {
    for (const name in obj) {
      obj[name].delete();
    }
  });
}
function getAggregationModel(device, shaderOptions) {
  const shaders = (0, import_core._mergeShaders)({
    vs: aggregate_to_grid_vs_glsl_default,
    fs: aggregate_to_grid_fs_glsl_default,
    modules: [import_shadertools.fp64arithmetic, import_core.project32]
  }, shaderOptions);
  return new import_engine.Model(device, {
    id: "Grid-Aggregation-Model",
    vertexCount: 1,
    drawMode: 0,
    shaderAssembler: (0, import_core.getShaderAssembler)(),
    ...shaders
  });
}
function getAllAggregationModel(device, instanceCount) {
  return new import_engine.Model(device, {
    id: "All-Aggregation-Model",
    vs: aggregate_all_vs_glsl_default,
    fs: aggregate_all_fs_glsl_default,
    modules: [import_shadertools.fp64arithmetic],
    vertexCount: 1,
    topology: "point-list",
    isInstanced: true,
    instanceCount,
    attributes: {
      position: [0, 0]
    }
  });
}
function getMeanTransform(device, opts) {
  return new import_engine.TextureTransform(device, {
    vs: transform_mean_vs_glsl_default,
    _targetTextureVarying: "meanValues",
    ...opts
  });
}

// dist/screen-grid-layer/screen-grid-cell-layer.js
var import_engine2 = require("@luma.gl/engine");
var import_core2 = require("@deck.gl/core");

// dist/utils/color-utils.js
var defaultColorRange = [
  [255, 255, 178],
  [254, 217, 118],
  [254, 178, 76],
  [253, 141, 60],
  [240, 59, 32],
  [189, 0, 38]
];
function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {
  let flatArray;
  if (Number.isFinite(colorRange[0])) {
    flatArray = new ArrayType(colorRange);
  } else {
    flatArray = new ArrayType(colorRange.length * 4);
    let index = 0;
    for (let i = 0; i < colorRange.length; i++) {
      const color = colorRange[i];
      flatArray[index++] = color[0];
      flatArray[index++] = color[1];
      flatArray[index++] = color[2];
      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
    }
  }
  if (normalize) {
    for (let i = 0; i < flatArray.length; i++) {
      flatArray[i] /= 255;
    }
  }
  return flatArray;
}

// dist/screen-grid-layer/screen-grid-layer-vertex.glsl.js
var screen_grid_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 instancePositions;
in vec4 instanceCounts;
in vec3 instancePickingColors;
uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;
out vec4 vColor;
out float vSampleCount;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= domain.x && value <= domain.y) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
outColor = outColor / 255.;
return outColor;
}
void main(void) {
vSampleCount = instanceCounts.a;
float weight = instanceCounts.r;
float maxWeight = texture(maxTexture, vec2(0.5)).r;
float step = weight / maxWeight;
vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;
vec2 domain = colorDomain;
float domainMaxValid = float(colorDomain.y != 0.);
domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
vec4 rangeColor = quantizeScale(domain, colorRange, weight);
float rangeMinMax = float(shouldUseMinMax);
vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
vColor = vec4(color.rgb, color.a * opacity);
picking_setPickingColor(instancePickingColors);
gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`;

// dist/screen-grid-layer/screen-grid-layer-fragment.glsl.js
var screen_grid_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
in float vSampleCount;
out vec4 fragColor;
void main(void) {
if (vSampleCount <= 0.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// dist/screen-grid-layer/screen-grid-cell-layer.js
var DEFAULT_MINCOLOR = [0, 0, 0, 0];
var DEFAULT_MAXCOLOR = [0, 255, 0, 255];
var COLOR_PROPS = ["minColor", "maxColor", "colorRange", "colorDomain"];
var defaultProps = {
  cellSizePixels: { type: "number", value: 100, min: 1 },
  cellMarginPixels: { type: "number", value: 2, min: 0, max: 5 },
  colorDomain: null,
  colorRange: defaultColorRange
};
var _ScreenGridCellLayer = class extends import_core2.Layer {
  getShaders() {
    return { vs: screen_grid_layer_vertex_glsl_default, fs: screen_grid_layer_fragment_glsl_default, modules: [import_core2.picking] };
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: { size: 3, update: this.calculateInstancePositions },
      instanceCounts: { size: 4, noAlloc: true }
    });
    this.setState({
      model: this._getModel()
    });
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState(params) {
    super.updateState(params);
    const { oldProps, props, changeFlags } = params;
    const attributeManager = this.getAttributeManager();
    if (props.numInstances !== oldProps.numInstances) {
      attributeManager.invalidateAll();
    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {
      attributeManager.invalidate("instancePositions");
    }
    this._updateUniforms(oldProps, props, changeFlags);
  }
  draw({ uniforms }) {
    const { parameters, maxTexture } = this.props;
    const minColor = this.props.minColor || DEFAULT_MINCOLOR;
    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;
    const colorDomain = this.props.colorDomain || [1, 0];
    const model = this.state.model;
    model.setUniforms(uniforms);
    model.setBindings({
      maxTexture
    });
    model.setUniforms({
      minColor,
      maxColor,
      colorDomain
    });
    model.setParameters({
      depthWriteEnabled: false,
      ...parameters
    });
    model.draw(this.context.renderPass);
  }
  calculateInstancePositions(attribute, { numInstances }) {
    const { width, height } = this.context.viewport;
    const { cellSizePixels } = this.props;
    const numCol = Math.ceil(width / cellSizePixels);
    const { value, size } = attribute;
    for (let i = 0; i < numInstances; i++) {
      const x = i % numCol;
      const y = Math.floor(i / numCol);
      value[i * size + 0] = x * cellSizePixels / width * 2 - 1;
      value[i * size + 1] = 1 - y * cellSizePixels / height * 2;
      value[i * size + 2] = 0;
    }
  }
  _getModel() {
    return new import_engine2.Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new import_engine2.Geometry({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array([
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            1,
            0
          ])
        }
      })
    });
  }
  _shouldUseMinMax() {
    const { minColor, maxColor, colorDomain, colorRange } = this.props;
    if (minColor || maxColor) {
      import_core2.log.deprecated("ScreenGridLayer props: minColor and maxColor", "colorRange, colorDomain")();
      return true;
    }
    if (colorDomain || colorRange) {
      return false;
    }
    return true;
  }
  _updateUniforms(oldProps, props, changeFlags) {
    const model = this.state.model;
    if (COLOR_PROPS.some((key) => oldProps[key] !== props[key])) {
      model.setUniforms({ shouldUseMinMax: this._shouldUseMinMax() });
    }
    if (oldProps.colorRange !== props.colorRange) {
      model.setUniforms({ colorRange: colorRangeToFlatArray(props.colorRange) });
    }
    if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
      const { width, height } = this.context.viewport;
      const { cellSizePixels, cellMarginPixels } = this.props;
      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;
      const cellScale = new Float32Array([
        (cellSizePixels - margin) / width * 2,
        -(cellSizePixels - margin) / height * 2,
        1
      ]);
      model.setUniforms({ cellScale });
    }
  }
};
var ScreenGridCellLayer = _ScreenGridCellLayer;
(() => {
  _ScreenGridCellLayer.layerName = "ScreenGridCellLayer";
})();
(() => {
  _ScreenGridCellLayer.defaultProps = defaultProps;
})();

// dist/grid-aggregation-layer.js
var import_constants3 = require("@luma.gl/constants");
var import_core7 = require("@deck.gl/core");

// dist/aggregation-layer.js
var import_core3 = require("@deck.gl/core");

// dist/utils/prop-utils.js
function filterProps(props, filterKeys) {
  const filteredProps = {};
  for (const key in props) {
    if (!filterKeys.includes(key)) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// dist/aggregation-layer.js
var _AggregationLayer = class extends import_core3.CompositeLayer {
  initializeAggregationLayer(dimensions) {
    super.initializeState(this.context);
    this.setState({
      ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),
      dimensions
    });
  }
  updateState(opts) {
    super.updateState(opts);
    const { changeFlags } = opts;
    if (changeFlags.extensionsChanged) {
      const shaders = this.getShaders({});
      if (shaders && shaders.defines) {
        shaders.defines.NON_INSTANCED_MODEL = 1;
      }
      this.updateShaders(shaders);
    }
    this._updateAttributes();
  }
  updateAttributes(changedAttributes) {
    this.setState({ changedAttributes });
  }
  getAttributes() {
    return this.getAttributeManager().getAttributes();
  }
  getModuleSettings() {
    const { viewport, mousePosition, device } = this.context;
    const moduleSettings = Object.assign(Object.create(this.props), {
      viewport,
      mousePosition,
      picking: {
        isActive: 0
      },
      devicePixelRatio: device.canvasContext.cssToDeviceRatio()
    });
    return moduleSettings;
  }
  updateShaders(shaders) {
  }
  isAggregationDirty(updateOpts, params = {}) {
    const { props, oldProps, changeFlags } = updateOpts;
    const { compareAll = false, dimension } = params;
    const { ignoreProps } = this.state;
    const { props: dataProps, accessors = [] } = dimension;
    const { updateTriggersChanged } = changeFlags;
    if (changeFlags.dataChanged) {
      return true;
    }
    if (updateTriggersChanged) {
      if (updateTriggersChanged.all) {
        return true;
      }
      for (const accessor of accessors) {
        if (updateTriggersChanged[accessor]) {
          return true;
        }
      }
    }
    if (compareAll) {
      if (changeFlags.extensionsChanged) {
        return true;
      }
      return (0, import_core3._compareProps)({
        oldProps,
        newProps: props,
        ignoreProps,
        propTypes: this.constructor._propTypes
      });
    }
    for (const name of dataProps) {
      if (props[name] !== oldProps[name]) {
        return true;
      }
    }
    return false;
  }
  isAttributeChanged(name) {
    const { changedAttributes } = this.state;
    if (!name) {
      return !isObjectEmpty(changedAttributes);
    }
    return changedAttributes && changedAttributes[name] !== void 0;
  }
  _getAttributeManager() {
    return new import_core3.AttributeManager(this.context.device, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
};
var AggregationLayer = _AggregationLayer;
(() => {
  _AggregationLayer.layerName = "AggregationLayer";
})();
function isObjectEmpty(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}

// dist/utils/scale-utils.js
var import_core4 = require("@deck.gl/core");
function getScale(domain, range, scaleFunction) {
  const scale = scaleFunction;
  scale.domain = () => domain;
  scale.range = () => range;
  return scale;
}
function getQuantizeScale(domain, range) {
  const scaleFunction = (value) => quantizeScale(domain, range, value);
  return getScale(domain, range, scaleFunction);
}
function getLinearScale(domain, range) {
  const scaleFunction = (value) => linearScale(domain, range, value);
  return getScale(domain, range, scaleFunction);
}
function getQuantileScale(domain, range) {
  const sortedDomain = domain.sort(ascending);
  let i = 0;
  const n = Math.max(1, range.length);
  const thresholds = new Array(n - 1);
  while (++i < n) {
    thresholds[i - 1] = threshold(sortedDomain, i / n);
  }
  const scaleFunction = (value) => thresholdsScale(thresholds, range, value);
  scaleFunction.thresholds = () => thresholds;
  return getScale(domain, range, scaleFunction);
}
function ascending(a, b) {
  return a - b;
}
function threshold(domain, fraction) {
  const domainLength = domain.length;
  if (fraction <= 0 || domainLength < 2) {
    return domain[0];
  }
  if (fraction >= 1) {
    return domain[domainLength - 1];
  }
  const domainFraction = (domainLength - 1) * fraction;
  const lowIndex = Math.floor(domainFraction);
  const low = domain[lowIndex];
  const high = domain[lowIndex + 1];
  return low + (high - low) * (domainFraction - lowIndex);
}
function bisectRight(a, x) {
  let lo = 0;
  let hi = a.length;
  while (lo < hi) {
    const mid = lo + hi >>> 1;
    if (ascending(a[mid], x) > 0) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return lo;
}
function thresholdsScale(thresholds, range, value) {
  return range[bisectRight(thresholds, value)];
}
function ordinalScale(domain, domainMap, range, value) {
  const key = `${value}`;
  let d = domainMap.get(key);
  if (d === void 0) {
    d = domain.push(value);
    domainMap.set(key, d);
  }
  return range[(d - 1) % range.length];
}
function getOrdinalScale(domain, range) {
  const domainMap = /* @__PURE__ */ new Map();
  const uniqueDomain = [];
  for (const d of domain) {
    const key = `${d}`;
    if (!domainMap.has(key)) {
      domainMap.set(key, uniqueDomain.push(d));
    }
  }
  const scaleFunction = (value) => ordinalScale(uniqueDomain, domainMap, range, value);
  return getScale(domain, range, scaleFunction);
}
function quantizeScale(domain, range, value) {
  const domainRange = domain[1] - domain[0];
  if (domainRange <= 0) {
    import_core4.log.warn("quantizeScale: invalid domain, returning range[0]")();
    return range[0];
  }
  const step = domainRange / range.length;
  const idx = Math.floor((value - domain[0]) / step);
  const clampIdx = Math.max(Math.min(idx, range.length - 1), 0);
  return range[clampIdx];
}
function linearScale(domain, range, value) {
  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
}
function notNullOrUndefined(d) {
  return d !== void 0 && d !== null;
}
function unique(values) {
  const results = [];
  values.forEach((v) => {
    if (!results.includes(v) && notNullOrUndefined(v)) {
      results.push(v);
    }
  });
  return results;
}
function getTruthyValues(data, valueAccessor) {
  const values = typeof valueAccessor === "function" ? data.map(valueAccessor) : data;
  return values.filter(notNullOrUndefined);
}
function getQuantileDomain(data, valueAccessor) {
  return getTruthyValues(data, valueAccessor);
}
function getOrdinalDomain(data, valueAccessor) {
  return unique(getTruthyValues(data, valueAccessor));
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function getScaleFunctionByScaleType(scaleType) {
  switch (scaleType) {
    case "quantize":
      return getQuantizeScale;
    case "linear":
      return getLinearScale;
    case "quantile":
      return getQuantileScale;
    case "ordinal":
      return getOrdinalScale;
    default:
      return getQuantizeScale;
  }
}

// dist/utils/bin-sorter.js
var defaultGetValue = (points) => points.length;
var MAX_32_BIT_FLOAT2 = 3402823466e29;
var defaultGetPoints = (bin) => bin.points;
var defaultGetIndex = (bin) => bin.index;
var ascending2 = (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
var defaultProps2 = {
  getValue: defaultGetValue,
  getPoints: defaultGetPoints,
  getIndex: defaultGetIndex,
  filterData: null
};
var BinSorter = class {
  constructor(bins = [], props = defaultProps2) {
    this.aggregatedBins = this.getAggregatedBins(bins, props);
    this._updateMinMaxValues();
    this.binMap = this.getBinMap();
  }
  getAggregatedBins(bins, props) {
    const { getValue = defaultGetValue, getPoints = defaultGetPoints, getIndex = defaultGetIndex, filterData } = props;
    const hasFilter = typeof filterData === "function";
    const binCount = bins.length;
    const aggregatedBins = [];
    let index = 0;
    for (let binIndex = 0; binIndex < binCount; binIndex++) {
      const bin = bins[binIndex];
      const points = getPoints(bin);
      const i = getIndex(bin);
      const filteredPoints = hasFilter ? points.filter(filterData) : points;
      bin.filteredPoints = hasFilter ? filteredPoints : null;
      const value = filteredPoints.length ? getValue(filteredPoints) : null;
      if (value !== null && value !== void 0) {
        aggregatedBins[index] = {
          i: Number.isFinite(i) ? i : binIndex,
          value,
          counts: filteredPoints.length
        };
        index++;
      }
    }
    return aggregatedBins;
  }
  _percentileToIndex(percentileRange) {
    const len = this.sortedBins.length;
    if (len < 2) {
      return [0, 0];
    }
    const [lower, upper] = percentileRange.map((n) => clamp(n, 0, 100));
    const lowerIdx = Math.ceil(lower / 100 * (len - 1));
    const upperIdx = Math.floor(upper / 100 * (len - 1));
    return [lowerIdx, upperIdx];
  }
  getBinMap() {
    const binMap = {};
    for (const bin of this.aggregatedBins) {
      binMap[bin.i] = bin;
    }
    return binMap;
  }
  _updateMinMaxValues() {
    let maxCount = 0;
    let maxValue = 0;
    let minValue = MAX_32_BIT_FLOAT2;
    let totalCount = 0;
    for (const x of this.aggregatedBins) {
      maxCount = maxCount > x.counts ? maxCount : x.counts;
      maxValue = maxValue > x.value ? maxValue : x.value;
      minValue = minValue < x.value ? minValue : x.value;
      totalCount += x.counts;
    }
    this.maxCount = maxCount;
    this.maxValue = maxValue;
    this.minValue = minValue;
    this.totalCount = totalCount;
  }
  getValueRange(percentileRange) {
    if (!this.sortedBins) {
      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending2(a.value, b.value));
    }
    if (!this.sortedBins.length) {
      return [];
    }
    let lowerIdx = 0;
    let upperIdx = this.sortedBins.length - 1;
    if (Array.isArray(percentileRange)) {
      const idxRange = this._percentileToIndex(percentileRange);
      lowerIdx = idxRange[0];
      upperIdx = idxRange[1];
    }
    return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
  }
  getValueDomainByScale(scale, [lower = 0, upper = 100] = []) {
    if (!this.sortedBins) {
      this.sortedBins = this.aggregatedBins.sort((a, b) => ascending2(a.value, b.value));
    }
    if (!this.sortedBins.length) {
      return [];
    }
    const indexEdge = this._percentileToIndex([lower, upper]);
    return this._getScaleDomain(scale, indexEdge);
  }
  _getScaleDomain(scaleType, [lowerIdx, upperIdx]) {
    const bins = this.sortedBins;
    switch (scaleType) {
      case "quantize":
      case "linear":
        return [bins[lowerIdx].value, bins[upperIdx].value];
      case "quantile":
        return getQuantileDomain(bins.slice(lowerIdx, upperIdx + 1), (d) => d.value);
      case "ordinal":
        return getOrdinalDomain(bins, (d) => d.value);
      default:
        return [bins[lowerIdx].value, bins[upperIdx].value];
    }
  }
};

// dist/cpu-grid-layer/grid-aggregator.js
var import_core6 = require("@deck.gl/core");

// dist/utils/grid-aggregation-utils.js
var import_core5 = require("@deck.gl/core");
var R_EARTH = 6378e3;
function toFinite(n) {
  return Number.isFinite(n) ? n : 0;
}
function getBoundingBox(attributes, vertexCount) {
  const positions = attributes.positions.value;
  let yMin = Infinity;
  let yMax = -Infinity;
  let xMin = Infinity;
  let xMax = -Infinity;
  let y;
  let x;
  for (let i = 0; i < vertexCount; i++) {
    x = positions[i * 3];
    y = positions[i * 3 + 1];
    yMin = y < yMin ? y : yMin;
    yMax = y > yMax ? y : yMax;
    xMin = x < xMin ? x : xMin;
    xMax = x > xMax ? x : xMax;
  }
  const boundingBox = {
    xMin: toFinite(xMin),
    xMax: toFinite(xMax),
    yMin: toFinite(yMin),
    yMax: toFinite(yMax)
  };
  return boundingBox;
}
function getTranslation(boundingBox, gridOffset, coordinateSystem, viewport) {
  const { width, height } = viewport;
  const worldOrigin = coordinateSystem === import_core5.COORDINATE_SYSTEM.CARTESIAN ? [-width / 2, -height / 2] : [-180, -90];
  import_core5.log.assert(coordinateSystem === import_core5.COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === import_core5.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === import_core5.COORDINATE_SYSTEM.DEFAULT);
  const { xMin, yMin } = boundingBox;
  return [
    -1 * (alignToCell(xMin - worldOrigin[0], gridOffset.xOffset) + worldOrigin[0]),
    -1 * (alignToCell(yMin - worldOrigin[1], gridOffset.yOffset) + worldOrigin[1])
  ];
}
function alignToCell(inValue, cellSize) {
  const sign = inValue < 0 ? -1 : 1;
  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);
  value = Math.floor(value / cellSize) * cellSize;
  return value * sign;
}
function getGridOffset(boundingBox, cellSize, convertToMeters = true) {
  if (!convertToMeters) {
    return { xOffset: cellSize, yOffset: cellSize };
  }
  const { yMin, yMax } = boundingBox;
  const centerLat = (yMin + yMax) / 2;
  return calculateGridLatLonOffset(cellSize, centerLat);
}
function getGridParams(boundingBox, cellSize, viewport, coordinateSystem) {
  const gridOffset = getGridOffset(boundingBox, cellSize, coordinateSystem !== import_core5.COORDINATE_SYSTEM.CARTESIAN);
  const translation = getTranslation(boundingBox, gridOffset, coordinateSystem, viewport);
  const { xMin, yMin, xMax, yMax } = boundingBox;
  const width = xMax - xMin + gridOffset.xOffset;
  const height = yMax - yMin + gridOffset.yOffset;
  const numCol = Math.ceil(width / gridOffset.xOffset);
  const numRow = Math.ceil(height / gridOffset.yOffset);
  return { gridOffset, translation, width, height, numCol, numRow };
}
function calculateGridLatLonOffset(cellSize, latitude) {
  const yOffset = calculateLatOffset(cellSize);
  const xOffset = calculateLonOffset(latitude, cellSize);
  return { yOffset, xOffset };
}
function calculateLatOffset(dy) {
  return dy / R_EARTH * (180 / Math.PI);
}
function calculateLonOffset(lat, dx) {
  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);
}

// dist/cpu-grid-layer/grid-aggregator.js
function pointToDensityGridDataCPU(props, aggregationParams) {
  const hashInfo = pointsToGridHashing(props, aggregationParams);
  const result = getGridLayerDataFromGridHash(hashInfo);
  return {
    gridHash: hashInfo.gridHash,
    gridOffset: hashInfo.gridOffset,
    data: result
  };
}
function pointsToGridHashing(props, aggregationParams) {
  const { data = [], cellSize } = props;
  const { attributes, viewport, projectPoints, numInstances } = aggregationParams;
  const positions = attributes.positions.value;
  const { size } = attributes.positions.getAccessor();
  const boundingBox = aggregationParams.boundingBox || getPositionBoundingBox(attributes.positions, numInstances);
  const offsets = aggregationParams.posOffset || [180, 90];
  const gridOffset = aggregationParams.gridOffset || getGridOffset(boundingBox, cellSize);
  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {
    return { gridHash: {}, gridOffset, offsets: [0, 0] };
  }
  const { width, height } = viewport;
  const numCol = Math.ceil(width / gridOffset.xOffset);
  const numRow = Math.ceil(height / gridOffset.yOffset);
  const gridHash = {};
  const { iterable, objectInfo } = (0, import_core6.createIterable)(data);
  const position = new Array(3);
  for (const pt of iterable) {
    objectInfo.index++;
    position[0] = positions[objectInfo.index * size];
    position[1] = positions[objectInfo.index * size + 1];
    position[2] = size >= 3 ? positions[objectInfo.index * size + 2] : 0;
    const [x, y] = projectPoints ? viewport.project(position) : position;
    if (Number.isFinite(x) && Number.isFinite(y)) {
      const yIndex = Math.floor((y + offsets[1]) / gridOffset.yOffset);
      const xIndex = Math.floor((x + offsets[0]) / gridOffset.xOffset);
      if (!projectPoints || xIndex >= 0 && xIndex < numCol && yIndex >= 0 && yIndex < numRow) {
        const key = `${yIndex}-${xIndex}`;
        gridHash[key] = gridHash[key] || { count: 0, points: [], lonIdx: xIndex, latIdx: yIndex };
        gridHash[key].count += 1;
        gridHash[key].points.push({
          source: pt,
          index: objectInfo.index
        });
      }
    }
  }
  return { gridHash, gridOffset, offsets: [offsets[0] * -1, offsets[1] * -1] };
}
function getGridLayerDataFromGridHash({ gridHash, gridOffset, offsets }) {
  const data = new Array(Object.keys(gridHash).length);
  let i = 0;
  for (const key in gridHash) {
    const idxs = key.split("-");
    const latIdx = parseInt(idxs[0], 10);
    const lonIdx = parseInt(idxs[1], 10);
    const index = i++;
    data[index] = {
      index,
      position: [
        offsets[0] + gridOffset.xOffset * lonIdx,
        offsets[1] + gridOffset.yOffset * latIdx
      ],
      ...gridHash[key]
    };
  }
  return data;
}
function getPositionBoundingBox(positionAttribute, numInstance) {
  const positions = positionAttribute.value;
  const { size } = positionAttribute.getAccessor();
  let yMin = Infinity;
  let yMax = -Infinity;
  let xMin = Infinity;
  let xMax = -Infinity;
  let y;
  let x;
  for (let i = 0; i < numInstance; i++) {
    x = positions[i * size];
    y = positions[i * size + 1];
    if (Number.isFinite(x) && Number.isFinite(y)) {
      yMin = y < yMin ? y : yMin;
      yMax = y > yMax ? y : yMax;
      xMin = x < xMin ? x : xMin;
      xMax = x > xMax ? x : xMax;
    }
  }
  return { xMin, xMax, yMin, yMax };
}

// dist/grid-aggregation-layer.js
var _GridAggregationLayer = class extends AggregationLayer {
  initializeAggregationLayer({ dimensions }) {
    super.initializeAggregationLayer(dimensions);
    this.setState({
      layerData: {},
      gpuGridAggregator: new GPUGridAggregator(this.context.device, {
        id: `${this.id}-gpu-aggregator`
      }),
      cpuGridAggregator: pointToDensityGridDataCPU
    });
  }
  updateState(opts) {
    super.updateState(opts);
    this.updateAggregationState(opts);
    const { aggregationDataDirty, aggregationWeightsDirty, gpuAggregation } = this.state;
    if (this.getNumInstances() <= 0) {
      return;
    }
    let aggregationDirty = false;
    if (aggregationDataDirty || gpuAggregation && aggregationWeightsDirty) {
      this._updateAggregation(opts);
      aggregationDirty = true;
    }
    if (!gpuAggregation && (aggregationDataDirty || aggregationWeightsDirty)) {
      this._updateWeightBins();
      this._uploadAggregationResults();
      aggregationDirty = true;
    }
    this.setState({ aggregationDirty });
  }
  finalizeState(context) {
    var _a;
    const { count } = this.state.weights;
    if (count && count.aggregationBuffer) {
      count.aggregationBuffer.delete();
    }
    (_a = this.state.gpuGridAggregator) == null ? void 0 : _a.delete();
    super.finalizeState(context);
  }
  updateShaders(shaders) {
    if (this.state.gpuAggregation) {
      this.state.gpuGridAggregator.updateShaders(shaders);
    }
  }
  updateAggregationState(opts) {
    import_core7.log.assert(false);
  }
  allocateResources(numRow, numCol) {
    if (this.state.numRow !== numRow || this.state.numCol !== numCol) {
      const dataBytes = numCol * numRow * 4 * 4;
      const { weights } = this.state;
      for (const name in weights) {
        const weight = weights[name];
        if (weight.aggregationBuffer) {
          weight.aggregationBuffer.delete();
        }
        weight.aggregationBuffer = this.context.device.createBuffer({
          byteLength: dataBytes,
          accessor: {
            size: 4,
            type: 5126,
            divisor: 1
          }
        });
      }
    }
  }
  updateResults({ aggregationData, maxMinData, maxData, minData }) {
    const { count } = this.state.weights;
    if (count) {
      count.aggregationData = aggregationData;
      count.maxMinData = maxMinData;
      count.maxData = maxData;
      count.minData = minData;
    }
  }
  _updateAggregation(opts) {
    const { cpuGridAggregator, gpuGridAggregator, gridOffset, posOffset, translation = [0, 0], scaling = [0, 0, 0], boundingBox, projectPoints, gpuAggregation, numCol, numRow } = this.state;
    const { props } = opts;
    const { viewport } = this.context;
    const attributes = this.getAttributes();
    const vertexCount = this.getNumInstances();
    if (!gpuAggregation) {
      const result = cpuGridAggregator(props, {
        gridOffset,
        projectPoints,
        attributes,
        viewport,
        posOffset,
        boundingBox
      });
      this.setState({
        layerData: result
      });
    } else {
      const { weights } = this.state;
      gpuGridAggregator.run({
        weights,
        cellSize: [gridOffset.xOffset, gridOffset.yOffset],
        numCol,
        numRow,
        translation,
        scaling,
        vertexCount,
        projectPoints,
        attributes,
        moduleSettings: this.getModuleSettings()
      });
    }
  }
  _updateWeightBins() {
    const { getValue } = this.state;
    const sortedBins = new BinSorter(this.state.layerData.data || [], { getValue });
    this.setState({ sortedBins });
  }
  _uploadAggregationResults() {
    const { numCol, numRow } = this.state;
    const { data } = this.state.layerData;
    const { aggregatedBins, minValue, maxValue, totalCount } = this.state.sortedBins;
    const ELEMENTCOUNT = 4;
    const aggregationSize = numCol * numRow * ELEMENTCOUNT;
    const aggregationData = new Float32Array(aggregationSize).fill(0);
    for (const bin of aggregatedBins) {
      const { lonIdx, latIdx } = data[bin.i];
      const { value, counts } = bin;
      const cellIndex = (lonIdx + latIdx * numCol) * ELEMENTCOUNT;
      aggregationData[cellIndex] = value;
      aggregationData[cellIndex + ELEMENTCOUNT - 1] = counts;
    }
    const maxMinData = new Float32Array([maxValue, 0, 0, minValue]);
    const maxData = new Float32Array([maxValue, 0, 0, totalCount]);
    const minData = new Float32Array([minValue, 0, 0, totalCount]);
    this.updateResults({ aggregationData, maxMinData, maxData, minData });
  }
};
var GridAggregationLayer = _GridAggregationLayer;
(() => {
  _GridAggregationLayer.layerName = "GridAggregationLayer";
})();

// dist/screen-grid-layer/screen-grid-layer.js
var defaultProps3 = {
  ...ScreenGridCellLayer.defaultProps,
  getPosition: { type: "accessor", value: (d) => d.position },
  getWeight: { type: "accessor", value: 1 },
  gpuAggregation: false,
  aggregation: "SUM"
};
var POSITION_ATTRIBUTE_NAME = "positions";
var DIMENSIONS = {
  data: {
    props: ["cellSizePixels"]
  },
  weights: {
    props: ["aggregation"],
    accessors: ["getWeight"]
  }
};
var _ScreenGridLayer = class extends GridAggregationLayer {
  initializeState() {
    super.initializeAggregationLayer({
      dimensions: DIMENSIONS,
      getCellSize: (props) => props.cellSizePixels
    });
    const weights = {
      count: {
        size: 1,
        operation: AGGREGATION_OPERATION.SUM,
        needMax: true,
        maxTexture: getFloatTexture(this.context.device, { id: `${this.id}-max-texture` })
      }
    };
    this.setState({
      supported: true,
      projectPoints: true,
      weights,
      subLayerData: { attributes: {} },
      maxTexture: weights.count.maxTexture,
      positionAttributeName: "positions",
      posOffset: [0, 0],
      translation: [1, -1]
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME]: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      count: { size: 3, accessor: "getWeight" }
    });
  }
  shouldUpdateState({ changeFlags }) {
    return this.state.supported && changeFlags.somethingChanged;
  }
  updateState(opts) {
    super.updateState(opts);
  }
  renderLayers() {
    if (!this.state.supported) {
      return [];
    }
    const { maxTexture, numRow, numCol, weights } = this.state;
    const { updateTriggers } = this.props;
    const { aggregationBuffer } = weights.count;
    const CellLayerClass = this.getSubLayerClass("cells", ScreenGridCellLayer);
    return new CellLayerClass(this.props, this.getSubLayerProps({
      id: "cell-layer",
      updateTriggers
    }), {
      data: { attributes: { instanceCounts: aggregationBuffer } },
      maxTexture,
      numInstances: numRow * numCol
    });
  }
  finalizeState(context) {
    super.finalizeState(context);
    const { aggregationBuffer, maxBuffer, maxTexture } = this.state;
    aggregationBuffer == null ? void 0 : aggregationBuffer.delete();
    maxBuffer == null ? void 0 : maxBuffer.delete();
    maxTexture == null ? void 0 : maxTexture.delete();
  }
  getPickingInfo({ info }) {
    const { index } = info;
    if (index >= 0) {
      const { gpuGridAggregator, gpuAggregation, weights } = this.state;
      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData("count") : weights.count;
      info.object = GPUGridAggregator.getAggregationData({
        pixelIndex: index,
        ...aggregationResults
      });
    }
    return info;
  }
  updateResults({ aggregationData, maxData }) {
    const { count } = this.state.weights;
    count.aggregationData = aggregationData;
    count.aggregationBuffer.write(aggregationData);
    count.maxData = maxData;
    count.maxTexture.setImageData({ data: maxData });
  }
  updateAggregationState(opts) {
    const cellSize = opts.props.cellSizePixels;
    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;
    const { viewportChanged } = opts.changeFlags;
    let gpuAggregation = opts.props.gpuAggregation;
    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {
      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {
        import_core8.log.warn("GPU Grid Aggregation not supported, falling back to CPU")();
        gpuAggregation = false;
      }
    }
    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
    this.setState({
      gpuAggregation
    });
    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);
    const { dimensions } = this.state;
    const { data, weights } = dimensions;
    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {
      compareAll: gpuAggregation,
      dimension: data
    });
    const aggregationWeightsDirty = this.isAggregationDirty(opts, { dimension: weights });
    this.setState({
      aggregationDataDirty,
      aggregationWeightsDirty
    });
    const { viewport } = this.context;
    if (viewportChanged || cellSizeChanged) {
      const { width, height } = viewport;
      const numCol = Math.ceil(width / cellSize);
      const numRow = Math.ceil(height / cellSize);
      this.allocateResources(numRow, numCol);
      this.setState({
        scaling: [width / 2, -height / 2, 1],
        gridOffset: { xOffset: cellSize, yOffset: cellSize },
        width,
        height,
        numCol,
        numRow
      });
    }
    if (aggregationWeightsDirty) {
      this._updateAccessors(opts);
    }
    if (aggregationDataDirty || aggregationWeightsDirty) {
      this._resetResults();
    }
  }
  _updateAccessors(opts) {
    const { getWeight, aggregation, data } = opts.props;
    const { count } = this.state.weights;
    if (count) {
      count.getWeight = getWeight;
      count.operation = AGGREGATION_OPERATION[aggregation];
    }
    this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });
  }
  _resetResults() {
    const { count } = this.state.weights;
    if (count) {
      count.aggregationData = null;
    }
  }
};
var ScreenGridLayer = _ScreenGridLayer;
(() => {
  _ScreenGridLayer.layerName = "ScreenGridLayer";
})();
(() => {
  _ScreenGridLayer.defaultProps = defaultProps3;
})();

// dist/cpu-grid-layer/cpu-grid-layer.js
var import_layers = require("@deck.gl/layers");

// dist/utils/cpu-aggregator.js
function noop() {
}
var dimensionSteps = ["getBins", "getDomain", "getScaleFunc"];
var defaultDimensions = [
  {
    key: "fillColor",
    accessor: "getFillColor",
    pickingInfo: "colorValue",
    getBins: {
      triggers: {
        value: {
          prop: "getColorValue",
          updateTrigger: "getColorValue"
        },
        weight: {
          prop: "getColorWeight",
          updateTrigger: "getColorWeight"
        },
        aggregation: {
          prop: "colorAggregation"
        },
        filterData: {
          prop: "_filterData",
          updateTrigger: "_filterData"
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: "lowerPercentile"
        },
        upperPercentile: {
          prop: "upperPercentile"
        },
        scaleType: {
          prop: "colorScaleType"
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: { prop: "colorDomain" },
        range: { prop: "colorRange" }
      },
      onSet: {
        props: "onSetColorDomain"
      }
    },
    nullValue: [0, 0, 0, 0]
  },
  {
    key: "elevation",
    accessor: "getElevation",
    pickingInfo: "elevationValue",
    getBins: {
      triggers: {
        value: {
          prop: "getElevationValue",
          updateTrigger: "getElevationValue"
        },
        weight: {
          prop: "getElevationWeight",
          updateTrigger: "getElevationWeight"
        },
        aggregation: {
          prop: "elevationAggregation"
        },
        filterData: {
          prop: "_filterData",
          updateTrigger: "_filterData"
        }
      }
    },
    getDomain: {
      triggers: {
        lowerPercentile: {
          prop: "elevationLowerPercentile"
        },
        upperPercentile: {
          prop: "elevationUpperPercentile"
        },
        scaleType: {
          prop: "elevationScaleType"
        }
      }
    },
    getScaleFunc: {
      triggers: {
        domain: { prop: "elevationDomain" },
        range: { prop: "elevationRange" }
      },
      onSet: {
        props: "onSetElevationDomain"
      }
    },
    nullValue: -1
  }
];
var defaultGetCellSize = (props) => props.cellSize;
var CPUAggregator = class {
  constructor(opts) {
    this.state = {
      layerData: {
        data: void 0
      },
      dimensions: {}
    };
    this.changeFlags = {};
    this.dimensionUpdaters = {};
    this._getCellSize = opts.getCellSize || defaultGetCellSize;
    this._getAggregator = opts.getAggregator;
    this._addDimension(opts.dimensions || defaultDimensions);
  }
  static defaultDimensions() {
    return defaultDimensions;
  }
  updateState(opts, aggregationParams) {
    const { oldProps, props, changeFlags } = opts;
    this.updateGetValueFuncs(oldProps, props, changeFlags);
    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);
    let aggregationDirty = false;
    if (changeFlags.dataChanged || reprojectNeeded) {
      this.getAggregatedData(props, aggregationParams);
      aggregationDirty = true;
    } else {
      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];
      dimensionChanges.forEach((f) => typeof f === "function" && f());
      aggregationDirty = true;
    }
    this.setState({ aggregationDirty });
    return this.state;
  }
  setState(updateObject) {
    this.state = { ...this.state, ...updateObject };
  }
  setDimensionState(key, updateObject) {
    this.setState({
      dimensions: {
        ...this.state.dimensions,
        [key]: { ...this.state.dimensions[key], ...updateObject }
      }
    });
  }
  normalizeResult(result = {}) {
    if (result.hexagons) {
      return { data: result.hexagons, ...result };
    } else if (result.layerData) {
      return { data: result.layerData, ...result };
    }
    return result;
  }
  getAggregatedData(props, aggregationParams) {
    const aggregator = this._getAggregator(props);
    const result = aggregator(props, aggregationParams);
    this.setState({
      layerData: this.normalizeResult(result)
    });
    this.changeFlags = {
      layerData: true
    };
    this.getSortedBins(props);
  }
  updateGetValueFuncs(oldProps, props, changeFlags) {
    for (const key in this.dimensionUpdaters) {
      const { value, weight, aggregation } = this.dimensionUpdaters[key].getBins.triggers;
      let getValue = props[value.prop];
      const getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);
      if (getValueChanged) {
        if (getValue) {
          getValue = wrapGetValueFunc(getValue, { data: props.data });
        } else {
          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], { data: props.data });
        }
      }
      if (getValue) {
        this.setDimensionState(key, { getValue });
      }
    }
  }
  needsReProjectPoints(oldProps, props, changeFlags) {
    return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);
  }
  addDimension(dimensions) {
    this._addDimension(dimensions);
  }
  _addDimension(dimensions = []) {
    dimensions.forEach((dimension) => {
      const { key } = dimension;
      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);
      this.state.dimensions[key] = {
        getValue: null,
        domain: null,
        sortedBins: null,
        scaleFunc: noop
      };
    });
  }
  getDimensionUpdaters({ key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue }) {
    return {
      key,
      accessor,
      pickingInfo,
      getBins: { updater: this.getDimensionSortedBins.bind(this), ...getBins },
      getDomain: { updater: this.getDimensionValueDomain.bind(this), ...getDomain },
      getScaleFunc: { updater: this.getDimensionScale.bind(this), ...getScaleFunc },
      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)
    };
  }
  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {
    return Object.values(dimensionStep.triggers).some((item) => {
      if (item.updateTrigger) {
        return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);
      }
      return oldProps[item.prop] !== props[item.prop];
    });
  }
  getDimensionChanges(oldProps, props, changeFlags) {
    const updaters = [];
    for (const key in this.dimensionUpdaters) {
      const needUpdate = dimensionSteps.find((step) => this.needUpdateDimensionStep(this.dimensionUpdaters[key][step], oldProps, props, changeFlags));
      if (needUpdate) {
        updaters.push(this.dimensionUpdaters[key][needUpdate].updater.bind(this, props, this.dimensionUpdaters[key]));
      }
    }
    return updaters.length ? updaters : null;
  }
  getUpdateTriggers(props) {
    const _updateTriggers = props.updateTriggers || {};
    const updateTriggers = {};
    for (const key in this.dimensionUpdaters) {
      const { accessor } = this.dimensionUpdaters[key];
      updateTriggers[accessor] = {};
      dimensionSteps.forEach((step) => {
        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(({ prop, updateTrigger }) => {
          if (updateTrigger) {
            const fromProp = _updateTriggers[updateTrigger];
            if (typeof fromProp === "object" && !Array.isArray(fromProp)) {
              Object.assign(updateTriggers[accessor], fromProp);
            } else if (fromProp !== void 0) {
              updateTriggers[accessor][prop] = fromProp;
            }
          } else {
            updateTriggers[accessor][prop] = props[prop];
          }
        });
      });
    }
    return updateTriggers;
  }
  getSortedBins(props) {
    for (const key in this.dimensionUpdaters) {
      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);
    }
  }
  getDimensionSortedBins(props, dimensionUpdater) {
    const { key } = dimensionUpdater;
    const { getValue } = this.state.dimensions[key];
    const sortedBins = new BinSorter(this.state.layerData.data || [], {
      getValue,
      filterData: props._filterData
    });
    this.setDimensionState(key, { sortedBins });
    this.getDimensionValueDomain(props, dimensionUpdater);
  }
  getDimensionValueDomain(props, dimensionUpdater) {
    const { getDomain, key } = dimensionUpdater;
    const { triggers: { lowerPercentile, upperPercentile, scaleType } } = getDomain;
    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);
    this.setDimensionState(key, { valueDomain });
    this.getDimensionScale(props, dimensionUpdater);
  }
  getDimensionScale(props, dimensionUpdater) {
    const { key, getScaleFunc, getDomain } = dimensionUpdater;
    const { domain, range } = getScaleFunc.triggers;
    const { scaleType } = getDomain.triggers;
    const { onSet } = getScaleFunc;
    const dimensionRange = props[range.prop];
    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;
    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);
    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);
    if (typeof onSet === "object" && typeof props[onSet.props] === "function") {
      props[onSet.props](scaleFunc.domain());
    }
    this.setDimensionState(key, { scaleFunc });
  }
  getSubLayerDimensionAttribute(key, nullValue) {
    return (cell) => {
      const { sortedBins, scaleFunc } = this.state.dimensions[key];
      const bin = sortedBins.binMap[cell.index];
      if (bin && bin.counts === 0) {
        return nullValue;
      }
      const cv = bin && bin.value;
      const domain = scaleFunc.domain();
      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];
      return isValueInDomain ? scaleFunc(cv) : nullValue;
    };
  }
  getSubLayerAccessors(props) {
    const accessors = {};
    for (const key in this.dimensionUpdaters) {
      const { accessor } = this.dimensionUpdaters[key];
      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);
    }
    return accessors;
  }
  getPickingInfo({ info }) {
    const isPicked = info.picked && info.index > -1;
    let object = null;
    if (isPicked) {
      const cell = this.state.layerData.data[info.index];
      const binInfo = {};
      for (const key in this.dimensionUpdaters) {
        const { pickingInfo } = this.dimensionUpdaters[key];
        const { sortedBins } = this.state.dimensions[key];
        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;
        binInfo[pickingInfo] = value;
      }
      object = Object.assign(binInfo, cell, {
        points: cell.filteredPoints || cell.points
      });
    }
    info.picked = Boolean(object);
    info.object = object;
    return info;
  }
  getAccessor(dimensionKey) {
    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {
      return noop;
    }
    return this.dimensionUpdaters[dimensionKey].attributeAccessor;
  }
};

// dist/cpu-grid-layer/cpu-grid-layer.js
function nop() {
}
var defaultProps4 = {
  colorDomain: null,
  colorRange: defaultColorRange,
  getColorValue: { type: "accessor", value: null },
  getColorWeight: { type: "accessor", value: 1 },
  colorAggregation: "SUM",
  lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  colorScaleType: "quantize",
  onSetColorDomain: nop,
  elevationDomain: null,
  elevationRange: [0, 1e3],
  getElevationValue: { type: "accessor", value: null },
  getElevationWeight: { type: "accessor", value: 1 },
  elevationAggregation: "SUM",
  elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
  elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
  elevationScale: { type: "number", min: 0, value: 1 },
  elevationScaleType: "linear",
  onSetElevationDomain: nop,
  gridAggregator: pointToDensityGridDataCPU,
  cellSize: { type: "number", min: 0, max: 1e3, value: 1e3 },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  getPosition: { type: "accessor", value: (x) => x.position },
  extruded: false,
  material: true,
  _filterData: { type: "function", value: null, optional: true }
};
var _CPUGridLayer = class extends AggregationLayer {
  initializeState() {
    const cpuAggregator = new CPUAggregator({
      getAggregator: (props) => props.gridAggregator,
      getCellSize: (props) => props.cellSize
    });
    this.state = {
      cpuAggregator,
      aggregatorState: cpuAggregator.state
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: { size: 3, type: "float64", accessor: "getPosition" }
    });
  }
  updateState(opts) {
    super.updateState(opts);
    this.setState({
      aggregatorState: this.state.cpuAggregator.updateState(opts, {
        viewport: this.context.viewport,
        attributes: this.getAttributes(),
        numInstances: this.getNumInstances()
      })
    });
  }
  getPickingInfo({ info }) {
    return this.state.cpuAggregator.getPickingInfo({ info });
  }
  _onGetSublayerColor(cell) {
    return this.state.cpuAggregator.getAccessor("fillColor")(cell);
  }
  _onGetSublayerElevation(cell) {
    return this.state.cpuAggregator.getAccessor("elevation")(cell);
  }
  _getSublayerUpdateTriggers() {
    return this.state.cpuAggregator.getUpdateTriggers(this.props);
  }
  renderLayers() {
    const { elevationScale, extruded, cellSize, coverage, material, transitions } = this.props;
    const { cpuAggregator } = this.state;
    const SubLayerClass = this.getSubLayerClass("grid-cell", import_layers.GridCellLayer);
    const updateTriggers = this._getSublayerUpdateTriggers();
    return new SubLayerClass({
      cellSize,
      coverage,
      material,
      elevationScale,
      extruded,
      getFillColor: this._onGetSublayerColor.bind(this),
      getElevation: this._onGetSublayerElevation.bind(this),
      transitions: transitions && {
        getFillColor: transitions.getColorValue || transitions.getColorWeight,
        getElevation: transitions.getElevationValue || transitions.getElevationWeight
      }
    }, this.getSubLayerProps({
      id: "grid-cell",
      updateTriggers
    }), {
      data: cpuAggregator.state.layerData.data
    });
  }
};
var CPUGridLayer = _CPUGridLayer;
(() => {
  _CPUGridLayer.layerName = "CPUGridLayer";
})();
(() => {
  _CPUGridLayer.defaultProps = defaultProps4;
})();

// dist/hexagon-layer/hexagon-layer.js
var import_core10 = require("@deck.gl/core");
var import_layers2 = require("@deck.gl/layers");

// dist/hexagon-layer/hexagon-aggregator.js
var import_d3_hexbin = require("d3-hexbin");
var import_core9 = require("@deck.gl/core");
function pointToHexbin(props, aggregationParams) {
  const { data, radius } = props;
  const { viewport, attributes } = aggregationParams;
  const centerLngLat = data.length ? getPointsCenter(data, aggregationParams) : null;
  const radiusCommon = getRadiusInCommon(radius, viewport, centerLngLat);
  const screenPoints = [];
  const { iterable, objectInfo } = (0, import_core9.createIterable)(data);
  const positions = attributes.positions.value;
  const { size } = attributes.positions.getAccessor();
  for (const object of iterable) {
    objectInfo.index++;
    const posIndex = objectInfo.index * size;
    const position = [positions[posIndex], positions[posIndex + 1]];
    const arrayIsFinite = Number.isFinite(position[0]) && Number.isFinite(position[1]);
    if (arrayIsFinite) {
      screenPoints.push({
        screenCoord: viewport.projectFlat(position),
        source: object,
        index: objectInfo.index
      });
    } else {
      import_core9.log.warn("HexagonLayer: invalid position")();
    }
  }
  const newHexbin = (0, import_d3_hexbin.hexbin)().radius(radiusCommon).x((d) => d.screenCoord[0]).y((d) => d.screenCoord[1]);
  const hexagonBins = newHexbin(screenPoints);
  return {
    hexagons: hexagonBins.map((hex, index) => ({
      position: viewport.unprojectFlat([hex.x, hex.y]),
      points: hex,
      index
    })),
    radiusCommon
  };
}
function getPointsCenter(data, aggregationParams) {
  const { attributes } = aggregationParams;
  const positions = attributes.positions.value;
  const { size } = attributes.positions.getAccessor();
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let i;
  for (i = 0; i < size * data.length; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    const arrayIsFinite = Number.isFinite(x) && Number.isFinite(y);
    if (arrayIsFinite) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }
  return [minX, minY, maxX, maxY].every(Number.isFinite) ? [(minX + maxX) / 2, (minY + maxY) / 2] : null;
}
function getRadiusInCommon(radius, viewport, center) {
  const { unitsPerMeter } = viewport.getDistanceScales(center);
  return radius * unitsPerMeter[0];
}

// dist/hexagon-layer/hexagon-layer.js
function nop2() {
}
var defaultProps5 = {
  colorDomain: null,
  colorRange: defaultColorRange,
  getColorValue: { type: "accessor", value: null },
  getColorWeight: { type: "accessor", value: 1 },
  colorAggregation: "SUM",
  lowerPercentile: { type: "number", value: 0, min: 0, max: 100 },
  upperPercentile: { type: "number", value: 100, min: 0, max: 100 },
  colorScaleType: "quantize",
  onSetColorDomain: nop2,
  elevationDomain: null,
  elevationRange: [0, 1e3],
  getElevationValue: { type: "accessor", value: null },
  getElevationWeight: { type: "accessor", value: 1 },
  elevationAggregation: "SUM",
  elevationLowerPercentile: { type: "number", value: 0, min: 0, max: 100 },
  elevationUpperPercentile: { type: "number", value: 100, min: 0, max: 100 },
  elevationScale: { type: "number", min: 0, value: 1 },
  elevationScaleType: "linear",
  onSetElevationDomain: nop2,
  radius: { type: "number", value: 1e3, min: 1 },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  extruded: false,
  hexagonAggregator: pointToHexbin,
  getPosition: { type: "accessor", value: (x) => x.position },
  material: true,
  _filterData: { type: "function", value: null, optional: true }
};
var _HexagonLayer = class extends AggregationLayer {
  initializeState() {
    const cpuAggregator = new CPUAggregator({
      getAggregator: (props) => props.hexagonAggregator,
      getCellSize: (props) => props.radius
    });
    this.state = {
      cpuAggregator,
      aggregatorState: cpuAggregator.state,
      vertices: null
    };
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: { size: 3, type: "float64", accessor: "getPosition" }
    });
  }
  updateState(opts) {
    super.updateState(opts);
    if (opts.changeFlags.propsOrDataChanged) {
      const aggregatorState = this.state.cpuAggregator.updateState(opts, {
        viewport: this.context.viewport,
        attributes: this.getAttributes()
      });
      if (this.state.aggregatorState.layerData !== aggregatorState.layerData) {
        const { hexagonVertices } = aggregatorState.layerData || {};
        this.setState({
          vertices: hexagonVertices && this.convertLatLngToMeterOffset(hexagonVertices)
        });
      }
      this.setState({
        aggregatorState
      });
    }
  }
  convertLatLngToMeterOffset(hexagonVertices) {
    const { viewport } = this.context;
    if (Array.isArray(hexagonVertices) && hexagonVertices.length === 6) {
      const vertex0 = hexagonVertices[0];
      const vertex3 = hexagonVertices[3];
      const centroid = [(vertex0[0] + vertex3[0]) / 2, (vertex0[1] + vertex3[1]) / 2];
      const centroidFlat = viewport.projectFlat(centroid);
      const { metersPerUnit } = viewport.getDistanceScales(centroid);
      const vertices = hexagonVertices.map((vt) => {
        const vtFlat = viewport.projectFlat(vt);
        return [
          (vtFlat[0] - centroidFlat[0]) * metersPerUnit[0],
          (vtFlat[1] - centroidFlat[1]) * metersPerUnit[1]
        ];
      });
      return vertices;
    }
    import_core10.log.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")();
    return null;
  }
  getPickingInfo({ info }) {
    return this.state.cpuAggregator.getPickingInfo({ info });
  }
  _onGetSublayerColor(cell) {
    return this.state.cpuAggregator.getAccessor("fillColor")(cell);
  }
  _onGetSublayerElevation(cell) {
    return this.state.cpuAggregator.getAccessor("elevation")(cell);
  }
  _getSublayerUpdateTriggers() {
    return this.state.cpuAggregator.getUpdateTriggers(this.props);
  }
  renderLayers() {
    const { elevationScale, extruded, coverage, material, transitions } = this.props;
    const { aggregatorState, vertices } = this.state;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell", import_layers2.ColumnLayer);
    const updateTriggers = this._getSublayerUpdateTriggers();
    const geometry = vertices ? { vertices, radius: 1 } : {
      radius: aggregatorState.layerData.radiusCommon || 1,
      radiusUnits: "common",
      angle: 90
    };
    return new SubLayerClass({
      ...geometry,
      diskResolution: 6,
      elevationScale,
      extruded,
      coverage,
      material,
      getFillColor: this._onGetSublayerColor.bind(this),
      getElevation: this._onGetSublayerElevation.bind(this),
      transitions: transitions && {
        getFillColor: transitions.getColorValue || transitions.getColorWeight,
        getElevation: transitions.getElevationValue || transitions.getElevationWeight
      }
    }, this.getSubLayerProps({
      id: "hexagon-cell",
      updateTriggers
    }), {
      data: aggregatorState.layerData.data
    });
  }
};
var HexagonLayer = _HexagonLayer;
(() => {
  _HexagonLayer.layerName = "HexagonLayer";
})();
(() => {
  _HexagonLayer.defaultProps = defaultProps5;
})();

// dist/contour-layer/contour-layer.js
var import_layers3 = require("@deck.gl/layers");

// dist/contour-layer/marching-squares.js
var import_core11 = require("@deck.gl/core");

// dist/contour-layer/marching-squares-codes.js
var HALF = 0.5;
var ONE6TH = 1 / 6;
var OFFSET = {
  N: [0, HALF],
  E: [HALF, 0],
  S: [0, -HALF],
  W: [-HALF, 0],
  NE: [HALF, HALF],
  NW: [-HALF, HALF],
  SE: [HALF, -HALF],
  SW: [-HALF, -HALF]
};
var SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
var SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
var NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
var NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];
var SW_TRAPEZOID = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF]
];
var SE_TRAPEZOID = [
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [HALF, -ONE6TH],
  [HALF, ONE6TH]
];
var NE_TRAPEZOID = [
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var NW_TRAPEZOID = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
var E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
var N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
var W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
var EW_RECTANGEL = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [HALF, -ONE6TH],
  [HALF, ONE6TH]
];
var SN_RECTANGEL = [
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];
var SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
var SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
var NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
var NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];
var NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
var NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
var SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
var SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];
var NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
var NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
var SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
var SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];
var S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
var E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
var N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
var W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
var SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
var NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];
var NE_HEPTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  OFFSET.E,
  OFFSET.NE,
  OFFSET.N
];
var SW_HEPTAGON = [
  OFFSET.W,
  OFFSET.SW,
  OFFSET.S,
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var NW_HEPTAGON = [
  OFFSET.NW,
  OFFSET.W,
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  OFFSET.N
];
var SE_HEPTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  OFFSET.S,
  OFFSET.SE,
  OFFSET.E,
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var OCTAGON = [
  [-HALF, ONE6TH],
  [-HALF, -ONE6TH],
  [-ONE6TH, -HALF],
  [ONE6TH, -HALF],
  [HALF, -ONE6TH],
  [HALF, ONE6TH],
  [ONE6TH, HALF],
  [-ONE6TH, HALF]
];
var ISOLINES_CODE_OFFSET_MAP = {
  0: [],
  1: [[OFFSET.W, OFFSET.S]],
  2: [[OFFSET.S, OFFSET.E]],
  3: [[OFFSET.W, OFFSET.E]],
  4: [[OFFSET.N, OFFSET.E]],
  5: {
    0: [
      [OFFSET.W, OFFSET.S],
      [OFFSET.N, OFFSET.E]
    ],
    1: [
      [OFFSET.W, OFFSET.N],
      [OFFSET.S, OFFSET.E]
    ]
  },
  6: [[OFFSET.N, OFFSET.S]],
  7: [[OFFSET.W, OFFSET.N]],
  8: [[OFFSET.W, OFFSET.N]],
  9: [[OFFSET.N, OFFSET.S]],
  10: {
    0: [
      [OFFSET.W, OFFSET.N],
      [OFFSET.S, OFFSET.E]
    ],
    1: [
      [OFFSET.W, OFFSET.S],
      [OFFSET.N, OFFSET.E]
    ]
  },
  11: [[OFFSET.N, OFFSET.E]],
  12: [[OFFSET.W, OFFSET.E]],
  13: [[OFFSET.S, OFFSET.E]],
  14: [[OFFSET.W, OFFSET.S]],
  15: []
};
function ternaryToIndex(ternary) {
  return parseInt(ternary, 4);
}
var ISOBANDS_CODE_OFFSET_MAP = {
  [ternaryToIndex("0000")]: [],
  [ternaryToIndex("2222")]: [],
  [ternaryToIndex("2221")]: [SW_TRIANGLE],
  [ternaryToIndex("2212")]: [SE_TRIANGLE],
  [ternaryToIndex("2122")]: [NE_TRIANGLE],
  [ternaryToIndex("1222")]: [NW_TRIANGLE],
  [ternaryToIndex("0001")]: [SW_TRIANGLE],
  [ternaryToIndex("0010")]: [SE_TRIANGLE],
  [ternaryToIndex("0100")]: [NE_TRIANGLE],
  [ternaryToIndex("1000")]: [NW_TRIANGLE],
  [ternaryToIndex("2220")]: [SW_TRAPEZOID],
  [ternaryToIndex("2202")]: [SE_TRAPEZOID],
  [ternaryToIndex("2022")]: [NE_TRAPEZOID],
  [ternaryToIndex("0222")]: [NW_TRAPEZOID],
  [ternaryToIndex("0002")]: [SW_TRAPEZOID],
  [ternaryToIndex("0020")]: [SE_TRAPEZOID],
  [ternaryToIndex("0200")]: [NE_TRAPEZOID],
  [ternaryToIndex("2000")]: [NW_TRAPEZOID],
  [ternaryToIndex("0011")]: [S_RECTANGLE],
  [ternaryToIndex("0110")]: [E_RECTANGLE],
  [ternaryToIndex("1100")]: [N_RECTANGLE],
  [ternaryToIndex("1001")]: [W_RECTANGLE],
  [ternaryToIndex("2211")]: [S_RECTANGLE],
  [ternaryToIndex("2112")]: [E_RECTANGLE],
  [ternaryToIndex("1122")]: [N_RECTANGLE],
  [ternaryToIndex("1221")]: [W_RECTANGLE],
  [ternaryToIndex("2200")]: [EW_RECTANGEL],
  [ternaryToIndex("2002")]: [SN_RECTANGEL],
  [ternaryToIndex("0022")]: [EW_RECTANGEL],
  [ternaryToIndex("0220")]: [SN_RECTANGEL],
  [ternaryToIndex("1111")]: [SQUARE],
  [ternaryToIndex("1211")]: [SW_PENTAGON],
  [ternaryToIndex("2111")]: [SE_PENTAGON],
  [ternaryToIndex("1112")]: [NE_PENTAGON],
  [ternaryToIndex("1121")]: [NW_PENTAGON],
  [ternaryToIndex("1011")]: [SW_PENTAGON],
  [ternaryToIndex("0111")]: [SE_PENTAGON],
  [ternaryToIndex("1110")]: [NE_PENTAGON],
  [ternaryToIndex("1101")]: [NW_PENTAGON],
  [ternaryToIndex("1200")]: [NW_N_PENTAGON],
  [ternaryToIndex("0120")]: [NE_E_PENTAGON],
  [ternaryToIndex("0012")]: [SE_S_PENTAGON],
  [ternaryToIndex("2001")]: [SW_W_PENTAGON],
  [ternaryToIndex("1022")]: [NW_N_PENTAGON],
  [ternaryToIndex("2102")]: [NE_E_PENTAGON],
  [ternaryToIndex("2210")]: [SE_S_PENTAGON],
  [ternaryToIndex("0221")]: [SW_W_PENTAGON],
  [ternaryToIndex("1002")]: [NW_W_PENTAGON],
  [ternaryToIndex("2100")]: [NE_N_PENTAGON],
  [ternaryToIndex("0210")]: [SE_E_PENTAGON],
  [ternaryToIndex("0021")]: [SW_S_PENTAGON],
  [ternaryToIndex("1220")]: [NW_W_PENTAGON],
  [ternaryToIndex("0122")]: [NE_N_PENTAGON],
  [ternaryToIndex("2012")]: [SE_E_PENTAGON],
  [ternaryToIndex("2201")]: [SW_S_PENTAGON],
  [ternaryToIndex("0211")]: [S_HEXAGON],
  [ternaryToIndex("2110")]: [E_HEXAGON],
  [ternaryToIndex("1102")]: [N_HEXAGON],
  [ternaryToIndex("1021")]: [W_HEXAGON],
  [ternaryToIndex("2011")]: [S_HEXAGON],
  [ternaryToIndex("0112")]: [E_HEXAGON],
  [ternaryToIndex("1120")]: [N_HEXAGON],
  [ternaryToIndex("1201")]: [W_HEXAGON],
  [ternaryToIndex("2101")]: [SW_NE_HEXAGON],
  [ternaryToIndex("0121")]: [SW_NE_HEXAGON],
  [ternaryToIndex("1012")]: [NW_SE_HEXAGON],
  [ternaryToIndex("1210")]: [NW_SE_HEXAGON],
  [ternaryToIndex("0101")]: {
    0: [SW_TRIANGLE, NE_TRIANGLE],
    1: [SW_NE_HEXAGON],
    2: [SW_NE_HEXAGON]
  },
  [ternaryToIndex("1010")]: {
    0: [NW_TRIANGLE, SE_TRIANGLE],
    1: [NW_SE_HEXAGON],
    2: [NW_SE_HEXAGON]
  },
  [ternaryToIndex("2121")]: {
    0: [SW_NE_HEXAGON],
    1: [SW_NE_HEXAGON],
    2: [SW_TRIANGLE, NE_TRIANGLE]
  },
  [ternaryToIndex("1212")]: {
    0: [NW_SE_HEXAGON],
    1: [NW_SE_HEXAGON],
    2: [NW_TRIANGLE, SE_TRIANGLE]
  },
  [ternaryToIndex("2120")]: {
    0: [NE_HEPTAGON],
    1: [NE_HEPTAGON],
    2: [SW_TRAPEZOID, NE_TRIANGLE]
  },
  [ternaryToIndex("2021")]: {
    0: [SW_HEPTAGON],
    1: [SW_HEPTAGON],
    2: [SW_TRIANGLE, NE_TRAPEZOID]
  },
  [ternaryToIndex("1202")]: {
    0: [NW_HEPTAGON],
    1: [NW_HEPTAGON],
    2: [NW_TRIANGLE, SE_TRAPEZOID]
  },
  [ternaryToIndex("0212")]: {
    0: [SE_HEPTAGON],
    1: [SE_HEPTAGON],
    2: [SE_TRIANGLE, NW_TRAPEZOID]
  },
  [ternaryToIndex("0102")]: {
    0: [SW_TRAPEZOID, NE_TRIANGLE],
    1: [NE_HEPTAGON],
    2: [NE_HEPTAGON]
  },
  [ternaryToIndex("0201")]: {
    0: [SW_TRIANGLE, NE_TRAPEZOID],
    1: [SW_HEPTAGON],
    2: [SW_HEPTAGON]
  },
  [ternaryToIndex("1020")]: {
    0: [NW_TRIANGLE, SE_TRAPEZOID],
    1: [NW_HEPTAGON],
    2: [NW_HEPTAGON]
  },
  [ternaryToIndex("2010")]: {
    0: [SE_TRIANGLE, NW_TRAPEZOID],
    1: [SE_HEPTAGON],
    2: [SE_HEPTAGON]
  },
  [ternaryToIndex("2020")]: {
    0: [NW_TRAPEZOID, SE_TRAPEZOID],
    1: [OCTAGON],
    2: [SW_TRAPEZOID, NE_TRAPEZOID]
  },
  [ternaryToIndex("0202")]: {
    0: [NE_TRAPEZOID, SW_TRAPEZOID],
    1: [OCTAGON],
    2: [NW_TRAPEZOID, SE_TRAPEZOID]
  }
};

// dist/contour-layer/marching-squares.js
var CONTOUR_TYPE = {
  ISO_LINES: 1,
  ISO_BANDS: 2
};
var DEFAULT_THRESHOLD_DATA = {
  zIndex: 0,
  zOffset: 5e-3
};
function getVertexCode(weight, threshold2) {
  if (Array.isArray(threshold2)) {
    if (weight < threshold2[0]) {
      return 0;
    }
    return weight < threshold2[1] ? 1 : 2;
  }
  return weight >= threshold2 ? 1 : 0;
}
function getCode(opts) {
  const { cellWeights, x, y, width, height } = opts;
  let threshold2 = opts.threshold;
  if (opts.thresholdValue) {
    import_core11.log.deprecated("thresholdValue", "threshold")();
    threshold2 = opts.thresholdValue;
  }
  const isLeftBoundary = x < 0;
  const isRightBoundary = x >= width - 1;
  const isBottomBoundary = y < 0;
  const isTopBoundary = y >= height - 1;
  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
  const weights = {};
  const codes = {};
  if (isLeftBoundary || isTopBoundary) {
    codes.top = 0;
  } else {
    weights.top = cellWeights[(y + 1) * width + x];
    codes.top = getVertexCode(weights.top, threshold2);
  }
  if (isRightBoundary || isTopBoundary) {
    codes.topRight = 0;
  } else {
    weights.topRight = cellWeights[(y + 1) * width + x + 1];
    codes.topRight = getVertexCode(weights.topRight, threshold2);
  }
  if (isRightBoundary || isBottomBoundary) {
    codes.right = 0;
  } else {
    weights.right = cellWeights[y * width + x + 1];
    codes.right = getVertexCode(weights.right, threshold2);
  }
  if (isLeftBoundary || isBottomBoundary) {
    codes.current = 0;
  } else {
    weights.current = cellWeights[y * width + x];
    codes.current = getVertexCode(weights.current, threshold2);
  }
  const { top, topRight, right, current } = codes;
  let code = -1;
  if (Number.isFinite(threshold2)) {
    code = top << 3 | topRight << 2 | right << 1 | current;
  }
  if (Array.isArray(threshold2)) {
    code = top << 6 | topRight << 4 | right << 2 | current;
  }
  let meanCode = 0;
  if (!isBoundary) {
    meanCode = getVertexCode((weights.top + weights.topRight + weights.right + weights.current) / 4, threshold2);
  }
  return { code, meanCode };
}
function getVertices(opts) {
  const { gridOrigin, cellSize, x, y, code, meanCode, type = CONTOUR_TYPE.ISO_LINES } = opts;
  const thresholdData = { ...DEFAULT_THRESHOLD_DATA, ...opts.thresholdData };
  let offsets = type === CONTOUR_TYPE.ISO_BANDS ? ISOBANDS_CODE_OFFSET_MAP[code] : ISOLINES_CODE_OFFSET_MAP[code];
  if (!Array.isArray(offsets)) {
    offsets = offsets[meanCode];
  }
  const vZ = thresholdData.zIndex * thresholdData.zOffset;
  const rX = (x + 1) * cellSize[0];
  const rY = (y + 1) * cellSize[1];
  const refVertexX = gridOrigin[0] + rX;
  const refVertexY = gridOrigin[1] + rY;
  if (type === CONTOUR_TYPE.ISO_BANDS) {
    const polygons = [];
    offsets.forEach((polygonOffsets) => {
      const polygon = [];
      polygonOffsets.forEach((xyOffset) => {
        const vX = refVertexX + xyOffset[0] * cellSize[0];
        const vY = refVertexY + xyOffset[1] * cellSize[1];
        polygon.push([vX, vY, vZ]);
      });
      polygons.push(polygon);
    });
    return polygons;
  }
  const lines = [];
  offsets.forEach((xyOffsets) => {
    xyOffsets.forEach((offset) => {
      const vX = refVertexX + offset[0] * cellSize[0];
      const vY = refVertexY + offset[1] * cellSize[1];
      lines.push([vX, vY, vZ]);
    });
  });
  return lines;
}

// dist/contour-layer/contour-utils.js
function generateContours({ thresholdData, cellWeights, gridSize, gridOrigin, cellSize }) {
  const contourSegments = [];
  const contourPolygons = [];
  const width = gridSize[0];
  const height = gridSize[1];
  let segmentIndex = 0;
  let polygonIndex = 0;
  for (const data of thresholdData) {
    const { contour } = data;
    const { threshold: threshold2 } = contour;
    for (let x = -1; x < width; x++) {
      for (let y = -1; y < height; y++) {
        const { code, meanCode } = getCode({
          cellWeights,
          threshold: threshold2,
          x,
          y,
          width,
          height
        });
        const opts = {
          type: CONTOUR_TYPE.ISO_BANDS,
          gridOrigin,
          cellSize,
          x,
          y,
          width,
          height,
          code,
          meanCode,
          thresholdData: data
        };
        if (Array.isArray(threshold2)) {
          opts.type = CONTOUR_TYPE.ISO_BANDS;
          const polygons = getVertices(opts);
          for (const polygon of polygons) {
            contourPolygons[polygonIndex++] = {
              vertices: polygon,
              contour
            };
          }
        } else {
          opts.type = CONTOUR_TYPE.ISO_LINES;
          const vertices = getVertices(opts);
          for (let i = 0; i < vertices.length; i += 2) {
            contourSegments[segmentIndex++] = {
              start: vertices[i],
              end: vertices[i + 1],
              contour
            };
          }
        }
      }
    }
  }
  return { contourSegments, contourPolygons };
}

// dist/contour-layer/contour-layer.js
var import_core12 = require("@deck.gl/core");
var DEFAULT_COLOR = [255, 255, 255, 255];
var DEFAULT_STROKE_WIDTH = 1;
var DEFAULT_THRESHOLD = 1;
var defaultProps6 = {
  cellSize: { type: "number", min: 1, max: 1e3, value: 1e3 },
  getPosition: { type: "accessor", value: (x) => x.position },
  getWeight: { type: "accessor", value: 1 },
  gpuAggregation: false,
  aggregation: "SUM",
  contours: {
    type: "object",
    value: [{ threshold: DEFAULT_THRESHOLD }],
    optional: true,
    compare: 3
  },
  zOffset: 5e-3
};
var POSITION_ATTRIBUTE_NAME2 = "positions";
var DIMENSIONS2 = {
  data: {
    props: ["cellSize"]
  },
  weights: {
    props: ["aggregation"],
    accessors: ["getWeight"]
  }
};
var _ContourLayer = class extends GridAggregationLayer {
  initializeState() {
    super.initializeAggregationLayer({
      dimensions: DIMENSIONS2
    });
    this.setState({
      contourData: {},
      projectPoints: false,
      weights: {
        count: {
          size: 1,
          operation: AGGREGATION_OPERATION.SUM
        }
      }
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME2]: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      count: { size: 3, accessor: "getWeight" }
    });
  }
  updateState(opts) {
    super.updateState(opts);
    let contoursChanged = false;
    const { oldProps, props } = opts;
    const { aggregationDirty } = this.state;
    if (oldProps.contours !== props.contours || oldProps.zOffset !== props.zOffset) {
      contoursChanged = true;
      this._updateThresholdData(opts.props);
    }
    if (this.getNumInstances() > 0 && (aggregationDirty || contoursChanged)) {
      this._generateContours();
    }
  }
  renderLayers() {
    const { contourSegments, contourPolygons } = this.state.contourData;
    const LinesSubLayerClass = this.getSubLayerClass("lines", import_layers3.LineLayer);
    const BandsSubLayerClass = this.getSubLayerClass("bands", import_layers3.SolidPolygonLayer);
    const lineLayer = contourSegments && contourSegments.length > 0 && new LinesSubLayerClass(this.getSubLayerProps({
      id: "lines"
    }), {
      data: this.state.contourData.contourSegments,
      getSourcePosition: (d) => d.start,
      getTargetPosition: (d) => d.end,
      getColor: (d) => d.contour.color || DEFAULT_COLOR,
      getWidth: (d) => d.contour.strokeWidth || DEFAULT_STROKE_WIDTH
    });
    const bandsLayer = contourPolygons && contourPolygons.length > 0 && new BandsSubLayerClass(this.getSubLayerProps({
      id: "bands"
    }), {
      data: this.state.contourData.contourPolygons,
      getPolygon: (d) => d.vertices,
      getFillColor: (d) => d.contour.color || DEFAULT_COLOR
    });
    return [lineLayer, bandsLayer];
  }
  updateAggregationState(opts) {
    const { props, oldProps } = opts;
    const { cellSize, coordinateSystem } = props;
    const { viewport } = this.context;
    const cellSizeChanged = oldProps.cellSize !== cellSize;
    let gpuAggregation = props.gpuAggregation;
    if (this.state.gpuAggregation !== props.gpuAggregation) {
      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.device)) {
        import_core12.log.warn("GPU Grid Aggregation not supported, falling back to CPU")();
        gpuAggregation = false;
      }
    }
    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;
    this.setState({
      gpuAggregation
    });
    const { dimensions } = this.state;
    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME2);
    const { data, weights } = dimensions;
    let { boundingBox } = this.state;
    if (positionsChanged) {
      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());
      this.setState({ boundingBox });
    }
    if (positionsChanged || cellSizeChanged) {
      const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);
      this.allocateResources(numRow, numCol);
      this.setState({
        gridOffset,
        boundingBox,
        translation,
        posOffset: translation.slice(),
        gridOrigin: [-1 * translation[0], -1 * translation[1]],
        width,
        height,
        numCol,
        numRow
      });
    }
    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || this.isAggregationDirty(opts, {
      dimension: data,
      compareAll: gpuAggregation
    });
    const aggregationWeightsDirty = this.isAggregationDirty(opts, {
      dimension: weights
    });
    if (aggregationWeightsDirty) {
      this._updateAccessors(opts);
    }
    if (aggregationDataDirty || aggregationWeightsDirty) {
      this._resetResults();
    }
    this.setState({
      aggregationDataDirty,
      aggregationWeightsDirty
    });
  }
  _updateAccessors(opts) {
    const { getWeight, aggregation, data } = opts.props;
    const { count } = this.state.weights;
    if (count) {
      count.getWeight = getWeight;
      count.operation = AGGREGATION_OPERATION[aggregation];
    }
    this.setState({ getValue: getValueFunc(aggregation, getWeight, { data }) });
  }
  _resetResults() {
    const { count } = this.state.weights;
    if (count) {
      count.aggregationData = null;
    }
  }
  _generateContours() {
    const { numCol, numRow, gridOrigin, gridOffset, thresholdData } = this.state;
    const { count } = this.state.weights;
    let { aggregationData } = count;
    if (!aggregationData) {
      aggregationData = count.aggregationBuffer.readSyncWebGL();
      count.aggregationData = aggregationData;
    }
    const { cellWeights } = GPUGridAggregator.getCellData({ countsData: aggregationData });
    const contourData = generateContours({
      thresholdData,
      cellWeights,
      gridSize: [numCol, numRow],
      gridOrigin,
      cellSize: [gridOffset.xOffset, gridOffset.yOffset]
    });
    this.setState({ contourData });
  }
  _updateThresholdData(props) {
    const { contours, zOffset } = props;
    const count = contours.length;
    const thresholdData = new Array(count);
    for (let i = 0; i < count; i++) {
      const contour = contours[i];
      thresholdData[i] = {
        contour,
        zIndex: contour.zIndex || i,
        zOffset
      };
    }
    this.setState({ thresholdData });
  }
};
var ContourLayer = _ContourLayer;
(() => {
  _ContourLayer.layerName = "ContourLayer";
})();
(() => {
  _ContourLayer.defaultProps = defaultProps6;
})();

// dist/grid-layer/grid-layer.js
var import_core15 = require("@deck.gl/core");

// dist/gpu-grid-layer/gpu-grid-layer.js
var import_constants5 = require("@luma.gl/constants");
var import_core14 = require("@deck.gl/core");

// dist/gpu-grid-layer/gpu-grid-cell-layer.js
var import_core13 = require("@deck.gl/core");
var import_engine3 = require("@luma.gl/engine");
var import_shadertools2 = require("@luma.gl/shadertools");
var import_engine4 = require("@luma.gl/engine");
var import_constants4 = require("@luma.gl/constants");

// dist/gpu-grid-layer/gpu-grid-cell-layer-vertex.glsl.js
var gpu_grid_cell_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 normals;
in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;
uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;
layout(std140) uniform;
uniform ColorData
{
vec4 maxMinCount;
} colorData;
uniform ElevationData
{
vec4 maxMinCount;
} elevationData;
#define EPSILON 0.00001
out vec4 vColor;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
return outColor;
}
float linearScale(vec2 domain, vec2 range, float value) {
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
}
return -1.;
}
void main(void) {
vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
vec4 color = quantizeScale(clrDomain, colorRange, colors.r);
float elevation = 0.0;
if (extruded) {
vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
elevation = linearScale(elvDomain, elevationRange, elevations.r);
elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
}
float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
float dotRadius = cellSize / 2. * coverage * shouldRender;
int yIndex = (gl_InstanceID / gridSize[0]);
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));
vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
geometry.worldPosition = centroidPosition;
vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);
picking_setPickingColor(instancePickingColors);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
vec3 normals_commonspace = project_normal(normals);
if (extruded) {
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);
vColor = vec4(lightColor, color.a * opacity) / 255.;
} else {
vColor = vec4(color.rgb, color.a * opacity) / 255.;
}
}
`;

// dist/gpu-grid-layer/gpu-grid-cell-layer-fragment.glsl.js
var gpu_grid_cell_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
fragColor = picking_filterColor(fragColor);
}
`;

// dist/gpu-grid-layer/gpu-grid-cell-layer.js
var COLOR_DATA_UBO_INDEX = 0;
var ELEVATION_DATA_UBO_INDEX = 1;
var defaultProps7 = {
  colorDomain: null,
  colorRange: defaultColorRange,
  elevationDomain: null,
  elevationRange: [0, 1e3],
  elevationScale: { type: "number", min: 0, value: 1 },
  gridSize: { type: "array", value: [1, 1] },
  gridOrigin: { type: "array", value: [0, 0] },
  gridOffset: { type: "array", value: [0, 0] },
  cellSize: { type: "number", min: 0, max: 1e3, value: 1e3 },
  offset: { type: "array", value: [1, 1] },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  extruded: true,
  material: true
};
var _GPUGridCellLayer = class extends import_core13.Layer {
  getShaders() {
    return super.getShaders({
      vs: gpu_grid_cell_layer_vertex_glsl_default,
      fs: gpu_grid_cell_layer_fragment_glsl_default,
      modules: [import_core13.project32, import_core13.gouraudLighting, import_core13.picking, import_shadertools2.fp64arithmetic]
    });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      colors: {
        size: 4,
        noAlloc: true
      },
      elevations: {
        size: 4,
        noAlloc: true
      }
    });
    const model = this._getModel();
    this._setupUniformBuffer(model);
    this.setState({ model });
  }
  _getModel() {
    return new import_engine4.Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new import_engine3.CubeGeometry(),
      isInstanced: true
    });
  }
  draw({ uniforms }) {
    const { cellSize, offset, extruded, elevationScale, coverage, gridSize, gridOrigin, gridOffset, elevationRange, colorMaxMinBuffer, elevationMaxMinBuffer } = this.props;
    const model = this.state.model;
    const gridOriginLow = [(0, import_core13.fp64LowPart)(gridOrigin[0]), (0, import_core13.fp64LowPart)(gridOrigin[1])];
    const gridOffsetLow = [(0, import_core13.fp64LowPart)(gridOffset[0]), (0, import_core13.fp64LowPart)(gridOffset[1])];
    const domainUniforms = this.getDomainUniforms();
    const colorRange = colorRangeToFlatArray(this.props.colorRange);
    this.bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
    model.setUniforms(uniforms);
    model.setUniforms(domainUniforms);
    model.setUniforms({
      cellSize,
      offset,
      extruded,
      elevationScale,
      coverage,
      gridSize,
      gridOrigin,
      gridOriginLow,
      gridOffset,
      gridOffsetLow,
      colorRange,
      elevationRange
    });
    model.draw(this.context.renderPass);
    this.unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer);
  }
  bindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
    colorMaxMinBuffer.bind({ target: 35345, index: COLOR_DATA_UBO_INDEX });
    elevationMaxMinBuffer.bind({ target: 35345, index: ELEVATION_DATA_UBO_INDEX });
  }
  unbindUniformBuffers(colorMaxMinBuffer, elevationMaxMinBuffer) {
    colorMaxMinBuffer.unbind({ target: 35345, index: COLOR_DATA_UBO_INDEX });
    elevationMaxMinBuffer.unbind({ target: 35345, index: ELEVATION_DATA_UBO_INDEX });
  }
  getDomainUniforms() {
    const { colorDomain, elevationDomain } = this.props;
    const domainUniforms = {};
    if (colorDomain !== null) {
      domainUniforms.colorDomainValid = true;
      domainUniforms.colorDomain = colorDomain;
    } else {
      domainUniforms.colorDomainValid = false;
    }
    if (elevationDomain !== null) {
      domainUniforms.elevationDomainValid = true;
      domainUniforms.elevationDomain = elevationDomain;
    } else {
      domainUniforms.elevationDomainValid = false;
    }
    return domainUniforms;
  }
  _setupUniformBuffer(model) {
    const programHandle = model.pipeline.handle;
    const gl = this.context.gl;
    const colorIndex = gl.getUniformBlockIndex(programHandle, "ColorData");
    const elevationIndex = gl.getUniformBlockIndex(programHandle, "ElevationData");
    gl.uniformBlockBinding(programHandle, colorIndex, COLOR_DATA_UBO_INDEX);
    gl.uniformBlockBinding(programHandle, elevationIndex, ELEVATION_DATA_UBO_INDEX);
  }
};
var GPUGridCellLayer = _GPUGridCellLayer;
(() => {
  _GPUGridCellLayer.layerName = "GPUGridCellLayer";
})();
(() => {
  _GPUGridCellLayer.defaultProps = defaultProps7;
})();

// dist/gpu-grid-layer/gpu-grid-layer.js
var defaultProps8 = {
  colorDomain: null,
  colorRange: defaultColorRange,
  getColorWeight: { type: "accessor", value: 1 },
  colorAggregation: "SUM",
  elevationDomain: null,
  elevationRange: [0, 1e3],
  getElevationWeight: { type: "accessor", value: 1 },
  elevationAggregation: "SUM",
  elevationScale: { type: "number", min: 0, value: 1 },
  cellSize: { type: "number", min: 1, max: 1e3, value: 1e3 },
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  getPosition: { type: "accessor", value: (x) => x.position },
  extruded: false,
  material: true
};
var DIMENSIONS3 = {
  data: {
    props: ["cellSize", "colorAggregation", "elevationAggregation"]
  }
};
var POSITION_ATTRIBUTE_NAME3 = "positions";
var _GPUGridLayer = class extends GridAggregationLayer {
  initializeState({ device }) {
    const isSupported = GPUGridAggregator.isSupported(device);
    if (!isSupported) {
      import_core14.log.error("GPUGridLayer is not supported on this browser, use GridLayer instead")();
    }
    super.initializeAggregationLayer({
      dimensions: DIMENSIONS3
    });
    this.setState({
      gpuAggregation: false,
      projectPoints: false,
      isSupported,
      weights: {
        color: {
          needMin: true,
          needMax: true,
          combineMaxMin: true,
          maxMinBuffer: device.createBuffer({
            byteLength: 4 * 4,
            accessor: { size: 4, type: 5126, divisor: 1 }
          })
        },
        elevation: {
          needMin: true,
          needMax: true,
          combineMaxMin: true,
          maxMinBuffer: device.createBuffer({
            byteLength: 4 * 4,
            accessor: { size: 4, type: 5126, divisor: 1 }
          })
        }
      },
      positionAttributeName: "positions"
    });
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      [POSITION_ATTRIBUTE_NAME3]: {
        size: 3,
        accessor: "getPosition",
        type: "float64",
        fp64: this.use64bitPositions()
      },
      color: { size: 3, accessor: "getColorWeight" },
      elevation: { size: 3, accessor: "getElevationWeight" }
    });
  }
  updateState(opts) {
    if (this.state.isSupported === false) {
      return;
    }
    super.updateState(opts);
    const { aggregationDirty } = this.state;
    if (aggregationDirty) {
      this.setState({
        gridHash: null
      });
    }
  }
  getHashKeyForIndex(index) {
    const { numRow, numCol, boundingBox, gridOffset } = this.state;
    const gridSize = [numCol, numRow];
    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
    const yIndex = Math.floor(index / gridSize[0]);
    const xIndex = index - yIndex * gridSize[0];
    const latIdx = Math.floor((yIndex * cellSize[1] + gridOrigin[1] + 90 + cellSize[1] / 2) / cellSize[1]);
    const lonIdx = Math.floor((xIndex * cellSize[0] + gridOrigin[0] + 180 + cellSize[0] / 2) / cellSize[0]);
    return `${latIdx}-${lonIdx}`;
  }
  getPositionForIndex(index) {
    const { numRow, numCol, boundingBox, gridOffset } = this.state;
    const gridSize = [numCol, numRow];
    const gridOrigin = [boundingBox.xMin, boundingBox.yMin];
    const cellSize = [gridOffset.xOffset, gridOffset.yOffset];
    const yIndex = Math.floor(index / gridSize[0]);
    const xIndex = index - yIndex * gridSize[0];
    const yPos = yIndex * cellSize[1] + gridOrigin[1];
    const xPos = xIndex * cellSize[0] + gridOrigin[0];
    return [xPos, yPos];
  }
  getPickingInfo({ info, mode }) {
    const { index } = info;
    let object = null;
    if (index >= 0) {
      const gpuGridAggregator = this.state.gpuGridAggregator;
      const position = this.getPositionForIndex(index);
      const colorInfo = GPUGridAggregator.getAggregationData({
        pixelIndex: index,
        ...gpuGridAggregator.getData("color")
      });
      const elevationInfo = GPUGridAggregator.getAggregationData({
        pixelIndex: index,
        ...gpuGridAggregator.getData("elevation")
      });
      object = {
        colorValue: colorInfo.cellWeight,
        elevationValue: elevationInfo.cellWeight,
        count: colorInfo.cellCount || elevationInfo.cellCount,
        position,
        totalCount: colorInfo.totalCount || elevationInfo.totalCount
      };
      if (mode !== "hover") {
        const { props } = this;
        let { gridHash } = this.state;
        if (!gridHash) {
          const { gridOffset, translation, boundingBox } = this.state;
          const { viewport } = this.context;
          const attributes = this.getAttributes();
          const cpuAggregation = pointToDensityGridDataCPU(props, {
            gridOffset,
            attributes,
            viewport,
            translation,
            boundingBox
          });
          gridHash = cpuAggregation.gridHash;
          this.setState({ gridHash });
        }
        const key = this.getHashKeyForIndex(index);
        const cpuAggregationData = gridHash[key];
        Object.assign(object, cpuAggregationData);
      }
    }
    info.picked = Boolean(object);
    info.object = object;
    return info;
  }
  renderLayers() {
    if (!this.state.isSupported) {
      return null;
    }
    const { elevationScale, extruded, cellSize: cellSizeMeters, coverage, material, elevationRange, colorDomain, elevationDomain } = this.props;
    const { weights, numRow, numCol, gridOrigin, gridOffset } = this.state;
    const { color, elevation } = weights;
    const colorRange = colorRangeToFlatArray(this.props.colorRange);
    const SubLayerClass = this.getSubLayerClass("gpu-grid-cell", GPUGridCellLayer);
    return new SubLayerClass({
      gridSize: [numCol, numRow],
      gridOrigin,
      gridOffset: [gridOffset.xOffset, gridOffset.yOffset],
      colorRange,
      elevationRange,
      colorDomain,
      elevationDomain,
      cellSize: cellSizeMeters,
      coverage,
      material,
      elevationScale,
      extruded
    }, this.getSubLayerProps({
      id: "gpu-grid-cell"
    }), {
      data: {
        attributes: {
          colors: color.aggregationBuffer,
          elevations: elevation.aggregationBuffer
        }
      },
      colorMaxMinBuffer: color.maxMinBuffer,
      elevationMaxMinBuffer: elevation.maxMinBuffer,
      numInstances: numCol * numRow
    });
  }
  finalizeState(context) {
    const { color, elevation } = this.state.weights;
    [color, elevation].forEach((weight) => {
      const { aggregationBuffer, maxMinBuffer } = weight;
      maxMinBuffer == null ? void 0 : maxMinBuffer.destroy();
      aggregationBuffer == null ? void 0 : aggregationBuffer.destroy();
    });
    super.finalizeState(context);
  }
  updateAggregationState(opts) {
    const { props, oldProps } = opts;
    const { cellSize, coordinateSystem } = props;
    const { viewport } = this.context;
    const cellSizeChanged = oldProps.cellSize !== cellSize;
    const { dimensions } = this.state;
    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME3);
    const attributesChanged = positionsChanged || this.isAttributeChanged();
    let { boundingBox } = this.state;
    if (positionsChanged) {
      boundingBox = getBoundingBox(this.getAttributes(), this.getNumInstances());
      this.setState({ boundingBox });
    }
    if (positionsChanged || cellSizeChanged) {
      const { gridOffset, translation, width, height, numCol, numRow } = getGridParams(boundingBox, cellSize, viewport, coordinateSystem);
      this.allocateResources(numRow, numCol);
      this.setState({
        gridOffset,
        translation,
        gridOrigin: [-1 * translation[0], -1 * translation[1]],
        width,
        height,
        numCol,
        numRow
      });
    }
    const aggregationDataDirty = attributesChanged || this.isAggregationDirty(opts, {
      dimension: dimensions.data,
      compareAll: true
    });
    if (aggregationDataDirty) {
      this._updateAccessors(opts);
    }
    this.setState({
      aggregationDataDirty
    });
  }
  _updateAccessors(opts) {
    const { colorAggregation, elevationAggregation } = opts.props;
    const { color, elevation } = this.state.weights;
    color.operation = AGGREGATION_OPERATION[colorAggregation];
    elevation.operation = AGGREGATION_OPERATION[elevationAggregation];
  }
};
var GPUGridLayer = _GPUGridLayer;
(() => {
  _GPUGridLayer.layerName = "GPUGridLayer";
})();
(() => {
  _GPUGridLayer.defaultProps = defaultProps8;
})();

// dist/grid-layer/grid-layer.js
var defaultProps9 = {
  ...GPUGridLayer.defaultProps,
  ...CPUGridLayer.defaultProps,
  gpuAggregation: false
};
var _GridLayer = class extends import_core15.CompositeLayer {
  initializeState() {
    this.state = {
      useGPUAggregation: false
    };
  }
  updateState({ props }) {
    this.setState({
      useGPUAggregation: false
    });
  }
  renderLayers() {
    const { data, updateTriggers } = this.props;
    const id = this.state.useGPUAggregation ? "GPU" : "CPU";
    const LayerType = this.state.useGPUAggregation ? this.getSubLayerClass("GPU", GPUGridLayer) : this.getSubLayerClass("CPU", CPUGridLayer);
    return new LayerType(this.props, this.getSubLayerProps({
      id,
      updateTriggers
    }), {
      data
    });
  }
  canUseGPUAggregation(props) {
    const { gpuAggregation, lowerPercentile, upperPercentile, getColorValue, getElevationValue, colorScaleType } = props;
    if (!gpuAggregation) {
      return false;
    }
    if (!GPUGridAggregator.isSupported(this.context.device)) {
      return false;
    }
    if (lowerPercentile !== 0 || upperPercentile !== 100) {
      return false;
    }
    if (getColorValue !== null || getElevationValue !== null) {
      return false;
    }
    if (colorScaleType === "quantile" || colorScaleType === "ordinal") {
      return false;
    }
    return true;
  }
};
var GridLayer = _GridLayer;
(() => {
  _GridLayer.layerName = "GridLayer";
})();
(() => {
  _GridLayer.defaultProps = defaultProps9;
})();

// dist/heatmap-layer/heatmap-layer-utils.js
function getBounds(points) {
  const x = points.map((p) => p[0]);
  const y = points.map((p) => p[1]);
  const xMin = Math.min.apply(null, x);
  const xMax = Math.max.apply(null, x);
  const yMin = Math.min.apply(null, y);
  const yMax = Math.max.apply(null, y);
  return [xMin, yMin, xMax, yMax];
}
function boundsContain(currentBounds, targetBounds) {
  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
    return true;
  }
  return false;
}
var scratchArray = new Float32Array(12);
function packVertices(points, dimensions = 2) {
  let index = 0;
  for (const point of points) {
    for (let i = 0; i < dimensions; i++) {
      scratchArray[index++] = point[i] || 0;
    }
  }
  return scratchArray;
}
function scaleToAspectRatio(boundingBox, width, height) {
  const [xMin, yMin, xMax, yMax] = boundingBox;
  const currentWidth = xMax - xMin;
  const currentHeight = yMax - yMin;
  let newWidth = currentWidth;
  let newHeight = currentHeight;
  if (currentWidth / currentHeight < width / height) {
    newWidth = width / height * currentHeight;
  } else {
    newHeight = height / width * currentWidth;
  }
  if (newWidth < width) {
    newWidth = width;
    newHeight = height;
  }
  const xCenter = (xMax + xMin) / 2;
  const yCenter = (yMax + yMin) / 2;
  return [
    xCenter - newWidth / 2,
    yCenter - newHeight / 2,
    xCenter + newWidth / 2,
    yCenter + newHeight / 2
  ];
}
function getTextureCoordinates(point, bounds) {
  const [xMin, yMin, xMax, yMax] = bounds;
  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
}

// dist/heatmap-layer/heatmap-layer.js
var import_engine6 = require("@luma.gl/engine");
var import_core17 = require("@deck.gl/core");

// dist/heatmap-layer/triangle-layer.js
var import_engine5 = require("@luma.gl/engine");
var import_core16 = require("@deck.gl/core");

// dist/heatmap-layer/triangle-layer-vertex.glsl.js
var triangle_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;
uniform float aggregationMode;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * threshold;
if (colorDomain[1] > 0.) {
maxValue = colorDomain[1];
minValue = colorDomain[0];
}
vIntensityMax = intensity / maxValue;
vIntensityMin = intensity / minValue;
}
`;

// dist/heatmap-layer/triangle-layer-fragment.glsl.js
var triangle_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
uniform float aggregationMode;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= opacity;
fragColor = linearColor;
}
`;

// dist/heatmap-layer/triangle-layer.js
var _TriangleLayer = class extends import_core16.Layer {
  getShaders() {
    return { vs: triangle_layer_vertex_glsl_default, fs: triangle_layer_fragment_glsl_default, modules: [import_core16.project32] };
  }
  initializeState({ device }) {
    this.setState({ model: this._getModel(device) });
  }
  _getModel(device) {
    const { vertexCount, data, weightsTexture, maxTexture, colorTexture } = this.props;
    return new import_engine5.Model(device, {
      ...this.getShaders(),
      id: this.props.id,
      bindings: { weightsTexture, maxTexture, colorTexture },
      attributes: data.attributes,
      bufferLayout: [
        { name: "positions", format: "float32x3" },
        { name: "texCoords", format: "float32x2" }
      ],
      topology: "triangle-fan-webgl",
      vertexCount
    });
  }
  draw({ uniforms }) {
    const { model } = this.state;
    const { intensity, threshold: threshold2, aggregationMode, colorDomain } = this.props;
    model.setUniforms({
      ...uniforms,
      intensity,
      threshold: threshold2,
      aggregationMode,
      colorDomain
    });
    model.draw(this.context.renderPass);
  }
};
var TriangleLayer = _TriangleLayer;
(() => {
  _TriangleLayer.layerName = "TriangleLayer";
})();

// dist/heatmap-layer/weights-vs.glsl.js
var weights_vs_glsl_default = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;
void main()
{
weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`;

// dist/heatmap-layer/weights-fs.glsl.js
var weights_fs_glsl_default = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// dist/heatmap-layer/max-vs.glsl.js
var max_vs_glsl_default = `#version 300 es
uniform sampler2D inTexture;
uniform float textureSize;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(textureSize);
int xIndex = gl_VertexID - (yIndex * int(textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;

// dist/heatmap-layer/max-fs.glsl.js
var max_fs_glsl_default = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;

// dist/heatmap-layer/heatmap-layer.js
var RESOLUTION = 2;
var TEXTURE_PROPS = {
  format: "rgba8unorm",
  mipmaps: false,
  sampler: {
    minFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
var DEFAULT_COLOR_DOMAIN = [0, 0];
var AGGREGATION_MODE = {
  SUM: 0,
  MEAN: 1
};
var defaultProps10 = {
  getPosition: { type: "accessor", value: (x) => x.position },
  getWeight: { type: "accessor", value: 1 },
  intensity: { type: "number", min: 0, value: 1 },
  radiusPixels: { type: "number", min: 1, max: 100, value: 50 },
  colorRange: defaultColorRange,
  threshold: { type: "number", min: 0, max: 1, value: 0.05 },
  colorDomain: { type: "array", value: null, optional: true },
  aggregation: "SUM",
  weightsTextureSize: { type: "number", min: 128, max: 2048, value: 2048 },
  debounceTimeout: { type: "number", min: 0, max: 1e3, value: 500 }
};
var FLOAT_TARGET_FEATURES = [
  "float32-renderable-webgl",
  "texture-blend-float-webgl"
];
var DIMENSIONS4 = {
  data: {
    props: ["radiusPixels"]
  }
};
var _HeatmapLayer = class extends AggregationLayer {
  initializeState() {
    super.initializeAggregationLayer(DIMENSIONS4);
    this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });
    this._setupTextureParams();
    this._setupAttributes();
    this._setupResources();
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState(opts) {
    super.updateState(opts);
    this._updateHeatmapState(opts);
  }
  _updateHeatmapState(opts) {
    const { props, oldProps } = opts;
    const changeFlags = this._getChangeFlags(opts);
    if (changeFlags.dataChanged || changeFlags.viewportChanged) {
      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
      this._updateTextureRenderingBounds();
    }
    if (changeFlags.dataChanged || changeFlags.boundsChanged) {
      clearTimeout(this.state.updateTimer);
      this.setState({ isWeightMapDirty: true });
    } else if (changeFlags.viewportZoomChanged) {
      this._debouncedUpdateWeightmap();
    }
    if (props.colorRange !== oldProps.colorRange) {
      this._updateColorTexture(opts);
    }
    if (this.state.isWeightMapDirty) {
      this._updateWeightmap();
    }
    this.setState({ zoom: opts.context.viewport.zoom });
  }
  renderLayers() {
    const { weightsTexture, triPositionBuffer, triTexCoordBuffer, maxWeightsTexture, colorTexture, colorDomain } = this.state;
    const { updateTriggers, intensity, threshold: threshold2, aggregation } = this.props;
    const TriangleLayerClass = this.getSubLayerClass("triangle", TriangleLayer);
    return new TriangleLayerClass(this.getSubLayerProps({
      id: "triangle-layer",
      updateTriggers
    }), {
      coordinateSystem: import_core17.COORDINATE_SYSTEM.DEFAULT,
      data: {
        attributes: {
          positions: triPositionBuffer,
          texCoords: triTexCoordBuffer
        }
      },
      vertexCount: 4,
      maxTexture: maxWeightsTexture,
      colorTexture,
      aggregationMode: AGGREGATION_MODE[aggregation] || 0,
      weightsTexture,
      intensity,
      threshold: threshold2,
      colorDomain
    });
  }
  finalizeState(context) {
    super.finalizeState(context);
    const { weightsTransform, weightsTexture, maxWeightTransform, maxWeightsTexture, triPositionBuffer, triTexCoordBuffer, colorTexture, updateTimer } = this.state;
    weightsTransform == null ? void 0 : weightsTransform.destroy();
    weightsTexture == null ? void 0 : weightsTexture.destroy();
    maxWeightTransform == null ? void 0 : maxWeightTransform.destroy();
    maxWeightsTexture == null ? void 0 : maxWeightsTexture.destroy();
    triPositionBuffer == null ? void 0 : triPositionBuffer.destroy();
    triTexCoordBuffer == null ? void 0 : triTexCoordBuffer.destroy();
    colorTexture == null ? void 0 : colorTexture.destroy();
    if (updateTimer) {
      clearTimeout(updateTimer);
    }
  }
  _getAttributeManager() {
    return new import_core17.AttributeManager(this.context.device, {
      id: this.props.id,
      stats: this.context.stats
    });
  }
  _getChangeFlags(opts) {
    const changeFlags = {};
    const { dimensions } = this.state;
    changeFlags.dataChanged = this.isAttributeChanged() && "attribute changed" || this.isAggregationDirty(opts, {
      compareAll: true,
      dimension: dimensions.data
    }) && "aggregation is dirty";
    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
    const { zoom } = this.state;
    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
      changeFlags.viewportZoomChanged = true;
    }
    return changeFlags;
  }
  _createTextures() {
    const { textureSize, format } = this.state;
    this.setState({
      weightsTexture: this.context.device.createTexture({
        ...TEXTURE_PROPS,
        width: textureSize,
        height: textureSize,
        format
      }),
      maxWeightsTexture: this.context.device.createTexture({
        ...TEXTURE_PROPS,
        width: 1,
        height: 1,
        format
      })
    });
  }
  _setupAttributes() {
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      positions: { size: 3, type: "float64", accessor: "getPosition" },
      weights: { size: 1, accessor: "getWeight" }
    });
    this.setState({ positionAttributeName: "positions" });
  }
  _setupTextureParams() {
    const { device } = this.context;
    const { weightsTextureSize } = this.props;
    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);
    const floatTargetSupport = FLOAT_TARGET_FEATURES.every((feature) => device.features.has(feature));
    const format = floatTargetSupport ? "rgba32float" : "rgba8unorm";
    const weightsScale = floatTargetSupport ? 1 : 1 / 255;
    this.setState({ textureSize, format, weightsScale });
    if (!floatTargetSupport) {
      import_core17.log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();
    }
  }
  _createWeightsTransform(shaders) {
    let { weightsTransform } = this.state;
    const { weightsTexture } = this.state;
    const attributeManager = this.getAttributeManager();
    weightsTransform == null ? void 0 : weightsTransform.destroy();
    weightsTransform = new import_engine6.TextureTransform(this.context.device, {
      id: `${this.id}-weights-transform`,
      bufferLayout: attributeManager.getBufferLayouts(),
      vertexCount: 1,
      targetTexture: weightsTexture,
      parameters: {
        depthWriteEnabled: false,
        blendColorOperation: "add",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      },
      topology: "point-list",
      ...shaders
    });
    this.setState({ weightsTransform });
  }
  _setupResources() {
    this._createTextures();
    const { device } = this.context;
    const { textureSize, weightsTexture, maxWeightsTexture } = this.state;
    const weightsTransformShaders = this.getShaders({
      vs: weights_vs_glsl_default,
      fs: weights_fs_glsl_default
    });
    this._createWeightsTransform(weightsTransformShaders);
    const maxWeightsTransformShaders = this.getShaders({ vs: max_vs_glsl_default, fs: max_fs_glsl_default });
    const maxWeightTransform = new import_engine6.TextureTransform(device, {
      id: `${this.id}-max-weights-transform`,
      bindings: { inTexture: weightsTexture },
      uniforms: { textureSize },
      targetTexture: maxWeightsTexture,
      ...maxWeightsTransformShaders,
      vertexCount: textureSize * textureSize,
      topology: "point-list",
      parameters: {
        depthWriteEnabled: false,
        blendColorOperation: "max",
        blendAlphaOperation: "max",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      }
    });
    this.setState({
      weightsTexture,
      maxWeightsTexture,
      maxWeightTransform,
      zoom: null,
      triPositionBuffer: device.createBuffer({ byteLength: 48 }),
      triTexCoordBuffer: device.createBuffer({ byteLength: 48 })
    });
  }
  updateShaders(shaderOptions) {
    this._createWeightsTransform({
      vs: weights_vs_glsl_default,
      fs: weights_fs_glsl_default,
      ...shaderOptions
    });
  }
  _updateMaxWeightValue() {
    const { maxWeightTransform } = this.state;
    maxWeightTransform.run({
      parameters: { viewport: [0, 0, 1, 1] },
      clearColor: [0, 0, 0, 0]
    });
  }
  _updateBounds(forceUpdate = false) {
    const { viewport } = this.context;
    const viewportCorners = [
      viewport.unproject([0, 0]),
      viewport.unproject([viewport.width, 0]),
      viewport.unproject([viewport.width, viewport.height]),
      viewport.unproject([0, viewport.height])
    ].map((p) => p.map(Math.fround));
    const visibleWorldBounds = getBounds(viewportCorners);
    const newState = { visibleWorldBounds, viewportCorners };
    let boundsChanged = false;
    if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
      if (this.props.coordinateSystem === import_core17.COORDINATE_SYSTEM.LNGLAT) {
        worldBounds[1] = Math.max(worldBounds[1], -85.051129);
        worldBounds[3] = Math.min(worldBounds[3], 85.051129);
        worldBounds[0] = Math.max(worldBounds[0], -360);
        worldBounds[2] = Math.min(worldBounds[2], 360);
      }
      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
      newState.worldBounds = worldBounds;
      newState.normalizedCommonBounds = normalizedCommonBounds;
      boundsChanged = true;
    }
    this.setState(newState);
    return boundsChanged;
  }
  _updateTextureRenderingBounds() {
    const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;
    const { viewport } = this.context;
    triPositionBuffer.write(packVertices(viewportCorners, 3));
    const textureBounds = viewportCorners.map((p) => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));
    triTexCoordBuffer.write(packVertices(textureBounds, 2));
  }
  _updateColorTexture(opts) {
    const { colorRange } = opts.props;
    let { colorTexture } = this.state;
    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
    if (colorTexture && (colorTexture == null ? void 0 : colorTexture.width) === colorRange.length) {
      colorTexture.setSubImageData({ data: colors });
    } else {
      colorTexture == null ? void 0 : colorTexture.destroy();
      colorTexture = this.context.device.createTexture({
        ...TEXTURE_PROPS,
        data: colors,
        width: colorRange.length,
        height: 1
      });
    }
    this.setState({ colorTexture });
  }
  _updateWeightmap() {
    const { radiusPixels, colorDomain, aggregation } = this.props;
    const { worldBounds, textureSize, weightsScale } = this.state;
    const weightsTransform = this.state.weightsTransform;
    this.state.isWeightMapDirty = false;
    const commonBounds = this._worldToCommonBounds(worldBounds, {
      useLayerCoordinateSystem: true
    });
    if (colorDomain && aggregation === "SUM") {
      const { viewport } = this.context;
      const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
      this.state.colorDomain = colorDomain.map((x) => x * metersPerPixel * weightsScale);
    } else {
      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
    }
    const attributeManager = this.getAttributeManager();
    const attributes = attributeManager.getAttributes();
    const moduleSettings = this.getModuleSettings();
    const positions = attributes.positions.buffer;
    const uniforms = { radiusPixels, commonBounds, textureWidth: textureSize, weightsScale };
    const weights = attributes.weights.buffer;
    weightsTransform.model.setAttributes({ positions, weights });
    weightsTransform.model.setVertexCount(this.getNumInstances());
    weightsTransform.model.setUniforms(uniforms);
    weightsTransform.model.updateModuleSettings(moduleSettings);
    weightsTransform.run({
      parameters: { viewport: [0, 0, textureSize, textureSize] },
      clearColor: [0, 0, 0, 0]
    });
    this._updateMaxWeightValue();
  }
  _debouncedUpdateWeightmap(fromTimer = false) {
    let { updateTimer } = this.state;
    const { debounceTimeout } = this.props;
    if (fromTimer) {
      updateTimer = null;
      this._updateBounds(true);
      this._updateTextureRenderingBounds();
      this.setState({ isWeightMapDirty: true });
    } else {
      this.setState({ isWeightMapDirty: false });
      clearTimeout(updateTimer);
      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
    }
    this.setState({ updateTimer });
  }
  _worldToCommonBounds(worldBounds, opts = {}) {
    const { useLayerCoordinateSystem = false } = opts;
    const [minLong, minLat, maxLong, maxLat] = worldBounds;
    const { viewport } = this.context;
    const { textureSize } = this.state;
    const { coordinateSystem } = this.props;
    const offsetMode = useLayerCoordinateSystem && (coordinateSystem === import_core17.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === import_core17.COORDINATE_SYSTEM.METER_OFFSETS);
    const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];
    const size = textureSize * RESOLUTION / viewport.scale;
    let bottomLeftCommon;
    let topRightCommon;
    if (useLayerCoordinateSystem && !offsetMode) {
      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
    } else {
      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
    }
    return scaleToAspectRatio([
      bottomLeftCommon[0] - offsetOriginCommon[0],
      bottomLeftCommon[1] - offsetOriginCommon[1],
      topRightCommon[0] - offsetOriginCommon[0],
      topRightCommon[1] - offsetOriginCommon[1]
    ], size, size);
  }
  _commonToWorldBounds(commonBounds) {
    const [xMin, yMin, xMax, yMax] = commonBounds;
    const { viewport } = this.context;
    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);
    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
  }
};
var HeatmapLayer = _HeatmapLayer;
(() => {
  _HeatmapLayer.layerName = "HeatmapLayer";
})();
(() => {
  _HeatmapLayer.defaultProps = defaultProps10;
})();
//# sourceMappingURL=index.cjs.map
