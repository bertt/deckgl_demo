(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var li=Object.create;var Nt=Object.defineProperty;var ci=Object.getOwnPropertyDescriptor;var ui=Object.getOwnPropertyNames;var gi=Object.getPrototypeOf,fi=Object.prototype.hasOwnProperty;var Qt=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),di=(n,t)=>{for(var e in t)Nt(n,e,{get:t[e],enumerable:!0})},Pt=(n,t,e,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ui(t))!fi.call(n,i)&&i!==e&&Nt(n,i,{get:()=>t[i],enumerable:!(o=ci(t,i))||o.enumerable});return n},U=(n,t,e)=>(Pt(n,t,"default"),e&&Pt(e,t,"default")),M=(n,t,e)=>(e=n!=null?li(gi(n)):{},Pt(t||!n||!n.__esModule?Nt(e,"default",{value:n,enumerable:!0}):e,n)),pi=n=>Pt(Nt({},"__esModule",{value:!0}),n);var $=Qt((Pr,he)=>{he.exports=globalThis.deck});var E=Qt((Dr,ve)=>{ve.exports=globalThis.deck});var q=Qt((Or,Se)=>{Se.exports=globalThis.luma});var Et={};di(Et,{AGGREGATION_OPERATION:()=>T,CPUGridLayer:()=>H,ContourLayer:()=>_t,GPUGridLayer:()=>V,GridLayer:()=>Mt,HeatmapLayer:()=>Ct,HexagonLayer:()=>At,ScreenGridLayer:()=>St,_AggregationLayer:()=>P,_BinSorter:()=>F,_CPUAggregator:()=>I,_GPUGridAggregator:()=>C});var L={},xe=M($(),1);U(L,M($(),1));if(!xe.GeoJsonLayer)throw new Error("@deck.gl/layers is not found");U(Et,L);var oo=M(E(),1);var vt=M(q(),1);function Zt(n,t=[],e=0){let o=Math.fround(n),i=n-o;return t[e]=o,t[e+1]=i,t}function Ae(n){return n-Math.fround(n)}function ye(n){let t=new Float32Array(32);for(let e=0;e<4;++e)for(let o=0;o<4;++o){let i=e*4+o;Zt(n[o*4+e],t,i*2)}return t}var _e=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var mi={ONE:1};function hi(){return mi}var K={name:"fp64-arithmetic",vs:_e,getUniforms:hi,fp64ify:Zt,fp64LowPart:Ae,fp64ifyMatrix4:ye};var J=M(E(),1);var T={SUM:1,MEAN:2,MIN:3,MAX:4};function be(n,t){return n+t}function xi(n,t){return t>n?t:n}function vi(n,t){return t<n?t:n}function Si(n,t){if(Number.isFinite(t))return n.length?t:null;let e=n.map(t).filter(Number.isFinite);return e.length?e.reduce(be,0)/e.length:null}function Ai(n,t){if(Number.isFinite(t))return n.length?n.length*t:null;let e=n.map(t).filter(Number.isFinite);return e.length?e.reduce(be,0):null}function yi(n,t){if(Number.isFinite(t))return n.length?t:null;let e=n.map(t).filter(Number.isFinite);return e.length?e.reduce(xi,-1/0):null}function _i(n,t){if(Number.isFinite(t))return n.length?t:null;let e=n.map(t).filter(Number.isFinite);return e.length?e.reduce(vi,1/0):null}function Q(n,t,e){let o=T[n]||T.SUM;switch(t=bi(t,e),o){case T.MIN:return i=>_i(i,t);case T.SUM:return i=>Ai(i,t);case T.MEAN:return i=>Si(i,t);case T.MAX:return i=>yi(i,t);default:return null}}function bi(n,t={}){return Number.isFinite(n)?n:e=>(t.index=e.index,n(e.source,t))}function Me(n,t={}){return e=>(t.indices=e.map(o=>o.index),n(e.map(o=>o.source),t))}var Te={projectPoints:!1,viewport:null,createBufferObjects:!0,moduleSettings:{}},W=3402823466e29,Jt=[32775,32774],te=[32776,32774],Ce=[32776,32775],ee={[T.SUM]:32774,[T.MEAN]:32774,[T.MIN]:Jt,[T.MAX]:te};var Ee={size:1,operation:T.SUM,needMin:!1,needMax:!1,combineMaxMin:!1},Pe=4;var Ne=`#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-vs
in vec3 positions;
in vec3 positions64Low;
in vec3 weights;
uniform vec2 cellSize;
uniform vec2 gridSize;
uniform bool projectPoints;
uniform vec2 translation;
uniform vec3 scaling;
out vec3 vWeights;
vec2 project_to_pixel(vec4 pos) {
vec4 result;
pos.xy = pos.xy/pos.w;
result = pos + vec4(translation, 0., 0.);
result.xy = scaling.z > 0. ? result.xy * scaling.xy : result.xy;
return result.xy;
}
void main(void) {
vWeights = weights;
vec4 windowPos = vec4(positions, 1.);
if (projectPoints) {
windowPos = project_position_to_clipspace(positions, positions64Low, vec3(0));
}
vec2 pos = project_to_pixel(windowPos);
vec2 pixelXY64[2];
pixelXY64[0] = vec2(pos.x, 0.);
pixelXY64[1] = vec2(pos.y, 0.);
vec2 gridXY64[2];
gridXY64[0] = div_fp64(pixelXY64[0], vec2(cellSize.x, 0));
gridXY64[1] = div_fp64(pixelXY64[1], vec2(cellSize.y, 0));
float x = floor(gridXY64[0].x);
float y = floor(gridXY64[1].x);
pos = vec2(x, y);
pos = (pos * (2., 2.) / (gridSize)) - (1., 1.);
vec2 offset = 1.0 / gridSize;
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;var De=`#version 300 es
#define SHADER_NAME gpu-aggregation-to-grid-fs
precision highp float;
in vec3 vWeights;
out vec4 fragColor;
void main(void) {
fragColor = vec4(vWeights, 1.0);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Oe=`#version 300 es
#define SHADER_NAME gpu-aggregation-all-vs-64
in vec2 position;
uniform ivec2 gridSize;
out vec2 vTextureCoord;
void main(void) {
vec2 pos = vec2(-1.0, -1.0);
vec2 offset = 1.0 / vec2(gridSize);
pos = pos + offset;
gl_Position = vec4(pos, 0.0, 1.0);
int yIndex = gl_InstanceID / gridSize[0];
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 yIndexFP64 = vec2(float(yIndex), 0.);
vec2 xIndexFP64 = vec2(float(xIndex), 0.);
vec2 gridSizeYFP64 = vec2(gridSize[1], 0.);
vec2 gridSizeXFP64 = vec2(gridSize[0], 0.);
vec2 texCoordXFP64 = div_fp64(yIndexFP64, gridSizeYFP64);
vec2 texCoordYFP64 = div_fp64(xIndexFP64, gridSizeXFP64);
vTextureCoord = vec2(texCoordYFP64.x, texCoordXFP64.x);
gl_PointSize = 1.0;
}
`;var Le=`#version 300 es
#define SHADER_NAME gpu-aggregation-all-fs
precision highp float;
in vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform bool combineMaxMin;
out vec4 fragColor;
void main(void) {
vec4 textureColor = texture(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
if (textureColor.a == 0.) {
discard;
}
fragColor.rgb = textureColor.rgb;
fragColor.a = combineMaxMin ? textureColor.r : textureColor.a;
}
`;var Fe=`#version 300 es
#define SHADER_NAME gpu-aggregation-transform-mean-vs
in vec4 aggregationValues;
out vec4 meanValues;
void main()
{
bool isCellValid = bool(aggregationValues.w > 0.);
meanValues.xyz = isCellValid ? aggregationValues.xyz/aggregationValues.w : vec3(0, 0, 0);
meanValues.w = aggregationValues.w;
gl_PointSize = 1.0;
}
`;var Mi={minFilter:"nearest",magFilter:"nearest"};function Z(n,t){let{width:e=1,height:o=1,data:i=null,parameters:r=Mi}=t;return n.createTexture({data:i,format:"rgba32float",mipmaps:!1,sampler:r,width:e,height:o})}function xt(n,t){let{id:e,width:o=1,height:i=1,texture:r}=t;return n.createFramebuffer({id:e,width:o,height:i,colorAttachments:[r]})}var Ti=["aggregationBuffer","maxMinBuffer","minBuffer","maxBuffer"],we={maxData:"maxBuffer",minData:"minBuffer",maxMinData:"maxMinBuffer"},Ci=["float32-renderable-webgl","texture-blend-float-webgl"],C=class{static getAggregationData({aggregationData:t,maxData:e,minData:o,maxMinData:i,pixelIndex:r}){let s=r*Pe,a={};return t&&(a.cellCount=t[s+3],a.cellWeight=t[s]),i?(a.maxCellWieght=i[0],a.minCellWeight=i[3]):(e&&(a.maxCellWieght=e[0],a.totalCount=e[3]),o&&(a.minCellWeight=o[0],a.totalCount=o[3])),a}static getCellData({countsData:t,size:e=1}){let o=t.length/4,i=new Float32Array(o*e),r=new Uint32Array(o);for(let s=0;s<o;s++){for(let a=0;a<e;a++)i[s*e+a]=t[s*4+a];r[s]=t[s*4+3]}return{cellCounts:r,cellWeights:i}}static isSupported(t){return Ci.every(e=>t.features.has(e))}constructor(t,e={}){this.state={weightAttributes:{},textures:{},meanTextures:{},buffers:{},framebuffers:{},maxMinFramebuffers:{},minFramebuffers:{},maxFramebuffers:{},equations:{},shaderOptions:{},modelDirty:!1,resources:{},results:{}},this.id=e.id||"gpu-grid-aggregator",this.device=t;let o=["float32-renderable-webgl"];this._hasGPUSupport=o.every(i=>t.features.has(i)),this._hasGPUSupport&&this._setupModels()}delete(){let{gridAggregationModel:t,allAggregationModel:e,meanTransform:o}=this,{textures:i,framebuffers:r,maxMinFramebuffers:s,minFramebuffers:a,maxFramebuffers:l,meanTextures:c,resources:g}=this.state;t?.destroy(),e?.destroy(),o?.destroy(),Pi([r,i,s,a,l,c,g])}run(t={}){this.setState({results:{}});let e=this._normalizeAggregationParams(t);return this._runAggregation(e)}getData(t){let e={},o=this.state.results;o[t].aggregationData||(o[t].aggregationData=o[t].aggregationBuffer.getData()),e.aggregationData=o[t].aggregationData;for(let i in we){let r=we[i];(o[t][i]||o[t][r])&&(o[t][i]=o[t][i]||o[t][r].getData(),e[i]=o[t][i])}return e}updateShaders(t={}){this.setState({shaderOptions:t,modelDirty:!0})}_normalizeAggregationParams(t){let e={...Te,...t},{weights:o}=e;return o&&(e.weights=Ei(o)),e}setState(t){Object.assign(this.state,t)}_getAggregateData(t){let e={},{textures:o,framebuffers:i,maxMinFramebuffers:r,minFramebuffers:s,maxFramebuffers:a,resources:l}=this.state,{weights:c}=t;for(let g in c){e[g]={};let{needMin:f,needMax:d,combineMaxMin:p}=c[g];e[g].aggregationTexture=o[g],e[g].aggregationBuffer=this.device.readPixelsToBufferWebGL(i[g],{target:c[g].aggregationBuffer,sourceType:5126}),f&&d&&p?(e[g].maxMinBuffer=this.device.readPixelsToBufferWebGL(r[g],{target:c[g].maxMinBuffer,sourceType:5126}),e[g].maxMinTexture=l[`${g}-maxMinTexture`]):(f&&(e[g].minBuffer=this.device.readPixelsToBufferWebGL(s[g],{target:c[g].minBuffer,sourceType:5126}),e[g].minTexture=l[`${g}-minTexture`]),d&&(e[g].maxBuffer=this.device.readPixelsToBufferWebGL(a[g],{target:c[g].maxBuffer,sourceType:5126}),e[g].maxTexture=l[`${g}-maxTexture`]))}return this._trackGPUResultBuffers(e,c),e}_renderAggregateData(t){let{cellSize:e,projectPoints:o,attributes:i,moduleSettings:r,numCol:s,numRow:a,weights:l,translation:c,scaling:g}=t,{maxMinFramebuffers:f,minFramebuffers:d,maxFramebuffers:p}=this.state,x=[s,a],h={blend:!0,depthTest:!1,blendFunc:[1,1]},A={cellSize:e,gridSize:x,projectPoints:o,translation:c,scaling:g};for(let S in l){let{needMin:y,needMax:_}=l[S],b=y&&_&&l[S].combineMaxMin;this._renderToWeightsTexture({id:S,parameters:h,moduleSettings:r,uniforms:A,gridSize:x,attributes:i,weights:l}),b?this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:Ce},gridSize:x,minOrMaxFb:f[S],clearParams:{clearColor:[0,0,0,W]},combineMaxMin:b}):(y&&this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:Jt},gridSize:x,minOrMaxFb:d[S],clearParams:{clearColor:[W,W,W,0]},combineMaxMin:b}),_&&this._renderToMaxMinTexture({id:S,parameters:{...h,blendEquation:te},gridSize:x,minOrMaxFb:p[S],clearParams:{clearColor:[0,0,0,0]},combineMaxMin:b}))}}_renderToMaxMinTexture(t){let{id:e,gridSize:o,minOrMaxFb:i,combineMaxMin:r,clearParams:s={}}=t,{framebuffers:a}=this.state,{allAggregationModel:l}=this;this.device.withParametersWebGL({...s,framebuffer:i,viewport:[0,0,o[0],o[1]]},()=>{this.device.clearWebGL({color:!0}),l.setUniforms({gridSize:o,combineMaxMin:r}),l.setBindings({uSampler:a[e].texture}),l.draw()})}_renderToWeightsTexture(t){let{id:e,parameters:o,moduleSettings:i,uniforms:r,gridSize:s,weights:a}=t,{framebuffers:l,equations:c,weightAttributes:g}=this.state,{gridAggregationModel:f}=this,{operation:d}=a[e],p=d===T.MIN?[W,W,W,0]:[0,0,0,0];if(this.device.withParametersWebGL({framebuffer:l[e],viewport:[0,0,s[0],s[1]],clearColor:p},()=>{this.device.clearWebGL({color:!0});let x={weights:g[e]};f.draw({parameters:{...o,blendEquation:c[e]},moduleSettings:i,uniforms:r,attributes:x})}),d===T.MEAN){let{meanTextures:x,textures:h}=this.state,A={_sourceTextures:{aggregationValues:x[e]},_targetTexture:h[e],elementCount:h[e].width*h[e].height};this.meanTransform?this.meanTransform.update(A):this.meanTransform=Oi(this.device,A),this.meanTransform.run({parameters:{blend:!1,depthTest:!1}}),l[e].attach({[36064]:h[e]})}}_runAggregation(t){this._updateModels(t),this._setupFramebuffers(t),this._renderAggregateData(t);let e=this._getAggregateData(t);return this.setState({results:e}),e}_setupFramebuffers(t){let{textures:e,framebuffers:o,maxMinFramebuffers:i,minFramebuffers:r,maxFramebuffers:s,meanTextures:a,equations:l}=this.state,{weights:c}=t,{numCol:g,numRow:f}=t,d={width:g,height:f};for(let p in c){let{needMin:x,needMax:h,combineMaxMin:A,operation:S}=c[p];e[p]=c[p].aggregationTexture||e[p]||Z(this.device,{id:`${p}-texture`,width:g,height:f}),e[p].resize(d);let y=e[p];S===T.MEAN&&(a[p]=a[p]||Z(this.device,{id:`${p}-mean-texture`,width:g,height:f}),a[p].resize(d),y=a[p]),o[p]?o[p].attach({[36064]:y}):o[p]=xt(this.device,{id:`${p}-fb`,width:g,height:f,texture:y}),o[p].resize(d),l[p]=ee[S]||ee[T.SUM],(x||h)&&(x&&h&&A?i[p]||(y=c[p].maxMinTexture||this._getMinMaxTexture(`${p}-maxMinTexture`),i[p]=xt(this.device,{id:`${p}-maxMinFb`,texture:y})):(x&&(r[p]||(y=c[p].minTexture||this._getMinMaxTexture(`${p}-minTexture`),r[p]=xt(this.device,{id:`${p}-minFb`,texture:y}))),h&&(s[p]||(y=c[p].maxTexture||this._getMinMaxTexture(`${p}-maxTexture`),s[p]=xt(this.device,{id:`${p}-maxFb`,texture:y})))))}}_getMinMaxTexture(t){let{resources:e}=this.state;return e[t]||(e[t]=Z(this.device,{id:"resourceName"})),e[t]}_setupModels({numCol:t=0,numRow:e=0}={}){let{shaderOptions:o}=this.state;if(this.gridAggregationModel?.destroy(),this.gridAggregationModel=Ni(this.device,o),!this.allAggregationModel){let i=t*e;this.allAggregationModel=Di(this.device,i)}}_setupWeightAttributes(t){let{weightAttributes:e}=this.state,{weights:o}=t;for(let i in o)e[i]=t.attributes[i]}_trackGPUResultBuffers(t,e){let{resources:o}=this.state;for(let i in t)if(t[i]){for(let r of Ti)if(t[i][r]&&e[i][r]!==t[i][r]){let s=`gpu-result-${i}-${r}`;o[s]&&o[s].delete(),o[s]=t[i][r]}}}_updateModels(t){let{vertexCount:e,attributes:o,numCol:i,numRow:r}=t,{modelDirty:s}=this.state;s&&(this._setupModels(t),this.setState({modelDirty:!1})),this._setupWeightAttributes(t),this.gridAggregationModel.setVertexCount(e),this.gridAggregationModel.setAttributes(o),this.allAggregationModel.setInstanceCount(i*r)}};function Ei(n){let t={};for(let e in n)t[e]={...Ee,...n[e]};return t}function Pi(n){n=Array.isArray(n)?n:[n],n.forEach(t=>{for(let e in t)t[e].delete()})}function Ni(n,t){let e=(0,J._mergeShaders)({vs:Ne,fs:De,modules:[K,J.project32]},t);return new vt.Model(n,{id:"Grid-Aggregation-Model",vertexCount:1,drawMode:0,shaderAssembler:(0,J.getShaderAssembler)(),...e})}function Di(n,t){return new vt.Model(n,{id:"All-Aggregation-Model",vs:Oe,fs:Le,modules:[K],vertexCount:1,topology:"point-list",isInstanced:!0,instanceCount:t,attributes:{position:[0,0]}})}function Oi(n,t){return new vt.TextureTransform(n,{vs:Fe,_targetTextureVarying:"meanValues",...t})}var Ot=M(q(),1),et=M(E(),1);var D=[[255,255,178],[254,217,118],[254,178,76],[253,141,60],[240,59,32],[189,0,38]];function z(n,t=!1,e=Float32Array){let o;if(Number.isFinite(n[0]))o=new e(n);else{o=new e(n.length*4);let i=0;for(let r=0;r<n.length;r++){let s=n[r];o[i++]=s[0],o[i++]=s[1],o[i++]=s[2],o[i++]=Number.isFinite(s[3])?s[3]:255}}if(t)for(let i=0;i<o.length;i++)o[i]/=255;return o}var Ie=`#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 instancePositions;
in vec4 instanceCounts;
in vec3 instancePickingColors;
uniform float opacity;
uniform vec3 cellScale;
uniform vec4 minColor;
uniform vec4 maxColor;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 colorDomain;
uniform bool shouldUseMinMax;
uniform sampler2D maxTexture;
out vec4 vColor;
out float vSampleCount;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= domain.x && value <= domain.y) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
outColor = outColor / 255.;
return outColor;
}
void main(void) {
vSampleCount = instanceCounts.a;
float weight = instanceCounts.r;
float maxWeight = texture(maxTexture, vec2(0.5)).r;
float step = weight / maxWeight;
vec4 minMaxColor = mix(minColor, maxColor, step) / 255.;
vec2 domain = colorDomain;
float domainMaxValid = float(colorDomain.y != 0.);
domain.y = mix(maxWeight, colorDomain.y, domainMaxValid);
vec4 rangeColor = quantizeScale(domain, colorRange, weight);
float rangeMinMax = float(shouldUseMinMax);
vec4 color = mix(rangeColor, minMaxColor, rangeMinMax);
vColor = vec4(color.rgb, color.a * opacity);
picking_setPickingColor(instancePickingColors);
gl_Position = vec4(instancePositions + positions * cellScale, 1.);
}
`;var Re=`#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader
precision highp float;
in vec4 vColor;
in float vSampleCount;
out vec4 fragColor;
void main(void) {
if (vSampleCount <= 0.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var Li=[0,0,0,0],Fi=[0,255,0,255],wi=["minColor","maxColor","colorRange","colorDomain"],Ii={cellSizePixels:{type:"number",value:100,min:1},cellMarginPixels:{type:"number",value:2,min:0,max:5},colorDomain:null,colorRange:D},Dt=class extends et.Layer{getShaders(){return{vs:Ie,fs:Re,modules:[et.picking]}}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,update:this.calculateInstancePositions},instanceCounts:{size:4,noAlloc:!0}}),this.setState({model:this._getModel()})}shouldUpdateState({changeFlags:t}){return t.somethingChanged}updateState(t){super.updateState(t);let{oldProps:e,props:o,changeFlags:i}=t,r=this.getAttributeManager();o.numInstances!==e.numInstances?r.invalidateAll():e.cellSizePixels!==o.cellSizePixels&&r.invalidate("instancePositions"),this._updateUniforms(e,o,i)}draw({uniforms:t}){let{parameters:e,maxTexture:o}=this.props,i=this.props.minColor||Li,r=this.props.maxColor||Fi,s=this.props.colorDomain||[1,0],a=this.state.model;a.setUniforms(t),a.setBindings({maxTexture:o}),a.setUniforms({minColor:i,maxColor:r,colorDomain:s}),a.setParameters({depthWriteEnabled:!1,...e}),a.draw(this.context.renderPass)}calculateInstancePositions(t,{numInstances:e}){let{width:o,height:i}=this.context.viewport,{cellSizePixels:r}=this.props,s=Math.ceil(o/r),{value:a,size:l}=t;for(let c=0;c<e;c++){let g=c%s,f=Math.floor(c/s);a[c*l+0]=g*r/o*2-1,a[c*l+1]=1-f*r/i*2,a[c*l+2]=0}}_getModel(){return new Ot.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:new Ot.Geometry({topology:"triangle-list",attributes:{positions:new Float32Array([0,0,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,0])}})})}_shouldUseMinMax(){let{minColor:t,maxColor:e,colorDomain:o,colorRange:i}=this.props;return t||e?(et.log.deprecated("ScreenGridLayer props: minColor and maxColor","colorRange, colorDomain")(),!0):!(o||i)}_updateUniforms(t,e,o){let i=this.state.model;if(wi.some(r=>t[r]!==e[r])&&i.setUniforms({shouldUseMinMax:this._shouldUseMinMax()}),t.colorRange!==e.colorRange&&i.setUniforms({colorRange:z(e.colorRange)}),t.cellMarginPixels!==e.cellMarginPixels||t.cellSizePixels!==e.cellSizePixels||o.viewportChanged){let{width:r,height:s}=this.context.viewport,{cellSizePixels:a,cellMarginPixels:l}=this.props,c=a>l?l:0,g=new Float32Array([(a-c)/r*2,-(a-c)/s*2,1]);i.setUniforms({cellScale:g})}}},tt=Dt;(()=>{Dt.layerName="ScreenGridCellLayer"})(),(()=>{Dt.defaultProps=Ii})();var to=M(E(),1);var ot=M(E(),1);function Be(n,t){let e={};for(let o in n)t.includes(o)||(e[o]=n[o]);return e}var oe=class extends ot.CompositeLayer{initializeAggregationLayer(t){super.initializeState(this.context),this.setState({ignoreProps:Be(this.constructor._propTypes,t.data.props),dimensions:t})}updateState(t){super.updateState(t);let{changeFlags:e}=t;if(e.extensionsChanged){let o=this.getShaders({});o&&o.defines&&(o.defines.NON_INSTANCED_MODEL=1),this.updateShaders(o)}this._updateAttributes()}updateAttributes(t){this.setState({changedAttributes:t})}getAttributes(){return this.getAttributeManager().getAttributes()}getModuleSettings(){let{viewport:t,mousePosition:e,device:o}=this.context;return Object.assign(Object.create(this.props),{viewport:t,mousePosition:e,picking:{isActive:0},devicePixelRatio:o.canvasContext.cssToDeviceRatio()})}updateShaders(t){}isAggregationDirty(t,e={}){let{props:o,oldProps:i,changeFlags:r}=t,{compareAll:s=!1,dimension:a}=e,{ignoreProps:l}=this.state,{props:c,accessors:g=[]}=a,{updateTriggersChanged:f}=r;if(r.dataChanged)return!0;if(f){if(f.all)return!0;for(let d of g)if(f[d])return!0}if(s)return r.extensionsChanged?!0:(0,ot._compareProps)({oldProps:i,newProps:o,ignoreProps:l,propTypes:this.constructor._propTypes});for(let d of c)if(o[d]!==i[d])return!0;return!1}isAttributeChanged(t){let{changedAttributes:e}=this.state;return t?e&&e[t]!==void 0:!Ri(e)}_getAttributeManager(){return new ot.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}},P=oe;(()=>{oe.layerName="AggregationLayer"})();function Ri(n){let t=!0;for(let e in n){t=!1;break}return t}var We=M(E(),1);function Lt(n,t,e){let o=e;return o.domain=()=>n,o.range=()=>t,o}function Ue(n,t){return Lt(n,t,o=>ki(n,t,o))}function Bi(n,t){return Lt(n,t,o=>ji(n,t,o))}function Ui(n,t){let e=n.sort(ze),o=0,i=Math.max(1,t.length),r=new Array(i-1);for(;++o<i;)r[o-1]=Wi(e,o/i);let s=a=>Gi(r,t,a);return s.thresholds=()=>r,Lt(n,t,s)}function ze(n,t){return n-t}function Wi(n,t){let e=n.length;if(t<=0||e<2)return n[0];if(t>=1)return n[e-1];let o=(e-1)*t,i=Math.floor(o),r=n[i],s=n[i+1];return r+(s-r)*(o-i)}function zi(n,t){let e=0,o=n.length;for(;e<o;){let i=e+o>>>1;ze(n[i],t)>0?o=i:e=i+1}return e}function Gi(n,t,e){return t[zi(n,e)]}function Hi(n,t,e,o){let i=`${o}`,r=t.get(i);return r===void 0&&(r=n.push(o),t.set(i,r)),e[(r-1)%e.length]}function Vi(n,t){let e=new Map,o=[];for(let r of n){let s=`${r}`;e.has(s)||e.set(s,o.push(r))}return Lt(n,t,r=>Hi(o,e,t,r))}function ki(n,t,e){let o=n[1]-n[0];if(o<=0)return We.log.warn("quantizeScale: invalid domain, returning range[0]")(),t[0];let i=o/t.length,r=Math.floor((e-n[0])/i),s=Math.max(Math.min(r,t.length-1),0);return t[s]}function ji(n,t,e){return(e-n[0])/(n[1]-n[0])*(t[1]-t[0])+t[0]}function Ge(n){return n!=null}function Xi(n){let t=[];return n.forEach(e=>{!t.includes(e)&&Ge(e)&&t.push(e)}),t}function He(n,t){return(typeof t=="function"?n.map(t):n).filter(Ge)}function Ve(n,t){return He(n,t)}function ke(n,t){return Xi(He(n,t))}function je(n,t,e){return Math.max(t,Math.min(e,n))}function Xe(n){switch(n){case"quantize":return Ue;case"linear":return Bi;case"quantile":return Ui;case"ordinal":return Vi;default:return Ue}}var Ye=n=>n.length,qi=3402823466e29,$e=n=>n.points,Ke=n=>n.index,qe=(n,t)=>n<t?-1:n>t?1:n>=t?0:NaN,Yi={getValue:Ye,getPoints:$e,getIndex:Ke,filterData:null},F=class{constructor(t=[],e=Yi){this.aggregatedBins=this.getAggregatedBins(t,e),this._updateMinMaxValues(),this.binMap=this.getBinMap()}getAggregatedBins(t,e){let{getValue:o=Ye,getPoints:i=$e,getIndex:r=Ke,filterData:s}=e,a=typeof s=="function",l=t.length,c=[],g=0;for(let f=0;f<l;f++){let d=t[f],p=i(d),x=r(d),h=a?p.filter(s):p;d.filteredPoints=a?h:null;let A=h.length?o(h):null;A!=null&&(c[g]={i:Number.isFinite(x)?x:f,value:A,counts:h.length},g++)}return c}_percentileToIndex(t){let e=this.sortedBins.length;if(e<2)return[0,0];let[o,i]=t.map(a=>je(a,0,100)),r=Math.ceil(o/100*(e-1)),s=Math.floor(i/100*(e-1));return[r,s]}getBinMap(){let t={};for(let e of this.aggregatedBins)t[e.i]=e;return t}_updateMinMaxValues(){let t=0,e=0,o=qi,i=0;for(let r of this.aggregatedBins)t=t>r.counts?t:r.counts,e=e>r.value?e:r.value,o=o<r.value?o:r.value,i+=r.counts;this.maxCount=t,this.maxValue=e,this.minValue=o,this.totalCount=i}getValueRange(t){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort((i,r)=>qe(i.value,r.value))),!this.sortedBins.length)return[];let e=0,o=this.sortedBins.length-1;if(Array.isArray(t)){let i=this._percentileToIndex(t);e=i[0],o=i[1]}return[this.sortedBins[e].value,this.sortedBins[o].value]}getValueDomainByScale(t,[e=0,o=100]=[]){if(this.sortedBins||(this.sortedBins=this.aggregatedBins.sort((r,s)=>qe(r.value,s.value))),!this.sortedBins.length)return[];let i=this._percentileToIndex([e,o]);return this._getScaleDomain(t,i)}_getScaleDomain(t,[e,o]){let i=this.sortedBins;switch(t){case"quantize":case"linear":return[i[e].value,i[o].value];case"quantile":return Ve(i.slice(e,o+1),r=>r.value);case"ordinal":return ke(i,r=>r.value);default:return[i[e].value,i[o].value]}}};var Je=M(E(),1);var G=M(E(),1),Ze=6378e3;function Ft(n){return Number.isFinite(n)?n:0}function wt(n,t){let e=n.positions.value,o=1/0,i=-1/0,r=1/0,s=-1/0,a,l;for(let g=0;g<t;g++)l=e[g*3],a=e[g*3+1],o=a<o?a:o,i=a>i?a:i,r=l<r?l:r,s=l>s?l:s;return{xMin:Ft(r),xMax:Ft(s),yMin:Ft(o),yMax:Ft(i)}}function $i(n,t,e,o){let{width:i,height:r}=o,s=e===G.COORDINATE_SYSTEM.CARTESIAN?[-i/2,-r/2]:[-180,-90];G.log.assert(e===G.COORDINATE_SYSTEM.CARTESIAN||e===G.COORDINATE_SYSTEM.LNGLAT||e===G.COORDINATE_SYSTEM.DEFAULT);let{xMin:a,yMin:l}=n;return[-1*(Qe(a-s[0],t.xOffset)+s[0]),-1*(Qe(l-s[1],t.yOffset)+s[1])]}function Qe(n,t){let e=n<0?-1:1,o=e<0?Math.abs(n)+t:Math.abs(n);return o=Math.floor(o/t)*t,o*e}function ie(n,t,e=!0){if(!e)return{xOffset:t,yOffset:t};let{yMin:o,yMax:i}=n,r=(o+i)/2;return Ki(t,r)}function It(n,t,e,o){let i=ie(n,t,o!==G.COORDINATE_SYSTEM.CARTESIAN),r=$i(n,i,o,e),{xMin:s,yMin:a,xMax:l,yMax:c}=n,g=l-s+i.xOffset,f=c-a+i.yOffset,d=Math.ceil(g/i.xOffset),p=Math.ceil(f/i.yOffset);return{gridOffset:i,translation:r,width:g,height:f,numCol:d,numRow:p}}function Ki(n,t){let e=Qi(n),o=Zi(t,n);return{yOffset:e,xOffset:o}}function Qi(n){return n/Ze*(180/Math.PI)}function Zi(n,t){return t/Ze*(180/Math.PI)/Math.cos(n*Math.PI/180)}function it(n,t){let e=Ji(n,t),o=tr(e);return{gridHash:e.gridHash,gridOffset:e.gridOffset,data:o}}function Ji(n,t){let{data:e=[],cellSize:o}=n,{attributes:i,viewport:r,projectPoints:s,numInstances:a}=t,l=i.positions.value,{size:c}=i.positions.getAccessor(),g=t.boundingBox||er(i.positions,a),f=t.posOffset||[180,90],d=t.gridOffset||ie(g,o);if(d.xOffset<=0||d.yOffset<=0)return{gridHash:{},gridOffset:d,offsets:[0,0]};let{width:p,height:x}=r,h=Math.ceil(p/d.xOffset),A=Math.ceil(x/d.yOffset),S={},{iterable:y,objectInfo:_}=(0,Je.createIterable)(e),b=new Array(3);for(let O of y){_.index++,b[0]=l[_.index*c],b[1]=l[_.index*c+1],b[2]=c>=3?l[_.index*c+2]:0;let[B,mt]=s?r.project(b):b;if(Number.isFinite(B)&&Number.isFinite(mt)){let k=Math.floor((mt+f[1])/d.yOffset),j=Math.floor((B+f[0])/d.xOffset);if(!s||j>=0&&j<h&&k>=0&&k<A){let X=`${k}-${j}`;S[X]=S[X]||{count:0,points:[],lonIdx:j,latIdx:k},S[X].count+=1,S[X].points.push({source:O,index:_.index})}}}return{gridHash:S,gridOffset:d,offsets:[f[0]*-1,f[1]*-1]}}function tr({gridHash:n,gridOffset:t,offsets:e}){let o=new Array(Object.keys(n).length),i=0;for(let r in n){let s=r.split("-"),a=parseInt(s[0],10),l=parseInt(s[1],10),c=i++;o[c]={index:c,position:[e[0]+t.xOffset*l,e[1]+t.yOffset*a],...n[r]}}return o}function er(n,t){let e=n.value,{size:o}=n.getAccessor(),i=1/0,r=-1/0,s=1/0,a=-1/0,l,c;for(let g=0;g<t;g++)c=e[g*o],l=e[g*o+1],Number.isFinite(c)&&Number.isFinite(l)&&(i=l<i?l:i,r=l>r?l:r,s=c<s?c:s,a=c>a?c:a);return{xMin:s,xMax:a,yMin:i,yMax:r}}var re=class extends P{initializeAggregationLayer({dimensions:t}){super.initializeAggregationLayer(t),this.setState({layerData:{},gpuGridAggregator:new C(this.context.device,{id:`${this.id}-gpu-aggregator`}),cpuGridAggregator:it})}updateState(t){super.updateState(t),this.updateAggregationState(t);let{aggregationDataDirty:e,aggregationWeightsDirty:o,gpuAggregation:i}=this.state;if(this.getNumInstances()<=0)return;let r=!1;(e||i&&o)&&(this._updateAggregation(t),r=!0),!i&&(e||o)&&(this._updateWeightBins(),this._uploadAggregationResults(),r=!0),this.setState({aggregationDirty:r})}finalizeState(t){let{count:e}=this.state.weights;e&&e.aggregationBuffer&&e.aggregationBuffer.delete(),this.state.gpuGridAggregator?.delete(),super.finalizeState(t)}updateShaders(t){this.state.gpuAggregation&&this.state.gpuGridAggregator.updateShaders(t)}updateAggregationState(t){to.log.assert(!1)}allocateResources(t,e){if(this.state.numRow!==t||this.state.numCol!==e){let o=e*t*4*4,{weights:i}=this.state;for(let r in i){let s=i[r];s.aggregationBuffer&&s.aggregationBuffer.delete(),s.aggregationBuffer=this.context.device.createBuffer({byteLength:o,accessor:{size:4,type:5126,divisor:1}})}}}updateResults({aggregationData:t,maxMinData:e,maxData:o,minData:i}){let{count:r}=this.state.weights;r&&(r.aggregationData=t,r.maxMinData=e,r.maxData=o,r.minData=i)}_updateAggregation(t){let{cpuGridAggregator:e,gpuGridAggregator:o,gridOffset:i,posOffset:r,translation:s=[0,0],scaling:a=[0,0,0],boundingBox:l,projectPoints:c,gpuAggregation:g,numCol:f,numRow:d}=this.state,{props:p}=t,{viewport:x}=this.context,h=this.getAttributes(),A=this.getNumInstances();if(g){let{weights:S}=this.state;o.run({weights:S,cellSize:[i.xOffset,i.yOffset],numCol:f,numRow:d,translation:s,scaling:a,vertexCount:A,projectPoints:c,attributes:h,moduleSettings:this.getModuleSettings()})}else{let S=e(p,{gridOffset:i,projectPoints:c,attributes:h,viewport:x,posOffset:r,boundingBox:l});this.setState({layerData:S})}}_updateWeightBins(){let{getValue:t}=this.state,e=new F(this.state.layerData.data||[],{getValue:t});this.setState({sortedBins:e})}_uploadAggregationResults(){let{numCol:t,numRow:e}=this.state,{data:o}=this.state.layerData,{aggregatedBins:i,minValue:r,maxValue:s,totalCount:a}=this.state.sortedBins,l=4,c=t*e*l,g=new Float32Array(c).fill(0);for(let x of i){let{lonIdx:h,latIdx:A}=o[x.i],{value:S,counts:y}=x,_=(h+A*t)*l;g[_]=S,g[_+l-1]=y}let f=new Float32Array([s,0,0,r]),d=new Float32Array([s,0,0,a]),p=new Float32Array([r,0,0,a]);this.updateResults({aggregationData:g,maxMinData:f,maxData:d,minData:p})}},w=re;(()=>{re.layerName="GridAggregationLayer"})();var or={...tt.defaultProps,getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM"},eo="positions",ir={data:{props:["cellSizePixels"]},weights:{props:["aggregation"],accessors:["getWeight"]}},Rt=class extends w{initializeState(){super.initializeAggregationLayer({dimensions:ir,getCellSize:o=>o.cellSizePixels});let t={count:{size:1,operation:T.SUM,needMax:!0,maxTexture:Z(this.context.device,{id:`${this.id}-max-texture`})}};this.setState({supported:!0,projectPoints:!0,weights:t,subLayerData:{attributes:{}},maxTexture:t.count.maxTexture,positionAttributeName:"positions",posOffset:[0,0],translation:[1,-1]}),this.getAttributeManager().add({[eo]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}shouldUpdateState({changeFlags:t}){return this.state.supported&&t.somethingChanged}updateState(t){super.updateState(t)}renderLayers(){if(!this.state.supported)return[];let{maxTexture:t,numRow:e,numCol:o,weights:i}=this.state,{updateTriggers:r}=this.props,{aggregationBuffer:s}=i.count,a=this.getSubLayerClass("cells",tt);return new a(this.props,this.getSubLayerProps({id:"cell-layer",updateTriggers:r}),{data:{attributes:{instanceCounts:s}},maxTexture:t,numInstances:e*o})}finalizeState(t){super.finalizeState(t);let{aggregationBuffer:e,maxBuffer:o,maxTexture:i}=this.state;e?.delete(),o?.delete(),i?.delete()}getPickingInfo({info:t}){let{index:e}=t;if(e>=0){let{gpuGridAggregator:o,gpuAggregation:i,weights:r}=this.state,s=i?o.getData("count"):r.count;t.object=C.getAggregationData({pixelIndex:e,...s})}return t}updateResults({aggregationData:t,maxData:e}){let{count:o}=this.state.weights;o.aggregationData=t,o.aggregationBuffer.write(t),o.maxData=e,o.maxTexture.setImageData({data:e})}updateAggregationState(t){let e=t.props.cellSizePixels,o=t.oldProps.cellSizePixels!==e,{viewportChanged:i}=t.changeFlags,r=t.props.gpuAggregation;this.state.gpuAggregation!==t.props.gpuAggregation&&r&&!C.isSupported(this.context.device)&&(oo.log.warn("GPU Grid Aggregation not supported, falling back to CPU")(),r=!1);let s=r!==this.state.gpuAggregation;this.setState({gpuAggregation:r});let a=this.isAttributeChanged(eo),{dimensions:l}=this.state,{data:c,weights:g}=l,f=a||s||i||this.isAggregationDirty(t,{compareAll:r,dimension:c}),d=this.isAggregationDirty(t,{dimension:g});this.setState({aggregationDataDirty:f,aggregationWeightsDirty:d});let{viewport:p}=this.context;if(i||o){let{width:x,height:h}=p,A=Math.ceil(x/e),S=Math.ceil(h/e);this.allocateResources(S,A),this.setState({scaling:[x/2,-h/2,1],gridOffset:{xOffset:e,yOffset:e},width:x,height:h,numCol:A,numRow:S})}d&&this._updateAccessors(t),(f||d)&&this._resetResults()}_updateAccessors(t){let{getWeight:e,aggregation:o,data:i}=t.props,{count:r}=this.state.weights;r&&(r.getWeight=e,r.operation=T[o]),this.setState({getValue:Q(o,e,{data:i})})}_resetResults(){let{count:t}=this.state.weights;t&&(t.aggregationData=null)}},St=Rt;(()=>{Rt.layerName="ScreenGridLayer"})(),(()=>{Rt.defaultProps=or})();var ao=M($(),1);function io(){}var ro=["getBins","getDomain","getScaleFunc"],no=[{key:"fillColor",accessor:"getFillColor",pickingInfo:"colorValue",getBins:{triggers:{value:{prop:"getColorValue",updateTrigger:"getColorValue"},weight:{prop:"getColorWeight",updateTrigger:"getColorWeight"},aggregation:{prop:"colorAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"lowerPercentile"},upperPercentile:{prop:"upperPercentile"},scaleType:{prop:"colorScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"colorDomain"},range:{prop:"colorRange"}},onSet:{props:"onSetColorDomain"}},nullValue:[0,0,0,0]},{key:"elevation",accessor:"getElevation",pickingInfo:"elevationValue",getBins:{triggers:{value:{prop:"getElevationValue",updateTrigger:"getElevationValue"},weight:{prop:"getElevationWeight",updateTrigger:"getElevationWeight"},aggregation:{prop:"elevationAggregation"},filterData:{prop:"_filterData",updateTrigger:"_filterData"}}},getDomain:{triggers:{lowerPercentile:{prop:"elevationLowerPercentile"},upperPercentile:{prop:"elevationUpperPercentile"},scaleType:{prop:"elevationScaleType"}}},getScaleFunc:{triggers:{domain:{prop:"elevationDomain"},range:{prop:"elevationRange"}},onSet:{props:"onSetElevationDomain"}},nullValue:-1}],rr=n=>n.cellSize,I=class{constructor(t){this.state={layerData:{data:void 0},dimensions:{}},this.changeFlags={},this.dimensionUpdaters={},this._getCellSize=t.getCellSize||rr,this._getAggregator=t.getAggregator,this._addDimension(t.dimensions||no)}static defaultDimensions(){return no}updateState(t,e){let{oldProps:o,props:i,changeFlags:r}=t;this.updateGetValueFuncs(o,i,r);let s=this.needsReProjectPoints(o,i,r),a=!1;return r.dataChanged||s?(this.getAggregatedData(i,e),a=!0):((this.getDimensionChanges(o,i,r)||[]).forEach(c=>typeof c=="function"&&c()),a=!0),this.setState({aggregationDirty:a}),this.state}setState(t){this.state={...this.state,...t}}setDimensionState(t,e){this.setState({dimensions:{...this.state.dimensions,[t]:{...this.state.dimensions[t],...e}}})}normalizeResult(t={}){return t.hexagons?{data:t.hexagons,...t}:t.layerData?{data:t.layerData,...t}:t}getAggregatedData(t,e){let i=this._getAggregator(t)(t,e);this.setState({layerData:this.normalizeResult(i)}),this.changeFlags={layerData:!0},this.getSortedBins(t)}updateGetValueFuncs(t,e,o){for(let i in this.dimensionUpdaters){let{value:r,weight:s,aggregation:a}=this.dimensionUpdaters[i].getBins.triggers,l=e[r.prop];this.needUpdateDimensionStep(this.dimensionUpdaters[i].getBins,t,e,o)&&(l?l=Me(l,{data:e.data}):l=Q(e[a.prop],e[s.prop],{data:e.data})),l&&this.setDimensionState(i,{getValue:l})}}needsReProjectPoints(t,e,o){return this._getCellSize(t)!==this._getCellSize(e)||this._getAggregator(t)!==this._getAggregator(e)||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPosition)}addDimension(t){this._addDimension(t)}_addDimension(t=[]){t.forEach(e=>{let{key:o}=e;this.dimensionUpdaters[o]=this.getDimensionUpdaters(e),this.state.dimensions[o]={getValue:null,domain:null,sortedBins:null,scaleFunc:io}})}getDimensionUpdaters({key:t,accessor:e,pickingInfo:o,getBins:i,getDomain:r,getScaleFunc:s,nullValue:a}){return{key:t,accessor:e,pickingInfo:o,getBins:{updater:this.getDimensionSortedBins.bind(this),...i},getDomain:{updater:this.getDimensionValueDomain.bind(this),...r},getScaleFunc:{updater:this.getDimensionScale.bind(this),...s},attributeAccessor:this.getSubLayerDimensionAttribute(t,a)}}needUpdateDimensionStep(t,e,o,i){return Object.values(t.triggers).some(r=>r.updateTrigger?i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged[r.updateTrigger]):e[r.prop]!==o[r.prop])}getDimensionChanges(t,e,o){let i=[];for(let r in this.dimensionUpdaters){let s=ro.find(a=>this.needUpdateDimensionStep(this.dimensionUpdaters[r][a],t,e,o));s&&i.push(this.dimensionUpdaters[r][s].updater.bind(this,e,this.dimensionUpdaters[r]))}return i.length?i:null}getUpdateTriggers(t){let e=t.updateTriggers||{},o={};for(let i in this.dimensionUpdaters){let{accessor:r}=this.dimensionUpdaters[i];o[r]={},ro.forEach(s=>{Object.values(this.dimensionUpdaters[i][s].triggers).forEach(({prop:a,updateTrigger:l})=>{if(l){let c=e[l];typeof c=="object"&&!Array.isArray(c)?Object.assign(o[r],c):c!==void 0&&(o[r][a]=c)}else o[r][a]=t[a]})})}return o}getSortedBins(t){for(let e in this.dimensionUpdaters)this.getDimensionSortedBins(t,this.dimensionUpdaters[e])}getDimensionSortedBins(t,e){let{key:o}=e,{getValue:i}=this.state.dimensions[o],r=new F(this.state.layerData.data||[],{getValue:i,filterData:t._filterData});this.setDimensionState(o,{sortedBins:r}),this.getDimensionValueDomain(t,e)}getDimensionValueDomain(t,e){let{getDomain:o,key:i}=e,{triggers:{lowerPercentile:r,upperPercentile:s,scaleType:a}}=o,l=this.state.dimensions[i].sortedBins.getValueDomainByScale(t[a.prop],[t[r.prop],t[s.prop]]);this.setDimensionState(i,{valueDomain:l}),this.getDimensionScale(t,e)}getDimensionScale(t,e){let{key:o,getScaleFunc:i,getDomain:r}=e,{domain:s,range:a}=i.triggers,{scaleType:l}=r.triggers,{onSet:c}=i,g=t[a.prop],f=t[s.prop]||this.state.dimensions[o].valueDomain,p=Xe(l&&t[l.prop])(f,g);typeof c=="object"&&typeof t[c.props]=="function"&&t[c.props](p.domain()),this.setDimensionState(o,{scaleFunc:p})}getSubLayerDimensionAttribute(t,e){return o=>{let{sortedBins:i,scaleFunc:r}=this.state.dimensions[t],s=i.binMap[o.index];if(s&&s.counts===0)return e;let a=s&&s.value,l=r.domain();return a>=l[0]&&a<=l[l.length-1]?r(a):e}}getSubLayerAccessors(t){let e={};for(let o in this.dimensionUpdaters){let{accessor:i}=this.dimensionUpdaters[o];e[i]=this.getSubLayerDimensionAttribute(t,o)}return e}getPickingInfo({info:t}){let e=t.picked&&t.index>-1,o=null;if(e){let i=this.state.layerData.data[t.index],r={};for(let s in this.dimensionUpdaters){let{pickingInfo:a}=this.dimensionUpdaters[s],{sortedBins:l}=this.state.dimensions[s],c=l.binMap[i.index]&&l.binMap[i.index].value;r[a]=c}o=Object.assign(r,i,{points:i.filteredPoints||i.points})}return t.picked=Boolean(o),t.object=o,t}getAccessor(t){return this.dimensionUpdaters.hasOwnProperty(t)?this.dimensionUpdaters[t].attributeAccessor:io}};function so(){}var nr={colorDomain:null,colorRange:D,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:so,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:so,gridAggregator:it,cellSize:{type:"number",min:0,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},extruded:!1,material:!0,_filterData:{type:"function",value:null,optional:!0}},Bt=class extends P{initializeState(){let t=new I({getAggregator:o=>o.gridAggregator,getCellSize:o=>o.cellSize});this.state={cpuAggregator:t,aggregatorState:t.state},this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(t){super.updateState(t),this.setState({aggregatorState:this.state.cpuAggregator.updateState(t,{viewport:this.context.viewport,attributes:this.getAttributes(),numInstances:this.getNumInstances()})})}getPickingInfo({info:t}){return this.state.cpuAggregator.getPickingInfo({info:t})}_onGetSublayerColor(t){return this.state.cpuAggregator.getAccessor("fillColor")(t)}_onGetSublayerElevation(t){return this.state.cpuAggregator.getAccessor("elevation")(t)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){let{elevationScale:t,extruded:e,cellSize:o,coverage:i,material:r,transitions:s}=this.props,{cpuAggregator:a}=this.state,l=this.getSubLayerClass("grid-cell",ao.GridCellLayer),c=this._getSublayerUpdateTriggers();return new l({cellSize:o,coverage:i,material:r,elevationScale:t,extruded:e,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:s&&{getFillColor:s.getColorValue||s.getColorWeight,getElevation:s.getElevationValue||s.getElevationWeight}},this.getSubLayerProps({id:"grid-cell",updateTriggers:c}),{data:a.state.layerData.data})}},H=Bt;(()=>{Bt.layerName="CPUGridLayer"})(),(()=>{Bt.defaultProps=nr})();var uo=M(E(),1),go=M($(),1);var rt=Math.PI/3,sr=[0,rt,2*rt,3*rt,4*rt,5*rt];function ar(n){return n[0]}function lr(n){return n[1]}function ne(){var n=0,t=0,e=1,o=1,i=ar,r=lr,s,a,l;function c(f){var d={},p=[],x,h=f.length;for(x=0;x<h;++x)if(!(isNaN(S=+i.call(null,A=f[x],x,f))||isNaN(y=+r.call(null,A,x,f)))){var A,S,y,_=Math.round(y=y/l),b=Math.round(S=S/a-(_&1)/2),O=y-_;if(Math.abs(O)*3>1){var B=S-b,mt=b+(S<b?-1:1)/2,k=_+(y<_?-1:1),j=S-mt,X=y-k;B*B+O*O>j*j+X*X&&(b=mt+(_&1?1:-1)/2,_=k)}var me=b+"-"+_,ht=d[me];ht?ht.push(A):(p.push(ht=d[me]=[A]),ht.x=(b+(_&1)/2)*a,ht.y=_*l)}return p}function g(f){var d=0,p=0;return sr.map(function(x){var h=Math.sin(x)*f,A=-Math.cos(x)*f,S=h-d,y=A-p;return d=h,p=A,[S,y]})}return c.hexagon=function(f){return"m"+g(f==null?s:+f).join("l")+"z"},c.centers=function(){for(var f=[],d=Math.round(t/l),p=Math.round(n/a),x=d*l;x<o+s;x+=l,++d)for(var h=p*a+(d&1)*a/2;h<e+a/2;h+=a)f.push([h,x]);return f},c.mesh=function(){var f=g(s).slice(0,4).join("l");return c.centers().map(function(d){return"M"+d+"m"+f}).join("")},c.x=function(f){return arguments.length?(i=f,c):i},c.y=function(f){return arguments.length?(r=f,c):r},c.radius=function(f){return arguments.length?(s=+f,a=s*2*Math.sin(rt),l=s*1.5,c):s},c.size=function(f){return arguments.length?(n=t=0,e=+f[0],o=+f[1],c):[e-n,o-t]},c.extent=function(f){return arguments.length?(n=+f[0][0],t=+f[0][1],e=+f[1][0],o=+f[1][1],c):[[n,t],[e,o]]},c.radius(1)}var Ut=M(E(),1);function lo(n,t){let{data:e,radius:o}=n,{viewport:i,attributes:r}=t,s=e.length?cr(e,t):null,a=ur(o,i,s),l=[],{iterable:c,objectInfo:g}=(0,Ut.createIterable)(e),f=r.positions.value,{size:d}=r.positions.getAccessor();for(let h of c){g.index++;let A=g.index*d,S=[f[A],f[A+1]];Number.isFinite(S[0])&&Number.isFinite(S[1])?l.push({screenCoord:i.projectFlat(S),source:h,index:g.index}):Ut.log.warn("HexagonLayer: invalid position")()}return{hexagons:ne().radius(a).x(h=>h.screenCoord[0]).y(h=>h.screenCoord[1])(l).map((h,A)=>({position:i.unprojectFlat([h.x,h.y]),points:h,index:A})),radiusCommon:a}}function cr(n,t){let{attributes:e}=t,o=e.positions.value,{size:i}=e.positions.getAccessor(),r=1/0,s=1/0,a=-1/0,l=-1/0,c;for(c=0;c<i*n.length;c+=i){let g=o[c],f=o[c+1];Number.isFinite(g)&&Number.isFinite(f)&&(r=Math.min(g,r),a=Math.max(g,a),s=Math.min(f,s),l=Math.max(f,l))}return[r,s,a,l].every(Number.isFinite)?[(r+a)/2,(s+l)/2]:null}function ur(n,t,e){let{unitsPerMeter:o}=t.getDistanceScales(e);return n*o[0]}function co(){}var gr={colorDomain:null,colorRange:D,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",value:0,min:0,max:100},upperPercentile:{type:"number",value:100,min:0,max:100},colorScaleType:"quantize",onSetColorDomain:co,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationLowerPercentile:{type:"number",value:0,min:0,max:100},elevationUpperPercentile:{type:"number",value:100,min:0,max:100},elevationScale:{type:"number",min:0,value:1},elevationScaleType:"linear",onSetElevationDomain:co,radius:{type:"number",value:1e3,min:1},coverage:{type:"number",min:0,max:1,value:1},extruded:!1,hexagonAggregator:lo,getPosition:{type:"accessor",value:n=>n.position},material:!0,_filterData:{type:"function",value:null,optional:!0}},Wt=class extends P{initializeState(){let t=new I({getAggregator:o=>o.hexagonAggregator,getCellSize:o=>o.radius});this.state={cpuAggregator:t,aggregatorState:t.state,vertices:null},this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"}})}updateState(t){if(super.updateState(t),t.changeFlags.propsOrDataChanged){let e=this.state.cpuAggregator.updateState(t,{viewport:this.context.viewport,attributes:this.getAttributes()});if(this.state.aggregatorState.layerData!==e.layerData){let{hexagonVertices:o}=e.layerData||{};this.setState({vertices:o&&this.convertLatLngToMeterOffset(o)})}this.setState({aggregatorState:e})}}convertLatLngToMeterOffset(t){let{viewport:e}=this.context;if(Array.isArray(t)&&t.length===6){let o=t[0],i=t[3],r=[(o[0]+i[0])/2,(o[1]+i[1])/2],s=e.projectFlat(r),{metersPerUnit:a}=e.getDistanceScales(r);return t.map(c=>{let g=e.projectFlat(c);return[(g[0]-s[0])*a[0],(g[1]-s[1])*a[1]]})}return uo.log.error("HexagonLayer: hexagonVertices needs to be an array of 6 points")(),null}getPickingInfo({info:t}){return this.state.cpuAggregator.getPickingInfo({info:t})}_onGetSublayerColor(t){return this.state.cpuAggregator.getAccessor("fillColor")(t)}_onGetSublayerElevation(t){return this.state.cpuAggregator.getAccessor("elevation")(t)}_getSublayerUpdateTriggers(){return this.state.cpuAggregator.getUpdateTriggers(this.props)}renderLayers(){let{elevationScale:t,extruded:e,coverage:o,material:i,transitions:r}=this.props,{aggregatorState:s,vertices:a}=this.state,l=this.getSubLayerClass("hexagon-cell",go.ColumnLayer),c=this._getSublayerUpdateTriggers(),g=a?{vertices:a,radius:1}:{radius:s.layerData.radiusCommon||1,radiusUnits:"common",angle:90};return new l({...g,diskResolution:6,elevationScale:t,extruded:e,coverage:o,material:i,getFillColor:this._onGetSublayerColor.bind(this),getElevation:this._onGetSublayerElevation.bind(this),transitions:r&&{getFillColor:r.getColorValue||r.getColorWeight,getElevation:r.getElevationValue||r.getElevationWeight}},this.getSubLayerProps({id:"hexagon-cell",updateTriggers:c}),{data:s.layerData.data})}},At=Wt;(()=>{Wt.layerName="HexagonLayer"})(),(()=>{Wt.defaultProps=gr})();var jt=M($(),1);var Uo=M(E(),1);var v=.16666666666666666,u={N:[0,.5],E:[.5,0],S:[0,-.5],W:[-.5,0],NE:[.5,.5],NW:[-.5,.5],SE:[.5,-.5],SW:[-.5,-.5]},nt=[u.W,u.SW,u.S],st=[u.S,u.SE,u.E],at=[u.E,u.NE,u.N],lt=[u.NW,u.W,u.N],ct=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5]],ut=[[-v,-.5],[v,-.5],[.5,-v],[.5,v]],gt=[[.5,-v],[.5,v],[v,.5],[-v,.5]],ft=[[-.5,v],[-.5,-v],[v,.5],[-v,.5]],fo=[u.W,u.SW,u.SE,u.E],po=[u.S,u.SE,u.NE,u.N],mo=[u.NW,u.W,u.E,u.NE],ho=[u.NW,u.SW,u.S,u.N],xo=[[-.5,v],[-.5,-v],[.5,-v],[.5,v]],vo=[[-v,-.5],[v,-.5],[v,.5],[-v,.5]],fr=[u.NW,u.SW,u.SE,u.NE],So=[u.NW,u.SW,u.SE,u.E,u.N],Ao=[u.W,u.SW,u.SE,u.NE,u.N],yo=[u.NW,u.W,u.S,u.SE,u.NE],_o=[u.NW,u.SW,u.S,u.E,u.NE],bo=[u.NW,u.W,[.5,-v],[.5,v],u.N],Mo=[[-v,-.5],[v,-.5],u.E,u.NE,u.N],To=[[-.5,v],[-.5,-v],u.S,u.SE,u.E],Co=[u.W,u.SW,u.S,[v,.5],[-v,.5]],Eo=[u.NW,u.W,[-v,-.5],[v,-.5],u.N],Po=[[-.5,v],[-.5,-v],u.E,u.NE,u.N],No=[u.S,u.SE,u.E,[v,.5],[-v,.5]],Do=[u.W,u.SW,u.S,[.5,-v],[.5,v]],Oo=[u.W,u.SW,u.SE,u.E,[v,.5],[-v,.5]],Lo=[[-.5,v],[-.5,-v],u.S,u.SE,u.NE,u.N],Fo=[u.NW,u.W,[-v,-.5],[v,-.5],u.E,u.NE],wo=[u.NW,u.SW,u.S,[.5,-v],[.5,v],u.N],dt=[u.W,u.SW,u.S,u.E,u.NE,u.N],pt=[u.NW,u.W,u.S,u.SE,u.E,u.N],zt=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5],u.E,u.NE,u.N],Gt=[u.W,u.SW,u.S,[.5,-v],[.5,v],[v,.5],[-v,.5]],Ht=[u.NW,u.W,[-v,-.5],[v,-.5],[.5,-v],[.5,v],u.N],Vt=[[-.5,v],[-.5,-v],u.S,u.SE,u.E,[v,.5],[-v,.5]],Io=[[-.5,v],[-.5,-v],[-v,-.5],[v,-.5],[.5,-v],[.5,v],[v,.5],[-v,.5]],Ro={0:[],1:[[u.W,u.S]],2:[[u.S,u.E]],3:[[u.W,u.E]],4:[[u.N,u.E]],5:{0:[[u.W,u.S],[u.N,u.E]],1:[[u.W,u.N],[u.S,u.E]]},6:[[u.N,u.S]],7:[[u.W,u.N]],8:[[u.W,u.N]],9:[[u.N,u.S]],10:{0:[[u.W,u.N],[u.S,u.E]],1:[[u.W,u.S],[u.N,u.E]]},11:[[u.N,u.E]],12:[[u.W,u.E]],13:[[u.S,u.E]],14:[[u.W,u.S]],15:[]};function m(n){return parseInt(n,4)}var Bo={[m("0000")]:[],[m("2222")]:[],[m("2221")]:[nt],[m("2212")]:[st],[m("2122")]:[at],[m("1222")]:[lt],[m("0001")]:[nt],[m("0010")]:[st],[m("0100")]:[at],[m("1000")]:[lt],[m("2220")]:[ct],[m("2202")]:[ut],[m("2022")]:[gt],[m("0222")]:[ft],[m("0002")]:[ct],[m("0020")]:[ut],[m("0200")]:[gt],[m("2000")]:[ft],[m("0011")]:[fo],[m("0110")]:[po],[m("1100")]:[mo],[m("1001")]:[ho],[m("2211")]:[fo],[m("2112")]:[po],[m("1122")]:[mo],[m("1221")]:[ho],[m("2200")]:[xo],[m("2002")]:[vo],[m("0022")]:[xo],[m("0220")]:[vo],[m("1111")]:[fr],[m("1211")]:[So],[m("2111")]:[Ao],[m("1112")]:[yo],[m("1121")]:[_o],[m("1011")]:[So],[m("0111")]:[Ao],[m("1110")]:[yo],[m("1101")]:[_o],[m("1200")]:[bo],[m("0120")]:[Mo],[m("0012")]:[To],[m("2001")]:[Co],[m("1022")]:[bo],[m("2102")]:[Mo],[m("2210")]:[To],[m("0221")]:[Co],[m("1002")]:[Eo],[m("2100")]:[Po],[m("0210")]:[No],[m("0021")]:[Do],[m("1220")]:[Eo],[m("0122")]:[Po],[m("2012")]:[No],[m("2201")]:[Do],[m("0211")]:[Oo],[m("2110")]:[Lo],[m("1102")]:[Fo],[m("1021")]:[wo],[m("2011")]:[Oo],[m("0112")]:[Lo],[m("1120")]:[Fo],[m("1201")]:[wo],[m("2101")]:[dt],[m("0121")]:[dt],[m("1012")]:[pt],[m("1210")]:[pt],[m("0101")]:{0:[nt,at],1:[dt],2:[dt]},[m("1010")]:{0:[lt,st],1:[pt],2:[pt]},[m("2121")]:{0:[dt],1:[dt],2:[nt,at]},[m("1212")]:{0:[pt],1:[pt],2:[lt,st]},[m("2120")]:{0:[zt],1:[zt],2:[ct,at]},[m("2021")]:{0:[Gt],1:[Gt],2:[nt,gt]},[m("1202")]:{0:[Ht],1:[Ht],2:[lt,ut]},[m("0212")]:{0:[Vt],1:[Vt],2:[st,ft]},[m("0102")]:{0:[ct,at],1:[zt],2:[zt]},[m("0201")]:{0:[nt,gt],1:[Gt],2:[Gt]},[m("1020")]:{0:[lt,ut],1:[Ht],2:[Ht]},[m("2010")]:{0:[st,ft],1:[Vt],2:[Vt]},[m("2020")]:{0:[ft,ut],1:[Io],2:[ct,gt]},[m("0202")]:{0:[gt,ct],1:[Io],2:[ft,ut]}};var Y={ISO_LINES:1,ISO_BANDS:2},dr={zIndex:0,zOffset:.005};function yt(n,t){return Array.isArray(t)?n<t[0]?0:n<t[1]?1:2:n>=t?1:0}function Wo(n){let{cellWeights:t,x:e,y:o,width:i,height:r}=n,s=n.threshold;n.thresholdValue&&(Uo.log.deprecated("thresholdValue","threshold")(),s=n.thresholdValue);let a=e<0,l=e>=i-1,c=o<0,g=o>=r-1,f=a||l||c||g,d={},p={};a||g?p.top=0:(d.top=t[(o+1)*i+e],p.top=yt(d.top,s)),l||g?p.topRight=0:(d.topRight=t[(o+1)*i+e+1],p.topRight=yt(d.topRight,s)),l||c?p.right=0:(d.right=t[o*i+e+1],p.right=yt(d.right,s)),a||c?p.current=0:(d.current=t[o*i+e],p.current=yt(d.current,s));let{top:x,topRight:h,right:A,current:S}=p,y=-1;Number.isFinite(s)&&(y=x<<3|h<<2|A<<1|S),Array.isArray(s)&&(y=x<<6|h<<4|A<<2|S);let _=0;return f||(_=yt((d.top+d.topRight+d.right+d.current)/4,s)),{code:y,meanCode:_}}function se(n){let{gridOrigin:t,cellSize:e,x:o,y:i,code:r,meanCode:s,type:a=Y.ISO_LINES}=n,l={...dr,...n.thresholdData},c=a===Y.ISO_BANDS?Bo[r]:Ro[r];Array.isArray(c)||(c=c[s]);let g=l.zIndex*l.zOffset,f=(o+1)*e[0],d=(i+1)*e[1],p=t[0]+f,x=t[1]+d;if(a===Y.ISO_BANDS){let A=[];return c.forEach(S=>{let y=[];S.forEach(_=>{let b=p+_[0]*e[0],O=x+_[1]*e[1];y.push([b,O,g])}),A.push(y)}),A}let h=[];return c.forEach(A=>{A.forEach(S=>{let y=p+S[0]*e[0],_=x+S[1]*e[1];h.push([y,_,g])})}),h}function zo({thresholdData:n,cellWeights:t,gridSize:e,gridOrigin:o,cellSize:i}){let r=[],s=[],a=e[0],l=e[1],c=0,g=0;for(let f of n){let{contour:d}=f,{threshold:p}=d;for(let x=-1;x<a;x++)for(let h=-1;h<l;h++){let{code:A,meanCode:S}=Wo({cellWeights:t,threshold:p,x,y:h,width:a,height:l}),y={type:Y.ISO_BANDS,gridOrigin:o,cellSize:i,x,y:h,width:a,height:l,code:A,meanCode:S,thresholdData:f};if(Array.isArray(p)){y.type=Y.ISO_BANDS;let _=se(y);for(let b of _)s[g++]={vertices:b,contour:d}}else{y.type=Y.ISO_LINES;let _=se(y);for(let b=0;b<_.length;b+=2)r[c++]={start:_[b],end:_[b+1],contour:d}}}}return{contourSegments:r,contourPolygons:s}}var Vo=M(E(),1);var Go=[255,255,255,255],pr=1,mr=1,hr={cellSize:{type:"number",min:1,max:1e3,value:1e3},getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},gpuAggregation:!1,aggregation:"SUM",contours:{type:"object",value:[{threshold:mr}],optional:!0,compare:3},zOffset:.005},Ho="positions",xr={data:{props:["cellSize"]},weights:{props:["aggregation"],accessors:["getWeight"]}},kt=class extends w{initializeState(){super.initializeAggregationLayer({dimensions:xr}),this.setState({contourData:{},projectPoints:!1,weights:{count:{size:1,operation:T.SUM}}}),this.getAttributeManager().add({[Ho]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},count:{size:3,accessor:"getWeight"}})}updateState(t){super.updateState(t);let e=!1,{oldProps:o,props:i}=t,{aggregationDirty:r}=this.state;(o.contours!==i.contours||o.zOffset!==i.zOffset)&&(e=!0,this._updateThresholdData(t.props)),this.getNumInstances()>0&&(r||e)&&this._generateContours()}renderLayers(){let{contourSegments:t,contourPolygons:e}=this.state.contourData,o=this.getSubLayerClass("lines",jt.LineLayer),i=this.getSubLayerClass("bands",jt.SolidPolygonLayer),r=t&&t.length>0&&new o(this.getSubLayerProps({id:"lines"}),{data:this.state.contourData.contourSegments,getSourcePosition:a=>a.start,getTargetPosition:a=>a.end,getColor:a=>a.contour.color||Go,getWidth:a=>a.contour.strokeWidth||pr}),s=e&&e.length>0&&new i(this.getSubLayerProps({id:"bands"}),{data:this.state.contourData.contourPolygons,getPolygon:a=>a.vertices,getFillColor:a=>a.contour.color||Go});return[r,s]}updateAggregationState(t){let{props:e,oldProps:o}=t,{cellSize:i,coordinateSystem:r}=e,{viewport:s}=this.context,a=o.cellSize!==i,l=e.gpuAggregation;this.state.gpuAggregation!==e.gpuAggregation&&l&&!C.isSupported(this.context.device)&&(Vo.log.warn("GPU Grid Aggregation not supported, falling back to CPU")(),l=!1);let c=l!==this.state.gpuAggregation;this.setState({gpuAggregation:l});let{dimensions:g}=this.state,f=this.isAttributeChanged(Ho),{data:d,weights:p}=g,{boundingBox:x}=this.state;if(f&&(x=wt(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:x})),f||a){let{gridOffset:S,translation:y,width:_,height:b,numCol:O,numRow:B}=It(x,i,s,r);this.allocateResources(B,O),this.setState({gridOffset:S,boundingBox:x,translation:y,posOffset:y.slice(),gridOrigin:[-1*y[0],-1*y[1]],width:_,height:b,numCol:O,numRow:B})}let h=f||c||this.isAggregationDirty(t,{dimension:d,compareAll:l}),A=this.isAggregationDirty(t,{dimension:p});A&&this._updateAccessors(t),(h||A)&&this._resetResults(),this.setState({aggregationDataDirty:h,aggregationWeightsDirty:A})}_updateAccessors(t){let{getWeight:e,aggregation:o,data:i}=t.props,{count:r}=this.state.weights;r&&(r.getWeight=e,r.operation=T[o]),this.setState({getValue:Q(o,e,{data:i})})}_resetResults(){let{count:t}=this.state.weights;t&&(t.aggregationData=null)}_generateContours(){let{numCol:t,numRow:e,gridOrigin:o,gridOffset:i,thresholdData:r}=this.state,{count:s}=this.state.weights,{aggregationData:a}=s;a||(a=s.aggregationBuffer.readSyncWebGL(),s.aggregationData=a);let{cellWeights:l}=C.getCellData({countsData:a}),c=zo({thresholdData:r,cellWeights:l,gridSize:[t,e],gridOrigin:o,cellSize:[i.xOffset,i.yOffset]});this.setState({contourData:c})}_updateThresholdData(t){let{contours:e,zOffset:o}=t,i=e.length,r=new Array(i);for(let s=0;s<i;s++){let a=e[s];r[s]={contour:a,zIndex:a.zIndex||s,zOffset:o}}this.setState({thresholdData:r})}},_t=kt;(()=>{kt.layerName="ContourLayer"})(),(()=>{kt.defaultProps=hr})();var Ko=M(E(),1);var $o=M(E(),1);var N=M(E(),1),Xo=M(q(),1);var qo=M(q(),1);var ko=`#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-vertex-shader
#define RANGE_COUNT 6
in vec3 positions;
in vec3 normals;
in vec4 colors;
in vec4 elevations;
in vec3 instancePickingColors;
uniform vec2 offset;
uniform bool extruded;
uniform float cellSize;
uniform float coverage;
uniform float opacity;
uniform float elevationScale;
uniform ivec2 gridSize;
uniform vec2 gridOrigin;
uniform vec2 gridOriginLow;
uniform vec2 gridOffset;
uniform vec2 gridOffsetLow;
uniform vec4 colorRange[RANGE_COUNT];
uniform vec2 elevationRange;
uniform vec2 colorDomain;
uniform bool colorDomainValid;
uniform vec2 elevationDomain;
uniform bool elevationDomainValid;
layout(std140) uniform;
uniform ColorData
{
vec4 maxMinCount;
} colorData;
uniform ElevationData
{
vec4 maxMinCount;
} elevationData;
#define EPSILON 0.00001
out vec4 vColor;
vec4 quantizeScale(vec2 domain, vec4 range[RANGE_COUNT], float value) {
vec4 outColor = vec4(0., 0., 0., 0.);
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
float domainRange = domain.y - domain.x;
if (domainRange <= 0.) {
outColor = colorRange[0];
} else {
float rangeCount = float(RANGE_COUNT);
float rangeStep = domainRange / rangeCount;
float idx = floor((value - domain.x) / rangeStep);
idx = clamp(idx, 0., rangeCount - 1.);
int intIdx = int(idx);
outColor = colorRange[intIdx];
}
}
return outColor;
}
float linearScale(vec2 domain, vec2 range, float value) {
if (value >= (domain.x - EPSILON) && value <= (domain.y + EPSILON)) {
return ((value - domain.x) / (domain.y - domain.x)) * (range.y - range.x) + range.x;
}
return -1.;
}
void main(void) {
vec2 clrDomain = colorDomainValid ? colorDomain : vec2(colorData.maxMinCount.a, colorData.maxMinCount.r);
vec4 color = quantizeScale(clrDomain, colorRange, colors.r);
float elevation = 0.0;
if (extruded) {
vec2 elvDomain = elevationDomainValid ? elevationDomain : vec2(elevationData.maxMinCount.a, elevationData.maxMinCount.r);
elevation = linearScale(elvDomain, elevationRange, elevations.r);
elevation = elevation  * (positions.z + 1.0) / 2.0 * elevationScale;
}
float shouldRender = float(color.r > 0.0 && elevations.r >= 0.0);
float dotRadius = cellSize / 2. * coverage * shouldRender;
int yIndex = (gl_InstanceID / gridSize[0]);
int xIndex = gl_InstanceID - (yIndex * gridSize[0]);
vec2 instancePositionXFP64 = mul_fp64(vec2(gridOffset[0], gridOffsetLow[0]), vec2(float(xIndex), 0.));
instancePositionXFP64 = sum_fp64(instancePositionXFP64, vec2(gridOrigin[0], gridOriginLow[0]));
vec2 instancePositionYFP64 = mul_fp64(vec2(gridOffset[1], gridOffsetLow[1]), vec2(float(yIndex), 0.));
instancePositionYFP64 = sum_fp64(instancePositionYFP64, vec2(gridOrigin[1], gridOriginLow[1]));
vec3 centroidPosition = vec3(instancePositionXFP64[0], instancePositionYFP64[0], elevation);
vec3 centroidPosition64Low = vec3(instancePositionXFP64[1], instancePositionYFP64[1], 0.0);
geometry.worldPosition = centroidPosition;
vec3 pos = vec3(project_size(positions.xy + offset) * dotRadius, 0.);
picking_setPickingColor(instancePickingColors);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
vec3 normals_commonspace = project_normal(normals);
if (extruded) {
vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, normals_commonspace);
vColor = vec4(lightColor, color.a * opacity) / 255.;
} else {
vColor = vec4(color.rgb, color.a * opacity) / 255.;
}
}
`;var jo=`#version 300 es
#define SHADER_NAME gpu-grid-cell-layer-fragment-shader
precision highp float;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
fragColor = vColor;
fragColor = picking_filterColor(fragColor);
}
`;var ae=0,le=1,vr={colorDomain:null,colorRange:D,elevationDomain:null,elevationRange:[0,1e3],elevationScale:{type:"number",min:0,value:1},gridSize:{type:"array",value:[1,1]},gridOrigin:{type:"array",value:[0,0]},gridOffset:{type:"array",value:[0,0]},cellSize:{type:"number",min:0,max:1e3,value:1e3},offset:{type:"array",value:[1,1]},coverage:{type:"number",min:0,max:1,value:1},extruded:!0,material:!0},Xt=class extends N.Layer{getShaders(){return super.getShaders({vs:ko,fs:jo,modules:[N.project32,N.gouraudLighting,N.picking,K]})}initializeState(){this.getAttributeManager().addInstanced({colors:{size:4,noAlloc:!0},elevations:{size:4,noAlloc:!0}});let e=this._getModel();this._setupUniformBuffer(e),this.setState({model:e})}_getModel(){return new qo.Model(this.context.device,{...this.getShaders(),id:this.props.id,geometry:new Xo.CubeGeometry,isInstanced:!0})}draw({uniforms:t}){let{cellSize:e,offset:o,extruded:i,elevationScale:r,coverage:s,gridSize:a,gridOrigin:l,gridOffset:c,elevationRange:g,colorMaxMinBuffer:f,elevationMaxMinBuffer:d}=this.props,p=this.state.model,x=[(0,N.fp64LowPart)(l[0]),(0,N.fp64LowPart)(l[1])],h=[(0,N.fp64LowPart)(c[0]),(0,N.fp64LowPart)(c[1])],A=this.getDomainUniforms(),S=z(this.props.colorRange);this.bindUniformBuffers(f,d),p.setUniforms(t),p.setUniforms(A),p.setUniforms({cellSize:e,offset:o,extruded:i,elevationScale:r,coverage:s,gridSize:a,gridOrigin:l,gridOriginLow:x,gridOffset:c,gridOffsetLow:h,colorRange:S,elevationRange:g}),p.draw(this.context.renderPass),this.unbindUniformBuffers(f,d)}bindUniformBuffers(t,e){t.bind({target:35345,index:ae}),e.bind({target:35345,index:le})}unbindUniformBuffers(t,e){t.unbind({target:35345,index:ae}),e.unbind({target:35345,index:le})}getDomainUniforms(){let{colorDomain:t,elevationDomain:e}=this.props,o={};return t!==null?(o.colorDomainValid=!0,o.colorDomain=t):o.colorDomainValid=!1,e!==null?(o.elevationDomainValid=!0,o.elevationDomain=e):o.elevationDomainValid=!1,o}_setupUniformBuffer(t){let e=t.pipeline.handle,o=this.context.gl,i=o.getUniformBlockIndex(e,"ColorData"),r=o.getUniformBlockIndex(e,"ElevationData");o.uniformBlockBinding(e,i,ae),o.uniformBlockBinding(e,r,le)}},bt=Xt;(()=>{Xt.layerName="GPUGridCellLayer"})(),(()=>{Xt.defaultProps=vr})();var Sr={colorDomain:null,colorRange:D,getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",elevationDomain:null,elevationRange:[0,1e3],getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},cellSize:{type:"number",min:1,max:1e3,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:n=>n.position},extruded:!1,material:!0},Ar={data:{props:["cellSize","colorAggregation","elevationAggregation"]}},Yo="positions",qt=class extends w{initializeState({device:t}){let e=C.isSupported(t);e||$o.log.error("GPUGridLayer is not supported on this browser, use GridLayer instead")(),super.initializeAggregationLayer({dimensions:Ar}),this.setState({gpuAggregation:!1,projectPoints:!1,isSupported:e,weights:{color:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:t.createBuffer({byteLength:4*4,accessor:{size:4,type:5126,divisor:1}})},elevation:{needMin:!0,needMax:!0,combineMaxMin:!0,maxMinBuffer:t.createBuffer({byteLength:4*4,accessor:{size:4,type:5126,divisor:1}})}},positionAttributeName:"positions"}),this.getAttributeManager().add({[Yo]:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},color:{size:3,accessor:"getColorWeight"},elevation:{size:3,accessor:"getElevationWeight"}})}updateState(t){if(this.state.isSupported===!1)return;super.updateState(t);let{aggregationDirty:e}=this.state;e&&this.setState({gridHash:null})}getHashKeyForIndex(t){let{numRow:e,numCol:o,boundingBox:i,gridOffset:r}=this.state,s=[o,e],a=[i.xMin,i.yMin],l=[r.xOffset,r.yOffset],c=Math.floor(t/s[0]),g=t-c*s[0],f=Math.floor((c*l[1]+a[1]+90+l[1]/2)/l[1]),d=Math.floor((g*l[0]+a[0]+180+l[0]/2)/l[0]);return`${f}-${d}`}getPositionForIndex(t){let{numRow:e,numCol:o,boundingBox:i,gridOffset:r}=this.state,s=[o,e],a=[i.xMin,i.yMin],l=[r.xOffset,r.yOffset],c=Math.floor(t/s[0]),g=t-c*s[0],f=c*l[1]+a[1];return[g*l[0]+a[0],f]}getPickingInfo({info:t,mode:e}){let{index:o}=t,i=null;if(o>=0){let r=this.state.gpuGridAggregator,s=this.getPositionForIndex(o),a=C.getAggregationData({pixelIndex:o,...r.getData("color")}),l=C.getAggregationData({pixelIndex:o,...r.getData("elevation")});if(i={colorValue:a.cellWeight,elevationValue:l.cellWeight,count:a.cellCount||l.cellCount,position:s,totalCount:a.totalCount||l.totalCount},e!=="hover"){let{props:c}=this,{gridHash:g}=this.state;if(!g){let{gridOffset:p,translation:x,boundingBox:h}=this.state,{viewport:A}=this.context,S=this.getAttributes();g=it(c,{gridOffset:p,attributes:S,viewport:A,translation:x,boundingBox:h}).gridHash,this.setState({gridHash:g})}let f=this.getHashKeyForIndex(o),d=g[f];Object.assign(i,d)}}return t.picked=Boolean(i),t.object=i,t}renderLayers(){if(!this.state.isSupported)return null;let{elevationScale:t,extruded:e,cellSize:o,coverage:i,material:r,elevationRange:s,colorDomain:a,elevationDomain:l}=this.props,{weights:c,numRow:g,numCol:f,gridOrigin:d,gridOffset:p}=this.state,{color:x,elevation:h}=c,A=z(this.props.colorRange),S=this.getSubLayerClass("gpu-grid-cell",bt);return new S({gridSize:[f,g],gridOrigin:d,gridOffset:[p.xOffset,p.yOffset],colorRange:A,elevationRange:s,colorDomain:a,elevationDomain:l,cellSize:o,coverage:i,material:r,elevationScale:t,extruded:e},this.getSubLayerProps({id:"gpu-grid-cell"}),{data:{attributes:{colors:x.aggregationBuffer,elevations:h.aggregationBuffer}},colorMaxMinBuffer:x.maxMinBuffer,elevationMaxMinBuffer:h.maxMinBuffer,numInstances:f*g})}finalizeState(t){let{color:e,elevation:o}=this.state.weights;[e,o].forEach(i=>{let{aggregationBuffer:r,maxMinBuffer:s}=i;s?.destroy(),r?.destroy()}),super.finalizeState(t)}updateAggregationState(t){let{props:e,oldProps:o}=t,{cellSize:i,coordinateSystem:r}=e,{viewport:s}=this.context,a=o.cellSize!==i,{dimensions:l}=this.state,c=this.isAttributeChanged(Yo),g=c||this.isAttributeChanged(),{boundingBox:f}=this.state;if(c&&(f=wt(this.getAttributes(),this.getNumInstances()),this.setState({boundingBox:f})),c||a){let{gridOffset:p,translation:x,width:h,height:A,numCol:S,numRow:y}=It(f,i,s,r);this.allocateResources(y,S),this.setState({gridOffset:p,translation:x,gridOrigin:[-1*x[0],-1*x[1]],width:h,height:A,numCol:S,numRow:y})}let d=g||this.isAggregationDirty(t,{dimension:l.data,compareAll:!0});d&&this._updateAccessors(t),this.setState({aggregationDataDirty:d})}_updateAccessors(t){let{colorAggregation:e,elevationAggregation:o}=t.props,{color:i,elevation:r}=this.state.weights;i.operation=T[e],r.operation=T[o]}},V=qt;(()=>{qt.layerName="GPUGridLayer"})(),(()=>{qt.defaultProps=Sr})();var yr={...V.defaultProps,...H.defaultProps,gpuAggregation:!1},Yt=class extends Ko.CompositeLayer{initializeState(){this.state={useGPUAggregation:!1}}updateState({props:t}){this.setState({useGPUAggregation:!1})}renderLayers(){let{data:t,updateTriggers:e}=this.props,o=this.state.useGPUAggregation?"GPU":"CPU",i=this.state.useGPUAggregation?this.getSubLayerClass("GPU",V):this.getSubLayerClass("CPU",H);return new i(this.props,this.getSubLayerProps({id:o,updateTriggers:e}),{data:t})}canUseGPUAggregation(t){let{gpuAggregation:e,lowerPercentile:o,upperPercentile:i,getColorValue:r,getElevationValue:s,colorScaleType:a}=t;return!(!e||!C.isSupported(this.context.device)||o!==0||i!==100||r!==null||s!==null||a==="quantile"||a==="ordinal")}},Mt=Yt;(()=>{Yt.layerName="GridLayer"})(),(()=>{Yt.defaultProps=yr})();function Zo(n){let t=n.map(a=>a[0]),e=n.map(a=>a[1]),o=Math.min.apply(null,t),i=Math.max.apply(null,t),r=Math.min.apply(null,e),s=Math.max.apply(null,e);return[o,r,i,s]}function Jo(n,t){return t[0]>=n[0]&&t[2]<=n[2]&&t[1]>=n[1]&&t[3]<=n[3]}var Qo=new Float32Array(12);function ce(n,t=2){let e=0;for(let o of n)for(let i=0;i<t;i++)Qo[e++]=o[i]||0;return Qo}function ti(n,t,e){let[o,i,r,s]=n,a=r-o,l=s-i,c=a,g=l;a/l<t/e?c=t/e*l:g=e/t*a,c<t&&(c=t,g=e);let f=(r+o)/2,d=(s+i)/2;return[f-c/2,d-g/2,f+c/2,d+g/2]}function ei(n,t){let[e,o,i,r]=t;return[(n[0]-e)/(i-e),(n[1]-o)/(r-o)]}var pe=M(q(),1),R=M(E(),1);var ri=M(q(),1),$t=M(E(),1);var oi=`#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
uniform float intensity;
uniform vec2 colorDomain;
uniform float threshold;
uniform float aggregationMode;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * threshold;
if (colorDomain[1] > 0.) {
maxValue = colorDomain[1];
minValue = colorDomain[0];
}
vIntensityMax = intensity / maxValue;
vIntensityMin = intensity / minValue;
}
`;var ii=`#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform float opacity;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
uniform float aggregationMode;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= opacity;
fragColor = linearColor;
}
`;var ue=class extends $t.Layer{getShaders(){return{vs:oi,fs:ii,modules:[$t.project32]}}initializeState({device:t}){this.setState({model:this._getModel(t)})}_getModel(t){let{vertexCount:e,data:o,weightsTexture:i,maxTexture:r,colorTexture:s}=this.props;return new ri.Model(t,{...this.getShaders(),id:this.props.id,bindings:{weightsTexture:i,maxTexture:r,colorTexture:s},attributes:o.attributes,bufferLayout:[{name:"positions",format:"float32x3"},{name:"texCoords",format:"float32x2"}],topology:"triangle-fan-webgl",vertexCount:e})}draw({uniforms:t}){let{model:e}=this.state,{intensity:o,threshold:i,aggregationMode:r,colorDomain:s}=this.props;e.setUniforms({...t,intensity:o,threshold:i,aggregationMode:r,colorDomain:s}),e.draw(this.context.renderPass)}},Tt=ue;(()=>{ue.layerName="TriangleLayer"})();var ge=`#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
uniform float radiusPixels;
uniform float textureWidth;
uniform vec4 commonBounds;
uniform float weightsScale;
void main()
{
weightsTexture = vec4(weights * weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(radiusPixels) * textureWidth / (commonBounds.z - commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - commonBounds.xy) / (commonBounds.zw - commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`;var fe=`#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ni=`#version 300 es
uniform sampler2D inTexture;
uniform float textureSize;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(textureSize);
int xIndex = gl_VertexID - (yIndex * int(textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`;var si=`#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;var _r=2,de={format:"rgba8unorm",mipmaps:!1,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}},ai=[0,0],br={SUM:0,MEAN:1},Mr={getPosition:{type:"accessor",value:n=>n.position},getWeight:{type:"accessor",value:1},intensity:{type:"number",min:0,value:1},radiusPixels:{type:"number",min:1,max:100,value:50},colorRange:D,threshold:{type:"number",min:0,max:1,value:.05},colorDomain:{type:"array",value:null,optional:!0},aggregation:"SUM",weightsTextureSize:{type:"number",min:128,max:2048,value:2048},debounceTimeout:{type:"number",min:0,max:1e3,value:500}},Tr=["float32-renderable-webgl","texture-blend-float-webgl"],Cr={data:{props:["radiusPixels"]}},Kt=class extends P{initializeState(){super.initializeAggregationLayer(Cr),this.setState({colorDomain:ai}),this._setupTextureParams(),this._setupAttributes(),this._setupResources()}shouldUpdateState({changeFlags:t}){return t.somethingChanged}updateState(t){super.updateState(t),this._updateHeatmapState(t)}_updateHeatmapState(t){let{props:e,oldProps:o}=t,i=this._getChangeFlags(t);(i.dataChanged||i.viewportChanged)&&(i.boundsChanged=this._updateBounds(i.dataChanged),this._updateTextureRenderingBounds()),i.dataChanged||i.boundsChanged?(clearTimeout(this.state.updateTimer),this.setState({isWeightMapDirty:!0})):i.viewportZoomChanged&&this._debouncedUpdateWeightmap(),e.colorRange!==o.colorRange&&this._updateColorTexture(t),this.state.isWeightMapDirty&&this._updateWeightmap(),this.setState({zoom:t.context.viewport.zoom})}renderLayers(){let{weightsTexture:t,triPositionBuffer:e,triTexCoordBuffer:o,maxWeightsTexture:i,colorTexture:r,colorDomain:s}=this.state,{updateTriggers:a,intensity:l,threshold:c,aggregation:g}=this.props,f=this.getSubLayerClass("triangle",Tt);return new f(this.getSubLayerProps({id:"triangle-layer",updateTriggers:a}),{coordinateSystem:R.COORDINATE_SYSTEM.DEFAULT,data:{attributes:{positions:e,texCoords:o}},vertexCount:4,maxTexture:i,colorTexture:r,aggregationMode:br[g]||0,weightsTexture:t,intensity:l,threshold:c,colorDomain:s})}finalizeState(t){super.finalizeState(t);let{weightsTransform:e,weightsTexture:o,maxWeightTransform:i,maxWeightsTexture:r,triPositionBuffer:s,triTexCoordBuffer:a,colorTexture:l,updateTimer:c}=this.state;e?.destroy(),o?.destroy(),i?.destroy(),r?.destroy(),s?.destroy(),a?.destroy(),l?.destroy(),c&&clearTimeout(c)}_getAttributeManager(){return new R.AttributeManager(this.context.device,{id:this.props.id,stats:this.context.stats})}_getChangeFlags(t){let e={},{dimensions:o}=this.state;e.dataChanged=this.isAttributeChanged()&&"attribute changed"||this.isAggregationDirty(t,{compareAll:!0,dimension:o.data})&&"aggregation is dirty",e.viewportChanged=t.changeFlags.viewportChanged;let{zoom:i}=this.state;return(!t.context.viewport||t.context.viewport.zoom!==i)&&(e.viewportZoomChanged=!0),e}_createTextures(){let{textureSize:t,format:e}=this.state;this.setState({weightsTexture:this.context.device.createTexture({...de,width:t,height:t,format:e}),maxWeightsTexture:this.context.device.createTexture({...de,width:1,height:1,format:e})})}_setupAttributes(){this.getAttributeManager().add({positions:{size:3,type:"float64",accessor:"getPosition"},weights:{size:1,accessor:"getWeight"}}),this.setState({positionAttributeName:"positions"})}_setupTextureParams(){let{device:t}=this.context,{weightsTextureSize:e}=this.props,o=Math.min(e,t.limits.maxTextureDimension2D),i=Tr.every(a=>t.features.has(a)),r=i?"rgba32float":"rgba8unorm",s=i?1:1/255;this.setState({textureSize:o,format:r,weightsScale:s}),i||R.log.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)()}_createWeightsTransform(t){let{weightsTransform:e}=this.state,{weightsTexture:o}=this.state,i=this.getAttributeManager();e?.destroy(),e=new pe.TextureTransform(this.context.device,{id:`${this.id}-weights-transform`,bufferLayout:i.getBufferLayouts(),vertexCount:1,targetTexture:o,parameters:{depthWriteEnabled:!1,blendColorOperation:"add",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},topology:"point-list",...t}),this.setState({weightsTransform:e})}_setupResources(){this._createTextures();let{device:t}=this.context,{textureSize:e,weightsTexture:o,maxWeightsTexture:i}=this.state,r=this.getShaders({vs:ge,fs:fe});this._createWeightsTransform(r);let s=this.getShaders({vs:ni,fs:si}),a=new pe.TextureTransform(t,{id:`${this.id}-max-weights-transform`,bindings:{inTexture:o},uniforms:{textureSize:e},targetTexture:i,...s,vertexCount:e*e,topology:"point-list",parameters:{depthWriteEnabled:!1,blendColorOperation:"max",blendAlphaOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"}});this.setState({weightsTexture:o,maxWeightsTexture:i,maxWeightTransform:a,zoom:null,triPositionBuffer:t.createBuffer({byteLength:48}),triTexCoordBuffer:t.createBuffer({byteLength:48})})}updateShaders(t){this._createWeightsTransform({vs:ge,fs:fe,...t})}_updateMaxWeightValue(){let{maxWeightTransform:t}=this.state;t.run({parameters:{viewport:[0,0,1,1]},clearColor:[0,0,0,0]})}_updateBounds(t=!1){let{viewport:e}=this.context,o=[e.unproject([0,0]),e.unproject([e.width,0]),e.unproject([e.width,e.height]),e.unproject([0,e.height])].map(a=>a.map(Math.fround)),i=Zo(o),r={visibleWorldBounds:i,viewportCorners:o},s=!1;if(t||!this.state.worldBounds||!Jo(this.state.worldBounds,i)){let a=this._worldToCommonBounds(i),l=this._commonToWorldBounds(a);this.props.coordinateSystem===R.COORDINATE_SYSTEM.LNGLAT&&(l[1]=Math.max(l[1],-85.051129),l[3]=Math.min(l[3],85.051129),l[0]=Math.max(l[0],-360),l[2]=Math.min(l[2],360));let c=this._worldToCommonBounds(l);r.worldBounds=l,r.normalizedCommonBounds=c,s=!0}return this.setState(r),s}_updateTextureRenderingBounds(){let{triPositionBuffer:t,triTexCoordBuffer:e,normalizedCommonBounds:o,viewportCorners:i}=this.state,{viewport:r}=this.context;t.write(ce(i,3));let s=i.map(a=>ei(r.projectPosition(a),o));e.write(ce(s,2))}_updateColorTexture(t){let{colorRange:e}=t.props,{colorTexture:o}=this.state,i=z(e,!1,Uint8Array);o&&o?.width===e.length?o.setSubImageData({data:i}):(o?.destroy(),o=this.context.device.createTexture({...de,data:i,width:e.length,height:1})),this.setState({colorTexture:o})}_updateWeightmap(){let{radiusPixels:t,colorDomain:e,aggregation:o}=this.props,{worldBounds:i,textureSize:r,weightsScale:s}=this.state,a=this.state.weightsTransform;this.state.isWeightMapDirty=!1;let l=this._worldToCommonBounds(i,{useLayerCoordinateSystem:!0});if(e&&o==="SUM"){let{viewport:h}=this.context,A=h.distanceScales.metersPerUnit[2]*(l[2]-l[0])/r;this.state.colorDomain=e.map(S=>S*A*s)}else this.state.colorDomain=e||ai;let g=this.getAttributeManager().getAttributes(),f=this.getModuleSettings(),d=g.positions.buffer,p={radiusPixels:t,commonBounds:l,textureWidth:r,weightsScale:s},x=g.weights.buffer;a.model.setAttributes({positions:d,weights:x}),a.model.setVertexCount(this.getNumInstances()),a.model.setUniforms(p),a.model.updateModuleSettings(f),a.run({parameters:{viewport:[0,0,r,r]},clearColor:[0,0,0,0]}),this._updateMaxWeightValue()}_debouncedUpdateWeightmap(t=!1){let{updateTimer:e}=this.state,{debounceTimeout:o}=this.props;t?(e=null,this._updateBounds(!0),this._updateTextureRenderingBounds(),this.setState({isWeightMapDirty:!0})):(this.setState({isWeightMapDirty:!1}),clearTimeout(e),e=setTimeout(this._debouncedUpdateWeightmap.bind(this,!0),o)),this.setState({updateTimer:e})}_worldToCommonBounds(t,e={}){let{useLayerCoordinateSystem:o=!1}=e,[i,r,s,a]=t,{viewport:l}=this.context,{textureSize:c}=this.state,{coordinateSystem:g}=this.props,f=o&&(g===R.COORDINATE_SYSTEM.LNGLAT_OFFSETS||g===R.COORDINATE_SYSTEM.METER_OFFSETS),d=f?l.projectPosition(this.props.coordinateOrigin):[0,0],p=c*_r/l.scale,x,h;return o&&!f?(x=this.projectPosition([i,r,0]),h=this.projectPosition([s,a,0])):(x=l.projectPosition([i,r,0]),h=l.projectPosition([s,a,0])),ti([x[0]-d[0],x[1]-d[1],h[0]-d[0],h[1]-d[1]],p,p)}_commonToWorldBounds(t){let[e,o,i,r]=t,{viewport:s}=this.context,a=s.unprojectPosition([e,o]),l=s.unprojectPosition([i,r]);return a.slice(0,2).concat(l.slice(0,2))}},Ct=Kt;(()=>{Kt.layerName="HeatmapLayer"})(),(()=>{Kt.defaultProps=Mr})();return pi(Et);})();
      return __exports__;
      });
