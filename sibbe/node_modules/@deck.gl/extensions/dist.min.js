(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var Rt=Object.create;var Q=Object.defineProperty;var Ct=Object.getOwnPropertyDescriptor;var St=Object.getOwnPropertyNames;var kt=Object.getPrototypeOf,Nt=Object.prototype.hasOwnProperty;var Fe=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Le=(r,e)=>{for(var t in e)Q(r,t,{get:e[t],enumerable:!0})},X=(r,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of St(e))!Nt.call(r,s)&&s!==t&&Q(r,s,{get:()=>e[s],enumerable:!(i=Ct(e,s))||i.enumerable});return r},P=(r,e,t)=>(X(r,e,"default"),t&&X(t,e,"default")),d=(r,e,t)=>(t=r!=null?Rt(kt(r)):{},X(e||!r||!r.__esModule?Q(t,"default",{value:r,enumerable:!0}):t,r)),Bt=r=>X(Q({},"__esModule",{value:!0}),r);var m=Fe((xi,Oe)=>{Oe.exports=globalThis.deck});var ze=Fe((Ei,je)=>{je.exports=globalThis.luma});var Z={};Le(Z,{BrushingExtension:()=>F,ClipExtension:()=>D,CollisionFilterExtension:()=>z,DataFilterExtension:()=>L,FillStyleExtension:()=>w,Fp64Extension:()=>S,MaskExtension:()=>q,PathStyleExtension:()=>N,_TerrainExtension:()=>K,project64:()=>oe});var v={},Ie=d(m(),1);P(v,d(m(),1));if(!Ie.Layer)throw new Error("@deck.gl/core is not found");P(Z,v);var Se=d(m(),1);var Re=d(m(),1);var wt=`
uniform bool brushing_enabled;
uniform int brushing_target;
uniform vec2 brushing_mousePos;
uniform float brushing_radius;
#ifdef NON_INSTANCED_MODEL
in vec2 brushingTargets;
#else
in vec2 instanceBrushingTargets;
#endif
out float brushing_isVisible;
bool brushing_isPointInRange(vec2 position) {
if (!brushing_enabled) {
return true;
}
vec2 source_commonspace = project_position(position);
vec2 target_commonspace = project_position(brushing_mousePos);
float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);
return distance <= brushing_radius;
}
bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
}
void brushing_setVisible(bool visible) {
brushing_isVisible = float(visible);
}
`,Dt=`
uniform bool brushing_enabled;
in float brushing_isVisible;
`,Vt={source:0,target:1,custom:2,source_target:3},jt={"vs:DECKGL_FILTER_GL_POSITION":`
vec2 brushingTarget;
vec2 brushingSource;
if (brushing_target == 3) {
brushingTarget = geometry.worldPositionAlt.xy;
brushingSource = geometry.worldPosition.xy;
} else if (brushing_target == 0) {
brushingTarget = geometry.worldPosition.xy;
} else if (brushing_target == 1) {
brushingTarget = geometry.worldPositionAlt.xy;
} else {
#ifdef NON_INSTANCED_MODEL
brushingTarget = brushingTargets;
#else
brushingTarget = instanceBrushingTargets;
#endif
}
bool visible;
if (brushing_target == 3) {
visible = brushing_arePointsInRange(brushingSource, brushingTarget);
} else {
visible = brushing_isPointInRange(brushingTarget);
}
brushing_setVisible(visible);
`,"fs:DECKGL_FILTER_COLOR":`
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `},Ce={name:"brushing",dependencies:[Re.project],vs:wt,fs:Dt,inject:jt,getUniforms:r=>{if(!r||!("viewport"in r))return{};let{brushingEnabled:e=!0,brushingRadius:t=1e4,brushingTarget:i="source",mousePosition:s,viewport:o}=r;return{brushing_enabled:Boolean(e&&s&&o.containsPixel(s)),brushing_radius:t,brushing_target:Vt[i]||0,brushing_mousePos:s?o.unproject([s.x-o.x,s.y-o.y]):[0,0]}}};var zt={getBrushingTarget:{type:"accessor",value:[0,0]},brushingTarget:"source",brushingEnabled:!0,brushingRadius:1e4},J=class extends Se.LayerExtension{getShaders(){return{modules:[Ce]}}initializeState(e,t){let i=this.getAttributeManager();i&&i.add({brushingTargets:{size:2,accessor:"getBrushingTarget",shaderAttributes:{brushingTargets:{divisor:0},instanceBrushingTargets:{divisor:1}}}});let s=()=>{this.getCurrentLayer()?.setNeedsRedraw()};this.state.onMouseMove=s,e.deck&&e.deck.eventManager.on({pointermove:s,pointerleave:s})}finalizeState(e,t){if(e.deck){let i=this.state.onMouseMove;e.deck.eventManager.off({pointermove:i,pointerleave:i})}}},F=J;(()=>{J.defaultProps=zt})(),(()=>{J.extensionName="BrushingExtension"})();var T=d(m(),1);var ke=`
uniform DATAFILTER_TYPE filter_min;
uniform DATAFILTER_TYPE filter_softMin;
uniform DATAFILTER_TYPE filter_softMax;
uniform DATAFILTER_TYPE filter_max;
uniform bool filter_useSoftMargin;
uniform bool filter_enabled;
uniform bool filter_transformSize;
uniform ivec4 filter_categoryBitMask;
#ifdef NON_INSTANCED_MODEL
#define DATAFILTER_ATTRIB filterValues
#define DATAFILTER_ATTRIB_64LOW filterValues64Low
#define DATACATEGORY_ATTRIB filterCategoryValues
#else
#define DATAFILTER_ATTRIB instanceFilterValues
#define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low
#define DATACATEGORY_ATTRIB instanceFilterCategoryValues
#endif
in DATAFILTER_TYPE DATAFILTER_ATTRIB;
#ifdef DATAFILTER_DOUBLE
in DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;
uniform DATAFILTER_TYPE filter_min64High;
uniform DATAFILTER_TYPE filter_max64High;
#endif
in DATACATEGORY_TYPE DATACATEGORY_ATTRIB;
out float dataFilter_value;
float dataFilter_reduceValue(float value) {
return value;
}
float dataFilter_reduceValue(vec2 value) {
return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
return min(min(value.x, value.y), min(value.z, value.w));
}
void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {
if (filter_enabled) {
if (filter_useSoftMargin) {
dataFilter_value = dataFilter_reduceValue(
smoothstep(filter_min, filter_softMin, valueFromMin) *
(1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))
);
} else {
dataFilter_value = dataFilter_reduceValue(
step(filter_min, valueFromMin) * step(valueFromMax, filter_max)
);
}
#if DATACATEGORY_CHANNELS == 1
int dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];
#elif DATACATEGORY_CHANNELS == 2
ivec2 dataFilter_masks = ivec2(
filter_categoryBitMask[int(category.x / 32.0)],
filter_categoryBitMask[int(category.y / 32.0) + 2]
);
#elif DATACATEGORY_CHANNELS == 3
ivec3 dataFilter_masks = filter_categoryBitMask.xyz;
#else
ivec4 dataFilter_masks = filter_categoryBitMask;
#endif
DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));
dataFilter_bits = mod(floor(dataFilter_bits), 2.0);
#if DATACATEGORY_CHANNELS == 1
if(dataFilter_bits == 0.0) dataFilter_value = 0.0;
#else
if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;
#endif
} else {
dataFilter_value = 1.0;
}
}
`,Ne=`
uniform bool filter_transformColor;
in float dataFilter_value;
`;function Be(r){if(!r||!("extensions"in r))return{};let{filterRange:e=[-1,1],filterEnabled:t=!0,filterTransformSize:i=!0,filterTransformColor:s=!0}=r,o=r.filterSoftRange||e;return{...Number.isFinite(e[0])?{filter_min:e[0],filter_softMin:o[0],filter_softMax:o[1],filter_max:e[1]}:{filter_min:e.map(n=>n[0]),filter_softMin:o.map(n=>n[0]),filter_softMax:o.map(n=>n[1]),filter_max:e.map(n=>n[1])},filter_enabled:t,filter_useSoftMargin:Boolean(r.filterSoftRange),filter_transformSize:t&&i,filter_transformColor:t&&s}}function Gt(r){if(!r||!("extensions"in r))return{};let e=Be(r);if(Number.isFinite(e.filter_min)){let t=Math.fround(e.filter_min);e.filter_min-=t,e.filter_softMin-=t,e.filter_min64High=t;let i=Math.fround(e.filter_max);e.filter_max-=i,e.filter_softMax-=i,e.filter_max64High=i}else{let t=e.filter_min.map(Math.fround);e.filter_min=e.filter_min.map((s,o)=>s-t[o]),e.filter_softMin=e.filter_softMin.map((s,o)=>s-t[o]),e.filter_min64High=t;let i=e.filter_max.map(Math.fround);e.filter_max=e.filter_max.map((s,o)=>s-i[o]),e.filter_softMax=e.filter_softMax.map((s,o)=>s-i[o]),e.filter_max64High=i}return e}var we={"vs:#main-start":`
#ifdef DATAFILTER_DOUBLE
dataFilter_setValue(
DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,
DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,
DATACATEGORY_ATTRIB
);
#else
dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);
#endif
`,"vs:#main-end":`
if (dataFilter_value == 0.0) {
gl_Position = vec4(0.);
}
`,"vs:DECKGL_FILTER_SIZE":`
if (filter_transformSize) {
size = size * dataFilter_value;
}
`,"fs:DECKGL_FILTER_COLOR":`
if (dataFilter_value == 0.0) discard;
if (filter_transformColor) {
color.a *= dataFilter_value;
}
`},De={name:"data-filter",vs:ke,fs:Ne,inject:we,getUniforms:Be},Ve={name:"data-filter-fp64",vs:ke,fs:Ne,inject:we,getUniforms:Gt};var Ge=d(ze(),1);var Ut=`#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`,qt=`#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`,Wt=["float32-renderable-webgl","texture-blend-float-webgl"];function Ue(r){return Wt.every(e=>r.features.has(e))}function qe(r,e){return e?r.createFramebuffer({width:1,height:1,colorAttachments:[r.createTexture({format:"rgba32float",type:5126,mipmaps:!1})]}):r.createFramebuffer({width:256,height:64,colorAttachments:[r.createTexture({format:"rgba8unorm",type:5126,mipmaps:!1})]})}function We(r,e,t){return e.defines.NON_INSTANCED_MODEL=1,t&&(e.defines.FLOAT_TARGET=1),new Ge.Model(r,{id:"data-filter-aggregation-model",vertexCount:1,isInstanced:!1,drawMode:0,vs:Ut,fs:qt,...e})}var He={blend:!0,blendFunc:[1,1,1,1],blendEquation:[32774,32774],depthTest:!1};var Yt={getFilterValue:{type:"accessor",value:0},getFilterCategory:{type:"accessor",value:0},onFilteredItemsChange:{type:"function",value:null,optional:!0},filterEnabled:!0,filterRange:[-1,1],filterSoftRange:null,filterCategories:[0],filterTransformSize:!0,filterTransformColor:!0},Kt={categorySize:1,filterSize:1,fp64:!1,countItems:!1},Ye={1:"float",2:"vec2",3:"vec3",4:"vec4"},ee=class extends T.LayerExtension{constructor(e={}){super({...Kt,...e})}getShaders(e){let{categorySize:t,filterSize:i,fp64:s}=e.opts;return{modules:[s?Ve:De],defines:{DATACATEGORY_TYPE:Ye[t],DATACATEGORY_CHANNELS:t,DATAFILTER_TYPE:Ye[i],DATAFILTER_DOUBLE:Boolean(s)}}}initializeState(e,t){let i=this.getAttributeManager(),{categorySize:s,filterSize:o,fp64:n}=t.opts;i&&i.add({filterValues:{size:o,type:n?"float64":"float32",accessor:"getFilterValue",shaderAttributes:{filterValues:{divisor:0},instanceFilterValues:{divisor:1}}},filterCategoryValues:{size:s,accessor:"getFilterCategory",transform:s===1?l=>t._getCategoryKey.call(this,l,0):l=>l.map((f,c)=>t._getCategoryKey.call(this,f,c)),shaderAttributes:{filterCategoryValues:{divisor:0},instanceFilterCategoryValues:{divisor:1}}}});let{device:a}=this.context;if(i&&t.opts.countItems){let l=Ue(a);i.add({filterIndices:{size:l?1:2,vertexOffset:1,type:"unorm8",accessor:(u,{index:_})=>{let p=u&&u.__source?u.__source.index:_;return l?(p+1)%255:[(p+1)%255,Math.floor(p/255)%255]},shaderAttributes:{filterPrevIndices:{vertexOffset:0},filterIndices:{vertexOffset:1}}}});let f=qe(a,l),c=We(a,t.getShaders.call(this,t),l);this.setState({filterFBO:f,filterModel:c})}}updateState({props:e,oldProps:t,changeFlags:i},s){let o=this.getAttributeManager(),{categorySize:n}=s.opts;if(this.state.filterModel){let a=o.attributes.filterValues.needsUpdate()||o.attributes.filterCategoryValues?.needsUpdate()||e.filterEnabled!==t.filterEnabled||e.filterRange!==t.filterRange||e.filterSoftRange!==t.filterSoftRange||e.filterCategories!==t.filterCategories;a&&this.setState({filterNeedsUpdate:a})}if(o?.attributes.filterCategoryValues){let a=o.attributes.filterCategoryValues.needsUpdate()||!(0,T._deepEqual)(e.filterCategories,t.filterCategories,2);a&&this.setState({categoryBitMaskNeedsUpdate:a}),i.dataChanged&&(this.setState({categoryMap:Array(n).fill(0).map(()=>({}))}),o.attributes.filterCategoryValues.setNeedsUpdate("categoryMap"))}}draw(e,t){let i=this.state.filterFBO,s=this.state.filterModel,o=this.state.filterNeedsUpdate,n=this.state.categoryBitMaskNeedsUpdate,{onFilteredItemsChange:a}=this.props;if(n&&t._updateCategoryBitMask.call(this,e,t),o&&a&&s){let{attributes:{filterValues:l,filterCategoryValues:f,filterIndices:c}}=this.getAttributeManager();s.setVertexCount(this.getNumInstances()),this.context.device.clearWebGL({framebuffer:i,color:[0,0,0,0]}),s.updateModuleSettings(e.moduleParameters),s.setAttributes({...l.getValue(),...f?.getValue(),...c?.getValue()}),s.setUniforms(e.uniforms),s.device.withParametersWebGL({framebuffer:i,...He,viewport:[0,0,i.width,i.height]},()=>{s.draw(this.context.renderPass)});let u=s.device.readPixelsToArrayWebGL(i),_=0;for(let p=0;p<u.length;p++)_+=u[p];a({id:this.id,count:_}),this.state.filterNeedsUpdate=!1}}finalizeState(){let e=this.state.filterFBO,t=this.state.filterModel;e?.destroy(),t?.destroy()}_updateCategoryBitMask(e,t){let{categorySize:i}=t.opts,{filterCategories:s}=this.props,o=new Uint32Array([0,0,0,0]),n=i===1?[s]:s,a=i===1?128:i===2?64:32;for(let l=0;l<n.length;l++){let f=n[l];for(let c of f){let u=t._getCategoryKey.call(this,c,l);if(u<a){let _=l*(a/32)+Math.floor(u/32);o[_]+=Math.pow(2,u%32)}else T.log.warn(`Exceeded maximum number of categories (${a})`)()}}e.uniforms.filter_categoryBitMask=o,this.state.categoryBitMaskNeedsUpdate=!1}_getCategoryKey(e,t){let i=this.state.categoryMap[t];return e in i||(i[e]=Object.keys(i).length),i[e]}},L=ee;(()=>{ee.defaultProps=Yt})(),(()=>{ee.extensionName="DataFilterExtension"})();var C=d(m(),1);function te(r,e=[],t=0){let i=Math.fround(r),s=r-i;return e[t]=i,e[t+1]=s,e}function ge(r){return r-Math.fround(r)}function xe(r){let e=new Float32Array(32);for(let t=0;t<4;++t)for(let i=0;i<4;++i){let s=t*4+i;te(r[i*4+t],e,s*2)}return e}var Ke=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var Ze=`const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);
const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);
const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);
const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);
float nint(float d) {
if (d == floor(d)) return d;
return floor(d + 0.5);
}
vec2 nint_fp64(vec2 a) {
float hi = nint(a.x);
float lo;
vec2 tmp;
if (hi == a.x) {
lo = nint(a.y);
tmp = quickTwoSum(hi, lo);
} else {
lo = 0.0;
if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
hi -= 1.0;
}
tmp = vec2(hi, lo);
}
return tmp;
}
vec2 exp_fp64(vec2 a) {
const int k_power = 4;
const float k = 16.0;
const float inv_k = 1.0 / k;
if (a.x <= -88.0) return vec2(0.0, 0.0);
if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
if (a.x == 1.0 && a.y == 0.0) return E_FP64;
float m = floor(a.x / LOG2_FP64.x + 0.5);
vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
vec2 s, t, p;
p = mul_fp64(r, r);
s = sum_fp64(r, p * 0.5);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
for (int i = 0; i < k_power; i++) {
s = sum_fp64(s * 2.0, mul_fp64(s, s));
}
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = sum_fp64(s, vec2(ONE, 0.0));
#else
s = sum_fp64(s, vec2(1.0, 0.0));
#endif
return s * pow(2.0, m);
}
vec2 log_fp64(vec2 a)
{
if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
vec2 x = vec2(log(a.x), 0.0);
vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = vec2(ONE, 0.0);
#else
s = vec2(1.0, 0.0);
#endif
x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
return x;
}
vec2 sin_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
x = -mul_fp64(a, a);
s = a;
r = a;
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
return s;
}
vec2 cos_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
x = -mul_fp64(a, a);
r = x;
s = sum_fp64(vec2(1.0, 0.0), r * 0.5);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
s = sum_fp64(s, t);
return s;
}
void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
if (a.x == 0.0 && a.y == 0.0) {
sin_t = vec2(0.0, 0.0);
cos_t = vec2(1.0, 0.0);
}
sin_t = sin_taylor_fp64(a);
cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}
vec2 sin_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return sin_taylor_fp64(t);
} else if (j == 1) {
return cos_taylor_fp64(t);
} else if (j == -1) {
return -cos_taylor_fp64(t);
} else {
return -sin_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else if (j == 1) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
}
} else {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
}
return result;
}
vec2 cos_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return cos_taylor_fp64(t);
} else if (j == 1) {
return -sin_taylor_fp64(t);
} else if (j == -1) {
return sin_taylor_fp64(t);
} else {
return -cos_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == 1) {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
return result;
}
vec2 tan_fp64(vec2 a) {
vec2 sin_a;
vec2 cos_a;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
vec2 sin_t, cos_t;
vec2 s, c;
sincos_taylor_fp64(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
if (k > 0) {
s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return div_fp64(sin_a, cos_a);
}
vec2 radians_fp64(vec2 degree) {
return mul_fp64(degree, PI_180_FP64);
}
vec2 mix_fp64(vec2 a, vec2 b, float x) {
vec2 range = sub_fp64(b, a);
return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sum_fp64(a[0], b[0]);
out_val[1] = sum_fp64(a[1], b[1]);
}
void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sub_fp64(a[0], b[0]);
out_val[1] = sub_fp64(a[1], b[1]);
}
void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = mul_fp64(a[0], b[0]);
out_val[1] = mul_fp64(a[1], b[1]);
}
void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = div_fp64(a[0], b[0]);
out_val[1] = div_fp64(a[1], b[1]);
}
void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
vec2 range[2];
vec2_sub_fp64(y, x, range);
vec2 portion[2];
portion[0] = range[0] * a;
portion[1] = range[1] * a;
vec2_sum_fp64(x, portion, out_val);
}
vec2 vec2_length_fp64(vec2 x[2]) {
return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}
void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
vec2 length = vec2_length_fp64(x);
vec2 length_vec2[2];
length_vec2[0] = length;
length_vec2[1] = length;
vec2_div_fp64(x, length_vec2, out_val);
}
vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
vec2 diff[2];
vec2_sub_fp64(x, y, diff);
return vec2_length_fp64(diff);
}
vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
vec2 v[2];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
vec2 vec3_length_fp64(vec2 x[3]) {
return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
mul_fp64(x[2], x[2])));
}
vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
vec2 diff[3];
vec3_sub_fp64(x, y, diff);
return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
out_val[0].x = a[0];
out_val[0].y = 0.0;
out_val[1].x = a[1];
out_val[1].y = 0.0;
out_val[2].x = a[2];
out_val[2].y = 0.0;
out_val[3].x = a[3];
out_val[3].y = 0.0;
}
void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
out_val[0] = mul_fp64(a[0], b);
out_val[1] = mul_fp64(a[1], b);
out_val[2] = mul_fp64(a[2], b);
out_val[3] = mul_fp64(a[3], b);
}
void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
for (int i = 0; i < 4; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
vec2 v[4];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
v[2] = mul_fp64(a[2], b[2]);
v[3] = mul_fp64(a[3], b[3]);
out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}
void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
vec2 tmp[4];
for (int i = 0; i < 4; i++)
{
for (int j = 0; j < 4; j++)
{
tmp[j] = b[j + i * 4];
}
vec4_dot_fp64(a, tmp, out_val[i]);
}
}
`;var Zt={ONE:1};function $t(){return Zt}var $e={name:"fp64-arithmetic",vs:Ke,getUniforms:$t,fp64ify:te,fp64LowPart:ge,fp64ifyMatrix4:xe},re={name:"fp64",vs:Ze,dependencies:[$e],fp64ify:te,fp64LowPart:ge,fp64ifyMatrix4:xe};var Ni=1/Math.PI*180,Bi=1/180*Math.PI,Xt={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...Xt}};var O=globalThis.mathgl.config;function Pe(r){return Array.isArray(r)||ArrayBuffer.isView(r)&&!(r instanceof DataView)}function b(r,e,t){let i=O.EPSILON;t&&(O.EPSILON=t);try{if(r===e)return!0;if(Pe(r)&&Pe(e)){if(r.length!==e.length)return!1;for(let s=0;s<r.length;++s)if(!b(r[s],e[s]))return!1;return!0}return r&&r.equals?r.equals(e):e&&e.equals?e.equals(r):typeof r=="number"&&typeof e=="number"?Math.abs(r-e)<=O.EPSILON*Math.max(1,Math.abs(r),Math.abs(e)):!1}finally{O.EPSILON=i}}var I=typeof Float32Array<"u"?Float32Array:Array,ye=Math.random;function ie(r){return r>=0?Math.round(r):r%.5===0?Math.floor(r):Math.round(r)}var Di=Math.PI/180;var R={};Le(R,{add:()=>ir,angle:()=>Mr,bezier:()=>gr,ceil:()=>sr,clone:()=>Jt,copy:()=>tr,create:()=>Xe,cross:()=>dr,dist:()=>kr,distance:()=>rt,div:()=>Sr,divide:()=>tt,dot:()=>be,equals:()=>Ir,exactEquals:()=>Or,floor:()=>or,forEach:()=>Dr,fromValues:()=>er,hermite:()=>vr,inverse:()=>_r,len:()=>Br,length:()=>Qe,lerp:()=>mr,max:()=>ar,min:()=>nr,mul:()=>Cr,multiply:()=>et,negate:()=>ur,normalize:()=>pr,random:()=>xr,rotateX:()=>br,rotateY:()=>Ar,rotateZ:()=>Er,round:()=>lr,scale:()=>fr,scaleAndAdd:()=>cr,set:()=>rr,slerp:()=>hr,sqrDist:()=>Nr,sqrLen:()=>wr,squaredDistance:()=>it,squaredLength:()=>st,str:()=>Lr,sub:()=>Rr,subtract:()=>Je,transformMat3:()=>yr,transformMat4:()=>Pr,transformQuat:()=>Tr,zero:()=>Fr});function Xe(){let r=new I(3);return I!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function Jt(r){let e=new I(3);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e}function Qe(r){let e=r[0],t=r[1],i=r[2];return Math.sqrt(e*e+t*t+i*i)}function er(r,e,t){let i=new I(3);return i[0]=r,i[1]=e,i[2]=t,i}function tr(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function rr(r,e,t,i){return r[0]=e,r[1]=t,r[2]=i,r}function ir(r,e,t){return r[0]=e[0]+t[0],r[1]=e[1]+t[1],r[2]=e[2]+t[2],r}function Je(r,e,t){return r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}function et(r,e,t){return r[0]=e[0]*t[0],r[1]=e[1]*t[1],r[2]=e[2]*t[2],r}function tt(r,e,t){return r[0]=e[0]/t[0],r[1]=e[1]/t[1],r[2]=e[2]/t[2],r}function sr(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r}function or(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r}function nr(r,e,t){return r[0]=Math.min(e[0],t[0]),r[1]=Math.min(e[1],t[1]),r[2]=Math.min(e[2],t[2]),r}function ar(r,e,t){return r[0]=Math.max(e[0],t[0]),r[1]=Math.max(e[1],t[1]),r[2]=Math.max(e[2],t[2]),r}function lr(r,e){return r[0]=ie(e[0]),r[1]=ie(e[1]),r[2]=ie(e[2]),r}function fr(r,e,t){return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r}function cr(r,e,t,i){return r[0]=e[0]+t[0]*i,r[1]=e[1]+t[1]*i,r[2]=e[2]+t[2]*i,r}function rt(r,e){let t=e[0]-r[0],i=e[1]-r[1],s=e[2]-r[2];return Math.sqrt(t*t+i*i+s*s)}function it(r,e){let t=e[0]-r[0],i=e[1]-r[1],s=e[2]-r[2];return t*t+i*i+s*s}function st(r){let e=r[0],t=r[1],i=r[2];return e*e+t*t+i*i}function ur(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function _r(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function pr(r,e){let t=e[0],i=e[1],s=e[2],o=t*t+i*i+s*s;return o>0&&(o=1/Math.sqrt(o)),r[0]=e[0]*o,r[1]=e[1]*o,r[2]=e[2]*o,r}function be(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function dr(r,e,t){let i=e[0],s=e[1],o=e[2],n=t[0],a=t[1],l=t[2];return r[0]=s*l-o*a,r[1]=o*n-i*l,r[2]=i*a-s*n,r}function mr(r,e,t,i){let s=e[0],o=e[1],n=e[2];return r[0]=s+i*(t[0]-s),r[1]=o+i*(t[1]-o),r[2]=n+i*(t[2]-n),r}function hr(r,e,t,i){let s=Math.acos(Math.min(Math.max(be(e,t),-1),1)),o=Math.sin(s),n=Math.sin((1-i)*s)/o,a=Math.sin(i*s)/o;return r[0]=n*e[0]+a*t[0],r[1]=n*e[1]+a*t[1],r[2]=n*e[2]+a*t[2],r}function vr(r,e,t,i,s,o){let n=o*o,a=n*(2*o-3)+1,l=n*(o-2)+o,f=n*(o-1),c=n*(3-2*o);return r[0]=e[0]*a+t[0]*l+i[0]*f+s[0]*c,r[1]=e[1]*a+t[1]*l+i[1]*f+s[1]*c,r[2]=e[2]*a+t[2]*l+i[2]*f+s[2]*c,r}function gr(r,e,t,i,s,o){let n=1-o,a=n*n,l=o*o,f=a*n,c=3*o*a,u=3*l*n,_=l*o;return r[0]=e[0]*f+t[0]*c+i[0]*u+s[0]*_,r[1]=e[1]*f+t[1]*c+i[1]*u+s[1]*_,r[2]=e[2]*f+t[2]*c+i[2]*u+s[2]*_,r}function xr(r,e){e=e===void 0?1:e;let t=ye()*2*Math.PI,i=ye()*2-1,s=Math.sqrt(1-i*i)*e;return r[0]=Math.cos(t)*s,r[1]=Math.sin(t)*s,r[2]=i*e,r}function Pr(r,e,t){let i=e[0],s=e[1],o=e[2],n=t[3]*i+t[7]*s+t[11]*o+t[15];return n=n||1,r[0]=(t[0]*i+t[4]*s+t[8]*o+t[12])/n,r[1]=(t[1]*i+t[5]*s+t[9]*o+t[13])/n,r[2]=(t[2]*i+t[6]*s+t[10]*o+t[14])/n,r}function yr(r,e,t){let i=e[0],s=e[1],o=e[2];return r[0]=i*t[0]+s*t[3]+o*t[6],r[1]=i*t[1]+s*t[4]+o*t[7],r[2]=i*t[2]+s*t[5]+o*t[8],r}function Tr(r,e,t){let i=t[0],s=t[1],o=t[2],n=t[3],a=e[0],l=e[1],f=e[2],c=s*f-o*l,u=o*a-i*f,_=i*l-s*a,p=s*_-o*u,x=o*c-i*_,$=i*u-s*c,h=n*2;return c*=h,u*=h,_*=h,p*=2,x*=2,$*=2,r[0]=a+c+p,r[1]=l+u+x,r[2]=f+_+$,r}function br(r,e,t,i){let s=[],o=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],o[0]=s[0],o[1]=s[1]*Math.cos(i)-s[2]*Math.sin(i),o[2]=s[1]*Math.sin(i)+s[2]*Math.cos(i),r[0]=o[0]+t[0],r[1]=o[1]+t[1],r[2]=o[2]+t[2],r}function Ar(r,e,t,i){let s=[],o=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],o[0]=s[2]*Math.sin(i)+s[0]*Math.cos(i),o[1]=s[1],o[2]=s[2]*Math.cos(i)-s[0]*Math.sin(i),r[0]=o[0]+t[0],r[1]=o[1]+t[1],r[2]=o[2]+t[2],r}function Er(r,e,t,i){let s=[],o=[];return s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],o[0]=s[0]*Math.cos(i)-s[1]*Math.sin(i),o[1]=s[0]*Math.sin(i)+s[1]*Math.cos(i),o[2]=s[2],r[0]=o[0]+t[0],r[1]=o[1]+t[1],r[2]=o[2]+t[2],r}function Mr(r,e){let t=r[0],i=r[1],s=r[2],o=e[0],n=e[1],a=e[2],l=Math.sqrt((t*t+i*i+s*s)*(o*o+n*n+a*a)),f=l&&be(r,e)/l;return Math.acos(Math.min(Math.max(f,-1),1))}function Fr(r){return r[0]=0,r[1]=0,r[2]=0,r}function Lr(r){return`vec3(${r[0]}, ${r[1]}, ${r[2]})`}function Or(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]}function Ir(r,e){let t=r[0],i=r[1],s=r[2],o=e[0],n=e[1],a=e[2];return Math.abs(t-o)<=1e-6*Math.max(1,Math.abs(t),Math.abs(o))&&Math.abs(i-n)<=1e-6*Math.max(1,Math.abs(i),Math.abs(n))&&Math.abs(s-a)<=1e-6*Math.max(1,Math.abs(s),Math.abs(a))}var Rr=Je,Cr=et,Sr=tt,kr=rt,Nr=it,Br=Qe,wr=st,Dr=function(){let r=Xe();return function(e,t,i,s,o,n){let a,l;for(t||(t=3),i||(i=0),s?l=Math.min(s*t+i,e.length):l=e.length,a=i;a<l;a+=t)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],o(r,r,n),e[a]=r[0],e[a+1]=r[1],e[a+2]=r[2];return e}}();var se=d(m(),1);var ot=`const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);
uniform vec2 project_uViewProjectionMatrixFP64[16];
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {
#if defined(NVIDIA_FP64_WORKAROUND)
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
out_val[1] = sum_fp64(PI_FP64,
log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
return;
}
void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
vec2 pos_fp64[2];
mercatorProject_fp64(position_fp64, pos_fp64);
out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);
return;
}
void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
vec4 position64xy = vec4(
position.x, position64xyLow.x,
position.y, position64xyLow.y);
project_position_fp64(position64xy, out_val);
}
vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
vec2 vertex_pos_clipspace[4];
mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,
vertex_pos_clipspace);
return vec4(
vertex_pos_clipspace[0].x,
vertex_pos_clipspace[1].x,
vertex_pos_clipspace[2].x,
vertex_pos_clipspace[3].x
);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
vec2 offset64[4];
vec4_fp64(vec4(offset, 0.0), offset64);
float z = project_size(position.z);
vec2 projectedPosition64xy[2];
project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);
vec2 commonPosition64[4];
commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
commonPosition64[3] = vec2(1.0, 0.0);
commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);
return project_common_position_to_clipspace_fp64(commonPosition64);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset
) {
vec4 commonPosition;
return project_position_to_clipspace(
position, position64xyLow, offset, commonPosition
);
}
`;var{fp64ify:Vr,fp64ifyMatrix4:jr}=re,oe={name:"project64",dependencies:[se.project,re],vs:ot,getUniforms:Gr},zr=(0,se._memoize)(Ur);function Gr(r){if(r&&"viewport"in r){let{viewProjectionMatrix:e,scale:t}=r.viewport;return zr({viewProjectionMatrix:e,scale:t})}return{}}function Ur({viewProjectionMatrix:r,scale:e}){let t=jr(r),i=Vr(e);return{project_uViewProjectionMatrixFP64:t,project64_uViewProjectionMatrix:t,project64_uScale:i}}var Ae=class extends C.LayerExtension{getShaders(){let{coordinateSystem:e}=this.props;if(e!==C.COORDINATE_SYSTEM.LNGLAT&&e!==C.COORDINATE_SYSTEM.DEFAULT)throw new Error("fp64: coordinateSystem must be LNGLAT");return{modules:[oe]}}},S=Ae;(()=>{Ae.extensionName="Fp64Extension"})();var k=d(m(),1);var nt={inject:{"vs:#decl":`
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,"vs:#main-end":`
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,"fs:#decl":`
uniform float dashAlignMode;
uniform float capType;
uniform bool dashGapPickable;
in vec2 vDashArray;
in float vDashOffset;
`,"fs:#main-start":`
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (capType <= 0.5) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`}},at={inject:{"vs:#decl":`
in float instanceOffsets;
`,"vs:DECKGL_FILTER_SIZE":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,"vs:#main-end":`
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,"fs:#main-start":`
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`}};var qr={getDashArray:{type:"accessor",value:[0,0]},getOffset:{type:"accessor",value:0},dashJustified:!1,dashGapPickable:!1},ne=class extends k.LayerExtension{constructor({dash:e=!1,offset:t=!1,highPrecisionDash:i=!1}={}){super({dash:e||i,offset:t,highPrecisionDash:i})}isEnabled(e){return"pathTesselator"in e.state}getShaders(e){if(!e.isEnabled(this))return null;let t={};return e.opts.dash&&(t=(0,k._mergeShaders)(t,nt)),e.opts.offset&&(t=(0,k._mergeShaders)(t,at)),t}initializeState(e,t){let i=this.getAttributeManager();!i||!t.isEnabled(this)||(t.opts.dash&&i.addInstanced({instanceDashArrays:{size:2,accessor:"getDashArray"},instanceDashOffsets:t.opts.highPrecisionDash?{size:1,accessor:"getPath",transform:t.getDashOffsets.bind(this)}:{size:1,update:s=>{s.constant=!0,s.value=[0]}}}),t.opts.offset&&i.addInstanced({instanceOffsets:{size:1,accessor:"getOffset"}}))}updateState(e,t){if(!t.isEnabled(this))return;let i={};t.opts.dash&&(i.dashAlignMode=this.props.dashJustified?1:0,i.dashGapPickable=Boolean(this.props.dashGapPickable)),this.state.model?.setUniforms(i)}getDashOffsets(e){let t=[0],i=this.props.positionFormat==="XY"?2:3,s=Array.isArray(e[0]),o=s?e.length:e.length/i,n,a;for(let l=0;l<o-1;l++)n=s?e[l]:e.slice(l*i,l*i+i),n=this.projectPosition(n),l>0&&(t[l]=t[l-1]+R.dist(a,n)),a=n;return t[o-1]=0,t}},N=ne;(()=>{ne.defaultProps=qr})(),(()=>{ne.extensionName="PathStyleExtension"})();var ft=d(m(),1);var B=d(m(),1);var Wr=`
#ifdef NON_INSTANCED_MODEL
#define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames
#define FILL_PATTERN_SCALE_ATTRIB fillPatternScales
#define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets
#else
#define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames
#define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales
#define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets
#endif
in vec4 FILL_PATTERN_FRAME_ATTRIB;
in float FILL_PATTERN_SCALE_ATTRIB;
in vec2 FILL_PATTERN_OFFSET_ATTRIB;
uniform bool fill_patternEnabled;
uniform vec2 fill_patternTextureSize;
out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`,Hr=`
uniform bool fill_patternEnabled;
uniform bool fill_patternMask;
uniform sampler2D fill_patternTexture;
uniform vec2 fill_uvCoordinateOrigin;
uniform vec2 fill_uvCoordinateOrigin64Low;
in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;
const float FILL_UV_SCALE = 512.0 / 40000000.0;
`,Yr={"vs:DECKGL_FILTER_GL_POSITION":`
fill_uv = geometry.position.xy;
`,"vs:DECKGL_FILTER_COLOR":`
if (fill_patternEnabled) {
fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);
fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;
fill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;
}
`,"fs:DECKGL_FILTER_COLOR":`
if (fill_patternEnabled) {
vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;
patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);
vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;
vec4 patternColor = texture(fill_patternTexture, texCoords);
color.a *= patternColor.a;
if (!fill_patternMask) {
color.rgb = patternColor.rgb;
}
}
`};function Kr(r,e){if(!r)return{};if("fillPatternTexture"in r){let{fillPatternTexture:t}=r;return{fill_patternTexture:t,fill_patternTextureSize:[t.width,t.height]}}if("viewport"in r){let{fillPatternMask:t=!0,fillPatternEnabled:i=!0}=r,{project_uCommonOrigin:s}=e,o=[(0,B.fp64LowPart)(s[0]),(0,B.fp64LowPart)(s[1])];return{fill_uvCoordinateOrigin:s.slice(0,2),fill_uvCoordinateOrigin64Low:o,fill_patternMask:t,fill_patternEnabled:i}}return{}}var lt={name:"fill-pattern",vs:Wr,fs:Hr,inject:Yr,dependencies:[B.project],getUniforms:Kr};var Zr={fillPatternEnabled:!0,fillPatternAtlas:{type:"image",value:null,async:!0,parameters:{lodMaxClamp:0}},fillPatternMapping:{type:"object",value:{},async:!0},fillPatternMask:!0,getFillPattern:{type:"accessor",value:r=>r.pattern},getFillPatternScale:{type:"accessor",value:1},getFillPatternOffset:{type:"accessor",value:[0,0]}},ae=class extends ft.LayerExtension{constructor({pattern:e=!1}={}){super({pattern:e})}isEnabled(e){return e.getAttributeManager()!==null&&!("pathTesselator"in e.state)}getShaders(e){return e.isEnabled(this)?{modules:[e.opts.pattern&&lt].filter(Boolean)}:null}initializeState(e,t){if(!t.isEnabled(this))return;let i=this.getAttributeManager();t.opts.pattern&&i.add({fillPatternFrames:{size:4,accessor:"getFillPattern",transform:t.getPatternFrame.bind(this),shaderAttributes:{fillPatternFrames:{divisor:0},instanceFillPatternFrames:{divisor:1}}},fillPatternScales:{size:1,accessor:"getFillPatternScale",defaultValue:1,shaderAttributes:{fillPatternScales:{divisor:0},instanceFillPatternScales:{divisor:1}}},fillPatternOffsets:{size:2,accessor:"getFillPatternOffset",shaderAttributes:{fillPatternOffsets:{divisor:0},instanceFillPatternOffsets:{divisor:1}}}}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState({props:e,oldProps:t},i){i.isEnabled(this)&&e.fillPatternMapping&&e.fillPatternMapping!==t.fillPatternMapping&&this.getAttributeManager().invalidate("getFillPattern")}draw(e,t){if(!t.isEnabled(this))return;let{fillPatternAtlas:i}=this.props;this.setModuleParameters({fillPatternTexture:i||this.state.emptyTexture})}finalizeState(){this.state.emptyTexture?.delete()}getPatternFrame(e){let{fillPatternMapping:t}=this.getCurrentLayer().props,i=t&&t[e];return i?[i.x,i.y,i.width,i.height]:[0,0,0,0]}},w=ae;(()=>{ae.defaultProps=Zr})(),(()=>{ae.extensionName="FillStyleExtension"})();var ct=d(m(),1);var $r={clipBounds:[0,0,1,1],clipByInstance:void 0},ut=`
uniform vec4 clip_bounds;
bool clip_isInBounds(vec2 position) {
return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];
}
`,Xr={name:"clip-vs",vs:ut},Qr={"vs:#decl":`
out float clip_isVisible;
`,"vs:DECKGL_FILTER_GL_POSITION":`
clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`,"fs:#decl":`
in float clip_isVisible;
`,"fs:DECKGL_FILTER_COLOR":`
if (clip_isVisible < 0.5) discard;
`},Jr={name:"clip-fs",fs:ut},ei={"vs:#decl":`
out vec2 clip_commonPosition;
`,"vs:DECKGL_FILTER_GL_POSITION":`
clip_commonPosition = geometry.position.xy;
`,"fs:#decl":`
in vec2 clip_commonPosition;
`,"fs:DECKGL_FILTER_COLOR":`
if (!clip_isInBounds(clip_commonPosition)) discard;
`},le=class extends ct.LayerExtension{getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return this.props.clipByInstance!==void 0&&(e=Boolean(this.props.clipByInstance)),this.state.clipByInstance=e,e?{modules:[Xr],inject:Qr}:{modules:[Jr],inject:ei}}draw({uniforms:e}){let{clipBounds:t}=this.props;if(this.state.clipByInstance)e.clip_bounds=t;else{let i=this.projectPosition([t[0],t[1],0]),s=this.projectPosition([t[2],t[3],0]);e.clip_bounds=[Math.min(i[0],s[0]),Math.min(i[1],s[1]),Math.max(i[0],s[0]),Math.max(i[1],s[1])]}}},D=le;(()=>{le.defaultProps=$r})(),(()=>{le.extensionName="ClipExtension"})();var ht=d(m(),1);var _t=d(m(),1);var ti=`
#ifdef NON_INSTANCED_MODEL
in float collisionPriorities;
#else
in float instanceCollisionPriorities;
#endif
uniform sampler2D collision_texture;
uniform bool collision_sort;
uniform bool collision_enabled;
vec2 collision_getCoords(vec4 position) {
vec4 collision_clipspace = project_common_position_to_clipspace(position);
return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}
float collision_match(vec2 tex, vec3 pickingColor) {
vec4 collision_pickingColor = texture(collision_texture, tex);
float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
float e = 0.001;
return step(delta, e);
}
float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
if (!collision_enabled) {
return 1.0;
}
const int N = 2;
float accumulator = 0.0;
vec2 step = vec2(1.0 / project_uViewportSize);
const float floatN = float(N);
vec2 delta = -floatN * step;
for(int i = -N; i <= N; i++) {
delta.x = -step.x * floatN;
for(int j = -N; j <= N; j++) {
accumulator += collision_match(texCoords + delta, pickingColor);
delta.x += step.x;
}
delta.y += step.y;
}
float W = 2.0 * floatN + 1.0;
return pow(accumulator / (W * W), 2.2);
}
`,ri={"vs:#decl":`
float collision_fade = 1.0;
`,"vs:DECKGL_FILTER_GL_POSITION":`
if (collision_sort) {
#ifdef NON_INSTANCED_MODEL
float collisionPriority = collisionPriorities;
#else
float collisionPriority = instanceCollisionPriorities;
#endif
position.z = -0.001 * collisionPriority * position.w;
}
if (collision_enabled) {
vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
vec2 collision_texCoords = collision_getCoords(collision_common_position);
collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
if (collision_fade < 0.0001) {
position = vec4(0.0, 0.0, 2.0, 1.0);
}
}
`,"vs:DECKGL_FILTER_COLOR":`
color.a *= collision_fade;
`},ii=(r,e)=>{if(!r||!("dummyCollisionMap"in r))return{};let{collisionFBO:t,drawToCollisionMap:i,dummyCollisionMap:s}=r;return{collision_sort:Boolean(i),collision_texture:!i&&t?t.colorAttachments[0]:s}},pt={name:"collision",dependencies:[_t.project],vs:ti,inject:ri,getUniforms:ii};var mt=d(m(),1);var dt=d(m(),1),V=class extends dt._LayersPass{renderCollisionMap(e,t){let s=[0,0,0,0],o=[1,1,e.width-2*1,e.height-2*1];this.render({...t,clearColor:s,scissorRect:o,target:e,pass:"collision"})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!1,depthRange:[0,1],depthTest:!0}}getModuleParameters(){return{drawToCollisionMap:!0,picking:{isActive:1,isAttribute:!1},lightSources:{}}}};var Ee=2,j=class{constructor(){this.id="collision-filter-effect",this.props=null,this.useInPicking=!0,this.order=1,this.channels={},this.collisionFBOs={}}setup(e){this.context=e;let{device:t}=e;this.dummyCollisionMap=t.createTexture({width:1,height:1}),this.collisionFilterPass=new V(t,{id:"default-collision-filter"})}preRender({effects:e,layers:t,layerFilter:i,viewports:s,onViewportActive:o,views:n,isPicking:a,preRenderStats:l={}}){let{device:f}=this.context;if(a)return;let c=t.filter(({props:{visible:h,collisionEnabled:ve}})=>h&&ve);if(c.length===0){this.channels={};return}let u=e?.filter(h=>h.useInPicking&&l[h.id]),_=l["mask-effect"]?.didRender,p=this._groupByCollisionGroup(f,c),x=s[0],$=!this.lastViewport||!this.lastViewport.equals(x)||_;for(let h in p){let ve=this.collisionFBOs[h],Lt=p[h],[Ot,It]=f.canvasContext.getPixelSize();ve.resize({width:Ot/Ee,height:It/Ee}),this._render(Lt,{effects:u,layerFilter:i,onViewportActive:o,views:n,viewport:x,viewportChanged:$})}}_render(e,{effects:t,layerFilter:i,onViewportActive:s,views:o,viewport:n,viewportChanged:a}){let{collisionGroup:l}=e,f=this.channels[l];if(!f)return;let c=a||e===f||!(0,mt._deepEqual)(f.layers,e.layers,1)||e.layerBounds.some((u,_)=>!b(u,f.layerBounds[_]))||e.allLayersLoaded!==f.allLayersLoaded||e.layers.some(u=>u.props.transitions);if(this.channels[l]=e,c){this.lastViewport=n;let u=this.collisionFBOs[l];this.collisionFilterPass.renderCollisionMap(u,{pass:"collision-filter",isPicking:!0,layers:e.layers,effects:t,layerFilter:i,viewports:n?[n]:[],onViewportActive:s,views:o,moduleParameters:{dummyCollisionMap:this.dummyCollisionMap,devicePixelRatio:u.device.canvasContext.getDevicePixelRatio()/Ee}})}}_groupByCollisionGroup(e,t){let i={};for(let s of t){let{collisionGroup:o}=s.props,n=i[o];n||(n={collisionGroup:o,layers:[],layerBounds:[],allLayersLoaded:!0},i[o]=n),n.layers.push(s),n.layerBounds.push(s.getBounds()),s.isLoaded||(n.allLayersLoaded=!1)}for(let s of Object.keys(i))this.collisionFBOs[s]||this.createFBO(e,s),this.channels[s]||(this.channels[s]=i[s]);for(let s of Object.keys(this.collisionFBOs))i[s]||this.destroyFBO(s);return i}getModuleParameters(e){let{collisionGroup:t}=e.props,{collisionFBOs:i,dummyCollisionMap:s}=this;return{collisionFBO:i[t],dummyCollisionMap:s}}cleanup(){this.dummyCollisionMap&&(this.dummyCollisionMap.delete(),this.dummyCollisionMap=void 0),this.channels={};for(let e of Object.keys(this.collisionFBOs))this.destroyFBO(e);this.collisionFBOs={},this.lastViewport=void 0}createFBO(e,t){let{width:i,height:s}=e.gl.canvas,o=e.createTexture({format:"rgba8unorm",width:i,height:s,sampler:{minFilter:"nearest",magFilter:"nearest",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),n=e.createTexture({format:"depth16unorm",width:i,height:s,mipmaps:!1,dataFormat:6402,type:5125});this.collisionFBOs[t]=e.createFramebuffer({id:`collision-${t}`,width:i,height:s,colorAttachments:[o],depthStencilAttachment:n})}destroyFBO(e){let t=this.collisionFBOs[e];t.colorAttachments[0]?.destroy(),t.depthStencilAttachment?.destroy(),t.destroy(),delete this.collisionFBOs[e]}};var si={getCollisionPriority:{type:"accessor",value:0},collisionEnabled:!0,collisionGroup:{type:"string",value:"default"},collisionTestProps:{}},fe=class extends ht.LayerExtension{getShaders(){return{modules:[pt]}}draw({uniforms:e,context:t,moduleParameters:i}){let{collisionEnabled:s}=this.props,{collisionFBO:o,drawToCollisionMap:n}=i,a=s&&Boolean(o);e.collision_enabled=a,n&&(this.props=this.clone(this.props.collisionTestProps).props)}initializeState(e,t){if(this.getAttributeManager()===null)return;this.context.deck?._addDefaultEffect(new j),this.getAttributeManager().add({collisionPriorities:{size:1,accessor:"getCollisionPriority",shaderAttributes:{collisionPriorities:{divisor:0},instanceCollisionPriorities:{divisor:1}}}})}getNeedsPickingBuffer(){return this.props.collisionEnabled}},z=fe;(()=>{fe.defaultProps=si})(),(()=>{fe.extensionName="CollisionFilterExtension"})();var y=d(m(),1);var vt=d(m(),1);var oi=`
uniform vec4 mask_bounds;
uniform bool mask_maskByInstance;
vec2 mask_getCoords(vec4 position) {
return (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);
}
`,ni=`
uniform sampler2D mask_texture;
uniform int mask_channel;
uniform bool mask_enabled;
uniform bool mask_inverted;
bool mask_isInBounds(vec2 texCoords) {
if (!mask_enabled) {
return true;
}
vec4 maskColor = texture(mask_texture, texCoords);
float maskValue = 1.0;
if (mask_channel == 0) {
maskValue = maskColor.r;
} else if (mask_channel == 1) {
maskValue = maskColor.g;
} else if (mask_channel == 2) {
maskValue = maskColor.b;
} else if (mask_channel == 3) {
maskValue = maskColor.a;
}
if (mask_inverted) {
return maskValue >= 0.5;
} else {
return maskValue < 0.5;
}
}
`,ai={"vs:#decl":`
out vec2 mask_texCoords;
`,"vs:#main-end":`
vec4 mask_common_position;
if (mask_maskByInstance) {
mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
} else {
mask_common_position = geometry.position;
}
mask_texCoords = mask_getCoords(mask_common_position);
`,"fs:#decl":`
in vec2 mask_texCoords;
`,"fs:#main-start":`
if (mask_enabled) {
bool mask = mask_isInBounds(mask_texCoords);
fragColor = texture(mask_texture, mask_texCoords);
if (!mask) discard;
}
`},li=r=>r&&"maskMap"in r?{mask_texture:r.maskMap}:{},gt={name:"mask",dependencies:[vt.project],vs:oi,fs:ni,inject:ai,getUniforms:li};var Me=d(m(),1);var xt=d(m(),1),fi={blendColorOperation:"subtract",blendColorSrcFactor:"zero",blendColorDstFactor:"one",blendAlphaOperation:"subtract",blendAlphaSrcFactor:"zero",blendAlphaDstFactor:"one"},G=class extends xt._LayersPass{constructor(e,t){super(e,t);let{mapSize:i=2048}=t;this.maskMap=e.createTexture({format:"rgba8unorm",width:i,height:i,sampler:{minFilter:"linear",magFilter:"linear",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}}),this.fbo=e.createFramebuffer({id:"maskmap",width:i,height:i,colorAttachments:[this.maskMap]})}render(e){let t=2**e.channel,i=[255,255,255,255];super.render({...e,clearColor:i,colorMask:t,target:this.fbo,pass:"mask"})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!0,depthTest:!1,...fi}}shouldDrawLayer(e){return e.props.operation.includes("mask")}delete(){this.fbo.delete(),this.maskMap.delete()}};var ce=d(m(),1);function A(r,e){let t=[1/0,1/0,-1/0,-1/0];for(let i of r){let s=i.getBounds();if(s){let o=i.projectPosition(s[0],{viewport:e,autoOffset:!1}),n=i.projectPosition(s[1],{viewport:e,autoOffset:!1});t[0]=Math.min(t[0],o[0]),t[1]=Math.min(t[1],o[1]),t[2]=Math.max(t[2],n[0]),t[3]=Math.max(t[3],n[1])}}return Number.isFinite(t[0])?t:null}var ci=2048;function E(r){let{bounds:e,viewport:t,border:i=0}=r,{isGeospatial:s}=t;if(e[2]<=e[0]||e[3]<=e[1])return null;let o=t.unprojectPosition([(e[0]+e[2])/2,(e[1]+e[3])/2,0]),{width:n,height:a,zoom:l}=r;if(l===void 0){n=n-i*2,a=a-i*2;let f=Math.min(n/(e[2]-e[0]),a/(e[3]-e[1]));l=Math.min(Math.log2(f),20)}else if(!n||!a){let f=2**l;n=Math.round(Math.abs(e[2]-e[0])*f),a=Math.round(Math.abs(e[3]-e[1])*f);let c=ci-i*2;if(n>c||a>c){let u=c/Math.max(n,a);n=Math.round(n*u),a=Math.round(a*u),l+=Math.log2(u)}}return s?new ce.WebMercatorViewport({id:t.id,x:i,y:i,width:n,height:a,longitude:o[0],latitude:o[1],zoom:l,orthographic:!0}):new ce.OrthographicViewport({id:t.id,x:i,y:i,width:n,height:a,target:o,zoom:l,flipY:!1})}function ui(r,e){let t;if(e&&e.length===2){let[o,n]=e,a=r.getBounds({z:o}),l=r.getBounds({z:n});t=[Math.min(a[0],l[0]),Math.min(a[1],l[1]),Math.max(a[2],l[2]),Math.max(a[3],l[3])]}else t=r.getBounds();let i=r.projectPosition(t.slice(0,2)),s=r.projectPosition(t.slice(2,4));return[i[0],i[1],s[0],s[1]]}function M(r,e,t){if(!r)return[0,0,1,1];let i=ui(e,t),s=_i(i);return r[2]-r[0]<=s[2]-s[0]&&r[3]-r[1]<=s[3]-s[1]?r:[Math.max(r[0],s[0]),Math.max(r[1],s[1]),Math.min(r[2],s[2]),Math.min(r[3],s[3])]}function _i(r){let e=r[2]-r[0],t=r[3]-r[1],i=(r[0]+r[2])/2,s=(r[1]+r[3])/2;return[i-e,s-t,i+e,s+t]}var U=class{constructor(){this.id="mask-effect",this.props=null,this.useInPicking=!0,this.order=0,this.channels=[],this.masks=null}setup({device:e}){this.dummyMaskMap=e.createTexture({width:1,height:1}),this.maskPass=new G(e,{id:"default-mask"}),this.maskMap=this.maskPass.maskMap}preRender({layers:e,layerFilter:t,viewports:i,onViewportActive:s,views:o,isPicking:n}){let a=!1;if(n)return{didRender:a};let l=e.filter(_=>_.props.visible&&_.props.operation.includes("mask"));if(l.length===0)return this.masks=null,this.channels.length=0,{didRender:a};this.masks={};let f=this._sortMaskChannels(l),c=i[0],u=!this.lastViewport||!this.lastViewport.equals(c);if(c.resolution!==void 0)return Me.log.warn("MaskExtension is not supported in GlobeView")(),{didRender:a};for(let _ in f){let p=this._renderChannel(f[_],{layerFilter:t,onViewportActive:s,views:o,viewport:c,viewportChanged:u});a||=p}return{didRender:a}}_renderChannel(e,{layerFilter:t,onViewportActive:i,views:s,viewport:o,viewportChanged:n}){let a=!1,l=this.channels[e.index];if(!l)return a;let f=e===l||e.layers.length!==l.layers.length||e.layers.some((c,u)=>c!==l.layers[u]||c.props.transitions)||e.layerBounds.some((c,u)=>c!==l.layerBounds[u]);if(e.bounds=l.bounds,e.maskBounds=l.maskBounds,this.channels[e.index]=e,f||n){this.lastViewport=o;let c=A(e.layers,o);if(e.bounds=c&&M(c,o),f||!b(e.bounds,l.bounds)){let{maskPass:u,maskMap:_}=this,p=c&&E({bounds:e.bounds,viewport:o,width:_.width,height:_.height,border:1});e.maskBounds=p?p.getBounds():[0,0,1,1],u.render({pass:"mask",channel:e.index,layers:e.layers,layerFilter:t,viewports:p?[p]:[],onViewportActive:i,views:s,moduleParameters:{devicePixelRatio:1}}),a=!0}}return this.masks[e.id]={index:e.index,bounds:e.maskBounds,coordinateOrigin:e.coordinateOrigin,coordinateSystem:e.coordinateSystem},a}_sortMaskChannels(e){let t={},i=0;for(let s of e){let{id:o}=s.root,n=t[o];if(!n){if(++i>4){Me.log.warn("Too many mask layers. The max supported is 4")();continue}n={id:o,index:this.channels.findIndex(a=>a?.id===o),layers:[],layerBounds:[],coordinateOrigin:s.root.props.coordinateOrigin,coordinateSystem:s.root.props.coordinateSystem},t[o]=n}n.layers.push(s),n.layerBounds.push(s.getBounds())}for(let s=0;s<4;s++){let o=this.channels[s];(!o||!(o.id in t))&&(this.channels[s]=null)}for(let s in t){let o=t[s];o.index<0&&(o.index=this.channels.findIndex(n=>!n),this.channels[o.index]=o)}return t}getModuleParameters(){return{maskMap:this.masks?this.maskMap:this.dummyMaskMap,maskChannels:this.masks}}cleanup(){this.dummyMaskMap&&(this.dummyMaskMap.delete(),this.dummyMaskMap=void 0),this.maskPass&&(this.maskPass.delete(),this.maskPass=void 0,this.maskMap=void 0),this.lastViewport=void 0,this.masks=null,this.channels.length=0}};var pi={maskId:"",maskByInstance:void 0,maskInverted:!1},ue=class extends y.LayerExtension{initializeState(){this.context.deck?._addDefaultEffect(new U)}getShaders(){let e="instancePositions"in this.getAttributeManager().attributes;return this.props.maskByInstance!==void 0&&(e=Boolean(this.props.maskByInstance)),this.state.maskByInstance=e,{modules:[gt]}}draw({uniforms:e,context:t,moduleParameters:i}){e.mask_maskByInstance=this.state.maskByInstance;let{maskId:s,maskInverted:o}=this.props,{maskChannels:n}=i,{viewport:a}=t;if(n&&n[s]){let{index:l,bounds:f,coordinateOrigin:c}=n[s],{coordinateSystem:u}=n[s];e.mask_enabled=!0,e.mask_channel=l,e.mask_inverted=o,u===y.COORDINATE_SYSTEM.DEFAULT&&(u=a.isGeospatial?y.COORDINATE_SYSTEM.LNGLAT:y.COORDINATE_SYSTEM.CARTESIAN);let _={modelMatrix:null,fromCoordinateOrigin:c,fromCoordinateSystem:u},p=this.projectPosition([f[0],f[1],0],_),x=this.projectPosition([f[2],f[3],0],_);e.mask_bounds=[p[0],p[1],x[0],x[1]]}else s&&y.log.warn(`Could not find a mask layer with id: ${s}`)(),e.mask_enabled=!1}},q=ue;(()=>{ue.defaultProps=pi})(),(()=>{ue.extensionName="MaskExtension"})();var Ft=d(m(),1);var Mt=d(m(),1);var yt=d(m(),1);var g={NONE:0,WRITE_HEIGHT_MAP:1,USE_HEIGHT_MAP:2,USE_COVER:3,USE_COVER_ONLY:4,SKIP:5},Pt=Object.keys(g).map(r=>`const float TERRAIN_MODE_${r} = ${g[r]}.0;`).join(`
`),W={name:"terrain",dependencies:[yt.project],inject:{"vs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
out vec3 commonPos;
`+Pt,"vs:#main-start":`
if (terrain_mode == TERRAIN_MODE_SKIP) {
gl_Position = vec4(0.0);
return;
}
`,"vs:DECKGL_FILTER_GL_POSITION":`
commonPos = geometry.position.xyz;
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
commonPos.z += project_uCommonOrigin.z;
}
if (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
vec3 anchor = geometry.worldPosition;
anchor.z = 0.0;
vec3 anchorCommon = project_position(anchor);
vec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;
if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
float terrainZ = texture(terrain_map, texCoords).r;
geometry.position.z += terrainZ;
position = project_common_position_to_clipspace(geometry.position);
}
}
`,"fs:#decl":`
uniform float terrain_mode;
uniform sampler2D terrain_map;
uniform vec4 terrain_bounds;
in vec3 commonPos;
`+Pt,"fs:#main-start":`
if (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
return;
}
`,"fs:DECKGL_FILTER_COLOR":`
if ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {
vec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;
vec4 pixel = texture(terrain_map, texCoords);
if (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {
color = pixel;
} else {
color = pixel + color * (1.0 - pixel.a);
}
return;
}
`},getUniforms:(r={},e)=>{if("dummyHeightMap"in r){let{drawToTerrainHeightMap:t,heightMap:i,heightMapBounds:s,dummyHeightMap:o,terrainCover:n,useTerrainHeightMap:a,terrainSkipRender:l}=r,{project_uCommonOrigin:f}=e,c=l?g.SKIP:g.NONE,u=o,_=null;if(t)c=g.WRITE_HEIGHT_MAP,_=s;else if(a&&i)c=g.USE_HEIGHT_MAP,u=i,_=s;else if(n){let p=r.picking?.isActive;u=(p?n.getPickingFramebuffer():n.getRenderFramebuffer())?.colorAttachments[0].texture,p&&(c=g.SKIP),u?(c=c===g.SKIP?g.USE_COVER_ONLY:g.USE_COVER,_=n.bounds):u=o}return{terrain_mode:c,terrain_map:u,terrain_bounds:_?[_[0]-f[0],_[1]-f[1],_[2]-_[0],_[3]-_[1]]:[0,0,0,0]}}return null}};function H(r,e){return r.createFramebuffer({id:e.id,colorAttachments:[r.createTexture({id:e.id,...e.float&&{format:"rgba32float",type:5126},mipmaps:!1,sampler:e.interpolate===!1?{minFilter:"nearest",magFilter:"nearest"}:{minFilter:"linear",magFilter:"linear"}})]})}var _e=class{constructor(e){this.isDirty=!0,this.renderViewport=null,this.bounds=null,this.layers=[],this.targetBounds=null,this.targetBoundsCommon=null,this.targetLayer=e,this.tile=Tt(e)}get id(){return this.targetLayer.id}get isActive(){return Boolean(this.targetLayer.getCurrentLayer())}shouldUpdate({targetLayer:e,viewport:t,layers:i,layerNeedsRedraw:s}){e&&(this.targetLayer=e);let o=t?this._updateViewport(t):!1,n=i?this._updateLayers(i):!1;if(s){for(let a of this.layers)if(s[a]){n=!0;break}}return n||o}_updateLayers(e){let t=!1;if(e=this.tile?di(this.tile,e):e,e.length!==this.layers.length)t=!0;else for(let i=0;i<e.length;i++)if(e[i].id!==this.layers[i]){t=!0;break}return t&&(this.layers=e.map(i=>i.id)),t}_updateViewport(e){let t=this.targetLayer,i=!1;if(this.tile&&"boundingBox"in this.tile){if(!this.targetBounds){i=!0,this.targetBounds=this.tile.boundingBox;let o=e.projectPosition(this.targetBounds[0]),n=e.projectPosition(this.targetBounds[1]);this.targetBoundsCommon=[o[0],o[1],n[0],n[1]]}}else this.targetBounds!==t.getBounds()&&(i=!0,this.targetBounds=t.getBounds(),this.targetBoundsCommon=A([t],e));if(!this.targetBoundsCommon)return!1;let s=Math.ceil(e.zoom+.5);if(this.tile)this.bounds=this.targetBoundsCommon;else{let o=this.renderViewport?.zoom;i=i||s!==o;let n=M(this.targetBoundsCommon,e),a=this.bounds;i=i||!a||n.some((l,f)=>l!==a[f]),this.bounds=n}return i&&(this.renderViewport=E({bounds:this.bounds,zoom:s,viewport:e})),i}getRenderFramebuffer(){return!this.renderViewport||this.layers.length===0?null:(this.fbo||(this.fbo=H(this.targetLayer.context.device,{id:this.id})),this.fbo)}getPickingFramebuffer(){return!this.renderViewport||this.layers.length===0&&!this.targetLayer.props.pickable?null:(this.pickingFbo||(this.pickingFbo=H(this.targetLayer.context.device,{id:`${this.id}-picking`,interpolate:!1})),this.pickingFbo)}filterLayers(e){return e.filter(({id:t})=>this.layers.includes(t))}delete(){let{fbo:e,pickingFbo:t}=this;e&&(e.colorAttachments[0].destroy(),e.destroy()),t&&(t.colorAttachments[0].destroy(),t.destroy())}};function di(r,e){return e.filter(t=>{let i=Tt(t);return i?mi(r.boundingBox,i.boundingBox):!0})}function Tt(r){for(;r;){let{tile:e}=r.props;if(e)return e;r=r.parent}return null}function mi(r,e){return r&&e?r[0][0]<e[1][0]&&e[0][0]<r[1][0]&&r[0][1]<e[1][1]&&e[0][1]<r[1][1]:!1}var bt=d(m(),1),hi={blendColorOperation:"max",blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one"},pe=class extends bt._LayersPass{getRenderableLayers(e,t){let{layers:i}=t,s=[],o=this._getDrawLayerParams(e,t,!0);for(let n=0;n<i.length;n++){let a=i[n];!a.isComposite&&o[n].shouldDrawLayer&&s.push(a)}return s}renderHeightMap(e,t){let i=e.getRenderFramebuffer(),s=e.renderViewport;!i||!s||(i.resize(s),this.render({...t,target:i,pass:"terrain-height-map",layers:t.layers,viewports:[s],effects:[],clearColor:[0,0,0,0]}))}renderTerrainCover(e,t){let i=e.getRenderFramebuffer(),s=e.renderViewport;if(!i||!s)return;let o=e.filterLayers(t.layers);i.resize(s),this.render({...t,target:i,pass:`terrain-cover-${e.id}`,layers:o,effects:[],viewports:[s],clearColor:[0,0,0,0]})}getLayerParameters(e,t,i){return{...e.props.parameters,blend:!0,depthTest:!1,...e.props.operation.includes("terrain")&&hi}}};var At=d(m(),1),de=class extends At._PickLayersPass{constructor(){super(...arguments),this.drawParameters={}}getRenderableLayers(e,t){let{layers:i}=t,s=[];this.drawParameters={},this._resetColorEncoder(t.pickZ);let o=this._getDrawLayerParams(e,t);for(let n=0;n<i.length;n++){let a=i[n];!a.isComposite&&o[n].shouldDrawLayer&&(s.push(a),this.drawParameters[a.id]=o[n].layerParameters)}return s}renderTerrainCover(e,t){let i=e.getPickingFramebuffer(),s=e.renderViewport;if(!i||!s)return;let o=e.filterLayers(t.layers),n=e.targetLayer;n.props.pickable&&o.unshift(n),i.resize(s),this.render({...t,pickingFBO:i,pass:`terrain-cover-picking-${e.id}`,layers:o,effects:[],viewports:[s],cullRect:void 0,deviceRect:s,pickZ:!1})}getLayerParameters(e,t,i){let s;return this.drawParameters[e.id]?s=this.drawParameters[e.id]:(s=super.getLayerParameters(e,t,i),s.blend=!0),{...s,depthTest:!1}}};var Et=2048,Y=class{static isSupported(e){return e.isTextureFormatRenderable("rgba32float")}constructor(e){this.renderViewport=null,this.bounds=null,this.layers=[],this.layersBounds=[],this.layersBoundsCommon=null,this.lastViewport=null,this.device=e}getRenderFramebuffer(){return this.renderViewport?(this.fbo||(this.fbo=H(this.device,{id:"height-map",float:!0})),this.fbo):null}shouldUpdate({layers:e,viewport:t}){let i=e.length!==this.layers.length||e.some((o,n)=>o!==this.layers[n]||o.props.transitions||o.getBounds()!==this.layersBounds[n]);i&&(this.layers=e,this.layersBounds=e.map(o=>o.getBounds()),this.layersBoundsCommon=A(e,t));let s=!this.lastViewport||!t.equals(this.lastViewport);if(!this.layersBoundsCommon)this.renderViewport=null;else if(i||s){let o=M(this.layersBoundsCommon,t);if(o[2]<=o[0]||o[3]<=o[1])return this.renderViewport=null,!1;this.bounds=o,this.lastViewport=t;let n=t.scale,a=(o[2]-o[0])*n,l=(o[3]-o[1])*n;return this.renderViewport=a>0||l>0?E({bounds:[t.center[0]-1,t.center[1]-1,t.center[0]+1,t.center[1]+1],zoom:t.zoom,width:Math.min(a,Et),height:Math.min(l,Et),viewport:t}):null,!0}return!1}delete(){this.fbo&&(this.fbo.colorAttachments[0].delete(),this.fbo.delete())}};var me=class{constructor(){this.id="terrain-effect",this.props=null,this.useInPicking=!0,this.isPicking=!1,this.isDrapingEnabled=!1,this.terrainCovers=new Map}setup({device:e,deck:t}){this.dummyHeightMap=e.createTexture({width:1,height:1,data:new Uint8Array([0,0,0,0])}),this.terrainPass=new pe(e,{id:"terrain"}),this.terrainPickingPass=new de(e,{id:"terrain-picking"}),Y.isSupported(e)?this.heightMap=new Y(e):Mt.log.warn("Terrain offset mode is not supported by this browser")(),t._addDefaultShaderModule(W)}preRender(e){if(e.pickZ){this.isDrapingEnabled=!1;return}let{viewports:t}=e,i=e.pass.startsWith("picking");this.isPicking=i,this.isDrapingEnabled=!0;let s=t[0],o=(i?this.terrainPickingPass:this.terrainPass).getRenderableLayers(s,e),n=o.filter(l=>l.props.operation.includes("terrain"));if(n.length===0)return;i||o.filter(f=>f.state.terrainDrawMode==="offset").length>0&&this._updateHeightMap(n,s,e);let a=o.filter(l=>l.state.terrainDrawMode==="drape");this._updateTerrainCovers(n,a,s,e)}getModuleParameters(e){let{terrainDrawMode:t}=e.state;return{heightMap:this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture||null,heightMapBounds:this.heightMap?.bounds,dummyHeightMap:this.dummyHeightMap,terrainCover:this.isDrapingEnabled?this.terrainCovers.get(e.id):null,useTerrainHeightMap:t==="offset",terrainSkipRender:t==="drape"||!e.props.operation.includes("draw")}}cleanup({deck:e}){this.dummyHeightMap&&(this.dummyHeightMap.delete(),this.dummyHeightMap=void 0),this.heightMap&&(this.heightMap.delete(),this.heightMap=void 0);for(let t of this.terrainCovers.values())t.delete();this.terrainCovers.clear(),e._removeDefaultShaderModule(W)}_updateHeightMap(e,t,i){!this.heightMap||!this.heightMap.shouldUpdate({layers:e,viewport:t})||this.terrainPass.renderHeightMap(this.heightMap,{...i,layers:e,moduleParameters:{heightMapBounds:this.heightMap.bounds,dummyHeightMap:this.dummyHeightMap,devicePixelRatio:1,drawToTerrainHeightMap:!0}})}_updateTerrainCovers(e,t,i,s){let o={};for(let n of t)n.state.terrainCoverNeedsRedraw&&(o[n.id]=!0,n.state.terrainCoverNeedsRedraw=!1);for(let n of this.terrainCovers.values())n.isDirty=n.isDirty||n.shouldUpdate({layerNeedsRedraw:o});for(let n of e)this._updateTerrainCover(n,t,i,s);this.isPicking||this._pruneTerrainCovers()}_updateTerrainCover(e,t,i,s){let o=this.isPicking?this.terrainPickingPass:this.terrainPass,n=this.terrainCovers.get(e.id);n||(n=new _e(e),this.terrainCovers.set(e.id,n));try{let a=n.shouldUpdate({targetLayer:e,viewport:i,layers:t});(this.isPicking||n.isDirty||a)&&(o.renderTerrainCover(n,{...s,layers:t,moduleParameters:{dummyHeightMap:this.dummyHeightMap,terrainSkipRender:!1,devicePixelRatio:1}}),this.isPicking||(n.isDirty=!1))}catch(a){e.raiseError(a,`Error rendering terrain cover ${n.id}`)}}_pruneTerrainCovers(){let e=[];for(let[t,i]of this.terrainCovers)i.isActive||e.push(t);for(let t of e)this.terrainCovers.delete(t)}};var vi={terrainDrawMode:void 0},he=class extends Ft.LayerExtension{getShaders(){return{modules:[W]}}initializeState(){this.context.deck?._addDefaultEffect(new me)}updateState(e){let{props:t,oldProps:i}=e;if(this.state.terrainDrawMode&&t.terrainDrawMode===i.terrainDrawMode&&t.extruded===i.extruded)return;let{terrainDrawMode:s}=t;if(!s){let o=this.props.extruded,n=this.getAttributeManager()?.attributes,a=n&&"instancePositions"in n;s=o||a?"offset":"drape"}this.setState({terrainDrawMode:s})}onNeedsRedraw(){let e=this.state;e.terrainDrawMode==="drape"&&(e.terrainCoverNeedsRedraw=!0)}},K=he;(()=>{he.defaultProps=vi})(),(()=>{he.extensionName="TerrainExtension"})();return Bt(Z);})();
      return __exports__;
      });
