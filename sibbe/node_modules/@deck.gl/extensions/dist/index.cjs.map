{
  "version": 3,
  "sources": ["index.js", "brushing/brushing-extension.js", "brushing/shader-module.js", "data-filter/data-filter-extension.js", "data-filter/shader-module.js", "data-filter/aggregator.js", "fp64/fp64-extension.js", "fp64/project64.js", "fp64/project64.glsl.js", "path-style/path-style-extension.js", "path-style/shaders.glsl.js", "fill-style/fill-style-extension.js", "fill-style/shader-module.js", "clip/clip-extension.js", "collision-filter/collision-filter-extension.js", "collision-filter/shader-module.js", "collision-filter/collision-filter-effect.js", "collision-filter/collision-filter-pass.js", "mask/mask-extension.js", "mask/shader-module.js", "mask/mask-effect.js", "mask/mask-pass.js", "utils/projection-utils.js", "terrain/terrain-extension.js", "terrain/terrain-effect.js", "terrain/shader-module.js", "terrain/utils.js", "terrain/terrain-cover.js", "terrain/terrain-pass.js", "terrain/terrain-picking-pass.js", "terrain/height-map-builder.js"],
  "sourcesContent": ["export { default as BrushingExtension } from \"./brushing/brushing-extension.js\";\nexport { default as DataFilterExtension } from \"./data-filter/data-filter-extension.js\";\nexport { default as Fp64Extension } from \"./fp64/fp64-extension.js\";\nexport { default as PathStyleExtension } from \"./path-style/path-style-extension.js\";\nexport { default as FillStyleExtension } from \"./fill-style/fill-style-extension.js\";\nexport { default as ClipExtension } from \"./clip/clip-extension.js\";\nexport { default as CollisionFilterExtension } from \"./collision-filter/collision-filter-extension.js\";\nexport { default as MaskExtension } from \"./mask/mask-extension.js\";\nexport { default as _TerrainExtension } from \"./terrain/terrain-extension.js\";\n// Shader module\nexport { default as project64 } from \"./fp64/project64.js\";\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { LayerExtension } from '@deck.gl/core';\nimport shaderModule from \"./shader-module.js\";\nconst defaultProps = {\n    getBrushingTarget: { type: 'accessor', value: [0, 0] },\n    brushingTarget: 'source',\n    brushingEnabled: true,\n    brushingRadius: 10000\n};\n/** Adds GPU-based data brushing functionalities to layers. It allows the layer to show/hide objects based on the current pointer position. */\nexport default class BrushingExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'BrushingExtension'; }\n    getShaders() {\n        return {\n            modules: [shaderModule]\n        };\n    }\n    initializeState(context, extension) {\n        const attributeManager = this.getAttributeManager();\n        if (attributeManager) {\n            attributeManager.add({\n                brushingTargets: {\n                    size: 2,\n                    accessor: 'getBrushingTarget',\n                    shaderAttributes: {\n                        brushingTargets: {\n                            divisor: 0\n                        },\n                        instanceBrushingTargets: {\n                            divisor: 1\n                        }\n                    }\n                }\n            });\n        }\n        // Trigger redraw when mouse moves\n        const onMouseMove = () => {\n            this.getCurrentLayer()?.setNeedsRedraw();\n        };\n        // TODO - expose this in a better way\n        this.state.onMouseMove = onMouseMove;\n        if (context.deck) {\n            // @ts-expect-error (2446) accessing protected property\n            context.deck.eventManager.on({\n                pointermove: onMouseMove,\n                pointerleave: onMouseMove\n            });\n        }\n    }\n    finalizeState(context, extension) {\n        // Remove event listeners\n        if (context.deck) {\n            const onMouseMove = this.state.onMouseMove;\n            // @ts-expect-error (2446) accessing protected property\n            context.deck.eventManager.off({\n                pointermove: onMouseMove,\n                pointerleave: onMouseMove\n            });\n        }\n    }\n}\n", "import { project } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\nconst vs = `\nuniform bool brushing_enabled;\nuniform int brushing_target;\nuniform vec2 brushing_mousePos;\nuniform float brushing_radius;\n#ifdef NON_INSTANCED_MODEL\nin vec2 brushingTargets;\n#else\nin vec2 instanceBrushingTargets;\n#endif\nout float brushing_isVisible;\nbool brushing_isPointInRange(vec2 position) {\nif (!brushing_enabled) {\nreturn true;\n}\nvec2 source_commonspace = project_position(position);\nvec2 target_commonspace = project_position(brushing_mousePos);\nfloat distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\nreturn distance <= brushing_radius;\n}\nbool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\nreturn brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n}\nvoid brushing_setVisible(bool visible) {\nbrushing_isVisible = float(visible);\n}\n`;\nconst fs = `\nuniform bool brushing_enabled;\nin float brushing_isVisible;\n`;\nconst TARGET = {\n    source: 0,\n    target: 1,\n    custom: 2,\n    source_target: 3\n};\nconst inject = {\n    'vs:DECKGL_FILTER_GL_POSITION': `\nvec2 brushingTarget;\nvec2 brushingSource;\nif (brushing_target == 3) {\nbrushingTarget = geometry.worldPositionAlt.xy;\nbrushingSource = geometry.worldPosition.xy;\n} else if (brushing_target == 0) {\nbrushingTarget = geometry.worldPosition.xy;\n} else if (brushing_target == 1) {\nbrushingTarget = geometry.worldPositionAlt.xy;\n} else {\n#ifdef NON_INSTANCED_MODEL\nbrushingTarget = brushingTargets;\n#else\nbrushingTarget = instanceBrushingTargets;\n#endif\n}\nbool visible;\nif (brushing_target == 3) {\nvisible = brushing_arePointsInRange(brushingSource, brushingTarget);\n} else {\nvisible = brushing_isPointInRange(brushingTarget);\n}\nbrushing_setVisible(visible);\n`,\n    'fs:DECKGL_FILTER_COLOR': `\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\nexport default {\n    name: 'brushing',\n    dependencies: [project],\n    vs,\n    fs,\n    inject,\n    getUniforms: (opts) => {\n        if (!opts || !('viewport' in opts)) {\n            return {};\n        }\n        const { brushingEnabled = true, brushingRadius = 10000, brushingTarget = 'source', mousePosition, viewport } = opts;\n        return {\n            brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),\n            brushing_radius: brushingRadius,\n            brushing_target: TARGET[brushingTarget] || 0,\n            brushing_mousePos: mousePosition\n                ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])\n                : [0, 0]\n        };\n    }\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { _deepEqual as deepEqual, LayerExtension, log } from '@deck.gl/core';\nimport { shaderModule, shaderModule64 } from \"./shader-module.js\";\nimport * as aggregator from \"./aggregator.js\";\nconst defaultProps = {\n    getFilterValue: { type: 'accessor', value: 0 },\n    getFilterCategory: { type: 'accessor', value: 0 },\n    onFilteredItemsChange: { type: 'function', value: null, optional: true },\n    filterEnabled: true,\n    filterRange: [-1, 1],\n    filterSoftRange: null,\n    filterCategories: [0],\n    filterTransformSize: true,\n    filterTransformColor: true\n};\nconst defaultOptions = {\n    categorySize: 1,\n    filterSize: 1,\n    fp64: false,\n    countItems: false\n};\nconst DATA_TYPE_FROM_SIZE = {\n    1: 'float',\n    2: 'vec2',\n    3: 'vec3',\n    4: 'vec4'\n};\n/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */\nexport default class DataFilterExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'DataFilterExtension'; }\n    constructor(opts = {}) {\n        super({ ...defaultOptions, ...opts });\n    }\n    getShaders(extension) {\n        const { categorySize, filterSize, fp64 } = extension.opts;\n        return {\n            modules: [fp64 ? shaderModule64 : shaderModule],\n            defines: {\n                DATACATEGORY_TYPE: DATA_TYPE_FROM_SIZE[categorySize],\n                DATACATEGORY_CHANNELS: categorySize,\n                DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n                DATAFILTER_DOUBLE: Boolean(fp64)\n            }\n        };\n    }\n    initializeState(context, extension) {\n        const attributeManager = this.getAttributeManager();\n        const { categorySize, filterSize, fp64 } = extension.opts;\n        if (attributeManager) {\n            attributeManager.add({\n                filterValues: {\n                    size: filterSize,\n                    type: fp64 ? 'float64' : 'float32',\n                    accessor: 'getFilterValue',\n                    shaderAttributes: {\n                        filterValues: {\n                            divisor: 0\n                        },\n                        instanceFilterValues: {\n                            divisor: 1\n                        }\n                    }\n                },\n                filterCategoryValues: {\n                    size: categorySize,\n                    accessor: 'getFilterCategory',\n                    transform: categorySize === 1\n                        ? d => extension._getCategoryKey.call(this, d, 0)\n                        : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i)),\n                    shaderAttributes: {\n                        filterCategoryValues: {\n                            divisor: 0\n                        },\n                        instanceFilterCategoryValues: {\n                            divisor: 1\n                        }\n                    }\n                }\n            });\n        }\n        const { device } = this.context;\n        if (attributeManager && extension.opts.countItems) {\n            const useFloatTarget = aggregator.supportsFloatTarget(device);\n            // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text\n            // The vertex shader checks if a vertex has the same \"index\" as the previous vertex\n            // so that we only write one count cross multiple vertices of the same object\n            attributeManager.add({\n                filterIndices: {\n                    size: useFloatTarget ? 1 : 2,\n                    vertexOffset: 1,\n                    type: 'unorm8',\n                    accessor: (object, { index }) => {\n                        const i = object && object.__source ? object.__source.index : index;\n                        return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];\n                    },\n                    shaderAttributes: {\n                        filterPrevIndices: {\n                            vertexOffset: 0\n                        },\n                        filterIndices: {\n                            vertexOffset: 1\n                        }\n                    }\n                }\n            });\n            const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);\n            const filterModel = aggregator.getModel(device, extension.getShaders.call(this, extension), useFloatTarget);\n            this.setState({ filterFBO, filterModel });\n        }\n    }\n    updateState({ props, oldProps, changeFlags }, extension) {\n        const attributeManager = this.getAttributeManager();\n        const { categorySize } = extension.opts;\n        if (this.state.filterModel) {\n            const filterNeedsUpdate = \n            // attributeManager must be defined for filterModel to be set\n            attributeManager.attributes.filterValues.needsUpdate() ||\n                attributeManager.attributes.filterCategoryValues?.needsUpdate() ||\n                props.filterEnabled !== oldProps.filterEnabled ||\n                props.filterRange !== oldProps.filterRange ||\n                props.filterSoftRange !== oldProps.filterSoftRange ||\n                props.filterCategories !== oldProps.filterCategories;\n            if (filterNeedsUpdate) {\n                this.setState({ filterNeedsUpdate });\n            }\n        }\n        if (attributeManager?.attributes.filterCategoryValues) {\n            // Update bitmask if accessor or selected categories has changed\n            const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() ||\n                !deepEqual(props.filterCategories, oldProps.filterCategories, 2);\n            if (categoryBitMaskNeedsUpdate) {\n                this.setState({ categoryBitMaskNeedsUpdate });\n            }\n            // Need to recreate category map if categorySize has changed\n            const resetCategories = changeFlags.dataChanged;\n            if (resetCategories) {\n                this.setState({\n                    categoryMap: Array(categorySize)\n                        .fill(0)\n                        .map(() => ({}))\n                });\n                attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');\n            }\n        }\n    }\n    draw(params, extension) {\n        const filterFBO = this.state.filterFBO;\n        const filterModel = this.state.filterModel;\n        const filterNeedsUpdate = this.state.filterNeedsUpdate;\n        const categoryBitMaskNeedsUpdate = this.state.categoryBitMaskNeedsUpdate;\n        const { onFilteredItemsChange } = this.props;\n        if (categoryBitMaskNeedsUpdate) {\n            extension._updateCategoryBitMask.call(this, params, extension);\n        }\n        if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {\n            const { attributes: { filterValues, filterCategoryValues, filterIndices } } = this.getAttributeManager();\n            filterModel.setVertexCount(this.getNumInstances());\n            this.context.device.clearWebGL({ framebuffer: filterFBO, color: [0, 0, 0, 0] });\n            filterModel.updateModuleSettings(params.moduleParameters);\n            // @ts-expect-error filterValue and filterIndices should always have buffer value\n            filterModel.setAttributes({\n                ...filterValues.getValue(),\n                ...filterCategoryValues?.getValue(),\n                ...filterIndices?.getValue()\n            });\n            filterModel.setUniforms(params.uniforms);\n            filterModel.device.withParametersWebGL({\n                framebuffer: filterFBO,\n                // ts-ignore 'readonly' cannot be assigned to the mutable type '[GLBlendEquation, GLBlendEquation]'\n                ...aggregator.parameters,\n                viewport: [0, 0, filterFBO.width, filterFBO.height]\n            }, () => {\n                filterModel.draw(this.context.renderPass);\n            });\n            const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);\n            let count = 0;\n            for (let i = 0; i < color.length; i++) {\n                count += color[i];\n            }\n            onFilteredItemsChange({ id: this.id, count });\n            this.state.filterNeedsUpdate = false;\n        }\n    }\n    finalizeState() {\n        const filterFBO = this.state.filterFBO;\n        const filterModel = this.state.filterModel;\n        // filterFBO.color.delete();\n        filterFBO?.destroy();\n        filterModel?.destroy();\n    }\n    /**\n     * Updates the bitmask used on the GPU to perform the filter based on the\n     * `filterCategories` prop. The mapping between categories and bit in the bitmask\n     * is performed by `_getCategoryKey()`\n     */\n    _updateCategoryBitMask(params, extension) {\n        const { categorySize } = extension.opts;\n        const { filterCategories } = this.props;\n        const categoryBitMask = new Uint32Array([0, 0, 0, 0]);\n        const categoryFilters = (categorySize === 1 ? [filterCategories] : filterCategories);\n        const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;\n        for (let c = 0; c < categoryFilters.length; c++) {\n            const categoryFilter = categoryFilters[c];\n            for (const category of categoryFilter) {\n                const key = extension._getCategoryKey.call(this, category, c);\n                if (key < maxCategories) {\n                    const channel = c * (maxCategories / 32) + Math.floor(key / 32);\n                    categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30\n                }\n                else {\n                    log.warn(`Exceeded maximum number of categories (${maxCategories})`)();\n                }\n            }\n        }\n        /* eslint-disable-next-line camelcase */\n        params.uniforms.filter_categoryBitMask = categoryBitMask;\n        this.state.categoryBitMaskNeedsUpdate = false;\n    }\n    /**\n     * Returns an index of bit in the bitmask for a given category. If the category has\n     * not yet been assigned a bit, a new one is assigned.\n     */\n    _getCategoryKey(category, channel) {\n        const categoryMap = this.state.categoryMap[channel];\n        if (!(category in categoryMap)) {\n            categoryMap[category] = Object.keys(categoryMap).length;\n        }\n        return categoryMap[category];\n    }\n}\n", "import { glsl } from \"../utils/syntax-tags.js\";\n/*\n * data filter shader module\n */\nconst vs = `\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\nuniform ivec4 filter_categoryBitMask;\n#ifdef NON_INSTANCED_MODEL\n#define DATAFILTER_ATTRIB filterValues\n#define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#define DATACATEGORY_ATTRIB filterCategoryValues\n#else\n#define DATAFILTER_ATTRIB instanceFilterValues\n#define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#define DATACATEGORY_ATTRIB instanceFilterCategoryValues\n#endif\nin DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\nin DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\nuniform DATAFILTER_TYPE filter_min64High;\nuniform DATAFILTER_TYPE filter_max64High;\n#endif\nin DATACATEGORY_TYPE DATACATEGORY_ATTRIB;\nout float dataFilter_value;\nfloat dataFilter_reduceValue(float value) {\nreturn value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\nreturn min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\nreturn min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\nreturn min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax, DATACATEGORY_TYPE category) {\nif (filter_enabled) {\nif (filter_useSoftMargin) {\ndataFilter_value = dataFilter_reduceValue(\nsmoothstep(filter_min, filter_softMin, valueFromMin) *\n(1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n);\n} else {\ndataFilter_value = dataFilter_reduceValue(\nstep(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n);\n}\n#if DATACATEGORY_CHANNELS == 1\nint dataFilter_masks = filter_categoryBitMask[int(category / 32.0)];\n#elif DATACATEGORY_CHANNELS == 2\nivec2 dataFilter_masks = ivec2(\nfilter_categoryBitMask[int(category.x / 32.0)],\nfilter_categoryBitMask[int(category.y / 32.0) + 2]\n);\n#elif DATACATEGORY_CHANNELS == 3\nivec3 dataFilter_masks = filter_categoryBitMask.xyz;\n#else\nivec4 dataFilter_masks = filter_categoryBitMask;\n#endif\nDATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) / pow(DATACATEGORY_TYPE(2.0), mod(category, 32.0));\ndataFilter_bits = mod(floor(dataFilter_bits), 2.0);\n#if DATACATEGORY_CHANNELS == 1\nif(dataFilter_bits == 0.0) dataFilter_value = 0.0;\n#else\nif(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0.0)))) dataFilter_value = 0.0;\n#endif\n} else {\ndataFilter_value = 1.0;\n}\n}\n`;\nconst fs = `\nuniform bool filter_transformColor;\nin float dataFilter_value;\n`;\n/* eslint-disable camelcase */\nfunction getUniforms(opts) {\n    if (!opts || !('extensions' in opts)) {\n        return {};\n    }\n    const { filterRange = [-1, 1], filterEnabled = true, filterTransformSize = true, filterTransformColor = true } = opts;\n    const filterSoftRange = opts.filterSoftRange || filterRange;\n    return {\n        ...(Number.isFinite(filterRange[0])\n            ? {\n                filter_min: filterRange[0],\n                filter_softMin: filterSoftRange[0],\n                filter_softMax: filterSoftRange[1],\n                filter_max: filterRange[1]\n            }\n            : {\n                filter_min: filterRange.map(r => r[0]),\n                filter_softMin: filterSoftRange.map(r => r[0]),\n                filter_softMax: filterSoftRange.map(r => r[1]),\n                filter_max: filterRange.map(r => r[1])\n            }),\n        filter_enabled: filterEnabled,\n        filter_useSoftMargin: Boolean(opts.filterSoftRange),\n        filter_transformSize: filterEnabled && filterTransformSize,\n        filter_transformColor: filterEnabled && filterTransformColor\n    };\n}\nfunction getUniforms64(opts) {\n    if (!opts || !('extensions' in opts)) {\n        return {};\n    }\n    const uniforms = getUniforms(opts);\n    if (Number.isFinite(uniforms.filter_min)) {\n        const min64High = Math.fround(uniforms.filter_min);\n        uniforms.filter_min -= min64High;\n        uniforms.filter_softMin -= min64High;\n        uniforms.filter_min64High = min64High;\n        const max64High = Math.fround(uniforms.filter_max);\n        uniforms.filter_max -= max64High;\n        uniforms.filter_softMax -= max64High;\n        uniforms.filter_max64High = max64High;\n    }\n    else {\n        const min64High = uniforms.filter_min.map(Math.fround);\n        uniforms.filter_min = uniforms.filter_min.map((x, i) => x - min64High[i]);\n        uniforms.filter_softMin = uniforms.filter_softMin.map((x, i) => x - min64High[i]);\n        uniforms.filter_min64High = min64High;\n        const max64High = uniforms.filter_max.map(Math.fround);\n        uniforms.filter_max = uniforms.filter_max.map((x, i) => x - max64High[i]);\n        uniforms.filter_softMax = uniforms.filter_softMax.map((x, i) => x - max64High[i]);\n        uniforms.filter_max64High = max64High;\n    }\n    return uniforms;\n}\nconst inject = {\n    'vs:#main-start': `\n#ifdef DATAFILTER_DOUBLE\ndataFilter_setValue(\nDATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\nDATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW,\nDATACATEGORY_ATTRIB\n);\n#else\ndataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB, DATACATEGORY_ATTRIB);\n#endif\n`,\n    'vs:#main-end': `\nif (dataFilter_value == 0.0) {\ngl_Position = vec4(0.);\n}\n`,\n    'vs:DECKGL_FILTER_SIZE': `\nif (filter_transformSize) {\nsize = size * dataFilter_value;\n}\n`,\n    'fs:DECKGL_FILTER_COLOR': `\nif (dataFilter_value == 0.0) discard;\nif (filter_transformColor) {\ncolor.a *= dataFilter_value;\n}\n`\n};\nexport const shaderModule = {\n    name: 'data-filter',\n    vs,\n    fs,\n    inject,\n    getUniforms\n};\nexport const shaderModule64 = {\n    name: 'data-filter-fp64',\n    vs,\n    fs,\n    inject,\n    getUniforms: getUniforms64\n};\n", "import { Model } from '@luma.gl/engine';\nimport { GL } from '@luma.gl/constants';\nconst AGGREGATE_VS = `\\\n#version 300 es\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  in float filterIndices;\n  in float filterPrevIndices;\n#else\n  in vec2 filterIndices;\n  in vec2 filterPrevIndices;\n#endif\n\nout vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n`;\nconst AGGREGATE_FS = `\\\n#version 300 es\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  fragColor = vColor;\n}\n`;\nconst FLOAT_TARGET_FEATURES = [\n    'float32-renderable-webgl', // ability to render to float texture\n    'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\nexport function supportsFloatTarget(device) {\n    return FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n}\n// A 1x1 framebuffer object that encodes the total count of filtered items\nexport function getFramebuffer(device, useFloatTarget) {\n    if (useFloatTarget) {\n        return device.createFramebuffer({\n            width: 1,\n            height: 1,\n            colorAttachments: [\n                device.createTexture({\n                    format: 'rgba32float',\n                    type: 5126,\n                    mipmaps: false\n                })\n            ]\n        });\n    }\n    return device.createFramebuffer({\n        width: 256,\n        height: 64,\n        colorAttachments: [device.createTexture({ format: 'rgba8unorm', type: 5126, mipmaps: false })]\n    });\n}\n// Increments the counter based on dataFilter_value\nexport function getModel(device, shaderOptions, useFloatTarget) {\n    shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n    if (useFloatTarget) {\n        shaderOptions.defines.FLOAT_TARGET = 1;\n    }\n    return new Model(device, {\n        id: 'data-filter-aggregation-model',\n        vertexCount: 1,\n        isInstanced: false,\n        drawMode: 0,\n        vs: AGGREGATE_VS,\n        fs: AGGREGATE_FS,\n        ...shaderOptions\n    });\n}\nexport const parameters = {\n    blend: true,\n    blendFunc: [1, 1, 1, 1],\n    blendEquation: [32774, 32774],\n    depthTest: false\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { LayerExtension, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport project64 from \"./project64.js\";\n/** @deprecated Adds the legacy 64-bit precision to geospatial layers. */\nexport default class Fp64Extension extends LayerExtension {\n    static { this.extensionName = 'Fp64Extension'; }\n    getShaders() {\n        const { coordinateSystem } = this.props;\n        if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT &&\n            coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {\n            throw new Error('fp64: coordinateSystem must be LNGLAT');\n        }\n        return {\n            modules: [project64]\n        };\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable camelcase */\nimport { fp64 } from '@luma.gl/shadertools';\nconst { fp64ify, fp64ifyMatrix4 } = fp64;\nimport { project, _memoize as memoize } from '@deck.gl/core';\nimport project64Shader from \"./project64.glsl.js\";\nexport default {\n    name: 'project64',\n    dependencies: [project, fp64],\n    vs: project64Shader,\n    getUniforms\n};\n// TODO - this module should calculate the 64 bit uniforms\n// It is currently done by project to minimize duplicated work\nconst getMemoizedUniforms = memoize(calculateUniforms);\nfunction getUniforms(opts) {\n    if (opts && 'viewport' in opts) {\n        const { viewProjectionMatrix, scale } = opts.viewport;\n        // We only need to update fp64 uniforms if fp32 projection is being updated\n        return getMemoizedUniforms({ viewProjectionMatrix, scale });\n    }\n    return {};\n}\nfunction calculateUniforms({ viewProjectionMatrix, scale }) {\n    const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);\n    const scaleFP64 = fp64ify(scale);\n    return {\n        project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,\n        project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,\n        project64_uScale: scaleFP64\n    };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default `\\\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n#if defined(NVIDIA_FP64_WORKAROUND)\nout_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\nout_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\nout_val[1] = sum_fp64(PI_FP64,\nlog_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\nreturn;\n}\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\nvec2 pos_fp64[2];\nmercatorProject_fp64(position_fp64, pos_fp64);\nout_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\nout_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\nreturn;\n}\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\nvec4 position64xy = vec4(\nposition.x, position64xyLow.x,\nposition.y, position64xyLow.y);\nproject_position_fp64(position64xy, out_val);\n}\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\nvec2 vertex_pos_clipspace[4];\nmat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\nvertex_pos_clipspace);\nreturn vec4(\nvertex_pos_clipspace[0].x,\nvertex_pos_clipspace[1].x,\nvertex_pos_clipspace[2].x,\nvertex_pos_clipspace[3].x\n);\n}\nvec4 project_position_to_clipspace(\nvec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\nvec2 offset64[4];\nvec4_fp64(vec4(offset, 0.0), offset64);\nfloat z = project_size(position.z);\nvec2 projectedPosition64xy[2];\nproject_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\nvec2 commonPosition64[4];\ncommonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\ncommonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\ncommonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\ncommonPosition64[3] = vec2(1.0, 0.0);\ncommonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\nreturn project_common_position_to_clipspace_fp64(commonPosition64);\n}\nvec4 project_position_to_clipspace(\nvec3 position, vec3 position64xyLow, vec3 offset\n) {\nvec4 commonPosition;\nreturn project_position_to_clipspace(\nposition, position64xyLow, offset, commonPosition\n);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { vec3 } from '@math.gl/core';\nimport { dashShaders, offsetShaders } from \"./shaders.glsl.js\";\nconst defaultProps = {\n    getDashArray: { type: 'accessor', value: [0, 0] },\n    getOffset: { type: 'accessor', value: 0 },\n    dashJustified: false,\n    dashGapPickable: false\n};\n/** Adds selected features to the `PathLayer` and composite layers that render the `PathLayer`. */\nexport default class PathStyleExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'PathStyleExtension'; }\n    constructor({ dash = false, offset = false, highPrecisionDash = false } = {}) {\n        super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });\n    }\n    isEnabled(layer) {\n        return 'pathTesselator' in layer.state;\n    }\n    getShaders(extension) {\n        if (!extension.isEnabled(this)) {\n            return null;\n        }\n        // Merge shader injection\n        let result = {};\n        if (extension.opts.dash) {\n            result = mergeShaders(result, dashShaders);\n        }\n        if (extension.opts.offset) {\n            result = mergeShaders(result, offsetShaders);\n        }\n        return result;\n    }\n    initializeState(context, extension) {\n        const attributeManager = this.getAttributeManager();\n        if (!attributeManager || !extension.isEnabled(this)) {\n            // This extension only works with the PathLayer\n            return;\n        }\n        if (extension.opts.dash) {\n            attributeManager.addInstanced({\n                instanceDashArrays: { size: 2, accessor: 'getDashArray' },\n                instanceDashOffsets: extension.opts.highPrecisionDash\n                    ? {\n                        size: 1,\n                        accessor: 'getPath',\n                        transform: extension.getDashOffsets.bind(this)\n                    }\n                    : {\n                        size: 1,\n                        update: attribute => {\n                            attribute.constant = true;\n                            attribute.value = [0];\n                        }\n                    }\n            });\n        }\n        if (extension.opts.offset) {\n            attributeManager.addInstanced({\n                instanceOffsets: { size: 1, accessor: 'getOffset' }\n            });\n        }\n    }\n    updateState(params, extension) {\n        if (!extension.isEnabled(this)) {\n            return;\n        }\n        const uniforms = {};\n        if (extension.opts.dash) {\n            uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n            uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n        }\n        this.state.model?.setUniforms(uniforms);\n    }\n    getDashOffsets(path) {\n        const result = [0];\n        const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n        const isNested = Array.isArray(path[0]);\n        const geometrySize = isNested ? path.length : path.length / positionSize;\n        let p;\n        let prevP;\n        for (let i = 0; i < geometrySize - 1; i++) {\n            p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n            p = this.projectPosition(p);\n            if (i > 0) {\n                result[i] = result[i - 1] + vec3.dist(prevP, p);\n            }\n            prevP = p;\n        }\n        result[geometrySize - 1] = 0;\n        return result;\n    }\n}\n", "export const dashShaders = {\n    inject: {\n        'vs:#decl': `\nin vec2 instanceDashArrays;\nin float instanceDashOffsets;\nout vec2 vDashArray;\nout float vDashOffset;\n`,\n        'vs:#main-end': `\nvDashArray = instanceDashArrays;\nvDashOffset = instanceDashOffsets / width.x;\n`,\n        'fs:#decl': `\nuniform float dashAlignMode;\nuniform float capType;\nuniform bool dashGapPickable;\nin vec2 vDashArray;\nin float vDashOffset;\n`,\n        // if given position is in the gap part of the dashed line\n        // dashArray.x: solid stroke length, relative to width\n        // dashArray.y: gap length, relative to width\n        // alignMode:\n        // 0 - no adjustment\n        // o----     ----     ----     ---- o----     -o----     ----     o\n        // 1 - stretch to fit, draw half dash at each end for nicer joints\n        // o--    ----    ----    ----    --o--      --o--     ----     --o\n        'fs:#main-start': `\nfloat solidLength = vDashArray.x;\nfloat gapLength = vDashArray.y;\nfloat unitLength = solidLength + gapLength;\nfloat offset;\nif (unitLength > 0.0) {\nif (dashAlignMode == 0.0) {\noffset = vDashOffset;\n} else {\nunitLength = vPathLength / round(vPathLength / unitLength);\noffset = solidLength / 2.0;\n}\nfloat unitOffset = mod(vPathPosition.y + offset, unitLength);\nif (gapLength > 0.0 && unitOffset > solidLength) {\nif (capType <= 0.5) {\nif (!(dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n} else {\nfloat distToEnd = length(vec2(\nmin(unitOffset - solidLength, unitLength - unitOffset),\nvPathPosition.x\n));\nif (distToEnd > 1.0) {\nif (!(dashGapPickable && bool(picking.isActive))) {\ndiscard;\n}\n}\n}\n}\n}\n`\n    }\n};\nexport const offsetShaders = {\n    inject: {\n        'vs:#decl': `\nin float instanceOffsets;\n`,\n        'vs:DECKGL_FILTER_SIZE': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nsize *= offsetWidth;\n`,\n        'vs:#main-end': `\nfloat offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\nfloat offsetDir = sign(instanceOffsets);\nvPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;\nvPathPosition.y *= offsetWidth;\nvPathLength *= offsetWidth;\n`,\n        'fs:#main-start': `\nfloat isInside;\nisInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\nif (isInside == 0.0) {\ndiscard;\n}\n`\n    }\n};\n", "import { LayerExtension } from '@deck.gl/core';\nimport { patternShaders } from \"./shader-module.js\";\nconst defaultProps = {\n    fillPatternEnabled: true,\n    fillPatternAtlas: {\n        type: 'image',\n        value: null,\n        async: true,\n        parameters: { lodMaxClamp: 0 }\n    },\n    fillPatternMapping: { type: 'object', value: {}, async: true },\n    fillPatternMask: true,\n    getFillPattern: { type: 'accessor', value: d => d.pattern },\n    getFillPatternScale: { type: 'accessor', value: 1 },\n    getFillPatternOffset: { type: 'accessor', value: [0, 0] }\n};\n/** Adds selected features to layers that render a \"fill\", such as the `PolygonLayer` and `ScatterplotLayer`. */\nexport default class FillStyleExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'FillStyleExtension'; }\n    constructor({ pattern = false } = {}) {\n        super({ pattern });\n    }\n    isEnabled(layer) {\n        return layer.getAttributeManager() !== null && !('pathTesselator' in layer.state);\n    }\n    getShaders(extension) {\n        if (!extension.isEnabled(this)) {\n            return null;\n        }\n        return {\n            modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n        };\n    }\n    initializeState(context, extension) {\n        if (!extension.isEnabled(this)) {\n            return;\n        }\n        const attributeManager = this.getAttributeManager();\n        if (extension.opts.pattern) {\n            attributeManager.add({\n                fillPatternFrames: {\n                    size: 4,\n                    accessor: 'getFillPattern',\n                    transform: extension.getPatternFrame.bind(this),\n                    shaderAttributes: {\n                        fillPatternFrames: {\n                            divisor: 0\n                        },\n                        instanceFillPatternFrames: {\n                            divisor: 1\n                        }\n                    }\n                },\n                fillPatternScales: {\n                    size: 1,\n                    accessor: 'getFillPatternScale',\n                    defaultValue: 1,\n                    shaderAttributes: {\n                        fillPatternScales: {\n                            divisor: 0\n                        },\n                        instanceFillPatternScales: {\n                            divisor: 1\n                        }\n                    }\n                },\n                fillPatternOffsets: {\n                    size: 2,\n                    accessor: 'getFillPatternOffset',\n                    shaderAttributes: {\n                        fillPatternOffsets: {\n                            divisor: 0\n                        },\n                        instanceFillPatternOffsets: {\n                            divisor: 1\n                        }\n                    }\n                }\n            });\n        }\n        this.setState({\n            emptyTexture: this.context.device.createTexture({\n                data: new Uint8Array(4),\n                width: 1,\n                height: 1\n            })\n        });\n    }\n    updateState({ props, oldProps }, extension) {\n        if (!extension.isEnabled(this)) {\n            return;\n        }\n        if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n            this.getAttributeManager().invalidate('getFillPattern');\n        }\n    }\n    draw(params, extension) {\n        if (!extension.isEnabled(this)) {\n            return;\n        }\n        const { fillPatternAtlas } = this.props;\n        this.setModuleParameters({\n            fillPatternTexture: fillPatternAtlas || this.state.emptyTexture\n        });\n    }\n    finalizeState() {\n        const emptyTexture = this.state.emptyTexture;\n        emptyTexture?.delete();\n    }\n    getPatternFrame(name) {\n        const { fillPatternMapping } = this.getCurrentLayer().props;\n        const def = fillPatternMapping && fillPatternMapping[name];\n        return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n    }\n}\n", "import { project, fp64LowPart } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\n/*\n * fill pattern shader module\n */\nconst patternVs = `\n#ifdef NON_INSTANCED_MODEL\n#define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n#define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n#define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n#define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n#define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n#define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\nin vec4 FILL_PATTERN_FRAME_ATTRIB;\nin float FILL_PATTERN_SCALE_ATTRIB;\nin vec2 FILL_PATTERN_OFFSET_ATTRIB;\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\nout vec2 fill_uv;\nout vec4 fill_patternBounds;\nout vec4 fill_patternPlacement;\n`;\nconst patternFs = `\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\nuniform vec2 fill_uvCoordinateOrigin64Low;\nin vec4 fill_patternBounds;\nin vec4 fill_patternPlacement;\nin vec2 fill_uv;\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n`;\nconst inject = {\n    'vs:DECKGL_FILTER_GL_POSITION': `\nfill_uv = geometry.position.xy;\n`,\n    'vs:DECKGL_FILTER_COLOR': `\nif (fill_patternEnabled) {\nfill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\nfill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\nfill_patternPlacement.zw = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.zw;\n}\n`,\n    'fs:DECKGL_FILTER_COLOR': `\nif (fill_patternEnabled) {\nvec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;\nvec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uvCoordinateOrigin64Low + fill_uv, scale) / scale;\npatternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\nvec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\nvec4 patternColor = texture(fill_patternTexture, texCoords);\ncolor.a *= patternColor.a;\nif (!fill_patternMask) {\ncolor.rgb = patternColor.rgb;\n}\n}\n`\n};\n/* eslint-disable camelcase */\nfunction getPatternUniforms(opts, uniforms) {\n    if (!opts) {\n        return {};\n    }\n    if ('fillPatternTexture' in opts) {\n        const { fillPatternTexture } = opts;\n        return {\n            fill_patternTexture: fillPatternTexture,\n            fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]\n        };\n    }\n    if ('viewport' in opts) {\n        const { fillPatternMask = true, fillPatternEnabled = true } = opts;\n        const { project_uCommonOrigin: coordinateOriginCommon } = uniforms;\n        const coordinateOriginCommon64Low = [\n            fp64LowPart(coordinateOriginCommon[0]),\n            fp64LowPart(coordinateOriginCommon[1])\n        ];\n        return {\n            fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),\n            fill_uvCoordinateOrigin64Low: coordinateOriginCommon64Low,\n            fill_patternMask: fillPatternMask,\n            fill_patternEnabled: fillPatternEnabled\n        };\n    }\n    return {};\n}\nexport const patternShaders = {\n    name: 'fill-pattern',\n    vs: patternVs,\n    fs: patternFs,\n    inject,\n    dependencies: [project],\n    getUniforms: getPatternUniforms\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { LayerExtension } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\nconst defaultProps = {\n    clipBounds: [0, 0, 1, 1],\n    clipByInstance: undefined\n};\nconst shaderFunction = `\nuniform vec4 clip_bounds;\nbool clip_isInBounds(vec2 position) {\nreturn position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n`;\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs = {\n    name: 'clip-vs',\n    vs: shaderFunction\n};\nconst injectionVs = {\n    'vs:#decl': `\nout float clip_isVisible;\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\nclip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));\n`,\n    'fs:#decl': `\nin float clip_isVisible;\n`,\n    'fs:DECKGL_FILTER_COLOR': `\nif (clip_isVisible < 0.5) discard;\n`\n};\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds\n */\nconst shaderModuleFs = {\n    name: 'clip-fs',\n    fs: shaderFunction\n};\nconst injectionFs = {\n    'vs:#decl': `\nout vec2 clip_commonPosition;\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\nclip_commonPosition = geometry.position.xy;\n`,\n    'fs:#decl': `\nin vec2 clip_commonPosition;\n`,\n    'fs:DECKGL_FILTER_COLOR': `\nif (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n/** Adds support for clipping rendered layers by rectangular bounds. */\nexport default class ClipExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'ClipExtension'; }\n    getShaders() {\n        // If `clipByInstance: true`, the entire object is shown/hidden based on its anchor position (done by vertex shader)\n        // Otherwise, the object is trimmed by the clip bounds (done by fragment shader)\n        // Default behavior: consider a layer instanced if it has attribute `instancePositions`\n        let clipByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n        // Users can override by setting the `clipByInstance` prop\n        if (this.props.clipByInstance !== undefined) {\n            clipByInstance = Boolean(this.props.clipByInstance);\n        }\n        this.state.clipByInstance = clipByInstance;\n        return clipByInstance\n            ? {\n                modules: [shaderModuleVs],\n                inject: injectionVs\n            }\n            : {\n                modules: [shaderModuleFs],\n                inject: injectionFs\n            };\n    }\n    /* eslint-disable camelcase */\n    draw({ uniforms }) {\n        const { clipBounds } = this.props;\n        if (this.state.clipByInstance) {\n            uniforms.clip_bounds = clipBounds;\n        }\n        else {\n            const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n            const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n            uniforms.clip_bounds = [\n                Math.min(corner0[0], corner1[0]),\n                Math.min(corner0[1], corner1[1]),\n                Math.max(corner0[0], corner1[0]),\n                Math.max(corner0[1], corner1[1])\n            ];\n        }\n    }\n}\n", "import { LayerExtension } from '@deck.gl/core';\nimport collision from \"./shader-module.js\";\nimport CollisionFilterEffect from \"./collision-filter-effect.js\";\nconst defaultProps = {\n    getCollisionPriority: { type: 'accessor', value: 0 },\n    collisionEnabled: true,\n    collisionGroup: { type: 'string', value: 'default' },\n    collisionTestProps: {}\n};\n/** Allows layers to hide overlapping objects. */\nexport default class CollisionFilterExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'CollisionFilterExtension'; }\n    getShaders() {\n        return { modules: [collision] };\n    }\n    /* eslint-disable camelcase */\n    draw({ uniforms, context, moduleParameters }) {\n        const { collisionEnabled } = this.props;\n        const { collisionFBO, drawToCollisionMap } = moduleParameters;\n        const enabled = collisionEnabled && Boolean(collisionFBO);\n        uniforms.collision_enabled = enabled;\n        if (drawToCollisionMap) {\n            // Override any props with those defined in collisionTestProps\n            // @ts-ignore\n            this.props = this.clone(this.props.collisionTestProps).props;\n        }\n    }\n    initializeState(context, extension) {\n        if (this.getAttributeManager() === null) {\n            return;\n        }\n        this.context.deck?._addDefaultEffect(new CollisionFilterEffect());\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            collisionPriorities: {\n                size: 1,\n                accessor: 'getCollisionPriority',\n                shaderAttributes: {\n                    collisionPriorities: { divisor: 0 },\n                    instanceCollisionPriorities: { divisor: 1 }\n                }\n            }\n        });\n    }\n    getNeedsPickingBuffer() {\n        return this.props.collisionEnabled;\n    }\n}\n", "import { project } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\nconst vs = `\n#ifdef NON_INSTANCED_MODEL\nin float collisionPriorities;\n#else\nin float instanceCollisionPriorities;\n#endif\nuniform sampler2D collision_texture;\nuniform bool collision_sort;\nuniform bool collision_enabled;\nvec2 collision_getCoords(vec4 position) {\nvec4 collision_clipspace = project_common_position_to_clipspace(position);\nreturn (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;\n}\nfloat collision_match(vec2 tex, vec3 pickingColor) {\nvec4 collision_pickingColor = texture(collision_texture, tex);\nfloat delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));\nfloat e = 0.001;\nreturn step(delta, e);\n}\nfloat collision_isVisible(vec2 texCoords, vec3 pickingColor) {\nif (!collision_enabled) {\nreturn 1.0;\n}\nconst int N = 2;\nfloat accumulator = 0.0;\nvec2 step = vec2(1.0 / project_uViewportSize);\nconst float floatN = float(N);\nvec2 delta = -floatN * step;\nfor(int i = -N; i <= N; i++) {\ndelta.x = -step.x * floatN;\nfor(int j = -N; j <= N; j++) {\naccumulator += collision_match(texCoords + delta, pickingColor);\ndelta.x += step.x;\n}\ndelta.y += step.y;\n}\nfloat W = 2.0 * floatN + 1.0;\nreturn pow(accumulator / (W * W), 2.2);\n}\n`;\nconst inject = {\n    'vs:#decl': `\nfloat collision_fade = 1.0;\n`,\n    'vs:DECKGL_FILTER_GL_POSITION': `\nif (collision_sort) {\n#ifdef NON_INSTANCED_MODEL\nfloat collisionPriority = collisionPriorities;\n#else\nfloat collisionPriority = instanceCollisionPriorities;\n#endif\nposition.z = -0.001 * collisionPriority * position.w;\n}\nif (collision_enabled) {\nvec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));\nvec2 collision_texCoords = collision_getCoords(collision_common_position);\ncollision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);\nif (collision_fade < 0.0001) {\nposition = vec4(0.0, 0.0, 2.0, 1.0);\n}\n}\n`,\n    'vs:DECKGL_FILTER_COLOR': `\ncolor.a *= collision_fade;\n`\n};\nconst getCollisionUniforms = (opts, uniforms) => {\n    if (!opts || !('dummyCollisionMap' in opts)) {\n        return {};\n    }\n    const { collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;\n    return {\n        collision_sort: Boolean(drawToCollisionMap),\n        // @ts-ignore (v9 not sure why this isn't allowed now)\n        collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap\n    };\n};\n// @ts-expect-error\nexport default {\n    name: 'collision',\n    dependencies: [project],\n    vs,\n    inject,\n    getUniforms: getCollisionUniforms\n};\n", "import { equals } from '@math.gl/core';\nimport { _deepEqual as deepEqual } from '@deck.gl/core';\nimport CollisionFilterPass from \"./collision-filter-pass.js\";\n// Factor by which to downscale Collision FBO relative to canvas\nconst DOWNSCALE = 2;\nexport default class CollisionFilterEffect {\n    constructor() {\n        this.id = 'collision-filter-effect';\n        this.props = null;\n        this.useInPicking = true;\n        this.order = 1;\n        this.channels = {};\n        this.collisionFBOs = {};\n    }\n    setup(context) {\n        this.context = context;\n        const { device } = context;\n        this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });\n        this.collisionFilterPass = new CollisionFilterPass(device, { id: 'default-collision-filter' });\n    }\n    preRender({ effects: allEffects, layers, layerFilter, viewports, onViewportActive, views, isPicking, preRenderStats = {} }) {\n        // This can only be called in preRender() after setup() where context is populated\n        const { device } = this.context;\n        if (isPicking) {\n            // Do not update on picking pass\n            return;\n        }\n        const collisionLayers = layers.filter(\n        // @ts-ignore\n        ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled);\n        if (collisionLayers.length === 0) {\n            this.channels = {};\n            return;\n        }\n        // Detect if mask has rendered. TODO: better dependency system for Effects\n        const effects = allEffects?.filter(e => e.useInPicking && preRenderStats[e.id]);\n        const maskEffectRendered = preRenderStats['mask-effect']?.didRender;\n        // Collect layers to render\n        const channels = this._groupByCollisionGroup(device, collisionLayers);\n        const viewport = viewports[0];\n        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;\n        // Resize framebuffers to match canvas\n        for (const collisionGroup in channels) {\n            const collisionFBO = this.collisionFBOs[collisionGroup];\n            const renderInfo = channels[collisionGroup];\n            // @ts-expect-error TODO - assuming WebGL context\n            const [width, height] = device.canvasContext.getPixelSize();\n            collisionFBO.resize({\n                width: width / DOWNSCALE,\n                height: height / DOWNSCALE\n            });\n            this._render(renderInfo, {\n                effects,\n                layerFilter,\n                onViewportActive,\n                views,\n                viewport,\n                viewportChanged\n            });\n        }\n        // debugFBO(this.collisionFBOs[Object.keys(channels)[0]], {minimap: true});\n    }\n    _render(renderInfo, { effects, layerFilter, onViewportActive, views, viewport, viewportChanged }) {\n        const { collisionGroup } = renderInfo;\n        const oldRenderInfo = this.channels[collisionGroup];\n        if (!oldRenderInfo) {\n            return;\n        }\n        const needsRender = viewportChanged ||\n            // If render info is new\n            renderInfo === oldRenderInfo ||\n            // If sublayers have changed\n            !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) ||\n            // If a sublayer's bounds have been updated\n            renderInfo.layerBounds.some((b, i) => !equals(b, oldRenderInfo.layerBounds[i])) ||\n            // If a sublayer's isLoaded state has been updated\n            renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded ||\n            // Some prop is in transition\n            renderInfo.layers.some(layer => layer.props.transitions);\n        this.channels[collisionGroup] = renderInfo;\n        if (needsRender) {\n            this.lastViewport = viewport;\n            const collisionFBO = this.collisionFBOs[collisionGroup];\n            // Rerender collision FBO\n            this.collisionFilterPass.renderCollisionMap(collisionFBO, {\n                pass: 'collision-filter',\n                isPicking: true,\n                layers: renderInfo.layers,\n                effects,\n                layerFilter,\n                viewports: viewport ? [viewport] : [],\n                onViewportActive,\n                views,\n                moduleParameters: {\n                    // To avoid feedback loop forming between Framebuffer and active Texture.\n                    dummyCollisionMap: this.dummyCollisionMap,\n                    // @ts-expect-error TODO - assuming WebGL context\n                    devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE\n                }\n            });\n        }\n    }\n    /**\n     * Group layers by collisionGroup\n     * Returns a map from collisionGroup to render info\n     */\n    _groupByCollisionGroup(device, collisionLayers) {\n        const channelMap = {};\n        for (const layer of collisionLayers) {\n            const { collisionGroup } = layer.props;\n            let channelInfo = channelMap[collisionGroup];\n            if (!channelInfo) {\n                channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };\n                channelMap[collisionGroup] = channelInfo;\n            }\n            channelInfo.layers.push(layer);\n            channelInfo.layerBounds.push(layer.getBounds());\n            if (!layer.isLoaded) {\n                channelInfo.allLayersLoaded = false;\n            }\n        }\n        // Create any new passes and remove any old ones\n        for (const collisionGroup of Object.keys(channelMap)) {\n            if (!this.collisionFBOs[collisionGroup]) {\n                this.createFBO(device, collisionGroup);\n            }\n            if (!this.channels[collisionGroup]) {\n                this.channels[collisionGroup] = channelMap[collisionGroup];\n            }\n        }\n        for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n            if (!channelMap[collisionGroup]) {\n                this.destroyFBO(collisionGroup);\n            }\n        }\n        return channelMap;\n    }\n    getModuleParameters(layer) {\n        const { collisionGroup } = layer.props;\n        const { collisionFBOs, dummyCollisionMap } = this;\n        return { collisionFBO: collisionFBOs[collisionGroup], dummyCollisionMap: dummyCollisionMap };\n    }\n    cleanup() {\n        if (this.dummyCollisionMap) {\n            this.dummyCollisionMap.delete();\n            this.dummyCollisionMap = undefined;\n        }\n        this.channels = {};\n        for (const collisionGroup of Object.keys(this.collisionFBOs)) {\n            this.destroyFBO(collisionGroup);\n        }\n        this.collisionFBOs = {};\n        this.lastViewport = undefined;\n    }\n    createFBO(device, collisionGroup) {\n        // @ts-expect-error\n        const { width, height } = device.gl.canvas;\n        const collisionMap = device.createTexture({\n            format: 'rgba8unorm',\n            width,\n            height,\n            sampler: {\n                minFilter: 'nearest',\n                magFilter: 'nearest',\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'clamp-to-edge'\n            }\n        });\n        // @ts-ignore\n        const depthStencilAttachment = device.createTexture({\n            format: 'depth16unorm',\n            width,\n            height,\n            mipmaps: false,\n            // TODO fix getWebGLTextureParameters() in luma to avoid passing deprecated parameters\n            dataFormat: 6402, // gl.DEPTH_COMPONENT\n            type: 5125 // gl.UNSIGNED_INT\n        });\n        this.collisionFBOs[collisionGroup] = device.createFramebuffer({\n            id: `collision-${collisionGroup}`,\n            width,\n            height,\n            colorAttachments: [collisionMap],\n            depthStencilAttachment\n        });\n    }\n    destroyFBO(collisionGroup) {\n        const fbo = this.collisionFBOs[collisionGroup];\n        fbo.colorAttachments[0]?.destroy();\n        fbo.depthStencilAttachment?.destroy();\n        fbo.destroy();\n        delete this.collisionFBOs[collisionGroup];\n    }\n}\n", "import { _LayersPass as LayersPass } from '@deck.gl/core';\nexport default class CollisionFilterPass extends LayersPass {\n    renderCollisionMap(target, options) {\n        const padding = 1;\n        const clearColor = [0, 0, 0, 0];\n        const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];\n        this.render({ ...options, clearColor, scissorRect, target, pass: 'collision' });\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return { ...layer.props.parameters, blend: false, depthRange: [0, 1], depthTest: true };\n    }\n    getModuleParameters() {\n        // Draw picking colors into collision FBO\n        return {\n            drawToCollisionMap: true,\n            picking: {\n                isActive: 1,\n                isAttribute: false\n            },\n            lightSources: {}\n        };\n    }\n}\n", "import { COORDINATE_SYSTEM, LayerExtension, log } from '@deck.gl/core';\nimport mask from \"./shader-module.js\";\nimport MaskEffect from \"./mask-effect.js\";\nconst defaultProps = {\n    maskId: '',\n    maskByInstance: undefined,\n    maskInverted: false\n};\n/** Allows layers to show/hide objects by a geofence. */\nexport default class MaskExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'MaskExtension'; }\n    initializeState() {\n        this.context.deck?._addDefaultEffect(new MaskEffect());\n    }\n    getShaders() {\n        // Infer by geometry if 'maskByInstance' prop isn't explictly set\n        let maskByInstance = 'instancePositions' in this.getAttributeManager().attributes;\n        // Users can override by setting the `maskByInstance` prop\n        if (this.props.maskByInstance !== undefined) {\n            maskByInstance = Boolean(this.props.maskByInstance);\n        }\n        this.state.maskByInstance = maskByInstance;\n        return {\n            modules: [mask]\n        };\n    }\n    /* eslint-disable camelcase */\n    draw({ uniforms, context, moduleParameters }) {\n        uniforms.mask_maskByInstance = this.state.maskByInstance;\n        const { maskId, maskInverted } = this.props;\n        const { maskChannels } = moduleParameters;\n        const { viewport } = context;\n        if (maskChannels && maskChannels[maskId]) {\n            const { index, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];\n            let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];\n            uniforms.mask_enabled = true;\n            uniforms.mask_channel = index;\n            uniforms.mask_inverted = maskInverted;\n            if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n                fromCoordinateSystem = viewport.isGeospatial\n                    ? COORDINATE_SYSTEM.LNGLAT\n                    : COORDINATE_SYSTEM.CARTESIAN;\n            }\n            const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };\n            const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);\n            const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);\n            uniforms.mask_bounds = [bl[0], bl[1], tr[0], tr[1]];\n        }\n        else {\n            if (maskId) {\n                log.warn(`Could not find a mask layer with id: ${maskId}`)();\n            }\n            uniforms.mask_enabled = false;\n        }\n    }\n}\n", "import { project } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\nconst vs = `\nuniform vec4 mask_bounds;\nuniform bool mask_maskByInstance;\nvec2 mask_getCoords(vec4 position) {\nreturn (position.xy - mask_bounds.xy) / (mask_bounds.zw - mask_bounds.xy);\n}\n`;\nconst fs = `\nuniform sampler2D mask_texture;\nuniform int mask_channel;\nuniform bool mask_enabled;\nuniform bool mask_inverted;\nbool mask_isInBounds(vec2 texCoords) {\nif (!mask_enabled) {\nreturn true;\n}\nvec4 maskColor = texture(mask_texture, texCoords);\nfloat maskValue = 1.0;\nif (mask_channel == 0) {\nmaskValue = maskColor.r;\n} else if (mask_channel == 1) {\nmaskValue = maskColor.g;\n} else if (mask_channel == 2) {\nmaskValue = maskColor.b;\n} else if (mask_channel == 3) {\nmaskValue = maskColor.a;\n}\nif (mask_inverted) {\nreturn maskValue >= 0.5;\n} else {\nreturn maskValue < 0.5;\n}\n}\n`;\nconst inject = {\n    'vs:#decl': `\nout vec2 mask_texCoords;\n`,\n    'vs:#main-end': `\nvec4 mask_common_position;\nif (mask_maskByInstance) {\nmask_common_position = project_position(vec4(geometry.worldPosition, 1.0));\n} else {\nmask_common_position = geometry.position;\n}\nmask_texCoords = mask_getCoords(mask_common_position);\n`,\n    'fs:#decl': `\nin vec2 mask_texCoords;\n`,\n    'fs:#main-start': `\nif (mask_enabled) {\nbool mask = mask_isInBounds(mask_texCoords);\nfragColor = texture(mask_texture, mask_texCoords);\nif (!mask) discard;\n}\n`\n};\n/* eslint-disable camelcase */\nconst getMaskUniforms = (opts) => {\n    if (opts && 'maskMap' in opts) {\n        return {\n            mask_texture: opts.maskMap\n        };\n    }\n    return {};\n};\nexport default {\n    name: 'mask',\n    dependencies: [project],\n    vs,\n    fs,\n    inject,\n    getUniforms: getMaskUniforms\n};\n", "import { log } from '@deck.gl/core';\nimport { equals } from '@math.gl/core';\nimport MaskPass from \"./mask-pass.js\";\nimport { joinLayerBounds, getRenderBounds, makeViewport } from \"../utils/projection-utils.js\";\n// Class to manage mask effect\nexport default class MaskEffect {\n    constructor() {\n        this.id = 'mask-effect';\n        this.props = null;\n        this.useInPicking = true;\n        this.order = 0;\n        this.channels = [];\n        this.masks = null;\n    }\n    setup({ device }) {\n        this.dummyMaskMap = device.createTexture({\n            width: 1,\n            height: 1\n        });\n        this.maskPass = new MaskPass(device, { id: 'default-mask' });\n        this.maskMap = this.maskPass.maskMap;\n    }\n    preRender({ layers, layerFilter, viewports, onViewportActive, views, isPicking }) {\n        let didRender = false;\n        if (isPicking) {\n            // Do not update on picking pass\n            return { didRender };\n        }\n        const maskLayers = layers.filter(l => l.props.visible && l.props.operation.includes('mask'));\n        if (maskLayers.length === 0) {\n            this.masks = null;\n            this.channels.length = 0;\n            return { didRender };\n        }\n        this.masks = {};\n        // Map layers to channels\n        const channelMap = this._sortMaskChannels(maskLayers);\n        // TODO - support multiple views\n        const viewport = viewports[0];\n        const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);\n        if (viewport.resolution !== undefined) {\n            log.warn('MaskExtension is not supported in GlobeView')();\n            return { didRender };\n        }\n        for (const maskId in channelMap) {\n            const result = this._renderChannel(channelMap[maskId], {\n                layerFilter,\n                onViewportActive,\n                views,\n                viewport,\n                viewportChanged\n            });\n            didRender ||= result;\n        }\n        // debugFBO(this.maskMap, {opaque: true});\n        return { didRender };\n    }\n    /* eslint-disable-next-line complexity */\n    _renderChannel(channelInfo, { layerFilter, onViewportActive, views, viewport, viewportChanged }) {\n        let didRender = false;\n        const oldChannelInfo = this.channels[channelInfo.index];\n        if (!oldChannelInfo) {\n            return didRender;\n        }\n        const maskChanged = \n        // If a channel is new\n        channelInfo === oldChannelInfo ||\n            // If sublayers have changed\n            channelInfo.layers.length !== oldChannelInfo.layers.length ||\n            channelInfo.layers.some((layer, i) => \n            // Layer instance is updated\n            // Layer props might have changed\n            // Undetermined props could have an effect on the output geometry of a mask layer,\n            // for example getRadius+updateTriggers, radiusScale, modelMatrix\n            layer !== oldChannelInfo.layers[i] ||\n                // Some prop is in transition\n                layer.props.transitions) ||\n            // If a sublayer's positions have been updated, the cached bounds will change shallowly\n            channelInfo.layerBounds.some((b, i) => b !== oldChannelInfo.layerBounds[i]);\n        channelInfo.bounds = oldChannelInfo.bounds;\n        channelInfo.maskBounds = oldChannelInfo.maskBounds;\n        this.channels[channelInfo.index] = channelInfo;\n        if (maskChanged || viewportChanged) {\n            // Recalculate mask bounds\n            this.lastViewport = viewport;\n            const layerBounds = joinLayerBounds(channelInfo.layers, viewport);\n            channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);\n            if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {\n                // Rerender mask FBO\n                const { maskPass, maskMap } = this;\n                const maskViewport = layerBounds &&\n                    makeViewport({\n                        bounds: channelInfo.bounds,\n                        viewport,\n                        width: maskMap.width,\n                        height: maskMap.height,\n                        border: 1\n                    });\n                channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];\n                // @ts-ignore (2532) This method is only called from preRender where maskPass is defined\n                maskPass.render({\n                    pass: 'mask',\n                    channel: channelInfo.index,\n                    layers: channelInfo.layers,\n                    layerFilter,\n                    viewports: maskViewport ? [maskViewport] : [],\n                    onViewportActive,\n                    views,\n                    moduleParameters: {\n                        devicePixelRatio: 1\n                    }\n                });\n                didRender = true;\n            }\n        }\n        // @ts-ignore (2532) This method is only called from preRender where masks is defined\n        this.masks[channelInfo.id] = {\n            index: channelInfo.index,\n            bounds: channelInfo.maskBounds,\n            coordinateOrigin: channelInfo.coordinateOrigin,\n            coordinateSystem: channelInfo.coordinateSystem\n        };\n        return didRender;\n    }\n    /**\n     * Find a channel to render each mask into\n     * If a maskId already exists, diff and update the existing channel\n     * Otherwise replace a removed mask\n     * Otherwise create a new channel\n     * Returns a map from mask layer id to channel info\n     */\n    _sortMaskChannels(maskLayers) {\n        const channelMap = {};\n        let channelCount = 0;\n        for (const layer of maskLayers) {\n            const { id } = layer.root;\n            let channelInfo = channelMap[id];\n            if (!channelInfo) {\n                if (++channelCount > 4) {\n                    log.warn('Too many mask layers. The max supported is 4')();\n                    continue; // eslint-disable-line no-continue\n                }\n                channelInfo = {\n                    id,\n                    index: this.channels.findIndex(c => c?.id === id),\n                    layers: [],\n                    layerBounds: [],\n                    coordinateOrigin: layer.root.props.coordinateOrigin,\n                    coordinateSystem: layer.root.props.coordinateSystem\n                };\n                channelMap[id] = channelInfo;\n            }\n            channelInfo.layers.push(layer);\n            channelInfo.layerBounds.push(layer.getBounds());\n        }\n        for (let i = 0; i < 4; i++) {\n            const channelInfo = this.channels[i];\n            if (!channelInfo || !(channelInfo.id in channelMap)) {\n                // The mask id at this channel no longer exists\n                this.channels[i] = null;\n            }\n        }\n        for (const maskId in channelMap) {\n            const channelInfo = channelMap[maskId];\n            if (channelInfo.index < 0) {\n                channelInfo.index = this.channels.findIndex(c => !c);\n                this.channels[channelInfo.index] = channelInfo;\n            }\n        }\n        return channelMap;\n    }\n    getModuleParameters() {\n        return {\n            maskMap: this.masks ? this.maskMap : this.dummyMaskMap,\n            maskChannels: this.masks\n        };\n    }\n    cleanup() {\n        if (this.dummyMaskMap) {\n            this.dummyMaskMap.delete();\n            this.dummyMaskMap = undefined;\n        }\n        if (this.maskPass) {\n            this.maskPass.delete();\n            this.maskPass = undefined;\n            this.maskMap = undefined;\n        }\n        this.lastViewport = undefined;\n        this.masks = null;\n        this.channels.length = 0;\n    }\n}\n", "import { _LayersPass as LayersPass } from '@deck.gl/core';\nconst MASK_BLENDING = {\n    blendColorOperation: 'subtract',\n    blendColorSrcFactor: 'zero',\n    blendColorDstFactor: 'one',\n    blendAlphaOperation: 'subtract',\n    blendAlphaSrcFactor: 'zero',\n    blendAlphaDstFactor: 'one'\n};\nexport default class MaskPass extends LayersPass {\n    constructor(device, props) {\n        super(device, props);\n        const { mapSize = 2048 } = props;\n        this.maskMap = device.createTexture({\n            format: 'rgba8unorm',\n            width: mapSize,\n            height: mapSize,\n            sampler: {\n                minFilter: 'linear',\n                magFilter: 'linear',\n                addressModeU: 'clamp-to-edge',\n                addressModeV: 'clamp-to-edge'\n            }\n        });\n        this.fbo = device.createFramebuffer({\n            id: 'maskmap',\n            width: mapSize,\n            height: mapSize,\n            colorAttachments: [this.maskMap]\n        });\n    }\n    render(options) {\n        const colorMask = 2 ** options.channel;\n        const clearColor = [255, 255, 255, 255];\n        super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: 'mask' });\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return {\n            ...layer.props.parameters,\n            blend: true,\n            depthTest: false,\n            ...MASK_BLENDING\n        };\n    }\n    shouldDrawLayer(layer) {\n        return layer.props.operation.includes('mask');\n    }\n    delete() {\n        this.fbo.delete();\n        this.maskMap.delete();\n    }\n}\n", "import { WebMercatorViewport, OrthographicViewport } from '@deck.gl/core';\n/*\n * Compute the union of bounds from multiple layers\n * Returns bounds in CARTESIAN coordinates\n */\nexport function joinLayerBounds(\n/** The layers to combine */\nlayers, \n/** A Viewport instance that is used to determine the type of the view */\nviewport) {\n    // Join the bounds of layer data\n    const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n    for (const layer of layers) {\n        const layerBounds = layer.getBounds();\n        if (layerBounds) {\n            const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });\n            const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });\n            bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);\n            bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);\n            bounds[2] = Math.max(bounds[2], topRightCommon[0]);\n            bounds[3] = Math.max(bounds[3], topRightCommon[1]);\n        }\n    }\n    if (Number.isFinite(bounds[0])) {\n        return bounds;\n    }\n    return null;\n}\nconst MAX_VIEWPORT_SIZE = 2048;\n/** Construct a viewport that just covers the target bounds. Used for rendering to common space indexed texture. */\nexport function makeViewport(opts) {\n    const { bounds, viewport, border = 0 } = opts;\n    const { isGeospatial } = viewport;\n    if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n        return null;\n    }\n    const centerWorld = viewport.unprojectPosition([\n        (bounds[0] + bounds[2]) / 2,\n        (bounds[1] + bounds[3]) / 2,\n        0\n    ]);\n    let { width, height, zoom } = opts;\n    if (zoom === undefined) {\n        // Use width and height to determine zoom\n        width = width - border * 2;\n        height = height - border * 2;\n        const scale = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n        zoom = Math.min(Math.log2(scale), 20);\n    }\n    else if (!width || !height) {\n        // Use zoom to determine width and height\n        const scale = 2 ** zoom;\n        width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale);\n        height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale);\n        const maxSize = MAX_VIEWPORT_SIZE - border * 2;\n        if (width > maxSize || height > maxSize) {\n            const r = maxSize / Math.max(width, height);\n            width = Math.round(width * r);\n            height = Math.round(height * r);\n            zoom += Math.log2(r);\n        }\n    }\n    // TODO - find a more generic way to construct this viewport\n    // Geospatial viewports may not be web-mercator\n    return isGeospatial\n        ? new WebMercatorViewport({\n            id: viewport.id,\n            x: border,\n            y: border,\n            width,\n            height,\n            longitude: centerWorld[0],\n            latitude: centerWorld[1],\n            zoom,\n            orthographic: true\n        })\n        : new OrthographicViewport({\n            id: viewport.id,\n            x: border,\n            y: border,\n            width,\n            height,\n            target: centerWorld,\n            zoom,\n            flipY: false\n        });\n}\n/** Returns viewport bounds in CARTESIAN coordinates */\nexport function getViewportBounds(viewport, zRange) {\n    // Viewport bounds in world coordinates\n    let viewportBoundsWorld;\n    if (zRange && zRange.length === 2) {\n        const [minZ, maxZ] = zRange;\n        const bounds0 = viewport.getBounds({ z: minZ });\n        const bounds1 = viewport.getBounds({ z: maxZ });\n        viewportBoundsWorld = [\n            Math.min(bounds0[0], bounds1[0]),\n            Math.min(bounds0[1], bounds1[1]),\n            Math.max(bounds0[2], bounds1[2]),\n            Math.max(bounds0[3], bounds1[3])\n        ];\n    }\n    else {\n        viewportBoundsWorld = viewport.getBounds();\n    }\n    // Viewport bounds in cartesian coordinates\n    const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));\n    const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));\n    return [\n        viewportBottomLeftCommon[0],\n        viewportBottomLeftCommon[1],\n        viewportTopRightCommon[0],\n        viewportTopRightCommon[1]\n    ];\n}\n/*\n * Determine the common space bounds that best cover the given data for the given viewport\n * Returns bounds in CARTESIAN coordinates\n */\nexport function getRenderBounds(layerBounds, viewport, zRange) {\n    if (!layerBounds) {\n        return [0, 0, 1, 1];\n    }\n    const viewportBounds = getViewportBounds(viewport, zRange);\n    // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n    // errors when mask is partially out of view\n    const paddedBounds = doubleBounds(viewportBounds);\n    // When bounds of the layers are smaller than the viewport bounds simply use\n    // mask bounds, so as to maximize resolution & avoid rerenders\n    if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] &&\n        layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {\n        return layerBounds;\n    }\n    // As viewport shrinks, to avoid pixelation along mask edges\n    // we need to reduce the bounds and only render the visible portion\n    // of the mask.\n    // We pad the viewport bounds to capture the section\n    // of the mask just outside the viewport to correctly maskByInstance.\n    // Intersect mask & padded viewport bounds\n    return [\n        Math.max(layerBounds[0], paddedBounds[0]),\n        Math.max(layerBounds[1], paddedBounds[1]),\n        Math.min(layerBounds[2], paddedBounds[2]),\n        Math.min(layerBounds[3], paddedBounds[3])\n    ];\n}\nfunction doubleBounds(bounds) {\n    const dx = bounds[2] - bounds[0];\n    const dy = bounds[3] - bounds[1];\n    const centerX = (bounds[0] + bounds[2]) / 2;\n    const centerY = (bounds[1] + bounds[3]) / 2;\n    return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];\n}\n", "import { LayerExtension } from '@deck.gl/core';\nimport { TerrainEffect } from \"./terrain-effect.js\";\nimport { terrainModule } from \"./shader-module.js\";\nconst defaultProps = {\n    terrainDrawMode: undefined\n};\n/** Allows layers to show/hide objects by a geofence. */\nexport default class TerrainExtension extends LayerExtension {\n    static { this.defaultProps = defaultProps; }\n    static { this.extensionName = 'TerrainExtension'; }\n    getShaders() {\n        return {\n            modules: [terrainModule]\n        };\n    }\n    initializeState() {\n        this.context.deck?._addDefaultEffect(new TerrainEffect());\n    }\n    updateState(params) {\n        const { props, oldProps } = params;\n        if (this.state.terrainDrawMode &&\n            props.terrainDrawMode === oldProps.terrainDrawMode &&\n            // @ts-ignore `extruded` may not exist in props\n            props.extruded === oldProps.extruded) {\n            return;\n        }\n        let { terrainDrawMode } = props;\n        if (!terrainDrawMode) {\n            // props.extruded is used as an indication that the layer is 2.5D\n            // @ts-ignore `extruded` may not exist in props\n            const is3d = this.props.extruded;\n            const attributes = this.getAttributeManager()?.attributes;\n            const hasAnchor = attributes && 'instancePositions' in attributes;\n            terrainDrawMode = is3d || hasAnchor ? 'offset' : 'drape';\n        }\n        this.setState({ terrainDrawMode });\n    }\n    onNeedsRedraw() {\n        const state = this.state;\n        if (state.terrainDrawMode === 'drape') {\n            state.terrainCoverNeedsRedraw = true;\n        }\n    }\n}\n", "import { log } from '@deck.gl/core';\nimport { terrainModule } from \"./shader-module.js\";\nimport { TerrainCover } from \"./terrain-cover.js\";\nimport { TerrainPass } from \"./terrain-pass.js\";\nimport { TerrainPickingPass } from \"./terrain-picking-pass.js\";\nimport { HeightMapBuilder } from \"./height-map-builder.js\";\n/** Class to manage terrain effect */\nexport class TerrainEffect {\n    constructor() {\n        this.id = 'terrain-effect';\n        this.props = null;\n        this.useInPicking = true;\n        /** true if picking in the current pass */\n        this.isPicking = false;\n        /** true if should use in the current pass */\n        this.isDrapingEnabled = false;\n        /** One texture for each primitive terrain layer, into which the draped layers render */\n        this.terrainCovers = new Map();\n    }\n    setup({ device, deck }) {\n        this.dummyHeightMap = device.createTexture({\n            width: 1,\n            height: 1,\n            data: new Uint8Array([0, 0, 0, 0])\n        });\n        this.terrainPass = new TerrainPass(device, { id: 'terrain' });\n        this.terrainPickingPass = new TerrainPickingPass(device, { id: 'terrain-picking' });\n        if (HeightMapBuilder.isSupported(device)) {\n            this.heightMap = new HeightMapBuilder(device);\n        }\n        else {\n            log.warn('Terrain offset mode is not supported by this browser')();\n        }\n        deck._addDefaultShaderModule(terrainModule);\n    }\n    preRender(opts) {\n        // @ts-expect-error pickZ only defined in picking pass\n        if (opts.pickZ) {\n            // Do not update if picking attributes\n            this.isDrapingEnabled = false;\n            return;\n        }\n        const { viewports } = opts;\n        const isPicking = opts.pass.startsWith('picking');\n        this.isPicking = isPicking;\n        this.isDrapingEnabled = true;\n        // TODO - support multiple views?\n        const viewport = viewports[0];\n        const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);\n        const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n        if (terrainLayers.length === 0) {\n            return;\n        }\n        if (!isPicking) {\n            const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n            if (offsetLayers.length > 0) {\n                this._updateHeightMap(terrainLayers, viewport, opts);\n            }\n        }\n        const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n        this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n    }\n    getModuleParameters(layer) {\n        const { terrainDrawMode } = layer.state;\n        return {\n            heightMap: this.heightMap?.getRenderFramebuffer()?.colorAttachments[0].texture || null,\n            heightMapBounds: this.heightMap?.bounds,\n            dummyHeightMap: this.dummyHeightMap,\n            terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n            useTerrainHeightMap: terrainDrawMode === 'offset',\n            terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n        };\n    }\n    cleanup({ deck }) {\n        if (this.dummyHeightMap) {\n            this.dummyHeightMap.delete();\n            this.dummyHeightMap = undefined;\n        }\n        if (this.heightMap) {\n            this.heightMap.delete();\n            this.heightMap = undefined;\n        }\n        for (const terrainCover of this.terrainCovers.values()) {\n            terrainCover.delete();\n        }\n        this.terrainCovers.clear();\n        deck._removeDefaultShaderModule(terrainModule);\n    }\n    _updateHeightMap(terrainLayers, viewport, opts) {\n        if (!this.heightMap) {\n            // Not supported\n            return;\n        }\n        const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });\n        if (!shouldUpdate) {\n            return;\n        }\n        this.terrainPass.renderHeightMap(this.heightMap, {\n            ...opts,\n            layers: terrainLayers,\n            moduleParameters: {\n                heightMapBounds: this.heightMap.bounds,\n                dummyHeightMap: this.dummyHeightMap,\n                devicePixelRatio: 1,\n                drawToTerrainHeightMap: true\n            }\n        });\n    }\n    _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {\n        // Mark a terrain cover as dirty if one of the drape layers needs redraw\n        const layerNeedsRedraw = {};\n        for (const layer of drapeLayers) {\n            if (layer.state.terrainCoverNeedsRedraw) {\n                layerNeedsRedraw[layer.id] = true;\n                layer.state.terrainCoverNeedsRedraw = false;\n            }\n        }\n        for (const terrainCover of this.terrainCovers.values()) {\n            terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });\n        }\n        for (const layer of terrainLayers) {\n            this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n        }\n        if (!this.isPicking) {\n            this._pruneTerrainCovers();\n        }\n    }\n    _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {\n        const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n        let terrainCover = this.terrainCovers.get(terrainLayer.id);\n        if (!terrainCover) {\n            terrainCover = new TerrainCover(terrainLayer);\n            this.terrainCovers.set(terrainLayer.id, terrainCover);\n        }\n        try {\n            const isDirty = terrainCover.shouldUpdate({\n                targetLayer: terrainLayer,\n                viewport,\n                layers: drapeLayers\n            });\n            if (this.isPicking || terrainCover.isDirty || isDirty) {\n                renderPass.renderTerrainCover(terrainCover, {\n                    ...opts,\n                    layers: drapeLayers,\n                    moduleParameters: {\n                        dummyHeightMap: this.dummyHeightMap,\n                        terrainSkipRender: false,\n                        devicePixelRatio: 1\n                    }\n                });\n                if (!this.isPicking) {\n                    // IsDirty refers to the normal fbo, not the picking fbo.\n                    // Only mark it as not dirty if the normal fbo was updated.\n                    terrainCover.isDirty = false;\n                }\n            }\n        }\n        catch (err) {\n            terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);\n        }\n    }\n    _pruneTerrainCovers() {\n        /** Prune the cache, remove textures for layers that have been removed */\n        const idsToRemove = [];\n        for (const [id, terrainCover] of this.terrainCovers) {\n            if (!terrainCover.isActive) {\n                idsToRemove.push(id);\n            }\n        }\n        for (const id of idsToRemove) {\n            this.terrainCovers.delete(id);\n        }\n    }\n}\n", "/* eslint-disable camelcase */\nimport { project } from '@deck.gl/core';\nimport { glsl } from \"../utils/syntax-tags.js\";\n/** A model can have one of the following modes */\nexport const TERRAIN_MODE = {\n    NONE: 0,\n    /** A terrain layer rendering encoded ground elevation into the height map */\n    WRITE_HEIGHT_MAP: 1,\n    /** An offset layer reading encoded ground elevation from the height map */\n    USE_HEIGHT_MAP: 2,\n    /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */\n    USE_COVER: 3,\n    /** A terrain layer rendering to screen, using the cover fbo as texture */\n    USE_COVER_ONLY: 4,\n    /** Draped layer is rendered into a texture, and never to screen */\n    SKIP: 5\n};\nconst TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE)\n    .map(key => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`)\n    .join('\\n');\n// @ts-expect-error\nexport const terrainModule = {\n    name: 'terrain',\n    dependencies: [project],\n    inject: {\n        'vs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nout vec3 commonPos;\n` + TERRAIN_MODE_CONSTANTS,\n        'vs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_SKIP) {\ngl_Position = vec4(0.0);\nreturn;\n}\n`,\n        'vs:DECKGL_FILTER_GL_POSITION': `\ncommonPos = geometry.position.xyz;\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\nvec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\nposition = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);\ncommonPos.z += project_uCommonOrigin.z;\n}\nif (terrain_mode == TERRAIN_MODE_USE_HEIGHT_MAP) {\nvec3 anchor = geometry.worldPosition;\nanchor.z = 0.0;\nvec3 anchorCommon = project_position(anchor);\nvec2 texCoords = (anchorCommon.xy - terrain_bounds.xy) / terrain_bounds.zw;\nif (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {\nfloat terrainZ = texture(terrain_map, texCoords).r;\ngeometry.position.z += terrainZ;\nposition = project_common_position_to_clipspace(geometry.position);\n}\n}\n`,\n        'fs:#decl': `\nuniform float terrain_mode;\nuniform sampler2D terrain_map;\nuniform vec4 terrain_bounds;\nin vec3 commonPos;\n` + TERRAIN_MODE_CONSTANTS,\n        'fs:#main-start': `\nif (terrain_mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {\nfragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);\nreturn;\n}\n`,\n        'fs:DECKGL_FILTER_COLOR': `\nif ((terrain_mode == TERRAIN_MODE_USE_COVER) || (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY)) {\nvec2 texCoords = (commonPos.xy - terrain_bounds.xy) / terrain_bounds.zw;\nvec4 pixel = texture(terrain_map, texCoords);\nif (terrain_mode == TERRAIN_MODE_USE_COVER_ONLY) {\ncolor = pixel;\n} else {\ncolor = pixel + color * (1.0 - pixel.a);\n}\nreturn;\n}\n`\n    },\n    // eslint-disable-next-line complexity\n    getUniforms: (opts = {}, uniforms) => {\n        if ('dummyHeightMap' in opts) {\n            const { drawToTerrainHeightMap, heightMap, heightMapBounds, dummyHeightMap, terrainCover, useTerrainHeightMap, terrainSkipRender } = opts;\n            const { project_uCommonOrigin } = uniforms;\n            let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;\n            // height map if case USE_HEIGHT_MAP, terrain cover if USE_COVER, otherwise empty\n            let sampler = dummyHeightMap;\n            // height map bounds if case USE_HEIGHT_MAP, terrain cover bounds if USE_COVER, otherwise null\n            let bounds = null;\n            if (drawToTerrainHeightMap) {\n                mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;\n                bounds = heightMapBounds;\n            }\n            else if (useTerrainHeightMap && heightMap) {\n                mode = TERRAIN_MODE.USE_HEIGHT_MAP;\n                sampler = heightMap;\n                bounds = heightMapBounds;\n            }\n            else if (terrainCover) {\n                // This is a terrain layer\n                const isPicking = opts.picking?.isActive;\n                const fbo = isPicking\n                    ? terrainCover.getPickingFramebuffer()\n                    : terrainCover.getRenderFramebuffer();\n                sampler = fbo?.colorAttachments[0].texture;\n                if (isPicking) {\n                    // Never render the layer itself in picking pass\n                    mode = TERRAIN_MODE.SKIP;\n                }\n                if (sampler) {\n                    mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;\n                    bounds = terrainCover.bounds;\n                }\n                else {\n                    sampler = dummyHeightMap;\n                }\n            }\n            /* eslint-disable camelcase */\n            return {\n                terrain_mode: mode,\n                terrain_map: sampler,\n                // Convert bounds to the common space, as [minX, minY, width, height]\n                terrain_bounds: bounds\n                    ? [\n                        bounds[0] - project_uCommonOrigin[0],\n                        bounds[1] - project_uCommonOrigin[1],\n                        bounds[2] - bounds[0],\n                        bounds[3] - bounds[1]\n                    ]\n                    : [0, 0, 0, 0]\n            };\n        }\n        return null;\n    }\n};\n", "import { GL } from '@luma.gl/constants';\nexport function createRenderTarget(device, opts) {\n    return device.createFramebuffer({\n        id: opts.id,\n        colorAttachments: [\n            device.createTexture({\n                id: opts.id,\n                ...(opts.float && {\n                    format: 'rgba32float',\n                    type: 5126\n                }),\n                mipmaps: false,\n                sampler: opts.interpolate === false\n                    ? {\n                        minFilter: 'nearest',\n                        magFilter: 'nearest'\n                    }\n                    : {\n                        minFilter: 'linear',\n                        magFilter: 'linear'\n                    }\n            })\n        ]\n    });\n}\n", "import { createRenderTarget } from \"./utils.js\";\nimport { joinLayerBounds, makeViewport, getRenderBounds } from \"../utils/projection-utils.js\";\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n    constructor(targetLayer) {\n        this.isDirty = true;\n        /** Viewport used to draw into the texture */\n        this.renderViewport = null;\n        /** Bounds of the terrain cover texture, in cartesian space */\n        this.bounds = null;\n        this.layers = [];\n        /** Cached version of targetLayer.getBounds() */\n        this.targetBounds = null;\n        /** targetBounds in cartesian space */\n        this.targetBoundsCommon = null;\n        this.targetLayer = targetLayer;\n        this.tile = getTile(targetLayer);\n    }\n    get id() {\n        return this.targetLayer.id;\n    }\n    /** returns true if the target layer is still in use (i.e. not finalized) */\n    get isActive() {\n        return Boolean(this.targetLayer.getCurrentLayer());\n    }\n    shouldUpdate({ targetLayer, viewport, layers, layerNeedsRedraw }) {\n        if (targetLayer) {\n            this.targetLayer = targetLayer;\n        }\n        const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n        let layersChanged = layers ? this._updateLayers(layers) : false;\n        if (layerNeedsRedraw) {\n            for (const id of this.layers) {\n                if (layerNeedsRedraw[id]) {\n                    layersChanged = true;\n                    // console.log('layer needs redraw', id);\n                    break;\n                }\n            }\n        }\n        return layersChanged || sizeChanged;\n    }\n    /** Compare layers with the last version. Only rerender if necessary. */\n    _updateLayers(layers) {\n        let needsRedraw = false;\n        layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n        if (layers.length !== this.layers.length) {\n            needsRedraw = true;\n            // console.log('layers count changed', this.layers.length, '>>', layers.length);\n        }\n        else {\n            for (let i = 0; i < layers.length; i++) {\n                const id = layers[i].id;\n                if (id !== this.layers[i]) {\n                    needsRedraw = true;\n                    // console.log('layer added/removed', id);\n                    break;\n                }\n            }\n        }\n        if (needsRedraw) {\n            this.layers = layers.map(layer => layer.id);\n        }\n        return needsRedraw;\n    }\n    /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n    _updateViewport(viewport) {\n        const targetLayer = this.targetLayer;\n        let shouldRedraw = false;\n        if (this.tile && 'boundingBox' in this.tile) {\n            if (!this.targetBounds) {\n                shouldRedraw = true;\n                this.targetBounds = this.tile.boundingBox;\n                const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);\n                const topRightCommon = viewport.projectPosition(this.targetBounds[1]);\n                this.targetBoundsCommon = [\n                    bottomLeftCommon[0],\n                    bottomLeftCommon[1],\n                    topRightCommon[0],\n                    topRightCommon[1]\n                ];\n            }\n        }\n        else if (this.targetBounds !== targetLayer.getBounds()) {\n            // console.log('bounds changed', this.bounds, '>>', newBounds);\n            shouldRedraw = true;\n            this.targetBounds = targetLayer.getBounds();\n            this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n        }\n        if (!this.targetBoundsCommon) {\n            return false;\n        }\n        const newZoom = Math.ceil(viewport.zoom + 0.5);\n        // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n        // Otherwise, use the smaller of layer bounds and the viewport bounds.\n        if (this.tile) {\n            this.bounds = this.targetBoundsCommon;\n        }\n        else {\n            const oldZoom = this.renderViewport?.zoom;\n            shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n            const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n            const oldBounds = this.bounds;\n            shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n            this.bounds = newBounds;\n        }\n        if (shouldRedraw) {\n            this.renderViewport = makeViewport({\n                bounds: this.bounds,\n                zoom: newZoom,\n                viewport\n            });\n        }\n        return shouldRedraw;\n    }\n    getRenderFramebuffer() {\n        if (!this.renderViewport || this.layers.length === 0) {\n            return null;\n        }\n        if (!this.fbo) {\n            this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });\n        }\n        return this.fbo;\n    }\n    getPickingFramebuffer() {\n        if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n            return null;\n        }\n        if (!this.pickingFbo) {\n            this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {\n                id: `${this.id}-picking`,\n                interpolate: false\n            });\n        }\n        return this.pickingFbo;\n    }\n    filterLayers(layers) {\n        return layers.filter(({ id }) => this.layers.includes(id));\n    }\n    delete() {\n        const { fbo, pickingFbo } = this;\n        if (fbo) {\n            fbo.colorAttachments[0].destroy();\n            fbo.destroy();\n        }\n        if (pickingFbo) {\n            pickingFbo.colorAttachments[0].destroy();\n            pickingFbo.destroy();\n        }\n    }\n}\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile, layers) {\n    return layers.filter(layer => {\n        const tile = getTile(layer);\n        if (tile) {\n            return intersect(sourceTile.boundingBox, tile.boundingBox);\n        }\n        return true;\n    });\n}\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer) {\n    while (layer) {\n        // @ts-expect-error tile may not exist\n        const { tile } = layer.props;\n        if (tile) {\n            return tile;\n        }\n        layer = layer.parent;\n    }\n    return null;\n}\nfunction intersect(b1, b2) {\n    if (b1 && b2) {\n        return b1[0][0] < b2[1][0] && b2[0][0] < b1[1][0] && b1[0][1] < b2[1][1] && b2[0][1] < b1[1][1];\n    }\n    return false;\n}\n", "import { _LayersPass as LayersPass } from '@deck.gl/core';\nconst TERRAIN_BLENDING = {\n    blendColorOperation: 'max',\n    blendColorSrcFactor: 'one',\n    blendColorDstFactor: 'one',\n    blendAlphaOperation: 'max',\n    blendAlphaSrcFactor: 'one',\n    blendAlphaDstFactor: 'one'\n};\n/** Renders textures used by the TerrainEffect render pass */\nexport class TerrainPass extends LayersPass {\n    getRenderableLayers(viewport, opts) {\n        const { layers } = opts;\n        const result = [];\n        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);\n        for (let i = 0; i < layers.length; i++) {\n            const layer = layers[i];\n            if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n                result.push(layer);\n            }\n        }\n        return result;\n    }\n    renderHeightMap(heightMap, opts) {\n        // console.log('Updating height map')\n        const target = heightMap.getRenderFramebuffer();\n        const viewport = heightMap.renderViewport;\n        if (!target || !viewport) {\n            return;\n        }\n        target.resize(viewport);\n        this.render({\n            ...opts,\n            target,\n            pass: 'terrain-height-map',\n            layers: opts.layers,\n            viewports: [viewport],\n            effects: [],\n            clearColor: [0, 0, 0, 0]\n        });\n    }\n    renderTerrainCover(terrainCover, opts) {\n        // console.log('Updating terrain cover ' + terrainCover.id)\n        const target = terrainCover.getRenderFramebuffer();\n        const viewport = terrainCover.renderViewport;\n        if (!target || !viewport) {\n            return;\n        }\n        const layers = terrainCover.filterLayers(opts.layers);\n        target.resize(viewport);\n        this.render({\n            ...opts,\n            target,\n            pass: `terrain-cover-${terrainCover.id}`,\n            layers,\n            effects: [],\n            viewports: [viewport],\n            clearColor: [0, 0, 0, 0]\n        });\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        return {\n            ...layer.props.parameters,\n            blend: true,\n            depthTest: false,\n            ...(layer.props.operation.includes('terrain') && TERRAIN_BLENDING)\n        };\n    }\n}\n", "import { _PickLayersPass as PickLayersPass } from '@deck.gl/core';\n/** Renders textures used by the TerrainEffect picking pass */\nexport class TerrainPickingPass extends PickLayersPass {\n    constructor() {\n        super(...arguments);\n        /** Save layer index for use when drawing to terrain cover.\n         * When a terrain cover's picking buffer is rendered,\n         * we need to make sure each layer receives a consistent index (encoded in the alpha channel)\n         * so that a picked color can be decoded back to the correct layer.\n         * Updated in getRenderableLayers which is called in TerrainEffect.preRender\n         */\n        this.drawParameters = {};\n    }\n    getRenderableLayers(viewport, opts) {\n        const { layers } = opts;\n        const result = [];\n        this.drawParameters = {};\n        this._resetColorEncoder(opts.pickZ);\n        const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);\n        for (let i = 0; i < layers.length; i++) {\n            const layer = layers[i];\n            if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {\n                result.push(layer);\n                this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;\n            }\n        }\n        return result;\n    }\n    renderTerrainCover(terrainCover, opts) {\n        // console.log('Updating terrain cover for picking ' + terrainCover.id)\n        const target = terrainCover.getPickingFramebuffer();\n        const viewport = terrainCover.renderViewport;\n        if (!target || !viewport) {\n            return;\n        }\n        const layers = terrainCover.filterLayers(opts.layers);\n        const terrainLayer = terrainCover.targetLayer;\n        if (terrainLayer.props.pickable) {\n            layers.unshift(terrainLayer);\n        }\n        target.resize(viewport);\n        this.render({\n            ...opts,\n            pickingFBO: target,\n            pass: `terrain-cover-picking-${terrainCover.id}`,\n            layers,\n            effects: [],\n            viewports: [viewport],\n            // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,\n            // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`\n            cullRect: undefined,\n            deviceRect: viewport,\n            pickZ: false\n        });\n    }\n    getLayerParameters(layer, layerIndex, viewport) {\n        let parameters;\n        if (this.drawParameters[layer.id]) {\n            parameters = this.drawParameters[layer.id];\n        }\n        else {\n            parameters = super.getLayerParameters(layer, layerIndex, viewport);\n            parameters.blend = true;\n        }\n        return { ...parameters, depthTest: false };\n    }\n}\n", "import { joinLayerBounds, getRenderBounds, makeViewport } from \"../utils/projection-utils.js\";\nimport { createRenderTarget } from \"./utils.js\";\nconst MAP_MAX_SIZE = 2048;\n/**\n * Manages the lifecycle of the height map (a framebuffer that encodes elevation).\n * One instance of height map is is shared across all layers. It is updated when the viewport changes\n * or when some terrain source layer's data changes.\n * During the draw call of any terrainDrawMode:offset layers,\n * the vertex shader reads from this framebuffer to retrieve its z offset.\n */\nexport class HeightMapBuilder {\n    static isSupported(device) {\n        return device.isTextureFormatRenderable('rgba32float');\n    }\n    constructor(device) {\n        /** Viewport used to draw into the texture */\n        this.renderViewport = null;\n        /** Bounds of the height map texture, in cartesian space */\n        this.bounds = null;\n        /** Last rendered layers */\n        this.layers = [];\n        /** Last layer.getBounds() */\n        this.layersBounds = [];\n        /** The union of layersBounds in cartesian space */\n        this.layersBoundsCommon = null;\n        this.lastViewport = null;\n        this.device = device;\n    }\n    /** Returns the height map framebuffer for read/write access.\n     * Returns null when the texture is invalid.\n     */\n    getRenderFramebuffer() {\n        if (!this.renderViewport) {\n            return null;\n        }\n        if (!this.fbo) {\n            this.fbo = createRenderTarget(this.device, { id: 'height-map', float: true });\n        }\n        return this.fbo;\n    }\n    /** Called every render cycle to check if the framebuffer needs update */\n    shouldUpdate({ layers, viewport }) {\n        const layersChanged = layers.length !== this.layers.length ||\n            layers.some((layer, i) => \n            // Layer instance is updated\n            // Layer props might have changed\n            // Undetermined props could have an effect on the output geometry of a terrain source,\n            // for example getElevation+updateTriggers, elevationScale, modelMatrix\n            layer !== this.layers[i] ||\n                // Some prop is in transition\n                layer.props.transitions ||\n                // Layer's geometry bounds have changed\n                layer.getBounds() !== this.layersBounds[i]);\n        if (layersChanged) {\n            // Recalculate cached bounds\n            this.layers = layers;\n            this.layersBounds = layers.map(layer => layer.getBounds());\n            this.layersBoundsCommon = joinLayerBounds(layers, viewport);\n        }\n        const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);\n        if (!this.layersBoundsCommon) {\n            this.renderViewport = null;\n        }\n        else if (layersChanged || viewportChanged) {\n            const bounds = getRenderBounds(this.layersBoundsCommon, viewport);\n            if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n                this.renderViewport = null;\n                return false;\n            }\n            this.bounds = bounds;\n            this.lastViewport = viewport;\n            const scale = viewport.scale;\n            const pixelWidth = (bounds[2] - bounds[0]) * scale;\n            const pixelHeight = (bounds[3] - bounds[1]) * scale;\n            this.renderViewport =\n                pixelWidth > 0 || pixelHeight > 0\n                    ? makeViewport({\n                        // It's not important whether the geometry is visible in this viewport, because\n                        // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader\n                        // However the viewport must have the same center and zoom as the screen viewport\n                        // So that projection uniforms used for calculating z are the same\n                        bounds: [\n                            viewport.center[0] - 1,\n                            viewport.center[1] - 1,\n                            viewport.center[0] + 1,\n                            viewport.center[1] + 1\n                        ],\n                        zoom: viewport.zoom,\n                        width: Math.min(pixelWidth, MAP_MAX_SIZE),\n                        height: Math.min(pixelHeight, MAP_MAX_SIZE),\n                        viewport\n                    })\n                    : null;\n            return true;\n        }\n        return false;\n    }\n    delete() {\n        if (this.fbo) {\n            this.fbo.colorAttachments[0].delete();\n            this.fbo.delete();\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "vs", "fs", "inject", "defaultProps", "fp64", "deepEqual", "import_core", "import_core", "getUniforms", "memoize", "import_core", "defaultProps", "mergeShaders", "import_core", "import_core", "inject", "defaultProps", "import_core", "defaultProps", "import_core", "import_core", "vs", "inject", "shader_module_default", "import_core", "import_core", "LayersPass", "deepEqual", "defaultProps", "shader_module_default", "import_core", "import_core", "vs", "fs", "inject", "shader_module_default", "import_core", "import_core", "LayersPass", "import_core", "defaultProps", "shader_module_default", "import_core", "import_core", "import_core", "import_constants", "import_core", "LayersPass", "import_core", "PickLayersPass", "parameters", "defaultProps"]
}
