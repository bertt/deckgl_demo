import { project } from '@deck.gl/core';
import { glsl } from "../utils/syntax-tags.js";
const vs = `
uniform bool brushing_enabled;
uniform int brushing_target;
uniform vec2 brushing_mousePos;
uniform float brushing_radius;
#ifdef NON_INSTANCED_MODEL
in vec2 brushingTargets;
#else
in vec2 instanceBrushingTargets;
#endif
out float brushing_isVisible;
bool brushing_isPointInRange(vec2 position) {
if (!brushing_enabled) {
return true;
}
vec2 source_commonspace = project_position(position);
vec2 target_commonspace = project_position(brushing_mousePos);
float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);
return distance <= brushing_radius;
}
bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
}
void brushing_setVisible(bool visible) {
brushing_isVisible = float(visible);
}
`;
const fs = `
uniform bool brushing_enabled;
in float brushing_isVisible;
`;
const TARGET = {
    source: 0,
    target: 1,
    custom: 2,
    source_target: 3
};
const inject = {
    'vs:DECKGL_FILTER_GL_POSITION': `
vec2 brushingTarget;
vec2 brushingSource;
if (brushing_target == 3) {
brushingTarget = geometry.worldPositionAlt.xy;
brushingSource = geometry.worldPosition.xy;
} else if (brushing_target == 0) {
brushingTarget = geometry.worldPosition.xy;
} else if (brushing_target == 1) {
brushingTarget = geometry.worldPositionAlt.xy;
} else {
#ifdef NON_INSTANCED_MODEL
brushingTarget = brushingTargets;
#else
brushingTarget = instanceBrushingTargets;
#endif
}
bool visible;
if (brushing_target == 3) {
visible = brushing_arePointsInRange(brushingSource, brushingTarget);
} else {
visible = brushing_isPointInRange(brushingTarget);
}
brushing_setVisible(visible);
`,
    'fs:DECKGL_FILTER_COLOR': `
    if (brushing_enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
};
export default {
    name: 'brushing',
    dependencies: [project],
    vs,
    fs,
    inject,
    getUniforms: (opts) => {
        if (!opts || !('viewport' in opts)) {
            return {};
        }
        const { brushingEnabled = true, brushingRadius = 10000, brushingTarget = 'source', mousePosition, viewport } = opts;
        return {
            brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
            brushing_radius: brushingRadius,
            brushing_target: TARGET[brushingTarget] || 0,
            brushing_mousePos: mousePosition
                ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])
                : [0, 0]
        };
    }
};
