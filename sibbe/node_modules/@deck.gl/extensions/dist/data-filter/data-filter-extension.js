// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { _deepEqual as deepEqual, LayerExtension, log } from '@deck.gl/core';
import { shaderModule, shaderModule64 } from "./shader-module.js";
import * as aggregator from "./aggregator.js";
const defaultProps = {
    getFilterValue: { type: 'accessor', value: 0 },
    getFilterCategory: { type: 'accessor', value: 0 },
    onFilteredItemsChange: { type: 'function', value: null, optional: true },
    filterEnabled: true,
    filterRange: [-1, 1],
    filterSoftRange: null,
    filterCategories: [0],
    filterTransformSize: true,
    filterTransformColor: true
};
const defaultOptions = {
    categorySize: 1,
    filterSize: 1,
    fp64: false,
    countItems: false
};
const DATA_TYPE_FROM_SIZE = {
    1: 'float',
    2: 'vec2',
    3: 'vec3',
    4: 'vec4'
};
/** Adds GPU-based data filtering functionalities to layers. It allows the layer to show/hide objects based on user-defined properties. */
export default class DataFilterExtension extends LayerExtension {
    static { this.defaultProps = defaultProps; }
    static { this.extensionName = 'DataFilterExtension'; }
    constructor(opts = {}) {
        super({ ...defaultOptions, ...opts });
    }
    getShaders(extension) {
        const { categorySize, filterSize, fp64 } = extension.opts;
        return {
            modules: [fp64 ? shaderModule64 : shaderModule],
            defines: {
                DATACATEGORY_TYPE: DATA_TYPE_FROM_SIZE[categorySize],
                DATACATEGORY_CHANNELS: categorySize,
                DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
                DATAFILTER_DOUBLE: Boolean(fp64)
            }
        };
    }
    initializeState(context, extension) {
        const attributeManager = this.getAttributeManager();
        const { categorySize, filterSize, fp64 } = extension.opts;
        if (attributeManager) {
            attributeManager.add({
                filterValues: {
                    size: filterSize,
                    type: fp64 ? 'float64' : 'float32',
                    accessor: 'getFilterValue',
                    shaderAttributes: {
                        filterValues: {
                            divisor: 0
                        },
                        instanceFilterValues: {
                            divisor: 1
                        }
                    }
                },
                filterCategoryValues: {
                    size: categorySize,
                    accessor: 'getFilterCategory',
                    transform: categorySize === 1
                        ? d => extension._getCategoryKey.call(this, d, 0)
                        : d => d.map((x, i) => extension._getCategoryKey.call(this, x, i)),
                    shaderAttributes: {
                        filterCategoryValues: {
                            divisor: 0
                        },
                        instanceFilterCategoryValues: {
                            divisor: 1
                        }
                    }
                }
            });
        }
        const { device } = this.context;
        if (attributeManager && extension.opts.countItems) {
            const useFloatTarget = aggregator.supportsFloatTarget(device);
            // This attribute is needed for variable-width data, e.g. Path, SolidPolygon, Text
            // The vertex shader checks if a vertex has the same "index" as the previous vertex
            // so that we only write one count cross multiple vertices of the same object
            attributeManager.add({
                filterIndices: {
                    size: useFloatTarget ? 1 : 2,
                    vertexOffset: 1,
                    type: 'unorm8',
                    accessor: (object, { index }) => {
                        const i = object && object.__source ? object.__source.index : index;
                        return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];
                    },
                    shaderAttributes: {
                        filterPrevIndices: {
                            vertexOffset: 0
                        },
                        filterIndices: {
                            vertexOffset: 1
                        }
                    }
                }
            });
            const filterFBO = aggregator.getFramebuffer(device, useFloatTarget);
            const filterModel = aggregator.getModel(device, extension.getShaders.call(this, extension), useFloatTarget);
            this.setState({ filterFBO, filterModel });
        }
    }
    updateState({ props, oldProps, changeFlags }, extension) {
        const attributeManager = this.getAttributeManager();
        const { categorySize } = extension.opts;
        if (this.state.filterModel) {
            const filterNeedsUpdate = 
            // attributeManager must be defined for filterModel to be set
            attributeManager.attributes.filterValues.needsUpdate() ||
                attributeManager.attributes.filterCategoryValues?.needsUpdate() ||
                props.filterEnabled !== oldProps.filterEnabled ||
                props.filterRange !== oldProps.filterRange ||
                props.filterSoftRange !== oldProps.filterSoftRange ||
                props.filterCategories !== oldProps.filterCategories;
            if (filterNeedsUpdate) {
                this.setState({ filterNeedsUpdate });
            }
        }
        if (attributeManager?.attributes.filterCategoryValues) {
            // Update bitmask if accessor or selected categories has changed
            const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() ||
                !deepEqual(props.filterCategories, oldProps.filterCategories, 2);
            if (categoryBitMaskNeedsUpdate) {
                this.setState({ categoryBitMaskNeedsUpdate });
            }
            // Need to recreate category map if categorySize has changed
            const resetCategories = changeFlags.dataChanged;
            if (resetCategories) {
                this.setState({
                    categoryMap: Array(categorySize)
                        .fill(0)
                        .map(() => ({}))
                });
                attributeManager.attributes.filterCategoryValues.setNeedsUpdate('categoryMap');
            }
        }
    }
    draw(params, extension) {
        const filterFBO = this.state.filterFBO;
        const filterModel = this.state.filterModel;
        const filterNeedsUpdate = this.state.filterNeedsUpdate;
        const categoryBitMaskNeedsUpdate = this.state.categoryBitMaskNeedsUpdate;
        const { onFilteredItemsChange } = this.props;
        if (categoryBitMaskNeedsUpdate) {
            extension._updateCategoryBitMask.call(this, params, extension);
        }
        if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
            const { attributes: { filterValues, filterCategoryValues, filterIndices } } = this.getAttributeManager();
            filterModel.setVertexCount(this.getNumInstances());
            this.context.device.clearWebGL({ framebuffer: filterFBO, color: [0, 0, 0, 0] });
            filterModel.updateModuleSettings(params.moduleParameters);
            // @ts-expect-error filterValue and filterIndices should always have buffer value
            filterModel.setAttributes({
                ...filterValues.getValue(),
                ...filterCategoryValues?.getValue(),
                ...filterIndices?.getValue()
            });
            filterModel.setUniforms(params.uniforms);
            filterModel.device.withParametersWebGL({
                framebuffer: filterFBO,
                // ts-ignore 'readonly' cannot be assigned to the mutable type '[GLBlendEquation, GLBlendEquation]'
                ...aggregator.parameters,
                viewport: [0, 0, filterFBO.width, filterFBO.height]
            }, () => {
                filterModel.draw(this.context.renderPass);
            });
            const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
            let count = 0;
            for (let i = 0; i < color.length; i++) {
                count += color[i];
            }
            onFilteredItemsChange({ id: this.id, count });
            this.state.filterNeedsUpdate = false;
        }
    }
    finalizeState() {
        const filterFBO = this.state.filterFBO;
        const filterModel = this.state.filterModel;
        // filterFBO.color.delete();
        filterFBO?.destroy();
        filterModel?.destroy();
    }
    /**
     * Updates the bitmask used on the GPU to perform the filter based on the
     * `filterCategories` prop. The mapping between categories and bit in the bitmask
     * is performed by `_getCategoryKey()`
     */
    _updateCategoryBitMask(params, extension) {
        const { categorySize } = extension.opts;
        const { filterCategories } = this.props;
        const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
        const categoryFilters = (categorySize === 1 ? [filterCategories] : filterCategories);
        const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
        for (let c = 0; c < categoryFilters.length; c++) {
            const categoryFilter = categoryFilters[c];
            for (const category of categoryFilter) {
                const key = extension._getCategoryKey.call(this, category, c);
                if (key < maxCategories) {
                    const channel = c * (maxCategories / 32) + Math.floor(key / 32);
                    categoryBitMask[channel] += Math.pow(2, key % 32); // 1 << key fails for key > 30
                }
                else {
                    log.warn(`Exceeded maximum number of categories (${maxCategories})`)();
                }
            }
        }
        /* eslint-disable-next-line camelcase */
        params.uniforms.filter_categoryBitMask = categoryBitMask;
        this.state.categoryBitMaskNeedsUpdate = false;
    }
    /**
     * Returns an index of bit in the bitmask for a given category. If the category has
     * not yet been assigned a bit, a new one is assigned.
     */
    _getCategoryKey(category, channel) {
        const categoryMap = this.state.categoryMap[channel];
        if (!(category in categoryMap)) {
            categoryMap[category] = Object.keys(categoryMap).length;
        }
        return categoryMap[category];
    }
}
