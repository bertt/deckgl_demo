(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // ../../node_modules/jsep/build/jsep.js
  var require_jsep = __commonJS({
    "../../node_modules/jsep/build/jsep.js"(exports, module) {
      (function(root) {
        "use strict";
        var COMPOUND = "Compound", IDENTIFIER = "Identifier", MEMBER_EXP = "MemberExpression", LITERAL = "Literal", THIS_EXP = "ThisExpression", CALL_EXP = "CallExpression", UNARY_EXP = "UnaryExpression", BINARY_EXP = "BinaryExpression", LOGICAL_EXP = "LogicalExpression", CONDITIONAL_EXP = "ConditionalExpression", ARRAY_EXP = "ArrayExpression", PERIOD_CODE = 46, COMMA_CODE = 44, SQUOTE_CODE = 39, DQUOTE_CODE = 34, OPAREN_CODE = 40, CPAREN_CODE = 41, OBRACK_CODE = 91, CBRACK_CODE = 93, QUMARK_CODE = 63, SEMCOL_CODE = 59, COLON_CODE = 58, throwError = function(message, index) {
          var error = new Error(message + " at character " + index);
          error.index = index;
          error.description = message;
          throw error;
        }, t2 = true, unary_ops = { "-": t2, "!": t2, "~": t2, "+": t2 }, binary_ops = {
          "||": 1,
          "&&": 2,
          "|": 3,
          "^": 4,
          "&": 5,
          "==": 6,
          "!=": 6,
          "===": 6,
          "!==": 6,
          "<": 7,
          ">": 7,
          "<=": 7,
          ">=": 7,
          "<<": 8,
          ">>": 8,
          ">>>": 8,
          "+": 9,
          "-": 9,
          "*": 10,
          "/": 10,
          "%": 10
        }, getMaxKeyLen = function(obj) {
          var max_len = 0, len;
          for (var key in obj) {
            if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {
              max_len = len;
            }
          }
          return max_len;
        }, max_unop_len = getMaxKeyLen(unary_ops), max_binop_len = getMaxKeyLen(binary_ops), literals = {
          "true": true,
          "false": false,
          "null": null
        }, this_str = "this", binaryPrecedence = function(op_val) {
          return binary_ops[op_val] || 0;
        }, createBinaryExpression = function(operator, left, right) {
          var type = operator === "||" || operator === "&&" ? LOGICAL_EXP : BINARY_EXP;
          return {
            type,
            operator,
            left,
            right
          };
        }, isDecimalDigit = function(ch) {
          return ch >= 48 && ch <= 57;
        }, isIdentifierStart = function(ch) {
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 128 && !binary_ops[String.fromCharCode(ch)];
        }, isIdentifierPart = function(ch) {
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 48 && ch <= 57 || ch >= 128 && !binary_ops[String.fromCharCode(ch)];
        }, jsep = function(expr) {
          var index = 0, charAtFunc = expr.charAt, charCodeAtFunc = expr.charCodeAt, exprI = function(i2) {
            return charAtFunc.call(expr, i2);
          }, exprICode = function(i2) {
            return charCodeAtFunc.call(expr, i2);
          }, length = expr.length, gobbleSpaces = function() {
            var ch = exprICode(index);
            while (ch === 32 || ch === 9 || ch === 10 || ch === 13) {
              ch = exprICode(++index);
            }
          }, gobbleExpression = function() {
            var test = gobbleBinaryExpression(), consequent, alternate;
            gobbleSpaces();
            if (exprICode(index) === QUMARK_CODE) {
              index++;
              consequent = gobbleExpression();
              if (!consequent) {
                throwError("Expected expression", index);
              }
              gobbleSpaces();
              if (exprICode(index) === COLON_CODE) {
                index++;
                alternate = gobbleExpression();
                if (!alternate) {
                  throwError("Expected expression", index);
                }
                return {
                  type: CONDITIONAL_EXP,
                  test,
                  consequent,
                  alternate
                };
              } else {
                throwError("Expected :", index);
              }
            } else {
              return test;
            }
          }, gobbleBinaryOp = function() {
            gobbleSpaces();
            var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
            while (tc_len > 0) {
              if (binary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {
                index += tc_len;
                return to_check;
              }
              to_check = to_check.substr(0, --tc_len);
            }
            return false;
          }, gobbleBinaryExpression = function() {
            var ch_i2, node2, biop, prec, stack, biop_info, left, right, i2, cur_biop;
            left = gobbleToken();
            biop = gobbleBinaryOp();
            if (!biop) {
              return left;
            }
            biop_info = { value: biop, prec: binaryPrecedence(biop) };
            right = gobbleToken();
            if (!right) {
              throwError("Expected expression after " + biop, index);
            }
            stack = [left, biop_info, right];
            while (biop = gobbleBinaryOp()) {
              prec = binaryPrecedence(biop);
              if (prec === 0) {
                break;
              }
              biop_info = { value: biop, prec };
              cur_biop = biop;
              while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
                right = stack.pop();
                biop = stack.pop().value;
                left = stack.pop();
                node2 = createBinaryExpression(biop, left, right);
                stack.push(node2);
              }
              node2 = gobbleToken();
              if (!node2) {
                throwError("Expected expression after " + cur_biop, index);
              }
              stack.push(biop_info, node2);
            }
            i2 = stack.length - 1;
            node2 = stack[i2];
            while (i2 > 1) {
              node2 = createBinaryExpression(stack[i2 - 1].value, stack[i2 - 2], node2);
              i2 -= 2;
            }
            return node2;
          }, gobbleToken = function() {
            var ch, to_check, tc_len;
            gobbleSpaces();
            ch = exprICode(index);
            if (isDecimalDigit(ch) || ch === PERIOD_CODE) {
              return gobbleNumericLiteral();
            } else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
              return gobbleStringLiteral();
            } else if (ch === OBRACK_CODE) {
              return gobbleArray();
            } else {
              to_check = expr.substr(index, max_unop_len);
              tc_len = to_check.length;
              while (tc_len > 0) {
                if (unary_ops.hasOwnProperty(to_check) && (!isIdentifierStart(exprICode(index)) || index + to_check.length < expr.length && !isIdentifierPart(exprICode(index + to_check.length)))) {
                  index += tc_len;
                  return {
                    type: UNARY_EXP,
                    operator: to_check,
                    argument: gobbleToken(),
                    prefix: true
                  };
                }
                to_check = to_check.substr(0, --tc_len);
              }
              if (isIdentifierStart(ch) || ch === OPAREN_CODE) {
                return gobbleVariable();
              }
            }
            return false;
          }, gobbleNumericLiteral = function() {
            var number = "", ch, chCode;
            while (isDecimalDigit(exprICode(index))) {
              number += exprI(index++);
            }
            if (exprICode(index) === PERIOD_CODE) {
              number += exprI(index++);
              while (isDecimalDigit(exprICode(index))) {
                number += exprI(index++);
              }
            }
            ch = exprI(index);
            if (ch === "e" || ch === "E") {
              number += exprI(index++);
              ch = exprI(index);
              if (ch === "+" || ch === "-") {
                number += exprI(index++);
              }
              while (isDecimalDigit(exprICode(index))) {
                number += exprI(index++);
              }
              if (!isDecimalDigit(exprICode(index - 1))) {
                throwError("Expected exponent (" + number + exprI(index) + ")", index);
              }
            }
            chCode = exprICode(index);
            if (isIdentifierStart(chCode)) {
              throwError("Variable names cannot start with a number (" + number + exprI(index) + ")", index);
            } else if (chCode === PERIOD_CODE) {
              throwError("Unexpected period", index);
            }
            return {
              type: LITERAL,
              value: parseFloat(number),
              raw: number
            };
          }, gobbleStringLiteral = function() {
            var str = "", quote = exprI(index++), closed = false, ch;
            while (index < length) {
              ch = exprI(index++);
              if (ch === quote) {
                closed = true;
                break;
              } else if (ch === "\\") {
                ch = exprI(index++);
                switch (ch) {
                  case "n":
                    str += "\n";
                    break;
                  case "r":
                    str += "\r";
                    break;
                  case "t":
                    str += "	";
                    break;
                  case "b":
                    str += "\b";
                    break;
                  case "f":
                    str += "\f";
                    break;
                  case "v":
                    str += "\v";
                    break;
                  default:
                    str += ch;
                }
              } else {
                str += ch;
              }
            }
            if (!closed) {
              throwError('Unclosed quote after "' + str + '"', index);
            }
            return {
              type: LITERAL,
              value: str,
              raw: quote + str + quote
            };
          }, gobbleIdentifier = function() {
            var ch = exprICode(index), start = index, identifier;
            if (isIdentifierStart(ch)) {
              index++;
            } else {
              throwError("Unexpected " + exprI(index), index);
            }
            while (index < length) {
              ch = exprICode(index);
              if (isIdentifierPart(ch)) {
                index++;
              } else {
                break;
              }
            }
            identifier = expr.slice(start, index);
            if (literals.hasOwnProperty(identifier)) {
              return {
                type: LITERAL,
                value: literals[identifier],
                raw: identifier
              };
            } else if (identifier === this_str) {
              return { type: THIS_EXP };
            } else {
              return {
                type: IDENTIFIER,
                name: identifier
              };
            }
          }, gobbleArguments = function(termination) {
            var ch_i2, args = [], node2, closed = false;
            var separator_count = 0;
            while (index < length) {
              gobbleSpaces();
              ch_i2 = exprICode(index);
              if (ch_i2 === termination) {
                closed = true;
                index++;
                if (termination === CPAREN_CODE && separator_count && separator_count >= args.length) {
                  throwError("Unexpected token " + String.fromCharCode(termination), index);
                }
                break;
              } else if (ch_i2 === COMMA_CODE) {
                index++;
                separator_count++;
                if (separator_count !== args.length) {
                  if (termination === CPAREN_CODE) {
                    throwError("Unexpected token ,", index);
                  } else if (termination === CBRACK_CODE) {
                    for (var arg = args.length; arg < separator_count; arg++) {
                      args.push(null);
                    }
                  }
                }
              } else {
                node2 = gobbleExpression();
                if (!node2 || node2.type === COMPOUND) {
                  throwError("Expected comma", index);
                }
                args.push(node2);
              }
            }
            if (!closed) {
              throwError("Expected " + String.fromCharCode(termination), index);
            }
            return args;
          }, gobbleVariable = function() {
            var ch_i2, node2;
            ch_i2 = exprICode(index);
            if (ch_i2 === OPAREN_CODE) {
              node2 = gobbleGroup();
            } else {
              node2 = gobbleIdentifier();
            }
            gobbleSpaces();
            ch_i2 = exprICode(index);
            while (ch_i2 === PERIOD_CODE || ch_i2 === OBRACK_CODE || ch_i2 === OPAREN_CODE) {
              index++;
              if (ch_i2 === PERIOD_CODE) {
                gobbleSpaces();
                node2 = {
                  type: MEMBER_EXP,
                  computed: false,
                  object: node2,
                  property: gobbleIdentifier()
                };
              } else if (ch_i2 === OBRACK_CODE) {
                node2 = {
                  type: MEMBER_EXP,
                  computed: true,
                  object: node2,
                  property: gobbleExpression()
                };
                gobbleSpaces();
                ch_i2 = exprICode(index);
                if (ch_i2 !== CBRACK_CODE) {
                  throwError("Unclosed [", index);
                }
                index++;
              } else if (ch_i2 === OPAREN_CODE) {
                node2 = {
                  type: CALL_EXP,
                  "arguments": gobbleArguments(CPAREN_CODE),
                  callee: node2
                };
              }
              gobbleSpaces();
              ch_i2 = exprICode(index);
            }
            return node2;
          }, gobbleGroup = function() {
            index++;
            var node2 = gobbleExpression();
            gobbleSpaces();
            if (exprICode(index) === CPAREN_CODE) {
              index++;
              return node2;
            } else {
              throwError("Unclosed (", index);
            }
          }, gobbleArray = function() {
            index++;
            return {
              type: ARRAY_EXP,
              elements: gobbleArguments(CBRACK_CODE)
            };
          }, nodes = [], ch_i, node;
          while (index < length) {
            ch_i = exprICode(index);
            if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
              index++;
            } else {
              if (node = gobbleExpression()) {
                nodes.push(node);
              } else if (index < length) {
                throwError('Unexpected "' + exprI(index) + '"', index);
              }
            }
          }
          if (nodes.length === 1) {
            return nodes[0];
          } else {
            return {
              type: COMPOUND,
              body: nodes
            };
          }
        };
        jsep.version = "0.3.5";
        jsep.toString = function() {
          return "JavaScript Expression Parser (JSEP) v" + jsep.version;
        };
        jsep.addUnaryOp = function(op_name) {
          max_unop_len = Math.max(op_name.length, max_unop_len);
          unary_ops[op_name] = t2;
          return this;
        };
        jsep.addBinaryOp = function(op_name, precedence) {
          max_binop_len = Math.max(op_name.length, max_binop_len);
          binary_ops[op_name] = precedence;
          return this;
        };
        jsep.addLiteral = function(literal_name, literal_value) {
          literals[literal_name] = literal_value;
          return this;
        };
        jsep.removeUnaryOp = function(op_name) {
          delete unary_ops[op_name];
          if (op_name.length === max_unop_len) {
            max_unop_len = getMaxKeyLen(unary_ops);
          }
          return this;
        };
        jsep.removeAllUnaryOps = function() {
          unary_ops = {};
          max_unop_len = 0;
          return this;
        };
        jsep.removeBinaryOp = function(op_name) {
          delete binary_ops[op_name];
          if (op_name.length === max_binop_len) {
            max_binop_len = getMaxKeyLen(binary_ops);
          }
          return this;
        };
        jsep.removeAllBinaryOps = function() {
          binary_ops = {};
          max_binop_len = 0;
          return this;
        };
        jsep.removeLiteral = function(literal_name) {
          delete literals[literal_name];
          return this;
        };
        jsep.removeAllLiterals = function() {
          literals = {};
          return this;
        };
        if (typeof exports === "undefined") {
          var old_jsep = root.jsep;
          root.jsep = jsep;
          jsep.noConflict = function() {
            if (root.jsep === jsep) {
              root.jsep = old_jsep;
            }
            return jsep;
          };
        } else {
          if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = jsep;
          } else {
            exports.parse = jsep;
          }
        }
      })(exports);
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    JSONConfiguration: () => JSONConfiguration,
    JSONConverter: () => JSONConverter,
    Transport: () => Transport,
    _convertFunctions: () => convertFunctions,
    _parseExpressionString: () => parseExpressionString,
    _shallowEqualObjects: () => shallowEqualObjects
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core(), 1);
  __reExport(peer_dependency_exports, __toESM(require_core(), 1));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/utils/assert.ts
  function assert(condition, message = "") {
    if (!condition) {
      throw new Error(`JSON conversion error ${message}`);
    }
  }

  // src/utils/get.ts
  function get(container, compositeKey) {
    const keyList = getKeys(compositeKey);
    let value = container;
    for (const key of keyList) {
      value = isObject(value) ? value[key] : void 0;
    }
    return value;
  }
  function isObject(value) {
    return value !== null && typeof value === "object";
  }
  var keyMap = {};
  function getKeys(compositeKey) {
    if (typeof compositeKey === "string") {
      let keyList = keyMap[compositeKey];
      if (!keyList) {
        keyList = compositeKey.split(".");
        keyMap[compositeKey] = keyList;
      }
      return keyList;
    }
    return Array.isArray(compositeKey) ? compositeKey : [compositeKey];
  }

  // ../../node_modules/expression-eval/dist/expression-eval.module.js
  var expression_eval_module_exports = {};
  __export(expression_eval_module_exports, {
    addBinaryOp: () => m,
    addUnaryOp: () => p,
    compile: () => l,
    compileAsync: () => f,
    eval: () => a,
    evalAsync: () => e,
    parse: () => import_jsep2.default
  });
  var import_jsep = __toESM(require_jsep());
  var import_jsep2 = __toESM(require_jsep());
  var e = function r2(e2, o2) {
    try {
      var s2, c2 = e2;
      switch (c2.type) {
        case "ArrayExpression":
          return Promise.resolve(t(c2.elements, o2));
        case "BinaryExpression":
          return Promise.resolve(Promise.all([r2(c2.left, o2), r2(c2.right, o2)])).then(function(r3) {
            return u[c2.operator](r3[0], r3[1]);
          });
        case "CallExpression":
          var a2, l2, f2, p2 = function() {
            if ("function" == typeof l2) {
              var r3 = l2, e3 = r3.apply, n2 = a2;
              return Promise.resolve(t(c2.arguments, o2)).then(function(t2) {
                return Promise.resolve(e3.call(r3, n2, t2));
              });
            }
          }, m2 = "MemberExpression" === c2.callee.type ? Promise.resolve(n(c2.callee, o2)).then(function(r3) {
            a2 = (f2 = r3)[0], l2 = f2[1];
          }) : Promise.resolve(r2(c2.callee, o2)).then(function(r3) {
            l2 = r3;
          });
          return Promise.resolve(m2 && m2.then ? m2.then(p2) : p2());
        case "ConditionalExpression":
          return Promise.resolve(r2(c2.test, o2)).then(function(e3) {
            return Promise.resolve(r2(e3 ? c2.consequent : c2.alternate, o2));
          });
        case "Identifier":
          return Promise.resolve(o2[c2.name]);
        case "Literal":
          return Promise.resolve(c2.value);
        case "LogicalExpression":
          var v = function(e3) {
            return s2 ? e3 : Promise.resolve(Promise.all([r2(c2.left, o2), r2(c2.right, o2)])).then(function(r3) {
              return u[c2.operator](r3[0], r3[1]);
            });
          }, h = "||" === c2.operator ? (s2 = 1, Promise.resolve(r2(c2.left, o2)).then(function(e3) {
            return e3 || Promise.resolve(r2(c2.right, o2));
          })) : function() {
            if ("&&" === c2.operator)
              return s2 = 1, Promise.resolve(r2(c2.left, o2)).then(function(e3) {
                return e3 ? Promise.resolve(r2(c2.right, o2)) : e3;
              });
          }();
          return Promise.resolve(h && h.then ? h.then(v) : v(h));
        case "MemberExpression":
          return Promise.resolve(n(c2, o2)).then(function(r3) {
            return r3[1];
          });
        case "ThisExpression":
          return Promise.resolve(o2);
        case "UnaryExpression":
          var P = i[c2.operator];
          return Promise.resolve(r2(c2.argument, o2)).then(function(r3) {
            return P.call(i, r3);
          });
        default:
          return Promise.resolve(void 0);
      }
    } catch (r3) {
      return Promise.reject(r3);
    }
  };
  var n = function(r3, n2) {
    try {
      return Promise.resolve(e(r3.object, n2)).then(function(t2) {
        function o2() {
          if (/^__proto__|prototype|constructor$/.test(u2))
            throw Error('Access to member "' + u2 + '" disallowed.');
          return [t2, t2[u2]];
        }
        var u2, i2 = function() {
          if (r3.computed)
            return Promise.resolve(e(r3.property, n2)).then(function(r4) {
              u2 = r4;
            });
          u2 = r3.property.name;
        }();
        return i2 && i2.then ? i2.then(o2) : o2();
      });
    } catch (r4) {
      return Promise.reject(r4);
    }
  };
  var t = function(r3, n2) {
    try {
      return Promise.resolve(Promise.all(r3.map(function(r4) {
        return e(r4, n2);
      })));
    } catch (r4) {
      return Promise.reject(r4);
    }
  };
  var o = { "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 10, "/": 10, "%": 10 };
  var u = { "||": function(r3, e2) {
    return r3 || e2;
  }, "&&": function(r3, e2) {
    return r3 && e2;
  }, "|": function(r3, e2) {
    return r3 | e2;
  }, "^": function(r3, e2) {
    return r3 ^ e2;
  }, "&": function(r3, e2) {
    return r3 & e2;
  }, "==": function(r3, e2) {
    return r3 == e2;
  }, "!=": function(r3, e2) {
    return r3 != e2;
  }, "===": function(r3, e2) {
    return r3 === e2;
  }, "!==": function(r3, e2) {
    return r3 !== e2;
  }, "<": function(r3, e2) {
    return r3 < e2;
  }, ">": function(r3, e2) {
    return r3 > e2;
  }, "<=": function(r3, e2) {
    return r3 <= e2;
  }, ">=": function(r3, e2) {
    return r3 >= e2;
  }, "<<": function(r3, e2) {
    return r3 << e2;
  }, ">>": function(r3, e2) {
    return r3 >> e2;
  }, ">>>": function(r3, e2) {
    return r3 >>> e2;
  }, "+": function(r3, e2) {
    return r3 + e2;
  }, "-": function(r3, e2) {
    return r3 - e2;
  }, "*": function(r3, e2) {
    return r3 * e2;
  }, "/": function(r3, e2) {
    return r3 / e2;
  }, "%": function(r3, e2) {
    return r3 % e2;
  } };
  var i = { "-": function(r3) {
    return -r3;
  }, "+": function(r3) {
    return +r3;
  }, "~": function(r3) {
    return ~r3;
  }, "!": function(r3) {
    return !r3;
  } };
  function s(r3, e2) {
    return r3.map(function(r4) {
      return a(r4, e2);
    });
  }
  function c(r3, e2) {
    var n2, t2 = a(r3.object, e2);
    if (n2 = r3.computed ? a(r3.property, e2) : r3.property.name, /^__proto__|prototype|constructor$/.test(n2))
      throw Error('Access to member "' + n2 + '" disallowed.');
    return [t2, t2[n2]];
  }
  function a(r3, e2) {
    var n2 = r3;
    switch (n2.type) {
      case "ArrayExpression":
        return s(n2.elements, e2);
      case "BinaryExpression":
        return u[n2.operator](a(n2.left, e2), a(n2.right, e2));
      case "CallExpression":
        var t2, o2, l2;
        if ("MemberExpression" === n2.callee.type ? (t2 = (l2 = c(n2.callee, e2))[0], o2 = l2[1]) : o2 = a(n2.callee, e2), "function" != typeof o2)
          return;
        return o2.apply(t2, s(n2.arguments, e2));
      case "ConditionalExpression":
        return a(n2.test, e2) ? a(n2.consequent, e2) : a(n2.alternate, e2);
      case "Identifier":
        return e2[n2.name];
      case "Literal":
        return n2.value;
      case "LogicalExpression":
        return "||" === n2.operator ? a(n2.left, e2) || a(n2.right, e2) : "&&" === n2.operator ? a(n2.left, e2) && a(n2.right, e2) : u[n2.operator](a(n2.left, e2), a(n2.right, e2));
      case "MemberExpression":
        return c(n2, e2)[1];
      case "ThisExpression":
        return e2;
      case "UnaryExpression":
        return i[n2.operator](a(n2.argument, e2));
      default:
        return;
    }
  }
  function l(e2) {
    return a.bind(null, (0, import_jsep.default)(e2));
  }
  function f(n2) {
    return e.bind(null, (0, import_jsep.default)(n2));
  }
  function p(e2, n2) {
    import_jsep.default.addUnaryOp(e2), i[e2] = n2;
  }
  function m(e2, n2, t2) {
    t2 ? (import_jsep.default.addBinaryOp(e2, n2), u[e2] = t2) : (import_jsep.default.addBinaryOp(e2, o[e2] || 1), u[e2] = n2);
  }

  // src/helpers/parse-expression-string.ts
  var { parse, eval: evaluate } = expression_eval_module_exports;
  var cachedExpressionMap = {
    "-": (object) => object
  };
  function parseExpressionString(propValue, configuration) {
    if (propValue in cachedExpressionMap) {
      return cachedExpressionMap[propValue];
    }
    let func;
    const ast = parse(propValue);
    if (ast.type === "Identifier") {
      func = (row) => {
        return get(row, propValue);
      };
    } else {
      traverse(ast, (node) => {
        if (node.type === "CallExpression") {
          throw new Error("Function calls not allowed in JSON expressions");
        }
      });
      func = (row) => {
        return evaluate(ast, row);
      };
    }
    cachedExpressionMap[propValue] = func;
    return func;
  }
  function traverse(node, visitor) {
    if (Array.isArray(node)) {
      node.forEach((element) => traverse(element, visitor));
    } else if (node && typeof node === "object") {
      if (node.type) {
        visitor(node);
      }
      for (const key in node) {
        traverse(node[key], visitor);
      }
    }
  }

  // src/syntactic-sugar.ts
  var FUNCTION_IDENTIFIER = "@@=";
  var CONSTANT_IDENTIFIER = "@@#";
  var TYPE_KEY = "@@type";
  var FUNCTION_KEY = "@@function";

  // src/json-configuration.ts
  var isObject2 = (value) => value && typeof value === "object";
  var JSONConfiguration = class {
    constructor(...configurations) {
      this.typeKey = TYPE_KEY;
      this.functionKey = FUNCTION_KEY;
      this.log = console;
      this.classes = {};
      this.reactComponents = {};
      this.enumerations = {};
      this.constants = {};
      this.functions = {};
      this.React = null;
      this.convertFunction = parseExpressionString;
      this.preProcessClassProps = (Class, props) => props;
      this.postProcessConvertedJson = (json) => json;
      for (const configuration of configurations) {
        this.merge(configuration);
      }
    }
    merge(configuration) {
      for (const key in configuration) {
        switch (key) {
          case "layers":
          case "views":
            Object.assign(this.classes, configuration[key]);
            break;
          default:
            if (key in this) {
              const value = configuration[key];
              this[key] = isObject2(this[key]) ? Object.assign(this[key], value) : value;
            }
        }
      }
    }
    validate(configuration) {
      assert(!this.typeKey || typeof this.typeKey === "string");
      assert(isObject2(this.classes));
      return true;
    }
  };

  // src/helpers/convert-functions.ts
  function hasFunctionIdentifier(value) {
    return typeof value === "string" && value.startsWith(FUNCTION_IDENTIFIER);
  }
  function trimFunctionIdentifier(value) {
    return value.replace(FUNCTION_IDENTIFIER, "");
  }
  function convertFunctions(props, configuration) {
    const replacedProps = {};
    for (const propName in props) {
      let propValue = props[propName];
      const isFunction = hasFunctionIdentifier(propValue);
      if (isFunction) {
        propValue = trimFunctionIdentifier(propValue);
        propValue = parseExpressionString(propValue, configuration);
      }
      replacedProps[propName] = propValue;
    }
    return replacedProps;
  }

  // src/helpers/instantiate-class.ts
  function instantiateClass(type, props, configuration) {
    const Class = configuration.classes[type];
    const Component = configuration.reactComponents[type];
    if (!Class && !Component) {
      const { log } = configuration;
      if (log) {
        const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
        log.warn(`JSON converter: No registered class of type ${type}(${stringProps}...)  `);
      }
      return null;
    }
    if (Class) {
      return instantiateJavaScriptClass(Class, props, configuration);
    }
    return instantiateReactComponent(Component, props, configuration);
  }
  function instantiateJavaScriptClass(Class, props, configuration) {
    if (configuration.preProcessClassProps) {
      props = configuration.preProcessClassProps(Class, props, configuration);
    }
    props = convertFunctions(props, configuration);
    return new Class(props);
  }
  function instantiateReactComponent(Component, props, configuration) {
    const { React } = configuration;
    const { children = [] } = props;
    delete props.children;
    if (configuration.preProcessClassProps) {
      props = configuration.preProcessClassProps(Component, props, configuration);
    }
    props = convertFunctions(props, configuration);
    return React.createElement(Component, props, children);
  }

  // src/helpers/execute-function.ts
  function executeFunction(targetFunction, props, configuration) {
    const matchedFunction = configuration.functions[targetFunction];
    if (!matchedFunction) {
      const { log } = configuration;
      if (log) {
        const stringProps = JSON.stringify(props, null, 0).slice(0, 40);
        log.warn(`JSON converter: No registered function ${targetFunction}(${stringProps}...)  `);
      }
      return null;
    }
    return matchedFunction(props);
  }

  // src/helpers/parse-json.ts
  function parseJSON(json) {
    return typeof json === "string" ? JSON.parse(json) : json;
  }

  // src/json-converter.ts
  var isObject3 = (value) => value && typeof value === "object";
  var JSONConverter = class {
    constructor(props) {
      this.log = console;
      this.onJSONChange = () => {
      };
      this.json = null;
      this.convertedJson = null;
      this.setProps(props);
    }
    finalize() {
    }
    setProps(props) {
      if ("configuration" in props) {
        this.configuration = props.configuration instanceof JSONConfiguration ? props.configuration : new JSONConfiguration(props.configuration);
      }
      if ("onJSONChange" in props) {
        this.onJSONChange = props.onJSONChange;
      }
    }
    mergeConfiguration(config) {
      this.configuration.merge(config);
    }
    convert(json) {
      if (!json || json === this.json) {
        return this.convertedJson;
      }
      this.json = json;
      const parsedJSON = parseJSON(json);
      let convertedJson = convertJSON(parsedJSON, this.configuration);
      convertedJson = this.configuration.postProcessConvertedJson(convertedJson);
      this.convertedJson = convertedJson;
      return convertedJson;
    }
    convertJson(json) {
      return this.convert(json);
    }
  };
  function convertJSON(json, configuration) {
    configuration = new JSONConfiguration(configuration);
    return convertJSONRecursively(json, "", configuration);
  }
  function convertJSONRecursively(json, key, configuration) {
    if (Array.isArray(json)) {
      return json.map((element, i2) => convertJSONRecursively(element, String(i2), configuration));
    }
    if (isClassInstance(json, configuration)) {
      return convertClassInstance(json, configuration);
    }
    if (isObject3(json)) {
      if (FUNCTION_KEY in json) {
        return convertFunctionObject(json, configuration);
      }
      return convertPlainObject(json, configuration);
    }
    if (typeof json === "string") {
      return convertString(json, key, configuration);
    }
    return json;
  }
  function isClassInstance(json, configuration) {
    const { typeKey } = configuration;
    const isClass = isObject3(json) && Boolean(json[typeKey]);
    return isClass;
  }
  function convertClassInstance(json, configuration) {
    const { typeKey } = configuration;
    const type = json[typeKey];
    let props = { ...json };
    delete props[typeKey];
    props = convertPlainObject(props, configuration);
    return instantiateClass(type, props, configuration);
  }
  function convertFunctionObject(json, configuration) {
    const { functionKey } = configuration;
    const targetFunction = json[functionKey];
    let props = { ...json };
    delete props[functionKey];
    props = convertPlainObject(props, configuration);
    return executeFunction(targetFunction, props, configuration);
  }
  function convertPlainObject(json, configuration) {
    assert(isObject3(json));
    const result = {};
    for (const key in json) {
      const value = json[key];
      result[key] = convertJSONRecursively(value, key, configuration);
    }
    return result;
  }
  function convertString(string, key, configuration) {
    if (string.startsWith(FUNCTION_IDENTIFIER) && configuration.convertFunction) {
      string = string.replace(FUNCTION_IDENTIFIER, "");
      return configuration.convertFunction(string, configuration);
    }
    if (string.startsWith(CONSTANT_IDENTIFIER)) {
      string = string.replace(CONSTANT_IDENTIFIER, "");
      if (configuration.constants[string]) {
        return configuration.constants[string];
      }
      const [enumVarName, enumValName] = string.split(".");
      return configuration.enumerations[enumVarName][enumValName];
    }
    return string;
  }

  // src/transports/transport.ts
  var state = {
    onInitialize: (_) => _,
    onFinalize: (_) => _,
    onMessage: (_) => _
  };
  var Transport = class {
    constructor(name = "Transport") {
      this._messageQueue = [];
      this.userData = {};
      this._destroyed = false;
      this.name = name;
    }
    static setCallbacks({ onInitialize, onFinalize, onMessage }) {
      if (onInitialize) {
        state.onInitialize = onInitialize;
      }
      if (onFinalize) {
        state.onFinalize = onFinalize;
      }
      if (onMessage) {
        state.onMessage = onMessage;
      }
    }
    getRootDOMElement() {
      return typeof document !== "undefined" ? document.body : null;
    }
    sendJSONMessage() {
      console.error("Back-channel not implemented for this transport");
    }
    sendBinaryMessage() {
      console.error("Back-channel not implemented for this transport");
    }
    _initialize(options = {}) {
      const message = { transport: this, ...options };
      state.onInitialize(message);
    }
    _finalize(options = {}) {
      const message = { transport: this, ...options };
      state.onFinalize(message);
      this._destroyed = true;
    }
    _messageReceived(message = {}) {
      message = { transport: this, ...message };
      console.debug("Delivering transport message", message);
      state.onMessage(message);
    }
    static _stringifyJSONSafe(v) {
      const cache = /* @__PURE__ */ new Set();
      return JSON.stringify(v, (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (cache.has(value)) {
            try {
              return JSON.parse(JSON.stringify(value));
            } catch (err) {
              return void 0;
            }
          }
          cache.add(value);
        }
        return value;
      });
    }
  };

  // src/utils/shallow-equal-objects.ts
  function shallowEqualObjects(a2, b) {
    if (a2 === b) {
      return true;
    }
    if (typeof a2 !== "object" || a2 === null || typeof b !== "object" || b === null) {
      return false;
    }
    if (Object.keys(a2).length !== Object.keys(b).length) {
      return false;
    }
    for (const key in a2) {
      if (!(key in b) || a2[key] !== b[key]) {
        return false;
      }
    }
    for (const key in b) {
      if (!(key in a2)) {
        return false;
      }
    }
    return true;
  }
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
