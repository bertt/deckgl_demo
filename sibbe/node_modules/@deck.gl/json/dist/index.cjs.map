{
  "version": 3,
  "sources": ["index.js", "utils/assert.js", "utils/get.js", "helpers/parse-expression-string.js", "syntactic-sugar.js", "json-configuration.js", "helpers/convert-functions.js", "helpers/instantiate-class.js", "helpers/execute-function.js", "helpers/parse-json.js", "json-converter.js", "transports/transport.js", "utils/shallow-equal-objects.js"],
  "sourcesContent": ["// @deck.gl/json: top-level exports\n// Generic JSON converter, usable by other wrapper modules\nexport { default as JSONConverter } from \"./json-converter.js\";\nexport { default as JSONConfiguration } from \"./json-configuration.js\";\n// Transports\nexport { default as Transport } from \"./transports/transport.js\";\n// Helpers\nexport { default as _convertFunctions } from \"./helpers/convert-functions.js\";\nexport { default as _parseExpressionString } from \"./helpers/parse-expression-string.js\";\nexport { shallowEqualObjects as _shallowEqualObjects } from \"./utils/shallow-equal-objects.js\";\n", "export default function assert(condition, message = '') {\n    if (!condition) {\n        throw new Error(`JSON conversion error ${message}`);\n    }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/**\n * Access properties of nested containers using dot-path notation\n * Returns `undefined` if any container is not valid, instead of throwing\n * @param {Object} container - container that supports get\n * @param {String|*} compositeKey - key to access, can be '.'-separated string\n * @return {*} - value in the final key of the nested container, or `undefined`\n */\nexport function get(container, compositeKey) {\n    // Split the key into subkeys\n    const keyList = getKeys(compositeKey);\n    // Recursively get the value of each key;\n    let value = container;\n    for (const key of keyList) {\n        // If any intermediate subfield is not an object, return undefined\n        value = isObject(value) ? value[key] : undefined;\n    }\n    return value;\n}\n/**\n * Checks if argument is an \"indexable\" object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\nfunction isObject(value) {\n    return value !== null && typeof value === 'object';\n}\n// Cache key to key arrays for speed\nconst keyMap = {};\n// Takes a string of '.' separated keys and returns an array of keys\n// - 'feature.geometry.type' => ['feature', 'geometry', 'type']\n// - 'feature' => ['feature']\nfunction getKeys(compositeKey) {\n    if (typeof compositeKey === 'string') {\n        // else assume string and split around dots\n        let keyList = keyMap[compositeKey];\n        if (!keyList) {\n            keyList = compositeKey.split('.');\n            keyMap[compositeKey] = keyList;\n        }\n        return keyList;\n    }\n    // Wrap in array if needed\n    return Array.isArray(compositeKey) ? compositeKey : [compositeKey];\n}\n", "import { get } from \"../utils/get.js\";\n// expression-eval: Small jsep based expression parser that supports array and object indexing\nimport * as expressionEval from 'expression-eval';\nconst { parse, eval: evaluate } = expressionEval;\nconst cachedExpressionMap = {\n    '-': object => object\n};\n// Calculates an accessor function from a JSON string\n// '-' : x => x\n// 'a.b.c': x => x.a.b.c\nexport default function parseExpressionString(propValue, configuration) {\n    // NOTE: Can be null which represents invalid function. Return null so that prop can be omitted\n    if (propValue in cachedExpressionMap) {\n        return cachedExpressionMap[propValue];\n    }\n    let func;\n    // Compile with expression-eval\n    const ast = parse(propValue);\n    if (ast.type === 'Identifier') {\n        func = row => {\n            return get(row, propValue);\n        };\n    }\n    else {\n        // NOTE: To avoid security risks, the arguments passed to the\n        // compiled expression must only give access to pure data (no globals etc)\n        // We disable function call syntax\n        traverse(ast, node => {\n            if (node.type === 'CallExpression') {\n                throw new Error('Function calls not allowed in JSON expressions');\n            }\n        });\n        // TODO Something like `expressionEval.eval(ast, {row});` would be useful for unpacking arrays\n        func = row => {\n            return evaluate(ast, row);\n        };\n    }\n    // Cache the compiled function\n    cachedExpressionMap[propValue] = func;\n    return func;\n}\n// Helper function to search all nodes in AST returned by expressionEval\n// eslint-disable-next-line complexity\nfunction traverse(node, visitor) {\n    if (Array.isArray(node)) {\n        node.forEach(element => traverse(element, visitor));\n    }\n    else if (node && typeof node === 'object') {\n        if (node.type) {\n            visitor(node);\n        }\n        for (const key in node) {\n            traverse(node[key], visitor);\n        }\n    }\n}\n", "const FUNCTION_IDENTIFIER = '@@=';\nconst CONSTANT_IDENTIFIER = '@@#';\nconst TYPE_KEY = '@@type';\nconst FUNCTION_KEY = '@@function';\nexport { FUNCTION_IDENTIFIER, CONSTANT_IDENTIFIER, TYPE_KEY, FUNCTION_KEY };\n", "// TODO - default parsing code should not be part of the configuration.\nimport parseExpressionString from \"./helpers/parse-expression-string.js\";\nimport assert from \"./utils/assert.js\";\nimport { TYPE_KEY, FUNCTION_KEY } from \"./syntactic-sugar.js\";\nconst isObject = value => value && typeof value === 'object';\nexport default class JSONConfiguration {\n    constructor(...configurations) {\n        this.typeKey = TYPE_KEY;\n        this.functionKey = FUNCTION_KEY;\n        this.log = console; // eslint-disable-line\n        this.classes = {};\n        this.reactComponents = {};\n        this.enumerations = {};\n        this.constants = {};\n        this.functions = {};\n        this.React = null;\n        // TODO - this needs to be simpler, function conversion should be built in\n        this.convertFunction = parseExpressionString;\n        this.preProcessClassProps = (Class, props) => props;\n        this.postProcessConvertedJson = json => json;\n        for (const configuration of configurations) {\n            this.merge(configuration);\n        }\n    }\n    merge(configuration) {\n        for (const key in configuration) {\n            switch (key) {\n                // DEPRECATED = For backwards compatibility, add views and layers to classes;\n                case 'layers':\n                case 'views':\n                    Object.assign(this.classes, configuration[key]);\n                    break;\n                default:\n                    // Store configuration as root fields (this.classes, ...)\n                    if (key in this) {\n                        const value = configuration[key];\n                        this[key] = isObject(this[key]) ? Object.assign(this[key], value) : value;\n                    }\n            }\n        }\n    }\n    validate(configuration) {\n        assert(!this.typeKey || typeof this.typeKey === 'string');\n        assert(isObject(this.classes));\n        return true;\n    }\n}\n", "import parseExpressionString from \"./parse-expression-string.js\";\nimport { FUNCTION_IDENTIFIER } from \"../syntactic-sugar.js\";\nfunction hasFunctionIdentifier(value) {\n    return typeof value === 'string' && value.startsWith(FUNCTION_IDENTIFIER);\n}\nfunction trimFunctionIdentifier(value) {\n    return value.replace(FUNCTION_IDENTIFIER, '');\n}\n// Try to determine if any props are function valued\n// and if so convert their string values to functions\nexport default function convertFunctions(props, configuration) {\n    // Use deck.gl prop types if available.\n    const replacedProps = {};\n    for (const propName in props) {\n        let propValue = props[propName];\n        // Parse string valued expressions\n        const isFunction = hasFunctionIdentifier(propValue);\n        if (isFunction) {\n            // Parse string as \"expression\", return equivalent JavaScript function\n            propValue = trimFunctionIdentifier(propValue);\n            propValue = parseExpressionString(propValue, configuration);\n        }\n        replacedProps[propName] = propValue;\n    }\n    return replacedProps;\n}\n", "import convertFunctions from \"./convert-functions.js\";\n// This attempts to instantiate a class, either as a class or as a React component\nexport function instantiateClass(type, props, configuration) {\n    // Find the class\n    const Class = configuration.classes[type];\n    const Component = configuration.reactComponents[type];\n    // Check that the class is in the configuration.\n    if (!Class && !Component) {\n        const { log } = configuration; // eslint-disable-line\n        if (log) {\n            const stringProps = JSON.stringify(props, null, 0).slice(0, 40);\n            log.warn(`JSON converter: No registered class of type ${type}(${stringProps}...)  `);\n        }\n        return null;\n    }\n    if (Class) {\n        return instantiateJavaScriptClass(Class, props, configuration);\n    }\n    return instantiateReactComponent(Component, props, configuration);\n}\nfunction instantiateJavaScriptClass(Class, props, configuration) {\n    if (configuration.preProcessClassProps) {\n        props = configuration.preProcessClassProps(Class, props, configuration);\n    }\n    props = convertFunctions(props, configuration);\n    return new Class(props);\n}\nfunction instantiateReactComponent(Component, props, configuration) {\n    const { React } = configuration;\n    const { children = [] } = props;\n    delete props.children;\n    if (configuration.preProcessClassProps) {\n        props = configuration.preProcessClassProps(Component, props, configuration);\n    }\n    props = convertFunctions(props, configuration);\n    return React.createElement(Component, props, children);\n}\n", "// This attempts to execute a function\nexport function executeFunction(targetFunction, props, configuration) {\n    // Find the function\n    const matchedFunction = configuration.functions[targetFunction];\n    // Check that the function is in the configuration.\n    if (!matchedFunction) {\n        const { log } = configuration; // eslint-disable-line\n        if (log) {\n            const stringProps = JSON.stringify(props, null, 0).slice(0, 40);\n            log.warn(`JSON converter: No registered function ${targetFunction}(${stringProps}...)  `);\n        }\n        return null;\n    }\n    return matchedFunction(props);\n}\n", "// Accept JSON strings by parsing them\n// TODO - use a parser that provides meaninful error messages\nexport default function parseJSON(json) {\n    return typeof json === 'string' ? JSON.parse(json) : json;\n}\n", "// Converts JSON to props (\"hydrating\" classes, resolving enums and functions etc).\n// Lightly processes `json` props, transform string values, and extract `views` and `layers`\n// See: https://github.com/visgl/deck.gl/blob/master/dev-docs/RFCs/v6.1/json-layers-rfc.md\n//\n// NOTES:\n// * This is intended to provide minimal necessary processing required to support\n//   existing deck.gl props via JSON. This is not an implementation of alternate JSON schemas.\n// * Optionally, error checking could be applied, but ideally should leverage\n//   non-JSON specific mechanisms like prop types.\nimport assert from \"./utils/assert.js\";\nimport JSONConfiguration from \"./json-configuration.js\";\nimport { instantiateClass } from \"./helpers/instantiate-class.js\";\nimport { executeFunction } from \"./helpers/execute-function.js\";\nimport { FUNCTION_IDENTIFIER, CONSTANT_IDENTIFIER, FUNCTION_KEY } from \"./syntactic-sugar.js\";\nimport parseJSON from \"./helpers/parse-json.js\";\nconst isObject = value => value && typeof value === 'object';\nexport default class JSONConverter {\n    constructor(props) {\n        this.log = console; // eslint-disable-line\n        this.onJSONChange = () => { };\n        this.json = null;\n        this.convertedJson = null;\n        this.setProps(props);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    finalize() { }\n    setProps(props) {\n        // HANDLE CONFIGURATION PROPS\n        if ('configuration' in props) {\n            // Accept object or `JSONConfiguration`\n            this.configuration =\n                props.configuration instanceof JSONConfiguration\n                    ? props.configuration\n                    : new JSONConfiguration(props.configuration);\n        }\n        if ('onJSONChange' in props) {\n            this.onJSONChange = props.onJSONChange;\n        }\n    }\n    mergeConfiguration(config) {\n        this.configuration.merge(config);\n    }\n    convert(json) {\n        // Use shallow equality to ensure we only convert same json once\n        if (!json || json === this.json) {\n            return this.convertedJson;\n        }\n        // Save json for shallow diffing\n        this.json = json;\n        // Accept JSON strings by parsing them\n        const parsedJSON = parseJSON(json);\n        // Convert the JSON\n        let convertedJson = convertJSON(parsedJSON, this.configuration);\n        convertedJson = this.configuration.postProcessConvertedJson(convertedJson);\n        this.convertedJson = convertedJson;\n        return convertedJson;\n    }\n    // DEPRECATED: Backwards compatibility\n    convertJson(json) {\n        return this.convert(json);\n    }\n}\nfunction convertJSON(json, configuration) {\n    // Fixup configuration\n    configuration = new JSONConfiguration(configuration);\n    return convertJSONRecursively(json, '', configuration);\n}\n// Converts JSON to props (\"hydrating\" classes, resolving enums and functions etc).\nfunction convertJSONRecursively(json, key, configuration) {\n    if (Array.isArray(json)) {\n        return json.map((element, i) => convertJSONRecursively(element, String(i), configuration));\n    }\n    // If object.type is in configuration, instantiate\n    if (isClassInstance(json, configuration)) {\n        return convertClassInstance(json, configuration);\n    }\n    if (isObject(json)) {\n        // If object.function is in configuration, convert object to function\n        if (FUNCTION_KEY in json) {\n            return convertFunctionObject(json, configuration);\n        }\n        return convertPlainObject(json, configuration);\n    }\n    // Single value\n    if (typeof json === 'string') {\n        return convertString(json, key, configuration);\n    }\n    // Return unchanged (number, boolean, ...)\n    return json;\n}\n// Returns true if an object has a `type` field\nfunction isClassInstance(json, configuration) {\n    const { typeKey } = configuration;\n    const isClass = isObject(json) && Boolean(json[typeKey]);\n    return isClass;\n}\nfunction convertClassInstance(json, configuration) {\n    // Extract the class type field\n    const { typeKey } = configuration;\n    const type = json[typeKey];\n    // Prepare a props object and ensure all values have been converted\n    let props = { ...json };\n    delete props[typeKey];\n    props = convertPlainObject(props, configuration);\n    return instantiateClass(type, props, configuration);\n}\n// Plain JS object, embed functions.\nfunction convertFunctionObject(json, configuration) {\n    // Extract the target function field\n    const { functionKey } = configuration;\n    const targetFunction = json[functionKey];\n    // Prepare a props object and ensure all values have been converted\n    let props = { ...json };\n    delete props[functionKey];\n    props = convertPlainObject(props, configuration);\n    return executeFunction(targetFunction, props, configuration);\n}\n// Plain JS object, convert each key and return.\nfunction convertPlainObject(json, configuration) {\n    assert(isObject(json));\n    const result = {};\n    for (const key in json) {\n        const value = json[key];\n        result[key] = convertJSONRecursively(value, key, configuration);\n    }\n    return result;\n}\n// Convert one string value in an object\n// TODO - We could also support string syntax for hydrating other types, like regexps...\n// But no current use case\nfunction convertString(string, key, configuration) {\n    // Here the JSON value is supposed to be treated as a function\n    if (string.startsWith(FUNCTION_IDENTIFIER) && configuration.convertFunction) {\n        string = string.replace(FUNCTION_IDENTIFIER, '');\n        return configuration.convertFunction(string, configuration);\n    }\n    if (string.startsWith(CONSTANT_IDENTIFIER)) {\n        string = string.replace(CONSTANT_IDENTIFIER, '');\n        if (configuration.constants[string]) {\n            return configuration.constants[string];\n        }\n        // enum\n        const [enumVarName, enumValName] = string.split('.');\n        return configuration.enumerations[enumVarName][enumValName];\n    }\n    return string;\n}\n", "/* global document */\nconst state = {\n    onInitialize: _ => _,\n    onFinalize: _ => _,\n    onMessage: _ => _\n};\nexport default class Transport {\n    static setCallbacks({ onInitialize, onFinalize, onMessage }) {\n        if (onInitialize) {\n            state.onInitialize = onInitialize;\n        }\n        if (onFinalize) {\n            state.onFinalize = onFinalize;\n        }\n        if (onMessage) {\n            state.onMessage = onMessage;\n        }\n        // this._flushQueuedConnections();\n    }\n    constructor(name = 'Transport') {\n        this._messageQueue = [];\n        this.userData = {};\n        this._destroyed = false;\n        this.name = name;\n    }\n    /**\n     * Return a root DOM element for this transport connection\n     * @return {HTMLElement} default implementation returns document.body\n     * Jupyter Notebook transports will return an element associated with the notebook cell\n     */\n    getRootDOMElement() {\n        return typeof document !== 'undefined' ? document.body : null;\n    }\n    /**\n     * Back-channel messaging\n     */\n    sendJSONMessage() {\n        // eslint-disable-next-line\n        console.error('Back-channel not implemented for this transport');\n    }\n    /**\n     * Back-channel messaging\n     */\n    sendBinaryMessage() {\n        // eslint-disable-next-line\n        console.error('Back-channel not implemented for this transport');\n    }\n    //\n    // API for transports (not intended for apps)\n    //\n    _initialize(options = {}) {\n        const message = { transport: this, ...options };\n        state.onInitialize(message);\n        // console.debug('Resolving init promise', options); // eslint-disable-line\n        // this._initResolvers.resolve(message);\n    }\n    _finalize(options = {}) {\n        const message = { transport: this, ...options };\n        // TODO - could potentially be called without Initialize being called\n        state.onFinalize(message);\n        this._destroyed = true;\n    }\n    _messageReceived(message = {}) {\n        message = { transport: this, ...message };\n        // TODO - this function could potentially be called before callback registered/ Initialize called\n        // if (!state.onMessage) {\n        //   console.error('Queueing transport message', message); // eslint-disable-line\n        //   this._messageQueue.push(message);\n        //   return;\n        // }\n        console.debug('Delivering transport message', message); // eslint-disable-line\n        state.onMessage(message);\n    }\n    /*\n    // This tries to handle the case that a transport connection initializes before the application\n    // has set the callbacks.\n    // Note: It is not clear that this can actually happen in the in initial Jupyter widget transport\n    _flushQueuedConnections() {\n      if (onInitialize) {\n        state._initPromise.then(initArgs => {\n          onInitialize(initArgs);\n  \n          if (state._onMessage) {\n            // Send any queued messages\n            let message;\n            while ((message = this._messageQueue.pop())) {\n              console.debug('Delivering queued transport message', message); // eslint-disable-line\n              this._onMessage(message);\n            }\n          }\n        });\n      }\n    }\n    */\n    static _stringifyJSONSafe(v) {\n        const cache = new Set();\n        return JSON.stringify(v, (key, value) => {\n            if (typeof value === 'object' && value !== null) {\n                if (cache.has(value)) {\n                    // Circular reference found\n                    try {\n                        // If this value does not reference a parent it can be deduped\n                        return JSON.parse(JSON.stringify(value));\n                    }\n                    catch (err) {\n                        // discard key if value cannot be deduped\n                        return undefined;\n                    }\n                }\n                // Store value in our set\n                cache.add(value);\n            }\n            return value;\n        });\n    }\n}\n", "// TODO - can we reuse the core util? Assuming we don't want to export it\n/* eslint-disable complexity */\n// Compares two objects to see if their keys are shallowly equal\nexport function shallowEqualObjects(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {\n        return false;\n    }\n    if (Object.keys(a).length !== Object.keys(b).length) {\n        return false;\n    }\n    for (const key in a) {\n        if (!(key in b) || a[key] !== b[key]) {\n            return false;\n        }\n    }\n    for (const key in b) {\n        if (!(key in a)) {\n            return false;\n        }\n    }\n    return true;\n}\n"],
  "mappings": "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",
  "names": ["isObject", "isObject"]
}
