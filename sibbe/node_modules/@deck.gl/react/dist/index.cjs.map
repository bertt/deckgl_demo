{
  "version": 3,
  "sources": ["index.js", "deckgl.js", "utils/use-isomorphic-layout-effect.js", "utils/extract-jsx-layers.js", "utils/inherits-from.js", "utils/evaluate-children.js", "utils/position-children-under-views.js", "utils/extract-styles.js"],
  "sourcesContent": ["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport { default as DeckGL } from \"./deckgl.js\";\nexport { default } from \"./deckgl.js\";\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport * as React from 'react';\nimport { createElement, useRef, useState, useMemo, useEffect, useImperativeHandle } from 'react';\nimport { Deck } from '@deck.gl/core';\nimport useIsomorphicLayoutEffect from \"./utils/use-isomorphic-layout-effect.js\";\nimport extractJSXLayers from \"./utils/extract-jsx-layers.js\";\nimport positionChildrenUnderViews from \"./utils/position-children-under-views.js\";\nimport extractStyles from \"./utils/extract-styles.js\";\nfunction getRefHandles(thisRef) {\n    return {\n        get deck() {\n            return thisRef.deck;\n        },\n        // The following method can only be called after ref is available, by which point deck is defined in useEffect\n        pickObject: opts => thisRef.deck.pickObject(opts),\n        pickMultipleObjects: opts => thisRef.deck.pickMultipleObjects(opts),\n        pickObjects: opts => thisRef.deck.pickObjects(opts)\n    };\n}\nfunction redrawDeck(thisRef) {\n    if (thisRef.redrawReason) {\n        // Only redraw if we have received a dirty flag\n        // @ts-expect-error accessing protected method\n        thisRef.deck._drawLayers(thisRef.redrawReason);\n        thisRef.redrawReason = null;\n    }\n}\nfunction createDeckInstance(thisRef, DeckClass, props) {\n    const deck = new DeckClass({\n        ...props,\n        // The Deck's animation loop is independent from React's render cycle, causing potential\n        // synchronization issues. We provide this custom render function to make sure that React\n        // and Deck update on the same schedule.\n        _customRender: redrawReason => {\n            // Save the dirty flag for later\n            thisRef.redrawReason = redrawReason;\n            // Viewport/view state is passed to child components as props.\n            // If they have changed, we need to trigger a React rerender to update children props.\n            const viewports = deck.getViewports();\n            if (thisRef.lastRenderedViewports !== viewports) {\n                // Viewports have changed, update children props first.\n                // This will delay the Deck canvas redraw till after React update (in useLayoutEffect)\n                // so that the canvas does not get rendered before the child components update.\n                thisRef.forceUpdate();\n            }\n            else {\n                redrawDeck(thisRef);\n            }\n        }\n    });\n    return deck;\n}\nfunction DeckGLWithRef(props, ref) {\n    // A mechanism to force redraw\n    const [version, setVersion] = useState(0);\n    // A reference to persistent states\n    const _thisRef = useRef({\n        control: null,\n        version,\n        forceUpdate: () => setVersion(v => v + 1)\n    });\n    const thisRef = _thisRef.current;\n    // DOM refs\n    const containerRef = useRef(null);\n    const canvasRef = useRef(null);\n    // extract any deck.gl layers masquerading as react elements from props.children\n    const jsxProps = useMemo(() => extractJSXLayers(props), [props.layers, props.views, props.children]);\n    // Callbacks\n    let inRender = true;\n    const handleViewStateChange = params => {\n        if (inRender && props.viewState) {\n            // Callback may invoke a state update. Defer callback to after render() to avoid React error\n            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n            // Store deferred parameters in ref so that we can access it in another render\n            thisRef.viewStateUpdateRequested = params;\n            return null;\n        }\n        thisRef.viewStateUpdateRequested = null;\n        return props.onViewStateChange?.(params);\n    };\n    const handleInteractionStateChange = params => {\n        if (inRender) {\n            // Callback may invoke a state update. Defer callback to after render() to avoid React error\n            // In React StrictMode, render is executed twice and useEffect/useLayoutEffect is executed once\n            // Store deferred parameters in ref so that we can access it in another render\n            thisRef.interactionStateUpdateRequested = params;\n        }\n        else {\n            thisRef.interactionStateUpdateRequested = null;\n            props.onInteractionStateChange?.(params);\n        }\n    };\n    // Update Deck's props. If Deck needs redraw, this will trigger a call to `_customRender` in\n    // the next animation frame.\n    // Needs to be called both from initial mount, and when new props are received\n    const deckProps = useMemo(() => {\n        const forwardProps = {\n            ...props,\n            // Override user styling props. We will set the canvas style in render()\n            style: null,\n            width: '100%',\n            height: '100%',\n            parent: containerRef.current,\n            canvas: canvasRef.current,\n            layers: jsxProps.layers,\n            views: jsxProps.views,\n            onViewStateChange: handleViewStateChange,\n            onInteractionStateChange: handleInteractionStateChange\n        };\n        // The defaultValue for _customRender is null, which would overwrite the definition\n        // of _customRender. Remove to avoid frequently redeclaring the method here.\n        delete forwardProps._customRender;\n        if (thisRef.deck) {\n            thisRef.deck.setProps(forwardProps);\n        }\n        return forwardProps;\n    }, [props]);\n    useEffect(() => {\n        const DeckClass = props.Deck || Deck;\n        thisRef.deck = createDeckInstance(thisRef, DeckClass, {\n            ...deckProps,\n            parent: containerRef.current,\n            canvas: canvasRef.current\n        });\n        return () => thisRef.deck?.finalize();\n    }, []);\n    useIsomorphicLayoutEffect(() => {\n        // render has just been called. The children are positioned based on the current view state.\n        // Redraw Deck canvas immediately, if necessary, using the current view state, so that it\n        // matches the child components.\n        redrawDeck(thisRef);\n        // Execute deferred callbacks\n        const { viewStateUpdateRequested, interactionStateUpdateRequested } = thisRef;\n        if (viewStateUpdateRequested) {\n            handleViewStateChange(viewStateUpdateRequested);\n        }\n        if (interactionStateUpdateRequested) {\n            handleInteractionStateChange(interactionStateUpdateRequested);\n        }\n    });\n    useImperativeHandle(ref, () => getRefHandles(thisRef), []);\n    const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : undefined;\n    const { ContextProvider, width = '100%', height = '100%', id, style } = props;\n    const { containerStyle, canvasStyle } = useMemo(() => extractStyles({ width, height, style }), [width, height, style]);\n    // Props changes may lead to 3 types of updates:\n    // 1. Only the WebGL canvas - updated in Deck's render cycle (next animation frame)\n    // 2. Only the DOM - updated in React's lifecycle (now)\n    // 3. Both the WebGL canvas and the DOM - defer React rerender to next animation frame just\n    //    before Deck redraw to ensure perfect synchronization & avoid excessive redraw\n    //    This is because multiple changes may happen to Deck between two frames e.g. transition\n    if ((!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports) || // case 2\n        thisRef.version !== version // case 3 just before deck redraws\n    ) {\n        thisRef.lastRenderedViewports = currentViewports;\n        thisRef.version = version;\n        // Render the background elements (typically react-map-gl instances)\n        // using the view descriptors\n        const childrenUnderViews = positionChildrenUnderViews({\n            children: jsxProps.children,\n            deck: thisRef.deck,\n            ContextProvider\n        });\n        const canvas = createElement('canvas', {\n            key: 'canvas',\n            id: id || 'deckgl-overlay',\n            ref: canvasRef,\n            style: canvasStyle\n        });\n        // Render deck.gl as the last child\n        thisRef.control = createElement('div', { id: `${id || 'deckgl'}-wrapper`, ref: containerRef, style: containerStyle }, [canvas, childrenUnderViews]);\n    }\n    inRender = false;\n    return thisRef.control;\n}\nconst DeckGL = React.forwardRef(DeckGLWithRef);\nexport default DeckGL;\n", "// From https://github.com/streamich/react-use/blob/master/src/useIsomorphicLayoutEffect.ts\n// useLayoutEffect but does not trigger warning in server-side rendering\nimport { useEffect, useLayoutEffect } from 'react';\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nexport default useIsomorphicLayoutEffect;\n", "import * as React from 'react';\nimport { createElement } from 'react';\nimport { inheritsFrom } from \"./inherits-from.js\";\nimport { Layer, View } from '@deck.gl/core';\nimport { isComponent } from \"./evaluate-children.js\";\n// recursively wrap render callbacks in `View`\nfunction wrapInView(node) {\n    if (typeof node === 'function') {\n        // React.Children does not traverse functions.\n        // All render callbacks must be protected under a <View>\n        // @ts-expect-error View is not a ReactJSXElement constructor. Only used as a temporary wrapper and will be removed in extractJSXLayers\n        return createElement(View, {}, node);\n    }\n    if (Array.isArray(node)) {\n        return node.map(wrapInView);\n    }\n    if (isComponent(node)) {\n        if (node.type === React.Fragment) {\n            return wrapInView(node.props.children);\n        }\n        if (inheritsFrom(node.type, View)) {\n            return node;\n        }\n    }\n    return node;\n}\n// extracts any deck.gl layers masquerading as react elements from props.children\nexport default function extractJSXLayers({ children, layers = [], views = null }) {\n    const reactChildren = []; // extract real react elements (i.e. not deck.gl layers)\n    const jsxLayers = []; // extracted layer from react children, will add to deck.gl layer array\n    const jsxViews = {};\n    // React.children\n    React.Children.forEach(wrapInView(children), reactElement => {\n        if (isComponent(reactElement)) {\n            // For some reason Children.forEach doesn't filter out `null`s\n            const ElementType = reactElement.type;\n            if (inheritsFrom(ElementType, Layer)) {\n                const layer = createLayer(ElementType, reactElement.props);\n                jsxLayers.push(layer);\n            }\n            else {\n                reactChildren.push(reactElement);\n            }\n            // empty id => default view\n            if (inheritsFrom(ElementType, View) && ElementType !== View && reactElement.props.id) {\n                // @ts-ignore Cannot instantiate an abstract class (View)\n                const view = new ElementType(reactElement.props);\n                jsxViews[view.id] = view;\n            }\n        }\n        else if (reactElement) {\n            reactChildren.push(reactElement);\n        }\n    });\n    // Avoid modifying views if no JSX views were found\n    if (Object.keys(jsxViews).length > 0) {\n        // If a view is specified in both views prop and JSX, use the one in views\n        if (Array.isArray(views)) {\n            views.forEach(view => {\n                jsxViews[view.id] = view;\n            });\n        }\n        else if (views) {\n            jsxViews[views.id] = views;\n        }\n        views = Object.values(jsxViews);\n    }\n    // Avoid modifying layers array if no JSX layers were found\n    layers = jsxLayers.length > 0 ? [...jsxLayers, ...layers] : layers;\n    return { layers, children: reactChildren, views };\n}\nfunction createLayer(LayerType, reactProps) {\n    const props = {};\n    // Layer.defaultProps is treated as ReactElement.defaultProps and merged into react props\n    // Remove them\n    const defaultProps = LayerType.defaultProps || {};\n    for (const key in reactProps) {\n        if (defaultProps[key] !== reactProps[key]) {\n            props[key] = reactProps[key];\n        }\n    }\n    // @ts-ignore Cannot instantiate an abstract class (Layer)\n    return new LayerType(props);\n}\n", "// Check if one JavaScript class inherits from another\nexport function inheritsFrom(Type, ParentType) {\n    while (Type) {\n        if (Type === ParentType) {\n            return true;\n        }\n        Type = Object.getPrototypeOf(Type);\n    }\n    return false;\n}\n", "import { cloneElement } from 'react';\nconst MAP_STYLE = { position: 'absolute', zIndex: -1 };\nexport default function evaluateChildren(children, childProps) {\n    if (typeof children === 'function') {\n        return children(childProps);\n    }\n    if (Array.isArray(children)) {\n        return children.map(child => evaluateChildren(child, childProps));\n    }\n    if (isComponent(children)) {\n        // Special treatment for react-map-gl's Map component\n        // to support shorthand use case <DeckGL><StaticMap /></DeckGL>\n        if (isReactMap(children)) {\n            // Place map under the canvas\n            childProps.style = MAP_STYLE;\n            return cloneElement(children, childProps);\n        }\n        if (needsDeckGLViewProps(children)) {\n            return cloneElement(children, childProps);\n        }\n    }\n    return children;\n}\nexport function isComponent(child) {\n    return (child && typeof child === 'object' && 'type' in child) || false;\n}\nfunction isReactMap(child) {\n    return child.props?.mapStyle;\n}\nfunction needsDeckGLViewProps(child) {\n    const componentClass = child.type;\n    // @ts-expect-error deckGLViewProps is a custom hack defined on the constructor (nebula.gl)\n    return componentClass && componentClass.deckGLViewProps;\n}\n", "import { createElement } from 'react';\nimport { View } from '@deck.gl/core';\nimport { inheritsFrom } from \"./inherits-from.js\";\nimport evaluateChildren, { isComponent } from \"./evaluate-children.js\";\n// Iterate over views and reposition children associated with views\n// TODO - Can we supply a similar function for the non-React case?\nexport default function positionChildrenUnderViews({ children, deck, ContextProvider }) {\n    // @ts-expect-error accessing protected property\n    const { viewManager } = deck || {};\n    if (!viewManager || !viewManager.views.length) {\n        return [];\n    }\n    const views = {};\n    const defaultViewId = viewManager.views[0].id;\n    // Sort children by view id\n    for (const child of children) {\n        // Unless child is a View, position / render as part of the default view\n        let viewId = defaultViewId;\n        let viewChildren = child;\n        if (isComponent(child) && inheritsFrom(child.type, View)) {\n            viewId = child.props.id || defaultViewId;\n            viewChildren = child.props.children;\n        }\n        const viewport = viewManager.getViewport(viewId);\n        const viewState = viewManager.getViewState(viewId);\n        // Drop (auto-hide) elements with viewId that are not matched by any current view\n        if (viewport) {\n            viewState.padding = viewport.padding;\n            const { x, y, width, height } = viewport;\n            // Resolve potentially relative dimensions using the deck.gl container size\n            viewChildren = evaluateChildren(viewChildren, {\n                x,\n                y,\n                width,\n                height,\n                viewport,\n                viewState\n            });\n            if (!views[viewId]) {\n                views[viewId] = {\n                    viewport,\n                    children: []\n                };\n            }\n            views[viewId].children.push(viewChildren);\n        }\n    }\n    // Render views\n    return Object.keys(views).map(viewId => {\n        const { viewport, children: viewChildren } = views[viewId];\n        const { x, y, width, height } = viewport;\n        const style = {\n            position: 'absolute',\n            left: x,\n            top: y,\n            width,\n            height\n        };\n        const key = `view-${viewId}`;\n        // If children is passed as an array, React will throw the \"each element in a list needs\n        // a key\" warning. Sending each child as separate arguments removes this requirement.\n        const viewElement = createElement('div', { key, id: key, style }, ...viewChildren);\n        if (ContextProvider) {\n            const contextValue = {\n                viewport,\n                // @ts-expect-error accessing protected property\n                container: deck.canvas.offsetParent,\n                // @ts-expect-error accessing protected property\n                eventManager: deck.eventManager,\n                onViewStateChange: params => {\n                    params.viewId = viewId;\n                    // @ts-expect-error accessing protected method\n                    deck._onViewStateChange(params);\n                }\n            };\n            return createElement(ContextProvider, { key, value: contextValue }, viewElement);\n        }\n        return viewElement;\n    });\n}\n", "const CANVAS_ONLY_STYLES = {\n    mixBlendMode: null\n};\nexport default function extractStyles({ width, height, style }) {\n    // This styling is enforced for correct positioning with children\n    const containerStyle = {\n        position: 'absolute',\n        zIndex: 0,\n        left: 0,\n        top: 0,\n        width,\n        height\n    };\n    // Fill the container\n    const canvasStyle = {\n        left: 0,\n        top: 0\n    };\n    if (style) {\n        for (const key in style) {\n            if (key in CANVAS_ONLY_STYLES) {\n                // apply style to the canvas, but not deck's children, e.g. mix-blend-mode\n                canvasStyle[key] = style[key];\n            }\n            else {\n                // apply style to the container, e.g. position/flow settings\n                containerStyle[key] = style[key];\n            }\n        }\n    }\n    return { containerStyle, canvasStyle };\n}\n"],
  "mappings": "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",
  "names": ["React", "import_react", "import_core", "import_react", "import_react", "import_react", "import_core"]
}
