{
  "version": 3,
  "sources": ["index.js", "constants.js", "lib/bounding-volumes/axis-aligned-bounding-box.js", "lib/bounding-volumes/bounding-sphere.js", "lib/bounding-volumes/oriented-bounding-box.js", "lib/culling-volume.js", "lib/plane.js", "lib/perspective-off-center-frustum.js", "lib/perspective-frustum.js", "lib/algorithms/bounding-sphere-from-points.js", "lib/algorithms/bounding-box-from-points.js", "lib/algorithms/compute-eigen-decomposition.js"],
  "sourcesContent": ["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nexport { INTERSECTION } from \"./constants.js\";\nexport { AxisAlignedBoundingBox } from \"./lib/bounding-volumes/axis-aligned-bounding-box.js\";\nexport { BoundingSphere } from \"./lib/bounding-volumes/bounding-sphere.js\";\nexport { OrientedBoundingBox } from \"./lib/bounding-volumes/oriented-bounding-box.js\";\nexport { CullingVolume } from \"./lib/culling-volume.js\";\nexport { Plane } from \"./lib/plane.js\";\nexport { PerspectiveOffCenterFrustum as _PerspectiveOffCenterFrustum } from \"./lib/perspective-off-center-frustum.js\";\nexport { PerspectiveFrustum as _PerspectiveFrustum } from \"./lib/perspective-frustum.js\";\nexport { makeBoundingSphereFromPoints } from \"./lib/algorithms/bounding-sphere-from-points.js\";\nexport { makeAxisAlignedBoundingBoxFromPoints, makeOrientedBoundingBoxFromPoints } from \"./lib/algorithms/bounding-box-from-points.js\";\nexport { computeEigenDecomposition } from \"./lib/algorithms/compute-eigen-decomposition.js\";\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nexport const INTERSECTION = {\n    OUTSIDE: -1, // Represents that an object is not contained within the frustum.\n    INTERSECTING: 0, // Represents that an object intersects one of the frustum's planes.\n    INSIDE: 1 // Represents that an object is fully within the frustum.\n};\n", "import { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport class AxisAlignedBoundingBox {\n    /**\n     * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n     * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n     * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n     * @param center The center of the box; automatically computed if not supplied.\n     */\n    constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center) {\n        // If center was not defined, compute it.\n        center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n        this.center = new Vector3(center);\n        this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n        /**\n         * The minimum point defining the bounding box.\n         * @type {Vector3}\n         * @default {@link 0, 0, 0}\n         */\n        this.minimum = new Vector3(minimum);\n        /**\n         * The maximum point defining the bounding box.\n         * @type {Vector3}\n         * @default {@link 0, 0, 0}\n         */\n        this.maximum = new Vector3(maximum);\n    }\n    /**\n     * Duplicates a AxisAlignedBoundingBox instance.\n     *\n     * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n     */\n    clone() {\n        return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n    /**\n     * Compares the provided AxisAlignedBoundingBox componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    equals(right) {\n        return (this === right ||\n            (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum)));\n    }\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\n     * @param transform The transformation matrix to apply to the bounding sphere.\n     * @returns itself, i.e. the modified BoundingVolume.\n     */\n    transform(transform) {\n        this.center.transformAsPoint(transform);\n        // TODO - this.halfDiagonal.transformAsVector(transform);\n        this.halfDiagonal.transform(transform);\n        this.minimum.transform(transform);\n        this.maximum.transform(transform);\n        return this;\n    }\n    /**\n     * Determines which side of a plane a box is located.\n     */\n    intersectPlane(plane) {\n        const { halfDiagonal } = this;\n        const normal = scratchNormal.from(plane.normal);\n        const e = halfDiagonal.x * Math.abs(normal.x) +\n            halfDiagonal.y * Math.abs(normal.y) +\n            halfDiagonal.z * Math.abs(normal.z);\n        const s = this.center.dot(normal) + plane.distance; // signed distance from center\n        if (s - e > 0) {\n            return INTERSECTION.INSIDE;\n        }\n        if (s + e < 0) {\n            // Not in front because normals point inward\n            return INTERSECTION.OUTSIDE;\n        }\n        return INTERSECTION.INTERSECTING;\n    }\n    /** Computes the estimated distance from the closest point on a bounding box to a point. */\n    distanceTo(point) {\n        return Math.sqrt(this.distanceSquaredTo(point));\n    }\n    /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n    distanceSquaredTo(point) {\n        const offset = scratchVector.from(point).subtract(this.center);\n        const { halfDiagonal } = this;\n        let distanceSquared = 0.0;\n        let d;\n        d = Math.abs(offset.x) - halfDiagonal.x;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        d = Math.abs(offset.y) - halfDiagonal.y;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        d = Math.abs(offset.z) - halfDiagonal.z;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        return distanceSquared;\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, mat4 } from '@math.gl/core';\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n/** A BoundingSphere */\nexport class BoundingSphere {\n    /** Creates a bounding sphere */\n    constructor(center = [0, 0, 0], radius = 0.0) {\n        this.radius = -0;\n        this.center = new Vector3();\n        this.fromCenterRadius(center, radius);\n    }\n    /** Sets the bounding sphere from `center` and `radius`. */\n    fromCenterRadius(center, radius) {\n        this.center.from(center);\n        this.radius = radius;\n        return this;\n    }\n    /**\n     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n     * tightly and fully encompasses the box.\n     */\n    fromCornerPoints(corner, oppositeCorner) {\n        oppositeCorner = scratchVector.from(oppositeCorner);\n        this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n        this.radius = this.center.distance(oppositeCorner);\n        return this;\n    }\n    /** Compares the provided BoundingSphere component wise */\n    equals(right) {\n        return (this === right ||\n            (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius));\n    }\n    /** Duplicates a BoundingSphere instance. */\n    clone() {\n        return new BoundingSphere(this.center, this.radius);\n    }\n    /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n    union(boundingSphere) {\n        const leftCenter = this.center;\n        const leftRadius = this.radius;\n        const rightCenter = boundingSphere.center;\n        const rightRadius = boundingSphere.radius;\n        const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n        const centerSeparation = toRightCenter.magnitude();\n        if (leftRadius >= centerSeparation + rightRadius) {\n            // Left sphere wins.\n            return this.clone();\n        }\n        if (rightRadius >= centerSeparation + leftRadius) {\n            // Right sphere wins.\n            return boundingSphere.clone();\n        }\n        // There are two tangent points, one on far side of each sphere.\n        const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n        // Compute the center point halfway between the two tangent points.\n        scratchVector2\n            .copy(toRightCenter)\n            .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n            .add(leftCenter);\n        this.center.copy(scratchVector2);\n        this.radius = halfDistanceBetweenTangentPoints;\n        return this;\n    }\n    /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n    expand(point) {\n        const scratchPoint = scratchVector.from(point);\n        const radius = scratchPoint.subtract(this.center).magnitude();\n        if (radius > this.radius) {\n            this.radius = radius;\n        }\n        return this;\n    }\n    // BoundingVolume interface\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\n     * @param sphere The bounding sphere to apply the transformation to.\n     * @param transform The transformation matrix to apply to the bounding sphere.\n     * @returns self.\n     */\n    transform(transform) {\n        this.center.transform(transform);\n        const scale = mat4.getScaling(scratchVector, transform);\n        this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n        return this;\n    }\n    /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n    distanceSquaredTo(point) {\n        const d = this.distanceTo(point);\n        return d * d;\n    }\n    /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n    distanceTo(point) {\n        const scratchPoint = scratchVector.from(point);\n        const delta = scratchPoint.subtract(this.center);\n        return Math.max(0, delta.len() - this.radius);\n    }\n    /** Determines which side of a plane a sphere is located. */\n    intersectPlane(plane) {\n        const center = this.center;\n        const radius = this.radius;\n        const normal = plane.normal;\n        const distanceToPlane = normal.dot(center) + plane.distance;\n        // The center point is negative side of the plane normal\n        if (distanceToPlane < -radius) {\n            return INTERSECTION.OUTSIDE;\n        }\n        // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n        if (distanceToPlane < radius) {\n            return INTERSECTION.INTERSECTING;\n        }\n        // The center point and radius is positive side of the plane\n        return INTERSECTION.INSIDE;\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport { BoundingSphere } from \"./bounding-sphere.js\";\nimport { INTERSECTION } from \"../../constants.js\";\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\nconst MATRIX3 = {\n    COLUMN0ROW0: 0,\n    COLUMN0ROW1: 1,\n    COLUMN0ROW2: 2,\n    COLUMN1ROW0: 3,\n    COLUMN1ROW1: 4,\n    COLUMN1ROW2: 5,\n    COLUMN2ROW0: 6,\n    COLUMN2ROW1: 7,\n    COLUMN2ROW2: 8\n};\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport class OrientedBoundingBox {\n    constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n        this.center = new Vector3().from(center);\n        this.halfAxes = new Matrix3(halfAxes);\n    }\n    /** Returns an array with three halfSizes for the bounding box */\n    get halfSize() {\n        const xAxis = this.halfAxes.getColumn(0);\n        const yAxis = this.halfAxes.getColumn(1);\n        const zAxis = this.halfAxes.getColumn(2);\n        return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n    }\n    /** Returns a quaternion describing the orientation of the bounding box */\n    get quaternion() {\n        const xAxis = this.halfAxes.getColumn(0);\n        const yAxis = this.halfAxes.getColumn(1);\n        const zAxis = this.halfAxes.getColumn(2);\n        const normXAxis = new Vector3(xAxis).normalize();\n        const normYAxis = new Vector3(yAxis).normalize();\n        const normZAxis = new Vector3(zAxis).normalize();\n        return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n    }\n    /**\n     * Create OrientedBoundingBox from quaternion based OBB,\n     */\n    fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n        const quaternionObject = new Quaternion(quaternion);\n        const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n        directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n        directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n        directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n        directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n        directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n        directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n        directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n        directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n        directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n        this.center = new Vector3().from(center);\n        this.halfAxes = directionsMatrix;\n        return this;\n    }\n    /** Duplicates a OrientedBoundingBox instance. */\n    clone() {\n        return new OrientedBoundingBox(this.center, this.halfAxes);\n    }\n    /** Compares the provided OrientedBoundingBox component wise and returns */\n    equals(right) {\n        return (this === right ||\n            (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes)));\n    }\n    /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n    getBoundingSphere(result = new BoundingSphere()) {\n        const halfAxes = this.halfAxes;\n        const u = halfAxes.getColumn(0, scratchVectorU);\n        const v = halfAxes.getColumn(1, scratchVectorV);\n        const w = halfAxes.getColumn(2, scratchVectorW);\n        // Calculate \"corner\" vector\n        const cornerVector = scratchVector3.copy(u).add(v).add(w);\n        result.center.copy(this.center);\n        result.radius = cornerVector.magnitude();\n        return result;\n    }\n    /** Determines which side of a plane the oriented bounding box is located. */\n    intersectPlane(plane) {\n        const center = this.center;\n        const normal = plane.normal;\n        const halfAxes = this.halfAxes;\n        const normalX = normal.x;\n        const normalY = normal.y;\n        const normalZ = normal.z;\n        // Plane is used as if it is its normal; the first three components are assumed to be normalized\n        const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n            normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n            normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) +\n            Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n                normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n                normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) +\n            Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n                normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n                normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n        const distanceToPlane = normal.dot(center) + plane.distance;\n        if (distanceToPlane <= -radEffective) {\n            // The entire box is on the negative side of the plane normal\n            return INTERSECTION.OUTSIDE;\n        }\n        else if (distanceToPlane >= radEffective) {\n            // The entire box is on the positive side of the plane normal\n            return INTERSECTION.INSIDE;\n        }\n        return INTERSECTION.INTERSECTING;\n    }\n    /** Computes the estimated distance from the closest point on a bounding box to a point. */\n    distanceTo(point) {\n        return Math.sqrt(this.distanceSquaredTo(point));\n    }\n    /**\n     * Computes the estimated distance squared from the closest point\n     * on a bounding box to a point.\n     * See Geometric Tools for Computer Graphics 10.4.2\n     */\n    distanceSquaredTo(point) {\n        // Computes the estimated distance squared from the\n        // closest point on a bounding box to a point.\n        // See Geometric Tools for Computer Graphics 10.4.2\n        const offset = scratchOffset.from(point).subtract(this.center);\n        const halfAxes = this.halfAxes;\n        const u = halfAxes.getColumn(0, scratchVectorU);\n        const v = halfAxes.getColumn(1, scratchVectorV);\n        const w = halfAxes.getColumn(2, scratchVectorW);\n        const uHalf = u.magnitude();\n        const vHalf = v.magnitude();\n        const wHalf = w.magnitude();\n        u.normalize();\n        v.normalize();\n        w.normalize();\n        let distanceSquared = 0.0;\n        let d;\n        d = Math.abs(offset.dot(u)) - uHalf;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        d = Math.abs(offset.dot(v)) - vHalf;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        d = Math.abs(offset.dot(w)) - wHalf;\n        if (d > 0) {\n            distanceSquared += d * d;\n        }\n        return distanceSquared;\n    }\n    /**\n     * The distances calculated by the vector from the center of the bounding box\n     * to position projected onto direction.\n     *\n     * - If you imagine the infinite number of planes with normal direction,\n     *   this computes the smallest distance to the closest and farthest planes\n     *   from `position` that intersect the bounding box.\n     *\n     * @param position The position to calculate the distance from.\n     * @param direction The direction from position.\n     * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n     * @returns Interval (array of length 2) with nearest and farthest distances\n     *   on the bounding box from position in direction.\n     */\n    // eslint-disable-next-line max-statements\n    computePlaneDistances(position, direction, result = [-0, -0]) {\n        let minDist = Number.POSITIVE_INFINITY;\n        let maxDist = Number.NEGATIVE_INFINITY;\n        const center = this.center;\n        const halfAxes = this.halfAxes;\n        const u = halfAxes.getColumn(0, scratchVectorU);\n        const v = halfAxes.getColumn(1, scratchVectorV);\n        const w = halfAxes.getColumn(2, scratchVectorW);\n        // project first corner\n        const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n        const toCenter = scratchToCenter.copy(corner).subtract(position);\n        let mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project second corner\n        corner.copy(center).add(u).add(v).subtract(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project third corner\n        corner.copy(center).add(u).subtract(v).add(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project fourth corner\n        corner.copy(center).add(u).subtract(v).subtract(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project fifth corner\n        center.copy(corner).subtract(u).add(v).add(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project sixth corner\n        center.copy(corner).subtract(u).add(v).subtract(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project seventh corner\n        center.copy(corner).subtract(u).subtract(v).add(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        // project eighth corner\n        center.copy(corner).subtract(u).subtract(v).subtract(w);\n        toCenter.copy(corner).subtract(position);\n        mag = direction.dot(toCenter);\n        minDist = Math.min(mag, minDist);\n        maxDist = Math.max(mag, maxDist);\n        result[0] = minDist;\n        result[1] = maxDist;\n        return result;\n    }\n    /**\n     * Applies a 4x4 affine transformation matrix to a bounding sphere.\n     * @param transform The transformation matrix to apply to the bounding sphere.\n     * @returns itself, i.e. the modified BoundingVolume.\n     */\n    transform(transformation) {\n        this.center.transformAsPoint(transformation);\n        const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n        xAxis.transformAsPoint(transformation);\n        const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n        yAxis.transformAsPoint(transformation);\n        const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n        zAxis.transformAsPoint(transformation);\n        this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n        return this;\n    }\n    getTransform() {\n        // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n        // return modelMatrix;\n        throw new Error('not implemented');\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, assert } from '@math.gl/core';\nimport { INTERSECTION } from \"../constants.js\";\nimport { Plane } from \"./plane.js\";\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n// const scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n/** A culling volume defined by planes. */\nexport class CullingVolume {\n    /**\n     * Create a new `CullingVolume` bounded by an array of clipping planed\n     * @param planes Array of clipping planes.\n     * */\n    constructor(planes = []) {\n        this.planes = planes;\n    }\n    /**\n     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n     * The planes are aligned to the x, y, and z axes in world coordinates.\n     */\n    fromBoundingSphere(boundingSphere) {\n        this.planes.length = 2 * faces.length;\n        const center = boundingSphere.center;\n        const radius = boundingSphere.radius;\n        let planeIndex = 0;\n        for (const faceNormal of faces) {\n            let plane0 = this.planes[planeIndex];\n            let plane1 = this.planes[planeIndex + 1];\n            if (!plane0) {\n                plane0 = this.planes[planeIndex] = new Plane();\n            }\n            if (!plane1) {\n                plane1 = this.planes[planeIndex + 1] = new Plane();\n            }\n            const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n            // const plane0Distance = -faceNormal.dot(plane0Center);\n            plane0.fromPointNormal(plane0Center, faceNormal);\n            const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n            const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n            // const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n            plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n            planeIndex += 2;\n        }\n        return this;\n    }\n    /** Determines whether a bounding volume intersects the culling volume. */\n    computeVisibility(boundingVolume) {\n        // const planes = this.planes;\n        let intersect = INTERSECTION.INSIDE;\n        for (const plane of this.planes) {\n            const result = boundingVolume.intersectPlane(plane);\n            switch (result) {\n                case INTERSECTION.OUTSIDE:\n                    // We are done\n                    return INTERSECTION.OUTSIDE;\n                case INTERSECTION.INTERSECTING:\n                    // If no other intersection is outside, return INTERSECTING\n                    intersect = INTERSECTION.INTERSECTING;\n                    break;\n                default:\n            }\n        }\n        return intersect;\n    }\n    /**\n     * Determines whether a bounding volume intersects the culling volume.\n     *\n     * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n     *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n     *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n     *   and that plane check can be skipped.\n     */\n    computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n        assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n        if (parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n            parentPlaneMask === CullingVolume.MASK_INSIDE) {\n            // parent is completely outside or completely inside, so this child is as well.\n            return parentPlaneMask;\n        }\n        // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n        // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n        let mask = CullingVolume.MASK_INSIDE;\n        const planes = this.planes;\n        for (let k = 0; k < this.planes.length; ++k) {\n            // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n            const flag = k < 31 ? 1 << k : 0;\n            if (k < 31 && (parentPlaneMask & flag) === 0) {\n                // boundingVolume is known to be INSIDE this plane.\n                continue;\n            }\n            const plane = planes[k];\n            const result = boundingVolume.intersectPlane(plane);\n            if (result === INTERSECTION.OUTSIDE) {\n                return CullingVolume.MASK_OUTSIDE;\n            }\n            else if (result === INTERSECTION.INTERSECTING) {\n                mask |= flag;\n            }\n        }\n        return mask;\n    }\n}\n/**\n * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n * represents the case where the object bounding volume is entirely outside the culling volume.\n */\nCullingVolume.MASK_OUTSIDE = 0xffffffff;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume is entirely inside the culling volume.\n */\nCullingVolume.MASK_INSIDE = 0x00000000;\n/**\n * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n */\nCullingVolume.MASK_INDETERMINATE = 0x7fffffff;\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, equals, assert } from '@math.gl/core';\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n// A plane in Hessian Normal Form\nexport class Plane {\n    constructor(normal = [0, 0, 1], distance = 0) {\n        this.normal = new Vector3();\n        this.distance = -0;\n        this.fromNormalDistance(normal, distance);\n    }\n    /** Creates a plane from a normal and a distance from the origin. */\n    fromNormalDistance(normal, distance) {\n        assert(Number.isFinite(distance));\n        this.normal.from(normal).normalize();\n        this.distance = distance;\n        return this;\n    }\n    /** Creates a plane from a normal and a point on the plane. */\n    fromPointNormal(point, normal) {\n        point = scratchPosition.from(point);\n        this.normal.from(normal).normalize();\n        const distance = -this.normal.dot(point);\n        this.distance = distance;\n        return this;\n    }\n    /** Creates a plane from the general equation */\n    fromCoefficients(a, b, c, d) {\n        this.normal.set(a, b, c);\n        assert(equals(this.normal.len(), 1));\n        this.distance = d;\n        return this;\n    }\n    /** Duplicates a Plane instance. */\n    clone() {\n        return new Plane(this.normal, this.distance);\n    }\n    /** Compares the provided Planes by normal and distance */\n    equals(right) {\n        return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n    }\n    /** Computes the signed shortest distance of a point to a plane.\n     * The sign of the distance determines which side of the plane the point is on.\n     */\n    getPointDistance(point) {\n        return this.normal.dot(point) + this.distance;\n    }\n    /** Transforms the plane by the given transformation matrix. */\n    transform(matrix4) {\n        const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n        const point = this.normal.scale(-this.distance).transform(matrix4);\n        return this.fromPointNormal(point, normal);\n    }\n    projectPointOntoPlane(point, result = [0, 0, 0]) {\n        const scratchPoint = scratchPosition.from(point);\n        // projectedPoint = point - (normal.point + scale) * normal\n        const pointDistance = this.getPointDistance(scratchPoint);\n        const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n        return scratchPoint.subtract(scaledNormal).to(result);\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\nimport { Vector3, Matrix4, assert } from '@math.gl/core';\nimport { CullingVolume } from \"./culling-volume.js\";\nimport { Plane } from \"./plane.js\";\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nexport class PerspectiveOffCenterFrustum {\n    /**\n     * The viewing frustum is defined by 6 planes.\n     * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n     * define the unit vector normal to the plane, and the w component is the distance of the\n     * plane from the origin/camera position.\n     *\n     * @alias PerspectiveOffCenterFrustum\n     *\n     * @example\n     * const frustum = new PerspectiveOffCenterFrustum({\n     *     left : -1.0,\n     *     right : 1.0,\n     *     top : 1.0,\n     *     bottom : -1.0,\n     *     near : 1.0,\n     *     far : 100.0\n     * });\n     *\n     * @see PerspectiveFrustum\n     */\n    constructor(options = {}) {\n        this._cullingVolume = new CullingVolume([\n            new Plane(),\n            new Plane(),\n            new Plane(),\n            new Plane(),\n            new Plane(),\n            new Plane()\n        ]);\n        this._perspectiveMatrix = new Matrix4();\n        this._infinitePerspective = new Matrix4();\n        const { near = 1.0, far = 500000000.0 } = options;\n        this.left = options.left;\n        this._left = undefined;\n        this.right = options.right;\n        this._right = undefined;\n        this.top = options.top;\n        this._top = undefined;\n        this.bottom = options.bottom;\n        this._bottom = undefined;\n        this.near = near;\n        this._near = near;\n        this.far = far;\n        this._far = far;\n    }\n    /**\n     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n     * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n     * */\n    clone() {\n        return new PerspectiveOffCenterFrustum({\n            right: this.right,\n            left: this.left,\n            top: this.top,\n            bottom: this.bottom,\n            near: this.near,\n            far: this.far\n        });\n    }\n    /**\n     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    equals(other) {\n        return (other &&\n            other instanceof PerspectiveOffCenterFrustum &&\n            this.right === other.right &&\n            this.left === other.left &&\n            this.top === other.top &&\n            this.bottom === other.bottom &&\n            this.near === other.near &&\n            this.far === other.far);\n    }\n    /**\n     * Gets the perspective projection matrix computed from the view frustum.\n     * @memberof PerspectiveOffCenterFrustum.prototype\n     * @type {Matrix4}\n     *\n     * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n     */\n    get projectionMatrix() {\n        this._update();\n        return this._perspectiveMatrix;\n    }\n    /**\n     * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n     * @memberof PerspectiveOffCenterFrustum.prototype\n     * @type {Matrix4}\n     *\n     * @see PerspectiveOffCenterFrustum#projectionMatrix\n     */\n    get infiniteProjectionMatrix() {\n        this._update();\n        return this._infinitePerspective;\n    }\n    /**\n     * Creates a culling volume for this frustum.\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\n     *\n     * @example\n     * // Check if a bounding volume intersects the frustum.\n     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n     * const intersect = cullingVolume.computeVisibility(boundingVolume);\n     */\n    // eslint-disable-next-line complexity, max-statements\n    computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position, \n    /** A Vector3 defines the view direction. */\n    direction, \n    /** A Vector3 defines the up direction. */\n    up) {\n        assert(position, 'position is required.');\n        assert(direction, 'direction is required.');\n        assert(up, 'up is required.');\n        const planes = this._cullingVolume.planes;\n        up = scratchPlaneUpVector.copy(up).normalize();\n        const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n        const nearCenter = scratchPlaneNearCenter\n            .copy(direction)\n            .multiplyByScalar(this.near)\n            .add(position);\n        const farCenter = scratchPlaneFarCenter\n            .copy(direction)\n            .multiplyByScalar(this.far)\n            .add(position);\n        let normal = scratchPlaneNormal;\n        // Left plane computation\n        normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n        planes[0].fromPointNormal(position, normal);\n        // Right plane computation\n        normal\n            .copy(right)\n            .multiplyByScalar(this.right)\n            .add(nearCenter)\n            .subtract(position)\n            .cross(up)\n            .negate();\n        planes[1].fromPointNormal(position, normal);\n        // Bottom plane computation\n        normal\n            .copy(up)\n            .multiplyByScalar(this.bottom)\n            .add(nearCenter)\n            .subtract(position)\n            .cross(right)\n            .negate();\n        planes[2].fromPointNormal(position, normal);\n        // Top plane computation\n        normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n        planes[3].fromPointNormal(position, normal);\n        normal = new Vector3().copy(direction);\n        // Near plane computation\n        planes[4].fromPointNormal(nearCenter, normal);\n        // Far plane computation\n        normal.negate();\n        planes[5].fromPointNormal(farCenter, normal);\n        return this._cullingVolume;\n    }\n    /**\n     * Returns the pixel's width and height in meters.\n     *\n     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n     *\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n     *\n     * @example\n     * // Example 1\n     * // Get the width and height of a pixel.\n     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n     *\n     * @example\n     * // Example 2\n     * // Get the width and height of a pixel if the near plane was set to 'distance'.\n     * // For example, get the size of a pixel of an image on a billboard.\n     * const position = camera.position;\n     * const direction = camera.direction;\n     * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n     * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n     * const distance = Vector3.magnitude(toCenterProj);\n     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n     */\n    getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth, \n    /** The height of the drawing buffer. */\n    drawingBufferHeight, \n    /** The distance to the near plane in meters. */\n    distance, \n    /** The object onto which to store the result. */\n    result) {\n        this._update();\n        assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n        // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n        assert(drawingBufferWidth > 0);\n        // 'drawingBufferWidth must be greater than zero.'\n        assert(drawingBufferHeight > 0);\n        // 'drawingBufferHeight must be greater than zero.'\n        assert(distance > 0);\n        // 'distance is required.');\n        assert(result);\n        // 'A result object is required.');\n        const inverseNear = 1.0 / this.near;\n        let tanTheta = this.top * inverseNear;\n        const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n        tanTheta = this.right * inverseNear;\n        const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n        result.x = pixelWidth;\n        result.y = pixelHeight;\n        return result;\n    }\n    // eslint-disable-next-line complexity, max-statements\n    _update() {\n        assert(Number.isFinite(this.right) &&\n            Number.isFinite(this.left) &&\n            Number.isFinite(this.top) &&\n            Number.isFinite(this.bottom) &&\n            Number.isFinite(this.near) &&\n            Number.isFinite(this.far));\n        // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n        const { top, bottom, right, left, near, far } = this;\n        if (top !== this._top ||\n            bottom !== this._bottom ||\n            left !== this._left ||\n            right !== this._right ||\n            near !== this._near ||\n            far !== this._far) {\n            assert(this.near > 0 && this.near < this.far, 'near must be greater than zero and less than far.');\n            this._left = left;\n            this._right = right;\n            this._top = top;\n            this._bottom = bottom;\n            this._near = near;\n            this._far = far;\n            this._perspectiveMatrix = new Matrix4().frustum({\n                left,\n                right,\n                bottom,\n                top,\n                near,\n                far\n            });\n            this._infinitePerspective = new Matrix4().frustum({\n                left,\n                right,\n                bottom,\n                top,\n                near,\n                far: Infinity\n            });\n        }\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\nimport { assert, Vector2 } from '@math.gl/core';\nimport { PerspectiveOffCenterFrustum } from \"./perspective-off-center-frustum.js\";\nconst defined = (val) => val !== null && typeof val !== 'undefined';\n/**\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias PerspectiveFrustum\n *\n * @example\n * var frustum = new PerspectiveFrustum({\n *     fov : Math.PI_OVER_THREE,\n *     aspectRatio : canvas.clientWidth / canvas.clientHeight\n *     near : 1.0,\n *     far : 1000.0\n * });\n *\n * @see PerspectiveOffCenterFrustum\n */\nexport class PerspectiveFrustum {\n    constructor(options = {}) {\n        this._offCenterFrustum = new PerspectiveOffCenterFrustum();\n        const { fov, aspectRatio, near = 1.0, far = 500000000.0, xOffset = 0.0, yOffset = 0.0 } = options;\n        this.fov = fov;\n        this.aspectRatio = aspectRatio;\n        this.near = near;\n        this.far = far;\n        this.xOffset = xOffset;\n        this.yOffset = yOffset;\n    }\n    /**\n     * Returns a duplicate of a PerspectiveFrustum instance.\n     */\n    clone() {\n        return new PerspectiveFrustum({\n            aspectRatio: this.aspectRatio,\n            fov: this.fov,\n            near: this.near,\n            far: this.far\n        });\n    }\n    /**\n     * Compares the provided PerspectiveFrustum componentwise and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     */\n    equals(other) {\n        if (!defined(other) || !(other instanceof PerspectiveFrustum)) {\n            return false;\n        }\n        this._update();\n        other._update();\n        return (this.fov === other.fov &&\n            this.aspectRatio === other.aspectRatio &&\n            this.near === other.near &&\n            this.far === other.far &&\n            this._offCenterFrustum.equals(other._offCenterFrustum));\n    }\n    /**\n     * Gets the perspective projection matrix computed from the view this.\n     */\n    get projectionMatrix() {\n        this._update();\n        return this._offCenterFrustum.projectionMatrix;\n    }\n    /**\n     * The perspective projection matrix computed from the view frustum with an infinite far plane.\n     */\n    get infiniteProjectionMatrix() {\n        this._update();\n        return this._offCenterFrustum.infiniteProjectionMatrix;\n    }\n    /**\n     * Gets the angle of the vertical field of view, in radians.\n     */\n    get fovy() {\n        this._update();\n        return this._fovy;\n    }\n    /**\n     * @private\n     */\n    get sseDenominator() {\n        this._update();\n        return this._sseDenominator;\n    }\n    /**\n     * Creates a culling volume for this this.ion.\n     * @returns {CullingVolume} A culling volume at the given position and orientation.\n     *\n     * @example\n     * // Check if a bounding volume intersects the this.\n     * var cullingVolume = this.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n     * var intersect = cullingVolume.computeVisibility(boundingVolume);\n     */\n    computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position, \n    /** A Vector3 defines the view direction. */\n    direction, \n    /** A Vector3 defines the up direction. */\n    up) {\n        this._update();\n        return this._offCenterFrustum.computeCullingVolume(position, direction, up);\n    }\n    /**\n     * Returns the pixel's width and height in meters.\n     * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n     *\n     * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n     * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n     *\n     * @example\n     * // Example 1\n     * // Get the width and height of a pixel.\n     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n     *\n     * @example\n     * // Example 2\n     * // Get the width and height of a pixel if the near plane was set to 'distance'.\n     * // For example, get the size of a pixel of an image on a billboard.\n     * var position = camera.position;\n     * var direction = camera.direction;\n     * var toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n     * var toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n     * var distance = Vector3.magnitude(toCenterProj);\n     * var pixelSize = camera.this.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n     */\n    getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth, \n    /** The height of the drawing buffer. */\n    drawingBufferHeight, \n    /** The distance to the near plane in meters. */\n    distance, \n    /** The object onto which to store the result. */\n    result) {\n        this._update();\n        return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result || new Vector2());\n    }\n    // eslint-disable-next-line complexity, max-statements\n    _update() {\n        assert(Number.isFinite(this.fov) &&\n            Number.isFinite(this.aspectRatio) &&\n            Number.isFinite(this.near) &&\n            Number.isFinite(this.far));\n        // 'fov, aspectRatio, near, or far parameters are not set.'\n        const f = this._offCenterFrustum;\n        if (this.fov !== this._fov ||\n            this.aspectRatio !== this._aspectRatio ||\n            this.near !== this._near ||\n            this.far !== this._far ||\n            this.xOffset !== this._xOffset ||\n            this.yOffset !== this._yOffset) {\n            assert(this.fov >= 0 && this.fov < Math.PI);\n            // throw new DeveloperError('fov must be in the range [0, PI).');\n            assert(this.aspectRatio > 0);\n            // throw new DeveloperError('aspectRatio must be positive.');\n            assert(this.near >= 0 && this.near < this.far);\n            // throw new DeveloperError('near must be greater than zero and less than far.');\n            this._aspectRatio = this.aspectRatio;\n            this._fov = this.fov;\n            this._fovy =\n                this.aspectRatio <= 1\n                    ? this.fov\n                    : Math.atan(Math.tan(this.fov * 0.5) / this.aspectRatio) * 2.0;\n            this._near = this.near;\n            this._far = this.far;\n            this._sseDenominator = 2.0 * Math.tan(0.5 * this._fovy);\n            this._xOffset = this.xOffset;\n            this._yOffset = this.yOffset;\n            f.top = this.near * Math.tan(0.5 * this._fovy);\n            f.bottom = -f.top;\n            f.right = this.aspectRatio * f.top;\n            f.left = -f.right;\n            f.near = this.near;\n            f.far = this.far;\n            f.right += this.xOffset;\n            f.left += this.xOffset;\n            f.top += this.yOffset;\n            f.bottom += this.yOffset;\n        }\n    }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3 } from '@math.gl/core';\nimport { BoundingSphere } from \"../bounding-volumes/bounding-sphere.js\";\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\n// const volumeConstant = (4.0 / 3.0) * Math.PI;\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport function makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n    if (!positions || positions.length === 0) {\n        return result.fromCenterRadius([0, 0, 0], 0);\n    }\n    const currentPos = fromPointsCurrentPos.copy(positions[0]);\n    const xMin = fromPointsXMin.copy(currentPos);\n    const yMin = fromPointsYMin.copy(currentPos);\n    const zMin = fromPointsZMin.copy(currentPos);\n    const xMax = fromPointsXMax.copy(currentPos);\n    const yMax = fromPointsYMax.copy(currentPos);\n    const zMax = fromPointsZMax.copy(currentPos);\n    for (const position of positions) {\n        currentPos.copy(position);\n        const x = currentPos.x;\n        const y = currentPos.y;\n        const z = currentPos.z;\n        // Store points containing the the smallest and largest components\n        if (x < xMin.x) {\n            xMin.copy(currentPos);\n        }\n        if (x > xMax.x) {\n            xMax.copy(currentPos);\n        }\n        if (y < yMin.y) {\n            yMin.copy(currentPos);\n        }\n        if (y > yMax.y) {\n            yMax.copy(currentPos);\n        }\n        if (z < zMin.z) {\n            zMin.copy(currentPos);\n        }\n        if (z > zMax.z) {\n            zMax.copy(currentPos);\n        }\n    }\n    // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n    const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n    const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n    const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n    // Set the diameter endpoints to the largest span.\n    let diameter1 = xMin;\n    let diameter2 = xMax;\n    let maxSpan = xSpan;\n    if (ySpan > maxSpan) {\n        maxSpan = ySpan;\n        diameter1 = yMin;\n        diameter2 = yMax;\n    }\n    if (zSpan > maxSpan) {\n        maxSpan = zSpan;\n        diameter1 = zMin;\n        diameter2 = zMax;\n    }\n    // Calculate the center of the initial sphere found by Ritter's algorithm\n    const ritterCenter = fromPointsRitterCenter;\n    ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n    ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n    ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n    // Calculate the radius of the initial sphere found by Ritter's algorithm\n    let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n    let ritterRadius = Math.sqrt(radiusSquared);\n    // Find the center of the sphere found using the Naive method.\n    const minBoxPt = fromPointsMinBoxPt;\n    minBoxPt.x = xMin.x;\n    minBoxPt.y = yMin.y;\n    minBoxPt.z = zMin.z;\n    const maxBoxPt = fromPointsMaxBoxPt;\n    maxBoxPt.x = xMax.x;\n    maxBoxPt.y = yMax.y;\n    maxBoxPt.z = zMax.z;\n    const naiveCenter = fromPointsNaiveCenterScratch\n        .copy(minBoxPt)\n        .add(maxBoxPt)\n        .multiplyByScalar(0.5);\n    // Begin 2nd pass to find naive radius and modify the ritter sphere.\n    let naiveRadius = 0;\n    for (const position of positions) {\n        currentPos.copy(position);\n        // Find the furthest point from the naive center to calculate the naive radius.\n        const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n        if (r > naiveRadius) {\n            naiveRadius = r;\n        }\n        // Make adjustments to the Ritter Sphere to include all points.\n        const oldCenterToPointSquared = fromPointsScratch\n            .copy(currentPos)\n            .subtract(ritterCenter)\n            .magnitudeSquared();\n        if (oldCenterToPointSquared > radiusSquared) {\n            const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n            // Calculate new radius to include the point that lies outside\n            ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n            radiusSquared = ritterRadius * ritterRadius;\n            // Calculate center of new Ritter sphere\n            const oldToNew = oldCenterToPoint - ritterRadius;\n            ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n            ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n            ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n        }\n    }\n    if (ritterRadius < naiveRadius) {\n        ritterCenter.to(result.center);\n        result.radius = ritterRadius;\n    }\n    else {\n        naiveCenter.to(result.center);\n        result.radius = naiveRadius;\n    }\n    return result;\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { computeEigenDecomposition } from \"./compute-eigen-decomposition.js\";\nimport { OrientedBoundingBox } from \"../bounding-volumes/oriented-bounding-box.js\";\nimport { AxisAlignedBoundingBox } from \"../bounding-volumes/axis-aligned-bounding-box.js\";\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\nconst scratchVector4 = new Vector3();\nconst scratchVector5 = new Vector3();\nconst scratchVector6 = new Vector3();\nconst scratchCovarianceResult = new Matrix3();\nconst scratchEigenResult = {\n    diagonal: new Matrix3(),\n    unitary: new Matrix3()\n};\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n    if (!positions || positions.length === 0) {\n        result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        result.center = new Vector3();\n        return result;\n    }\n    const length = positions.length;\n    const meanPoint = new Vector3(0, 0, 0);\n    for (const position of positions) {\n        meanPoint.add(position);\n    }\n    const invLength = 1.0 / length;\n    meanPoint.multiplyByScalar(invLength);\n    let exx = 0.0;\n    let exy = 0.0;\n    let exz = 0.0;\n    let eyy = 0.0;\n    let eyz = 0.0;\n    let ezz = 0.0;\n    for (const position of positions) {\n        const p = scratchVector2.copy(position).subtract(meanPoint);\n        exx += p.x * p.x;\n        exy += p.x * p.y;\n        exz += p.x * p.z;\n        eyy += p.y * p.y;\n        eyz += p.y * p.z;\n        ezz += p.z * p.z;\n    }\n    exx *= invLength;\n    exy *= invLength;\n    exz *= invLength;\n    eyy *= invLength;\n    eyz *= invLength;\n    ezz *= invLength;\n    const covarianceMatrix = scratchCovarianceResult;\n    covarianceMatrix[0] = exx;\n    covarianceMatrix[1] = exy;\n    covarianceMatrix[2] = exz;\n    covarianceMatrix[3] = exy;\n    covarianceMatrix[4] = eyy;\n    covarianceMatrix[5] = eyz;\n    covarianceMatrix[6] = exz;\n    covarianceMatrix[7] = eyz;\n    covarianceMatrix[8] = ezz;\n    const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n    const rotation = result.halfAxes.copy(unitary);\n    let v1 = rotation.getColumn(0, scratchVector4);\n    let v2 = rotation.getColumn(1, scratchVector5);\n    let v3 = rotation.getColumn(2, scratchVector6);\n    let u1 = -Number.MAX_VALUE;\n    let u2 = -Number.MAX_VALUE;\n    let u3 = -Number.MAX_VALUE;\n    let l1 = Number.MAX_VALUE;\n    let l2 = Number.MAX_VALUE;\n    let l3 = Number.MAX_VALUE;\n    for (const position of positions) {\n        scratchVector2.copy(position);\n        u1 = Math.max(scratchVector2.dot(v1), u1);\n        u2 = Math.max(scratchVector2.dot(v2), u2);\n        u3 = Math.max(scratchVector2.dot(v3), u3);\n        l1 = Math.min(scratchVector2.dot(v1), l1);\n        l2 = Math.min(scratchVector2.dot(v2), l2);\n        l3 = Math.min(scratchVector2.dot(v3), l3);\n    }\n    v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n    v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n    v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n    result.center.copy(v1).add(v2).add(v3);\n    const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n    const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n    result.halfAxes.multiplyRight(scaleMatrix);\n    return result;\n}\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(positions, result = new AxisAlignedBoundingBox()) {\n    if (!positions || positions.length === 0) {\n        result.minimum.set(0, 0, 0);\n        result.maximum.set(0, 0, 0);\n        result.center.set(0, 0, 0);\n        result.halfDiagonal.set(0, 0, 0);\n        return result;\n    }\n    let minimumX = positions[0][0];\n    let minimumY = positions[0][1];\n    let minimumZ = positions[0][2];\n    let maximumX = positions[0][0];\n    let maximumY = positions[0][1];\n    let maximumZ = positions[0][2];\n    for (const p of positions) {\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n        minimumX = Math.min(x, minimumX);\n        maximumX = Math.max(x, maximumX);\n        minimumY = Math.min(y, minimumY);\n        maximumY = Math.max(y, maximumY);\n        minimumZ = Math.min(z, minimumZ);\n        maximumZ = Math.max(z, maximumZ);\n    }\n    result.minimum.set(minimumX, minimumY, minimumZ);\n    result.maximum.set(maximumX, maximumY, maximumZ);\n    result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n    result.halfDiagonal.copy(result.maximum).subtract(result.center);\n    return result;\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Matrix3, _MathUtils } from '@math.gl/core';\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport function computeEigenDecomposition(matrix, \n// @ts-expect-error accept empty object type\nresult = {}) {\n    const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n    const EIGEN_MAX_SWEEPS = 10;\n    let count = 0;\n    let sweep = 0;\n    const unitaryMatrix = scratchUnitary;\n    const diagonalMatrix = scratchDiagonal;\n    unitaryMatrix.identity();\n    diagonalMatrix.copy(matrix);\n    const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n    while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n        shurDecomposition(diagonalMatrix, jMatrix);\n        jMatrixTranspose.copy(jMatrix).transpose();\n        diagonalMatrix.multiplyRight(jMatrix);\n        diagonalMatrix.multiplyLeft(jMatrixTranspose);\n        unitaryMatrix.multiplyRight(jMatrix);\n        if (++count > 2) {\n            ++sweep;\n            count = 0;\n        }\n    }\n    result.unitary = unitaryMatrix.toTarget(result.unitary);\n    result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n    return result;\n}\nfunction computeFrobeniusNorm(matrix) {\n    let norm = 0.0;\n    for (let i = 0; i < 9; ++i) {\n        const temp = matrix[i];\n        norm += temp * temp;\n    }\n    return Math.sqrt(norm);\n}\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix) {\n    let norm = 0.0;\n    for (let i = 0; i < 3; ++i) {\n        const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n        norm += 2.0 * temp * temp;\n    }\n    return Math.sqrt(norm);\n}\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix, result) {\n    const tolerance = _MathUtils.EPSILON15;\n    let maxDiagonal = 0.0;\n    let rotAxis = 1;\n    // find pivot (rotAxis) based on max diagonal of matrix\n    for (let i = 0; i < 3; ++i) {\n        const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n        if (temp > maxDiagonal) {\n            rotAxis = i;\n            maxDiagonal = temp;\n        }\n    }\n    const p = rowVal[rotAxis];\n    const q = colVal[rotAxis];\n    let c = 1.0;\n    let s = 0.0;\n    if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n        const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n        const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n        const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n        const tau = (qq - pp) / 2.0 / qp;\n        let t;\n        if (tau < 0.0) {\n            t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n        }\n        else {\n            t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n        }\n        c = 1.0 / Math.sqrt(1.0 + t * t);\n        s = t * c;\n    }\n    // Copy into result\n    Matrix3.IDENTITY.to(result);\n    result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n    result[scratchMatrix.getElementIndex(q, p)] = s;\n    result[scratchMatrix.getElementIndex(p, q)] = -s;\n    return result;\n}\n"],
  "mappings": "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",
  "names": ["import_core", "scratchVector", "scratchVector2", "import_core", "import_core", "import_core", "scratchNormal", "import_core", "scratchPlaneNormal", "import_core", "import_core", "import_core", "import_core", "scratchVector2", "scratchVector3"]
}
