{
  "version": 3,
  "sources": ["index.js", "ellipsoid/ellipsoid.js", "constants.js", "type-utils.js", "ellipsoid/helpers/ellipsoid-transform.js", "ellipsoid/helpers/scale-to-geodetic-surface.js"],
  "sourcesContent": ["export { Ellipsoid } from \"./ellipsoid/ellipsoid.js\";\nexport { isWGS84 } from \"./type-utils.js\";\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n/* eslint-disable */\nimport { Vector3, Matrix4, assert, equals, _MathUtils, vec3 } from '@math.gl/core';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from \"../constants.js\";\nimport { fromCartographicToRadians, toCartographicFromRadians } from \"../type-utils.js\";\nimport { localFrameToFixedFrame } from \"./helpers/ellipsoid-transform.js\";\nimport { scaleToGeodeticSurface } from \"./helpers/scale-to-geodetic-surface.js\";\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport class Ellipsoid {\n    constructor(x = 0.0, y = 0.0, z = 0.0) {\n        this.centerToleranceSquared = _MathUtils.EPSILON1;\n        assert(x >= 0.0);\n        assert(y >= 0.0);\n        assert(z >= 0.0);\n        this.radii = new Vector3(x, y, z);\n        this.radiiSquared = new Vector3(x * x, y * y, z * z);\n        this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n        this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n        this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n        this.minimumRadius = Math.min(x, y, z);\n        this.maximumRadius = Math.max(x, y, z);\n        if (this.radiiSquared.z !== 0) {\n            this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n        }\n        Object.freeze(this);\n    }\n    /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n    equals(right) {\n        return this === right || Boolean(right && this.radii.equals(right.radii));\n    }\n    /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n    toString() {\n        return this.radii.toString();\n    }\n    cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n        const normal = scratchNormal;\n        const k = scratchK;\n        const [, , height] = cartographic;\n        this.geodeticSurfaceNormalCartographic(cartographic, normal);\n        k.copy(this.radiiSquared).scale(normal);\n        const gamma = Math.sqrt(normal.dot(k));\n        k.scale(1 / gamma);\n        normal.scale(height);\n        k.add(normal);\n        return k.to(result);\n    }\n    cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n        scratchCartesian.from(cartesian);\n        const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n        if (!point) {\n            return undefined;\n        }\n        const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n        const h = scratchHeight;\n        h.copy(scratchCartesian).subtract(point);\n        const longitude = Math.atan2(normal.y, normal.x);\n        const latitude = Math.asin(normal.z);\n        const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n        return toCartographicFromRadians([longitude, latitude, height], result);\n    }\n    eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n        return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n    }\n    // Computes a 4x4 transformation matrix from a reference frame centered at\n    // the provided origin to the ellipsoid's fixed reference frame.\n    localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n        return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n    }\n    geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n        return scratchVector.from(cartesian).normalize().to(result);\n    }\n    geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n        const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n        const longitude = cartographicVectorRadians[0];\n        const latitude = cartographicVectorRadians[1];\n        const cosLatitude = Math.cos(latitude);\n        scratchVector\n            .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n            .normalize();\n        return scratchVector.to(result);\n    }\n    geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n        return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n    }\n    /** Scales the provided Cartesian position along the geodetic surface normal\n     * so that it is on the surface of this ellipsoid.  If the position is\n     * at the center of the ellipsoid, this function returns undefined. */\n    scaleToGeodeticSurface(cartesian, result) {\n        return scaleToGeodeticSurface(cartesian, this, result);\n    }\n    /** Scales the provided Cartesian position along the geocentric surface normal\n     * so that it is on the surface of this ellipsoid. */\n    scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n        scratchPosition.from(cartesian);\n        const positionX = scratchPosition.x;\n        const positionY = scratchPosition.y;\n        const positionZ = scratchPosition.z;\n        const oneOverRadiiSquared = this.oneOverRadiiSquared;\n        const beta = 1.0 /\n            Math.sqrt(positionX * positionX * oneOverRadiiSquared.x +\n                positionY * positionY * oneOverRadiiSquared.y +\n                positionZ * positionZ * oneOverRadiiSquared.z);\n        return scratchPosition.multiplyScalar(beta).to(result);\n    }\n    /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n     * its components by the result of `Ellipsoid#oneOverRadii` */\n    transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n        return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n    }\n    /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n     * its components by the result of `Ellipsoid#radii`. */\n    transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n        return scratchPosition.from(position).scale(this.radii).to(result);\n    }\n    /** Computes a point which is the intersection of the surface normal with the z-axis. */\n    getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {\n        // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n        assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n        assert(this.radii.z > 0);\n        scratchPosition.from(position);\n        const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n        if (Math.abs(z) >= this.radii.z - buffer) {\n            return undefined;\n        }\n        return scratchPosition.set(0.0, 0.0, z).to(result);\n    }\n}\n/** An Ellipsoid instance initialized to the WGS84 standard. */\nEllipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nexport const WGS84_RADIUS_X = 6378137.0;\nexport const WGS84_RADIUS_Y = 6378137.0;\nexport const WGS84_RADIUS_Z = 6356752.3142451793;\n// Pre-calculated ellipsoid defaults to avoid utils depending on `ellipsoid.js`\nexport const WGS84_CONSTANTS = {\n    radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],\n    radiiSquared: [\n        WGS84_RADIUS_X * WGS84_RADIUS_X,\n        WGS84_RADIUS_Y * WGS84_RADIUS_Y,\n        WGS84_RADIUS_Z * WGS84_RADIUS_Z\n    ],\n    oneOverRadii: [1.0 / WGS84_RADIUS_X, 1.0 / WGS84_RADIUS_Y, 1.0 / WGS84_RADIUS_Z],\n    oneOverRadiiSquared: [\n        1.0 / (WGS84_RADIUS_X * WGS84_RADIUS_X),\n        1.0 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),\n        1.0 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)\n    ],\n    maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),\n    centerToleranceSquared: 1e-1 // EPSILON1;\n};\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\nimport { Vector3, toRadians, toDegrees, config } from '@math.gl/core';\nimport { WGS84_CONSTANTS } from \"./constants.js\";\nfunction identity(x) {\n    return x;\n}\nconst scratchVector = new Vector3();\nexport function fromCartographic(cartographic, result = [], map = identity) {\n    if ('longitude' in cartographic) {\n        result[0] = map(cartographic.longitude);\n        result[1] = map(cartographic.latitude);\n        result[2] = cartographic.height;\n    }\n    else if ('x' in cartographic) {\n        result[0] = map(cartographic.x);\n        result[1] = map(cartographic.y);\n        result[2] = cartographic.z;\n    }\n    else {\n        result[0] = map(cartographic[0]);\n        result[1] = map(cartographic[1]);\n        result[2] = cartographic[2];\n    }\n    return result;\n}\nexport function fromCartographicToRadians(cartographic, vector = []) {\n    return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\nexport function fromCartographicToDegrees(cartographic, vector = []) {\n    return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\nexport function toCartographic(vector, cartographic, map = identity) {\n    if ('longitude' in cartographic) {\n        cartographic.longitude = map(vector[0]);\n        cartographic.latitude = map(vector[1]);\n        cartographic.height = vector[2];\n    }\n    else if ('x' in cartographic) {\n        cartographic.x = map(vector[0]);\n        cartographic.y = map(vector[1]);\n        cartographic.z = vector[2];\n    }\n    else {\n        cartographic[0] = map(vector[0]);\n        cartographic[1] = map(vector[1]);\n        cartographic[2] = vector[2];\n    }\n    return cartographic;\n}\nexport function toCartographicFromRadians(vector, cartographic) {\n    return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\nexport function toCartographicFromDegrees(vector, cartographic) {\n    return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector) {\n    if (!vector) {\n        return false;\n    }\n    scratchVector.from(vector);\n    const { oneOverRadiiSquared, centerToleranceSquared } = WGS84_CONSTANTS;\n    const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n    const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n    const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n    return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n", "import { Vector3, assert, equals as equalsEpsilon } from '@math.gl/core';\nconst EPSILON14 = 1e-14;\nconst scratchOrigin = new Vector3();\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n    up: {\n        south: 'east',\n        north: 'west',\n        west: 'south',\n        east: 'north'\n    },\n    down: {\n        south: 'west',\n        north: 'east',\n        west: 'north',\n        east: 'south'\n    },\n    south: {\n        up: 'west',\n        down: 'east',\n        west: 'down',\n        east: 'up'\n    },\n    north: {\n        up: 'east',\n        down: 'west',\n        west: 'up',\n        east: 'down'\n    },\n    west: {\n        up: 'north',\n        down: 'south',\n        north: 'down',\n        south: 'up'\n    },\n    east: {\n        up: 'south',\n        down: 'north',\n        north: 'up',\n        south: 'down'\n    }\n};\nconst degeneratePositionLocalFrame = {\n    north: [-1, 0, 0],\n    east: [0, 1, 0],\n    up: [0, 0, 1],\n    south: [1, 0, 0],\n    west: [0, -1, 0],\n    down: [0, 0, -1]\n};\nconst scratchAxisVectors = {\n    east: new Vector3(),\n    north: new Vector3(),\n    up: new Vector3(),\n    west: new Vector3(),\n    south: new Vector3(),\n    down: new Vector3()\n};\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {\n    const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];\n    // firstAxis and secondAxis must be east, north, up, west, south or down.');\n    assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n    let firstAxisVector;\n    let secondAxisVector;\n    let thirdAxisVector;\n    const origin = scratchOrigin.copy(cartesianOrigin);\n    // If x and y are zero, assume origin is at a pole, which is a special case.\n    const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n    if (atPole) {\n        // Look up axis value and adjust\n        const sign = Math.sign(origin.z);\n        firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n        if (firstAxis !== 'east' && firstAxis !== 'west') {\n            firstAxisVector.scale(sign);\n        }\n        secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n        if (secondAxis !== 'east' && secondAxis !== 'west') {\n            secondAxisVector.scale(sign);\n        }\n        thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n        if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n            thirdAxisVector.scale(sign);\n        }\n    }\n    else {\n        // Calculate all axis\n        const { up, east, north } = scratchAxisVectors;\n        east.set(-origin.y, origin.x, 0.0).normalize();\n        ellipsoid.geodeticSurfaceNormal(origin, up);\n        north.copy(up).cross(east);\n        const { down, west, south } = scratchAxisVectors;\n        down.copy(up).scale(-1);\n        west.copy(east).scale(-1);\n        south.copy(north).scale(-1);\n        // Pick three axis based on desired orientation\n        firstAxisVector = scratchAxisVectors[firstAxis];\n        secondAxisVector = scratchAxisVectors[secondAxis];\n        thirdAxisVector = scratchAxisVectors[thirdAxis];\n    }\n    // TODO - assuming the result is column-major\n    result[0] = firstAxisVector.x;\n    result[1] = firstAxisVector.y;\n    result[2] = firstAxisVector.z;\n    result[3] = 0.0;\n    result[4] = secondAxisVector.x;\n    result[5] = secondAxisVector.y;\n    result[6] = secondAxisVector.z;\n    result[7] = 0.0;\n    result[8] = thirdAxisVector.x;\n    result[9] = thirdAxisVector.y;\n    result[10] = thirdAxisVector.z;\n    result[11] = 0.0;\n    result[12] = origin.x;\n    result[13] = origin.y;\n    result[14] = origin.z;\n    result[15] = 1.0;\n    return result;\n}\n", "/* eslint-disable */\nimport { Vector3, _MathUtils } from '@math.gl/core';\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {\n    const { oneOverRadii, oneOverRadiiSquared, centerToleranceSquared } = ellipsoid;\n    scratchVector.from(cartesian);\n    const positionX = scratchVector.x;\n    const positionY = scratchVector.y;\n    const positionZ = scratchVector.z;\n    const oneOverRadiiX = oneOverRadii.x;\n    const oneOverRadiiY = oneOverRadii.y;\n    const oneOverRadiiZ = oneOverRadii.z;\n    const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n    const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n    const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n    // Compute the squared ellipsoid norm.\n    const squaredNorm = x2 + y2 + z2;\n    const ratio = Math.sqrt(1.0 / squaredNorm);\n    // When very close to center or at center\n    if (!Number.isFinite(ratio)) {\n        return undefined;\n    }\n    // As an initial approximation, assume that the radial intersection is the projection point.\n    const intersection = scaleToGeodeticSurfaceIntersection;\n    intersection.copy(cartesian).scale(ratio);\n    // If the position is near the center, the iteration will not converge.\n    if (squaredNorm < centerToleranceSquared) {\n        return intersection.to(result);\n    }\n    const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n    const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n    const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n    // Use the gradient at the intersection point in place of the true unit normal.\n    // The difference in magnitude will be absorbed in the multiplier.\n    const gradient = scaleToGeodeticSurfaceGradient;\n    gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n    // Compute the initial guess at the normal vector multiplier, lambda.\n    let lambda = ((1.0 - ratio) * scratchVector.len()) / (0.5 * gradient.len());\n    let correction = 0.0;\n    let xMultiplier;\n    let yMultiplier;\n    let zMultiplier;\n    let func;\n    do {\n        lambda -= correction;\n        xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n        yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n        zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n        const xMultiplier2 = xMultiplier * xMultiplier;\n        const yMultiplier2 = yMultiplier * yMultiplier;\n        const zMultiplier2 = zMultiplier * zMultiplier;\n        const xMultiplier3 = xMultiplier2 * xMultiplier;\n        const yMultiplier3 = yMultiplier2 * yMultiplier;\n        const zMultiplier3 = zMultiplier2 * zMultiplier;\n        func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n        // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n        // computations in the sections to follow.\n        const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX +\n            y2 * yMultiplier3 * oneOverRadiiSquaredY +\n            z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n        const derivative = -2.0 * denominator;\n        correction = func / derivative;\n    } while (Math.abs(func) > _MathUtils.EPSILON12);\n    return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "equalsEpsilon", "import_core", "scratchVector", "scratchVector"]
}
