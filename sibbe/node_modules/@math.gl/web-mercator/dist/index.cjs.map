{
  "version": 3,
  "sources": ["index.js", "math-utils.js", "web-mercator-utils.js", "assert.js", "fit-bounds.js", "get-bounds.js", "web-mercator-viewport.js", "normalize-viewport-props.js", "fly-to-viewport.js"],
  "sourcesContent": ["// Classic web-mercator-project\nexport { WebMercatorViewport } from \"./web-mercator-viewport.js\";\nexport { getBounds } from \"./get-bounds.js\";\nexport { fitBounds } from \"./fit-bounds.js\";\nexport { normalizeViewportProps } from \"./normalize-viewport-props.js\";\nexport { flyToViewport, getFlyToDuration } from \"./fly-to-viewport.js\";\nexport { MAX_LATITUDE, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld, zoomToScale, scaleToZoom, altitudeToFovy, fovyToAltitude, getMeterZoom, unitsPerMeter, getDistanceScales, addMetersToLngLat, getViewMatrix, getProjectionMatrix, getProjectionParameters } from \"./web-mercator-utils.js\";\n/** @deprecated default export */\nexport { WebMercatorViewport as default } from \"./web-mercator-viewport.js\";\n", "import { vec4 } from '@math.gl/core';\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n// Transforms a vec4 with a projection matrix\nexport function transformVector(matrix, vector) {\n    const result = vec4.transformMat4([], vector, matrix);\n    vec4.scale(result, result, 1 / result[3]);\n    return result;\n}\nexport function mod(value, divisor) {\n    const modulus = value % divisor;\n    return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function lerp(start, end, step) {\n    return step * end + (1 - step) * start;\n}\nexport function clamp(x, min, max) {\n    return x < min ? min : x > max ? max : x;\n}\nfunction ieLog2(x) {\n    return Math.log(x) * Math.LOG2E;\n}\n// Handle missing log2 in IE 11\nexport const log2 = Math.log2 || ieLog2;\n", "// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE\nimport { createMat4, transformVector, clamp, log2 } from \"./math-utils.js\";\nimport { mat4, vec2, vec3 } from '@math.gl/core';\nimport { assert } from \"./assert.js\";\n// CONSTANTS\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n// Latitude that makes a square world, 2 * atan(E ** PI) - PI / 2\nexport const MAX_LATITUDE = 85.051129;\n// Mapbox default altitude\nexport const DEFAULT_ALTITUDE = 1.5;\n/** Logarithimic zoom to linear scale **/\nexport function zoomToScale(zoom) {\n    return Math.pow(2, zoom);\n}\n/** Linear scale to logarithimic zoom **/\nexport function scaleToZoom(scale) {\n    return log2(scale);\n}\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return [x,y] coordinates.\n */\nexport function lngLatToWorld(lngLat) {\n    const [lng, lat] = lngLat;\n    assert(Number.isFinite(lng));\n    assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');\n    const lambda2 = lng * DEGREES_TO_RADIANS;\n    const phi2 = lat * DEGREES_TO_RADIANS;\n    const x = (TILE_SIZE * (lambda2 + PI)) / (2 * PI);\n    const y = (TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5)))) / (2 * PI);\n    return [x, y];\n}\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param xy - array with [x,y] members\n *  representing point on projected map plane\n * @return - array with [x,y] of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nexport function worldToLngLat(xy) {\n    const [x, y] = xy;\n    const lambda2 = (x / TILE_SIZE) * (2 * PI) - PI;\n    const phi2 = 2 * (Math.atan(Math.exp((y / TILE_SIZE) * (2 * PI) - PI)) - PI_4);\n    return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n/**\n * Returns the zoom level that gives a 1 meter pixel at a certain latitude\n * 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)\n */\nexport function getMeterZoom(options) {\n    const { latitude } = options;\n    assert(Number.isFinite(latitude));\n    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\n/**\n * Calculate the conversion from meter to common units at a given latitude\n * This is a cheaper version of `getDistanceScales`\n * @param latitude center latitude in degrees\n * @returns common units per meter\n */\nexport function unitsPerMeter(latitude) {\n    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;\n}\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales(options) {\n    const { latitude, longitude, highPrecision = false } = options;\n    assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n    const worldSize = TILE_SIZE;\n    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n    /**\n     * Number of pixels occupied by one degree longitude around current lat/lon:\n       unitsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n         = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n       unitsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n         = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n     */\n    const unitsPerDegreeX = worldSize / 360;\n    const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n    /**\n     * Number of pixels occupied by one meter around current lat/lon:\n     */\n    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n    /**\n     * LngLat: longitude -> east and latitude -> north (bottom left)\n     * UTM meter offset: x -> east and y -> north (bottom left)\n     * World space: x -> east and y -> south (top left)\n     *\n     * Y needs to be flipped when converting delta degree/meter to delta pixels\n     */\n    const result = {\n        unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],\n        metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],\n        unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],\n        degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]\n    };\n    /**\n     * Taylor series 2nd order for 1/latCosine\n       f'(a) * (x - a)\n         = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n         = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n     */\n    if (highPrecision) {\n        const latCosine2 = (DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS)) / latCosine;\n        const unitsPerDegreeY2 = (unitsPerDegreeX * latCosine2) / 2;\n        const altUnitsPerDegree2 = (worldSize / EARTH_CIRCUMFERENCE) * latCosine2;\n        const altUnitsPerMeter2 = (altUnitsPerDegree2 / unitsPerDegreeY) * altUnitsPerMeter;\n        result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n        result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n    }\n    // Main results, used for converting meters to latlng deltas and scaling offsets\n    return result;\n}\n/**\n * Offset a lng/lat position by meterOffset (northing, easting)\n */\nexport function addMetersToLngLat(lngLatZ, xyz) {\n    const [longitude, latitude, z0] = lngLatZ;\n    const [x, y, z] = xyz;\n    const { unitsPerMeter, unitsPerMeter2 } = getDistanceScales({\n        longitude,\n        latitude,\n        highPrecision: true\n    });\n    const worldspace = lngLatToWorld(lngLatZ);\n    worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n    worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n    const newLngLat = worldToLngLat(worldspace);\n    const newZ = (z0 || 0) + (z || 0);\n    return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\n/**\n *\n * view and projection matrix creation is intentionally kept compatible with\n * mapbox-gl's implementation to ensure that seamless interoperation\n * with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\n */\nexport function getViewMatrix(options) {\n    const { \n    // Viewport props\n    height, pitch, bearing, altitude, \n    // Pre-calculated parameters\n    scale, center } = options;\n    // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES\n    // Note that mercator world coordinates typically need to be flipped\n    //\n    // Note: As usual, matrix operation orders should be read in reverse\n    // since vectors will be multiplied from the right during transformation\n    const vm = createMat4();\n    // Move camera to altitude (along the pitch & bearing direction)\n    mat4.translate(vm, vm, [0, 0, -altitude]);\n    // Rotate by bearing, and then by pitch (which tilts the view)\n    mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n    mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n    const relativeScale = scale / height;\n    mat4.scale(vm, vm, [relativeScale, relativeScale, relativeScale]);\n    if (center) {\n        mat4.translate(vm, vm, vec3.negate([], center));\n    }\n    return vm;\n}\n/**\n * Calculates mapbox compatible projection matrix from parameters\n *\n * @param options.width Width of \"viewport\" or window\n * @param options.height Height of \"viewport\" or window\n * @param options.scale Scale at the current zoom\n * @param options.center Offset of the target, vec3 in world space\n * @param options.offset Offset of the focal point, vec2 in screen space\n * @param options.pitch Camera angle in degrees (0 is straight down)\n * @param options.fovy field of view in degrees\n * @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`\n * @param options.nearZMultiplier control z buffer\n * @param options.farZMultiplier control z buffer\n * @returns project parameters object\n */\nexport function getProjectionParameters(options) {\n    const { width, height, altitude, pitch = 0, offset, center, scale, nearZMultiplier = 1, farZMultiplier = 1 } = options;\n    let { fovy = altitudeToFovy(DEFAULT_ALTITUDE) } = options;\n    // For back-compatibility allow field of view to be\n    // derived from altitude\n    if (altitude !== undefined) {\n        fovy = altitudeToFovy(altitude);\n    }\n    const fovRadians = fovy * DEGREES_TO_RADIANS;\n    const pitchRadians = pitch * DEGREES_TO_RADIANS;\n    // Distance from camera to the target\n    const focalDistance = fovyToAltitude(fovy);\n    let cameraToSeaLevelDistance = focalDistance;\n    if (center) {\n        cameraToSeaLevelDistance += (center[2] * scale) / Math.cos(pitchRadians) / height;\n    }\n    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);\n    // Find the distance from the center point to the center top\n    // in focal distance units using law of sines.\n    const topHalfSurfaceDistance = (Math.sin(fovAboveCenter) * cameraToSeaLevelDistance) /\n        Math.sin(clamp(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));\n    // Calculate z distance of the farthest fragment that should be rendered.\n    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;\n    // Matches mapbox limit\n    const horizonDistance = cameraToSeaLevelDistance * 10;\n    // Calculate z value of the farthest fragment that should be rendered.\n    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);\n    return {\n        fov: fovRadians,\n        aspect: width / height,\n        focalDistance,\n        near: nearZMultiplier,\n        far: farZ\n    };\n}\n/**\n * CALCULATE PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE\n *\n * To match mapbox's z buffer:\n *  - \\<= 0.28: nearZMultiplier: 0.1, farZmultiplier: 1\n *  - \\>= 0.29: nearZMultiplier: 1 / height, farZMultiplier: 1.01\n *\n * @param options Viewport options\n * @param options.width Width of \"viewport\" or window\n * @param options.height Height of \"viewport\" or window\n * @param options.scale Scale at the current zoom\n * @param options.center Offset of the target, vec3 in world space\n * @param options.offset Offset of the focal point, vec2 in screen space\n * @param options.pitch Camera angle in degrees (0 is straight down)\n * @param options.fovy field of view in degrees\n * @param options.altitude if provided, field of view is calculated using `altitudeToFovy()`\n * @param options.nearZMultiplier control z buffer\n * @param options.farZMultiplier control z buffer\n * @returns 4x4 projection matrix\n */\nexport function getProjectionMatrix(options) {\n    const { fov, aspect, near, far } = getProjectionParameters(options);\n    const projectionMatrix = mat4.perspective([], fov, // fov in radians\n    aspect, // aspect ratio\n    near, // near plane\n    far // far plane\n    );\n    return projectionMatrix;\n}\n/**\n *\n * Convert an altitude to field of view such that the\n * focal distance is equal to the altitude\n *\n * @param altitude - altitude of camera in screen units\n * @return fovy field of view in degrees\n */\nexport function altitudeToFovy(altitude) {\n    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\n/**\n *\n * Convert an field of view such that the\n * focal distance is equal to the altitude\n *\n * @param fovy - field of view in degrees\n * @return altitude altitude of camera in screen units\n */\nexport function fovyToAltitude(fovy) {\n    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\n// Project flat coordinates to pixels on screen.\nexport function worldToPixels(xyz, pixelProjectionMatrix) {\n    const [x, y, z = 0] = xyz;\n    assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n    return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\n/**\n * Unproject pixels on screen to flat coordinates.\n *\n * @param xyz - pixel coordinate on screen.\n * @param pixelUnprojectionMatrix - unprojection matrix 4x4\n * @param targetZ - if pixel coordinate does not have a 3rd component (depth),\n *    targetZ is used as the elevation plane to unproject onto\n * @return [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.\n */\nexport function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {\n    const [x, y, z] = xyz;\n    assert(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');\n    if (Number.isFinite(z)) {\n        // Has depth component\n        const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n        return coord;\n    }\n    // since we don't know the correct projected z value for the point,\n    // unproject two points to get a line and then find the point on that line with z=0\n    const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n    const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n    const z0 = coord0[2];\n    const z1 = coord1[2];\n    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n    return vec2.lerp([], coord0, coord1, t);\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || '@math.gl/web-mercator: assertion failed.');\n    }\n}\n", "import { assert } from \"./assert.js\";\nimport { log2, clamp } from \"./math-utils.js\";\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from \"./web-mercator-utils.js\";\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n *\n * > _Note: Only supports non-perspective mode._\n *\n * @param options fit bounds parameters\n * @returns - latitude, longitude and zoom\n */\nexport function fitBounds(options) {\n    const { width, height, bounds, minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n    maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n    offset = [0, 0] } = options;\n    const [[west, south], [east, north]] = bounds;\n    const padding = getPaddingObject(options.padding);\n    const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n    const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n    // width/height on the Web Mercator plane\n    const size = [\n        Math.max(Math.abs(se[0] - nw[0]), minExtent),\n        Math.max(Math.abs(se[1] - nw[1]), minExtent)\n    ];\n    const targetSize = [\n        width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n        height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n    ];\n    assert(targetSize[0] > 0 && targetSize[1] > 0);\n    // scale = screen pixels per unit on the Web Mercator plane\n    const scaleX = targetSize[0] / size[0];\n    const scaleY = targetSize[1] / size[1];\n    // Find how much we need to shift the center\n    const offsetX = (padding.right - padding.left) / 2 / scaleX;\n    const offsetY = (padding.top - padding.bottom) / 2 / scaleY;\n    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n    const centerLngLat = worldToLngLat(center);\n    const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n    assert(Number.isFinite(zoom));\n    return {\n        longitude: centerLngLat[0],\n        latitude: centerLngLat[1],\n        zoom\n    };\n}\n// Helpers\nfunction getPaddingObject(padding = 0) {\n    if (typeof padding === 'number') {\n        return {\n            top: padding,\n            bottom: padding,\n            left: padding,\n            right: padding\n        };\n    }\n    // Make sure all the required properties are set\n    assert(Number.isFinite(padding.top) &&\n        Number.isFinite(padding.bottom) &&\n        Number.isFinite(padding.left) &&\n        Number.isFinite(padding.right));\n    return padding;\n}\n", "/* eslint-disable camelcase */\nimport { vec2 } from '@math.gl/core';\nimport { worldToLngLat } from \"./web-mercator-utils.js\";\nimport { transformVector } from \"./math-utils.js\";\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n/*\n * Returns the quad at the intersection of the frustum and the given z plane\n * @param {WebMercatorViewport} viewport\n * @param {Number} z - elevation in meters\n */\nexport function getBounds(viewport, z = 0) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { width, height, unproject } = viewport;\n    const unprojectOps = { targetZ: z };\n    const bottomLeft = unproject([0, height], unprojectOps);\n    const bottomRight = unproject([width, height], unprojectOps);\n    let topLeft;\n    let topRight;\n    const halfFov = viewport.fovy\n        ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS\n        : Math.atan(0.5 / viewport.altitude);\n    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;\n    // The top plane is parallel to the ground if halfFov == angleToGround\n    if (halfFov > angleToGround - 0.01) {\n        // intersect with the far plane\n        topLeft = unprojectOnFarPlane(viewport, 0, z);\n        topRight = unprojectOnFarPlane(viewport, width, z);\n    }\n    else {\n        // intersect with the top plane\n        topLeft = unproject([0, 0], unprojectOps);\n        topRight = unproject([width, 0], unprojectOps);\n    }\n    return [bottomLeft, bottomRight, topRight, topLeft];\n}\n/*\n * Find a point on the far clipping plane of the viewport\n * @param {WebMercatorViewport} viewport\n * @param {Number} x - projected x in screen space\n * @param {Number} targetZ - the elevation of the point in meters\n */\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n    const { pixelUnprojectionMatrix } = viewport;\n    const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n    const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n    const coord = vec2.lerp([], coord0, coord1, t);\n    const result = worldToLngLat(coord);\n    result.push(targetZ);\n    return result;\n}\n", "// View and Projection Matrix calculations for mapbox-js style map view properties\nimport { createMat4 } from \"./math-utils.js\";\nimport { zoomToScale, pixelsToWorld, lngLatToWorld, worldToLngLat, worldToPixels, altitudeToFovy, fovyToAltitude, DEFAULT_ALTITUDE, getProjectionMatrix, getDistanceScales, getViewMatrix } from \"./web-mercator-utils.js\";\nimport { fitBounds } from \"./fit-bounds.js\";\nimport { getBounds } from \"./get-bounds.js\";\nimport { mat4, vec2, vec3 } from '@math.gl/core';\n/**\n * The WebMercatorViewport class creates\n * - view/projection matrices\n * - \"uniform values\" (for shaders) from mercator params\n *\n * Note: Instances are immutable in the sense that they only have accessors.\n * A new viewport instance should be created if any parameters have changed.\n */\nexport class WebMercatorViewport {\n    /**\n     * @classdesc\n     * Creates view/projection matrices from mercator params\n     * Note: The Viewport is immutable in the sense that it only has accessors.\n     * A new viewport instance should be created if any parameters have changed.\n     */\n    // eslint-disable-next-line max-statements\n    constructor(props = { width: 1, height: 1 }) {\n        /** Two viewports are equal if width and height are identical, and if\n         * their view and projection matrices are (approximately) equal.\n         */\n        this.equals = (viewport) => {\n            if (!(viewport instanceof WebMercatorViewport)) {\n                return false;\n            }\n            return (viewport.width === this.width &&\n                viewport.height === this.height &&\n                mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n                mat4.equals(viewport.viewMatrix, this.viewMatrix));\n        };\n        /**\n         * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n         * using viewport projection parameters\n         * - [longitude, latitude] to [x, y]\n         * - [longitude, latitude, Z] => [x, y, z]\n         * Note: By default, returns top-left coordinates for canvas/SVG type render\n         *\n         * @param lngLatZ - [lng, lat] or [lng, lat, Z]\n         * @param options - options\n         * @param options.topLeft=true - Whether projected coords are top left\n         * @return - screen coordinates [x, y] or [x, y, z], z as pixel depth\n         */\n        this.project = (lngLatZ, options = {}) => {\n            const { topLeft = true } = options;\n            const worldPosition = this.projectPosition(lngLatZ);\n            const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n            const [x, y] = coord;\n            const y2 = topLeft ? y : this.height - y;\n            return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];\n        };\n        /**\n         * Unproject pixel coordinates on screen onto world coordinates, possibly `[lon, lat]` on map.\n         *\n         * - [x, y] => [lng, lat]\n         * - [x, y, z] => [lng, lat, Z]\n         *\n         * @param xyz - screen coordinates, z as pixel depth\n         * @param options - options\n         * @param options.topLeft=true - Whether projected coords are top left\n         * @param options.targetZ=0 - If pixel depth is unknown, targetZ is used as\n         *   the elevation plane to unproject onto\n         * @return - [lng, lat, Z] or [X, Y, Z]\n         */\n        this.unproject = (xyz, options = {}) => {\n            const { topLeft = true, targetZ = undefined } = options;\n            const [x, y, z] = xyz;\n            const y2 = topLeft ? y : this.height - y;\n            const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n            const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n            const [X, Y, Z] = this.unprojectPosition(coord);\n            if (Number.isFinite(z)) {\n                return [X, Y, Z];\n            }\n            return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n        };\n        // NON_LINEAR PROJECTION HOOKS\n        // Used for web meractor projection\n        this.projectPosition = (xyz) => {\n            const [X, Y] = lngLatToWorld(xyz);\n            const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n            return [X, Y, Z];\n        };\n        this.unprojectPosition = (xyz) => {\n            const [X, Y] = worldToLngLat(xyz);\n            const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n            return [X, Y, Z];\n        };\n        let { \n        // Map state\n        width, height, altitude = null, fovy = null } = props;\n        const { latitude = 0, longitude = 0, zoom = 0, pitch = 0, bearing = 0, position = null, nearZMultiplier = 0.02, farZMultiplier = 1.01 } = props;\n        // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n        width = width || 1;\n        height = height || 1;\n        // `fovy` & `altitude` are independent parameters, one for the\n        // projection and the latter for the view matrix. In the past,\n        // the `fovy` was always derived from the `altitude`\n        if (fovy === null && altitude === null) {\n            altitude = DEFAULT_ALTITUDE;\n            fovy = altitudeToFovy(altitude);\n        }\n        else if (fovy === null) {\n            fovy = altitudeToFovy(altitude);\n        }\n        else if (altitude === null) {\n            altitude = fovyToAltitude(fovy);\n        }\n        const scale = zoomToScale(zoom);\n        // Altitude - prevent division by 0\n        // TODO - just throw an Error instead?\n        altitude = Math.max(0.75, altitude);\n        const distanceScales = getDistanceScales({ longitude, latitude });\n        const center = lngLatToWorld([longitude, latitude]);\n        center.push(0);\n        if (position) {\n            vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n        }\n        this.projectionMatrix = getProjectionMatrix({\n            width,\n            height,\n            scale,\n            center,\n            pitch,\n            fovy,\n            nearZMultiplier,\n            farZMultiplier\n        });\n        this.viewMatrix = getViewMatrix({\n            height,\n            scale,\n            center,\n            pitch,\n            bearing,\n            altitude\n        });\n        // Save parameters\n        this.width = width;\n        this.height = height;\n        this.scale = scale;\n        this.latitude = latitude;\n        this.longitude = longitude;\n        this.zoom = zoom;\n        this.pitch = pitch;\n        this.bearing = bearing;\n        this.altitude = altitude;\n        this.fovy = fovy;\n        this.center = center;\n        this.meterOffset = position || [0, 0, 0];\n        this.distanceScales = distanceScales;\n        this._initMatrices();\n        Object.freeze(this);\n    }\n    _initMatrices() {\n        const { width, height, projectionMatrix, viewMatrix } = this;\n        // Note: As usual, matrix operations should be applied in \"reverse\" order\n        // since vectors will be multiplied in from the right during transformation\n        const vpm = createMat4();\n        mat4.multiply(vpm, vpm, projectionMatrix);\n        mat4.multiply(vpm, vpm, viewMatrix);\n        this.viewProjectionMatrix = vpm;\n        // Calculate matrices and scales needed for projection\n        /**\n         * Builds matrices that converts preprojected lngLats to screen pixels\n         * and vice versa.\n         * Note: Currently returns bottom-left coordinates!\n         * Note: Starts with the GL projection matrix and adds steps to the\n         *       scale and translate that matrix onto the window.\n         * Note: WebGL controls clip space to screen projection with gl.viewport\n         *       and does not need this step.\n         */\n        const m = createMat4();\n        // matrix for conversion from location to screen coordinates\n        mat4.scale(m, m, [width / 2, -height / 2, 1]);\n        mat4.translate(m, m, [1, -1, 0]);\n        mat4.multiply(m, m, vpm);\n        const mInverse = mat4.invert(createMat4(), m);\n        if (!mInverse) {\n            throw new Error('Pixel project matrix not invertible');\n        }\n        this.pixelProjectionMatrix = m;\n        this.pixelUnprojectionMatrix = mInverse;\n    }\n    /**\n     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n     * Performs the nonlinear part of the web mercator projection.\n     * Remaining projection is done with 4x4 matrices which also handles\n     * perspective.\n     *\n     * @param lngLat - [lng, lat] coordinates\n     *   Specifies a point on the sphere to project onto the map.\n     * @return [x,y] coordinates.\n     */\n    projectFlat(lngLat) {\n        return lngLatToWorld(lngLat);\n    }\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     *\n     * @param xy - array with [x,y] members\n     *  representing point on projected map plane\n     * @return - array with [lat,lon] of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n    unprojectFlat(xy) {\n        return worldToLngLat(xy);\n    }\n    /**\n     * Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n     * @param opt\n     * @param opt.lngLat - [lng,lat] coordinates\n     *   Specifies a point on the sphere.\n     * @param opt.pos - [x,y] coordinates\n     *   Specifies a point on the screen.\n     * @return [lng,lat] new map center.\n     */\n    getMapCenterByLngLatPosition({ lngLat, pos }) {\n        const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n        const toLocation = lngLatToWorld(lngLat);\n        const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n        const newCenter = vec2.add([], this.center, translate);\n        return worldToLngLat(newCenter);\n    }\n    /**\n     * Returns a new viewport that fit around the given rectangle.\n     * Only supports non-perspective mode.\n     * @param bounds - [[lon, lat], [lon, lat]]\n     * @param [options]\n     * @param [options.padding] - The amount of padding in pixels to add to the given bounds.\n     * @param [options.offset] - The center of the given bounds relative to the map's center,\n     *    [x, y] measured in pixels.\n     * @returns {WebMercatorViewport}\n     */\n    fitBounds(bounds, options = {}) {\n        const { width, height } = this;\n        const { longitude, latitude, zoom } = fitBounds(Object.assign({ width, height, bounds }, options));\n        return new WebMercatorViewport({ width, height, longitude, latitude, zoom });\n    }\n    /**\n     * Returns the bounding box of the viewport.\n     * @param [options]\n     * @param [options.z] - The altitude at which the bounds should be calculated.\n     * @returns {Array} bounds - [[lon, lat], [lon, lat]]\n     */\n    getBounds(options) {\n        const corners = this.getBoundingRegion(options);\n        const west = Math.min(...corners.map((p) => p[0]));\n        const east = Math.max(...corners.map((p) => p[0]));\n        const south = Math.min(...corners.map((p) => p[1]));\n        const north = Math.max(...corners.map((p) => p[1]));\n        return [\n            [west, south],\n            [east, north]\n        ];\n    }\n    /**\n     * Returns the bounding box of the viewport.\n     * @param [options]\n     * @param [options.z] - The altitude at which the bounds should be calculated.\n     * @returns {Array} an array of 4 points that define the visible region\n     */\n    getBoundingRegion(options = {}) {\n        return getBounds(this, options.z || 0);\n    }\n    // DEPRECATED\n    /** @deprecated Legacy method name */\n    getLocationAtPoint({ lngLat, pos }) {\n        return this.getMapCenterByLngLatPosition({ lngLat, pos });\n    }\n}\n", "import { worldToLngLat } from \"./web-mercator-utils.js\";\nimport { mod, log2 } from \"./math-utils.js\";\n// defined by mapbox-gl\nconst TILE_SIZE = 512;\n/**\n * Apply mathematical constraints to viewport props\n * @param props\n */\n// eslint-disable-next-line complexity\nexport function normalizeViewportProps(props) {\n    const { width, height, pitch = 0 } = props;\n    let { longitude, latitude, zoom, bearing = 0 } = props;\n    // Normalize degrees\n    if (longitude < -180 || longitude > 180) {\n        longitude = mod(longitude + 180, 360) - 180;\n    }\n    if (bearing < -180 || bearing > 180) {\n        bearing = mod(bearing + 180, 360) - 180;\n    }\n    // Constrain zoom and shift center at low zoom levels\n    const minZoom = log2(height / TILE_SIZE);\n    if (zoom <= minZoom) {\n        zoom = minZoom;\n        latitude = 0;\n    }\n    else {\n        // Eliminate white space above and below the map\n        const halfHeightPixels = height / 2 / Math.pow(2, zoom);\n        const minLatitude = worldToLngLat([0, halfHeightPixels])[1];\n        if (latitude < minLatitude) {\n            latitude = minLatitude;\n        }\n        else {\n            const maxLatitude = worldToLngLat([0, TILE_SIZE - halfHeightPixels])[1];\n            if (latitude > maxLatitude) {\n                latitude = maxLatitude;\n            }\n        }\n    }\n    return { width, height, longitude, latitude, zoom, pitch, bearing };\n}\n", "import { lerp } from \"./math-utils.js\";\nimport { scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat } from \"./web-mercator-utils.js\";\nimport { vec2 } from '@math.gl/core';\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n    curve: 1.414,\n    speed: 1.2\n    // screenSpeed and maxDuration are used only if specified\n};\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements \u201CSmooth and efficient zooming and panning.\u201D algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport function flyToViewport(startProps, endProps, t, options) {\n    // Equations from above paper are referred where needed.\n    const { startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0 } = getFlyToTransitionParams(startProps, endProps, options);\n    // If change in center is too small, do linear interpolaiton.\n    if (u1 < EPSILON) {\n        const viewport = {};\n        for (const key of VIEWPORT_TRANSITION_PROPS) {\n            const startValue = startProps[key];\n            const endValue = endProps[key];\n            // @ts-ignore-error properties are populated dynamically\n            viewport[key] = lerp(startValue, endValue, t);\n        }\n        // @ts-expect-error properties are populated dynamically\n        return viewport;\n    }\n    const s = t * S;\n    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n    const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n    const scaleIncrement = 1 / w; // Using w method for scaling.\n    const newZoom = startZoom + scaleToZoom(scaleIncrement);\n    const newCenterWorld = vec2.scale([], uDelta, u);\n    vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n    const newCenter = worldToLngLat(newCenterWorld);\n    return {\n        longitude: newCenter[0],\n        latitude: newCenter[1],\n        zoom: newZoom\n    };\n}\n// returns transition duration in milliseconds\nexport function getFlyToDuration(startProps, endProps, options) {\n    const opts = { ...DEFAULT_OPTS, ...options };\n    const { screenSpeed, speed, maxDuration } = opts;\n    const { S, rho } = getFlyToTransitionParams(startProps, endProps, opts);\n    const length = 1000 * S;\n    let duration;\n    if (Number.isFinite(screenSpeed)) {\n        duration = length / (screenSpeed / rho);\n    }\n    else {\n        duration = length / speed;\n    }\n    return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n// Private Methods\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n    opts = Object.assign({}, DEFAULT_OPTS, opts);\n    const rho = opts.curve;\n    const startZoom = startProps.zoom;\n    const startCenter = [startProps.longitude, startProps.latitude];\n    const startScale = zoomToScale(startZoom);\n    const endZoom = endProps.zoom;\n    const endCenter = [endProps.longitude, endProps.latitude];\n    const scale = zoomToScale(endZoom - startZoom);\n    const startCenterXY = lngLatToWorld(startCenter);\n    const endCenterXY = lngLatToWorld(endCenter);\n    const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n    const w0 = Math.max(startProps.width, startProps.height);\n    const w1 = w0 / scale;\n    const u1 = vec2.length(uDelta) * startScale;\n    // u0 is treated as '0' in Eq (9).\n    // If u1 is too small, will generate invalid number\n    const _u1 = Math.max(u1, EPSILON);\n    // Implement Equation (9) from above algorithm.\n    const rho2 = rho * rho;\n    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n    const S = (r1 - r0) / rho;\n    return { startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1 };\n}\n"],
  "mappings": "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",
  "names": ["import_core", "unitsPerMeter", "unitsPerMeter2", "import_core", "DEGREES_TO_RADIANS", "import_core", "TILE_SIZE", "import_core"]
}
