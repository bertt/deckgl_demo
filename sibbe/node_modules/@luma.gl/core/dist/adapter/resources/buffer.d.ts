import type { Device } from "../device.js";
import { Resource, ResourceProps } from "./resource.js";
export type BufferProps = ResourceProps & {
    /** Supply a handle to connect to an existing device-specific buffer */
    handle?: WebGLBuffer;
    /** Specifies how this buffer can be used */
    usage?: number;
    /** Length in bytes of memory to be allocated. If not specified, `byteLength` of  `props.data` will be used. */
    byteLength?: number;
    /** Data to initialize the buffer with. */
    data?: ArrayBuffer | ArrayBufferView | null;
    /** Byte offset into the newly created Buffer to store data at */
    byteOffset?: number;
    /** If props.usage includes Buffer.INDEX */
    indexType?: 'uint16' | 'uint32';
    mappedAtCreation?: boolean;
};
/** Abstract GPU buffer */
export declare abstract class Buffer extends Resource<BufferProps> {
    static defaultProps: Required<BufferProps>;
    static MAP_READ: number;
    static MAP_WRITE: number;
    static COPY_SRC: number;
    static COPY_DST: number;
    /** Index buffer */
    static INDEX: number;
    /** Vertex buffer */
    static VERTEX: number;
    /** Uniform buffer */
    static UNIFORM: number;
    /** Storage buffer */
    static STORAGE: number;
    static INDIRECT: number;
    static QUERY_RESOLVE: number;
    get [Symbol.toStringTag](): string;
    /** The usage with which this buffer was created */
    readonly usage: number;
    /** For index buffers, whether indices are 16 or 32 bit */
    readonly indexType?: 'uint16' | 'uint32';
    /** Length of buffer in bytes */
    abstract byteLength: number;
    /** "Time" of last update */
    updateTimestamp: number;
    constructor(device: Device, props: BufferProps);
    /** Write data to buffer */
    abstract write(data: ArrayBufferView, byteOffset?: number): void;
    /** Read data asynchronously */
    abstract readAsync(byteOffset?: number, byteLength?: number): Promise<Uint8Array>;
    /** Read data synchronously. @note WebGL2 only */
    readSyncWebGL(byteOffset?: number, byteLength?: number): Uint8Array;
    /** Max amount of debug data saved. Two vec4's */
    static DEBUG_DATA_MAX_LENGTH: number;
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    debugData: ArrayBuffer;
    /** This doesn't handle partial non-zero offset updates correctly */
    protected _setDebugData(data: ArrayBufferView | ArrayBuffer | null, byteOffset: number, byteLength: number): void;
}
//# sourceMappingURL=buffer.d.ts.map