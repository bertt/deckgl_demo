// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { Resource } from "./resource.js";
/** Abstract GPU buffer */
export class Buffer extends Resource {
    static defaultProps = {
        ...Resource.defaultProps,
        usage: 0, // Buffer.COPY_DST | Buffer.COPY_SRC
        byteLength: 0,
        byteOffset: 0,
        data: null,
        indexType: 'uint16',
        mappedAtCreation: false
    };
    // Usage Flags
    static MAP_READ = 0x01;
    static MAP_WRITE = 0x02;
    static COPY_SRC = 0x0004;
    static COPY_DST = 0x0008;
    /** Index buffer */
    static INDEX = 0x0010;
    /** Vertex buffer */
    static VERTEX = 0x0020;
    /** Uniform buffer */
    static UNIFORM = 0x0040;
    /** Storage buffer */
    static STORAGE = 0x0080;
    static INDIRECT = 0x0100;
    static QUERY_RESOLVE = 0x0200;
    get [Symbol.toStringTag]() {
        return 'Buffer';
    }
    /** The usage with which this buffer was created */
    usage;
    /** For index buffers, whether indices are 16 or 32 bit */
    indexType;
    /** "Time" of last update */
    updateTimestamp;
    constructor(device, props) {
        const deducedProps = { ...props };
        // Deduce indexType
        if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
            if (props.data instanceof Uint32Array) {
                deducedProps.indexType = 'uint32';
            }
            else if (props.data instanceof Uint16Array) {
                deducedProps.indexType = 'uint16';
            }
        }
        super(device, deducedProps, Buffer.defaultProps);
        this.usage = props.usage || 0;
        this.indexType = deducedProps.indexType;
        // TODO - perhaps this should be set on async write completion?
        this.updateTimestamp = device.incrementTimestamp();
    }
    /** Read data synchronously. @note WebGL2 only */
    readSyncWebGL(byteOffset, byteLength) {
        throw new Error('not implemented');
    }
    // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
    /** Max amount of debug data saved. Two vec4's */
    static DEBUG_DATA_MAX_LENGTH = 32;
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    debugData = new ArrayBuffer(0);
    /** This doesn't handle partial non-zero offset updates correctly */
    _setDebugData(data, byteOffset, byteLength) {
        const buffer = ArrayBuffer.isView(data) ? data.buffer : data;
        const debugDataLength = Math.min(data ? data.byteLength : byteLength, Buffer.DEBUG_DATA_MAX_LENGTH);
        if (data === null) {
            this.debugData = new ArrayBuffer(debugDataLength);
        }
        else if (byteOffset === 0 && byteLength === data.byteLength) {
            this.debugData = buffer.slice(0, debugDataLength);
        }
        else {
            this.debugData = buffer.slice(byteOffset, byteOffset + debugDataLength);
        }
    }
}
