// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { VERSION } from "../init.js";
import { lumaStats } from "../utils/stats-manager.js";
import { log } from "../utils/log.js";
import { uid } from "../utils/utils.js";
import { Buffer } from "./resources/buffer.js";
import { isTextureFormatCompressed } from "./type-utils/decode-texture-format.js";
/** Limits for a device (max supported sizes of resources, max number of bindings etc) */
export class DeviceLimits {
}
/** Set-like class for features (lets apps check for WebGL / WebGPU extensions) */
export class DeviceFeatures {
    features;
    disabledFeatures;
    constructor(features = [], disabledFeatures) {
        this.features = new Set(features);
        this.disabledFeatures = disabledFeatures || {};
    }
    *[Symbol.iterator]() {
        yield* this.features;
    }
    has(feature) {
        return !this.disabledFeatures[feature] && this.features.has(feature);
    }
}
/**
 * WebGPU Device/WebGL context abstraction
 */
export class Device {
    static defaultProps = {
        id: null,
        canvas: null,
        container: null,
        manageState: true,
        width: 800, // width are height are only used by headless gl
        height: 600,
        requestMaxLimits: true,
        debug: Boolean(log.get('debug')), // Instrument context (at the expense of performance)
        spector: Boolean(log.get('spector')), // Initialize the SpectorJS WebGL debugger
        break: [],
        // TODO - Change these after confirming things work as expected
        initalizeFeatures: true,
        disabledFeatures: {
            'compilation-status-async-webgl': true
        },
        // alpha: undefined,
        // depth: undefined,
        // stencil: undefined,
        // antialias: undefined,
        // premultipliedAlpha: undefined,
        // preserveDrawingBuffer: undefined,
        // failIfMajorPerformanceCaveat: undefined
        gl: null,
        // Callbacks
        onError: (error) => log.error(error.message)
    };
    get [Symbol.toStringTag]() {
        return 'Device';
    }
    static VERSION = VERSION;
    constructor(props) {
        this.props = { ...Device.defaultProps, ...props };
        this.id = this.props.id || uid(this[Symbol.toStringTag].toLowerCase());
    }
    /** id of this device, primarily for debugging */
    id;
    /** A copy of the device props  */
    props;
    /** Available for the application to store data on the device */
    userData = {};
    /** stats */
    statsManager = lumaStats;
    /** Used by other luma.gl modules to store data on the device */
    _lumaData = {};
    /** Check if a specific texture format is GPU compressed */
    isTextureFormatCompressed(format) {
        return isTextureFormatCompressed(format);
    }
    /**
     * Trigger device loss.
     * @returns `true` if context loss could actually be triggered.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice() {
        return false;
    }
    /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
    getCanvasContext() {
        if (!this.canvasContext) {
            throw new Error('Device has no CanvasContext');
        }
        return this.canvasContext;
    }
    createTexture(props) {
        // Signature: new Texture2D(gl, url | Promise)
        if (props instanceof Promise || typeof props === 'string') {
            props = { data: props };
        }
        return this._createTexture(props);
    }
    createCommandEncoder(props = {}) {
        throw new Error('not implemented');
    }
    // WebGL specific HACKS - enables app to remove webgl import
    // Use until we have a better way to handle these
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToArrayWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use command encoder */
    readPixelsToBufferWebGL(source, options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    setParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    getParametersWebGL(parameters) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
    withParametersWebGL(parameters, func) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use clear arguments in RenderPass */
    clearWebGL(options) {
        throw new Error('not implemented');
    }
    /** @deprecated - will be removed - should use for debugging only */
    resetWebGL() {
        throw new Error('not implemented');
    }
    timestamp = 0;
    /** A monotonic counter for tracking buffer and texture updates */
    incrementTimestamp() {
        return this.timestamp++;
    }
    // Error Handling
    /** Report unhandled device errors */
    onError(error) {
        this.props.onError(error);
    }
    // IMPLEMENTATION
    _getBufferProps(props) {
        if (props instanceof ArrayBuffer || ArrayBuffer.isView(props)) {
            props = { data: props };
        }
        // TODO - fragile, as this is done before we merge with default options
        // inside the Buffer constructor
        const newProps = { ...props };
        // Deduce indexType
        if ((props.usage || 0) & Buffer.INDEX && !props.indexType) {
            if (props.data instanceof Uint32Array) {
                newProps.indexType = 'uint32';
            }
            else if (props.data instanceof Uint16Array) {
                newProps.indexType = 'uint16';
            }
            else {
                log.warn('indices buffer content must be of integer type')();
            }
        }
        return newProps;
    }
}
