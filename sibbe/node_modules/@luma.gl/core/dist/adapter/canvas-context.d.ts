import type { Device } from "./device.js";
import type { Framebuffer } from "./resources/framebuffer.js";
/** Properties for a CanvasContext */
export type CanvasContextProps = {
    /** If canvas not supplied, will be created and added to the DOM. If string, will be looked up in the DOM */
    canvas?: HTMLCanvasElement | OffscreenCanvas | string | null;
    /** If new canvas is created, it will be created in the specified container, otherwise appended to body */
    container?: HTMLElement | string | null;
    /** Width in pixels of the canvas */
    width?: number;
    /** Height in pixels of the canvas */
    height?: number;
    /** Whether to apply a device pixels scale factor (`true` uses browser DPI) */
    useDevicePixels?: boolean | number;
    /** Whether to track resizes (if not ) */
    autoResize?: boolean;
    /** Visibility (only used if new canvas is created). */
    visible?: boolean;
    /** WebGPU only https://www.w3.org/TR/webgpu/#canvas-configuration */
    colorSpace?: 'srgb';
    /** WebGPU only https://www.w3.org/TR/webgpu/#canvas-configuration */
    alphaMode?: 'opaque' | 'premultiplied';
};
/**
 * Manages a canvas. Supports both HTML or offscreen canvas
 * - Creates a new canvas or looks up a canvas from the DOM
 * - Provides check for DOM loaded
 * @todo commit(): https://github.com/w3ctag/design-reviews/issues/288
 * @todo transferControlToOffscreen: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen
 */
export declare abstract class CanvasContext {
    abstract readonly device: Device;
    readonly id: string;
    readonly props: Required<CanvasContextProps>;
    readonly canvas: HTMLCanvasElement | OffscreenCanvas;
    readonly htmlCanvas?: HTMLCanvasElement;
    readonly offscreenCanvas?: OffscreenCanvas;
    readonly type: 'html-canvas' | 'offscreen-canvas' | 'node';
    width: number;
    height: number;
    readonly resizeObserver: ResizeObserver | undefined;
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    readonly _canvasSizeInfo: {
        clientWidth: number;
        clientHeight: number;
        devicePixelRatio: number;
    };
    /** Check if the DOM is loaded */
    static get isPageLoaded(): boolean;
    /**
     * Get a 'lazy' promise that resolves when the DOM is loaded.
     * @note Since there may be limitations on number of `load` event listeners,
     * it is recommended avoid calling this function until actually needed.
     * I.e. don't call it until you know that you will be looking up a string in the DOM.
     */
    static pageLoaded: Promise<void>;
    constructor(props?: CanvasContextProps);
    /** Returns a framebuffer with properly resized current 'swap chain' textures */
    abstract getCurrentFramebuffer(): Framebuffer;
    /**
     * Returns the current DPR, if props.useDevicePixels is true
     * Device refers to physical
     */
    getDevicePixelRatio(useDevicePixels?: boolean | number): number;
    /**
     * Returns the size of drawing buffer in device pixels.
     * @note This can be different from the 'CSS' size of a canvas, and also from the
     * canvas' internal drawing buffer size (.width, .height).
     * This is the size required to cover the canvas, adjusted for DPR
     */
    getPixelSize(): [number, number];
    getAspect(): number;
    /**
     * Returns multiplier need to convert CSS size to Device size
     */
    cssToDeviceRatio(): number;
    /**
     * Maps CSS pixel position to device pixel position
     */
    cssToDevicePixels(cssPixel: number[], yInvert?: boolean): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    /**
     * Use devicePixelRatio to set canvas width and height
     * @note this is a raw port of luma.gl v8 code. Might be worth a review
     */
    setDevicePixelRatio(devicePixelRatio: number, options?: {
        width?: number;
        height?: number;
    }): void;
    /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
    getDrawingBufferSize(): [number, number];
    abstract resize(options?: {
        width?: number;
        height?: number;
        useDevicePixels?: boolean | number;
    }): void;
    /** Perform platform specific updates (WebGPU vs WebGL) */
    protected abstract update(): void;
    /**
     * Allows subclass constructor to override the canvas id for auto created canvases.
     * This can really help when debugging DOM in apps that create multiple devices
     */
    protected _setAutoCreatedCanvasId(id: string): void;
}
//# sourceMappingURL=canvas-context.d.ts.map