// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { Device } from "../adapter/device.js";
import { lumaStats } from "../utils/stats-manager.js";
import { log } from "../utils/log.js";
import { assert } from "../utils/assert.js";
const deviceMap = new Map();
/**
 * Entry point to the luma.gl GPU abstraction
 * Register WebGPU and/or WebGL devices (controls application bundle size)
 * Run-time selection of the first available Device
 */
export class luma {
    static defaultProps = {
        ...Device.defaultProps,
        type: 'best-available',
        devices: undefined
    };
    /** Global stats for all devices */
    static stats = lumaStats;
    /** Global log */
    static log = log;
    static registerDevices(deviceClasses /* : typeof Device */) {
        for (const deviceClass of deviceClasses) {
            assert(deviceClass.type && deviceClass.isSupported && deviceClass.create);
            deviceMap.set(deviceClass.type, deviceClass);
        }
    }
    static getAvailableDevices() {
        // @ts-expect-error
        return Array.from(deviceMap).map(Device => Device.type);
    }
    static getSupportedDevices() {
        return (Array.from(deviceMap)
            // @ts-expect-error
            .filter(Device => Device.isSupported())
            // @ts-expect-error
            .map(Device => Device.type));
    }
    static setDefaultDeviceProps(props) {
        Object.assign(Device.defaultProps, props);
    }
    /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
    static async attachDevice(props) {
        const devices = getDeviceMap(props.devices) || deviceMap;
        // WebGL
        if (props.handle instanceof WebGL2RenderingContext) {
            const WebGLDevice = devices.get('webgl');
            if (WebGLDevice) {
                return (await WebGLDevice.attach(props.handle));
            }
        }
        // TODO - WebGPU does not yet have a stable API
        // if (props.handle instanceof GPUDevice) {
        //   const WebGPUDevice = devices.get('webgpu') as any;
        //   if (WebGPUDevice) {
        //     return (await WebGPUDevice.attach(props.handle)) as Device;
        //   }
        // }
        // null
        if (props.handle === null) {
            const UnknownDevice = devices.get('unknown');
            if (UnknownDevice) {
                return (await UnknownDevice.attach(null));
            }
        }
        throw new Error('Failed to attach device. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.');
    }
    /** Creates a device. Asynchronously. */
    static async createDevice(props = {}) {
        props = { ...Device.defaultProps, ...props };
        if (props.gl) {
            props.type = 'webgl';
        }
        const devices = getDeviceMap(props.devices) || deviceMap;
        switch (props.type) {
            case 'webgpu':
                let WebGPUDevice = devices.get('webgpu');
                if (WebGPUDevice) {
                    return await WebGPUDevice.create(props);
                }
                break;
            case 'webgl':
                let WebGLDevice = devices.get('webgl');
                if (WebGLDevice) {
                    return await WebGLDevice.create(props);
                }
                break;
            case 'unknown':
                const UnknownDevice = devices.get('unknown');
                if (UnknownDevice) {
                    return await UnknownDevice.create(props);
                }
                break;
            case 'best-available':
                WebGPUDevice = devices.get('webgpu');
                if (WebGPUDevice?.isSupported?.()) {
                    return await WebGPUDevice.create(props);
                }
                WebGLDevice = devices.get('webgl');
                if (WebGLDevice?.isSupported?.()) {
                    return await WebGLDevice.create(props);
                }
                break;
        }
        throw new Error('No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.');
    }
}
/** Convert a list of devices to a map */
function getDeviceMap(deviceClasses /* : typeof Device */) {
    if (!deviceClasses || deviceClasses?.length === 0) {
        return null;
    }
    const map = new Map();
    for (const deviceClass of deviceClasses) {
        // assert(deviceClass.type && deviceClass.isSupported && deviceClass.create);
        map.set(deviceClass.type, deviceClass);
    }
    return map;
}
