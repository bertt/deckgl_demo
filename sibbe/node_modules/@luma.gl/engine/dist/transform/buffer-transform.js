// luma.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
import { Buffer, assert } from '@luma.gl/core';
import { getPassthroughFS } from '@luma.gl/shadertools';
import { Model } from "../model/model.js";
/**
 * Creates a pipeline for bufferâ†’buffer transforms.
 * @deprecated
 */
export class BufferTransform {
    device;
    model;
    transformFeedback;
    /** @deprecated Use device feature test. */
    static isSupported(device) {
        return device?.info?.type === 'webgl';
    }
    constructor(device, props = Model.defaultProps) {
        assert(BufferTransform.isSupported(device), 'BufferTransform not yet implemented on WebGPU');
        this.device = device;
        this.model = new Model(this.device, {
            id: props.id || 'buffer-transform-model',
            fs: props.fs || getPassthroughFS(),
            topology: props.topology || 'point-list',
            ...props
        });
        this.transformFeedback = this.device.createTransformFeedback({
            layout: this.model.pipeline.shaderLayout,
            buffers: props.feedbackBuffers
        });
        this.model.setTransformFeedback(this.transformFeedback);
        Object.seal(this);
    }
    /** Destroy owned resources. */
    destroy() {
        if (this.model) {
            this.model.destroy();
        }
    }
    /** @deprecated Use {@link destroy}. */
    delete() {
        this.destroy();
    }
    /** Run one transform loop. */
    run(options) {
        const renderPass = this.device.beginRenderPass(options);
        this.model.draw(renderPass);
        renderPass.end();
    }
    /** @deprecated */
    update(...args) {
        // TODO(v9): Method should likely be removed for v9. Keeping a method stub
        // to assist with migrating DeckGL usage.
        // eslint-disable-next-line no-console
        console.warn('TextureTransform#update() not implemented');
    }
    /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
    getBuffer(varyingName) {
        return this.transformFeedback.getBuffer(varyingName);
    }
    readAsync(varyingName) {
        const result = this.getBuffer(varyingName);
        if (result instanceof Buffer) {
            return result.readAsync();
        }
        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;
        return buffer.readAsync(byteOffset, byteLength);
    }
}
