{
  "version": 3,
  "sources": ["index.js", "animation/timeline.js", "animation/key-frames.js", "animation-loop/animation-loop-template.js", "animation-loop/animation-loop.js", "animation-loop/make-animation-loop.js", "model/model.js", "geometry/gpu-geometry.js", "shader-inputs.js", "lib/pipeline-factory.js", "lib/shader-factory.js", "debug/debug-shader-layout.js", "debug/debug-framebuffer.js", "transform/buffer-transform.js", "transform/texture-transform.js", "lib/clip-space.js", "geometry/geometry.js", "scenegraph/scenegraph-node.js", "scenegraph/group-node.js", "scenegraph/model-node.js", "geometries/cone-geometry.js", "geometries/truncated-cone-geometry.js", "geometries/cube-geometry.js", "geometries/cylinder-geometry.js", "geometries/ico-sphere-geometry.js", "geometries/plane-geometry.js", "geometry/geometry-utils.js", "geometries/sphere-geometry.js", "computation.js"],
  "sourcesContent": ["// luma.gl Engine API\n// Animation\nexport { Timeline } from \"./animation/timeline.js\";\nexport { KeyFrames } from \"./animation/key-frames.js\";\nexport { AnimationLoopTemplate } from \"./animation-loop/animation-loop-template.js\";\nexport { AnimationLoop } from \"./animation-loop/animation-loop.js\";\nexport { makeAnimationLoop } from \"./animation-loop/make-animation-loop.js\";\nexport { Model } from \"./model/model.js\";\nexport { BufferTransform } from \"./transform/buffer-transform.js\";\nexport { TextureTransform } from \"./transform/texture-transform.js\";\nexport { PipelineFactory } from \"./lib/pipeline-factory.js\";\nexport { ShaderFactory } from \"./lib/shader-factory.js\";\n// Utils\nexport { ClipSpace } from \"./lib/clip-space.js\";\n// Scenegraph Core nodes\nexport { ScenegraphNode } from \"./scenegraph/scenegraph-node.js\";\nexport { GroupNode } from \"./scenegraph/group-node.js\";\nexport { ModelNode } from \"./scenegraph/model-node.js\";\nexport { Geometry } from \"./geometry/geometry.js\";\nexport { GPUGeometry } from \"./geometry/gpu-geometry.js\";\nexport { ConeGeometry } from \"./geometries/cone-geometry.js\";\nexport { CubeGeometry } from \"./geometries/cube-geometry.js\";\nexport { CylinderGeometry } from \"./geometries/cylinder-geometry.js\";\nexport { IcoSphereGeometry } from \"./geometries/ico-sphere-geometry.js\";\nexport { PlaneGeometry } from \"./geometries/plane-geometry.js\";\nexport { SphereGeometry } from \"./geometries/sphere-geometry.js\";\nexport { TruncatedConeGeometry } from \"./geometries/truncated-cone-geometry.js\";\nexport { ShaderInputs as _ShaderInputs } from \"./shader-inputs.js\";\nexport { Computation } from \"./computation.js\";\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nlet channelHandles = 1;\nlet animationHandles = 1;\nexport class Timeline {\n    time = 0;\n    channels = new Map();\n    animations = new Map();\n    playing = false;\n    lastEngineTime = -1;\n    constructor() { }\n    addChannel(props) {\n        const { delay = 0, duration = Number.POSITIVE_INFINITY, rate = 1, repeat = 1 } = props;\n        const channelId = channelHandles++;\n        const channel = {\n            time: 0,\n            delay,\n            duration,\n            rate,\n            repeat\n        };\n        this._setChannelTime(channel, this.time);\n        this.channels.set(channelId, channel);\n        return channelId;\n    }\n    removeChannel(channelId) {\n        this.channels.delete(channelId);\n        for (const [animationHandle, animation] of this.animations) {\n            if (animation.channel === channelId) {\n                this.detachAnimation(animationHandle);\n            }\n        }\n    }\n    isFinished(channelId) {\n        const channel = this.channels.get(channelId);\n        if (channel === undefined) {\n            return false;\n        }\n        return this.time >= channel.delay + channel.duration * channel.repeat;\n    }\n    getTime(channelId) {\n        if (channelId === undefined) {\n            return this.time;\n        }\n        const channel = this.channels.get(channelId);\n        if (channel === undefined) {\n            return -1;\n        }\n        return channel.time;\n    }\n    setTime(time) {\n        this.time = Math.max(0, time);\n        const channels = this.channels.values();\n        for (const channel of channels) {\n            this._setChannelTime(channel, this.time);\n        }\n        const animations = this.animations.values();\n        for (const animationData of animations) {\n            const { animation, channel } = animationData;\n            animation.setTime(this.getTime(channel));\n        }\n    }\n    play() {\n        this.playing = true;\n    }\n    pause() {\n        this.playing = false;\n        this.lastEngineTime = -1;\n    }\n    reset() {\n        this.setTime(0);\n    }\n    attachAnimation(animation, channelHandle) {\n        const animationHandle = animationHandles++;\n        this.animations.set(animationHandle, {\n            animation,\n            channel: channelHandle\n        });\n        animation.setTime(this.getTime(channelHandle));\n        return animationHandle;\n    }\n    detachAnimation(channelId) {\n        this.animations.delete(channelId);\n    }\n    update(engineTime) {\n        if (this.playing) {\n            if (this.lastEngineTime === -1) {\n                this.lastEngineTime = engineTime;\n            }\n            this.setTime(this.time + (engineTime - this.lastEngineTime));\n            this.lastEngineTime = engineTime;\n        }\n    }\n    _setChannelTime(channel, time) {\n        const offsetTime = time - channel.delay;\n        const totalDuration = channel.duration * channel.repeat;\n        // Note(Tarek): Don't loop on final repeat.\n        if (offsetTime >= totalDuration) {\n            channel.time = channel.duration * channel.rate;\n        }\n        else {\n            channel.time = Math.max(0, offsetTime) % channel.duration;\n            channel.time *= channel.rate;\n        }\n    }\n}\n", "/** Holds a list of key frames (timestamped values) */\nexport class KeyFrames {\n    startIndex = -1;\n    endIndex = -1;\n    factor = 0;\n    times = [];\n    values = [];\n    _lastTime = -1;\n    constructor(keyFrames) {\n        this.setKeyFrames(keyFrames);\n        this.setTime(0);\n    }\n    setKeyFrames(keyFrames) {\n        const numKeys = keyFrames.length;\n        this.times.length = numKeys;\n        this.values.length = numKeys;\n        for (let i = 0; i < numKeys; ++i) {\n            this.times[i] = keyFrames[i][0];\n            this.values[i] = keyFrames[i][1];\n        }\n        this._calculateKeys(this._lastTime);\n    }\n    setTime(time) {\n        time = Math.max(0, time);\n        if (time !== this._lastTime) {\n            this._calculateKeys(time);\n            this._lastTime = time;\n        }\n    }\n    getStartTime() {\n        return this.times[this.startIndex];\n    }\n    getEndTime() {\n        return this.times[this.endIndex];\n    }\n    getStartData() {\n        return this.values[this.startIndex];\n    }\n    getEndData() {\n        return this.values[this.endIndex];\n    }\n    _calculateKeys(time) {\n        let index = 0;\n        const numKeys = this.times.length;\n        for (index = 0; index < numKeys - 2; ++index) {\n            if (this.times[index + 1] > time) {\n                break;\n            }\n        }\n        this.startIndex = index;\n        this.endIndex = index + 1;\n        const startTime = this.times[this.startIndex];\n        const endTime = this.times[this.endIndex];\n        this.factor = Math.min(Math.max(0, (time - startTime) / (endTime - startTime)), 1);\n    }\n}\n", "/**\n * Minimal class that represents a \"componentized\" rendering life cycle\n * (resource construction, repeated rendering, resource destruction)\n *\n * @note A motivation for this class compared to the raw animation loop is\n * that it simplifies TypeScript code by allowing resources to be typed unconditionally\n * since they are allocated in the constructor rather than in onInitialized\n *\n * @note Introduced in luma.gl v9\n *\n * @example AnimationLoopTemplate is intended to be subclassed,\n * but the subclass should not be instantiated directly. Instead the subclass\n * (i.e. the constructor of the subclass) should be used\n * as an argument to create an AnimationLoop.\n */\nexport class AnimationLoopTemplate {\n    constructor(animationProps) { }\n    async onInitialize(animationProps) {\n        return null;\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { luma } from '@luma.gl/core';\nimport { requestAnimationFrame, cancelAnimationFrame } from '@luma.gl/core';\nimport { Stats } from '@probe.gl/stats';\nlet statIdCounter = 0;\nconst DEFAULT_ANIMATION_LOOP_PROPS = {\n    device: null,\n    onAddHTML: () => '',\n    onInitialize: async () => {\n        return null;\n    },\n    onRender: () => { },\n    onFinalize: () => { },\n    onError: error => console.error(error), // eslint-disable-line no-console\n    stats: luma.stats.get(`animation-loop-${statIdCounter++}`),\n    // view parameters\n    useDevicePixels: true,\n    autoResizeViewport: false,\n    autoResizeDrawingBuffer: false\n};\n/** Convenient animation loop */\nexport class AnimationLoop {\n    device = null;\n    canvas = null;\n    props;\n    animationProps = null;\n    timeline = null;\n    stats;\n    cpuTime;\n    gpuTime;\n    frameRate;\n    display;\n    needsRedraw = 'initialized';\n    _initialized = false;\n    _running = false;\n    _animationFrameId = null;\n    _nextFramePromise = null;\n    _resolveNextFrame = null;\n    _cpuStartTime = 0;\n    // _gpuTimeQuery: Query | null = null;\n    /*\n     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n     */\n    constructor(props) {\n        this.props = { ...DEFAULT_ANIMATION_LOOP_PROPS, ...props };\n        props = this.props;\n        if (!props.device) {\n            throw new Error('No device provided');\n        }\n        const { useDevicePixels = true } = this.props;\n        // state\n        this.stats = props.stats || new Stats({ id: 'animation-loop-stats' });\n        this.cpuTime = this.stats.get('CPU Time');\n        this.gpuTime = this.stats.get('GPU Time');\n        this.frameRate = this.stats.get('Frame Rate');\n        this.setProps({\n            autoResizeViewport: props.autoResizeViewport,\n            autoResizeDrawingBuffer: props.autoResizeDrawingBuffer,\n            useDevicePixels\n        });\n        // Bind methods\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        this._onMousemove = this._onMousemove.bind(this);\n        this._onMouseleave = this._onMouseleave.bind(this);\n    }\n    destroy() {\n        this.stop();\n        this._setDisplay(null);\n    }\n    /** @deprecated Use .destroy() */\n    delete() {\n        this.destroy();\n    }\n    /** Flags this animation loop as needing redraw */\n    setNeedsRedraw(reason) {\n        this.needsRedraw = this.needsRedraw || reason;\n        return this;\n    }\n    /** TODO - move these props to CanvasContext? */\n    setProps(props) {\n        if ('autoResizeViewport' in props) {\n            this.props.autoResizeViewport = props.autoResizeViewport || false;\n        }\n        if ('autoResizeDrawingBuffer' in props) {\n            this.props.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer || false;\n        }\n        if ('useDevicePixels' in props) {\n            this.props.useDevicePixels = props.useDevicePixels || false;\n        }\n        return this;\n    }\n    /** Starts a render loop if not already running */\n    async start() {\n        if (this._running) {\n            return this;\n        }\n        this._running = true;\n        try {\n            let appContext;\n            if (!this._initialized) {\n                this._initialized = true;\n                // Create the WebGL context\n                await this._initDevice();\n                this._initialize();\n                // Note: onIntialize can return a promise (e.g. in case app needs to load resources)\n                await this.props.onInitialize(this._getAnimationProps());\n            }\n            // check that we haven't been stopped\n            if (!this._running) {\n                return null;\n            }\n            // Start the loop\n            if (appContext !== false) {\n                // cancel any pending renders to ensure only one loop can ever run\n                this._cancelAnimationFrame();\n                this._requestAnimationFrame();\n            }\n            return this;\n        }\n        catch (err) {\n            const error = err instanceof Error ? err : new Error('Unknown error');\n            this.props.onError(error);\n            // this._running = false; // TODO\n            throw error;\n        }\n    }\n    /** Stops a render loop if already running, finalizing */\n    stop() {\n        // console.debug(`Stopping ${this.constructor.name}`);\n        if (this._running) {\n            // call callback\n            // If stop is called immediately, we can end up in a state where props haven't been initialized...\n            if (this.animationProps) {\n                this.props.onFinalize(this.animationProps);\n            }\n            this._cancelAnimationFrame();\n            this._nextFramePromise = null;\n            this._resolveNextFrame = null;\n            this._running = false;\n        }\n        return this;\n    }\n    /** Explicitly draw a frame */\n    redraw() {\n        if (this.device?.isLost) {\n            return this;\n        }\n        this._beginFrameTimers();\n        this._setupFrame();\n        this._updateAnimationProps();\n        this._renderFrame(this._getAnimationProps());\n        // clear needsRedraw flag\n        this._clearNeedsRedraw();\n        if (this._resolveNextFrame) {\n            this._resolveNextFrame(this);\n            this._nextFramePromise = null;\n            this._resolveNextFrame = null;\n        }\n        this._endFrameTimers();\n        return this;\n    }\n    /** Add a timeline, it will be automatically updated by the animation loop. */\n    attachTimeline(timeline) {\n        this.timeline = timeline;\n        return this.timeline;\n    }\n    /** Remove a timeline */\n    detachTimeline() {\n        this.timeline = null;\n    }\n    /** Wait until a render completes */\n    waitForRender() {\n        this.setNeedsRedraw('waitForRender');\n        if (!this._nextFramePromise) {\n            this._nextFramePromise = new Promise(resolve => {\n                this._resolveNextFrame = resolve;\n            });\n        }\n        return this._nextFramePromise;\n    }\n    /** TODO - should use device.deviceContext */\n    async toDataURL() {\n        this.setNeedsRedraw('toDataURL');\n        await this.waitForRender();\n        if (this.canvas instanceof HTMLCanvasElement) {\n            return this.canvas.toDataURL();\n        }\n        throw new Error('OffscreenCanvas');\n    }\n    // PRIVATE METHODS\n    _initialize() {\n        this._startEventHandling();\n        // Initialize the callback data\n        this._initializeAnimationProps();\n        this._updateAnimationProps();\n        // Default viewport setup, in case onInitialize wants to render\n        this._resizeCanvasDrawingBuffer();\n        this._resizeViewport();\n        // this._gpuTimeQuery = Query.isSupported(this.gl, ['timers']) ? new Query(this.gl) : null;\n    }\n    _setDisplay(display) {\n        if (this.display) {\n            this.display.destroy();\n            this.display.animationLoop = null;\n        }\n        // store animation loop on the display\n        if (display) {\n            display.animationLoop = this;\n        }\n        this.display = display;\n    }\n    _requestAnimationFrame() {\n        if (!this._running) {\n            return;\n        }\n        // VR display has a separate animation frame to sync with headset\n        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n        // if (this.display && this.display.requestAnimationFrame) {\n        //   this._animationFrameId = this.display.requestAnimationFrame(this._animationFrame.bind(this));\n        // }\n        this._animationFrameId = requestAnimationFrame(this._animationFrame.bind(this));\n    }\n    _cancelAnimationFrame() {\n        if (this._animationFrameId === null) {\n            return;\n        }\n        // VR display has a separate animation frame to sync with headset\n        // TODO WebVR API discontinued, replaced by WebXR: https://immersive-web.github.io/webxr/\n        // See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestAnimationFrame\n        // if (this.display && this.display.cancelAnimationFrame) {\n        //   this.display.cancelAnimationFrame(this._animationFrameId);\n        // }\n        cancelAnimationFrame(this._animationFrameId);\n        this._animationFrameId = null;\n    }\n    _animationFrame() {\n        if (!this._running) {\n            return;\n        }\n        this.redraw();\n        this._requestAnimationFrame();\n    }\n    // Called on each frame, can be overridden to call onRender multiple times\n    // to support e.g. stereoscopic rendering\n    _renderFrame(animationProps) {\n        // Allow e.g. VR display to render multiple frames.\n        if (this.display) {\n            this.display._renderFrame(animationProps);\n            return;\n        }\n        // call callback\n        this.props.onRender(this._getAnimationProps());\n        // end callback\n        // Submit commands (necessary on WebGPU)\n        this.device.submit();\n    }\n    _clearNeedsRedraw() {\n        this.needsRedraw = false;\n    }\n    _setupFrame() {\n        this._resizeCanvasDrawingBuffer();\n        this._resizeViewport();\n    }\n    // Initialize the  object that will be passed to app callbacks\n    _initializeAnimationProps() {\n        if (!this.device) {\n            throw new Error('loop');\n        }\n        this.animationProps = {\n            animationLoop: this,\n            device: this.device,\n            canvas: this.device?.canvasContext?.canvas,\n            timeline: this.timeline,\n            // Initial values\n            useDevicePixels: this.props.useDevicePixels,\n            needsRedraw: false,\n            // Placeholders\n            width: 1,\n            height: 1,\n            aspect: 1,\n            // Animation props\n            time: 0,\n            startTime: Date.now(),\n            engineTime: 0,\n            tick: 0,\n            tock: 0,\n            // Experimental\n            _mousePosition: null // Event props\n        };\n    }\n    _getAnimationProps() {\n        if (!this.animationProps) {\n            throw new Error('animationProps');\n        }\n        return this.animationProps;\n    }\n    // Update the context object that will be passed to app callbacks\n    _updateAnimationProps() {\n        if (!this.animationProps) {\n            return;\n        }\n        // Can this be replaced with canvas context?\n        const { width, height, aspect } = this._getSizeAndAspect();\n        if (width !== this.animationProps.width || height !== this.animationProps.height) {\n            this.setNeedsRedraw('drawing buffer resized');\n        }\n        if (aspect !== this.animationProps.aspect) {\n            this.setNeedsRedraw('drawing buffer aspect changed');\n        }\n        this.animationProps.width = width;\n        this.animationProps.height = height;\n        this.animationProps.aspect = aspect;\n        this.animationProps.needsRedraw = this.needsRedraw;\n        // Update time properties\n        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;\n        if (this.timeline) {\n            this.timeline.update(this.animationProps.engineTime);\n        }\n        this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);\n        this.animationProps.tock++;\n        // For back compatibility\n        this.animationProps.time = this.timeline\n            ? this.timeline.getTime()\n            : this.animationProps.engineTime;\n    }\n    /** Wait for supplied device */\n    async _initDevice() {\n        this.device = await this.props.device;\n        if (!this.device) {\n            throw new Error('No device provided');\n        }\n        this.canvas = this.device.canvasContext?.canvas || null;\n        // this._createInfoDiv();\n    }\n    _createInfoDiv() {\n        if (this.canvas && this.props.onAddHTML) {\n            const wrapperDiv = document.createElement('div');\n            document.body.appendChild(wrapperDiv);\n            wrapperDiv.style.position = 'relative';\n            const div = document.createElement('div');\n            div.style.position = 'absolute';\n            div.style.left = '10px';\n            div.style.bottom = '10px';\n            div.style.width = '300px';\n            div.style.background = 'white';\n            if (this.canvas instanceof HTMLCanvasElement) {\n                wrapperDiv.appendChild(this.canvas);\n            }\n            wrapperDiv.appendChild(div);\n            const html = this.props.onAddHTML(div);\n            if (html) {\n                div.innerHTML = html;\n            }\n        }\n    }\n    _getSizeAndAspect() {\n        if (!this.device) {\n            return { width: 1, height: 1, aspect: 1 };\n        }\n        // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n        const [width, height] = this.device?.canvasContext?.getPixelSize() || [1, 1];\n        // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html\n        let aspect = 1;\n        const canvas = this.device?.canvasContext?.canvas;\n        // @ts-expect-error\n        if (canvas && canvas.clientHeight) {\n            // @ts-expect-error\n            aspect = canvas.clientWidth / canvas.clientHeight;\n        }\n        else if (width > 0 && height > 0) {\n            aspect = width / height;\n        }\n        return { width, height, aspect };\n    }\n    /** Default viewport setup */\n    _resizeViewport() {\n        // TODO can we use canvas context to code this in a portable way?\n        // @ts-expect-error Expose on canvasContext\n        if (this.props.autoResizeViewport && this.device.gl) {\n            // @ts-expect-error Expose canvasContext\n            this.device.gl.viewport(0, 0, \n            // @ts-expect-error Expose canvasContext\n            this.device.gl.drawingBufferWidth, \n            // @ts-expect-error Expose canvasContext\n            this.device.gl.drawingBufferHeight);\n        }\n    }\n    /**\n     * Resize the render buffer of the canvas to match canvas client size\n     * Optionally multiplying with devicePixel ratio\n     */\n    _resizeCanvasDrawingBuffer() {\n        if (this.props.autoResizeDrawingBuffer) {\n            this.device?.canvasContext?.resize({ useDevicePixels: this.props.useDevicePixels });\n        }\n    }\n    _beginFrameTimers() {\n        this.frameRate.timeEnd();\n        this.frameRate.timeStart();\n        // Check if timer for last frame has completed.\n        // GPU timer results are never available in the same\n        // frame they are captured.\n        // if (\n        //   this._gpuTimeQuery &&\n        //   this._gpuTimeQuery.isResultAvailable() &&\n        //   !this._gpuTimeQuery.isTimerDisjoint()\n        // ) {\n        //   this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());\n        // }\n        // if (this._gpuTimeQuery) {\n        //   // GPU time query start\n        //   this._gpuTimeQuery.beginTimeElapsedQuery();\n        // }\n        this.cpuTime.timeStart();\n    }\n    _endFrameTimers() {\n        this.cpuTime.timeEnd();\n        // if (this._gpuTimeQuery) {\n        //   // GPU time query end. Results will be available on next frame.\n        //   this._gpuTimeQuery.end();\n        // }\n    }\n    // Event handling\n    _startEventHandling() {\n        if (this.canvas) {\n            this.canvas.addEventListener('mousemove', this._onMousemove.bind(this));\n            this.canvas.addEventListener('mouseleave', this._onMouseleave.bind(this));\n        }\n    }\n    _onMousemove(event) {\n        if (event instanceof MouseEvent) {\n            this._getAnimationProps()._mousePosition = [event.offsetX, event.offsetY];\n        }\n    }\n    _onMouseleave(event) {\n        this._getAnimationProps()._mousePosition = null;\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { luma } from '@luma.gl/core';\nimport { AnimationLoop } from \"./animation-loop.js\";\n/** Instantiates and runs the render loop */\nexport function makeAnimationLoop(AnimationLoopTemplateCtor, props) {\n    let renderLoop = null;\n    const device = props?.device || luma.createDevice();\n    // Create an animation loop;\n    const animationLoop = new AnimationLoop({\n        ...props,\n        device,\n        async onInitialize(animationProps) {\n            // @ts-expect-error abstract to prevent instantiation\n            renderLoop = new AnimationLoopTemplateCtor(animationProps);\n            // Any async loading can be handled here\n            return await renderLoop?.onInitialize(animationProps);\n        },\n        onRender: (animationProps) => renderLoop?.onRender(animationProps),\n        onFinalize: (animationProps) => renderLoop?.onFinalize(animationProps)\n    });\n    // @ts-expect-error Hack: adds info for the website to find\n    animationLoop.getInfo = () => {\n        // @ts-ignore\n        // eslint-disable-next-line no-invalid-this\n        return this.AnimationLoopTemplateCtor.info;\n    };\n    // Start the loop automatically\n    // animationLoop.start();\n    return animationLoop;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, Texture, TextureView, Sampler } from '@luma.gl/core';\nimport { RenderPipeline, UniformStore } from '@luma.gl/core';\nimport { log, uid, deepEqual, isObjectEmpty, splitUniformsAndBindings } from '@luma.gl/core';\nimport { getTypedArrayFromDataType, getAttributeInfosFromLayouts } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { makeGPUGeometry } from \"../geometry/gpu-geometry.js\";\nimport { ShaderInputs } from \"../shader-inputs.js\";\nimport { PipelineFactory } from \"../lib/pipeline-factory.js\";\nimport { ShaderFactory } from \"../lib/shader-factory.js\";\nimport { getDebugTableForShaderLayout } from \"../debug/debug-shader-layout.js\";\nimport { debugFramebuffer } from \"../debug/debug-framebuffer.js\";\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Model {\n    static defaultProps = {\n        ...RenderPipeline.defaultProps,\n        source: null,\n        vs: null,\n        fs: null,\n        id: 'unnamed',\n        handle: undefined,\n        userData: {},\n        defines: {},\n        modules: [],\n        moduleSettings: undefined,\n        geometry: null,\n        indexBuffer: null,\n        attributes: {},\n        constantAttributes: {},\n        varyings: [],\n        shaderInputs: undefined,\n        pipelineFactory: undefined,\n        shaderFactory: undefined,\n        transformFeedback: undefined,\n        shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n        debugShaders: undefined,\n        disableWarnings: undefined\n    };\n    device;\n    id;\n    source;\n    vs;\n    fs;\n    pipelineFactory;\n    shaderFactory;\n    userData = {};\n    // Fixed properties (change can trigger pipeline rebuild)\n    /** The render pipeline GPU parameters, depth testing etc */\n    parameters;\n    /** The primitive topology */\n    topology;\n    /** Buffer layout */\n    bufferLayout;\n    // Dynamic properties\n    /** Vertex count */\n    vertexCount;\n    /** instance count */\n    instanceCount = 0;\n    /** Index buffer */\n    indexBuffer = null;\n    /** Buffer-valued attributes */\n    bufferAttributes = {};\n    /** Constant-valued attributes */\n    constantAttributes = {};\n    /** Bindings (textures, samplers, uniform buffers) */\n    bindings = {};\n    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/\n    uniforms = {};\n    /**\n     * VertexArray\n     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!\n     * @todo - allow application to define multiple vertex arrays?\n     * */\n    vertexArray;\n    /** TransformFeedback, WebGL 2 only. */\n    transformFeedback = null;\n    /** The underlying GPU \"program\". @note May be recreated if parameters change */\n    pipeline;\n    /** ShaderInputs instance */\n    shaderInputs;\n    _uniformStore;\n    _attributeInfos = {};\n    _gpuGeometry = null;\n    _getModuleUniforms;\n    props;\n    _pipelineNeedsUpdate = 'newly created';\n    _needsRedraw = 'initializing';\n    _destroyed = false;\n    /** \"Time\" of last draw. Monotonically increasing timestamp */\n    _lastDrawTimestamp = -1;\n    constructor(device, props) {\n        this.props = { ...Model.defaultProps, ...props };\n        props = this.props;\n        this.id = props.id || uid('model');\n        this.device = device;\n        Object.assign(this.userData, props.userData);\n        // Setup shader module inputs\n        const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n        this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));\n        // Setup shader assembler\n        const platformInfo = getPlatformInfo(device);\n        // Extract modules from shader inputs if not supplied\n        const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n        const isWebGPU = this.device.type === 'webgpu';\n        // WebGPU\n        // TODO - hack to support unified WGSL shader\n        // TODO - this is wrong, compile a single shader\n        if (isWebGPU && this.props.source) {\n            // WGSL\n            this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n            const { source, getUniforms } = this.props.shaderAssembler.assembleShader({\n                platformInfo,\n                ...this.props,\n                modules\n            });\n            this.source = source;\n            this._getModuleUniforms = getUniforms;\n        }\n        else {\n            // GLSL\n            const { vs, fs, getUniforms } = this.props.shaderAssembler.assembleShaderPair({\n                platformInfo,\n                ...this.props,\n                modules\n            });\n            this.vs = vs;\n            this.fs = fs;\n            this._getModuleUniforms = getUniforms;\n        }\n        this.vertexCount = this.props.vertexCount;\n        this.instanceCount = this.props.instanceCount;\n        this.topology = this.props.topology;\n        this.bufferLayout = this.props.bufferLayout;\n        this.parameters = this.props.parameters;\n        // Geometry, if provided, sets topology and vertex cound\n        if (props.geometry) {\n            this.setGeometry(props.geometry);\n        }\n        this.pipelineFactory =\n            props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n        this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n        // Create the pipeline\n        // @note order is important\n        this.pipeline = this._updatePipeline();\n        this.vertexArray = device.createVertexArray({\n            renderPipeline: this.pipeline\n        });\n        // Now we can apply geometry attributes\n        if (this._gpuGeometry) {\n            this._setGeometryAttributes(this._gpuGeometry);\n        }\n        // Apply any dynamic settings that will not trigger pipeline change\n        if (props.vertexCount) {\n            this.setVertexCount(props.vertexCount);\n        }\n        if (props.instanceCount) {\n            this.setInstanceCount(props.instanceCount);\n        }\n        if (props.indexBuffer) {\n            this.setIndexBuffer(props.indexBuffer);\n        }\n        if (props.attributes) {\n            this.setAttributes(props.attributes);\n        }\n        if (props.constantAttributes) {\n            this.setConstantAttributes(props.constantAttributes);\n        }\n        if (props.bindings) {\n            this.setBindings(props.bindings);\n        }\n        if (props.uniforms) {\n            this.setUniforms(props.uniforms);\n        }\n        if (props.moduleSettings) {\n            // log.warn('Model.props.moduleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n            this.updateModuleSettings(props.moduleSettings);\n        }\n        if (props.transformFeedback) {\n            this.transformFeedback = props.transformFeedback;\n        }\n        // Catch any access to non-standard props\n        Object.seal(this);\n    }\n    destroy() {\n        if (this._destroyed)\n            return;\n        this.pipelineFactory.release(this.pipeline);\n        this.shaderFactory.release(this.pipeline.vs);\n        if (this.pipeline.fs) {\n            this.shaderFactory.release(this.pipeline.fs);\n        }\n        this._uniformStore.destroy();\n        // TODO - mark resource as managed and destroyIfManaged() ?\n        this._gpuGeometry?.destroy();\n        this._destroyed = true;\n    }\n    // Draw call\n    /** Query redraw status. Clears the status. */\n    needsRedraw() {\n        // Catch any writes to already bound resources\n        if (this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp) {\n            this.setNeedsRedraw('contents of bound textures or buffers updated');\n        }\n        const needsRedraw = this._needsRedraw;\n        this._needsRedraw = false;\n        return needsRedraw;\n    }\n    /** Mark the model as needing a redraw */\n    setNeedsRedraw(reason) {\n        this._needsRedraw ||= reason;\n    }\n    predraw() {\n        // Update uniform buffers if needed\n        this.updateShaderInputs();\n        // Check if the pipeline is invalidated\n        this.pipeline = this._updatePipeline();\n    }\n    draw(renderPass) {\n        this.predraw();\n        let drawSuccess;\n        try {\n            this._logDrawCallStart();\n            // Update the pipeline if invalidated\n            // TODO - inside RenderPass is likely the worst place to do this from performance perspective.\n            // Application can call Model.predraw() to avoid this.\n            this.pipeline = this._updatePipeline();\n            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n            // Any caching needs to be done inside the pipeline functions\n            this.pipeline.setBindings(this.bindings, { disableWarnings: this.props.disableWarnings });\n            if (!isObjectEmpty(this.uniforms)) {\n                this.pipeline.setUniformsWebGL(this.uniforms);\n            }\n            const { indexBuffer } = this.vertexArray;\n            const indexCount = indexBuffer\n                ? indexBuffer.byteLength / (indexBuffer.indexType === 'uint32' ? 4 : 2)\n                : undefined;\n            drawSuccess = this.pipeline.draw({\n                renderPass,\n                vertexArray: this.vertexArray,\n                vertexCount: this.vertexCount,\n                instanceCount: this.instanceCount,\n                indexCount,\n                transformFeedback: this.transformFeedback || undefined,\n                // WebGL shares underlying cached pipelines even for models that have different parameters and topology,\n                // so we must provide our unique parameters to each draw\n                // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)\n                parameters: this.parameters,\n                topology: this.topology\n            });\n        }\n        finally {\n            this._logDrawCallEnd();\n        }\n        this._logFramebuffer(renderPass);\n        // Update needsRedraw flag\n        if (drawSuccess) {\n            this._lastDrawTimestamp = this.device.timestamp;\n            this._needsRedraw = false;\n        }\n        else {\n            this._needsRedraw = 'waiting for resource initialization';\n        }\n        return drawSuccess;\n    }\n    // Update fixed fields (can trigger pipeline rebuild)\n    /**\n     * Updates the optional geometry\n     * Geometry, set topology and bufferLayout\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    setGeometry(geometry) {\n        this._gpuGeometry?.destroy();\n        const gpuGeometry = geometry && makeGPUGeometry(this.device, geometry);\n        if (gpuGeometry) {\n            this.setTopology(gpuGeometry.topology || 'triangle-list');\n            this.bufferLayout = mergeBufferLayouts(gpuGeometry.bufferLayout, this.bufferLayout);\n            if (this.vertexArray) {\n                this._setGeometryAttributes(gpuGeometry);\n            }\n        }\n        this._gpuGeometry = gpuGeometry;\n    }\n    /**\n     * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).\n     * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    setTopology(topology) {\n        if (topology !== this.topology) {\n            this.topology = topology;\n            this._setPipelineNeedsUpdate('topology');\n        }\n    }\n    /**\n     * Updates the buffer layout.\n     * @note Triggers a pipeline rebuild / pipeline cache fetch\n     */\n    setBufferLayout(bufferLayout) {\n        this.bufferLayout = this._gpuGeometry\n            ? mergeBufferLayouts(bufferLayout, this._gpuGeometry.bufferLayout)\n            : bufferLayout;\n        this._setPipelineNeedsUpdate('bufferLayout');\n        // Recreate the pipeline\n        this.pipeline = this._updatePipeline();\n        // vertex array needs to be updated if we update buffer layout,\n        // but not if we update parameters\n        this.vertexArray = this.device.createVertexArray({\n            renderPipeline: this.pipeline\n        });\n        // Reapply geometry attributes to the new vertex array\n        if (this._gpuGeometry) {\n            this._setGeometryAttributes(this._gpuGeometry);\n        }\n    }\n    /**\n     * Set GPU parameters.\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch.\n     * @param parameters\n     */\n    setParameters(parameters) {\n        if (!deepEqual(parameters, this.parameters, 2)) {\n            this.parameters = parameters;\n            this._setPipelineNeedsUpdate('parameters');\n        }\n    }\n    // Update dynamic fields\n    /**\n     * Updates the vertex count (used in draw calls)\n     * @note Any attributes with stepMode=vertex need to be at least this big\n     */\n    setVertexCount(vertexCount) {\n        this.vertexCount = vertexCount;\n        this.setNeedsRedraw('vertexCount');\n    }\n    /**\n     * Updates the instance count (used in draw calls)\n     * @note Any attributes with stepMode=instance need to be at least this big\n     */\n    setInstanceCount(instanceCount) {\n        this.instanceCount = instanceCount;\n        this.setNeedsRedraw('instanceCount');\n    }\n    setShaderInputs(shaderInputs) {\n        this.shaderInputs = shaderInputs;\n        this._uniformStore = new UniformStore(this.shaderInputs.modules);\n        // Create uniform buffer bindings for all modules\n        for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n            const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n            this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n        }\n        this.setNeedsRedraw('shaderInputs');\n    }\n    updateShaderInputs() {\n        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n        // TODO - this is already tracked through buffer/texture update times?\n        this.setNeedsRedraw('shaderInputs');\n    }\n    /**\n     * Sets bindings (textures, samplers, uniform buffers)\n     */\n    setBindings(bindings) {\n        Object.assign(this.bindings, bindings);\n        this.setNeedsRedraw('bindings');\n    }\n    /**\n     * Updates optional transform feedback. WebGL only.\n     */\n    setTransformFeedback(transformFeedback) {\n        this.transformFeedback = transformFeedback;\n        this.setNeedsRedraw('transformFeedback');\n    }\n    /**\n     * Sets the index buffer\n     * @todo - how to unset it if we change geometry?\n     */\n    setIndexBuffer(indexBuffer) {\n        this.vertexArray.setIndexBuffer(indexBuffer);\n        this.setNeedsRedraw('indexBuffer');\n    }\n    /**\n     * Sets attributes (buffers)\n     * @note Overrides any attributes previously set with the same name\n     */\n    setAttributes(buffers, options) {\n        if (buffers.indices) {\n            log.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();\n        }\n        for (const [bufferName, buffer] of Object.entries(buffers)) {\n            const bufferLayout = this.bufferLayout.find(layout => getAttributeNames(layout).includes(bufferName));\n            if (!bufferLayout) {\n                log.warn(`Model(${this.id}): Missing layout for buffer \"${bufferName}\".`)();\n                continue; // eslint-disable-line no-continue\n            }\n            // For an interleaved attribute we may need to set multiple attributes\n            const attributeNames = getAttributeNames(bufferLayout);\n            let set = false;\n            for (const attributeName of attributeNames) {\n                const attributeInfo = this._attributeInfos[attributeName];\n                if (attributeInfo) {\n                    this.vertexArray.setBuffer(attributeInfo.location, buffer);\n                    set = true;\n                }\n            }\n            if (!set && !(options?.disableWarnings ?? this.props.disableWarnings)) {\n                log.warn(`Model(${this.id}): Ignoring buffer \"${buffer.id}\" for unknown attribute \"${bufferName}\"`)();\n            }\n        }\n        this.setNeedsRedraw('attributes');\n    }\n    /**\n     * Sets constant attributes\n     * @note Overrides any attributes previously set with the same name\n     * Constant attributes are only supported in WebGL, not in WebGPU\n     * Any attribute that is disabled in the current vertex array object\n     * is read from the context's global constant value for that attribute location.\n     * @param constantAttributes\n     */\n    setConstantAttributes(attributes, options) {\n        for (const [attributeName, value] of Object.entries(attributes)) {\n            const attributeInfo = this._attributeInfos[attributeName];\n            if (attributeInfo) {\n                this.vertexArray.setConstantWebGL(attributeInfo.location, value);\n            }\n            else if (!(options?.disableWarnings ?? this.props.disableWarnings)) {\n                log.warn(`Model \"${this.id}: Ignoring constant supplied for unknown attribute \"${attributeName}\"`)();\n            }\n        }\n        this.setNeedsRedraw('constants');\n    }\n    // DEPRECATED METHODS\n    /**\n     * Sets individual uniforms\n     * @deprecated WebGL only, use uniform buffers for portability\n     * @param uniforms\n     */\n    setUniforms(uniforms) {\n        if (!isObjectEmpty(uniforms)) {\n            this.pipeline.setUniformsWebGL(uniforms);\n            Object.assign(this.uniforms, uniforms);\n        }\n        this.setNeedsRedraw('uniforms');\n    }\n    /**\n     * @deprecated Updates shader module settings (which results in uniforms being set)\n     */\n    updateModuleSettings(props) {\n        // log.warn('Model.updateModuleSettings is deprecated. Use Model.shaderInputs.setProps()')();\n        const { bindings, uniforms } = splitUniformsAndBindings(this._getModuleUniforms(props));\n        Object.assign(this.bindings, bindings);\n        Object.assign(this.uniforms, uniforms);\n        this.setNeedsRedraw('moduleSettings');\n    }\n    // Internal methods\n    /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */\n    _getBindingsUpdateTimestamp() {\n        let timestamp = 0;\n        for (const binding of Object.values(this.bindings)) {\n            if (binding instanceof TextureView) {\n                timestamp = Math.max(timestamp, binding.texture.updateTimestamp);\n            }\n            else if (binding instanceof Buffer || binding instanceof Texture) {\n                timestamp = Math.max(timestamp, binding.updateTimestamp);\n            }\n            else if (!(binding instanceof Sampler)) {\n                timestamp = Math.max(timestamp, binding.buffer.updateTimestamp);\n            }\n        }\n        return timestamp;\n    }\n    /**\n     * Updates the optional geometry attributes\n     * Geometry, sets several attributes, indexBuffer, and also vertex count\n     * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU\n     */\n    _setGeometryAttributes(gpuGeometry) {\n        // Filter geometry attribute so that we don't issue warnings for unused attributes\n        const attributes = { ...gpuGeometry.attributes };\n        for (const [attributeName] of Object.entries(attributes)) {\n            if (!this.pipeline.shaderLayout.attributes.find(layout => layout.name === attributeName) &&\n                attributeName !== 'positions') {\n                delete attributes[attributeName];\n            }\n        }\n        // TODO - delete previous geometry?\n        this.vertexCount = gpuGeometry.vertexCount;\n        this.setIndexBuffer(gpuGeometry.indices || null);\n        this.setAttributes(gpuGeometry.attributes, { disableWarnings: true });\n        this.setAttributes(attributes, { disableWarnings: this.props.disableWarnings });\n        this.setNeedsRedraw('geometry attributes');\n    }\n    /** Mark pipeline as needing update */\n    _setPipelineNeedsUpdate(reason) {\n        this._pipelineNeedsUpdate ||= reason;\n        this.setNeedsRedraw(reason);\n    }\n    /** Update pipeline if needed */\n    _updatePipeline() {\n        if (this._pipelineNeedsUpdate) {\n            let prevShaderVs = null;\n            let prevShaderFs = null;\n            if (this.pipeline) {\n                log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n                prevShaderVs = this.pipeline.vs;\n                prevShaderFs = this.pipeline.fs;\n            }\n            this._pipelineNeedsUpdate = false;\n            const vs = this.shaderFactory.createShader({\n                id: `${this.id}-vertex`,\n                stage: 'vertex',\n                source: this.source || this.vs,\n                debug: this.props.debugShaders\n            });\n            let fs = null;\n            if (this.source) {\n                fs = vs;\n            }\n            else if (this.fs) {\n                fs = this.shaderFactory.createShader({\n                    id: `${this.id}-fragment`,\n                    stage: 'fragment',\n                    source: this.source || this.fs,\n                    debug: this.props.debugShaders\n                });\n            }\n            this.pipeline = this.pipelineFactory.createRenderPipeline({\n                ...this.props,\n                bufferLayout: this.bufferLayout,\n                topology: this.topology,\n                parameters: this.parameters,\n                vs,\n                fs\n            });\n            this._attributeInfos = getAttributeInfosFromLayouts(this.pipeline.shaderLayout, this.bufferLayout);\n            if (prevShaderVs)\n                this.shaderFactory.release(prevShaderVs);\n            if (prevShaderFs)\n                this.shaderFactory.release(prevShaderFs);\n        }\n        return this.pipeline;\n    }\n    /** Throttle draw call logging */\n    _lastLogTime = 0;\n    _logOpen = false;\n    _logDrawCallStart() {\n        // IF level is 4 or higher, log every frame.\n        const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n        if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n            return;\n        }\n        this._lastLogTime = Date.now();\n        this._logOpen = true;\n        log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();\n    }\n    _logDrawCallEnd() {\n        if (this._logOpen) {\n            const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.shaderLayout, this.id);\n            // log.table(logLevel, attributeTable)();\n            // log.table(logLevel, uniformTable)();\n            log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n            const uniformTable = this.shaderInputs.getDebugTable();\n            // Add any global uniforms\n            for (const [name, value] of Object.entries(this.uniforms)) {\n                uniformTable[name] = { value };\n            }\n            log.table(LOG_DRAW_PRIORITY, uniformTable)();\n            const attributeTable = this._getAttributeDebugTable();\n            log.table(LOG_DRAW_PRIORITY, this._attributeInfos)();\n            log.table(LOG_DRAW_PRIORITY, attributeTable)();\n            log.groupEnd(LOG_DRAW_PRIORITY)();\n            this._logOpen = false;\n        }\n    }\n    _drawCount = 0;\n    _logFramebuffer(renderPass) {\n        const debugFramebuffers = log.get('framebuffer');\n        this._drawCount++;\n        // Update first 3 frames and then every 60 frames\n        if (!debugFramebuffers || (this._drawCount++ > 3 && this._drawCount % 60)) {\n            return;\n        }\n        // TODO - display framebuffer output in debug window\n        const framebuffer = renderPass.props.framebuffer;\n        if (framebuffer) {\n            debugFramebuffer(framebuffer, { id: framebuffer.id, minimap: true });\n            // log.image({logLevel: LOG_DRAW_PRIORITY, message: `${framebuffer.id} %c sup?`, image})();\n        }\n    }\n    _getAttributeDebugTable() {\n        const table = {};\n        for (const [name, attributeInfo] of Object.entries(this._attributeInfos)) {\n            table[attributeInfo.location] = {\n                name,\n                type: attributeInfo.shaderType,\n                values: this._getBufferOrConstantValues(this.vertexArray.attributes[attributeInfo.location], attributeInfo.bufferDataType)\n            };\n        }\n        if (this.vertexArray.indexBuffer) {\n            const { indexBuffer } = this.vertexArray;\n            const values = indexBuffer.indexType === 'uint32'\n                ? new Uint32Array(indexBuffer.debugData)\n                : new Uint16Array(indexBuffer.debugData);\n            table.indices = {\n                name: 'indices',\n                type: indexBuffer.indexType,\n                values: values.toString()\n            };\n        }\n        return table;\n    }\n    // TODO - fix typing of luma data types\n    _getBufferOrConstantValues(attribute, dataType) {\n        const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n        const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n        return typedArray.toString();\n    }\n}\n// HELPERS\n/** TODO - move to core, document add tests */\nfunction mergeBufferLayouts(layouts1, layouts2) {\n    const layouts = [...layouts1];\n    for (const attribute of layouts2) {\n        const index = layouts.findIndex(attribute2 => attribute2.name === attribute.name);\n        if (index < 0) {\n            layouts.push(attribute);\n        }\n        else {\n            layouts[index] = attribute;\n        }\n    }\n    return layouts;\n}\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n    return {\n        type: device.type,\n        shaderLanguage: device.info.shadingLanguage,\n        shaderLanguageVersion: device.info.shadingLanguageVersion,\n        gpu: device.info.gpu,\n        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n        features: device.features\n    };\n}\n/** Get attribute names from a BufferLayout */\nfunction getAttributeNames(bufferLayout) {\n    return bufferLayout.attributes\n        ? bufferLayout.attributes?.map(layout => layout.attribute)\n        : [bufferLayout.name];\n}\n", "import { Buffer, uid, assert, getVertexFormatFromAttribute } from '@luma.gl/core';\nexport class GPUGeometry {\n    id;\n    userData = {};\n    /** Determines how vertices are read from the 'vertex' attributes */\n    topology;\n    bufferLayout = [];\n    vertexCount;\n    indices;\n    attributes;\n    constructor(props) {\n        this.id = props.id || uid('geometry');\n        this.topology = props.topology;\n        this.indices = props.indices || null;\n        this.attributes = props.attributes;\n        this.vertexCount = props.vertexCount;\n        this.bufferLayout = props.bufferLayout || [];\n        if (this.indices) {\n            assert(this.indices.usage === Buffer.INDEX);\n        }\n    }\n    destroy() {\n        this.indices?.destroy();\n        for (const attribute of Object.values(this.attributes)) {\n            attribute.destroy();\n        }\n    }\n    getVertexCount() {\n        return this.vertexCount;\n    }\n    getAttributes() {\n        return this.attributes;\n    }\n    getIndexes() {\n        return this.indices;\n    }\n    _calculateVertexCount(positions) {\n        // Assume that positions is a fully packed float32x3 buffer\n        const vertexCount = positions.byteLength / 12;\n        return vertexCount;\n    }\n}\nexport function makeGPUGeometry(device, geometry) {\n    if (geometry instanceof GPUGeometry) {\n        return geometry;\n    }\n    const indices = getIndexBufferFromGeometry(device, geometry);\n    const { attributes, bufferLayout } = getAttributeBuffersFromGeometry(device, geometry);\n    return new GPUGeometry({\n        topology: geometry.topology || 'triangle-list',\n        bufferLayout,\n        vertexCount: geometry.vertexCount,\n        indices,\n        attributes\n    });\n}\nexport function getIndexBufferFromGeometry(device, geometry) {\n    if (!geometry.indices) {\n        return undefined;\n    }\n    const data = geometry.indices.value;\n    return device.createBuffer({ usage: Buffer.INDEX, data });\n}\nexport function getAttributeBuffersFromGeometry(device, geometry) {\n    const bufferLayout = [];\n    const attributes = {};\n    for (const [attributeName, attribute] of Object.entries(geometry.attributes)) {\n        let name = attributeName;\n        // TODO Map some GLTF attribute names (is this still needed?)\n        switch (attributeName) {\n            case 'POSITION':\n                name = 'positions';\n                break;\n            case 'NORMAL':\n                name = 'normals';\n                break;\n            case 'TEXCOORD_0':\n                name = 'texCoords';\n                break;\n            case 'COLOR_0':\n                name = 'colors';\n                break;\n        }\n        attributes[name] = device.createBuffer({ data: attribute.value, id: `${attributeName}-buffer` });\n        const { value, size, normalized } = attribute;\n        bufferLayout.push({ name, format: getVertexFormatFromAttribute(value, size, normalized) });\n    }\n    const vertexCount = geometry._calculateVertexCount(geometry.attributes, geometry.indices);\n    return { attributes, bufferLayout, vertexCount };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\n// import type {ShaderUniformType, UniformValue, UniformFormat, UniformInfoDevice, Texture, Sampler} from '@luma.gl/core';\nimport { _resolveModules } from '@luma.gl/shadertools';\n/**\n * ShaderInputs holds uniform and binding values for one or more shader modules,\n * - It can generate binary data for any uniform buffer\n * - It can manage a uniform buffer for each block\n * - It can update managed uniform buffers with a single call\n * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.\n */\nexport class ShaderInputs {\n    /**\n     * The map of modules\n     * @todo should should this include the resolved dependencies?\n     */\n    modules;\n    /** Stores the uniform values for each module */\n    moduleUniforms;\n    /** Stores the uniform bindings for each module  */\n    moduleBindings;\n    /** Tracks if uniforms have changed */\n    moduleUniformsChanged;\n    /**\n     * Create a new UniformStore instance\n     * @param modules\n     */\n    constructor(modules) {\n        // TODO - get all dependencies from modules\n        const allModules = _resolveModules(Object.values(modules));\n        log.log(1, 'Creating ShaderInputs with modules', allModules.map(m => m.name))();\n        // Store the module definitions and create storage for uniform values and binding values, per module\n        this.modules = modules;\n        this.moduleUniforms = {};\n        this.moduleBindings = {};\n        // Initialize the modules\n        for (const [name, module] of Object.entries(modules)) {\n            const moduleName = name;\n            // Get default uniforms from module\n            this.moduleUniforms[moduleName] = module.defaultUniforms || {};\n            this.moduleBindings[moduleName] = {};\n        }\n    }\n    /** Destroy */\n    destroy() { }\n    /**\n     * Set module props\n     */\n    setProps(props) {\n        for (const name of Object.keys(props)) {\n            const moduleName = name;\n            const moduleProps = props[moduleName];\n            const module = this.modules[moduleName];\n            if (!module) {\n                // Ignore props for unregistered modules\n                log.warn(`Module ${name} not found`)();\n                continue; // eslint-disable-line no-continue\n            }\n            const oldUniforms = this.moduleUniforms[moduleName];\n            const uniforms = module.getUniforms?.(moduleProps, this.moduleUniforms[moduleName]) || moduleProps;\n            // console.error(uniforms)\n            this.moduleUniforms[moduleName] = { ...oldUniforms, ...uniforms };\n            // this.moduleUniformsChanged ||= moduleName;\n            // console.log(`setProps(${String(moduleName)}`, moduleName, this.moduleUniforms[moduleName])\n            // TODO - Get Module bindings\n            // const bindings = module.getBindings?.(moduleProps);\n            // this.moduleUniforms[moduleName] = bindings;\n        }\n    }\n    /** Merges all bindings for the shader (from the various modules) */\n    // getUniformBlocks(): Record<string, Texture | Sampler> {\n    //   return this.moduleUniforms;\n    // }\n    /**\n     * Return the map of modules\n     * @todo should should this include the resolved dependencies?\n     */\n    getModules() {\n        return Object.values(this.modules);\n    }\n    /** Get all uniform values for all modules */\n    getUniformValues() {\n        return this.moduleUniforms;\n    }\n    /** Merges all bindings for the shader (from the various modules) */\n    getBindings() {\n        const bindings = {};\n        for (const moduleBindings of Object.values(this.moduleBindings)) {\n            Object.assign(bindings, moduleBindings);\n        }\n        return bindings;\n    }\n    getDebugTable() {\n        const table = {};\n        for (const [moduleName, module] of Object.entries(this.moduleUniforms)) {\n            for (const [key, value] of Object.entries(module)) {\n                table[`${moduleName}.${key}`] = {\n                    type: this.modules[moduleName].uniformTypes?.[key],\n                    value: String(value)\n                };\n            }\n        }\n        return table;\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { RenderPipeline, ComputePipeline } from '@luma.gl/core';\n/**\n * Efficiently creates / caches pipelines\n */\nexport class PipelineFactory {\n    static defaultProps = { ...RenderPipeline.defaultProps };\n    device;\n    _hashCounter = 0;\n    _hashes = {};\n    _renderPipelineCache = {};\n    _computePipelineCache = {};\n    /** Get the singleton default pipeline factory for the specified device */\n    static getDefaultPipelineFactory(device) {\n        device._lumaData.defaultPipelineFactory =\n            device._lumaData.defaultPipelineFactory || new PipelineFactory(device);\n        return device._lumaData.defaultPipelineFactory;\n    }\n    constructor(device) {\n        this.device = device;\n    }\n    /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */\n    createRenderPipeline(props) {\n        const allProps = { ...RenderPipeline.defaultProps, ...props };\n        const hash = this._hashRenderPipeline(allProps);\n        if (!this._renderPipelineCache[hash]) {\n            const pipeline = this.device.createRenderPipeline({\n                ...allProps,\n                id: allProps.id ? `${allProps.id}-cached` : undefined\n            });\n            pipeline.hash = hash;\n            this._renderPipelineCache[hash] = { pipeline, useCount: 0 };\n        }\n        this._renderPipelineCache[hash].useCount++;\n        return this._renderPipelineCache[hash].pipeline;\n    }\n    createComputePipeline(props) {\n        const allProps = { ...ComputePipeline.defaultProps, ...props };\n        const hash = this._hashComputePipeline(allProps);\n        if (!this._computePipelineCache[hash]) {\n            const pipeline = this.device.createComputePipeline({\n                ...allProps,\n                id: allProps.id ? `${allProps.id}-cached` : undefined\n            });\n            pipeline.hash = hash;\n            this._computePipelineCache[hash] = { pipeline, useCount: 0 };\n        }\n        this._computePipelineCache[hash].useCount++;\n        return this._computePipelineCache[hash].pipeline;\n    }\n    release(pipeline) {\n        const hash = pipeline.hash;\n        const cache = pipeline instanceof ComputePipeline ? this._computePipelineCache : this._renderPipelineCache;\n        cache[hash].useCount--;\n        if (cache[hash].useCount === 0) {\n            cache[hash].pipeline.destroy();\n            delete cache[hash];\n        }\n    }\n    // PRIVATE\n    _hashComputePipeline(props) {\n        const shaderHash = this._getHash(props.shader.source);\n        return `${shaderHash}`;\n    }\n    /** Calculate a hash based on all the inputs for a render pipeline */\n    _hashRenderPipeline(props) {\n        const vsHash = this._getHash(props.vs.source);\n        const fsHash = props.fs ? this._getHash(props.fs.source) : 0;\n        // WebGL specific\n        // const {varyings = [], bufferMode = {}} = props;\n        // const varyingHashes = varyings.map((v) => this._getHash(v));\n        const varyingHash = '-'; // `${varyingHashes.join('/')}B${bufferMode}`\n        const bufferLayoutHash = this._getHash(JSON.stringify(props.bufferLayout));\n        switch (this.device.type) {\n            case 'webgl':\n                // WebGL is more dynamic\n                return `${vsHash}/${fsHash}V${varyingHash}BL${bufferLayoutHash}`;\n            default:\n                // On WebGPU we need to rebuild the pipeline if topology, parameters or bufferLayout change\n                const parameterHash = this._getHash(JSON.stringify(props.parameters));\n                // TODO - Can json.stringify() generate different strings for equivalent objects if order of params is different?\n                // create a deepHash() to deduplicate?\n                return `${vsHash}/${fsHash}V${varyingHash}T${props.topology}P${parameterHash}BL${bufferLayoutHash}`;\n        }\n    }\n    _getHash(key) {\n        if (this._hashes[key] === undefined) {\n            this._hashes[key] = this._hashCounter++;\n        }\n        return this._hashes[key];\n    }\n}\n", "import { Shader } from '@luma.gl/core';\n/** Manages a cached pool of Shaders for reuse. */\nexport class ShaderFactory {\n    static defaultProps = { ...Shader.defaultProps };\n    device;\n    _cache = {};\n    /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */\n    static getDefaultShaderFactory(device) {\n        device._lumaData.defaultShaderFactory ||= new ShaderFactory(device);\n        return device._lumaData.defaultShaderFactory;\n    }\n    /** @internal */\n    constructor(device) {\n        this.device = device;\n    }\n    /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */\n    createShader(props) {\n        const key = this._hashShader(props);\n        let cacheEntry = this._cache[key];\n        if (!cacheEntry) {\n            const shader = this.device.createShader({\n                ...props,\n                id: props.id ? `${props.id}-cached` : undefined\n            });\n            this._cache[key] = cacheEntry = { shader, useCount: 0 };\n        }\n        cacheEntry.useCount++;\n        return cacheEntry.shader;\n    }\n    /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */\n    release(shader) {\n        const key = this._hashShader(shader);\n        const cacheEntry = this._cache[key];\n        if (cacheEntry) {\n            cacheEntry.useCount--;\n            if (cacheEntry.useCount === 0) {\n                delete this._cache[key];\n                cacheEntry.shader.destroy();\n            }\n        }\n    }\n    // PRIVATE\n    _hashShader(value) {\n        return `${value.stage}:${value.source}`;\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Extracts a table suitable for `console.table()` from a shader layout to assist in debugging.\n * @param layout shader layout\n * @param name app should provide the most meaningful name, usually the model or pipeline name / id.\n * @returns\n */\nexport function getDebugTableForShaderLayout(layout, name) {\n    const table = {};\n    const header = 'Values'; // '`Shader Layout for ${name}`;\n    if (layout.attributes.length === 0 && !layout.varyings?.length) {\n        return { 'No attributes or varyings': { [header]: 'N/A' } };\n    }\n    for (const attributeDeclaration of layout.attributes) {\n        if (attributeDeclaration) {\n            const glslDeclaration = `${attributeDeclaration.location} ${attributeDeclaration.name}: ${attributeDeclaration.type}`;\n            table[`in ${glslDeclaration}`] = { [header]: attributeDeclaration.stepMode || 'vertex' };\n        }\n    }\n    for (const varyingDeclaration of layout.varyings || []) {\n        const glslDeclaration = `${varyingDeclaration.location} ${varyingDeclaration.name}`;\n        table[`out ${glslDeclaration}`] = { [header]: JSON.stringify(varyingDeclaration.accessor) };\n    }\n    return table;\n}\n", "// import {copyTextureToImage} from '../debug/copy-texture-to-image';\n/** Only works with 1st device? */\nlet canvas = null;\nlet ctx = null;\n// let targetImage: HTMLImageElement | null = null;\n/** Debug utility to draw FBO contents onto screen */\n// eslint-disable-next-line\nexport function debugFramebuffer(fbo, { id, minimap, opaque, top = '0', left = '0', rgbaScale = 1 }) {\n    if (!canvas) {\n        canvas = document.createElement('canvas');\n        canvas.id = id;\n        canvas.title = id;\n        canvas.style.zIndex = '100';\n        canvas.style.position = 'absolute';\n        canvas.style.top = top; // \u26A0\uFE0F\n        canvas.style.left = left; // \u26A0\uFE0F\n        canvas.style.border = 'blue 1px solid';\n        canvas.style.transform = 'scaleY(-1)';\n        document.body.appendChild(canvas);\n        ctx = canvas.getContext('2d');\n        // targetImage = new Image();\n    }\n    // const canvasHeight = (minimap ? 2 : 1) * fbo.height;\n    if (canvas.width !== fbo.width || canvas.height !== fbo.height) {\n        canvas.width = fbo.width / 2;\n        canvas.height = fbo.height / 2;\n        canvas.style.width = '400px';\n        canvas.style.height = '400px';\n    }\n    // const image = copyTextureToImage(fbo, {targetMaxHeight: 100, targetImage});\n    // ctx.drawImage(image, 0, 0);\n    const color = fbo.device.readPixelsToArrayWebGL(fbo);\n    const imageData = ctx.createImageData(fbo.width, fbo.height);\n    // Full map\n    const offset = 0;\n    // if (color.some((v) => v > 0)) {\n    //   console.error('THERE IS NON-ZERO DATA IN THE FBO!');\n    // }\n    for (let i = 0; i < color.length; i += 4) {\n        imageData.data[offset + i + 0] = color[i + 0] * rgbaScale;\n        imageData.data[offset + i + 1] = color[i + 1] * rgbaScale;\n        imageData.data[offset + i + 2] = color[i + 2] * rgbaScale;\n        imageData.data[offset + i + 3] = opaque ? 255 : color[i + 3] * rgbaScale;\n    }\n    ctx.putImageData(imageData, 0, 0);\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, assert } from '@luma.gl/core';\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport { Model } from \"../model/model.js\";\n/**\n * Creates a pipeline for buffer\u2192buffer transforms.\n * @deprecated\n */\nexport class BufferTransform {\n    device;\n    model;\n    transformFeedback;\n    /** @deprecated Use device feature test. */\n    static isSupported(device) {\n        return device?.info?.type === 'webgl';\n    }\n    constructor(device, props = Model.defaultProps) {\n        assert(BufferTransform.isSupported(device), 'BufferTransform not yet implemented on WebGPU');\n        this.device = device;\n        this.model = new Model(this.device, {\n            id: props.id || 'buffer-transform-model',\n            fs: props.fs || getPassthroughFS(),\n            topology: props.topology || 'point-list',\n            ...props\n        });\n        this.transformFeedback = this.device.createTransformFeedback({\n            layout: this.model.pipeline.shaderLayout,\n            buffers: props.feedbackBuffers\n        });\n        this.model.setTransformFeedback(this.transformFeedback);\n        Object.seal(this);\n    }\n    /** Destroy owned resources. */\n    destroy() {\n        if (this.model) {\n            this.model.destroy();\n        }\n    }\n    /** @deprecated Use {@link destroy}. */\n    delete() {\n        this.destroy();\n    }\n    /** Run one transform loop. */\n    run(options) {\n        const renderPass = this.device.beginRenderPass(options);\n        this.model.draw(renderPass);\n        renderPass.end();\n    }\n    /** @deprecated */\n    update(...args) {\n        // TODO(v9): Method should likely be removed for v9. Keeping a method stub\n        // to assist with migrating DeckGL usage.\n        // eslint-disable-next-line no-console\n        console.warn('TextureTransform#update() not implemented');\n    }\n    /** Returns the {@link Buffer} or {@link BufferRange} for given varying name. */\n    getBuffer(varyingName) {\n        return this.transformFeedback.getBuffer(varyingName);\n    }\n    readAsync(varyingName) {\n        const result = this.getBuffer(varyingName);\n        if (result instanceof Buffer) {\n            return result.readAsync();\n        }\n        const { buffer, byteOffset = 0, byteLength = buffer.byteLength } = result;\n        return buffer.readAsync(byteOffset, byteLength);\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from \"../model/model.js\";\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n/**\n * Creates a pipeline for texture\u2192texture transforms.\n * @deprecated\n */\nexport class TextureTransform {\n    device;\n    model;\n    sampler;\n    currentIndex = 0;\n    samplerTextureMap = null;\n    bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n    resources = {}; // resources to be deleted\n    constructor(device, props) {\n        this.device = device;\n        // For precise picking of element IDs.\n        this.sampler = device.createSampler({\n            addressModeU: 'clamp-to-edge',\n            addressModeV: 'clamp-to-edge',\n            minFilter: 'nearest',\n            magFilter: 'nearest',\n            mipmapFilter: 'nearest'\n        });\n        this.model = new Model(this.device, {\n            id: props.id || 'texture-transform-model',\n            fs: props.fs ||\n                getPassthroughFS({\n                    input: props.targetTextureVarying,\n                    inputChannels: props.targetTextureChannels,\n                    output: FS_OUTPUT_VARIABLE\n                }),\n            vertexCount: props.vertexCount, // TODO(donmccurdy): Naming?\n            ...props\n        });\n        this._initialize(props);\n        Object.seal(this);\n    }\n    // Delete owned resources.\n    destroy() { }\n    /** @deprecated Use {@link destroy}. */\n    delete() {\n        this.destroy();\n    }\n    run(options) {\n        const { framebuffer } = this.bindings[this.currentIndex];\n        const renderPass = this.device.beginRenderPass({ framebuffer, ...options });\n        this.model.draw(renderPass);\n        renderPass.end();\n    }\n    /** @deprecated */\n    update(...args) {\n        // TODO(v9): Method should likely be removed for v9. Keeping a method stub\n        // to assist with migrating DeckGL usage.\n        // eslint-disable-next-line no-console\n        console.warn('TextureTransform#update() not implemented');\n    }\n    getData({ packed = false } = {}) {\n        // TODO(v9): Method should likely be removed for v9. Keeping a method stub\n        // to assist with migrating DeckGL usage.\n        throw new Error('getData() not implemented');\n    }\n    getTargetTexture() {\n        const { targetTexture } = this.bindings[this.currentIndex];\n        return targetTexture;\n    }\n    getFramebuffer() {\n        const currentResources = this.bindings[this.currentIndex];\n        return currentResources.framebuffer;\n    }\n    // Private\n    _initialize(props) {\n        this._updateBindings(props);\n    }\n    _updateBindings(props) {\n        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], props);\n    }\n    _updateBinding(binding, { sourceBuffers, sourceTextures, targetTexture }) {\n        if (!binding) {\n            binding = {\n                sourceBuffers: {},\n                sourceTextures: {},\n                targetTexture: null\n            };\n        }\n        Object.assign(binding.sourceTextures, sourceTextures);\n        Object.assign(binding.sourceBuffers, sourceBuffers);\n        if (targetTexture) {\n            binding.targetTexture = targetTexture;\n            const { width, height } = targetTexture;\n            // TODO(donmccurdy): When is this called, and is this expected?\n            if (binding.framebuffer) {\n                binding.framebuffer.destroy();\n            }\n            binding.framebuffer = this.device.createFramebuffer({\n                id: 'transform-framebuffer',\n                width,\n                height,\n                colorAttachments: [targetTexture]\n            });\n            binding.framebuffer.resize({ width, height });\n        }\n        return binding;\n    }\n    // set texture filtering parameters on source textures.\n    _setSourceTextureParameters() {\n        const index = this.currentIndex;\n        const { sourceTextures } = this.bindings[index];\n        for (const name in sourceTextures) {\n            sourceTextures[name].sampler = this.sampler;\n        }\n    }\n}\n", "// ClipSpace\nimport { glsl } from '@luma.gl/core';\nimport { Model } from \"../model/model.js\";\nimport { Geometry } from \"../geometry/geometry.js\";\nconst CLIPSPACE_VERTEX_SHADER = `\\\n#version 300 es\nin vec2 aClipSpacePosition;\nin vec2 aTexCoord;\nin vec2 aCoordinate;\nout vec2 position;\nout vec2 coordinate;\nout vec2 uv;\nvoid main(void) {\ngl_Position = vec4(aClipSpacePosition, 0., 1.);\nposition = aClipSpacePosition;\ncoordinate = aCoordinate;\nuv = aTexCoord;\n}\n`;\n/* eslint-disable indent, no-multi-spaces */\nconst POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];\n/**\n * A flat geometry that covers the \"visible area\" that the GPU renders.\n */\nexport class ClipSpace extends Model {\n    constructor(device, opts) {\n        const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));\n        super(device, {\n            ...opts,\n            vs: CLIPSPACE_VERTEX_SHADER,\n            vertexCount: 4,\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                vertexCount: 4,\n                attributes: {\n                    aClipSpacePosition: { size: 2, value: new Float32Array(POSITIONS) },\n                    aTexCoord: { size: 2, value: new Float32Array(TEX_COORDS) },\n                    aCoordinate: { size: 2, value: new Float32Array(TEX_COORDS) }\n                }\n            })\n        });\n    }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { uid, assert } from '@luma.gl/core';\nexport class Geometry {\n    id;\n    /** Determines how vertices are read from the 'vertex' attributes */\n    topology;\n    vertexCount;\n    indices;\n    attributes;\n    userData = {};\n    constructor(props) {\n        const { attributes = {}, indices = null, vertexCount = null } = props;\n        this.id = props.id || uid('geometry');\n        this.topology = props.topology;\n        if (indices) {\n            this.indices = ArrayBuffer.isView(indices) ? { value: indices, size: 1 } : indices;\n        }\n        // @ts-expect-error\n        this.attributes = {};\n        for (const [attributeName, attributeValue] of Object.entries(attributes)) {\n            // Wrap \"unwrapped\" arrays and try to autodetect their type\n            const attribute = ArrayBuffer.isView(attributeValue)\n                ? { value: attributeValue }\n                : attributeValue;\n            assert(ArrayBuffer.isView(attribute.value), `${this._print(attributeName)}: must be typed array or object with value as typed array`);\n            if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {\n                attribute.size = 3;\n            }\n            // Move indices to separate field\n            if (attributeName === 'indices') {\n                assert(!this.indices);\n                this.indices = attribute;\n            }\n            else {\n                this.attributes[attributeName] = attribute;\n            }\n        }\n        if (this.indices && this.indices.isIndexed !== undefined) {\n            this.indices = Object.assign({}, this.indices);\n            delete this.indices.isIndexed;\n        }\n        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);\n    }\n    getVertexCount() {\n        return this.vertexCount;\n    }\n    /**\n     * Return an object with all attributes plus indices added as a field.\n     * TODO Geometry types are a mess\n     */\n    getAttributes() {\n        return this.indices ? { indices: this.indices, ...this.attributes } : this.attributes;\n    }\n    // PRIVATE\n    _print(attributeName) {\n        return `Geometry ${this.id} attribute ${attributeName}`;\n    }\n    /**\n     * GeometryAttribute\n     * value: typed array\n     * type: indices, vertices, uvs\n     * size: elements per vertex\n     * target: WebGL buffer type (string or constant)\n     *\n     * @param attributes\n     * @param indices\n     * @returns\n     */\n    _setAttributes(attributes, indices) {\n        return this;\n    }\n    _calculateVertexCount(attributes, indices) {\n        if (indices) {\n            return indices.value.length;\n        }\n        let vertexCount = Infinity;\n        for (const attribute of Object.values(attributes)) {\n            const { value, size, constant } = attribute;\n            if (!constant && value && size >= 1) {\n                vertexCount = Math.min(vertexCount, value.length / size);\n            }\n        }\n        assert(Number.isFinite(vertexCount));\n        return vertexCount;\n    }\n}\n", "import { assert, uid } from '@luma.gl/core';\nimport { Vector3, Matrix4 } from '@math.gl/core';\nexport class ScenegraphNode {\n    id;\n    matrix = new Matrix4();\n    display = true;\n    position = new Vector3();\n    rotation = new Vector3();\n    scale = new Vector3(1, 1, 1);\n    userData = {};\n    props = {};\n    constructor(props = {}) {\n        const { id } = props;\n        this.id = id || uid(this.constructor.name);\n        this._setScenegraphNodeProps(props);\n    }\n    getBounds() {\n        return null;\n    }\n    destroy() { }\n    /** @deprecated use .destroy() */\n    delete() {\n        this.destroy();\n    }\n    setProps(props) {\n        this._setScenegraphNodeProps(props);\n        return this;\n    }\n    toString() {\n        return `{type: ScenegraphNode, id: ${this.id})}`;\n    }\n    setPosition(position) {\n        assert(position.length === 3, 'setPosition requires vector argument');\n        this.position = position;\n        return this;\n    }\n    setRotation(rotation) {\n        assert(rotation.length === 3, 'setRotation requires vector argument');\n        this.rotation = rotation;\n        return this;\n    }\n    setScale(scale) {\n        assert(scale.length === 3, 'setScale requires vector argument');\n        this.scale = scale;\n        return this;\n    }\n    setMatrix(matrix, copyMatrix = true) {\n        if (copyMatrix) {\n            this.matrix.copy(matrix);\n        }\n        else {\n            this.matrix = matrix;\n        }\n    }\n    setMatrixComponents(components) {\n        const { position, rotation, scale, update = true } = components;\n        if (position) {\n            this.setPosition(position);\n        }\n        if (rotation) {\n            this.setRotation(rotation);\n        }\n        if (scale) {\n            this.setScale(scale);\n        }\n        if (update) {\n            this.updateMatrix();\n        }\n        return this;\n    }\n    updateMatrix() {\n        const pos = this.position;\n        const rot = this.rotation;\n        const scale = this.scale;\n        this.matrix.identity();\n        this.matrix.translate(pos);\n        this.matrix.rotateXYZ(rot);\n        this.matrix.scale(scale);\n        return this;\n    }\n    update(options = {}) {\n        const { position, rotation, scale } = options;\n        if (position) {\n            this.setPosition(position);\n        }\n        if (rotation) {\n            this.setRotation(rotation);\n        }\n        if (scale) {\n            this.setScale(scale);\n        }\n        this.updateMatrix();\n        return this;\n    }\n    getCoordinateUniforms(viewMatrix, modelMatrix) {\n        // TODO - solve multiple class problem\n        // assert(viewMatrix instanceof Matrix4);\n        assert(viewMatrix);\n        modelMatrix = modelMatrix || this.matrix;\n        const worldMatrix = new Matrix4(viewMatrix).multiplyRight(modelMatrix);\n        const worldInverse = worldMatrix.invert();\n        const worldInverseTranspose = worldInverse.transpose();\n        return {\n            viewMatrix,\n            modelMatrix,\n            objectMatrix: modelMatrix,\n            worldMatrix,\n            worldInverseMatrix: worldInverse,\n            worldInverseTransposeMatrix: worldInverseTranspose\n        };\n    }\n    // TODO - copied code, not yet vetted\n    /*\n    transform() {\n      if (!this.parent) {\n        this.endPosition.set(this.position);\n        this.endRotation.set(this.rotation);\n        this.endScale.set(this.scale);\n      } else {\n        const parent = this.parent;\n        this.endPosition.set(this.position.add(parent.endPosition));\n        this.endRotation.set(this.rotation.add(parent.endRotation));\n        this.endScale.set(this.scale.add(parent.endScale));\n      }\n  \n      const ch = this.children;\n      for (let i = 0; i < ch.length; ++i) {\n        ch[i].transform();\n      }\n  \n      return this;\n    }\n    */\n    _setScenegraphNodeProps(props) {\n        if ('display' in props) {\n            this.display = props.display;\n        }\n        if ('position' in props) {\n            this.setPosition(props.position);\n        }\n        if ('rotation' in props) {\n            this.setRotation(props.rotation);\n        }\n        if ('scale' in props) {\n            this.setScale(props.scale);\n        }\n        // Matrix overwrites other props\n        if ('matrix' in props) {\n            this.setMatrix(props.matrix);\n        }\n        Object.assign(this.props, props);\n    }\n}\n", "import { Matrix4, Vector3 } from '@math.gl/core';\nimport { log } from '@luma.gl/core';\nimport { ScenegraphNode } from \"./scenegraph-node.js\";\nexport class GroupNode extends ScenegraphNode {\n    children;\n    constructor(props = {}) {\n        props = Array.isArray(props) ? { children: props } : props;\n        const { children = [] } = props;\n        log.assert(children.every(child => child instanceof ScenegraphNode), 'every child must an instance of ScenegraphNode');\n        super(props);\n        this.children = children;\n    }\n    getBounds() {\n        const result = [\n            [Infinity, Infinity, Infinity],\n            [-Infinity, -Infinity, -Infinity]\n        ];\n        this.traverse((node, { worldMatrix }) => {\n            const bounds = node.getBounds();\n            if (!bounds) {\n                return;\n            }\n            const [min, max] = bounds;\n            const center = new Vector3(min).add(max).divide([2, 2, 2]);\n            worldMatrix.transformAsPoint(center, center);\n            const halfSize = new Vector3(max).subtract(min).divide([2, 2, 2]);\n            worldMatrix.transformAsVector(halfSize, halfSize);\n            for (let v = 0; v < 8; v++) {\n                // Test all 8 corners of the box\n                const position = new Vector3(v & 0b001 ? -1 : 1, v & 0b010 ? -1 : 1, v & 0b100 ? -1 : 1)\n                    .multiply(halfSize)\n                    .add(center);\n                for (let i = 0; i < 3; i++) {\n                    result[0][i] = Math.min(result[0][i], position[i]);\n                    result[1][i] = Math.max(result[1][i], position[i]);\n                }\n            }\n        });\n        if (!Number.isFinite(result[0][0])) {\n            return null;\n        }\n        return result;\n    }\n    destroy() {\n        this.children.forEach(child => child.destroy());\n        this.removeAll();\n        super.destroy();\n    }\n    // Unpacks arrays and nested arrays of children\n    add(...children) {\n        for (const child of children) {\n            if (Array.isArray(child)) {\n                this.add(...child);\n            }\n            else {\n                this.children.push(child);\n            }\n        }\n        return this;\n    }\n    remove(child) {\n        const children = this.children;\n        const indexOf = children.indexOf(child);\n        if (indexOf > -1) {\n            children.splice(indexOf, 1);\n        }\n        return this;\n    }\n    removeAll() {\n        this.children = [];\n        return this;\n    }\n    traverse(visitor, { worldMatrix = new Matrix4() } = {}) {\n        const modelMatrix = new Matrix4(worldMatrix).multiplyRight(this.matrix);\n        for (const child of this.children) {\n            if (child instanceof GroupNode) {\n                child.traverse(visitor, { worldMatrix: modelMatrix });\n            }\n            else {\n                visitor(child, { worldMatrix: modelMatrix });\n            }\n        }\n    }\n}\n", "import { ScenegraphNode } from \"./scenegraph-node.js\";\nexport class ModelNode extends ScenegraphNode {\n    model;\n    bounds = null;\n    managedResources;\n    // TODO - is this used? override callbacks to make sure we call them with this\n    // onBeforeRender = null;\n    // onAfterRender = null;\n    // AfterRender = null;\n    constructor(props) {\n        super(props);\n        // Create new Model or used supplied Model\n        this.model = props.model;\n        this.managedResources = props.managedResources || [];\n        this.bounds = props.bounds || null;\n        this.setProps(props);\n    }\n    getBounds() {\n        return this.bounds;\n    }\n    destroy() {\n        if (this.model) {\n            this.model.destroy();\n            // @ts-expect-error\n            this.model = null;\n        }\n        this.managedResources.forEach(resource => resource.destroy());\n        this.managedResources = [];\n    }\n    // Expose model methods\n    draw(renderPass) {\n        // Return value indicates if something was actually drawn\n        return this.model.draw(renderPass);\n    }\n}\n", "import { uid } from '@luma.gl/core';\nimport { TruncatedConeGeometry } from \"./truncated-cone-geometry.js\";\nexport class ConeGeometry extends TruncatedConeGeometry {\n    constructor(props = {}) {\n        const { id = uid('cone-geometry'), radius = 1, cap = true } = props;\n        super({\n            ...props,\n            id,\n            topRadius: 0,\n            topCap: Boolean(cap),\n            bottomCap: Boolean(cap),\n            bottomRadius: radius\n        });\n    }\n}\n", "import { uid } from '@luma.gl/core';\nimport { Geometry } from \"../geometry/geometry.js\";\nconst INDEX_OFFSETS = {\n    x: [2, 0, 1],\n    y: [0, 1, 2],\n    z: [1, 2, 0]\n};\n/**\n * Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n * copyright 2011 Google Inc. new BSD License\n * (http://www.opensource.org/licenses/bsd-license.php).\n */\nexport class TruncatedConeGeometry extends Geometry {\n    constructor(props = {}) {\n        const { id = uid('truncated-code-geometry') } = props;\n        const { indices, attributes } = tesselateTruncatedCone(props);\n        super({\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices,\n            attributes: {\n                POSITION: { size: 3, value: attributes.POSITION },\n                NORMAL: { size: 3, value: attributes.NORMAL },\n                TEXCOORD_0: { size: 2, value: attributes.TEXCOORD_0 },\n                ...props.attributes\n            }\n        });\n    }\n}\n/* eslint-disable max-statements, complexity */\nfunction tesselateTruncatedCone(props = {}) {\n    const { bottomRadius = 0, topRadius = 0, height = 1, nradial = 10, nvertical = 10, verticalAxis = 'y', topCap = false, bottomCap = false } = props;\n    const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);\n    const numVertices = (nradial + 1) * (nvertical + 1 + extra);\n    const slant = Math.atan2(bottomRadius - topRadius, height);\n    const msin = Math.sin;\n    const mcos = Math.cos;\n    const mpi = Math.PI;\n    const cosSlant = mcos(slant);\n    const sinSlant = msin(slant);\n    const start = topCap ? -2 : 0;\n    const end = nvertical + (bottomCap ? 2 : 0);\n    const vertsAroundEdge = nradial + 1;\n    const indices = new Uint16Array(nradial * (nvertical + extra) * 6);\n    const indexOffset = INDEX_OFFSETS[verticalAxis];\n    const positions = new Float32Array(numVertices * 3);\n    const normals = new Float32Array(numVertices * 3);\n    const texCoords = new Float32Array(numVertices * 2);\n    let i3 = 0;\n    let i2 = 0;\n    for (let i = start; i <= end; i++) {\n        let v = i / nvertical;\n        let y = height * v;\n        let ringRadius;\n        if (i < 0) {\n            y = 0;\n            v = 1;\n            ringRadius = bottomRadius;\n        }\n        else if (i > nvertical) {\n            y = height;\n            v = 1;\n            ringRadius = topRadius;\n        }\n        else {\n            ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);\n        }\n        if (i === -2 || i === nvertical + 2) {\n            ringRadius = 0;\n            v = 0;\n        }\n        y -= height / 2;\n        for (let j = 0; j < vertsAroundEdge; j++) {\n            const sin = msin((j * mpi * 2) / nradial);\n            const cos = mcos((j * mpi * 2) / nradial);\n            positions[i3 + indexOffset[0]] = sin * ringRadius;\n            positions[i3 + indexOffset[1]] = y;\n            positions[i3 + indexOffset[2]] = cos * ringRadius;\n            normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;\n            normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;\n            normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;\n            texCoords[i2 + 0] = j / nradial;\n            texCoords[i2 + 1] = v;\n            i2 += 2;\n            i3 += 3;\n        }\n    }\n    for (let i = 0; i < nvertical + extra; i++) {\n        for (let j = 0; j < nradial; j++) {\n            const index = (i * nradial + j) * 6;\n            indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;\n            indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;\n            indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;\n            indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;\n            indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;\n            indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;\n        }\n    }\n    return {\n        indices,\n        attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            TEXCOORD_0: texCoords\n        }\n    };\n}\n", "import { uid } from '@luma.gl/core';\nimport { Geometry } from \"../geometry/geometry.js\";\nexport class CubeGeometry extends Geometry {\n    constructor(props = {}) {\n        const { id = uid('cube-geometry'), indices = true } = props;\n        super(indices\n            ? {\n                ...props,\n                id,\n                topology: 'triangle-list',\n                indices: { size: 1, value: CUBE_INDICES },\n                attributes: { ...ATTRIBUTES, ...props.attributes }\n            }\n            : {\n                ...props,\n                id,\n                topology: 'triangle-list',\n                indices: undefined,\n                attributes: { ...NON_INDEXED_ATTRIBUTES, ...props.attributes }\n            });\n    }\n}\n// prettier-ignore\nconst CUBE_INDICES = new Uint16Array([\n    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,\n    14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23\n]);\n// prettier-ignore\nconst CUBE_POSITIONS = new Float32Array([\n    -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,\n    -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1,\n    -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,\n    -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1,\n    1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,\n    -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1\n]);\n// TODO - could be Uint8\n// prettier-ignore\nconst CUBE_NORMALS = new Float32Array([\n    // Front face\n    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,\n    // Back face\n    0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,\n    // Top face\n    0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n    // Bottom face\n    0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\n    // Right face\n    1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,\n    // Left face\n    -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0\n]);\n// prettier-ignore\nconst CUBE_TEX_COORDS = new Float32Array([\n    // Front face\n    0, 0, 1, 0, 1, 1, 0, 1,\n    // Back face\n    1, 0, 1, 1, 0, 1, 0, 0,\n    // Top face\n    0, 1, 0, 0, 1, 0, 1, 1,\n    // Bottom face\n    1, 1, 0, 1, 0, 0, 1, 0,\n    // Right face\n    1, 0, 1, 1, 0, 1, 0, 0,\n    // Left face\n    0, 0, 1, 0, 1, 1, 0, 1\n]);\n// float4 position\n// prettier-ignore\nexport const CUBE_NON_INDEXED_POSITIONS = new Float32Array([\n    1, -1, 1,\n    -1, -1, 1,\n    -1, -1, -1,\n    1, -1, -1,\n    1, -1, 1,\n    -1, -1, -1,\n    1, 1, 1,\n    1, -1, 1,\n    1, -1, -1,\n    1, 1, -1,\n    1, 1, 1,\n    1, -1, -1,\n    -1, 1, 1,\n    1, 1, 1,\n    1, 1, -1,\n    -1, 1, -1,\n    -1, 1, 1,\n    1, 1, -1,\n    -1, -1, 1,\n    -1, 1, 1,\n    -1, 1, -1,\n    -1, -1, -1,\n    -1, -1, 1,\n    -1, 1, -1,\n    1, 1, 1,\n    -1, 1, 1,\n    -1, -1, 1,\n    -1, -1, 1,\n    1, -1, 1,\n    1, 1, 1,\n    1, -1, -1,\n    -1, -1, -1,\n    -1, 1, -1,\n    1, 1, -1,\n    1, -1, -1,\n    -1, 1, -1,\n]);\n// float2 uv,\n// prettier-ignore\nexport const CUBE_NON_INDEXED_TEX_COORDS = new Float32Array([\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n    1, 1,\n    0, 1,\n    0, 0,\n    0, 0,\n    1, 0,\n    1, 1,\n    1, 1,\n    0, 1,\n    0, 0,\n    1, 0,\n    1, 1,\n    0, 0,\n]);\n// float4 color\n// prettier-ignore\nexport const CUBE_NON_INDEXED_COLORS = new Float32Array([\n    1, 0, 1, 1,\n    0, 0, 1, 1,\n    0, 0, 0, 1,\n    1, 0, 0, 1,\n    1, 0, 1, 1,\n    0, 0, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 1,\n    1, 0, 0, 1,\n    1, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 0, 1,\n    0, 1, 1, 1,\n    1, 1, 1, 1,\n    1, 1, 0, 1,\n    0, 1, 0, 1,\n    0, 1, 1, 1,\n    1, 1, 0, 1,\n    0, 0, 1, 1,\n    0, 1, 1, 1,\n    0, 1, 0, 1,\n    0, 0, 0, 1,\n    0, 0, 1, 1,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    0, 1, 1, 1,\n    0, 0, 1, 1,\n    0, 0, 1, 1,\n    1, 0, 1, 1,\n    1, 1, 1, 1,\n    1, 0, 0, 1,\n    0, 0, 0, 1,\n    0, 1, 0, 1,\n    1, 1, 0, 1,\n    1, 0, 0, 1,\n    0, 1, 0, 1,\n]);\nconst ATTRIBUTES = {\n    POSITION: { size: 3, value: CUBE_POSITIONS },\n    NORMAL: { size: 3, value: CUBE_NORMALS },\n    TEXCOORD_0: { size: 2, value: CUBE_TEX_COORDS }\n};\nconst NON_INDEXED_ATTRIBUTES = {\n    POSITION: { size: 3, value: CUBE_NON_INDEXED_POSITIONS },\n    // NORMAL: {size: 3, value: CUBE_NON_INDEXED_NORMALS},\n    TEXCOORD_0: { size: 2, value: CUBE_NON_INDEXED_TEX_COORDS },\n    COLOR_0: { size: 3, value: CUBE_NON_INDEXED_COLORS }\n};\n", "import { uid } from '@luma.gl/core';\nimport { TruncatedConeGeometry } from \"./truncated-cone-geometry.js\";\nexport class CylinderGeometry extends TruncatedConeGeometry {\n    constructor(props = {}) {\n        const { id = uid('cylinder-geometry'), radius = 1 } = props;\n        super({\n            ...props,\n            id,\n            bottomRadius: radius,\n            topRadius: radius\n        });\n    }\n}\n", "import { uid } from '@luma.gl/core';\nimport { Vector3 } from '@math.gl/core';\nimport { Geometry } from \"../geometry/geometry.js\";\n/* eslint-disable comma-spacing, max-statements, complexity */\nconst ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];\nconst ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];\nexport class IcoSphereGeometry extends Geometry {\n    constructor(props = {}) {\n        const { id = uid('ico-sphere-geometry') } = props;\n        const { indices, attributes } = tesselateIcosaHedron(props);\n        super({\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices,\n            attributes: { ...attributes, ...props.attributes }\n        });\n    }\n}\nfunction tesselateIcosaHedron(props) {\n    const { iterations = 0 } = props;\n    const PI = Math.PI;\n    const PI2 = PI * 2;\n    const positions = [...ICO_POSITIONS];\n    let indices = [...ICO_INDICES];\n    positions.push();\n    indices.push();\n    const getMiddlePoint = (() => {\n        const pointMemo = {};\n        return (i1, i2) => {\n            i1 *= 3;\n            i2 *= 3;\n            const mini = i1 < i2 ? i1 : i2;\n            const maxi = i1 > i2 ? i1 : i2;\n            const key = `${mini}|${maxi}`;\n            if (key in pointMemo) {\n                return pointMemo[key];\n            }\n            const x1 = positions[i1];\n            const y1 = positions[i1 + 1];\n            const z1 = positions[i1 + 2];\n            const x2 = positions[i2];\n            const y2 = positions[i2 + 1];\n            const z2 = positions[i2 + 2];\n            let xm = (x1 + x2) / 2;\n            let ym = (y1 + y2) / 2;\n            let zm = (z1 + z2) / 2;\n            const len = Math.sqrt(xm * xm + ym * ym + zm * zm);\n            xm /= len;\n            ym /= len;\n            zm /= len;\n            positions.push(xm, ym, zm);\n            return (pointMemo[key] = positions.length / 3 - 1);\n        };\n    })();\n    for (let i = 0; i < iterations; i++) {\n        const indices2 = [];\n        for (let j = 0; j < indices.length; j += 3) {\n            const a = getMiddlePoint(indices[j + 0], indices[j + 1]);\n            const b = getMiddlePoint(indices[j + 1], indices[j + 2]);\n            const c = getMiddlePoint(indices[j + 2], indices[j + 0]);\n            indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);\n        }\n        indices = indices2;\n    }\n    // Calculate texCoords and normals\n    const normals = new Array(positions.length);\n    const texCoords = new Array((positions.length / 3) * 2);\n    const l = indices.length;\n    for (let i = l - 3; i >= 0; i -= 3) {\n        const i1 = indices[i + 0];\n        const i2 = indices[i + 1];\n        const i3 = indices[i + 2];\n        const in1 = i1 * 3;\n        const in2 = i2 * 3;\n        const in3 = i3 * 3;\n        const iu1 = i1 * 2;\n        const iu2 = i2 * 2;\n        const iu3 = i3 * 2;\n        const x1 = positions[in1 + 0];\n        const y1 = positions[in1 + 1];\n        const z1 = positions[in1 + 2];\n        const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n        const phi1 = Math.atan2(y1, x1) + PI;\n        const v1 = theta1 / PI;\n        const u1 = 1 - phi1 / PI2;\n        const x2 = positions[in2 + 0];\n        const y2 = positions[in2 + 1];\n        const z2 = positions[in2 + 2];\n        const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));\n        const phi2 = Math.atan2(y2, x2) + PI;\n        const v2 = theta2 / PI;\n        const u2 = 1 - phi2 / PI2;\n        const x3 = positions[in3 + 0];\n        const y3 = positions[in3 + 1];\n        const z3 = positions[in3 + 2];\n        const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));\n        const phi3 = Math.atan2(y3, x3) + PI;\n        const v3 = theta3 / PI;\n        const u3 = 1 - phi3 / PI2;\n        const vec1 = [x3 - x2, y3 - y2, z3 - z2];\n        const vec2 = [x1 - x2, y1 - y2, z1 - z2];\n        const normal = new Vector3(vec1).cross(vec2).normalize();\n        let newIndex;\n        if ((u1 === 0 || u2 === 0 || u3 === 0) &&\n            (u1 === 0 || u1 > 0.5) &&\n            (u2 === 0 || u2 > 0.5) &&\n            (u3 === 0 || u3 > 0.5)) {\n            positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);\n            newIndex = positions.length / 3 - 1;\n            indices.push(newIndex);\n            texCoords[newIndex * 2 + 0] = 1;\n            texCoords[newIndex * 2 + 1] = v1;\n            normals[newIndex * 3 + 0] = normal.x;\n            normals[newIndex * 3 + 1] = normal.y;\n            normals[newIndex * 3 + 2] = normal.z;\n            positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);\n            newIndex = positions.length / 3 - 1;\n            indices.push(newIndex);\n            texCoords[newIndex * 2 + 0] = 1;\n            texCoords[newIndex * 2 + 1] = v2;\n            normals[newIndex * 3 + 0] = normal.x;\n            normals[newIndex * 3 + 1] = normal.y;\n            normals[newIndex * 3 + 2] = normal.z;\n            positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);\n            newIndex = positions.length / 3 - 1;\n            indices.push(newIndex);\n            texCoords[newIndex * 2 + 0] = 1;\n            texCoords[newIndex * 2 + 1] = v3;\n            normals[newIndex * 3 + 0] = normal.x;\n            normals[newIndex * 3 + 1] = normal.y;\n            normals[newIndex * 3 + 2] = normal.z;\n        }\n        normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;\n        normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;\n        normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;\n        texCoords[iu1 + 0] = u1;\n        texCoords[iu1 + 1] = v1;\n        texCoords[iu2 + 0] = u2;\n        texCoords[iu2 + 1] = v2;\n        texCoords[iu3 + 0] = u3;\n        texCoords[iu3 + 1] = v3;\n    }\n    return {\n        indices: { size: 1, value: new Uint16Array(indices) },\n        attributes: {\n            POSITION: { size: 3, value: new Float32Array(positions) },\n            NORMAL: { size: 3, value: new Float32Array(normals) },\n            TEXCOORD_0: { size: 2, value: new Float32Array(texCoords) }\n        }\n    };\n}\n", "import { uid } from '@luma.gl/core';\nimport { Geometry } from \"../geometry/geometry.js\";\nimport { unpackIndexedGeometry } from \"../geometry/geometry-utils.js\";\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class PlaneGeometry extends Geometry {\n    constructor(props = {}) {\n        const { id = uid('plane-geometry') } = props;\n        const { indices, attributes } = tesselatePlane(props);\n        super({\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices,\n            attributes: { ...attributes, ...props.attributes }\n        });\n    }\n}\n/* eslint-disable complexity, max-statements */\nfunction tesselatePlane(props) {\n    const { type = 'x,y', offset = 0, flipCull = false, unpack = false } = props;\n    const coords = type.split(',');\n    // width, height\n    let c1len = props[`${coords[0]}len`] || 1;\n    const c2len = props[`${coords[1]}len`] || 1;\n    // subdivisionsWidth, subdivisionsDepth\n    const subdivisions1 = props[`n${coords[0]}`] || 1;\n    const subdivisions2 = props[`n${coords[1]}`] || 1;\n    const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n    const positions = new Float32Array(numVertices * 3);\n    const normals = new Float32Array(numVertices * 3);\n    const texCoords = new Float32Array(numVertices * 2);\n    if (flipCull) {\n        c1len = -c1len;\n    }\n    let i2 = 0;\n    let i3 = 0;\n    for (let z = 0; z <= subdivisions2; z++) {\n        for (let x = 0; x <= subdivisions1; x++) {\n            const u = x / subdivisions1;\n            const v = z / subdivisions2;\n            texCoords[i2 + 0] = flipCull ? 1 - u : u;\n            texCoords[i2 + 1] = v;\n            switch (type) {\n                case 'x,y':\n                    positions[i3 + 0] = c1len * u - c1len * 0.5;\n                    positions[i3 + 1] = c2len * v - c2len * 0.5;\n                    positions[i3 + 2] = offset;\n                    normals[i3 + 0] = 0;\n                    normals[i3 + 1] = 0;\n                    normals[i3 + 2] = flipCull ? 1 : -1;\n                    break;\n                case 'x,z':\n                    positions[i3 + 0] = c1len * u - c1len * 0.5;\n                    positions[i3 + 1] = offset;\n                    positions[i3 + 2] = c2len * v - c2len * 0.5;\n                    normals[i3 + 0] = 0;\n                    normals[i3 + 1] = flipCull ? 1 : -1;\n                    normals[i3 + 2] = 0;\n                    break;\n                case 'y,z':\n                    positions[i3 + 0] = offset;\n                    positions[i3 + 1] = c1len * u - c1len * 0.5;\n                    positions[i3 + 2] = c2len * v - c2len * 0.5;\n                    normals[i3 + 0] = flipCull ? 1 : -1;\n                    normals[i3 + 1] = 0;\n                    normals[i3 + 2] = 0;\n                    break;\n                default:\n                    throw new Error('PlaneGeometry: unknown type');\n            }\n            i2 += 2;\n            i3 += 3;\n        }\n    }\n    const numVertsAcross = subdivisions1 + 1;\n    const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n    for (let z = 0; z < subdivisions2; z++) {\n        for (let x = 0; x < subdivisions1; x++) {\n            const index = (z * subdivisions1 + x) * 6;\n            // Make triangle 1 of quad.\n            indices[index + 0] = (z + 0) * numVertsAcross + x;\n            indices[index + 1] = (z + 1) * numVertsAcross + x;\n            indices[index + 2] = (z + 0) * numVertsAcross + x + 1;\n            // Make triangle 2 of quad.\n            indices[index + 3] = (z + 1) * numVertsAcross + x;\n            indices[index + 4] = (z + 1) * numVertsAcross + x + 1;\n            indices[index + 5] = (z + 0) * numVertsAcross + x + 1;\n        }\n    }\n    const geometry = {\n        indices: { size: 1, value: indices },\n        attributes: {\n            POSITION: { size: 3, value: positions },\n            NORMAL: { size: 3, value: normals },\n            TEXCOORD_0: { size: 2, value: texCoords }\n        }\n    };\n    // Optionally, unpack indexed geometry\n    return unpack ? unpackIndexedGeometry(geometry) : geometry;\n}\n", "// import type {Geometry} from './geometry';\nexport function unpackIndexedGeometry(geometry) {\n    const { indices, attributes } = geometry;\n    if (!indices) {\n        return geometry;\n    }\n    const vertexCount = indices.value.length;\n    const unpackedAttributes = {};\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        const { constant, value, size } = attribute;\n        if (constant || !size) {\n            continue; // eslint-disable-line\n        }\n        const unpackedValue = new value.constructor(vertexCount * size);\n        for (let x = 0; x < vertexCount; ++x) {\n            const index = indices.value[x];\n            for (let i = 0; i < size; i++) {\n                unpackedValue[x * size + i] = value[index * size + i];\n            }\n        }\n        unpackedAttributes[attributeName] = { size, value: unpackedValue };\n    }\n    return {\n        attributes: Object.assign({}, attributes, unpackedAttributes)\n    };\n}\n// export function calculateVertexNormals(positions: Float32Array): Uint8Array {\n//   let normals = new Uint8Array(positions.length / 3);\n//   for (let i = 0; i < positions.length; i++) {\n//     const vec1 = new Vector3(positions.subarray(i * 3, i + 0, i + 3));\n//     const vec2 = new Vector3(positions.subarray(i + 3, i + 6));\n//     const vec3 = new Vector3(positions.subarray(i + 6, i + 9));\n//     const normal = new Vector3(vec1).cross(vec2).normalize();\n//     normals.set(normal[0], i + 4);\n//     normals.set(normal[1], i + 4 + 1);\n//     normals.set(normal[2], i + 2);\n//   }\n//   const normal = new Vector3(vec1).cross(vec2).normalize();\n// }\n", "import { uid } from '@luma.gl/core';\nimport { Geometry } from \"../geometry/geometry.js\";\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\nexport class SphereGeometry extends Geometry {\n    constructor(props = {}) {\n        const { id = uid('sphere-geometry') } = props;\n        const { indices, attributes } = tesselateSphere(props);\n        super({\n            ...props,\n            id,\n            topology: 'triangle-list',\n            indices,\n            attributes: { ...attributes, ...props.attributes }\n        });\n    }\n}\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n    const { nlat = 10, nlong = 10 } = props;\n    const startLat = 0;\n    const endLat = Math.PI;\n    const latRange = endLat - startLat;\n    const startLong = 0;\n    const endLong = 2 * Math.PI;\n    const longRange = endLong - startLong;\n    const numVertices = (nlat + 1) * (nlong + 1);\n    const radius = (n1, n2, n3, u, v) => props.radius || 1;\n    const positions = new Float32Array(numVertices * 3);\n    const normals = new Float32Array(numVertices * 3);\n    const texCoords = new Float32Array(numVertices * 2);\n    const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n    const indices = new IndexType(nlat * nlong * 6);\n    // Create positions, normals and texCoords\n    for (let y = 0; y <= nlat; y++) {\n        for (let x = 0; x <= nlong; x++) {\n            const u = x / nlong;\n            const v = y / nlat;\n            const index = x + y * (nlong + 1);\n            const i2 = index * 2;\n            const i3 = index * 3;\n            const theta = longRange * u;\n            const phi = latRange * v;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n            const sinPhi = Math.sin(phi);\n            const cosPhi = Math.cos(phi);\n            const ux = cosTheta * sinPhi;\n            const uy = cosPhi;\n            const uz = sinTheta * sinPhi;\n            const r = radius(ux, uy, uz, u, v);\n            positions[i3 + 0] = r * ux;\n            positions[i3 + 1] = r * uy;\n            positions[i3 + 2] = r * uz;\n            normals[i3 + 0] = ux;\n            normals[i3 + 1] = uy;\n            normals[i3 + 2] = uz;\n            texCoords[i2 + 0] = u;\n            texCoords[i2 + 1] = 1 - v;\n        }\n    }\n    // Create indices\n    const numVertsAround = nlong + 1;\n    for (let x = 0; x < nlong; x++) {\n        for (let y = 0; y < nlat; y++) {\n            const index = (x * nlat + y) * 6;\n            indices[index + 0] = y * numVertsAround + x;\n            indices[index + 1] = y * numVertsAround + x + 1;\n            indices[index + 2] = (y + 1) * numVertsAround + x;\n            indices[index + 3] = (y + 1) * numVertsAround + x;\n            indices[index + 4] = y * numVertsAround + x + 1;\n            indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n        }\n    }\n    return {\n        indices: { size: 1, value: indices },\n        attributes: {\n            POSITION: { size: 3, value: positions },\n            NORMAL: { size: 3, value: normals },\n            TEXCOORD_0: { size: 2, value: texCoords }\n        }\n    };\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Buffer, ComputePipeline, UniformStore } from '@luma.gl/core';\nimport { log, uid, isNumberArray } from '@luma.gl/core';\nimport { getTypedArrayFromDataType } from '@luma.gl/core';\nimport { ShaderAssembler, getShaderLayoutFromWGSL } from '@luma.gl/shadertools';\nimport { ShaderInputs } from \"./shader-inputs.js\";\nimport { PipelineFactory } from \"./lib/pipeline-factory.js\";\nimport { ShaderFactory } from \"./lib/shader-factory.js\";\n// import {getDebugTableForShaderLayout} from '../debug/debug-shader-layout';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n/**\n * v9 Model API\n * A model\n * - automatically reuses pipelines (programs) when possible\n * - automatically rebuilds pipelines if necessary to accommodate changed settings\n * shadertools integration\n * - accepts modules and performs shader transpilation\n */\nexport class Computation {\n    static defaultProps = {\n        ...ComputePipeline.defaultProps,\n        id: 'unnamed',\n        handle: undefined,\n        userData: {},\n        source: '',\n        modules: [],\n        defines: {},\n        bindings: undefined,\n        shaderInputs: undefined,\n        pipelineFactory: undefined,\n        shaderFactory: undefined,\n        shaderAssembler: ShaderAssembler.getDefaultShaderAssembler(),\n        debugShaders: undefined\n    };\n    device;\n    id;\n    pipelineFactory;\n    shaderFactory;\n    userData = {};\n    /** Bindings (textures, samplers, uniform buffers) */\n    bindings = {};\n    /** The underlying GPU \"program\". @note May be recreated if parameters change */\n    pipeline;\n    /** the underlying compiled compute shader */\n    shader;\n    source;\n    /** ShaderInputs instance */\n    shaderInputs;\n    _uniformStore;\n    _pipelineNeedsUpdate = 'newly created';\n    _getModuleUniforms;\n    props;\n    _destroyed = false;\n    constructor(device, props) {\n        if (device.type !== 'webgpu') {\n            throw new Error('Computation is only supported in WebGPU');\n        }\n        this.props = { ...Computation.defaultProps, ...props };\n        props = this.props;\n        this.id = props.id || uid('model');\n        this.device = device;\n        Object.assign(this.userData, props.userData);\n        // Setup shader module inputs\n        const moduleMap = Object.fromEntries(this.props.modules?.map(module => [module.name, module]) || []);\n        this.setShaderInputs(props.shaderInputs || new ShaderInputs(moduleMap));\n        // Support WGSL shader layout introspection\n        // TODO - Don't modify props!!\n        this.props.shaderLayout ||= getShaderLayoutFromWGSL(this.props.source);\n        // Setup shader assembler\n        const platformInfo = getPlatformInfo(device);\n        // Extract modules from shader inputs if not supplied\n        const modules = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];\n        this.pipelineFactory =\n            props.pipelineFactory || PipelineFactory.getDefaultPipelineFactory(this.device);\n        this.shaderFactory = props.shaderFactory || ShaderFactory.getDefaultShaderFactory(this.device);\n        const { source, getUniforms } = this.props.shaderAssembler.assembleShader({\n            platformInfo,\n            ...this.props,\n            modules\n        });\n        this.source = source;\n        this._getModuleUniforms = getUniforms;\n        // Create the pipeline\n        // @note order is important\n        this.pipeline = this._updatePipeline();\n        // Apply any dynamic settings that will not trigger pipeline change\n        if (props.bindings) {\n            this.setBindings(props.bindings);\n        }\n        // Catch any access to non-standard props\n        Object.seal(this);\n    }\n    destroy() {\n        if (this._destroyed)\n            return;\n        this.pipelineFactory.release(this.pipeline);\n        this.shaderFactory.release(this.shader);\n        this._uniformStore.destroy();\n        this._destroyed = true;\n    }\n    // Draw call\n    predraw() {\n        // Update uniform buffers if needed\n        this.updateShaderInputs();\n    }\n    dispatch(computePass, x, y, z) {\n        try {\n            this._logDrawCallStart();\n            // Check if the pipeline is invalidated\n            // TODO - this is likely the worst place to do this from performance perspective. Perhaps add a predraw()?\n            this.pipeline = this._updatePipeline();\n            // Set pipeline state, we may be sharing a pipeline so we need to set all state on every draw\n            // Any caching needs to be done inside the pipeline functions\n            this.pipeline.setBindings(this.bindings);\n            computePass.setPipeline(this.pipeline);\n            // @ts-expect-error\n            computePass.setBindings([]);\n            computePass.dispatch(x, y, z);\n        }\n        finally {\n            this._logDrawCallEnd();\n        }\n    }\n    // Update fixed fields (can trigger pipeline rebuild)\n    // Update dynamic fields\n    /**\n     * Updates the vertex count (used in draw calls)\n     * @note Any attributes with stepMode=vertex need to be at least this big\n     */\n    setVertexCount(vertexCount) {\n        // this.vertexCount = vertexCount;\n    }\n    /**\n     * Updates the instance count (used in draw calls)\n     * @note Any attributes with stepMode=instance need to be at least this big\n     */\n    setInstanceCount(instanceCount) {\n        // this.instanceCount = instanceCount;\n    }\n    setShaderInputs(shaderInputs) {\n        this.shaderInputs = shaderInputs;\n        this._uniformStore = new UniformStore(this.shaderInputs.modules);\n        // Create uniform buffer bindings for all modules\n        for (const moduleName of Object.keys(this.shaderInputs.modules)) {\n            const uniformBuffer = this._uniformStore.getManagedUniformBuffer(this.device, moduleName);\n            this.bindings[`${moduleName}Uniforms`] = uniformBuffer;\n        }\n    }\n    /**\n     * Updates shader module settings (which results in uniforms being set)\n     */\n    setShaderModuleProps(props) {\n        const uniforms = this._getModuleUniforms(props);\n        // Extract textures & framebuffers set by the modules\n        // TODO better way to extract bindings\n        const keys = Object.keys(uniforms).filter(k => {\n            const uniform = uniforms[k];\n            return !isNumberArray(uniform) && typeof uniform !== 'number' && typeof uniform !== 'boolean';\n        });\n        const bindings = {};\n        for (const k of keys) {\n            bindings[k] = uniforms[k];\n            delete uniforms[k];\n        }\n    }\n    updateShaderInputs() {\n        this._uniformStore.setUniforms(this.shaderInputs.getUniformValues());\n    }\n    /**\n     * Sets bindings (textures, samplers, uniform buffers)\n     */\n    setBindings(bindings) {\n        Object.assign(this.bindings, bindings);\n    }\n    _setPipelineNeedsUpdate(reason) {\n        this._pipelineNeedsUpdate = this._pipelineNeedsUpdate || reason;\n    }\n    _updatePipeline() {\n        if (this._pipelineNeedsUpdate) {\n            let prevShader = null;\n            if (this.pipeline) {\n                log.log(1, `Model ${this.id}: Recreating pipeline because \"${this._pipelineNeedsUpdate}\".`)();\n                prevShader = this.shader;\n            }\n            this._pipelineNeedsUpdate = false;\n            this.shader = this.shaderFactory.createShader({\n                id: `${this.id}-fragment`,\n                stage: 'compute',\n                source: this.source,\n                debug: this.props.debugShaders\n            });\n            this.pipeline = this.pipelineFactory.createComputePipeline({\n                ...this.props,\n                shader: this.shader\n            });\n            if (prevShader) {\n                this.shaderFactory.release(prevShader);\n            }\n        }\n        return this.pipeline;\n    }\n    /** Throttle draw call logging */\n    _lastLogTime = 0;\n    _logOpen = false;\n    _logDrawCallStart() {\n        // IF level is 4 or higher, log every frame.\n        const logDrawTimeout = log.level > 3 ? 0 : LOG_DRAW_TIMEOUT;\n        if (log.level < 2 || Date.now() - this._lastLogTime < logDrawTimeout) {\n            return;\n        }\n        this._lastLogTime = Date.now();\n        this._logOpen = true;\n        log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, { collapsed: log.level <= 2 })();\n    }\n    _logDrawCallEnd() {\n        if (this._logOpen) {\n            // const shaderLayoutTable = getDebugTableForShaderLayout(this.pipeline.props.shaderLayout, this.id);\n            // log.table(logLevel, attributeTable)();\n            // log.table(logLevel, uniformTable)();\n            // log.table(LOG_DRAW_PRIORITY, shaderLayoutTable)();\n            const uniformTable = this.shaderInputs.getDebugTable();\n            log.table(LOG_DRAW_PRIORITY, uniformTable)();\n            log.groupEnd(LOG_DRAW_PRIORITY)();\n            this._logOpen = false;\n        }\n    }\n    _drawCount = 0;\n    // TODO - fix typing of luma data types\n    _getBufferOrConstantValues(attribute, dataType) {\n        const TypedArrayConstructor = getTypedArrayFromDataType(dataType);\n        const typedArray = attribute instanceof Buffer ? new TypedArrayConstructor(attribute.debugData) : attribute;\n        return typedArray.toString();\n    }\n}\n/** Create a shadertools platform info from the Device */\nexport function getPlatformInfo(device) {\n    return {\n        type: device.type,\n        shaderLanguage: device.info.shadingLanguage,\n        shaderLanguageVersion: device.info.shadingLanguageVersion,\n        gpu: device.info.gpu,\n        // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API\n        features: device.features\n    };\n}\n"],
  "mappings": "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,0BAA0B,IAAI,aAAa;AAAA,EACpD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACT;AAAA,EAAG;A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",
  "names": ["import_core", "canvas", "import_core", "import_core", "import_shadertools", "import_core", "import_core", "module", "import_core", "import_core", "module", "import_core", "import_shadertools", "import_shadertools", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "import_shadertools", "LOG_DRAW_PRIORITY", "LOG_DRAW_TIMEOUT", "module", "getPlatformInfo"]
}
