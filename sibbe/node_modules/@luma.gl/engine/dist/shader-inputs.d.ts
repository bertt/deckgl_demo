import type { UniformValue, Texture, Sampler } from '@luma.gl/core';
import { ShaderModuleInstance } from '@luma.gl/shadertools';
/** Minimal ShaderModule subset, we don't need shader code etc */
export type ShaderModuleInputs<PropsT extends Record<string, unknown> = Record<string, unknown>, UniformsT extends Record<string, UniformValue> = Record<string, UniformValue>, BindingsT extends Record<string, Texture | Sampler> = Record<string, Texture | Sampler>> = {
    defaultUniforms?: UniformsT;
    getUniforms?: (settings: Partial<PropsT>, prevUniforms?: UniformsT) => UniformsT;
    /** Not used. Used to access props type */
    props?: PropsT;
    bindings?: Record<keyof BindingsT, {
        location: number;
        type: 'texture' | 'sampler' | 'uniforms';
    }>;
    uniformTypes?: any;
};
/**
 * ShaderInputs holds uniform and binding values for one or more shader modules,
 * - It can generate binary data for any uniform buffer
 * - It can manage a uniform buffer for each block
 * - It can update managed uniform buffers with a single call
 * - It performs some book keeping on what has changed to minimize unnecessary writes to uniform buffers.
 */
export declare class ShaderInputs<ShaderPropsT extends Partial<Record<string, Record<string, unknown>>> = Partial<Record<string, Record<string, unknown>>>> {
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    modules: Readonly<{
        [P in keyof ShaderPropsT]: ShaderModuleInputs<ShaderPropsT[P]>;
    }>;
    /** Stores the uniform values for each module */
    moduleUniforms: Record<keyof ShaderPropsT, Record<string, UniformValue>>;
    /** Stores the uniform bindings for each module  */
    moduleBindings: Record<keyof ShaderPropsT, Record<string, Texture | Sampler>>;
    /** Tracks if uniforms have changed */
    moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
    /**
     * Create a new UniformStore instance
     * @param modules
     */
    constructor(modules: {
        [P in keyof ShaderPropsT]: ShaderModuleInputs<ShaderPropsT[P]>;
    });
    /** Destroy */
    destroy(): void;
    /**
     * Set module props
     */
    setProps(props: Partial<{
        [P in keyof ShaderPropsT]?: Partial<ShaderPropsT[P]>;
    }>): void;
    /** Merges all bindings for the shader (from the various modules) */
    /**
     * Return the map of modules
     * @todo should should this include the resolved dependencies?
     */
    getModules(): ShaderModuleInstance[];
    /** Get all uniform values for all modules */
    getUniformValues(): Record<keyof ShaderPropsT, Record<string, UniformValue>>;
    /** Merges all bindings for the shader (from the various modules) */
    getBindings(): Record<string, Texture | Sampler>;
    getDebugTable(): Record<string, Record<string, unknown>>;
}
//# sourceMappingURL=shader-inputs.d.ts.map