(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // external-global-plugin:@luma.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@luma.gl/core"(exports, module) {
      module.exports = globalThis.luma;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    Accessor: () => Accessor,
    WEBGLBuffer: () => WEBGLBuffer,
    WEBGLCommandEncoder: () => WEBGLCommandEncoder,
    WEBGLFramebuffer: () => WEBGLFramebuffer,
    WEBGLRenderPass: () => WEBGLRenderPass,
    WEBGLRenderPipeline: () => WEBGLRenderPipeline,
    WEBGLResource: () => WebGLResource,
    WEBGLSampler: () => WEBGLSampler,
    WEBGLShader: () => WEBGLShader,
    WEBGLTexture: () => WEBGLTexture,
    WEBGLTransformFeedback: () => WEBGLTransformFeedback,
    WEBGLVertexArray: () => WEBGLVertexArray,
    WebGLCanvasContext: () => WebGLCanvasContext,
    WebGLDevice: () => WebGLDevice,
    WebGLResource: () => WebGLResource,
    _TEXTURE_FORMATS: () => TEXTURE_FORMATS,
    _WEBGLRenderbuffer: () => WEBGLRenderbuffer,
    convertGLToTextureFormat: () => convertGLToTextureFormat,
    getGLParameters: () => getGLParameters,
    getShaderLayout: () => getShaderLayout,
    popContextState: () => popContextState,
    pushContextState: () => pushContextState,
    resetGLParameters: () => resetGLParameters,
    setDeviceParameters: () => setDeviceParameters,
    setGLParameters: () => setGLParameters,
    trackContextState: () => trackContextState,
    withDeviceParameters: () => withDeviceParameters,
    withGLParameters: () => withGLParameters
  });
  __reExport(bundle_exports, __toESM(require_core(), 1));

  // src/adapter/webgl-device.ts
  var import_core27 = __toESM(require_core(), 1);

  // src/context/state-tracker/track-context-state.ts
  var import_core = __toESM(require_core(), 1);

  // ../constants/src/webgl-constants.ts
  var GLEnum = /* @__PURE__ */ ((GLEnum2) => {
    GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
    GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
    GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
    GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
    GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
    GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
    GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
    GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
    GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
    GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
    GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
    GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
    GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
    GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
    GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
    GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
    GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
    GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
    GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
    GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
    GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
    GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
    GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
    GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
    GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
    GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
    GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
    GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
    GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
    GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
    GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
    GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
    GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
    GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
    GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
    GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
    GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
    GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
    GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
    GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
    GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
    GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
    GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
    GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
    GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
    GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
    GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
    GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
    GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
    GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
    GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
    GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
    GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
    GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
    GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
    GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
    GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
    GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
    GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
    GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
    GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
    GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
    GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
    GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
    GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
    GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
    GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
    GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
    GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
    GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
    GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
    GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
    GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
    GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
    GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
    GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
    GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
    GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
    GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
    GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
    GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
    GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
    GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
    GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
    GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
    GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
    GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
    GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
    GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
    GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
    GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
    GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
    GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
    GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
    GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
    GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
    GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
    GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
    GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
    GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
    GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
    GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
    GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
    GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
    GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
    GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
    GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
    GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
    GLEnum2[GLEnum2["CW"] = 2304] = "CW";
    GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
    GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
    GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
    GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
    GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
    GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
    GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
    GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    GLEnum2[GLEnum2["INT"] = 5124] = "INT";
    GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
    GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
    GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
    GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
    GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
    GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
    GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
    GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
    GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
    GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
    GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
    GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
    GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
    GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
    GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
    GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
    GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
    GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
    GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
    GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
    GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
    GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
    GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
    GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
    GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
    GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
    GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
    GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
    GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
    GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
    GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
    GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
    GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
    GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
    GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
    GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
    GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
    GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
    GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
    GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
    GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
    GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
    GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
    GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
    GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
    GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
    GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
    GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
    GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
    GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
    GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
    GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
    GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
    GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
    GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
    GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
    GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
    GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
    GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
    GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
    GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
    GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
    GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
    GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
    GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
    GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
    GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
    GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
    GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
    GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
    GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
    GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
    GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
    GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
    GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
    GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
    GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
    GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
    GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
    GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
    GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
    GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
    GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
    GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
    GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
    GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
    GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
    GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
    GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
    GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
    GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
    GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
    GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
    GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
    GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
    GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
    GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
    GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
    GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
    GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
    GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
    GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
    GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
    GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
    GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
    GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
    GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
    GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
    GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
    GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
    GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
    GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
    GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
    GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
    GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
    GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
    GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
    GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
    GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
    GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
    GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
    GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
    GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
    GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
    GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
    GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
    GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
    GLEnum2[GLEnum2["RED"] = 6403] = "RED";
    GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
    GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
    GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
    GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
    GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
    GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
    GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
    GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
    GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
    GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
    GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
    GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
    GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
    GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
    GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
    GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
    GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
    GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
    GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
    GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
    GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
    GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
    GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
    GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
    GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
    GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
    GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
    GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
    GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
    GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
    GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
    GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
    GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
    GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
    GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
    GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
    GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
    GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
    GLEnum2[GLEnum2["R8"] = 33321] = "R8";
    GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
    GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
    GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
    GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
    GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
    GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
    GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
    GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
    GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
    GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
    GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
    GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
    GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
    GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
    GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
    GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
    GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
    GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
    GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
    GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
    GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
    GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
    GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
    GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
    GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
    GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
    GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
    GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
    GLEnum2[GLEnum2["RG"] = 33319] = "RG";
    GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
    GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
    GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
    GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
    GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
    GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
    GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
    GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
    GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
    GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
    GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
    GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
    GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
    GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
    GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
    GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
    GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
    GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
    GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
    GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
    GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
    GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
    GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
    GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
    GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
    GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
    GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
    GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
    GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
    GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
    GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
    GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
    GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
    GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
    GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
    GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
    GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
    GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
    GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
    GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
    GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
    GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
    GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
    GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
    GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
    GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
    GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
    GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
    GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
    GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
    GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
    GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
    GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
    GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
    GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
    GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
    GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
    GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
    GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
    GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
    GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
    GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
    GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
    GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
    GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
    GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
    GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
    GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
    GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
    GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
    GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
    GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
    GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
    GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
    GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
    GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
    GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
    GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
    GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
    GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
    GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
    GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
    GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
    GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
    GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
    GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
    GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
    GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
    GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
    GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
    GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
    GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
    GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
    GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
    GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
    GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
    GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
    GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
    GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
    GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
    GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
    GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
    GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
    GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
    GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
    GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
    GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
    GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
    GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
    GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
    GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
    GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
    GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
    GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
    GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
    GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
    GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
    GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
    GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
    GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
    GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
    GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
    GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
    GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
    GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
    GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
    GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
    GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
    GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
    GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
    GLEnum2[GLEnum2["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
    GLEnum2[GLEnum2["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
    GLEnum2[GLEnum2["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
    GLEnum2[GLEnum2["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
    GLEnum2[GLEnum2["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
    GLEnum2[GLEnum2["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
    GLEnum2[GLEnum2["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
    GLEnum2[GLEnum2["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
    GLEnum2[GLEnum2["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
    GLEnum2[GLEnum2["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
    GLEnum2[GLEnum2["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
    GLEnum2[GLEnum2["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
    GLEnum2[GLEnum2["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
    GLEnum2[GLEnum2["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
    GLEnum2[GLEnum2["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
    GLEnum2[GLEnum2["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
    GLEnum2[GLEnum2["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
    GLEnum2[GLEnum2["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
    GLEnum2[GLEnum2["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
    GLEnum2[GLEnum2["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
    GLEnum2[GLEnum2["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
    GLEnum2[GLEnum2["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
    GLEnum2[GLEnum2["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
    GLEnum2[GLEnum2["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
    GLEnum2[GLEnum2["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
    GLEnum2[GLEnum2["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
    return GLEnum2;
  })(GLEnum || {});

  // src/context/parameters/webgl-parameter-tables.ts
  var GL_PARAMETER_DEFAULTS = {
    [3042 /* BLEND */]: false,
    [32773 /* BLEND_COLOR */]: new Float32Array([0, 0, 0, 0]),
    [32777 /* BLEND_EQUATION_RGB */]: 32774 /* FUNC_ADD */,
    [34877 /* BLEND_EQUATION_ALPHA */]: 32774 /* FUNC_ADD */,
    [32969 /* BLEND_SRC_RGB */]: 1 /* ONE */,
    [32968 /* BLEND_DST_RGB */]: 0 /* ZERO */,
    [32971 /* BLEND_SRC_ALPHA */]: 1 /* ONE */,
    [32970 /* BLEND_DST_ALPHA */]: 0 /* ZERO */,
    [3106 /* COLOR_CLEAR_VALUE */]: new Float32Array([0, 0, 0, 0]),
    // TBD
    [3107 /* COLOR_WRITEMASK */]: [true, true, true, true],
    [2884 /* CULL_FACE */]: false,
    [2885 /* CULL_FACE_MODE */]: 1029 /* BACK */,
    [2929 /* DEPTH_TEST */]: false,
    [2931 /* DEPTH_CLEAR_VALUE */]: 1,
    [2932 /* DEPTH_FUNC */]: 513 /* LESS */,
    [2928 /* DEPTH_RANGE */]: new Float32Array([0, 1]),
    // TBD
    [2930 /* DEPTH_WRITEMASK */]: true,
    [3024 /* DITHER */]: true,
    [35725 /* CURRENT_PROGRAM */]: null,
    // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006 /* FRAMEBUFFER_BINDING */]: null,
    [36007 /* RENDERBUFFER_BINDING */]: null,
    [34229 /* VERTEX_ARRAY_BINDING */]: null,
    [34964 /* ARRAY_BUFFER_BINDING */]: null,
    [2886 /* FRONT_FACE */]: 2305 /* CCW */,
    [33170 /* GENERATE_MIPMAP_HINT */]: 4352 /* DONT_CARE */,
    [2849 /* LINE_WIDTH */]: 1,
    [32823 /* POLYGON_OFFSET_FILL */]: false,
    [32824 /* POLYGON_OFFSET_FACTOR */]: 0,
    [10752 /* POLYGON_OFFSET_UNITS */]: 0,
    [32926 /* SAMPLE_ALPHA_TO_COVERAGE */]: false,
    [32928 /* SAMPLE_COVERAGE */]: false,
    [32938 /* SAMPLE_COVERAGE_VALUE */]: 1,
    [32939 /* SAMPLE_COVERAGE_INVERT */]: false,
    [3089 /* SCISSOR_TEST */]: false,
    // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
    [3088 /* SCISSOR_BOX */]: new Int32Array([0, 0, 1024, 1024]),
    [2960 /* STENCIL_TEST */]: false,
    [2961 /* STENCIL_CLEAR_VALUE */]: 0,
    [2968 /* STENCIL_WRITEMASK */]: 4294967295,
    [36005 /* STENCIL_BACK_WRITEMASK */]: 4294967295,
    [2962 /* STENCIL_FUNC */]: 519 /* ALWAYS */,
    [2967 /* STENCIL_REF */]: 0,
    [2963 /* STENCIL_VALUE_MASK */]: 4294967295,
    [34816 /* STENCIL_BACK_FUNC */]: 519 /* ALWAYS */,
    [36003 /* STENCIL_BACK_REF */]: 0,
    [36004 /* STENCIL_BACK_VALUE_MASK */]: 4294967295,
    [2964 /* STENCIL_FAIL */]: 7680 /* KEEP */,
    [2965 /* STENCIL_PASS_DEPTH_FAIL */]: 7680 /* KEEP */,
    [2966 /* STENCIL_PASS_DEPTH_PASS */]: 7680 /* KEEP */,
    [34817 /* STENCIL_BACK_FAIL */]: 7680 /* KEEP */,
    [34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */]: 7680 /* KEEP */,
    [34819 /* STENCIL_BACK_PASS_DEPTH_PASS */]: 7680 /* KEEP */,
    // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
    [2978 /* VIEWPORT */]: [0, 0, 1024, 1024],
    [36389 /* TRANSFORM_FEEDBACK_BINDING */]: null,
    [36662 /* COPY_READ_BUFFER_BINDING */]: null,
    [36663 /* COPY_WRITE_BUFFER_BINDING */]: null,
    [35053 /* PIXEL_PACK_BUFFER_BINDING */]: null,
    [35055 /* PIXEL_UNPACK_BUFFER_BINDING */]: null,
    [35723 /* FRAGMENT_SHADER_DERIVATIVE_HINT */]: 4352 /* DONT_CARE */,
    [36010 /* READ_FRAMEBUFFER_BINDING */]: null,
    [35977 /* RASTERIZER_DISCARD */]: false,
    [3333 /* PACK_ALIGNMENT */]: 4,
    [3317 /* UNPACK_ALIGNMENT */]: 4,
    [37440 /* UNPACK_FLIP_Y_WEBGL */]: false,
    [37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */]: false,
    [37443 /* UNPACK_COLORSPACE_CONVERSION_WEBGL */]: 37444 /* BROWSER_DEFAULT_WEBGL */,
    [3330 /* PACK_ROW_LENGTH */]: 0,
    [3332 /* PACK_SKIP_PIXELS */]: 0,
    [3331 /* PACK_SKIP_ROWS */]: 0,
    [3314 /* UNPACK_ROW_LENGTH */]: 0,
    [32878 /* UNPACK_IMAGE_HEIGHT */]: 0,
    [3316 /* UNPACK_SKIP_PIXELS */]: 0,
    [3315 /* UNPACK_SKIP_ROWS */]: 0,
    [32877 /* UNPACK_SKIP_IMAGES */]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var bindFramebuffer = (gl, value, key) => {
    const target = key === 36006 /* FRAMEBUFFER_BINDING */ ? 36009 /* DRAW_FRAMEBUFFER */ : 36008 /* READ_FRAMEBUFFER */;
    return gl.bindFramebuffer(target, value);
  };
  var bindBuffer = (gl, value, key) => {
    const bindingMap = {
      [34964 /* ARRAY_BUFFER_BINDING */]: 34962 /* ARRAY_BUFFER */,
      [36662 /* COPY_READ_BUFFER_BINDING */]: 36662 /* COPY_READ_BUFFER */,
      [36663 /* COPY_WRITE_BUFFER_BINDING */]: 36663 /* COPY_WRITE_BUFFER */,
      [35053 /* PIXEL_PACK_BUFFER_BINDING */]: 35051 /* PIXEL_PACK_BUFFER */,
      [35055 /* PIXEL_UNPACK_BUFFER_BINDING */]: 35052 /* PIXEL_UNPACK_BUFFER */
    };
    const glTarget = bindingMap[key];
    gl.bindBuffer(glTarget, value);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
  }
  var GL_PARAMETER_SETTERS = {
    [3042 /* BLEND */]: enable,
    [32773 /* BLEND_COLOR */]: (gl, value) => gl.blendColor(...value),
    [32777 /* BLEND_EQUATION_RGB */]: "blendEquation",
    [34877 /* BLEND_EQUATION_ALPHA */]: "blendEquation",
    [32969 /* BLEND_SRC_RGB */]: "blendFunc",
    [32968 /* BLEND_DST_RGB */]: "blendFunc",
    [32971 /* BLEND_SRC_ALPHA */]: "blendFunc",
    [32970 /* BLEND_DST_ALPHA */]: "blendFunc",
    [3106 /* COLOR_CLEAR_VALUE */]: (gl, value) => gl.clearColor(...value),
    [3107 /* COLOR_WRITEMASK */]: (gl, value) => gl.colorMask(...value),
    [2884 /* CULL_FACE */]: enable,
    [2885 /* CULL_FACE_MODE */]: (gl, value) => gl.cullFace(value),
    [2929 /* DEPTH_TEST */]: enable,
    [2931 /* DEPTH_CLEAR_VALUE */]: (gl, value) => gl.clearDepth(value),
    [2932 /* DEPTH_FUNC */]: (gl, value) => gl.depthFunc(value),
    [2928 /* DEPTH_RANGE */]: (gl, value) => gl.depthRange(...value),
    [2930 /* DEPTH_WRITEMASK */]: (gl, value) => gl.depthMask(value),
    [3024 /* DITHER */]: enable,
    [35723 /* FRAGMENT_SHADER_DERIVATIVE_HINT */]: hint,
    [35725 /* CURRENT_PROGRAM */]: (gl, value) => gl.useProgram(value),
    [36007 /* RENDERBUFFER_BINDING */]: (gl, value) => gl.bindRenderbuffer(36161 /* RENDERBUFFER */, value),
    [36389 /* TRANSFORM_FEEDBACK_BINDING */]: (gl, value) => gl.bindTransformFeedback?.(36386 /* TRANSFORM_FEEDBACK */, value),
    [34229 /* VERTEX_ARRAY_BINDING */]: (gl, value) => gl.bindVertexArray(value),
    // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
    [36006 /* FRAMEBUFFER_BINDING */]: bindFramebuffer,
    [36010 /* READ_FRAMEBUFFER_BINDING */]: bindFramebuffer,
    // Buffers
    [34964 /* ARRAY_BUFFER_BINDING */]: bindBuffer,
    [36662 /* COPY_READ_BUFFER_BINDING */]: bindBuffer,
    [36663 /* COPY_WRITE_BUFFER_BINDING */]: bindBuffer,
    [35053 /* PIXEL_PACK_BUFFER_BINDING */]: bindBuffer,
    [35055 /* PIXEL_UNPACK_BUFFER_BINDING */]: bindBuffer,
    [2886 /* FRONT_FACE */]: (gl, value) => gl.frontFace(value),
    [33170 /* GENERATE_MIPMAP_HINT */]: hint,
    [2849 /* LINE_WIDTH */]: (gl, value) => gl.lineWidth(value),
    [32823 /* POLYGON_OFFSET_FILL */]: enable,
    [32824 /* POLYGON_OFFSET_FACTOR */]: "polygonOffset",
    [10752 /* POLYGON_OFFSET_UNITS */]: "polygonOffset",
    [35977 /* RASTERIZER_DISCARD */]: enable,
    [32926 /* SAMPLE_ALPHA_TO_COVERAGE */]: enable,
    [32928 /* SAMPLE_COVERAGE */]: enable,
    [32938 /* SAMPLE_COVERAGE_VALUE */]: "sampleCoverage",
    [32939 /* SAMPLE_COVERAGE_INVERT */]: "sampleCoverage",
    [3089 /* SCISSOR_TEST */]: enable,
    [3088 /* SCISSOR_BOX */]: (gl, value) => gl.scissor(...value),
    [2960 /* STENCIL_TEST */]: enable,
    [2961 /* STENCIL_CLEAR_VALUE */]: (gl, value) => gl.clearStencil(value),
    [2968 /* STENCIL_WRITEMASK */]: (gl, value) => gl.stencilMaskSeparate(1028 /* FRONT */, value),
    [36005 /* STENCIL_BACK_WRITEMASK */]: (gl, value) => gl.stencilMaskSeparate(1029 /* BACK */, value),
    [2962 /* STENCIL_FUNC */]: "stencilFuncFront",
    [2967 /* STENCIL_REF */]: "stencilFuncFront",
    [2963 /* STENCIL_VALUE_MASK */]: "stencilFuncFront",
    [34816 /* STENCIL_BACK_FUNC */]: "stencilFuncBack",
    [36003 /* STENCIL_BACK_REF */]: "stencilFuncBack",
    [36004 /* STENCIL_BACK_VALUE_MASK */]: "stencilFuncBack",
    [2964 /* STENCIL_FAIL */]: "stencilOpFront",
    [2965 /* STENCIL_PASS_DEPTH_FAIL */]: "stencilOpFront",
    [2966 /* STENCIL_PASS_DEPTH_PASS */]: "stencilOpFront",
    [34817 /* STENCIL_BACK_FAIL */]: "stencilOpBack",
    [34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */]: "stencilOpBack",
    [34819 /* STENCIL_BACK_PASS_DEPTH_PASS */]: "stencilOpBack",
    [2978 /* VIEWPORT */]: (gl, value) => gl.viewport(...value),
    // WEBGL2 EXTENSIONS
    // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
    [34383 /* DEPTH_CLAMP_EXT */]: enable,
    // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
    // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
    // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
    // POLYGON_MODE_WEBGL  TODO - extension function needed
    [10754 /* POLYGON_OFFSET_LINE_WEBGL */]: enable,
    // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
    [12288 /* CLIP_DISTANCE0_WEBGL */]: enable,
    [12289 /* CLIP_DISTANCE1_WEBGL */]: enable,
    [12290 /* CLIP_DISTANCE2_WEBGL */]: enable,
    [12291 /* CLIP_DISTANCE3_WEBGL */]: enable,
    [12292 /* CLIP_DISTANCE4_WEBGL */]: enable,
    [12293 /* CLIP_DISTANCE5_WEBGL */]: enable,
    [12294 /* CLIP_DISTANCE6_WEBGL */]: enable,
    [12295 /* CLIP_DISTANCE7_WEBGL */]: enable,
    // PIXEL PACK/UNPACK MODES
    [3333 /* PACK_ALIGNMENT */]: pixelStorei,
    [3317 /* UNPACK_ALIGNMENT */]: pixelStorei,
    [37440 /* UNPACK_FLIP_Y_WEBGL */]: pixelStorei,
    [37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */]: pixelStorei,
    [37443 /* UNPACK_COLORSPACE_CONVERSION_WEBGL */]: pixelStorei,
    [3330 /* PACK_ROW_LENGTH */]: pixelStorei,
    [3332 /* PACK_SKIP_PIXELS */]: pixelStorei,
    [3331 /* PACK_SKIP_ROWS */]: pixelStorei,
    [3314 /* UNPACK_ROW_LENGTH */]: pixelStorei,
    [32878 /* UNPACK_IMAGE_HEIGHT */]: pixelStorei,
    [3316 /* UNPACK_SKIP_PIXELS */]: pixelStorei,
    [3315 /* UNPACK_SKIP_ROWS */]: pixelStorei,
    [32877 /* UNPACK_SKIP_IMAGES */]: pixelStorei,
    // Function-style setters
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160 /* FRAMEBUFFER */, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042 /* BLEND */) : gl.disable(3042 /* BLEND */),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      const separateModes = typeof args === "number" ? [args, args] : args;
      gl.blendEquationSeparate(...separateModes);
    },
    blendFunc: (gl, args) => {
      const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...separateFuncs);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884 /* CULL_FACE */) : gl.disable(2884 /* CULL_FACE */),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929 /* DEPTH_TEST */) : gl.disable(2929 /* DEPTH_TEST */),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024 /* DITHER */) : gl.disable(3024 /* DITHER */),
    derivativeHint: (gl, value) => {
      gl.hint(35723 /* FRAGMENT_SHADER_DERIVATIVE_HINT */, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170 /* GENERATE_MIPMAP_HINT */, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823 /* POLYGON_OFFSET_FILL */) : gl.disable(32823 /* POLYGON_OFFSET_FILL */),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089 /* SCISSOR_TEST */) : gl.disable(3089 /* SCISSOR_TEST */),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960 /* STENCIL_TEST */) : gl.disable(2960 /* STENCIL_TEST */),
    stencilMask: (gl, value) => {
      value = isArray(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028 /* FRONT */, mask);
      gl.stencilMaskSeparate(1029 /* BACK */, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028 /* FRONT */, func, ref, mask);
      gl.stencilFuncSeparate(1029 /* BACK */, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028 /* FRONT */, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029 /* BACK */, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache) => gl.blendEquationSeparate(
      getValue(32777 /* BLEND_EQUATION_RGB */, values, cache),
      getValue(34877 /* BLEND_EQUATION_ALPHA */, values, cache)
    ),
    blendFunc: (gl, values, cache) => gl.blendFuncSeparate(
      getValue(32969 /* BLEND_SRC_RGB */, values, cache),
      getValue(32968 /* BLEND_DST_RGB */, values, cache),
      getValue(32971 /* BLEND_SRC_ALPHA */, values, cache),
      getValue(32970 /* BLEND_DST_ALPHA */, values, cache)
    ),
    polygonOffset: (gl, values, cache) => gl.polygonOffset(
      getValue(32824 /* POLYGON_OFFSET_FACTOR */, values, cache),
      getValue(10752 /* POLYGON_OFFSET_UNITS */, values, cache)
    ),
    sampleCoverage: (gl, values, cache) => gl.sampleCoverage(
      getValue(32938 /* SAMPLE_COVERAGE_VALUE */, values, cache),
      getValue(32939 /* SAMPLE_COVERAGE_INVERT */, values, cache)
    ),
    stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(
      1028 /* FRONT */,
      getValue(2962 /* STENCIL_FUNC */, values, cache),
      getValue(2967 /* STENCIL_REF */, values, cache),
      getValue(2963 /* STENCIL_VALUE_MASK */, values, cache)
    ),
    stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(
      1029 /* BACK */,
      getValue(34816 /* STENCIL_BACK_FUNC */, values, cache),
      getValue(36003 /* STENCIL_BACK_REF */, values, cache),
      getValue(36004 /* STENCIL_BACK_VALUE_MASK */, values, cache)
    ),
    stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(
      1028 /* FRONT */,
      getValue(2964 /* STENCIL_FAIL */, values, cache),
      getValue(2965 /* STENCIL_PASS_DEPTH_FAIL */, values, cache),
      getValue(2966 /* STENCIL_PASS_DEPTH_PASS */, values, cache)
    ),
    stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(
      1029 /* BACK */,
      getValue(34817 /* STENCIL_BACK_FAIL */, values, cache),
      getValue(34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */, values, cache),
      getValue(34819 /* STENCIL_BACK_PASS_DEPTH_PASS */, values, cache)
    )
  };
  var GL_HOOKED_SETTERS = {
    // GENERIC SETTERS
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    // SPECIFIC SETTERS
    useProgram: (update, value) => update({
      [35725 /* CURRENT_PROGRAM */]: value
    }),
    bindRenderbuffer: (update, target, value) => update({
      [36007 /* RENDERBUFFER_BINDING */]: value
    }),
    bindTransformFeedback: (update, target, value) => update({
      [36389 /* TRANSFORM_FEEDBACK_BINDING */]: value
    }),
    bindVertexArray: (update, value) => update({
      [34229 /* VERTEX_ARRAY_BINDING */]: value
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160 /* FRAMEBUFFER */:
          return update({
            [36006 /* DRAW_FRAMEBUFFER_BINDING */]: framebuffer,
            [36010 /* READ_FRAMEBUFFER_BINDING */]: framebuffer
          });
        case 36009 /* DRAW_FRAMEBUFFER */:
          return update({ [36006 /* DRAW_FRAMEBUFFER_BINDING */]: framebuffer });
        case 36008 /* READ_FRAMEBUFFER */:
          return update({ [36010 /* READ_FRAMEBUFFER_BINDING */]: framebuffer });
        default:
          return null;
      }
    },
    bindBuffer: (update, target, buffer) => {
      const pname = {
        [34962 /* ARRAY_BUFFER */]: [34964 /* ARRAY_BUFFER_BINDING */],
        [36662 /* COPY_READ_BUFFER */]: [36662 /* COPY_READ_BUFFER_BINDING */],
        [36663 /* COPY_WRITE_BUFFER */]: [36663 /* COPY_WRITE_BUFFER_BINDING */],
        [35051 /* PIXEL_PACK_BUFFER */]: [35053 /* PIXEL_PACK_BUFFER_BINDING */],
        [35052 /* PIXEL_UNPACK_BUFFER */]: [35055 /* PIXEL_UNPACK_BUFFER_BINDING */]
      }[target];
      if (pname) {
        return update({ [pname]: buffer });
      }
      return { valueChanged: true };
    },
    blendColor: (update, r, g, b, a) => update({
      [32773 /* BLEND_COLOR */]: new Float32Array([r, g, b, a])
    }),
    blendEquation: (update, mode) => update({
      [32777 /* BLEND_EQUATION_RGB */]: mode,
      [34877 /* BLEND_EQUATION_ALPHA */]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777 /* BLEND_EQUATION_RGB */]: modeRGB,
      [34877 /* BLEND_EQUATION_ALPHA */]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969 /* BLEND_SRC_RGB */]: src,
      [32968 /* BLEND_DST_RGB */]: dst,
      [32971 /* BLEND_SRC_ALPHA */]: src,
      [32970 /* BLEND_DST_ALPHA */]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969 /* BLEND_SRC_RGB */]: srcRGB,
      [32968 /* BLEND_DST_RGB */]: dstRGB,
      [32971 /* BLEND_SRC_ALPHA */]: srcAlpha,
      [32970 /* BLEND_DST_ALPHA */]: dstAlpha
    }),
    clearColor: (update, r, g, b, a) => update({
      [3106 /* COLOR_CLEAR_VALUE */]: new Float32Array([r, g, b, a])
    }),
    clearDepth: (update, depth) => update({
      [2931 /* DEPTH_CLEAR_VALUE */]: depth
    }),
    clearStencil: (update, s) => update({
      [2961 /* STENCIL_CLEAR_VALUE */]: s
    }),
    colorMask: (update, r, g, b, a) => update({
      [3107 /* COLOR_WRITEMASK */]: [r, g, b, a]
    }),
    cullFace: (update, mode) => update({
      [2885 /* CULL_FACE_MODE */]: mode
    }),
    depthFunc: (update, func) => update({
      [2932 /* DEPTH_FUNC */]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928 /* DEPTH_RANGE */]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930 /* DEPTH_WRITEMASK */]: mask
    }),
    frontFace: (update, face) => update({
      [2886 /* FRONT_FACE */]: face
    }),
    lineWidth: (update, width) => update({
      [2849 /* LINE_WIDTH */]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824 /* POLYGON_OFFSET_FACTOR */]: factor,
      [10752 /* POLYGON_OFFSET_UNITS */]: units
    }),
    sampleCoverage: (update, value, invert) => update({
      [32938 /* SAMPLE_COVERAGE_VALUE */]: value,
      [32939 /* SAMPLE_COVERAGE_INVERT */]: invert
    }),
    scissor: (update, x, y, width, height) => update({
      [3088 /* SCISSOR_BOX */]: new Int32Array([x, y, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968 /* STENCIL_WRITEMASK */]: mask,
      [36005 /* STENCIL_BACK_WRITEMASK */]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 /* FRONT */ ? 2968 /* STENCIL_WRITEMASK */ : 36005 /* STENCIL_BACK_WRITEMASK */]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962 /* STENCIL_FUNC */]: func,
      [2967 /* STENCIL_REF */]: ref,
      [2963 /* STENCIL_VALUE_MASK */]: mask,
      [34816 /* STENCIL_BACK_FUNC */]: func,
      [36003 /* STENCIL_BACK_REF */]: ref,
      [36004 /* STENCIL_BACK_VALUE_MASK */]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 /* FRONT */ ? 2962 /* STENCIL_FUNC */ : 34816 /* STENCIL_BACK_FUNC */]: func,
      [face === 1028 /* FRONT */ ? 2967 /* STENCIL_REF */ : 36003 /* STENCIL_BACK_REF */]: ref,
      [face === 1028 /* FRONT */ ? 2963 /* STENCIL_VALUE_MASK */ : 36004 /* STENCIL_BACK_VALUE_MASK */]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964 /* STENCIL_FAIL */]: fail,
      [2965 /* STENCIL_PASS_DEPTH_FAIL */]: zfail,
      [2966 /* STENCIL_PASS_DEPTH_PASS */]: zpass,
      [34817 /* STENCIL_BACK_FAIL */]: fail,
      [34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */]: zfail,
      [34819 /* STENCIL_BACK_PASS_DEPTH_PASS */]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 /* FRONT */ ? 2964 /* STENCIL_FAIL */ : 34817 /* STENCIL_BACK_FAIL */]: fail,
      [face === 1028 /* FRONT */ ? 2965 /* STENCIL_PASS_DEPTH_FAIL */ : 34818 /* STENCIL_BACK_PASS_DEPTH_FAIL */]: zfail,
      [face === 1028 /* FRONT */ ? 2966 /* STENCIL_PASS_DEPTH_PASS */ : 34819 /* STENCIL_BACK_PASS_DEPTH_PASS */]: zpass
    }),
    viewport: (update, x, y, width, height) => update({
      [2978 /* VIEWPORT */]: [x, y, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042 /* BLEND */]: isEnabled,
    [2884 /* CULL_FACE */]: isEnabled,
    [2929 /* DEPTH_TEST */]: isEnabled,
    [3024 /* DITHER */]: isEnabled,
    [32823 /* POLYGON_OFFSET_FILL */]: isEnabled,
    [32926 /* SAMPLE_ALPHA_TO_COVERAGE */]: isEnabled,
    [32928 /* SAMPLE_COVERAGE */]: isEnabled,
    [3089 /* SCISSOR_TEST */]: isEnabled,
    [2960 /* STENCIL_TEST */]: isEnabled,
    [35977 /* RASTERIZER_DISCARD */]: isEnabled
  };
  var NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
    // setter not intercepted
    34016 /* ACTIVE_TEXTURE */,
    36388 /* TRANSFORM_FEEDBACK_ACTIVE */,
    36387 /* TRANSFORM_FEEDBACK_PAUSED */,
    // setters bindBufferRange/bindBufferBase cannot be pruned based on cache
    35983 /* TRANSFORM_FEEDBACK_BUFFER_BINDING */,
    35368 /* UNIFORM_BUFFER_BINDING */,
    // states depending on VERTEX_ARRAY_BINDING
    34965 /* ELEMENT_ARRAY_BUFFER_BINDING */,
    // states depending on READ_FRAMEBUFFER_BINDING
    35739 /* IMPLEMENTATION_COLOR_READ_FORMAT */,
    35738 /* IMPLEMENTATION_COLOR_READ_TYPE */,
    // states depending on FRAMEBUFFER_BINDING
    3074 /* READ_BUFFER */,
    34853 /* DRAW_BUFFER0 */,
    34854 /* DRAW_BUFFER1 */,
    34855 /* DRAW_BUFFER2 */,
    34856 /* DRAW_BUFFER3 */,
    34857 /* DRAW_BUFFER4 */,
    34858 /* DRAW_BUFFER5 */,
    34859 /* DRAW_BUFFER6 */,
    34860 /* DRAW_BUFFER7 */,
    34861 /* DRAW_BUFFER8 */,
    34862 /* DRAW_BUFFER9 */,
    34863 /* DRAW_BUFFER10 */,
    34864 /* DRAW_BUFFER11 */,
    34865 /* DRAW_BUFFER12 */,
    34866 /* DRAW_BUFFER13 */,
    34867 /* DRAW_BUFFER14 */,
    34868 /* DRAW_BUFFER15 */,
    // states depending on ACTIVE_TEXTURE
    35097 /* SAMPLER_BINDING */,
    32873 /* TEXTURE_BINDING_2D */,
    35869 /* TEXTURE_BINDING_2D_ARRAY */,
    32874 /* TEXTURE_BINDING_3D */,
    34068 /* TEXTURE_BINDING_CUBE_MAP */
  ]);

  // src/context/parameters/unified-parameter-api.ts
  function setGLParameters(gl, parameters) {
    if (isObjectEmpty(parameters)) {
      return;
    }
    const compositeSetters = {};
    for (const key in parameters) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, parameters[key], glConstant);
        }
      }
    }
    const cache = gl.state && gl.state.cache;
    if (cache) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, parameters, cache);
      }
    }
  }
  function getGLParameters(gl, parameters = GL_PARAMETER_DEFAULTS) {
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetGLParameters(gl) {
    setGLParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // src/context/state-tracker/deep-array-equal.ts
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
      for (let i = 0; i < x.length; ++i) {
        if (x[i] !== y[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // src/context/state-tracker/track-context-state.ts
  var GLState = class {
    gl;
    program = null;
    stateStack = [];
    enable = true;
    cache;
    log;
    constructor(gl, {
      copyState = false,
      // Copy cache from params (slow) or initialize from WebGL defaults (fast)
      log: log9 = () => {
      }
      // Logging function, called when gl parameter change calls are actually issued
    } = {}) {
      this.gl = gl;
      this.cache = copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log9;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push(values = {}) {
      this.stateStack.push({});
    }
    pop() {
      (0, import_core.assert)(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setGLParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    /**
    // interceptor for context set functions - update our cache and our stack
    // values (Object) - the key values for this setter
     * @param values
     * @returns
     */
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
      for (const key in values) {
        (0, import_core.assert)(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return { valueChanged, oldValue };
    }
  };
  function getContextState(gl) {
    return gl.state;
  }
  function trackContextState(gl, options) {
    const { enable: enable2 = true, copyState } = options;
    (0, import_core.assert)(copyState !== void 0);
    if (!gl.state) {
      gl.state = new GLState(gl, { copyState });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    const glState = getContextState(gl);
    glState.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    let glState = getContextState(gl);
    if (!glState) {
      trackContextState(gl, { copyState: false });
      glState = getContextState(gl);
    }
    glState.push();
  }
  function popContextState(gl) {
    const glState = getContextState(gl);
    (0, import_core.assert)(glState);
    glState.pop();
  }
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get(pname) {
      if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
        return originalGetterFunc(pname);
      }
      const glState = getContextState(gl);
      if (!(pname in glState.cache)) {
        glState.cache[pname] = originalGetterFunc(pname);
      }
      return glState.enable ? (
        // Call the getter the params so that it can e.g. serve from a cache
        glState.cache[pname]
      ) : (
        // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
        originalGetterFunc(pname)
      );
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-from-cache`,
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    if (!gl[functionName]) {
      return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set(...params) {
      const glState = getContextState(gl);
      const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-to-cache`,
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      const glState = getContextState(gl);
      if (glState.program !== handle) {
        originalUseProgram(handle);
        glState.program = handle;
      }
    };
  }

  // src/context/helpers/create-browser-context.ts
  var DEFAULT_CONTEXT_PROPS = {
    powerPreference: "high-performance",
    // After all, most apps are using WebGL for performance reasons
    // eslint-disable-next-line no-console
    onContextLost: () => console.error("WebGL context lost"),
    // eslint-disable-next-line no-console
    onContextRestored: () => console.info("WebGL context restored")
  };
  function createBrowserContext(canvas, props) {
    props = { ...DEFAULT_CONTEXT_PROPS, ...props };
    let errorMessage = null;
    const onCreateError = (error) => errorMessage = error.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    let gl = null;
    gl ||= canvas.getContext("webgl2", props);
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      throw new Error(`Failed to create WebGL context: ${errorMessage || "Unknown error"}`);
    }
    if (props.onContextLost) {
      const { onContextLost } = props;
      canvas.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
    }
    if (props.onContextRestored) {
      const { onContextRestored } = props;
      canvas.addEventListener(
        "webglcontextrestored",
        (event) => onContextRestored(event),
        false
      );
    }
    return gl;
  }

  // src/context/helpers/webgl-extensions.ts
  function getWebGLExtension(gl, name, extensions) {
    if (extensions[name] === void 0) {
      extensions[name] = gl.getExtension(name) || null;
    }
    return extensions[name];
  }

  // src/adapter/device-helpers/webgl-device-info.ts
  function getDeviceInfo(gl, extensions) {
    const vendorMasked = gl.getParameter(7936 /* VENDOR */);
    const rendererMasked = gl.getParameter(7937 /* RENDERER */);
    getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
    const ext = extensions.WEBGL_debug_renderer_info;
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936 /* VENDOR */);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937 /* RENDERER */);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    const version = gl.getParameter(7938 /* VERSION */);
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    const shadingLanguage = "glsl";
    const shadingLanguageVersion = 300;
    return {
      type: "webgl",
      gpu,
      gpuType,
      gpuBackend,
      vendor,
      renderer,
      version,
      shadingLanguage,
      shadingLanguageVersion
    };
  }
  function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
      return "nvidia";
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
      return "intel";
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
      return "apple";
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
      return "amd";
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "software";
    }
    return "unknown";
  }
  function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
      return "metal";
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
      return "opengl";
    }
    return "unknown";
  }
  function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "cpu";
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch (gpuVendor) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }

  // src/adapter/device-helpers/webgl-device-features.ts
  var import_core3 = __toESM(require_core(), 1);

  // src/adapter/converters/texture-formats.ts
  var import_core2 = __toESM(require_core(), 1);

  // src/adapter/converters/vertex-formats.ts
  function getGLFromVertexType(dataType) {
    switch (dataType) {
      case "uint8":
        return 5121 /* UNSIGNED_BYTE */;
      case "sint8":
        return 5120 /* BYTE */;
      case "unorm8":
        return 5121 /* UNSIGNED_BYTE */;
      case "snorm8":
        return 5120 /* BYTE */;
      case "uint16":
        return 5123 /* UNSIGNED_SHORT */;
      case "sint16":
        return 5122 /* SHORT */;
      case "unorm16":
        return 5123 /* UNSIGNED_SHORT */;
      case "snorm16":
        return 5122 /* SHORT */;
      case "uint32":
        return 5125 /* UNSIGNED_INT */;
      case "sint32":
        return 5124 /* INT */;
      case "float16":
        return 5131 /* HALF_FLOAT */;
      case "float32":
        return 5126 /* FLOAT */;
    }
    throw new Error(String(dataType));
  }

  // src/adapter/converters/texture-formats.ts
  var texture_compression_bc = "texture-compression-bc";
  var texture_compression_astc = "texture-compression-astc";
  var texture_compression_etc2 = "texture-compression-etc2";
  var texture_compression_etc1_webgl = "texture-compression-etc1-webgl";
  var texture_compression_pvrtc_webgl = "texture-compression-pvrtc-webgl";
  var texture_compression_atc_webgl = "texture-compression-atc-webgl";
  var float32_renderable = "float32-renderable-webgl";
  var float16_renderable = "float16-renderable-webgl";
  var rgb9e5ufloat_renderable = "rgb9e5ufloat_renderable-webgl";
  var snorm8_renderable = "snorm8-renderable-webgl";
  var norm16_renderable = "norm16-renderable-webgl";
  var snorm16_renderable = "snorm16-renderable-webgl";
  var float32_filterable = "float32-filterable";
  var float16_filterable = "float16-filterable-webgl";
  var X_S3TC = "WEBGL_compressed_texture_s3tc";
  var X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
  var X_RGTC = "EXT_texture_compression_rgtc";
  var X_BPTC = "EXT_texture_compression_bptc";
  var X_ETC2 = "WEBGL_compressed_texture_etc";
  var X_ASTC = "WEBGL_compressed_texture_astc";
  var X_ETC1 = "WEBGL_compressed_texture_etc1";
  var X_PVRTC = "WEBGL_compressed_texture_pvrtc";
  var X_ATC = "WEBGL_compressed_texture_atc";
  var EXT_texture_norm16 = "EXT_texture_norm16";
  var EXT_render_snorm = "EXT_render_snorm";
  var EXT_color_buffer_float = "EXT_color_buffer_float";
  var TEXTURE_FEATURES = {
    "float32-renderable-webgl": ["EXT_color_buffer_float"],
    "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
    "rgb9e5ufloat_renderable-webgl": ["WEBGL_render_shared_exponent"],
    "snorm8-renderable-webgl": [EXT_render_snorm],
    "norm16-renderable-webgl": [EXT_texture_norm16],
    "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
    "float32-filterable": ["OES_texture_float_linear"],
    "float16-filterable-webgl": ["OES_texture_half_float_linear"],
    "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
    "texture-blend-float-webgl": ["EXT_float_blend"],
    "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
    // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
    // 'texture-compression-bc3-webgl': [X_S3TC],
    "texture-compression-bc5-webgl": [X_RGTC],
    "texture-compression-bc7-webgl": [X_BPTC],
    "texture-compression-etc2": [X_ETC2],
    "texture-compression-astc": [X_ASTC],
    "texture-compression-etc1-webgl": [X_ETC1],
    "texture-compression-pvrtc-webgl": [X_PVRTC],
    "texture-compression-atc-webgl": [X_ATC]
  };
  function isTextureFeature(feature) {
    return feature in TEXTURE_FEATURES;
  }
  function checkTextureFeature(gl, feature, extensions) {
    const textureExtensions = TEXTURE_FEATURES[feature] || [];
    return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
  }
  var TEXTURE_FORMATS = {
    // Unsized formats that leave the precision up to the driver. TODO - Fix bpp constants
    "rgb8unorm-unsized": {
      gl: 6407 /* RGB */,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6407 /* RGB */,
      types: [5121 /* UNSIGNED_BYTE */, 33635 /* UNSIGNED_SHORT_5_6_5 */]
    },
    "rgba8unorm-unsized": {
      gl: 6408 /* RGBA */,
      b: 4,
      c: 2,
      bpp: 4,
      dataFormat: 6408 /* RGBA */,
      types: [5121 /* UNSIGNED_BYTE */, 32819 /* UNSIGNED_SHORT_4_4_4_4 */, 32820 /* UNSIGNED_SHORT_5_5_5_1 */]
    },
    // 'r8unorm-unsized': {gl: GL.LUMINANCE, b: 4, c: 2, bpp: 4},
    // 'rgb8unorm-srgb-unsized': {gl: GL.SRGB_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
    // 'rgba8unorm-srgb-unsized': {gl: GL.SRGB_ALPHA_EXT, b: 4, c: 2, bpp: 4, gl1Ext: SRGB},
    // 8-bit formats
    "r8unorm": { gl: 33321 /* R8 */, b: 1, c: 1, rb: true },
    "r8snorm": { gl: 36756 /* R8_SNORM */, b: 1, c: 1, render: snorm8_renderable },
    "r8uint": { gl: 33330 /* R8UI */, b: 1, c: 1, rb: true },
    "r8sint": { gl: 33329 /* R8I */, b: 1, c: 1, rb: true },
    // 16-bit formats
    "rg8unorm": { gl: 33323 /* RG8 */, b: 2, c: 2, rb: true },
    "rg8snorm": { gl: 36757 /* RG8_SNORM */, b: 2, c: 2, render: snorm8_renderable },
    "rg8uint": { gl: 33336 /* RG8UI */, b: 2, c: 2, rb: true },
    "rg8sint": { gl: 33335 /* RG8I */, b: 2, c: 2, rb: true },
    "r16uint": { gl: 33332 /* R16UI */, b: 2, c: 1, rb: true },
    "r16sint": { gl: 33331 /* R16I */, b: 2, c: 1, rb: true },
    "r16float": { gl: 33325 /* R16F */, b: 2, c: 1, render: float16_renderable, filter: "float16-filterable-webgl", rb: true },
    "r16unorm-webgl": { gl: 33322 /* R16_EXT */, b: 2, c: 1, f: norm16_renderable, rb: true },
    "r16snorm-webgl": { gl: 36760 /* R16_SNORM_EXT */, b: 2, c: 1, f: snorm16_renderable },
    // Packed 16-bit formats
    "rgba4unorm-webgl": { gl: 32854 /* RGBA4 */, b: 2, c: 4, wgpu: false, rb: true },
    "rgb565unorm-webgl": { gl: 36194 /* RGB565 */, b: 2, c: 4, wgpu: false, rb: true },
    "rgb5a1unorm-webgl": { gl: 32855 /* RGB5_A1 */, b: 2, c: 4, wgpu: false, rb: true },
    // 24-bit formats
    "rgb8unorm-webgl": { gl: 32849 /* RGB8 */, b: 3, c: 3, wgpu: false },
    "rgb8snorm-webgl": { gl: 36758 /* RGB8_SNORM */, b: 3, c: 3, wgpu: false },
    // 32-bit formats  
    "rgba8unorm": { gl: 32856 /* RGBA8 */, b: 4, c: 2, bpp: 4 },
    "rgba8unorm-srgb": { gl: 35907 /* SRGB8_ALPHA8 */, b: 4, c: 4, bpp: 4 },
    "rgba8snorm": { gl: 36759 /* RGBA8_SNORM */, b: 4, c: 4, render: snorm8_renderable },
    "rgba8uint": { gl: 36220 /* RGBA8UI */, b: 4, c: 4, bpp: 4 },
    "rgba8sint": { gl: 36238 /* RGBA8I */, b: 4, c: 4, bpp: 4 },
    // reverse colors, webgpu only
    "bgra8unorm": { b: 4, c: 4 },
    "bgra8unorm-srgb": { b: 4, c: 4 },
    "rg16uint": { gl: 33338 /* RG16UI */, b: 4, c: 1, bpp: 4 },
    "rg16sint": { gl: 33337 /* RG16I */, b: 4, c: 2, bpp: 4 },
    // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
    "rg16float": { gl: 33327 /* RG16F */, bpp: 4, b: 4, c: 2, render: float16_renderable, filter: float16_filterable, rb: true },
    "rg16unorm-webgl": { gl: 33324 /* RG16_EXT */, b: 2, c: 2, render: norm16_renderable },
    "rg16snorm-webgl": { gl: 36761 /* RG16_SNORM_EXT */, b: 2, c: 2, render: snorm16_renderable },
    "r32uint": { gl: 33334 /* R32UI */, b: 4, c: 1, bpp: 4, rb: true },
    "r32sint": { gl: 33333 /* R32I */, b: 4, c: 1, bpp: 4, rb: true },
    "r32float": { gl: 33326 /* R32F */, bpp: 4, b: 4, c: 1, render: float32_renderable, filter: float32_filterable },
    // Packed 32-bit formats
    "rgb9e5ufloat": { gl: 35901 /* RGB9_E5 */, b: 4, c: 3, p: 1, render: rgb9e5ufloat_renderable },
    // , filter: true},
    "rg11b10ufloat": { gl: 35898 /* R11F_G11F_B10F */, b: 4, c: 3, p: 1, render: float32_renderable, rb: true },
    "rgb10a2unorm": { gl: 32857 /* RGB10_A2 */, b: 4, c: 4, p: 1, rb: true },
    "rgb10a2uint-webgl": { b: 4, c: 4, gl: 36975 /* RGB10_A2UI */, p: 1, wgpu: false, bpp: 4, rb: true },
    // 48-bit formats
    "rgb16unorm-webgl": { gl: 32852 /* RGB16_EXT */, b: 2, c: 3, f: norm16_renderable },
    // rgb not renderable
    "rgb16snorm-webgl": { gl: 36762 /* RGB16_SNORM_EXT */, b: 2, c: 3, f: norm16_renderable },
    // rgb not renderable
    // 64-bit formats
    "rg32uint": { gl: 33340 /* RG32UI */, b: 8, c: 2, rb: true },
    "rg32sint": { gl: 33339 /* RG32I */, b: 8, c: 2, rb: true },
    "rg32float": { gl: 33328 /* RG32F */, b: 8, c: 2, render: float32_renderable, filter: float32_filterable, rb: true },
    "rgba16uint": { gl: 36214 /* RGBA16UI */, b: 8, c: 4, rb: true },
    "rgba16sint": { gl: 36232 /* RGBA16I */, b: 8, c: 4, rb: true },
    "rgba16float": { gl: 34842 /* RGBA16F */, b: 8, c: 4, render: float16_renderable, filter: float16_filterable },
    "rgba16unorm-webgl": { gl: 32859 /* RGBA16_EXT */, b: 2, c: 4, render: norm16_renderable, rb: true },
    "rgba16snorm-webgl": { gl: 36763 /* RGBA16_SNORM_EXT */, b: 2, c: 4, render: snorm16_renderable },
    // 96-bit formats (deprecated!)
    "rgb32float-webgl": {
      gl: 34837 /* RGB32F */,
      render: float32_renderable,
      filter: float32_filterable,
      gl2ext: EXT_color_buffer_float,
      dataFormat: 6407 /* RGB */,
      types: [5126 /* FLOAT */]
    },
    // 128-bit formats
    "rgba32uint": { gl: 36208 /* RGBA32UI */, b: 16, c: 4, rb: true },
    "rgba32sint": { gl: 36226 /* RGBA32I */, b: 16, c: 4, rb: true },
    "rgba32float": { gl: 34836 /* RGBA32F */, b: 16, c: 4, render: float32_renderable, filter: float32_filterable, rb: true },
    // Depth and stencil formats
    "stencil8": { gl: 36168 /* STENCIL_INDEX8 */, b: 1, c: 1, attachment: 36128 /* STENCIL_ATTACHMENT */, rb: true },
    // 8 stencil bits
    "depth16unorm": {
      gl: 33189 /* DEPTH_COMPONENT16 */,
      b: 2,
      c: 1,
      attachment: 36096 /* DEPTH_ATTACHMENT */,
      dataFormat: 6402 /* DEPTH_COMPONENT */,
      types: [5123 /* UNSIGNED_SHORT */],
      rb: true
    },
    // 16 depth bits
    "depth24plus": {
      gl: 33190 /* DEPTH_COMPONENT24 */,
      b: 3,
      c: 1,
      attachment: 36096 /* DEPTH_ATTACHMENT */,
      dataFormat: 6402 /* DEPTH_COMPONENT */,
      types: [5125 /* UNSIGNED_INT */]
    },
    "depth32float": {
      gl: 36012 /* DEPTH_COMPONENT32F */,
      b: 4,
      c: 1,
      attachment: 36096 /* DEPTH_ATTACHMENT */,
      dataFormat: 6402 /* DEPTH_COMPONENT */,
      types: [5126 /* FLOAT */],
      rb: true
    },
    // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
    "depth24plus-stencil8": {
      gl: 35056 /* DEPTH24_STENCIL8 */,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306 /* DEPTH_STENCIL_ATTACHMENT */,
      rb: true,
      depthTexture: true,
      dataFormat: 34041 /* DEPTH_STENCIL */,
      types: [34042 /* UNSIGNED_INT_24_8 */]
    },
    // "depth24unorm-stencil8" feature
    "depth24unorm-stencil8": {
      gl: 35056 /* DEPTH24_STENCIL8 */,
      b: 4,
      c: 2,
      p: 1,
      attachment: 33306 /* DEPTH_STENCIL_ATTACHMENT */,
      dataFormat: 34041 /* DEPTH_STENCIL */,
      types: [34042 /* UNSIGNED_INT_24_8 */],
      rb: true
    },
    // "depth32float-stencil8" feature - TODO below is render buffer only?
    "depth32float-stencil8": {
      gl: 36013 /* DEPTH32F_STENCIL8 */,
      b: 5,
      c: 2,
      p: 1,
      attachment: 33306 /* DEPTH_STENCIL_ATTACHMENT */,
      dataFormat: 34041 /* DEPTH_STENCIL */,
      types: [36269 /* FLOAT_32_UNSIGNED_INT_24_8_REV */],
      rb: true
    },
    // BC compressed formats: check device.features.has("texture-compression-bc");
    "bc1-rgb-unorm-webgl": { gl: 33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */, x: X_S3TC, f: texture_compression_bc },
    "bc1-rgb-unorm-srgb-webgl": { gl: 35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc1-rgba-unorm": { gl: 33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */, x: X_S3TC, f: texture_compression_bc },
    "bc1-rgba-unorm-srgb": { gl: 35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc2-rgba-unorm": { gl: 33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */, x: X_S3TC, f: texture_compression_bc },
    "bc2-rgba-unorm-srgb": { gl: 35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc3-rgba-unorm": { gl: 33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */, x: X_S3TC, f: texture_compression_bc },
    "bc3-rgba-unorm-srgb": { gl: 35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */, x: X_S3TC_SRGB, f: texture_compression_bc },
    "bc4-r-unorm": { gl: 36283 /* COMPRESSED_RED_RGTC1_EXT */, x: X_RGTC, f: texture_compression_bc },
    "bc4-r-snorm": { gl: 36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */, x: X_RGTC, f: texture_compression_bc },
    "bc5-rg-unorm": { gl: 36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */, x: X_RGTC, f: texture_compression_bc },
    "bc5-rg-snorm": { gl: 36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */, x: X_RGTC, f: texture_compression_bc },
    "bc6h-rgb-ufloat": { gl: 36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */, x: X_BPTC, f: texture_compression_bc },
    "bc6h-rgb-float": { gl: 36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */, x: X_BPTC, f: texture_compression_bc },
    "bc7-rgba-unorm": { gl: 36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */, x: X_BPTC, f: texture_compression_bc },
    "bc7-rgba-unorm-srgb": { gl: 36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */, x: X_BPTC, f: texture_compression_bc },
    // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
    // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
    "etc2-rgb8unorm": { gl: 37492 /* COMPRESSED_RGB8_ETC2 */, f: texture_compression_etc2 },
    "etc2-rgb8unorm-srgb": { gl: 37494 /* COMPRESSED_SRGB8_ETC2 */, f: texture_compression_etc2 },
    "etc2-rgb8a1unorm": { gl: 37496 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */, f: texture_compression_etc2 },
    "etc2-rgb8a1unorm-srgb": { gl: 37497 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */, f: texture_compression_etc2 },
    "etc2-rgba8unorm": { gl: 37493 /* COMPRESSED_RGBA8_ETC2_EAC */, f: texture_compression_etc2 },
    "etc2-rgba8unorm-srgb": { gl: 37495 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */, f: texture_compression_etc2 },
    "eac-r11unorm": { gl: 37488 /* COMPRESSED_R11_EAC */, f: texture_compression_etc2 },
    "eac-r11snorm": { gl: 37489 /* COMPRESSED_SIGNED_R11_EAC */, f: texture_compression_etc2 },
    "eac-rg11unorm": { gl: 37490 /* COMPRESSED_RG11_EAC */, f: texture_compression_etc2 },
    "eac-rg11snorm": { gl: 37491 /* COMPRESSED_SIGNED_RG11_EAC */, f: texture_compression_etc2 },
    // X_ASTC compressed formats: device.features.has("texture-compression-astc")
    "astc-4x4-unorm": { gl: 37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */, f: texture_compression_astc },
    "astc-4x4-unorm-srgb": { gl: 37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */, f: texture_compression_astc },
    "astc-5x4-unorm": { gl: 37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */, f: texture_compression_astc },
    "astc-5x4-unorm-srgb": { gl: 37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */, f: texture_compression_astc },
    "astc-5x5-unorm": { gl: 37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */, f: texture_compression_astc },
    "astc-5x5-unorm-srgb": { gl: 37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */, f: texture_compression_astc },
    "astc-6x5-unorm": { gl: 37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */, f: texture_compression_astc },
    "astc-6x5-unorm-srgb": { gl: 37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */, f: texture_compression_astc },
    "astc-6x6-unorm": { gl: 37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */, f: texture_compression_astc },
    "astc-6x6-unorm-srgb": { gl: 37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */, f: texture_compression_astc },
    "astc-8x5-unorm": { gl: 37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */, f: texture_compression_astc },
    "astc-8x5-unorm-srgb": { gl: 37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */, f: texture_compression_astc },
    "astc-8x6-unorm": { gl: 37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */, f: texture_compression_astc },
    "astc-8x6-unorm-srgb": { gl: 37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */, f: texture_compression_astc },
    "astc-8x8-unorm": { gl: 37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */, f: texture_compression_astc },
    "astc-8x8-unorm-srgb": { gl: 37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */, f: texture_compression_astc },
    "astc-10x5-unorm": { gl: 37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */, f: texture_compression_astc },
    "astc-10x5-unorm-srgb": { gl: 37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */, f: texture_compression_astc },
    "astc-10x6-unorm": { gl: 37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */, f: texture_compression_astc },
    "astc-10x6-unorm-srgb": { gl: 37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */, f: texture_compression_astc },
    "astc-10x8-unorm": { gl: 37818 /* COMPRESSED_RGBA_ASTC_10x8_KHR */, f: texture_compression_astc },
    "astc-10x8-unorm-srgb": { gl: 37850 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR */, f: texture_compression_astc },
    "astc-10x10-unorm": { gl: 37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */, f: texture_compression_astc },
    "astc-10x10-unorm-srgb": { gl: 37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */, f: texture_compression_astc },
    "astc-12x10-unorm": { gl: 37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */, f: texture_compression_astc },
    "astc-12x10-unorm-srgb": { gl: 37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */, f: texture_compression_astc },
    "astc-12x12-unorm": { gl: 37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */, f: texture_compression_astc },
    "astc-12x12-unorm-srgb": { gl: 37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */, f: texture_compression_astc },
    // WEBGL_compressed_texture_pvrtc
    "pvrtc-rgb4unorm-webgl": { gl: 35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */, f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba4unorm-webgl": { gl: 35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */, f: texture_compression_pvrtc_webgl },
    "pvrtc-rbg2unorm-webgl": { gl: 35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */, f: texture_compression_pvrtc_webgl },
    "pvrtc-rgba2unorm-webgl": { gl: 35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */, f: texture_compression_pvrtc_webgl },
    // WEBGL_compressed_texture_etc1
    "etc1-rbg-unorm-webgl": { gl: 36196 /* COMPRESSED_RGB_ETC1_WEBGL */, f: texture_compression_etc1_webgl },
    // WEBGL_compressed_texture_atc
    "atc-rgb-unorm-webgl": { gl: 35986 /* COMPRESSED_RGB_ATC_WEBGL */, f: texture_compression_atc_webgl },
    "atc-rgba-unorm-webgl": { gl: 35986 /* COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL */, f: texture_compression_atc_webgl },
    "atc-rgbai-unorm-webgl": { gl: 34798 /* COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL */, f: texture_compression_atc_webgl }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403 /* RED */]: 1,
    [36244 /* RED_INTEGER */]: 1,
    [33319 /* RG */]: 2,
    [33320 /* RG_INTEGER */]: 2,
    [6407 /* RGB */]: 3,
    [36248 /* RGB_INTEGER */]: 3,
    [6408 /* RGBA */]: 4,
    [36249 /* RGBA_INTEGER */]: 4,
    [6402 /* DEPTH_COMPONENT */]: 1,
    [34041 /* DEPTH_STENCIL */]: 1,
    [6406 /* ALPHA */]: 1,
    [6409 /* LUMINANCE */]: 1,
    [6410 /* LUMINANCE_ALPHA */]: 2
  };
  var TYPE_SIZES = {
    [5126 /* FLOAT */]: 4,
    [5125 /* UNSIGNED_INT */]: 4,
    [5124 /* INT */]: 4,
    [5123 /* UNSIGNED_SHORT */]: 2,
    [5122 /* SHORT */]: 2,
    [5131 /* HALF_FLOAT */]: 2,
    [5120 /* BYTE */]: 1,
    [5121 /* UNSIGNED_BYTE */]: 1
  };
  function isTextureFormatSupported(gl, format, extensions) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl === void 0) {
      return false;
    }
    const extension = info.x || info.gl2ext;
    if (extension) {
      return Boolean(getWebGLExtension(gl, extension, extensions));
    }
    return true;
  }
  function isRenderbufferFormatSupported(gl, format, extensions) {
    return isTextureFormatSupported(gl, format, extensions) && TEXTURE_FORMATS[format]?.rb;
  }
  function convertGLToTextureFormat(format) {
    if (typeof format === "string") {
      return format;
    }
    const entry = Object.entries(TEXTURE_FORMATS).find(([, entry2]) => entry2.gl === format);
    if (!entry) {
      throw new Error(`Unknown texture format ${format}`);
    }
    return entry[0];
  }
  function convertTextureFormatToGL(format) {
    const formatInfo = TEXTURE_FORMATS[format];
    const webglFormat = formatInfo?.gl;
    if (webglFormat === void 0) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
  }
  function isTextureFormatFilterable(gl, format, extensions) {
    if (!isTextureFormatSupported(gl, format, extensions)) {
      return false;
    }
    if (format.startsWith("depth") || format.startsWith("stencil")) {
      return false;
    }
    try {
      const decoded = (0, import_core2.decodeTextureFormat)(format);
      if (decoded.signed) {
        return false;
      }
    } catch {
      return false;
    }
    if (format.endsWith("32float")) {
      return Boolean(getWebGLExtension(gl, "OES_texture_float_linear, extensions", extensions));
    }
    if (format.endsWith("16float")) {
      return Boolean(getWebGLExtension(gl, "OES_texture_half_float_linear, extensions", extensions));
    }
    return true;
  }
  function isTextureFormatRenderable(gl, format, extensions) {
    if (!isTextureFormatSupported(gl, format, extensions)) {
      return false;
    }
    if (typeof format === "number") {
      return false;
    }
    return true;
  }
  function getWebGLTextureParameters(format) {
    const formatData = TEXTURE_FORMATS[format];
    const webglFormat = convertTextureFormatToGL(format);
    const decoded = (0, import_core2.decodeTextureFormat)(format);
    return {
      format: webglFormat,
      dataFormat: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.format, decoded.integer, decoded.normalized, webglFormat),
      // depth formats don't have a type
      type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121 /* UNSIGNED_BYTE */,
      // @ts-expect-error
      compressed: decoded.compressed
    };
  }
  function getDepthStencilAttachmentWebGL(format) {
    const info = TEXTURE_FORMATS[format];
    if (!info?.attachment) {
      throw new Error(`${format} is not a depth stencil format`);
    }
    return info.attachment;
  }
  function getTextureFormatBytesPerPixel(format) {
    const params = getWebGLTextureParameters(format);
    const channels = DATA_FORMAT_CHANNELS[params.dataFormat] || 4;
    const channelSize = TYPE_SIZES[params.type] || 1;
    return channels * channelSize;
  }
  function getWebGLPixelDataFormat(dataFormat, integer, normalized, format) {
    if (format === 6408 /* RGBA */ || format === 6407 /* RGB */) {
      return format;
    }
    switch (dataFormat) {
      case "r":
        return integer && !normalized ? 36244 /* RED_INTEGER */ : 6403 /* RED */;
      case "rg":
        return integer && !normalized ? 33320 /* RG_INTEGER */ : 33319 /* RG */;
      case "rgb":
        return integer && !normalized ? 36248 /* RGB_INTEGER */ : 6407 /* RGB */;
      case "rgba":
        return integer && !normalized ? 36249 /* RGBA_INTEGER */ : 6408 /* RGBA */;
      default:
        return 6408 /* RGBA */;
    }
  }

  // src/adapter/device-helpers/webgl-device-features.ts
  var WEBGL_FEATURES = {
    // optional WebGPU features
    "depth-clip-control": "EXT_depth_clamp",
    // TODO these seem subtly different
    // 'timestamp-query' // GPUQueryType "timestamp-query"
    // "indirect-first-instance"
    // Textures are handled by getTextureFeatures()
    // 'depth24unorm-stencil8' // GPUTextureFormat 'depth24unorm-stencil8'
    // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
    // optional WebGL features
    "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
    "compilation-status-async-webgl": "KHR_parallel_shader_compile",
    "polygon-mode-webgl": "WEBGL_polygon_mode",
    "provoking-vertex-webgl": "WEBGL_provoking_vertex",
    "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
    "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
    "shader-conservative-depth-webgl": "EXT_conservative_depth"
    // Textures are handled by getTextureFeatures()
  };
  var WebGLDeviceFeatures = class extends import_core3.DeviceFeatures {
    gl;
    extensions;
    testedFeatures = /* @__PURE__ */ new Set();
    constructor(gl, extensions, disabledFeatures) {
      super([], disabledFeatures);
      this.gl = gl;
      this.extensions = extensions;
      getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
    }
    *[Symbol.iterator]() {
      const features = this.getFeatures();
      for (const feature of features) {
        if (this.has(feature)) {
          yield feature;
        }
      }
      return [];
    }
    has(feature) {
      if (this.disabledFeatures[feature]) {
        return false;
      }
      if (!this.testedFeatures.has(feature)) {
        this.testedFeatures.add(feature);
        if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
          this.features.add(feature);
        }
        if (this.getWebGLFeature(feature)) {
          this.features.add(feature);
        }
      }
      return this.features.has(feature);
    }
    // FOR DEVICE
    initializeFeatures() {
      const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
      for (const feature of features) {
        this.has(feature);
      }
    }
    // IMPLEMENTATION
    getFeatures() {
      return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
    }
    /** Extract all WebGL features */
    getWebGLFeature(feature) {
      const featureInfo = WEBGL_FEATURES[feature];
      const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
      return isSupported;
    }
  };

  // src/adapter/device-helpers/webgl-device-limits.ts
  var import_core4 = __toESM(require_core(), 1);
  var WebGLDeviceLimits = class extends import_core4.DeviceLimits {
    get maxTextureDimension1D() {
      return 0;
    }
    // WebGL does not support 1D textures
    get maxTextureDimension2D() {
      return this.getParameter(3379 /* MAX_TEXTURE_SIZE */);
    }
    get maxTextureDimension3D() {
      return this.getParameter(32883 /* MAX_3D_TEXTURE_SIZE */);
    }
    get maxTextureArrayLayers() {
      return this.getParameter(35071 /* MAX_ARRAY_TEXTURE_LAYERS */);
    }
    get maxBindGroups() {
      return 0;
    }
    get maxDynamicUniformBuffersPerPipelineLayout() {
      return 0;
    }
    // TBD
    get maxDynamicStorageBuffersPerPipelineLayout() {
      return 0;
    }
    // TBD
    get maxSampledTexturesPerShaderStage() {
      return this.getParameter(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */);
    }
    // ) TBD
    get maxSamplersPerShaderStage() {
      return this.getParameter(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */);
    }
    get maxStorageBuffersPerShaderStage() {
      return 0;
    }
    // TBD
    get maxStorageTexturesPerShaderStage() {
      return 0;
    }
    // TBD
    get maxUniformBuffersPerShaderStage() {
      return this.getParameter(35375 /* MAX_UNIFORM_BUFFER_BINDINGS */);
    }
    get maxUniformBufferBindingSize() {
      return this.getParameter(35376 /* MAX_UNIFORM_BLOCK_SIZE */);
    }
    get maxStorageBufferBindingSize() {
      return 0;
    }
    get minUniformBufferOffsetAlignment() {
      return this.getParameter(35380 /* UNIFORM_BUFFER_OFFSET_ALIGNMENT */);
    }
    get minStorageBufferOffsetAlignment() {
      return 0;
    }
    get maxVertexBuffers() {
      return 16;
    }
    // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
    get maxVertexAttributes() {
      return this.getParameter(34921 /* MAX_VERTEX_ATTRIBS */);
    }
    get maxVertexBufferArrayStride() {
      return 2048;
    }
    // TBD, this is just the default value from WebGPU
    get maxInterStageShaderComponents() {
      return this.getParameter(35659 /* MAX_VARYING_COMPONENTS */);
    }
    get maxComputeWorkgroupStorageSize() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeInvocationsPerWorkgroup() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeX() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeY() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupSizeZ() {
      return 0;
    }
    // WebGL does not support compute shaders
    get maxComputeWorkgroupsPerDimension() {
      return 0;
    }
    // WebGL does not support compute shaders
    // PRIVATE
    gl;
    limits = {};
    constructor(gl) {
      super();
      this.gl = gl;
    }
    getParameter(parameter) {
      if (this.limits[parameter] === void 0) {
        this.limits[parameter] = this.gl.getParameter(parameter);
      }
      return this.limits[parameter];
    }
  };

  // src/adapter/webgl-canvas-context.ts
  var import_core11 = __toESM(require_core(), 1);

  // src/adapter/resources/webgl-framebuffer.ts
  var import_core10 = __toESM(require_core(), 1);

  // src/adapter/resources/webgl-texture.ts
  var import_core9 = __toESM(require_core(), 1);

  // src/context/state-tracker/with-parameters.ts
  function withGLParameters(gl, parameters, func) {
    if (isObjectEmpty2(parameters)) {
      return func(gl);
    }
    const { nocatch = true } = parameters;
    pushContextState(gl);
    setGLParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }
  function isObjectEmpty2(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }

  // src/adapter/converters/device-parameters.ts
  var import_core5 = __toESM(require_core(), 1);
  function withDeviceAndGLParameters(device, parameters, glParameters, func) {
    if ((0, import_core5.isObjectEmpty)(parameters)) {
      return func(device);
    }
    const webglDevice = device;
    pushContextState(webglDevice.gl);
    try {
      setDeviceParameters(device, parameters);
      setGLParameters(webglDevice.gl, glParameters);
      return func(device);
    } finally {
      popContextState(webglDevice.gl);
    }
  }
  function withDeviceParameters(device, parameters, func) {
    if ((0, import_core5.isObjectEmpty)(parameters)) {
      return func(device);
    }
    pushContextState(device.gl);
    try {
      setDeviceParameters(device, parameters);
      return func(device);
    } finally {
      popContextState(device.gl);
    }
  }
  function setDeviceParameters(device, parameters) {
    const webglDevice = device;
    const { gl } = webglDevice;
    if (parameters.cullMode) {
      switch (parameters.cullMode) {
        case "none":
          gl.disable(2884 /* CULL_FACE */);
          break;
        case "front":
          gl.enable(2884 /* CULL_FACE */);
          gl.cullFace(1028 /* FRONT */);
          break;
        case "back":
          gl.enable(2884 /* CULL_FACE */);
          gl.cullFace(1029 /* BACK */);
          break;
      }
    }
    if (parameters.frontFace) {
      gl.frontFace(
        map("frontFace", parameters.frontFace, {
          ccw: 2305 /* CCW */,
          cw: 2304 /* CW */
        })
      );
    }
    if (parameters.unclippedDepth) {
      if (device.features.has("depth-clip-control")) {
        gl.enable(34383 /* DEPTH_CLAMP_EXT */);
      }
    }
    if (parameters.depthBias !== void 0) {
      gl.enable(32823 /* POLYGON_OFFSET_FILL */);
      gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
    }
    if (parameters.provokingVertex) {
      if (device.features.has("provoking-vertex-webgl")) {
        const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
        const ext = extensions.WEBGL_provoking_vertex;
        const vertex = map(
          "provokingVertex",
          parameters.provokingVertex,
          {
            first: 36429 /* FIRST_VERTEX_CONVENTION_WEBGL */,
            last: 36430 /* LAST_VERTEX_CONVENTION_WEBGL */
          }
        );
        ext?.provokingVertexWEBGL(vertex);
      }
    }
    if (parameters.polygonMode || parameters.polygonOffsetLine) {
      if (device.features.has("polygon-mode-webgl")) {
        if (parameters.polygonMode) {
          const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
          const ext = extensions.WEBGL_polygon_mode;
          const mode = map("polygonMode", parameters.polygonMode, {
            fill: 6914 /* FILL_WEBGL */,
            line: 6913 /* LINE_WEBGL */
          });
          ext?.polygonModeWEBGL(1028 /* FRONT */, mode);
          ext?.polygonModeWEBGL(1029 /* BACK */, mode);
        }
        if (parameters.polygonOffsetLine) {
          gl.enable(10754 /* POLYGON_OFFSET_LINE_WEBGL */);
        }
      }
    }
    if (device.features.has("shader-clip-cull-distance-webgl")) {
      if (parameters.clipDistance0) {
        gl.enable(12288 /* CLIP_DISTANCE0_WEBGL */);
      }
      if (parameters.clipDistance1) {
        gl.enable(12289 /* CLIP_DISTANCE1_WEBGL */);
      }
      if (parameters.clipDistance2) {
        gl.enable(12290 /* CLIP_DISTANCE2_WEBGL */);
      }
      if (parameters.clipDistance3) {
        gl.enable(12291 /* CLIP_DISTANCE3_WEBGL */);
      }
      if (parameters.clipDistance4) {
        gl.enable(12292 /* CLIP_DISTANCE4_WEBGL */);
      }
      if (parameters.clipDistance5) {
        gl.enable(12293 /* CLIP_DISTANCE5_WEBGL */);
      }
      if (parameters.clipDistance6) {
        gl.enable(12294 /* CLIP_DISTANCE6_WEBGL */);
      }
      if (parameters.clipDistance7) {
        gl.enable(12295 /* CLIP_DISTANCE7_WEBGL */);
      }
    }
    if (parameters.depthWriteEnabled !== void 0) {
      gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
    }
    if (parameters.depthCompare) {
      parameters.depthCompare !== "always" ? gl.enable(2929 /* DEPTH_TEST */) : gl.disable(2929 /* DEPTH_TEST */);
      gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
    }
    if (parameters.stencilWriteMask) {
      const mask = parameters.stencilWriteMask;
      gl.stencilMaskSeparate(1028 /* FRONT */, mask);
      gl.stencilMaskSeparate(1029 /* BACK */, mask);
    }
    if (parameters.stencilReadMask) {
      import_core5.log.warn("stencilReadMask not supported under WebGL");
    }
    if (parameters.stencilCompare) {
      const mask = parameters.stencilReadMask || 4294967295;
      const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
      parameters.stencilCompare !== "always" ? gl.enable(2960 /* STENCIL_TEST */) : gl.disable(2960 /* STENCIL_TEST */);
      gl.stencilFuncSeparate(1028 /* FRONT */, glValue, 0, mask);
      gl.stencilFuncSeparate(1029 /* BACK */, glValue, 0, mask);
    }
    if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
      const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
      const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
      const dpfail = convertStencilOperation(
        "stencilDepthFailOperation",
        parameters.stencilDepthFailOperation
      );
      gl.stencilOpSeparate(1028 /* FRONT */, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029 /* BACK */, sfail, dpfail, dppass);
    }
    if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
      gl.enable(3042 /* BLEND */);
      const colorEquation = convertBlendOperationToEquation(
        "blendColorOperation",
        parameters.blendColorOperation || "add"
      );
      const alphaEquation = convertBlendOperationToEquation(
        "blendAlphaOperation",
        parameters.blendAlphaOperation || "add"
      );
      gl.blendEquationSeparate(colorEquation, alphaEquation);
      const colorSrcFactor = convertBlendFactorToFunction(
        "blendColorSrcFactor",
        parameters.blendColorSrcFactor || "one"
      );
      const colorDstFactor = convertBlendFactorToFunction(
        "blendColorDstFactor",
        parameters.blendColorDstFactor || "zero"
      );
      const alphaSrcFactor = convertBlendFactorToFunction(
        "blendAlphaSrcFactor",
        parameters.blendAlphaSrcFactor || "one"
      );
      const alphaDstFactor = convertBlendFactorToFunction(
        "blendAlphaDstFactor",
        parameters.blendAlphaDstFactor || "zero"
      );
      gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
  }
  function convertCompareFunction(parameter, value) {
    return map(parameter, value, {
      never: 512 /* NEVER */,
      less: 513 /* LESS */,
      equal: 514 /* EQUAL */,
      "less-equal": 515 /* LEQUAL */,
      greater: 516 /* GREATER */,
      "not-equal": 517 /* NOTEQUAL */,
      "greater-equal": 518 /* GEQUAL */,
      always: 519 /* ALWAYS */
    });
  }
  function convertStencilOperation(parameter, value) {
    return map(parameter, value, {
      keep: 7680 /* KEEP */,
      zero: 0 /* ZERO */,
      replace: 7681 /* REPLACE */,
      invert: 5386 /* INVERT */,
      "increment-clamp": 7682 /* INCR */,
      "decrement-clamp": 7683 /* DECR */,
      "increment-wrap": 34055 /* INCR_WRAP */,
      "decrement-wrap": 34056 /* DECR_WRAP */
    });
  }
  function convertBlendOperationToEquation(parameter, value) {
    return map(parameter, value, {
      add: 32774 /* FUNC_ADD */,
      subtract: 32778 /* FUNC_SUBTRACT */,
      "reverse-subtract": 32779 /* FUNC_REVERSE_SUBTRACT */,
      min: 32775 /* MIN */,
      max: 32776 /* MAX */
    });
  }
  function convertBlendFactorToFunction(parameter, value) {
    return map(parameter, value, {
      one: 1 /* ONE */,
      zero: 0 /* ZERO */,
      "src-color": 768 /* SRC_COLOR */,
      "one-minus-src-color": 769 /* ONE_MINUS_SRC_COLOR */,
      "dst-color": 774 /* DST_COLOR */,
      "one-minus-dst-color": 775 /* ONE_MINUS_DST_COLOR */,
      "src-alpha": 770 /* SRC_ALPHA */,
      "one-minus-src-alpha": 771 /* ONE_MINUS_SRC_ALPHA */,
      "dst-alpha": 772 /* DST_ALPHA */,
      "one-minus-dst-alpha": 773 /* ONE_MINUS_DST_ALPHA */,
      "src-alpha-saturated": 776 /* SRC_ALPHA_SATURATE */,
      "constant-color": 32769 /* CONSTANT_COLOR */,
      "one-minus-constant-color": 32770 /* ONE_MINUS_CONSTANT_COLOR */,
      "constant-alpha": 32771 /* CONSTANT_ALPHA */,
      "one-minus-constant-alpha": 32772 /* ONE_MINUS_CONSTANT_ALPHA */
    });
  }
  function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
  }
  function map(parameter, value, valueMap) {
    if (!(value in valueMap)) {
      throw new Error(message(parameter, value));
    }
    return valueMap[value];
  }
  function mapBoolean(parameter, value) {
    return value;
  }

  // src/adapter/converters/sampler-parameters.ts
  function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
      params[10242 /* TEXTURE_WRAP_S */] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
      params[10243 /* TEXTURE_WRAP_T */] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
      params[32882 /* TEXTURE_WRAP_R */] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
      params[10240 /* TEXTURE_MAG_FILTER */] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
      params[10241 /* TEXTURE_MIN_FILTER */] = convertMinFilterMode(
        props.minFilter || "linear",
        props.mipmapFilter
      );
    }
    if (props.lodMinClamp !== void 0) {
      params[33082 /* TEXTURE_MIN_LOD */] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== void 0) {
      params[33083 /* TEXTURE_MAX_LOD */] = props.lodMaxClamp;
    }
    if (props.type === "comparison-sampler") {
      params[34892 /* TEXTURE_COMPARE_MODE */] = 34894 /* COMPARE_REF_TO_TEXTURE */;
    }
    if (props.compare) {
      params[34893 /* TEXTURE_COMPARE_FUNC */] = convertCompareFunction("compare", props.compare);
    }
    if (props.maxAnisotropy) {
      params[34046 /* TEXTURE_MAX_ANISOTROPY_EXT */] = props.maxAnisotropy;
    }
    return params;
  }
  function convertAddressMode(addressMode) {
    switch (addressMode) {
      case "clamp-to-edge":
        return 33071 /* CLAMP_TO_EDGE */;
      case "repeat":
        return 10497 /* REPEAT */;
      case "mirror-repeat":
        return 33648 /* MIRRORED_REPEAT */;
    }
  }
  function convertMaxFilterMode(maxFilter) {
    switch (maxFilter) {
      case "nearest":
        return 9728 /* NEAREST */;
      case "linear":
        return 9729 /* LINEAR */;
    }
  }
  function convertMinFilterMode(minFilter, mipmapFilter) {
    if (!mipmapFilter) {
      return convertMaxFilterMode(minFilter);
    }
    switch (minFilter) {
      case "nearest":
        return mipmapFilter === "nearest" ? 9984 /* NEAREST_MIPMAP_NEAREST */ : 9986 /* NEAREST_MIPMAP_LINEAR */;
      case "linear":
        return mipmapFilter === "nearest" ? 9985 /* LINEAR_MIPMAP_NEAREST */ : 9987 /* LINEAR_MIPMAP_LINEAR */;
    }
  }

  // src/adapter/resources/webgl-buffer.ts
  var import_core6 = __toESM(require_core(), 1);
  var WEBGLBuffer = class extends import_core6.Buffer {
    device;
    gl;
    handle;
    /** Target in OpenGL defines the type of buffer */
    glTarget;
    /** Usage is a hint on how frequently the buffer will be updates */
    glUsage;
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    glIndexType = 5123 /* UNSIGNED_SHORT */;
    /** Number of bytes allocated on the GPU for this buffer */
    byteLength;
    /** Number of bytes used */
    bytesUsed;
    constructor(device, props = {}) {
      super(device, props);
      this.device = device;
      this.gl = this.device.gl;
      const handle = typeof props === "object" ? props.handle : void 0;
      this.handle = handle || this.gl.createBuffer();
      device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
      this.glTarget = getWebGLTarget(this.props.usage);
      this.glUsage = getWebGLUsage(this.props.usage);
      this.glIndexType = this.props.indexType === "uint32" ? 5125 /* UNSIGNED_INT */ : 5123 /* UNSIGNED_SHORT */;
      if (props.data) {
        this._initWithData(props.data, props.byteOffset, props.byteLength);
      } else {
        this._initWithByteLength(props.byteLength || 0);
      }
    }
    // PRIVATE METHODS
    /** Allocate a new buffer and initialize to contents of typed array */
    _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, byteLength, this.glUsage);
      this.gl.bufferSubData(glTarget, byteOffset, data);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(data, byteOffset, byteLength);
      this.trackAllocatedMemory(byteLength);
    }
    // Allocate a GPU buffer of specified size.
    _initWithByteLength(byteLength) {
      (0, import_core6.assert)(byteLength >= 0);
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const glTarget = this.glTarget;
      this.gl.bindBuffer(glTarget, this.handle);
      this.gl.bufferData(glTarget, data, this.glUsage);
      this.gl.bindBuffer(glTarget, null);
      this.bytesUsed = byteLength;
      this.byteLength = byteLength;
      this._setDebugData(null, 0, byteLength);
      this.trackAllocatedMemory(byteLength);
      return this;
    }
    destroy() {
      if (!this.destroyed && this.handle) {
        this.removeStats();
        this.trackDeallocatedMemory();
        this.gl.deleteBuffer(this.handle);
        this.destroyed = true;
        this.handle = null;
      }
    }
    write(data, byteOffset = 0) {
      const srcOffset = 0;
      const byteLength = void 0;
      const glTarget = 36663 /* COPY_WRITE_BUFFER */;
      this.gl.bindBuffer(glTarget, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        this.gl.bufferSubData(glTarget, byteOffset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(glTarget, byteOffset, data);
      }
      this.gl.bindBuffer(glTarget, null);
      this._setDebugData(data, byteOffset, data.byteLength);
    }
    /** Asynchronously read data from the buffer */
    async readAsync(byteOffset = 0, byteLength) {
      return this.readSyncWebGL(byteOffset, byteLength);
    }
    /** Synchronously read data from the buffer. WebGL only. */
    readSyncWebGL(byteOffset = 0, byteLength) {
      byteLength = byteLength ?? this.byteLength - byteOffset;
      const data = new Uint8Array(byteLength);
      const dstOffset = 0;
      this.gl.bindBuffer(36662 /* COPY_READ_BUFFER */, this.handle);
      this.gl.getBufferSubData(36662 /* COPY_READ_BUFFER */, byteOffset, data, dstOffset, byteLength);
      this.gl.bindBuffer(36662 /* COPY_READ_BUFFER */, null);
      this._setDebugData(data, byteOffset, byteLength);
      return data;
    }
  };
  function getWebGLTarget(usage) {
    if (usage & import_core6.Buffer.INDEX) {
      return 34963 /* ELEMENT_ARRAY_BUFFER */;
    }
    if (usage & import_core6.Buffer.VERTEX) {
      return 34962 /* ARRAY_BUFFER */;
    }
    if (usage & import_core6.Buffer.UNIFORM) {
      return 35345 /* UNIFORM_BUFFER */;
    }
    return 34962 /* ARRAY_BUFFER */;
  }
  function getWebGLUsage(usage) {
    if (usage & import_core6.Buffer.INDEX) {
      return 35044 /* STATIC_DRAW */;
    }
    if (usage & import_core6.Buffer.VERTEX) {
      return 35044 /* STATIC_DRAW */;
    }
    if (usage & import_core6.Buffer.UNIFORM) {
      return 35048 /* DYNAMIC_DRAW */;
    }
    return 35044 /* STATIC_DRAW */;
  }

  // src/adapter/resources/webgl-sampler.ts
  var import_core7 = __toESM(require_core(), 1);
  var WEBGLSampler = class extends import_core7.Sampler {
    device;
    handle;
    parameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.parameters = convertSamplerParametersToWebGL(props);
      this.handle = this.handle || this.device.gl.createSampler();
      this._setSamplerParameters(this.parameters);
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteSampler(this.handle);
        this.handle = void 0;
      }
    }
    toString() {
      return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    /** Set sampler parameters on the sampler */
    _setSamplerParameters(parameters) {
      for (const [pname, value] of Object.entries(parameters)) {
        const param = Number(pname);
        switch (param) {
          case 33082 /* TEXTURE_MIN_LOD */:
          case 33083 /* TEXTURE_MAX_LOD */:
            this.device.gl.samplerParameterf(this.handle, param, value);
            break;
          default:
            this.device.gl.samplerParameteri(this.handle, param, value);
            break;
        }
      }
    }
  };

  // src/adapter/resources/webgl-texture-view.ts
  var import_core8 = __toESM(require_core(), 1);
  var WEBGLTextureView = class extends import_core8.TextureView {
    device;
    gl;
    handle;
    texture;
    constructor(device, props) {
      super(device, { ...import_core8.Texture.defaultProps, ...props });
      this.device = device;
      this.gl = this.device.gl;
      this.handle = null;
      this.texture = props.texture;
    }
  };

  // src/adapter/resources/webgl-texture.ts
  var DEFAULT_WEBGL_TEXTURE_PROPS = {
    // deprecated
    parameters: {},
    pixelStore: {},
    pixels: null,
    border: 0,
    dataFormat: void 0,
    textureUnit: void 0,
    target: void 0
  };
  var _WEBGLTexture = class extends import_core9.Texture {
    MAX_ATTRIBUTES;
    device;
    gl;
    handle;
    // (TODO - currently unused in WebGL, but WebGL 2 does support sampler objects) */
    sampler = void 0;
    view = void 0;
    // data;
    glFormat = void 0;
    type = void 0;
    dataFormat = void 0;
    mipmaps = void 0;
    /**
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * they get special information. When you first bind a texture as a
     * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     * */
    target;
    textureUnit = void 0;
    /**
     * Program.draw() checks the loaded flag of all textures to avoid
     * Textures that are still loading from promises
     * Set to true as soon as texture has been initialized with valid data
     */
    loaded = false;
    _video;
    constructor(device, props) {
      super(device, { ...DEFAULT_WEBGL_TEXTURE_PROPS, format: "rgba8unorm", ...props });
      this.device = device;
      this.gl = this.device.gl;
      this.handle = this.props.handle || this.gl.createTexture();
      this.device.setSpectorMetadata(this.handle, { ...this.props, data: typeof this.props.data });
      this.glFormat = 6408 /* RGBA */;
      this.target = getWebGLTextureTarget(this.props);
      this.loaded = false;
      if (typeof this.props?.data === "string") {
        Object.assign(this.props, { data: (0, import_core9.loadImage)(this.props.data) });
      }
      this.initialize(this.props);
      Object.seal(this);
    }
    destroy() {
      if (this.handle) {
        this.gl.deleteTexture(this.handle);
        this.removeStats();
        this.trackDeallocatedMemory("Texture");
        this.destroyed = true;
      }
    }
    toString() {
      return `Texture(${this.id},${this.width}x${this.height})`;
    }
    createView(props) {
      return new WEBGLTextureView(this.device, { ...props, texture: this });
    }
    // eslint-disable-next-line max-statements
    initialize(props = {}) {
      if (this.props.dimension === "cube") {
        return this.initializeCube(props);
      }
      let data = props.data;
      if (data instanceof Promise) {
        data.then(
          (resolvedImageData) => this.initialize(
            Object.assign({}, props, {
              pixels: resolvedImageData,
              data: resolvedImageData
            })
          )
        );
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const { parameters = {} } = props;
      const { pixels = null, pixelStore = {}, textureUnit = void 0, mipmaps = true } = props;
      if (!data) {
        data = pixels;
      }
      let { width, height, dataFormat, type, compressed = false } = props;
      const { depth = 0 } = props;
      const glFormat = convertTextureFormatToGL(props.format);
      ({ width, height, compressed, dataFormat, type } = this._deduceParameters({
        format: props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.glFormat = glFormat;
      this.type = type;
      this.dataFormat = dataFormat;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 /* TEXTURE0 */ + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format: glFormat,
        type,
        dataFormat,
        // @ts-expect-error
        parameters: pixelStore,
        compressed
      });
      this.setSampler(props.sampler);
      this._setSamplerParameters(parameters);
      this.view = this.createView({ ...this.props, mipLevelCount: 1, arrayLayerCount: 1 });
      if (mipmaps && this.device.isTextureFormatFilterable(props.format)) {
        this.generateMipmap();
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          // @ts-expect-error
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    initializeCube(props) {
      const { mipmaps = true, parameters = {} } = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setSampler(props.sampler);
        this._setSamplerParameters(parameters);
      });
      return this;
    }
    setSampler(sampler = {}) {
      let samplerProps;
      if (sampler instanceof WEBGLSampler) {
        this.sampler = sampler;
        samplerProps = sampler.props;
      } else {
        this.sampler = new WEBGLSampler(this.device, sampler);
        samplerProps = sampler;
      }
      const parameters = convertSamplerParametersToWebGL(samplerProps);
      this._setSamplerParameters(parameters);
      return this;
    }
    /**
     * If size has changed, reinitializes with current format
     * @note note clears image and mipmaps
     */
    resize(options) {
      const { height, width, mipmaps = false } = options;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          mipmaps
        });
      }
      return this;
    }
    /** Update external texture (video frame) */
    update() {
      if (this._video) {
        const { video, parameters, lastTime } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    // Call to regenerate mipmaps after modifying texture(s)
    generateMipmap(params = {}) {
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    /*
     * Allocates storage
     * @param {*} pixels -
     *  null - create empty texture of specified format
     *  Typed array - init from image data in typed array
     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
     *  HTMLImageElement|Image - Inits with content of image. Auto width/height
     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
     *  HTMLVideoElement - Creates video texture. Auto width/height
     *
     * @param  width -
     * @param  height -
     * @param  mipMapLevel -
     * @param {GLenum} format - format of image data.
     * @param {GLenum} type
     *  - format of array (autodetect from type) or
     *  - (WEBGL2) format of buffer
     * @param {Number} offset - (WEBGL2) offset from start of buffer
     * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
     */
    // eslint-disable-next-line max-statements, complexity
    setImageData(options) {
      if (this.props.dimension === "3d" || this.props.dimension === "2d-array") {
        return this.setImageData3D(options);
      }
      this.trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        glFormat = this.glFormat,
        offset = 0,
        parameters = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const { gl } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({ data, dataType } = this._getDataType({ data, compressed }));
      withGLParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              dataFormat,
              type,
              data
            );
            break;
          case "typed-array":
            gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              // border (must be 0)
              dataFormat,
              type,
              data,
              offset
            );
            break;
          case "buffer":
            this.device.gl.bindBuffer(35052 /* PIXEL_UNPACK_BUFFER */, data.handle || data);
            this.device.gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              dataFormat,
              type,
              offset
            );
            this.device.gl.bindBuffer(35052 /* PIXEL_UNPACK_BUFFER */, null);
            break;
          case "browser-object":
            gl.texImage2D(
              target,
              level,
              glFormat,
              width,
              height,
              0,
              dataFormat,
              type,
              data
            );
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(
                target,
                levelIndex,
                levelData.format,
                levelData.width,
                levelData.height,
                0,
                levelData.data
              );
            }
            break;
          default:
            (0, import_core9.assert)(false, "Unknown image data type");
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
        this.trackAllocatedMemory(this.width * this.height * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    /**
     * Redefines an area of an existing texture
     * Note: does not allocate storage
     * Redefines an area of an existing texture
     */
    setSubImageData({
      target = this.target,
      pixels = null,
      data = null,
      x = 0,
      y = 0,
      width = this.width,
      height = this.height,
      level = 0,
      glFormat = this.glFormat,
      type = this.type,
      dataFormat = this.dataFormat,
      compressed = false,
      offset = 0,
      parameters = {}
    }) {
      ({ type, dataFormat, compressed, width, height } = this._deduceParameters({
        format: this.props.format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      (0, import_core9.assert)(this.depth === 1, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof WEBGLBuffer) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withGLParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x, y, width, height, glFormat, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
        } else if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
          this.device.gl.bindBuffer(35052 /* PIXEL_UNPACK_BUFFER */, data);
          this.device.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
          this.device.gl.bindBuffer(35052 /* PIXEL_UNPACK_BUFFER */, null);
        } else {
          this.device.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     *
     * Note that binding a texture into a Framebuffer's color buffer and
     * rendering can be faster.
     */
    copyFramebuffer(opts = {}) {
      import_core9.log.error(
        "Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})"
      )();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016 /* ACTIVE_TEXTURE */) - 33984 /* TEXTURE0 */;
    }
    bind(textureUnit = this.textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind(textureUnit = this.textureUnit) {
      const { gl } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    // PRIVATE METHODS
    _getDataType({ data, compressed = false }) {
      if (compressed) {
        return { data, dataType: "compressed" };
      }
      if (data === null) {
        return { data, dataType: "null" };
      }
      if (ArrayBuffer.isView(data)) {
        return { data, dataType: "typed-array" };
      }
      if (data instanceof WEBGLBuffer) {
        return { data: data.handle, dataType: "buffer" };
      }
      if (typeof WebGLBuffer !== "undefined" && data instanceof WebGLBuffer) {
        return { data, dataType: "buffer" };
      }
      return { data, dataType: "browser-object" };
    }
    // HELPER METHODS
    _deduceParameters(opts) {
      const { format, data } = opts;
      let { width, height, dataFormat, type, compressed } = opts;
      const parameters = getWebGLTextureParameters(format);
      dataFormat = dataFormat || parameters.dataFormat;
      type = type || parameters.type;
      compressed = compressed || parameters.compressed;
      ({ width, height } = this._deduceImageSize(data, width, height));
      return { dataFormat, type, compressed, width, height, format, data };
    }
    // eslint-disable-next-line complexity
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = { width: data.naturalWidth, height: data.naturalHeight };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = { width: data.width, height: data.height };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = { width: data.width, height: data.height };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = { width: data.videoWidth, height: data.videoHeight };
      } else if (!data) {
        size = { width: width >= 0 ? width : 1, height: height >= 0 ? height : 1 };
      } else {
        size = { width, height };
      }
      (0, import_core9.assert)(size, "Could not deduced texture size");
      (0, import_core9.assert)(
        width === void 0 || size.width === width,
        "Deduced texture width does not match supplied width"
      );
      (0, import_core9.assert)(
        height === void 0 || size.height === height,
        "Deduced texture height does not match supplied height"
      );
      return size;
    }
    // CUBE MAP METHODS
    /* eslint-disable max-statements, max-len */
    async setCubeMapImageData(options) {
      const { gl } = this;
      const { width, height, pixels, data, format = 6408 /* RGBA */, type = 5121 /* UNSIGNED_BYTE */ } = options;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(
        _WEBGLTexture.FACES.map((face) => {
          const facePixels = imageDataMap[face];
          return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
        })
      );
      this.bind();
      _WEBGLTexture.FACES.forEach((face, index) => {
        if (resolvedFaces[index].length > 1 && this.props.mipmaps !== false) {
          import_core9.log.warn(`${this.id} has mipmap and multiple LODs.`)();
        }
        resolvedFaces[index].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, 0, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    /** @todo update this method to accept LODs */
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        format = 6408 /* RGBA */,
        type = 5121 /* UNSIGNED_BYTE */
        // generateMipmap = false // TODO
      } = options;
      const { gl } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then(
          (resolvedImageData) => this.setImageDataForFace(
            Object.assign({}, options, {
              face,
              data: resolvedImageData,
              pixels: resolvedImageData
            })
          )
        );
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, 0, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
    /** Image 3D copies from Typed Array or WebGLBuffer */
    setImageData3D(options) {
      const {
        level = 0,
        dataFormat,
        format,
        type,
        // = GL.UNSIGNED_BYTE,
        width,
        height,
        depth = 1,
        offset = 0,
        data,
        parameters = {}
      } = options;
      this.trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      const webglTextureFormat = getWebGLTextureParameters(format);
      withGLParameters(this.gl, parameters, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(
            this.target,
            level,
            webglTextureFormat.format,
            width,
            height,
            depth,
            0,
            webglTextureFormat.dataFormat,
            webglTextureFormat.type,
            // dataType: getWebGL,
            data
          );
        }
        if (data instanceof WEBGLBuffer) {
          this.gl.bindBuffer(35052 /* PIXEL_UNPACK_BUFFER */, data.handle);
          this.gl.texImage3D(
            this.target,
            level,
            dataFormat,
            width,
            height,
            depth,
            0,
            format,
            type,
            offset
          );
        }
      });
      if (data && data.byteLength) {
        this.trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const bytesPerPixel = getTextureFormatBytesPerPixel(this.props.format);
        this.trackAllocatedMemory(this.width * this.height * this.depth * bytesPerPixel, "Texture");
      }
      this.loaded = true;
      return this;
    }
    // RESOURCE METHODS
    /**
     * Sets sampler parameters on texture
     */
    _setSamplerParameters(parameters) {
      if ((0, import_core9.isObjectEmpty)(parameters)) {
        return;
      }
      logParameters(parameters);
      this.gl.bindTexture(this.target, this.handle);
      for (const [pname, pvalue] of Object.entries(parameters)) {
        const param = Number(pname);
        const value = pvalue;
        switch (param) {
          case 33082 /* TEXTURE_MIN_LOD */:
          case 33083 /* TEXTURE_MAX_LOD */:
            this.gl.texParameterf(this.target, param, value);
            break;
          default:
            this.gl.texParameteri(this.target, param, value);
            break;
        }
      }
      this.gl.bindTexture(this.target, null);
      return;
    }
  };
  var WEBGLTexture = _WEBGLTexture;
  // TODO - remove?
  __publicField(WEBGLTexture, "FACES", [
    34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */,
    34070 /* TEXTURE_CUBE_MAP_NEGATIVE_X */,
    34071 /* TEXTURE_CUBE_MAP_POSITIVE_Y */,
    34072 /* TEXTURE_CUBE_MAP_NEGATIVE_Y */,
    34073 /* TEXTURE_CUBE_MAP_POSITIVE_Z */,
    34074 /* TEXTURE_CUBE_MAP_NEGATIVE_Z */
  ]);
  function getWebGLTextureTarget(props) {
    switch (props.dimension) {
      case "2d":
        return 3553 /* TEXTURE_2D */;
      case "cube":
        return 34067 /* TEXTURE_CUBE_MAP */;
      case "2d-array":
        return 35866 /* TEXTURE_2D_ARRAY */;
      case "3d":
        return 32879 /* TEXTURE_3D */;
      case "1d":
      case "cube-array":
      default:
        throw new Error(props.dimension);
    }
  }
  function logParameters(parameters) {
    import_core9.log.log(1, "texture sampler parameters", parameters)();
  }

  // src/adapter/resources/webgl-framebuffer.ts
  var WEBGLFramebuffer = class extends import_core10.Framebuffer {
    device;
    gl;
    handle;
    get texture() {
      return this.colorAttachments[0];
    }
    constructor(device, props) {
      super(device, props);
      const isDefaultFramebuffer = props.handle === null;
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
      if (!isDefaultFramebuffer) {
        device.setSpectorMetadata(this.handle, { id: this.props.id, props: this.props });
        this.autoCreateAttachmentTextures();
        const prevHandle = this.gl.bindFramebuffer(
          36160 /* FRAMEBUFFER */,
          this.handle
        );
        for (let i = 0; i < this.colorAttachments.length; ++i) {
          const attachment = this.colorAttachments[i];
          const attachmentPoint = 36064 /* COLOR_ATTACHMENT0 */ + i;
          if (attachment) {
            this._attachOne(attachmentPoint, attachment);
          }
        }
        if (this.depthStencilAttachment) {
          this._attachOne(
            getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format),
            this.depthStencilAttachment
          );
        }
        if (props.check !== false) {
          const status = this.gl.checkFramebufferStatus(36160 /* FRAMEBUFFER */);
          if (status !== 36053 /* FRAMEBUFFER_COMPLETE */) {
            throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
          }
        }
        this.gl.bindFramebuffer(36160 /* FRAMEBUFFER */, prevHandle);
      }
    }
    /** destroys any auto created resources etc. */
    destroy() {
      super.destroy();
      if (!this.destroyed && this.handle !== null) {
        this.gl.deleteFramebuffer(this.handle);
      }
    }
    // PRIVATE
    /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
    createDepthStencilTexture(format) {
      return new WEBGLTexture(this.device, {
        id: `${this.id}-depth-stencil`,
        format,
        width: this.width,
        height: this.height,
        mipmaps: false
      });
    }
    /**
     * Attachment resize is expected to be a noop if size is same
     */
    resizeAttachments(width, height) {
      if (this.handle === null) {
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      for (const colorAttachment of this.colorAttachments) {
        colorAttachment.texture.resize({ width, height });
      }
      if (this.depthStencilAttachment) {
        this.depthStencilAttachment.texture.resize({ width, height });
      }
      return this;
    }
    /** Attach one attachment */
    _attachOne(attachmentPoint, attachment) {
      if (Array.isArray(attachment)) {
        const [texture, layer = 0, level = 0] = attachment;
        this._attachTexture(attachmentPoint, texture, layer, level);
        return texture;
      }
      if (attachment instanceof WEBGLTexture) {
        this._attachTexture(attachmentPoint, attachment, 0, 0);
        return attachment;
      }
      if (attachment instanceof WEBGLTextureView) {
        const textureView = attachment;
        this._attachTexture(
          attachmentPoint,
          textureView.texture,
          textureView.props.baseMipLevel,
          textureView.props.baseArrayLayer
        );
        return attachment.texture;
      }
      throw new Error("attach");
    }
    // TODO - we do not seem to need render buffers in WebGL 2
    // protected _attachWEBGLRenderbuffer(attachment: GL, renderbuffer: WEBGLRenderbuffer): void {
    //   this.gl.framebufferRenderbuffer(
    //     GL.FRAMEBUFFER,
    //     attachment,
    //     GL.RENDERBUFFER,
    //     renderbuffer.handle
    //   );
    // }
    /**
     * @param attachment
     * @param texture
     * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
     * @param level = 0 - mipmapLevel
     */
    _attachTexture(attachment, texture, layer, level) {
      const { gl } = this.device;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866 /* TEXTURE_2D_ARRAY */:
        case 32879 /* TEXTURE_3D */:
          gl.framebufferTextureLayer(36160 /* FRAMEBUFFER */, attachment, texture.target, level, layer);
          break;
        case 34067 /* TEXTURE_CUBE_MAP */:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160 /* FRAMEBUFFER */, attachment, face, texture.handle, level);
          break;
        case 3553 /* TEXTURE_2D */:
          gl.framebufferTexture2D(36160 /* FRAMEBUFFER */, attachment, 3553 /* TEXTURE_2D */, texture.handle, level);
          break;
        default:
          (0, import_core10.assert)(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */ ? layer + 34069 /* TEXTURE_CUBE_MAP_POSITIVE_X */ : layer;
  }
  function _getFrameBufferStatus(status) {
    switch (status) {
      case 36053 /* FRAMEBUFFER_COMPLETE */:
        return "success";
      case 36054 /* FRAMEBUFFER_INCOMPLETE_ATTACHMENT */:
        return "Mismatched attachments";
      case 36055 /* FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT */:
        return "No attachments";
      case 36057 /* FRAMEBUFFER_INCOMPLETE_DIMENSIONS */:
        return "Height/width mismatch";
      case 36061 /* FRAMEBUFFER_UNSUPPORTED */:
        return "Unsupported or split attachments";
      case 36182 /* FRAMEBUFFER_INCOMPLETE_MULTISAMPLE */:
        return "Samples mismatch";
      default:
        return `${status}`;
    }
  }

  // src/adapter/webgl-canvas-context.ts
  var WebGLCanvasContext = class extends import_core11.CanvasContext {
    device;
    presentationSize;
    _framebuffer = null;
    constructor(device, props) {
      super(props);
      this.device = device;
      this.presentationSize = [-1, -1];
      this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
      this.update();
    }
    getCurrentFramebuffer() {
      this.update();
      this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
      return this._framebuffer;
    }
    /** Resizes and updates render targets if necessary */
    update() {
      const size = this.getPixelSize();
      const sizeChanged = size[0] !== this.presentationSize[0] || size[1] !== this.presentationSize[1];
      if (sizeChanged) {
        this.presentationSize = size;
        this.resize();
      }
    }
    /**
     * Resize the canvas' drawing buffer.
     *
     * Can match the canvas CSS size, and optionally also consider devicePixelRatio
     * Can be called every frame
     *
     * Regardless of size, the drawing buffer will always be scaled to the viewport, but
     * for best visual results, usually set to either:
     *  canvas CSS width x canvas CSS height
     *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
     * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
     */
    resize(options) {
      if (!this.device.gl)
        return;
      if (this.canvas) {
        const devicePixelRatio = this.getDevicePixelRatio(options?.useDevicePixels);
        this.setDevicePixelRatio(devicePixelRatio, options);
        return;
      }
    }
    commit() {
    }
  };

  // src/context/debug/spector.ts
  var import_core12 = __toESM(require_core(), 1);
  var DEFAULT_SPECTOR_PROPS = {
    spector: import_core12.log.get("spector") || import_core12.log.get("inspect")
  };
  var SPECTOR_CDN_URL = "https://spectorcdn.babylonjs.com/spector.bundle.js";
  var LOG_LEVEL = 1;
  var spector = null;
  var initialized = false;
  async function loadSpectorJS(props) {
    if (!globalThis.SPECTOR) {
      try {
        await (0, import_core12.loadScript)(SPECTOR_CDN_URL);
      } catch (error) {
        import_core12.log.warn(String(error));
      }
    }
  }
  function initializeSpectorJS(props) {
    props = { ...DEFAULT_SPECTOR_PROPS, ...props };
    if (!props?.spector) {
      return null;
    }
    if (!spector && globalThis.SPECTOR) {
      import_core12.log.probe(LOG_LEVEL, "SPECTOR found and initialized")();
      spector = new globalThis.SPECTOR.Spector();
      if (globalThis.luma) {
        globalThis.luma.spector = spector;
      }
    }
    if (!spector) {
      return null;
    }
    if (!initialized) {
      initialized = true;
      spector.spyCanvases();
      spector?.onCaptureStarted.add(
        (capture) => import_core12.log.info("Spector capture started:", capture)()
      );
      spector?.onCapture.add((capture) => {
        import_core12.log.info("Spector capture complete:", capture)();
        spector?.getResultUI();
        spector?.resultView.display();
        spector?.resultView.addCapture(capture);
      });
    }
    if (props?.canvas) {
      if (typeof props.spector === "string" && props.spector !== props.canvas.id) {
        return spector;
      }
      spector?.startCapture(props?.canvas, 500);
      new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
        import_core12.log.info("Spector capture stopped after 2 seconds")();
        spector?.stopCapture();
      });
    }
    return spector;
  }

  // src/context/debug/webgl-developer-tools.ts
  var import_core13 = __toESM(require_core(), 1);

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var document_ = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && window.process?.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
  }

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser() {
    const isNode = (
      // @ts-expect-error
      typeof process === "object" && String(process) === "[object process]" && !process?.browser
    );
    return !isNode || isElectron();
  }

  // ../../node_modules/@probe.gl/env/dist/lib/get-browser.js
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) {
      return "Edge";
    }
    if (globalThis.chrome) {
      return "Chrome";
    }
    if (globalThis.safari) {
      return "Safari";
    }
    if (globalThis.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // src/context/debug/webgl-developer-tools.ts
  var WEBGL_DEBUG_CDN_URL = "https://unpkg.com/webgl-debug@2.0.1/index.js";
  function getWebGLContextData(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
  }
  async function loadWebGLDeveloperTools() {
    if (isBrowser() && !globalThis.WebGLDebugUtils) {
      globalThis.global = globalThis.global || globalThis;
      globalThis.global.module = {};
      await (0, import_core13.loadScript)(WEBGL_DEBUG_CDN_URL);
    }
  }
  function makeDebugContext(gl, props = {}) {
    if (!gl) {
      return null;
    }
    return props.debug ? getDebugContext(gl, props) : getRealContext(gl);
  }
  function getRealContext(gl) {
    const data = getWebGLContextData(gl);
    return data.realContext ? data.realContext : gl;
  }
  function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
      import_core13.log.warn("webgl-debug not loaded")();
      return gl;
    }
    const data = getWebGLContextData(gl);
    if (data.debugContext) {
      return data.debugContext;
    }
    globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(
      gl,
      onGLError.bind(null, props),
      onValidateGLFunc.bind(null, props)
    );
    for (const key in GLEnum) {
      if (!(key in glDebug) && typeof GLEnum[key] === "number") {
        glDebug[key] = GLEnum[key];
      }
    }
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    return debugContext;
  }
  function getFunctionString(functionName, functionArgs) {
    functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
    return `gl.${functionName}(${args})`;
  }
  function onGLError(props, err, functionName, args) {
    args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
    import_core13.log.error(message2)();
    debugger;
    if (props.throwOnError) {
      throw new Error(message2);
    }
  }
  function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = "";
    if (import_core13.log.level >= 1) {
      functionString = getFunctionString(functionName, functionArgs);
      import_core13.log.log(1, functionString)();
    }
    if (props.break && props.break.length > 0) {
      functionString = functionString || getFunctionString(functionName, functionArgs);
      const isBreakpoint = props.break.every(
        (breakOn) => functionString.indexOf(breakOn) !== -1
      );
      if (isBreakpoint) {
        debugger;
      }
    }
    for (const arg of functionArgs) {
      if (arg === void 0) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        if (props.throwOnError) {
          throw new Error(`Undefined argument: ${functionString}`);
        } else {
          import_core13.log.error(`Undefined argument: ${functionString}`)();
          debugger;
        }
      }
    }
  }

  // src/adapter/resources/webgl-shader.ts
  var import_core14 = __toESM(require_core(), 1);

  // src/adapter/helpers/parse-shader-compiler-log.ts
  function parseShaderCompilerLog(errLog) {
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines) {
      if (line.length <= 1) {
        continue;
      }
      const segments = line.split(":");
      if (segments.length === 2) {
        const [messageType2, message2] = segments;
        messages.push({
          message: message2.trim(),
          type: getMessageType(messageType2),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [messageType, linePosition, lineNumber, ...rest] = segments;
      let lineNum = parseInt(lineNumber, 10);
      if (isNaN(lineNum)) {
        lineNum = 0;
      }
      let linePos = parseInt(linePosition, 10);
      if (isNaN(linePos)) {
        linePos = 0;
      }
      messages.push({
        message: rest.join(":").trim(),
        type: getMessageType(messageType),
        lineNum,
        linePos
        // TODO
      });
    }
    return messages;
  }
  function getMessageType(messageType) {
    const MESSAGE_TYPES = ["warning", "error", "info"];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
  }

  // src/adapter/resources/webgl-shader.ts
  var WEBGLShader = class extends import_core14.Shader {
    device;
    handle;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      switch (this.props.stage) {
        case "vertex":
          this.handle = this.props.handle || this.device.gl.createShader(35633 /* VERTEX_SHADER */);
          break;
        case "fragment":
          this.handle = this.props.handle || this.device.gl.createShader(35632 /* FRAGMENT_SHADER */);
          break;
        default:
          throw new Error(this.props.stage);
      }
      this._compile(this.source);
    }
    destroy() {
      if (this.handle) {
        this.removeStats();
        this.device.gl.deleteShader(this.handle);
        this.destroyed = true;
      }
    }
    async getCompilationInfo() {
      await this._waitForCompilationComplete();
      return this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
      const log9 = this.device.gl.getShaderInfoLog(this.handle);
      return parseShaderCompilerLog(log9);
    }
    getTranslatedSource() {
      const extensions = this.device.getExtension("WEBGL_debug_shaders");
      const ext = extensions.WEBGL_debug_shaders;
      return ext?.getTranslatedShaderSource(this.handle);
    }
    // PRIVATE METHODS
    /** Compile a shader and get compilation status */
    async _compile(source) {
      const addGLSLVersion = (source2) => source2.startsWith("#version ") ? source2 : `#version 100
${source2}`;
      source = addGLSLVersion(source);
      const { gl } = this.device;
      gl.shaderSource(this.handle, source);
      gl.compileShader(this.handle);
      if (import_core14.log.level === 0) {
        this.compilationStatus = "pending";
        return;
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        this._getCompilationStatus();
        this.debugShader();
        if (this.compilationStatus === "error") {
          throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
        }
        return;
      }
      import_core14.log.once(1, "Shader compilation is asynchronous")();
      await this._waitForCompilationComplete();
      import_core14.log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
      this._getCompilationStatus();
      this.debugShader();
    }
    /** Use KHR_parallel_shader_compile extension if available */
    async _waitForCompilationComplete() {
      const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getShaderParameter(this.handle, 37297 /* COMPLETION_STATUS_KHR */);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */
    _getCompilationStatus() {
      this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713 /* COMPILE_STATUS */) ? "success" : "error";
    }
  };

  // src/adapter/resources/webgl-render-pass.ts
  var import_core15 = __toESM(require_core(), 1);
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var COLOR_CHANNELS = [1, 2, 4, 8];
  var WEBGLRenderPass = class extends import_core15.RenderPass {
    device;
    /** Parameters that should be applied before each draw call */
    glParameters;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      pushContextState(this.device.gl);
      this.setParameters(this.props.parameters);
      this.clear();
    }
    end() {
      popContextState(this.device.gl);
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    // beginOcclusionQuery(queryIndex: number): void;
    // endOcclusionQuery(): void;
    // executeBundles(bundles: Iterable<GPURenderBundle>): void;
    /**
     * Maps RenderPass parameters to GL parameters
     */
    setParameters(parameters = {}) {
      const glParameters = { ...this.glParameters };
      if (this.props.framebuffer) {
        glParameters.framebuffer = this.props.framebuffer;
      }
      if (this.props.depthReadOnly) {
        glParameters.depthMask = !this.props.depthReadOnly;
      }
      glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
      glParameters[35977 /* RASTERIZER_DISCARD */] = this.props.discard;
      if (parameters.viewport) {
        if (parameters.viewport.length >= 6) {
          glParameters.viewport = parameters.viewport.slice(0, 4);
          glParameters.depthRange = [parameters.viewport[4], parameters.viewport[5]];
        } else {
          glParameters.viewport = parameters.viewport;
        }
      }
      if (parameters.scissorRect) {
        glParameters.scissorTest = true;
        glParameters.scissor = parameters.scissorRect;
      }
      if (parameters.blendConstant) {
        glParameters.blendColor = parameters.blendConstant;
      }
      if (parameters.stencilReference) {
        console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
        parameters[2967 /* STENCIL_REF */] = parameters.stencilReference;
      }
      if (parameters.colorMask) {
        glParameters.colorMask = COLOR_CHANNELS.map(
          (channel) => Boolean(channel & parameters.colorMask)
        );
      }
      this.glParameters = glParameters;
      setGLParameters(this.device.gl, glParameters);
    }
    beginOcclusionQuery(queryIndex) {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.beginOcclusionQuery();
    }
    endOcclusionQuery() {
      const webglQuerySet = this.props.occlusionQuerySet;
      webglQuerySet?.endOcclusionQuery();
    }
    // PRIVATE
    /**
     * Optionally clears depth, color and stencil buffers based on parameters
     */
    clear() {
      const glParameters = { ...this.glParameters };
      let clearMask = 0;
      if (this.props.clearColor !== false) {
        clearMask |= GL_COLOR_BUFFER_BIT;
        glParameters.clearColor = this.props.clearColor;
      }
      if (this.props.clearDepth !== false) {
        clearMask |= GL_DEPTH_BUFFER_BIT;
        glParameters.clearDepth = this.props.clearDepth;
      }
      if (this.props.clearStencil !== false) {
        clearMask |= GL_STENCIL_BUFFER_BIT;
        glParameters.clearStencil = this.props.clearStencil;
      }
      if (clearMask !== 0) {
        withGLParameters(this.device.gl, glParameters, () => {
          this.device.gl.clear(clearMask);
        });
      }
    }
    /**
     * WebGL2 - clear a specific color buffer
     */
    clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
      withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
        switch (value.constructor) {
          case Int32Array:
            this.device.gl.clearBufferiv(GL_COLOR, drawBuffer, value);
            break;
          case Uint32Array:
            this.device.gl.clearBufferuiv(GL_COLOR, drawBuffer, value);
            break;
          case Float32Array:
          default:
            this.device.gl.clearBufferfv(GL_COLOR, drawBuffer, value);
            break;
        }
      });
    }
    // clearDepthStencil() {
    // const GL_DEPTH = 0x1801;
    // const GL_STENCIL = 0x1802;
    // const GL_DEPTH_STENCIL = 0x84f9;
    //     case GL_DEPTH:
    //       this.device.gl.clearBufferfv(GL_DEPTH, 0, [value]);
    //       break;
    //     case GL_STENCIL:
    //       this.device.gl.clearBufferiv(GL_STENCIL, 0, [value]);
    //       break;
    //     case GL_DEPTH_STENCIL:
    //       const [depth, stencil] = value;
    //       this.device.gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
    //       break;
    //     default:
    //       assert(false, ERR_ARGUMENTS);
    //   }
    // });
  };

  // src/adapter/resources/webgl-render-pipeline.ts
  var import_core17 = __toESM(require_core(), 1);
  var import_core18 = __toESM(require_core(), 1);

  // src/classic/accessor.ts
  var import_core16 = __toESM(require_core(), 1);

  // src/classic/typed-array-utils.ts
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126 /* FLOAT */;
      case Uint16Array:
        return 5123 /* UNSIGNED_SHORT */;
      case Uint32Array:
        return 5125 /* UNSIGNED_INT */;
      case Uint8Array:
        return 5121 /* UNSIGNED_BYTE */;
      case Uint8ClampedArray:
        return 5121 /* UNSIGNED_BYTE */;
      case Int8Array:
        return 5120 /* BYTE */;
      case Int16Array:
        return 5122 /* SHORT */;
      case Int32Array:
        return 5124 /* INT */;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType, options) {
    const { clamped = true } = options || {};
    switch (glType) {
      case 5126 /* FLOAT */:
        return Float32Array;
      case 5123 /* UNSIGNED_SHORT */:
      case 33635 /* UNSIGNED_SHORT_5_6_5 */:
      case 32819 /* UNSIGNED_SHORT_4_4_4_4 */:
      case 32820 /* UNSIGNED_SHORT_5_5_5_1 */:
        return Uint16Array;
      case 5125 /* UNSIGNED_INT */:
        return Uint32Array;
      case 5121 /* UNSIGNED_BYTE */:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120 /* BYTE */:
        return Int8Array;
      case 5122 /* SHORT */:
        return Int16Array;
      case 5124 /* INT */:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }

  // src/classic/accessor.ts
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126 /* FLOAT */,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    offset;
    stride;
    type;
    size;
    divisor;
    normalized;
    integer;
    buffer;
    index;
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126 /* FLOAT */);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      (0, import_core16.assert)(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126 /* FLOAT */);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    // Combines (merges) a list of accessors. On top of default values
    // Usually [programAccessor, bufferAccessor, appAccessor]
    // All props will be set in the returned object.
    // TODO check for conflicts between values in the supplied accessors
    static resolve(...accessors) {
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor(...accessors) {
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    // ACCESSORS
    // TODO - remove>
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    // PRIVATE
    // eslint-disable-next-line complexity, max-statements
    _assign(props = {}) {
      props = (0, import_core16.checkProps)("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 /* INT */ || props.type === 5125 /* UNSIGNED_INT */) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalize !== void 0) {
        this.normalized = props.normalize;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      if (this.offset === void 0)
        delete this.offset;
      if (this.stride === void 0)
        delete this.stride;
      if (this.type === void 0)
        delete this.type;
      if (this.size === void 0)
        delete this.size;
      if (this.divisor === void 0)
        delete this.divisor;
      if (this.normalized === void 0)
        delete this.normalized;
      if (this.integer === void 0)
        delete this.integer;
      if (this.buffer === void 0)
        delete this.buffer;
      if (this.index === void 0)
        delete this.index;
      return this;
    }
  };

  // src/adapter/helpers/decode-webgl-types.ts
  function isSamplerUniform(type) {
    return SAMPLER_TYPES.includes(type);
  }
  var SAMPLER_TYPES = [
    35678 /* SAMPLER_2D */,
    35680 /* SAMPLER_CUBE */,
    35679 /* SAMPLER_3D */,
    35682 /* SAMPLER_2D_SHADOW */,
    36289 /* SAMPLER_2D_ARRAY */,
    36292 /* SAMPLER_2D_ARRAY_SHADOW */,
    36293 /* SAMPLER_CUBE_SHADOW */,
    36298 /* INT_SAMPLER_2D */,
    36299 /* INT_SAMPLER_3D */,
    36300 /* INT_SAMPLER_CUBE */,
    36303 /* INT_SAMPLER_2D_ARRAY */,
    36306 /* UNSIGNED_INT_SAMPLER_2D */,
    36307 /* UNSIGNED_INT_SAMPLER_3D */,
    36308 /* UNSIGNED_INT_SAMPLER_CUBE */,
    36311 /* UNSIGNED_INT_SAMPLER_2D_ARRAY */
  ];
  var COMPOSITE_GL_TYPES = {
    [5126 /* FLOAT */]: [5126 /* FLOAT */, 1, "float", "f32", "float32"],
    [35664 /* FLOAT_VEC2 */]: [5126 /* FLOAT */, 2, "vec2", "vec2<f32>", "float32x2"],
    [35665 /* FLOAT_VEC3 */]: [5126 /* FLOAT */, 3, "vec3", "vec3<f32>", "float32x3"],
    [35666 /* FLOAT_VEC4 */]: [5126 /* FLOAT */, 4, "vec4", "vec4<f32>", "float32x4"],
    [5124 /* INT */]: [5124 /* INT */, 1, "int", "i32", "sint32"],
    [35667 /* INT_VEC2 */]: [5124 /* INT */, 2, "ivec2", "vec2<i32>", "sint32x2"],
    [35668 /* INT_VEC3 */]: [5124 /* INT */, 3, "ivec3", "vec3<i32>", "sint32x3"],
    [35669 /* INT_VEC4 */]: [5124 /* INT */, 4, "ivec4", "vec4<i32>", "sint32x4"],
    [5125 /* UNSIGNED_INT */]: [5125 /* UNSIGNED_INT */, 1, "uint", "u32", "uint32"],
    [36294 /* UNSIGNED_INT_VEC2 */]: [5125 /* UNSIGNED_INT */, 2, "uvec2", "vec2<u32>", "uint32x2"],
    [36295 /* UNSIGNED_INT_VEC3 */]: [5125 /* UNSIGNED_INT */, 3, "uvec3", "vec3<u32>", "uint32x3"],
    [36296 /* UNSIGNED_INT_VEC4 */]: [5125 /* UNSIGNED_INT */, 4, "uvec4", "vec4<u32>", "uint32x4"],
    [35670 /* BOOL */]: [5126 /* FLOAT */, 1, "bool", "f32", "float32"],
    [35671 /* BOOL_VEC2 */]: [5126 /* FLOAT */, 2, "bvec2", "vec2<f32>", "float32x2"],
    [35672 /* BOOL_VEC3 */]: [5126 /* FLOAT */, 3, "bvec3", "vec3<f32>", "float32x3"],
    [35673 /* BOOL_VEC4 */]: [5126 /* FLOAT */, 4, "bvec4", "vec4<f32>", "float32x4"],
    // TODO - are sizes/components below correct?
    [35674 /* FLOAT_MAT2 */]: [5126 /* FLOAT */, 8, "mat2", "mat2x2<f32>"],
    // 4
    [35685 /* FLOAT_MAT2x3 */]: [5126 /* FLOAT */, 8, "mat2x3", "mat2x3<f32>"],
    // 6
    [35686 /* FLOAT_MAT2x4 */]: [5126 /* FLOAT */, 8, "mat2x4", "mat2x4<f32>"],
    // 8
    [35687 /* FLOAT_MAT3x2 */]: [5126 /* FLOAT */, 12, "mat3x2", "mat3x2<f32>"],
    // 6
    [35675 /* FLOAT_MAT3 */]: [5126 /* FLOAT */, 12, "mat3", "mat3x3<f32>"],
    // 9
    [35688 /* FLOAT_MAT3x4 */]: [5126 /* FLOAT */, 12, "mat3x4", "mat3x4<f32>"],
    // 12
    [35689 /* FLOAT_MAT4x2 */]: [5126 /* FLOAT */, 16, "mat4x2", "mat4x2<f32>"],
    // 8
    [35690 /* FLOAT_MAT4x3 */]: [5126 /* FLOAT */, 16, "mat4x3", "mat4x3<f32>"],
    // 12
    [35676 /* FLOAT_MAT4 */]: [5126 /* FLOAT */, 16, "mat4", "mat4x4<f32>"]
    // 16
  };
  function decodeGLUniformType(glUniformType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glUniformType];
    if (!typeAndSize) {
      throw new Error("uniform");
    }
    const [glType, components, , format] = typeAndSize;
    return { format, components, glType };
  }
  function decodeGLAttributeType(glAttributeType) {
    const typeAndSize = COMPOSITE_GL_TYPES[glAttributeType];
    if (!typeAndSize) {
      throw new Error("attribute");
    }
    const [, components, , shaderType, vertexFormat] = typeAndSize;
    const attributeType = shaderType;
    return { attributeType, vertexFormat, components };
  }

  // src/adapter/helpers/get-shader-layout.ts
  function getShaderLayout(gl, program) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock of uniformBlocks) {
      const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
        name: uniform.name,
        format: uniform.format,
        byteOffset: uniform.byteOffset,
        byteStride: uniform.byteStride,
        arrayLength: uniform.arrayLength
      }));
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniformBlock.name,
        location: uniformBlock.location,
        visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
        minBindingSize: uniformBlock.byteLength,
        uniforms: uniforms2
      });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms) {
      if (isSamplerUniform(uniform.type)) {
        const { viewDimension, sampleType } = getSamplerInfo(uniform.type);
        shaderLayout.bindings.push({
          type: "texture",
          name: uniform.name,
          location: textureUnit,
          viewDimension,
          sampleType
        });
        uniform.textureUnit = textureUnit;
        textureUnit += 1;
      }
    }
    if (uniforms.length) {
      shaderLayout.uniforms = uniforms;
    }
    const varyings = readVaryings(gl, program);
    if (varyings?.length) {
      shaderLayout.varyings = varyings;
    }
    return shaderLayout;
  }
  function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let index = 0; index < count; index++) {
      const activeInfo = gl.getActiveAttrib(program, index);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name,
        type: compositeType
        /* , size*/
      } = activeInfo;
      const location = gl.getAttribLocation(program, name);
      if (location >= 0) {
        const { attributeType } = decodeGLAttributeType(compositeType);
        const stepMode = /instance/i.test(name) ? "instance" : "vertex";
        attributes.push({
          name,
          location,
          stepMode,
          type: attributeType
          // size - for arrays, size is the number of elements in the array
        });
      }
    }
    attributes.sort((a, b) => a.location - b.location);
    return attributes;
  }
  function readVaryings(gl, program) {
    const varyings = [];
    const count = gl.getProgramParameter(program, 35971 /* TRANSFORM_FEEDBACK_VARYINGS */);
    for (let location = 0; location < count; location++) {
      const activeInfo = gl.getTransformFeedbackVarying(program, location);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name, type: compositeType, size } = activeInfo;
      const { glType, components } = decodeGLUniformType(compositeType);
      const accessor = new Accessor({ type: glType, size: size * components });
      const varying = { location, name, accessor };
      varyings.push(varying);
    }
    varyings.sort((a, b) => a.location - b.location);
    return varyings;
  }
  function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718 /* ACTIVE_UNIFORMS */);
    for (let i = 0; i < uniformCount; i++) {
      const activeInfo = gl.getActiveUniform(program, i);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: rawName, size, type } = activeInfo;
      const { name, isArray: isArray2 } = parseUniformName(rawName);
      let webglLocation = gl.getUniformLocation(program, name);
      const uniformInfo = {
        // WebGL locations are uniquely typed but just numbers
        location: webglLocation,
        name,
        size,
        type,
        isArray: isArray2
      };
      uniforms.push(uniformInfo);
      if (uniformInfo.size > 1) {
        for (let j = 0; j < uniformInfo.size; j++) {
          const elementName = `${name}[${j}]`;
          webglLocation = gl.getUniformLocation(program, elementName);
          const arrayElementUniformInfo = {
            ...uniformInfo,
            name: elementName,
            location: webglLocation
          };
          uniforms.push(arrayElementUniformInfo);
        }
      }
    }
    return uniforms;
  }
  function readUniformBlocks(gl, program) {
    const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl.getProgramParameter(program, 35382 /* ACTIVE_UNIFORM_BLOCKS */);
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      const blockInfo = {
        name: gl.getActiveUniformBlockName(program, blockIndex) || "",
        location: getBlockParameter(blockIndex, 35391 /* UNIFORM_BLOCK_BINDING */),
        byteLength: getBlockParameter(blockIndex, 35392 /* UNIFORM_BLOCK_DATA_SIZE */),
        vertex: getBlockParameter(blockIndex, 35396 /* UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER */),
        fragment: getBlockParameter(blockIndex, 35398 /* UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER */),
        uniformCount: getBlockParameter(blockIndex, 35394 /* UNIFORM_BLOCK_ACTIVE_UNIFORMS */),
        uniforms: []
      };
      const uniformIndices = getBlockParameter(blockIndex, 35395 /* UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES */) || [];
      const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383 /* UNIFORM_TYPE */);
      const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384 /* UNIFORM_SIZE */);
      const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387 /* UNIFORM_OFFSET */);
      const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388 /* UNIFORM_ARRAY_STRIDE */);
      for (let i = 0; i < blockInfo.uniformCount; ++i) {
        const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);
        if (!activeInfo) {
          throw new Error("activeInfo");
        }
        blockInfo.uniforms.push({
          name: activeInfo.name,
          format: decodeGLUniformType(uniformType[i]).format,
          type: uniformType[i],
          arrayLength: uniformArrayLength[i],
          byteOffset: uniformOffset[i],
          byteStride: uniformStride[i]
          // matrixStride: uniformStride[i],
          // rowMajor: uniformRowMajor[i]
        });
      }
      uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a, b) => a.location - b.location);
    return uniformBlocks;
  }
  var SAMPLER_UNIFORMS_GL_TO_GPU = {
    [35678 /* SAMPLER_2D */]: ["2d", "float"],
    [35680 /* SAMPLER_CUBE */]: ["cube", "float"],
    [35679 /* SAMPLER_3D */]: ["3d", "float"],
    [35682 /* SAMPLER_2D_SHADOW */]: ["3d", "depth"],
    [36289 /* SAMPLER_2D_ARRAY */]: ["2d-array", "float"],
    [36292 /* SAMPLER_2D_ARRAY_SHADOW */]: ["2d-array", "depth"],
    [36293 /* SAMPLER_CUBE_SHADOW */]: ["cube", "float"],
    [36298 /* INT_SAMPLER_2D */]: ["2d", "sint"],
    [36299 /* INT_SAMPLER_3D */]: ["3d", "sint"],
    [36300 /* INT_SAMPLER_CUBE */]: ["cube", "sint"],
    [36303 /* INT_SAMPLER_2D_ARRAY */]: ["2d-array", "uint"],
    [36306 /* UNSIGNED_INT_SAMPLER_2D */]: ["2d", "uint"],
    [36307 /* UNSIGNED_INT_SAMPLER_3D */]: ["3d", "uint"],
    [36308 /* UNSIGNED_INT_SAMPLER_CUBE */]: ["cube", "uint"],
    [36311 /* UNSIGNED_INT_SAMPLER_2D_ARRAY */]: ["2d-array", "uint"]
  };
  function getSamplerInfo(type) {
    const sampler = SAMPLER_UNIFORMS_GL_TO_GPU[type];
    if (!sampler) {
      throw new Error("sampler");
    }
    const [viewDimension, sampleType] = sampler;
    return { viewDimension, sampleType };
  }
  function parseUniformName(name) {
    if (name[name.length - 1] !== "]") {
      return {
        name,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = UNIFORM_NAME_REGEXP.exec(name);
    if (!matches || matches.length < 2) {
      throw new Error(`Failed to parse GLSL uniform name ${name}`);
    }
    return {
      name: matches[1],
      length: matches[2] ? 1 : 0,
      isArray: Boolean(matches[2])
    };
  }

  // src/adapter/helpers/set-uniform.ts
  function setUniform(gl, location, type, value) {
    const gl2 = gl;
    let uniformValue = value;
    if (uniformValue === true) {
      uniformValue = 1;
    }
    if (uniformValue === false) {
      uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
    switch (type) {
      case 35678 /* SAMPLER_2D */:
      case 35680 /* SAMPLER_CUBE */:
      case 35679 /* SAMPLER_3D */:
      case 35682 /* SAMPLER_2D_SHADOW */:
      case 36289 /* SAMPLER_2D_ARRAY */:
      case 36292 /* SAMPLER_2D_ARRAY_SHADOW */:
      case 36293 /* SAMPLER_CUBE_SHADOW */:
      case 36298 /* INT_SAMPLER_2D */:
      case 36299 /* INT_SAMPLER_3D */:
      case 36300 /* INT_SAMPLER_CUBE */:
      case 36303 /* INT_SAMPLER_2D_ARRAY */:
      case 36306 /* UNSIGNED_INT_SAMPLER_2D */:
      case 36307 /* UNSIGNED_INT_SAMPLER_3D */:
      case 36308 /* UNSIGNED_INT_SAMPLER_CUBE */:
      case 36311 /* UNSIGNED_INT_SAMPLER_2D_ARRAY */:
        if (typeof value !== "number") {
          throw new Error("samplers must be set to integers");
        }
        return gl.uniform1i(location, value);
      case 5126 /* FLOAT */:
        return gl.uniform1fv(location, arrayValue);
      case 35664 /* FLOAT_VEC2 */:
        return gl.uniform2fv(location, arrayValue);
      case 35665 /* FLOAT_VEC3 */:
        return gl.uniform3fv(location, arrayValue);
      case 35666 /* FLOAT_VEC4 */:
        return gl.uniform4fv(location, arrayValue);
      case 5124 /* INT */:
        return gl.uniform1iv(location, arrayValue);
      case 35667 /* INT_VEC2 */:
        return gl.uniform2iv(location, arrayValue);
      case 35668 /* INT_VEC3 */:
        return gl.uniform3iv(location, arrayValue);
      case 35669 /* INT_VEC4 */:
        return gl.uniform4iv(location, arrayValue);
      case 35670 /* BOOL */:
        return gl.uniform1iv(location, arrayValue);
      case 35671 /* BOOL_VEC2 */:
        return gl.uniform2iv(location, arrayValue);
      case 35672 /* BOOL_VEC3 */:
        return gl.uniform3iv(location, arrayValue);
      case 35673 /* BOOL_VEC4 */:
        return gl.uniform4iv(location, arrayValue);
      case 5125 /* UNSIGNED_INT */:
        return gl2.uniform1uiv(location, arrayValue, 1);
      case 36294 /* UNSIGNED_INT_VEC2 */:
        return gl2.uniform2uiv(location, arrayValue, 2);
      case 36295 /* UNSIGNED_INT_VEC3 */:
        return gl2.uniform3uiv(location, arrayValue, 3);
      case 36296 /* UNSIGNED_INT_VEC4 */:
        return gl2.uniform4uiv(location, arrayValue, 4);
      case 35674 /* FLOAT_MAT2 */:
        return gl.uniformMatrix2fv(location, false, arrayValue);
      case 35675 /* FLOAT_MAT3 */:
        return gl.uniformMatrix3fv(location, false, arrayValue);
      case 35676 /* FLOAT_MAT4 */:
        return gl.uniformMatrix4fv(location, false, arrayValue);
      case 35685 /* FLOAT_MAT2x3 */:
        return gl2.uniformMatrix2x3fv(location, false, arrayValue);
      case 35686 /* FLOAT_MAT2x4 */:
        return gl2.uniformMatrix2x4fv(location, false, arrayValue);
      case 35687 /* FLOAT_MAT3x2 */:
        return gl2.uniformMatrix3x2fv(location, false, arrayValue);
      case 35688 /* FLOAT_MAT3x4 */:
        return gl2.uniformMatrix3x4fv(location, false, arrayValue);
      case 35689 /* FLOAT_MAT4x2 */:
        return gl2.uniformMatrix4x2fv(location, false, arrayValue);
      case 35690 /* FLOAT_MAT4x3 */:
        return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error("Illegal uniform");
  }

  // src/adapter/helpers/webgl-topology-utils.ts
  function getGLDrawMode(topology) {
    switch (topology) {
      case "point-list":
        return 0 /* POINTS */;
      case "line-list":
        return 1 /* LINES */;
      case "line-strip":
        return 3 /* LINE_STRIP */;
      case "line-loop-webgl":
        return 2 /* LINE_LOOP */;
      case "triangle-list":
        return 4 /* TRIANGLES */;
      case "triangle-strip":
        return 5 /* TRIANGLE_STRIP */;
      case "triangle-fan-webgl":
        return 6 /* TRIANGLE_FAN */;
      default:
        throw new Error(topology);
    }
  }
  function getGLPrimitive(topology) {
    switch (topology) {
      case "point-list":
        return 0 /* POINTS */;
      case "line-list":
        return 1 /* LINES */;
      case "line-strip":
        return 1 /* LINES */;
      case "line-loop-webgl":
        return 1 /* LINES */;
      case "triangle-list":
        return 4 /* TRIANGLES */;
      case "triangle-strip":
        return 4 /* TRIANGLES */;
      case "triangle-fan-webgl":
        return 4 /* TRIANGLES */;
      default:
        throw new Error(topology);
    }
  }

  // src/adapter/resources/webgl-render-pipeline.ts
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var WEBGLRenderPipeline = class extends import_core17.RenderPipeline {
    /** The WebGL device that created this render pipeline */
    device;
    /** Handle to underlying WebGL program */
    handle;
    /** vertex shader */
    vs;
    /** fragment shader */
    fs;
    /** The layout extracted from shader by WebGL introspection APIs */
    introspectedLayout;
    /** Uniforms set on this model */
    uniforms = {};
    /** Bindings set on this model */
    bindings = {};
    /** WebGL varyings */
    varyings = null;
    _uniformCount = 0;
    _uniformSetters = {};
    // TODO are these used?
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.props.handle || this.device.gl.createProgram();
      this.device.setSpectorMetadata(this.handle, { id: this.props.id });
      this.vs = (0, import_core17.cast)(props.vs);
      this.fs = (0, import_core17.cast)(props.fs);
      const { varyings, bufferMode = 35981 /* SEPARATE_ATTRIBS */ } = props;
      if (varyings && varyings.length > 0) {
        this.varyings = varyings;
        this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._linkShaders();
      import_core17.log.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.introspectedLayout = getShaderLayout(this.device.gl, this.handle);
      import_core17.log.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)();
      this.shaderLayout = (0, import_core18.mergeShaderLayout)(this.introspectedLayout, props.shaderLayout);
      switch (this.props.topology) {
        case "triangle-fan-webgl":
        case "line-loop-webgl":
          import_core17.log.warn(
            `Primitive topology ${this.props.topology} is deprecated and will be removed in v9.1`
          );
          break;
        default:
      }
    }
    destroy() {
      if (this.handle) {
        this.device.gl.deleteProgram(this.handle);
        this.destroyed = true;
      }
    }
    /**
     * Bindings include: textures, samplers and uniform buffers
     * @todo needed for portable model
     */
    setBindings(bindings, options) {
      for (const [name, value] of Object.entries(bindings)) {
        const binding = this.shaderLayout.bindings.find((binding2) => binding2.name === name) || this.shaderLayout.bindings.find((binding2) => binding2.name === `${name}Uniforms`);
        if (!binding) {
          const validBindings = this.shaderLayout.bindings.map((binding2) => `"${binding2.name}"`).join(", ");
          if (!options?.disableWarnings) {
            import_core17.log.warn(
              `Unknown binding "${name}" in render pipeline "${this.id}", expected one of ${validBindings}`
            )();
          }
          continue;
        }
        if (!value) {
          import_core17.log.warn(`Unsetting binding "${name}" in render pipeline "${this.id}"`)();
        }
        switch (binding.type) {
          case "uniform":
            if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
              throw new Error("buffer value");
            }
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture value");
            }
            break;
          case "sampler":
            import_core17.log.warn(`Ignoring sampler ${name}`)();
            break;
          default:
            throw new Error(binding.type);
        }
        this.bindings[name] = value;
      }
    }
    /** @todo needed for portable model
     * @note The WebGL API is offers many ways to draw things
     * This function unifies those ways into a single call using common parameters with sane defaults
     */
    draw(options) {
      const {
        renderPass,
        parameters = this.props.parameters,
        topology = this.props.topology,
        vertexArray,
        vertexCount,
        // indexCount,
        instanceCount,
        firstVertex = 0,
        // firstIndex,
        // firstInstance,
        // baseVertex,
        transformFeedback
      } = options;
      const glDrawMode = getGLDrawMode(topology);
      const isIndexed = Boolean(vertexArray.indexBuffer);
      const glIndexType = vertexArray.indexBuffer?.glIndexType;
      const isInstanced = Number(instanceCount) > 0;
      if (this.linkStatus !== "success") {
        import_core17.log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
        return false;
      }
      if (!this._areTexturesRenderable() || vertexCount === 0) {
        import_core17.log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
        return false;
      }
      if (vertexCount === 0) {
        import_core17.log.info(2, `RenderPipeline:${this.id}.draw() aborted - no vertices to draw`)();
        return true;
      }
      this.device.gl.useProgram(this.handle);
      vertexArray.bindBeforeRender(renderPass);
      if (transformFeedback) {
        transformFeedback.begin(this.props.topology);
      }
      this._applyBindings();
      this._applyUniforms();
      const webglRenderPass = renderPass;
      withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {
        if (isIndexed && isInstanced) {
          this.device.gl.drawElementsInstanced(
            glDrawMode,
            vertexCount || 0,
            // indexCount?
            glIndexType,
            firstVertex,
            instanceCount || 0
          );
        } else if (isIndexed) {
          this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
        } else if (isInstanced) {
          this.device.gl.drawArraysInstanced(
            glDrawMode,
            firstVertex,
            vertexCount || 0,
            instanceCount || 0
          );
        } else {
          this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
        }
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      vertexArray.unbindAfterRender(renderPass);
      return true;
    }
    // DEPRECATED METHODS
    setUniformsWebGL(uniforms) {
      const { bindings } = (0, import_core17.splitUniformsAndBindings)(uniforms);
      Object.keys(bindings).forEach((name) => {
        import_core17.log.warn(
          `Unsupported value "${JSON.stringify(
            bindings[name]
          )}" used in setUniforms() for key ${name}. Use setBindings() instead?`
        )();
      });
      Object.assign(this.uniforms, uniforms);
    }
    // PRIVATE METHODS
    // setAttributes(attributes: Record<string, Buffer>): void {}
    // setBindings(bindings: Record<string, Binding>): void {}
    async _linkShaders() {
      const { gl } = this.device;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      import_core17.log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      gl.linkProgram(this.handle);
      import_core17.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
      if (import_core17.log.level === 0) {
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        const status2 = this._getLinkStatus();
        this._reportLinkStatus(status2);
        return;
      }
      import_core17.log.once(1, "RenderPipeline linking is asynchronous")();
      await this._waitForLinkComplete();
      import_core17.log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
      const status = this._getLinkStatus();
      this._reportLinkStatus(status);
    }
    /** Report link status. First, check for shader compilation failures if linking fails */
    _reportLinkStatus(status) {
      switch (status) {
        case "success":
          return;
        default:
          if (this.vs.compilationStatus === "error") {
            this.vs.debugShader();
            throw new Error(`Error during compilation of shader ${this.vs.id}`);
          }
          if (this.fs?.compilationStatus === "error") {
            this.vs.debugShader();
            throw new Error(`Error during compilation of shader ${this.fs.id}`);
          }
          throw new Error(`Error during ${status}: ${this.device.gl.getProgramInfoLog(this.handle)}`);
      }
    }
    /**
     * Get the shader compilation status
     * TODO - Load log even when no error reported, to catch warnings?
     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
     */
    _getLinkStatus() {
      const { gl } = this.device;
      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
      if (!linked) {
        this.linkStatus = "error";
        return "linking";
      }
      gl.validateProgram(this.handle);
      const validated = gl.getProgramParameter(this.handle, gl.VALIDATE_STATUS);
      if (!validated) {
        this.linkStatus = "error";
        return "validation";
      }
      this.linkStatus = "success";
      return "success";
    }
    /** Use KHR_parallel_shader_compile extension if available */
    async _waitForLinkComplete() {
      const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
      const DELAY_MS = 10;
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await waitMs(DELAY_MS);
        return;
      }
      const { gl } = this.device;
      for (; ; ) {
        const complete = gl.getProgramParameter(this.handle, 37297 /* COMPLETION_STATUS_KHR */);
        if (complete) {
          return;
        }
        await waitMs(DELAY_MS);
      }
    }
    /**
     * Checks if all texture-values uniforms are renderable (i.e. loaded)
     * Update a texture if needed (e.g. from video)
     * Note: This is currently done before every draw call
     */
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const [, texture] of Object.entries(this.bindings)) {
        if (texture instanceof WEBGLTexture) {
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
      }
      return texturesRenderable;
    }
    /** Apply any bindings (before each draw call) */
    _applyBindings() {
      if (this.linkStatus !== "success") {
        return;
      }
      const { gl } = this.device;
      gl.useProgram(this.handle);
      let textureUnit = 0;
      let uniformBufferIndex = 0;
      for (const binding of this.shaderLayout.bindings) {
        const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
        if (!value) {
          throw new Error(`No value for binding ${binding.name} in ${this.id}`);
        }
        switch (binding.type) {
          case "uniform":
            const { name } = binding;
            const location = gl.getUniformBlockIndex(this.handle, name);
            if (location === 4294967295 /* INVALID_INDEX */) {
              throw new Error(`Invalid uniform block name ${name}`);
            }
            gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
            if (value instanceof WEBGLBuffer) {
              gl.bindBufferBase(35345 /* UNIFORM_BUFFER */, uniformBufferIndex, value.handle);
            } else {
              gl.bindBufferRange(
                35345 /* UNIFORM_BUFFER */,
                uniformBufferIndex,
                // @ts-expect-error
                value.buffer.handle,
                // @ts-expect-error
                value.offset || 0,
                // @ts-expect-error
                value.size || value.buffer.byteLength - value.offset
              );
            }
            uniformBufferIndex += 1;
            break;
          case "texture":
            if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
              throw new Error("texture");
            }
            let texture;
            if (value instanceof WEBGLTextureView) {
              texture = value.texture;
            } else if (value instanceof WEBGLTexture) {
              texture = value;
            } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
              import_core17.log.warn(
                "Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead"
              )();
              texture = value.colorAttachments[0].texture;
            } else {
              throw new Error("No texture");
            }
            gl.activeTexture(33984 /* TEXTURE0 */ + textureUnit);
            gl.bindTexture(texture.target, texture.handle);
            textureUnit += 1;
            break;
          case "sampler":
            break;
          case "storage":
          case "read-only-storage":
            throw new Error(`binding type '${binding.type}' not supported in WebGL`);
        }
      }
    }
    /**
     * Due to program sharing, uniforms need to be reset before every draw call
     * (though caching will avoid redundant WebGL calls)
     */
    _applyUniforms() {
      for (const uniformLayout of this.shaderLayout.uniforms || []) {
        const { name, location, type, textureUnit } = uniformLayout;
        const value = this.uniforms[name] ?? textureUnit;
        if (value !== void 0) {
          setUniform(this.device.gl, location, type, value);
        }
      }
    }
  };

  // src/adapter/resources/webgl-command-encoder.ts
  var import_core20 = __toESM(require_core(), 1);

  // src/adapter/resources/webgl-command-buffer.ts
  var import_core19 = __toESM(require_core(), 1);
  function cast2(value) {
    return value;
  }
  var WEBGLCommandBuffer = class extends import_core19.CommandBuffer {
    device;
    commands = [];
    constructor(device) {
      super(device, {});
      this.device = device;
    }
    submitCommands(commands = this.commands) {
      for (const command of commands) {
        switch (command.name) {
          case "copy-buffer-to-buffer":
            _copyBufferToBuffer(this.device, command.options);
            break;
          case "copy-buffer-to-texture":
            _copyBufferToTexture(this.device, command.options);
            break;
          case "copy-texture-to-buffer":
            _copyTextureToBuffer(this.device, command.options);
            break;
          case "copy-texture-to-texture":
            _copyTextureToTexture(this.device, command.options);
            break;
        }
      }
    }
  };
  function _copyBufferToBuffer(device, options) {
    const source = cast2(options.source);
    const destination = cast2(options.destination);
    device.gl.bindBuffer(36662 /* COPY_READ_BUFFER */, source.handle);
    device.gl.bindBuffer(36663 /* COPY_WRITE_BUFFER */, destination.handle);
    device.gl.copyBufferSubData(
      36662 /* COPY_READ_BUFFER */,
      36663 /* COPY_WRITE_BUFFER */,
      options.sourceOffset ?? 0,
      options.destinationOffset ?? 0,
      options.size
    );
    device.gl.bindBuffer(36662 /* COPY_READ_BUFFER */, null);
    device.gl.bindBuffer(36663 /* COPY_WRITE_BUFFER */, null);
  }
  function _copyBufferToTexture(device, options) {
    throw new Error("Not implemented");
  }
  function _copyTextureToBuffer(device, options) {
    const {
      /** Texture to copy to/from. */
      source,
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      mipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      aspect = "all",
      /** Width to copy */
      width = options.source.width,
      /** Height to copy */
      height = options.source.height,
      depthOrArrayLayers = 0,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      origin = [0, 0],
      /** Destination buffer */
      destination,
      /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
      byteOffset = 0,
      /**
       * The stride, in bytes, between the beginning of each block row and the subsequent block row.
       * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
       */
      bytesPerRow,
      /**
       * Number of block rows per single image of the texture.
       * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
       * Required if there are multiple images (i.e. the copy depth is more than one).
       */
      rowsPerImage
    } = options;
    if (aspect !== "all") {
      throw new Error("not supported");
    }
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
      throw new Error("not implemented");
    }
    const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
    let prevHandle;
    try {
      const webglBuffer = destination;
      const sourceWidth = width || framebuffer.width;
      const sourceHeight = height || framebuffer.height;
      const sourceParams = getWebGLTextureParameters(framebuffer.texture.props.format);
      const sourceFormat = sourceParams.dataFormat;
      const sourceType = sourceParams.type;
      device.gl.bindBuffer(35051 /* PIXEL_PACK_BUFFER */, webglBuffer.handle);
      prevHandle = device.gl.bindFramebuffer(36160 /* FRAMEBUFFER */, framebuffer.handle);
      device.gl.readPixels(
        origin[0],
        origin[1],
        sourceWidth,
        sourceHeight,
        sourceFormat,
        sourceType,
        byteOffset
      );
    } finally {
      device.gl.bindBuffer(35051 /* PIXEL_PACK_BUFFER */, null);
      if (prevHandle !== void 0) {
        device.gl.bindFramebuffer(36160 /* FRAMEBUFFER */, prevHandle);
      }
      if (destroyFramebuffer) {
        framebuffer.destroy();
      }
    }
  }
  function _copyTextureToTexture(device, options) {
    const {
      /** Texture to copy to/from. */
      source,
      /**  Mip-map level of the texture to copy to (Default 0) */
      destinationMipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      // aspect = 'all',
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
      origin = [0, 0],
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
      destinationOrigin = [0, 0],
      /** Texture to copy to/from. */
      destination
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      // destinationMipLevel = options.mipLevel,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      // destinationOrigin = [0, 0],
      /** Defines which aspects of the texture to copy to/from. */
      // destinationAspect = options.aspect,
    } = options;
    let {
      width = options.destination.width,
      height = options.destination.height
      // depthOrArrayLayers = 0
    } = options;
    const { framebuffer, destroyFramebuffer } = getFramebuffer(source);
    const [sourceX, sourceY] = origin;
    const [destinationX, destinationY, destinationZ] = destinationOrigin;
    const prevHandle = device.gl.bindFramebuffer(
      36160 /* FRAMEBUFFER */,
      framebuffer.handle
    );
    let texture = null;
    let textureTarget;
    if (destination instanceof WEBGLTexture) {
      texture = destination;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture.bind(0);
      textureTarget = texture.target;
    } else {
      throw new Error("invalid destination");
    }
    switch (textureTarget) {
      case 3553 /* TEXTURE_2D */:
      case 34067 /* TEXTURE_CUBE_MAP */:
        device.gl.copyTexSubImage2D(
          textureTarget,
          destinationMipLevel,
          destinationX,
          destinationY,
          sourceX,
          sourceY,
          width,
          height
        );
        break;
      case 35866 /* TEXTURE_2D_ARRAY */:
      case 32879 /* TEXTURE_3D */:
        device.gl.copyTexSubImage3D(
          textureTarget,
          destinationMipLevel,
          destinationX,
          destinationY,
          destinationZ,
          sourceX,
          sourceY,
          width,
          height
        );
        break;
      default:
    }
    if (texture) {
      texture.unbind();
    }
    device.gl.bindFramebuffer(36160 /* FRAMEBUFFER */, prevHandle);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
  function getFramebuffer(source) {
    if (source instanceof import_core19.Texture) {
      const { width, height, id } = source;
      const framebuffer = source.device.createFramebuffer({
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [source]
      });
      return { framebuffer, destroyFramebuffer: true };
    }
    return { framebuffer: source, destroyFramebuffer: false };
  }

  // src/adapter/resources/webgl-command-encoder.ts
  var WEBGLCommandEncoder = class extends import_core20.CommandEncoder {
    device;
    commandBuffer;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.commandBuffer = new WEBGLCommandBuffer(device);
    }
    destroy() {
    }
    finish() {
      this.commandBuffer.submitCommands();
    }
    // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
    // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
    // finish(options?: {id?: string}): GPUCommandBuffer;
    copyBufferToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
    }
    copyBufferToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
    }
    copyTextureToBuffer(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
    }
    copyTextureToTexture(options) {
      this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
    }
    pushDebugGroup(groupLabel) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(markerLabel) {
    }
    resolveQuerySet(querySet, destination, options) {
    }
  };

  // src/adapter/resources/webgl-vertex-array.ts
  var import_core21 = __toESM(require_core(), 1);
  var WEBGLVertexArray = class extends import_core21.VertexArray {
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    device;
    handle;
    /** Attribute 0 buffer constant */
    buffer = null;
    bufferValue = null;
    /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
    static isConstantAttributeZeroSupported(device) {
      return getBrowser() === "Chrome";
    }
    // Create a VertexArray
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.handle = this.device.gl.createVertexArray();
    }
    destroy() {
      super.destroy();
      if (this.buffer) {
        this.buffer?.destroy();
      }
      if (this.handle) {
        this.device.gl.deleteVertexArray(this.handle);
        this.handle = void 0;
      }
    }
    /**
    // Set (bind/unbind) an elements buffer, for indexed rendering.
    // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
     *
     * @param elementBuffer
     */
    setIndexBuffer(indexBuffer) {
      const buffer = indexBuffer;
      if (buffer && buffer.glTarget !== 34963 /* ELEMENT_ARRAY_BUFFER */) {
        throw new Error("Use .setBuffer()");
      }
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, buffer ? buffer.handle : null);
      this.indexBuffer = buffer;
      this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
    setBuffer(location, attributeBuffer) {
      const buffer = attributeBuffer;
      if (buffer.glTarget === 34963 /* ELEMENT_ARRAY_BUFFER */) {
        throw new Error("Use .setIndexBuffer()");
      }
      const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
      this.device.gl.bindVertexArray(this.handle);
      this.device.gl.bindBuffer(34962 /* ARRAY_BUFFER */, buffer.handle);
      if (integer) {
        this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      this.device.gl.enableVertexAttribArray(location);
      this.device.gl.vertexAttribDivisor(location, divisor || 0);
      this.attributes[location] = buffer;
      this.device.gl.bindVertexArray(null);
    }
    /** Set a location in vertex attributes array to a constant value, disables the location */
    setConstantWebGL(location, value) {
      this._enable(location, false);
      this.attributes[location] = value;
    }
    bindBeforeRender() {
      this.device.gl.bindVertexArray(this.handle);
      this._applyConstantAttributes();
    }
    unbindAfterRender() {
      this.device.gl.bindVertexArray(null);
    }
    // Internal methods
    /**
     * Constant attributes need to be reset before every draw call
     * Any attribute that is disabled in the current vertex array object
     * is read from the context's global constant value for that attribute location.
     * @note Constant attributes are only supported in WebGL, not in WebGPU
     */
    _applyConstantAttributes() {
      for (let location = 0; location < this.maxVertexAttributes; ++location) {
        const constant = this.attributes[location];
        if (ArrayBuffer.isView(constant)) {
          this.device.setConstantAttributeWebGL(location, constant);
        }
      }
    }
    /**
     * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
     * @note requires vertex array to be bound
     */
    // protected _setAttributeLayout(location: number): void {
    //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
    //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
    //   if (integer) {
    //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
    //   } else {
    //     // Attaches ARRAY_BUFFER with specified buffer format to location
    //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    //   }
    //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
    // }
    /** Get an accessor from the  */
    _getAccessor(location) {
      const attributeInfo = this.attributeInfos[location];
      if (!attributeInfo) {
        throw new Error(`Unknown attribute location ${location}`);
      }
      const glType = getGLFromVertexType(attributeInfo.bufferDataType);
      return {
        size: attributeInfo.bufferComponents,
        type: glType,
        stride: attributeInfo.byteStride,
        offset: attributeInfo.byteOffset,
        normalized: attributeInfo.normalized,
        // it is the shader attribute declaration, not the vertex memory format,
        // that determines if the data in the buffer will be treated as integers.
        //
        // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
        // but as far as we can tell, WebGPU does not.
        integer: attributeInfo.integer,
        divisor: attributeInfo.stepMode === "instance" ? 1 : 0
      };
    }
    /**
     * Enabling an attribute location makes it reference the currently bound buffer
     * Disabling an attribute location makes it reference the global constant value
     * TODO - handle single values for size 1 attributes?
     * TODO - convert classic arrays based on known type?
     */
    _enable(location, enable2 = true) {
      const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
      const canDisableAttribute = canDisableAttributeZero || location !== 0;
      if (enable2 || canDisableAttribute) {
        location = Number(location);
        this.device.gl.bindVertexArray(this.handle);
        if (enable2) {
          this.device.gl.enableVertexAttribArray(location);
        } else {
          this.device.gl.disableVertexAttribArray(location);
        }
        this.device.gl.bindVertexArray(null);
      }
    }
    /**
     * Provide a means to create a buffer that is equivalent to a constant.
     * NOTE: Desktop OpenGL cannot disable attribute 0.
     * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
     * this-has-significant-performance-penalty
     */
    getConstantBuffer(elementCount, value) {
      const constantValue = normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length = constantValue.length * elementCount;
      if (this.buffer && byteLength !== this.buffer.byteLength) {
        throw new Error(
          `Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`
        );
      }
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || this.device.createBuffer({ byteLength });
      updateNeeded = updateNeeded || !compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = (0, import_core21.getScratchArray)(value.constructor, length);
        (0, import_core21.fillArray)({ target: typedArray, source: constantValue, start: 0, count: length });
        this.buffer.write(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
  };
  function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }

  // src/adapter/resources/webgl-transform-feedback.ts
  var import_core22 = __toESM(require_core(), 1);
  var WEBGLTransformFeedback = class extends import_core22.TransformFeedback {
    device;
    gl;
    handle;
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    layout;
    buffers = {};
    unusedBuffers = {};
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    bindOnUse = true;
    _bound = false;
    constructor(device, props) {
      super(device, props);
      this.device = device;
      this.gl = device.gl;
      this.handle = this.props.handle || this.gl.createTransformFeedback();
      this.layout = this.props.layout;
      if (props.buffers) {
        this.setBuffers(props.buffers);
      }
      Object.seal(this);
    }
    destroy() {
      this.gl.deleteTransformFeedback(this.handle);
      super.destroy();
    }
    begin(topology = "point-list") {
      this.gl.bindTransformFeedback(36386 /* TRANSFORM_FEEDBACK */, this.handle);
      if (this.bindOnUse) {
        this._bindBuffers();
      }
      this.gl.beginTransformFeedback(getGLPrimitive(topology));
    }
    end() {
      this.gl.endTransformFeedback();
      if (!this.bindOnUse) {
        this._unbindBuffers();
      }
      this.gl.bindTransformFeedback(36386 /* TRANSFORM_FEEDBACK */, null);
    }
    // SUBCLASS
    setBuffers(buffers) {
      this.buffers = {};
      this.unusedBuffers = {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
    }
    setBuffer(locationOrName, bufferOrRange) {
      const location = this._getVaryingIndex(locationOrName);
      const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
      if (location < 0) {
        this.unusedBuffers[locationOrName] = buffer;
        import_core22.log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
        return;
      }
      this.buffers[location] = { buffer, byteLength, byteOffset };
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteLength);
      }
    }
    getBuffer(locationOrName) {
      if (isIndex(locationOrName)) {
        return this.buffers[locationOrName] || null;
      }
      const location = this._getVaryingIndex(locationOrName);
      return location >= 0 ? this.buffers[location] : null;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this.gl.bindTransformFeedback(36386 /* TRANSFORM_FEEDBACK */, funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this.gl.bindTransformFeedback(36386 /* TRANSFORM_FEEDBACK */, this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this.gl.bindTransformFeedback(36386 /* TRANSFORM_FEEDBACK */, null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    // PRIVATE METHODS
    /** Extract offsets for bindBufferRange */
    _getBufferRange(bufferOrRange) {
      if (bufferOrRange instanceof WEBGLBuffer) {
        return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
      }
      const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
      return { buffer, byteOffset, byteLength };
    }
    _getVaryingIndex(locationOrName) {
      if (isIndex(locationOrName)) {
        return Number(locationOrName);
      }
      for (const varying of this.layout.varyings) {
        if (locationOrName === varying.name) {
          return varying.location;
        }
      }
      return -1;
    }
    /**
     * Need to avoid chrome bug where buffer that is already bound to a different target
     * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     */
    _bindBuffers() {
      for (const bufferIndex in this.buffers) {
        const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
        this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
      }
    }
    _unbindBuffers() {
      for (const bufferIndex in this.buffers) {
        this.gl.bindBufferBase(35982 /* TRANSFORM_FEEDBACK_BUFFER */, Number(bufferIndex), null);
      }
    }
    _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
      const handle = buffer && buffer.handle;
      if (!handle || byteLength === void 0) {
        this.gl.bindBufferBase(35982 /* TRANSFORM_FEEDBACK_BUFFER */, index, handle);
      } else {
        this.gl.bindBufferRange(35982 /* TRANSFORM_FEEDBACK_BUFFER */, index, handle, byteOffset, byteLength);
      }
    }
  };
  function isIndex(value) {
    if (typeof value === "number") {
      return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
  }

  // src/adapter/resources/webgl-query-set.ts
  var import_core23 = __toESM(require_core(), 1);
  var WEBGLQuerySet = class extends import_core23.QuerySet {
    device;
    handle;
    target = null;
    _queryPending = false;
    _pollingPromise = null;
    get [Symbol.toStringTag]() {
      return "Query";
    }
    // Create a query class
    constructor(device, props) {
      super(device, props);
      this.device = device;
      if (props.count > 1) {
        throw new Error("WebGL QuerySet can only have one value");
      }
      this.handle = this.device.gl.createQuery();
      Object.seal(this);
    }
    destroy() {
      this.device.gl.deleteQuery(this.handle);
    }
    // FOR RENDER PASS AND COMMAND ENCODER
    /**
     * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
     * Measures GPU time delta between this call and a matching `end` call in the
     * GPU instruction stream.
     */
    beginTimestampQuery() {
      return this._begin(35007 /* TIME_ELAPSED_EXT */);
    }
    endTimestampQuery() {
      this._end();
    }
    // Shortcut for occlusion queries
    beginOcclusionQuery(options) {
      return this._begin(
        options?.conservative ? 36202 /* ANY_SAMPLES_PASSED_CONSERVATIVE */ : 35887 /* ANY_SAMPLES_PASSED */
      );
    }
    endOcclusionQuery() {
      this._end();
    }
    // Shortcut for transformFeedbackQuery
    beginTransformFeedbackQuery() {
      return this._begin(35976 /* TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN */);
    }
    endTransformFeedbackQuery() {
      this._end();
    }
    async resolveQuery() {
      const value = await this.pollQuery();
      return [value];
    }
    // PRIVATE METHODS
    /**
     * Due to OpenGL API limitations, after calling `begin()` on one Query
     * instance, `end()` must be called on that same instance before
     * calling `begin()` on another query. While there can be multiple
     * outstanding queries representing disjoint `begin()`/`end()` intervals.
     * It is not possible to interleave or overlap `begin` and `end` calls.
     */
    _begin(target) {
      if (this._queryPending) {
        return;
      }
      this.target = target;
      this.device.gl.beginQuery(this.target, this.handle);
      return;
    }
    // ends the current query
    _end() {
      if (this._queryPending) {
        return;
      }
      if (this.target) {
        this.device.gl.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return;
    }
    // Returns true if the query result is available
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.device.gl.getQueryParameter(
        this.handle,
        34919 /* QUERY_RESULT_AVAILABLE */
      );
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    // Timing query is disjoint, i.e. results are invalid
    isTimerDisjoint() {
      return this.device.gl.getParameter(36795 /* GPU_DISJOINT_EXT */);
    }
    // Returns query result.
    getResult() {
      return this.device.gl.getQueryParameter(this.handle, 34918 /* QUERY_RESULT */);
    }
    // Returns the query result, converted to milliseconds to match JavaScript conventions.
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    // Polls the query
    pollQuery(limit = Number.POSITIVE_INFINITY) {
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter = 0;
      this._pollingPromise = new Promise((resolve, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve(this.getResult());
            this._pollingPromise = null;
          } else if (counter++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
  };

  // src/classic/copy-and-blit.ts
  var import_core25 = __toESM(require_core(), 1);

  // src/classic/format-utils.ts
  var import_core24 = __toESM(require_core(), 1);
  function glFormatToComponents(format) {
    switch (format) {
      case 6406 /* ALPHA */:
      case 33326 /* R32F */:
      case 6403 /* RED */:
        return 1;
      case 33328 /* RG32F */:
      case 33319 /* RG */:
        return 2;
      case 6407 /* RGB */:
      case 34837 /* RGB32F */:
        return 3;
      case 6408 /* RGBA */:
      case 34836 /* RGBA32F */:
        return 4;
      default:
        (0, import_core24.assert)(false);
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121 /* UNSIGNED_BYTE */:
        return 1;
      case 33635 /* UNSIGNED_SHORT_5_6_5 */:
      case 32819 /* UNSIGNED_SHORT_4_4_4_4 */:
      case 32820 /* UNSIGNED_SHORT_5_5_5_1 */:
        return 2;
      case 5126 /* FLOAT */:
        return 4;
      default:
        (0, import_core24.assert)(false);
        return 0;
    }
  }

  // src/classic/copy-and-blit.ts
  function readPixelsToArray(source, options) {
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408 /* RGBA */,
      sourceAttachment = 36064 /* COLOR_ATTACHMENT0 */
      // TODO - support gl.readBuffer
    } = options || {};
    let {
      target = null,
      // following parameters are auto deduced if not provided
      sourceWidth,
      sourceHeight,
      sourceType
    } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    (0, import_core25.assert)(framebuffer);
    const { gl, handle } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const attachment = sourceAttachment - 36064 /* COLOR_ATTACHMENT0 */;
    sourceType = sourceType || framebuffer.colorAttachments[attachment]?.texture?.type || 5121 /* UNSIGNED_BYTE */;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160 /* FRAMEBUFFER */, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160 /* FRAMEBUFFER */, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return target;
  }
  function readPixelsToBuffer(source, options) {
    const {
      target,
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408 /* RGBA */,
      targetByteOffset = 0
    } = options || {};
    let { sourceWidth, sourceHeight, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    (0, import_core25.assert)(framebuffer);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const webglFramebuffer = framebuffer;
    sourceType = sourceType || 5121 /* UNSIGNED_BYTE */;
    let webglBufferTarget = target;
    if (!webglBufferTarget) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
    }
    const commandEncoder = source.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
      source,
      width: sourceWidth,
      height: sourceHeight,
      origin: [sourceX, sourceY],
      destination: webglBufferTarget,
      byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return webglBufferTarget;
  }
  function getFramebuffer2(source) {
    if (!(source instanceof import_core25.Framebuffer)) {
      return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
    }
    return { framebuffer: source, deleteFramebuffer: false };
  }
  function toFramebuffer(texture, props) {
    const { device, width, height, id } = texture;
    const framebuffer = device.createFramebuffer({
      ...props,
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [texture]
    });
    return framebuffer;
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121 /* UNSIGNED_BYTE */;
    const ArrayType = getTypedArrayFromGLType(type, { clamped: false });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // src/classic/clear.ts
  var import_core26 = __toESM(require_core(), 1);
  var GL_DEPTH_BUFFER_BIT2 = 256;
  var GL_STENCIL_BUFFER_BIT2 = 1024;
  var GL_COLOR_BUFFER_BIT2 = 16384;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(device, options) {
    const { framebuffer = null, color = null, depth = null, stencil = null } = options || {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT2;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT2;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT2;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    (0, import_core26.assert)(clearFlags !== 0, ERR_ARGUMENTS);
    const gl = device.gl;
    withGLParameters(gl, parameters, () => {
      gl.clear(clearFlags);
    });
  }

  // src/adapter/webgl-device.ts
  var LOG_LEVEL2 = 1;
  var _WebGLDevice = class extends import_core27.Device {
    /** type of this device */
    type = "webgl";
    /** The underlying WebGL context */
    handle;
    features;
    limits;
    info;
    canvasContext;
    lost;
    _resolveContextLost;
    //
    // Static methods, expected to be present by `luma.createDevice()`
    //
    /** Check if WebGL 2 is available */
    static isSupported() {
      return typeof WebGL2RenderingContext !== "undefined";
    }
    /**
     * Get a device instance from a GL context
     * Creates and instruments the device if not already created
     * @param gl
     * @returns
     */
    static attach(gl) {
      if (gl instanceof _WebGLDevice) {
        return gl;
      }
      if (gl?.device instanceof import_core27.Device) {
        return gl.device;
      }
      if (!isWebGL(gl)) {
        throw new Error("Invalid WebGL2RenderingContext");
      }
      return new _WebGLDevice({ gl });
    }
    static async create(props = {}) {
      import_core27.log.groupCollapsed(LOG_LEVEL2, "WebGLDevice created")();
      const promises = [];
      if (props.debug) {
        promises.push(loadWebGLDeveloperTools());
      }
      if (props.spector) {
        promises.push(loadSpectorJS());
      }
      if (typeof props.canvas === "string") {
        promises.push(import_core27.CanvasContext.pageLoaded);
      }
      const results = await Promise.allSettled(promises);
      for (const result of results) {
        if (result.status === "rejected") {
          import_core27.log.error(`Failed to initialize debug libraries ${result.reason}`)();
        }
      }
      import_core27.log.probe(LOG_LEVEL2 + 1, "DOM is loaded")();
      if (props.gl?.device) {
        import_core27.log.warn("reattaching existing device")();
        return _WebGLDevice.attach(props.gl);
      }
      const device = new _WebGLDevice(props);
      const message2 = `Created ${device.type}${device.debug ? " debug" : ""} context: ${device.info.vendor}, ${device.info.renderer} for canvas: ${device.canvasContext.id}`;
      import_core27.log.probe(LOG_LEVEL2, message2)();
      import_core27.log.table(LOG_LEVEL2, device.info)();
      import_core27.log.groupEnd(LOG_LEVEL2)();
      return device;
    }
    //
    // Public API
    //
    constructor(props) {
      super({ ...props, id: props.id || (0, import_core27.uid)("webgl-device") });
      const device = props.gl?.device;
      if (device) {
        throw new Error(`WebGL context already attached to device ${device.id}`);
      }
      const canvas = props.gl?.canvas || props.canvas;
      this.canvasContext = new WebGLCanvasContext(this, { ...props, canvas });
      this.lost = new Promise((resolve) => {
        this._resolveContextLost = resolve;
      });
      let gl = props.gl || null;
      gl ||= createBrowserContext(this.canvasContext.canvas, {
        ...props,
        onContextLost: (event) => this._resolveContextLost?.({
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        })
      });
      if (!gl) {
        throw new Error("WebGL context creation failed");
      }
      this.handle = gl;
      this.gl = gl;
      this.gl.device = this;
      this.gl._version = 2;
      this.info = getDeviceInfo(this.gl, this._extensions);
      this.limits = new WebGLDeviceLimits(this.gl);
      this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props.disabledFeatures);
      if (this.props.initalizeFeatures) {
        this.features.initializeFeatures();
      }
      this.canvasContext.resize();
      const { enable: enable2 = true, copyState = false } = props;
      trackContextState(this.gl, {
        enable: enable2,
        copyState,
        log: (...args) => import_core27.log.log(1, ...args)()
      });
      if (props.debug) {
        this.gl = makeDebugContext(this.gl, { ...props, throwOnError: true });
        this.debug = true;
        import_core27.log.level = Math.max(import_core27.log.level, 1);
        import_core27.log.warn("WebGL debug mode activated. Performance reduced.")();
      }
      if (props.spector) {
        this.spectorJS = initializeSpectorJS({ ...this.props, canvas: this.handle.canvas });
      }
    }
    /**
     * Destroys the context
     * @note Has no effect for WebGL browser contexts, there is no browser API for destroying contexts
     */
    destroy() {
    }
    get isLost() {
      return this.gl.isContextLost();
    }
    getSize() {
      return [this.gl.drawingBufferWidth, this.gl.drawingBufferHeight];
    }
    isTextureFormatSupported(format) {
      return isTextureFormatSupported(this.gl, format, this._extensions);
    }
    isTextureFormatFilterable(format) {
      return isTextureFormatFilterable(this.gl, format, this._extensions);
    }
    isTextureFormatRenderable(format) {
      return isTextureFormatRenderable(this.gl, format, this._extensions);
    }
    // IMPLEMENTATION OF ABSTRACT DEVICE
    createCanvasContext(props) {
      throw new Error("WebGL only supports a single canvas");
    }
    createBuffer(props) {
      const newProps = this._getBufferProps(props);
      return new WEBGLBuffer(this, newProps);
    }
    _createTexture(props) {
      return new WEBGLTexture(this, props);
    }
    createExternalTexture(props) {
      throw new Error("createExternalTexture() not implemented");
    }
    createSampler(props) {
      return new WEBGLSampler(this, props);
    }
    createShader(props) {
      return new WEBGLShader(this, props);
    }
    createFramebuffer(props) {
      return new WEBGLFramebuffer(this, props);
    }
    createVertexArray(props) {
      return new WEBGLVertexArray(this, props);
    }
    createTransformFeedback(props) {
      return new WEBGLTransformFeedback(this, props);
    }
    createQuerySet(props) {
      return new WEBGLQuerySet(this, props);
    }
    createRenderPipeline(props) {
      return new WEBGLRenderPipeline(this, props);
    }
    beginRenderPass(props) {
      return new WEBGLRenderPass(this, props);
    }
    createComputePipeline(props) {
      throw new Error("ComputePipeline not supported in WebGL");
    }
    beginComputePass(props) {
      throw new Error("ComputePass not supported in WebGL");
    }
    renderPass = null;
    createCommandEncoder(props) {
      return new WEBGLCommandEncoder(this, props);
    }
    /**
     * Offscreen Canvas Support: Commit the frame
     * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
     * Chrome's offscreen canvas does not require gl.commit
     */
    submit() {
      this.renderPass?.end();
      this.renderPass = null;
    }
    //
    // TEMPORARY HACKS - will be removed in v9.1
    //
    /** @deprecated - should use command encoder */
    readPixelsToArrayWebGL(source, options) {
      return readPixelsToArray(source, options);
    }
    /** @deprecated - should use command encoder */
    readPixelsToBufferWebGL(source, options) {
      return readPixelsToBuffer(source, options);
    }
    setParametersWebGL(parameters) {
      setGLParameters(this.gl, parameters);
    }
    getParametersWebGL(parameters) {
      return getGLParameters(this.gl, parameters);
    }
    withParametersWebGL(parameters, func) {
      return withGLParameters(this.gl, parameters, func);
    }
    clearWebGL(options) {
      clear(this, options);
    }
    resetWebGL() {
      import_core27.log.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
      resetGLParameters(this.gl);
    }
    //
    // WebGL-only API (not part of `Device` API)
    //
    /** WebGL2 context. */
    gl;
    debug = false;
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    _canvasSizeInfo = { clientWidth: 0, clientHeight: 0, devicePixelRatio: 1 };
    /** State used by luma.gl classes - TODO - not used? */
    _extensions = {};
    _polyfilled = false;
    /** Instance of Spector.js (if initialized) */
    spectorJS;
    /**
     * Triggers device (or WebGL context) loss.
     * @note primarily intended for testing how application reacts to device loss
     */
    loseDevice() {
      let deviceLossTriggered = false;
      const extensions = this.getExtension("WEBGL_lose_context");
      const ext = extensions.WEBGL_lose_context;
      if (ext) {
        deviceLossTriggered = true;
        ext.loseContext();
      }
      this._resolveContextLost?.({
        reason: "destroyed",
        message: "Application triggered context loss"
      });
      return deviceLossTriggered;
    }
    /** Save current WebGL context state onto an internal stack */
    pushState() {
      pushContextState(this.gl);
    }
    /** Restores previously saved context state */
    popState() {
      popContextState(this.gl);
    }
    /**
     * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
     * luma.gl ids and props can be inspected
     */
    setSpectorMetadata(handle, props) {
      handle.__SPECTOR_Metadata = props;
    }
    /**
     * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
     * Be aware that there are some duplicates especially for constants that are 0,
     * so this isn't guaranteed to return the right key in all cases.
     */
    getGLKey(value, gl) {
      gl = gl || this.gl2 || this.gl;
      const number = Number(value);
      for (const key in gl) {
        if (gl[key] === number) {
          return `GL.${key}`;
        }
      }
      return String(value);
    }
    /** Store constants */
    _constants;
    /**
     * Set a constant value for a location. Disabled attributes at that location will read from this value
     * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
     * so they need to be updated before every render
     * @todo - remember/cache values to avoid setting them unnecessarily?
     */
    setConstantAttributeWebGL(location, constant) {
      const maxVertexAttributes = this.limits.maxVertexAttributes;
      this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
      const currentConstant = this._constants[location];
      if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
        import_core27.log.info(
          1,
          `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`
        )();
      }
      this._constants[location] = constant;
      switch (constant.constructor) {
        case Float32Array:
          setConstantFloatArray(this, location, constant);
          break;
        case Int32Array:
          setConstantIntArray(this, location, constant);
          break;
        case Uint32Array:
          setConstantUintArray(this, location, constant);
          break;
        default:
          (0, import_core27.assert)(false);
      }
    }
    /** Ensure extensions are only requested once */
    getExtension(name) {
      getWebGLExtension(this.gl, name, this._extensions);
      return this._extensions;
    }
  };
  var WebGLDevice = _WebGLDevice;
  //
  // Public `Device` API
  //
  /** type of this device */
  __publicField(WebGLDevice, "type", "webgl");
  function isWebGL(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function setConstantFloatArray(device, location, array) {
    switch (array.length) {
      case 1:
        device.gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        device.gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        device.gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        device.gl.vertexAttrib4fv(location, array);
        break;
      default:
        (0, import_core27.assert)(false);
    }
  }
  function setConstantIntArray(device, location, array) {
    device.gl.vertexAttribI4iv(location, array);
  }
  function setConstantUintArray(device, location, array) {
    device.gl.vertexAttribI4uiv(location, array);
  }
  function compareConstantArrayValues2(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }

  // src/adapter/objects/webgl-resource.ts
  var import_core28 = __toESM(require_core(), 1);
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var WebGLResource = class extends import_core28.Resource {
    device;
    gl;
    gl2;
    _handle;
    _bound = false;
    // Only meaningful for resources that allocate GPU memory
    byteLength = 0;
    constructor(device, props, defaultProps) {
      super(device, props, defaultProps);
      this.device = device;
      const gl = this.device.gl;
      const { id } = props || {};
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || (0, import_core28.uid)(this.constructor.name);
      this._handle = props?.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
    }
    toString() {
      return `${this.constructor.name}(${this.id})`;
    }
    get handle() {
      return this._handle;
    }
    delete({ deleteChildren = false } = {}) {
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this.removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.destroy());
      }
      return this;
    }
    bind(funcOrHandle = this.handle) {
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    // Install stubs for removed methods
    stubRemovedMethods(className, version, methodNames) {
      return (0, import_core28.stubRemovedMethods)(this, className, version, methodNames);
    }
    // PUBLIC VIRTUAL METHODS
    initialize(props) {
    }
    // PROTECTED METHODS - These must be overridden by subclass
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, props) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    // PRIVATE METHODS
    /*
      _addStats() {
        const name = this.constructor.name;
        const stats = lumaStats.get('Resource Counts');
    
        stats.get('Resources Created').incrementCount();
        stats.get(`${name}s Created`).incrementCount();
        stats.get(`${name}s Active`).incrementCount();
      }
    
      _removeStats() {
        const name = this.constructor.name;
        const stats = lumaStats.get('Resource Counts');
    
        stats.get(`${name}s Active`).decrementCount();
      }
    
      trackAllocatedMemory(bytes, name = this.constructor.name) {
        const stats = lumaStats.get('Memory Usage');
    
        stats.get('GPU Memory').addCount(bytes);
        stats.get(`${name} Memory`).addCount(bytes);
        this.byteLength = bytes;
      }
    
      trackDeallocatedMemory(name = this.constructor.name) {
        const stats = lumaStats.get('Memory Usage');
    
        stats.get('GPU Memory').subtractCount(this.byteLength);
        stats.get(`${name} Memory`).subtractCount(this.byteLength);
        this.byteLength = 0;
      }
      */
  };

  // src/adapter/objects/webgl-renderbuffer.ts
  var import_core29 = __toESM(require_core(), 1);
  var _WEBGLRenderbuffer = class extends WebGLResource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    get width() {
      return this.props.width;
    }
    get height() {
      return this.props.height;
    }
    get format() {
      return this.props.format;
    }
    get samples() {
      return this.props.samples;
    }
    get attachment() {
      return;
    }
    /** WebGL format constant */
    glFormat;
    static isTextureFormatSupported(device, format) {
      return isRenderbufferFormatSupported(device.gl, format, device._extensions);
    }
    constructor(device, props) {
      if (typeof props.format === "number") {
        throw new Error("Renderbuffer");
      }
      super(device, props, _WEBGLRenderbuffer.defaultProps);
      this.glFormat = convertTextureFormatToGL(this.props.format);
      this._initialize(this.props);
    }
    resize(size) {
      if (size.width !== this.width || size.height !== this.height) {
        Object.assign(this.props, { ...size, format: this.format, samples: this.samples });
        this._initialize(this.props);
      }
    }
    // PRIVATE METHODS
    /** Creates and initializes a renderbuffer object's data store */
    _initialize(props) {
      const { format, width, height, samples } = props;
      (0, import_core29.assert)(format, "Needs format");
      this.trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161 /* RENDERBUFFER */, this.handle);
      if (samples !== 0) {
        this.gl.renderbufferStorageMultisample(
          36161 /* RENDERBUFFER */,
          samples,
          this.glFormat,
          width,
          height
        );
      } else {
        this.gl.renderbufferStorage(36161 /* RENDERBUFFER */, this.glFormat, width, height);
      }
      this.gl.bindRenderbuffer(36161 /* RENDERBUFFER */, null);
      this.trackAllocatedMemory(
        width * height * (samples || 1) * getTextureFormatBytesPerPixel(this.format)
      );
    }
    // RESOURCE IMPLEMENTATION
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this.trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161 /* RENDERBUFFER */, handle);
    }
  };
  var WEBGLRenderbuffer = _WEBGLRenderbuffer;
  __publicField(WEBGLRenderbuffer, "defaultProps", {
    id: void 0,
    handle: void 0,
    userData: void 0,
    format: void 0,
    // 'depth16unorm'
    width: 1,
    height: 1,
    samples: 0
  });
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
