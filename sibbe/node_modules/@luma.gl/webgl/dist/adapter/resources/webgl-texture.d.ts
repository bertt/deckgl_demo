import { Device, TextureProps, TextureViewProps, Sampler, SamplerProps, TypedArray } from '@luma.gl/core';
import { Texture } from '@luma.gl/core';
import { GL, GLSamplerParameters } from '@luma.gl/constants';
import { WebGLDevice } from "../webgl-device.js";
import { WEBGLSampler } from "./webgl-sampler.js";
import { WEBGLTextureView } from "./webgl-texture-view.js";
export type WEBGLTextureProps = TextureProps & {
    /** @deprecated use props.sampler */
    parameters?: Record<number, number>;
    /** @deprecated use props.data */
    pixels?: any;
    /** @deprecated use props.format */
    dataFormat?: number | null;
    /** @deprecated rarely supported */
    border?: number;
    /** @deprecated WebGL only. */
    pixelStore?: object;
    /** @deprecated WebGL only. */
    textureUnit?: number;
    /** @deprecated WebGL only. Use dimension. */
    target?: number;
};
export declare const DEFAULT_WEBGL_TEXTURE_PROPS: {
    parameters: {};
    pixelStore: {};
    pixels: any;
    border: number;
    dataFormat: any;
    textureUnit: any;
    target: any;
};
export type TextureSourceData = TypedArray | ImageData | HTMLImageElement | HTMLCanvasElement | ImageBitmap | HTMLVideoElement;
type SetImageDataOptions = {
    target?: number;
    level?: number;
    dataFormat?: any;
    width?: number;
    height?: number;
    depth?: number;
    glFormat?: GL;
    type?: any;
    offset?: number;
    data: any;
    compressed?: boolean;
    parameters?: Record<GL, any>;
    /** @deprecated */
    pixels?: any;
};
/**
 * @param {*} pixels, data -
 *  null - create empty texture of specified format
 *  Typed array - init from image data in typed array
 *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
 *  HTMLImageElement|Image - Inits with content of image. Auto width/height
 *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
 *  HTMLVideoElement - Creates video texture. Auto width/height
 *
 * @param  x - xOffset from where texture to be updated
 * @param  y - yOffset from where texture to be updated
 * @param  width - width of the sub image to be updated
 * @param  height - height of the sub image to be updated
 * @param  level - mip level to be updated
 * @param {GLenum} format - internal format of image data.
 * @param {GLenum} type
 *  - format of array (autodetect from type) or
 *  - (WEBGL2) format of buffer or ArrayBufferView
 * @param {GLenum} dataFormat - format of image data.
 * @param {Number} offset - (WEBGL2) offset from start of buffer
 * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
 */
type SetSubImageDataOptions = {
    target?: number;
    level?: number;
    dataFormat?: any;
    width?: number;
    height?: number;
    depth?: number;
    glFormat?: any;
    type?: any;
    offset?: number;
    data: any;
    parameters?: Record<GL, any>;
    compressed?: boolean;
    x?: number;
    y?: number;
    /** @deprecated */
    pixels?: any;
};
type SetImageData3DOptions = {
    level?: number;
    dataFormat?: any;
    width?: number;
    height?: number;
    depth?: number;
    format?: any;
    type?: any;
    offset?: number;
    data: any;
    parameters?: Record<GL, any>;
};
export declare class WEBGLTexture extends Texture<WEBGLTextureProps> {
    static FACES: number[];
    readonly MAX_ATTRIBUTES: number;
    readonly device: WebGLDevice;
    readonly gl: WebGL2RenderingContext;
    readonly handle: WebGLTexture;
    sampler: WEBGLSampler;
    view: WEBGLTextureView;
    glFormat: GL;
    type: GL;
    dataFormat: GL;
    mipmaps: boolean;
    /**
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * they get special information. When you first bind a texture as a
     * GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     * */
    target: GL;
    textureUnit: number;
    /**
     * Program.draw() checks the loaded flag of all textures to avoid
     * Textures that are still loading from promises
     * Set to true as soon as texture has been initialized with valid data
     */
    loaded: boolean;
    _video: {
        video: HTMLVideoElement;
        parameters: any;
        lastTime: number;
    };
    constructor(device: Device, props: WEBGLTextureProps);
    destroy(): void;
    toString(): string;
    createView(props: TextureViewProps): WEBGLTextureView;
    initialize(props?: WEBGLTextureProps): this;
    initializeCube(props?: WEBGLTextureProps): this;
    setSampler(sampler?: Sampler | SamplerProps): this;
    /**
     * If size has changed, reinitializes with current format
     * @note note clears image and mipmaps
     */
    resize(options: {
        height: number;
        width: number;
        mipmaps?: boolean;
    }): this;
    /** Update external texture (video frame) */
    update(): void;
    generateMipmap(params?: {}): this;
    setImageData(options: SetImageDataOptions): this;
    /**
     * Redefines an area of an existing texture
     * Note: does not allocate storage
     * Redefines an area of an existing texture
     */
    setSubImageData({ target, pixels, data, x, y, width, height, level, glFormat, type, dataFormat, compressed, offset, parameters }: SetSubImageDataOptions): void;
    /**
     * Defines a two-dimensional texture image or cube-map texture image with
     * pixels from the current framebuffer (rather than from client memory).
     * (gl.copyTexImage2D wrapper)
     *
     * Note that binding a texture into a Framebuffer's color buffer and
     * rendering can be faster.
     */
    copyFramebuffer(opts?: {}): any;
    getActiveUnit(): number;
    bind(textureUnit?: number): number;
    unbind(textureUnit?: number): number;
    _getDataType({ data, compressed }: {
        data: any;
        compressed?: boolean;
    }): {
        data: any;
        dataType: string;
    };
    _deduceParameters(opts: WEBGLTextureProps): {
        dataFormat: number;
        type: number;
        compressed: boolean;
        width: number;
        height: number;
        format: import("@luma.gl/core").TextureFormat;
        data: string | import("@luma.gl/core").TextureData | Promise<import("@luma.gl/core").TextureData> | import("modules/core/dist/adapter/resources/texture").CubeTextureData | HTMLVideoElement;
    };
    _deduceImageSize(data: any, width: any, height: any): {
        width: number;
        height: number;
    };
    setCubeMapImageData(options: {
        width: any;
        height: any;
        pixels: any;
        data: any;
        format?: any;
        type?: any;
    }): Promise<void>;
    /** @todo update this method to accept LODs */
    setImageDataForFace(options: any): this;
    /** Image 3D copies from Typed Array or WebGLBuffer */
    setImageData3D(options: SetImageData3DOptions): this;
    /**
     * Sets sampler parameters on texture
     */
    _setSamplerParameters(parameters: GLSamplerParameters): void;
}
export {};
//# sourceMappingURL=webgl-texture.d.ts.map