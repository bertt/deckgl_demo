import { ResourceProps, TextureFormat } from '@luma.gl/core';
import { GL } from '@luma.gl/constants';
import { WebGLDevice } from "../webgl-device.js";
import { WebGLResource } from "./webgl-resource.js";
export type RenderbufferProps = ResourceProps & {
    format: TextureFormat;
    width?: number;
    height?: number;
    samples?: number;
};
/**
 * Renderbuffers are GPU objects that contain images.
 * In contrast to Textures they are optimized for use as render targets, with Framebuffers.
 * while Textures may not be, and are the logical choice when
 * you do not need to sample (i.e. in a post-pass shader)
 * from the produced image. If you need to resample
 * (such as when reading depth back in a second shader pass),
 * use Textures instead.
 * Renderbuffer objects also natively accommodate Multisampling (MSAA).
 */
export declare class WEBGLRenderbuffer extends WebGLResource<RenderbufferProps> {
    static readonly defaultProps: Required<RenderbufferProps>;
    get [Symbol.toStringTag](): string;
    get width(): number;
    get height(): number;
    get format(): TextureFormat;
    get samples(): number;
    get attachment(): void;
    /** WebGL format constant */
    glFormat: GL;
    static isTextureFormatSupported(device: WebGLDevice, format: TextureFormat): boolean;
    constructor(device: WebGLDevice, props: RenderbufferProps);
    resize(size: {
        width: number;
        height: number;
    }): void;
    /** Creates and initializes a renderbuffer object's data store */
    protected _initialize(props: Required<RenderbufferProps>): void;
    _createHandle(): WebGLRenderbuffer;
    _deleteHandle(): void;
    _bindHandle(handle: WEBGLRenderbuffer): void;
}
//# sourceMappingURL=webgl-renderbuffer.d.ts.map