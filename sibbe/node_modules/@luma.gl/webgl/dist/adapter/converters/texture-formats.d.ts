import type { TextureFormat, DeviceFeature } from '@luma.gl/core';
import { GL, GLExtensions } from '@luma.gl/constants';
export declare const TEXTURE_FEATURES: Partial<Record<DeviceFeature, string[]>>;
/** Return a list of texture feature strings (for Device.features). Mainly compressed texture support */
export declare function isTextureFeature(feature: DeviceFeature): boolean;
/** Checks a texture feature (for Device.features). Mainly compressed texture support */
export declare function checkTextureFeature(gl: WebGL2RenderingContext, feature: DeviceFeature, extensions: GLExtensions): boolean;
/** Map a format to webgl and constants */
type Format = {
    gl?: GL;
    /** format requires WebGL2, when using a WebGL 1 context, color renderbuffer formats are limited */
    gl2ext?: string;
    /** (bytes per pixel), for memory usage calculations. */
    b?: number;
    /** channels */
    c?: number;
    bpp?: number;
    /** packed */
    p?: number;
    /** compressed */
    x?: string;
    /** for compressed texture formats */
    f?: DeviceFeature;
    /** renderable if feature is present */
    render?: DeviceFeature;
    /** filterable if feature is present */
    filter?: DeviceFeature;
    /** If not supported on WebGPU */
    wgpu?: false;
    types?: number[];
    dataFormat?: GL;
    /** Depth and stencil format attachment points. If set, needs to be a Renderbuffer unless depthTexture is set  */
    attachment?: GL.DEPTH_ATTACHMENT | GL.STENCIL_ATTACHMENT | GL.DEPTH_STENCIL_ATTACHMENT;
    /** if depthTexture is set this is a depth/stencil format that can be set to a texture  */
    depthTexture?: boolean;
    /** @deprecated can this format be used with renderbuffers */
    rb?: boolean;
};
/**
 * Texture format data -
 * Exported but can change without notice
 */
export declare const TEXTURE_FORMATS: Record<TextureFormat, Format>;
/** Checks if a texture format is supported */
export declare function isTextureFormatSupported(gl: WebGL2RenderingContext, format: TextureFormat, extensions: GLExtensions): boolean;
export declare function isRenderbufferFormatSupported(gl: WebGL2RenderingContext, format: TextureFormat, extensions: GLExtensions): boolean;
/**
 * Map WebGL texture formats (GL constants) to WebGPU-style TextureFormat strings
 */
export declare function convertGLToTextureFormat(format: GL | TextureFormat): TextureFormat;
/**
 * Map WebGPU style texture format strings to GL constants
 */
export declare function convertTextureFormatToGL(format: TextureFormat): GL | undefined;
/** Checks if a texture format is supported */
export declare function getTextureFormatSupport(gl: WebGL2RenderingContext, format: TextureFormat, extensions: GLExtensions): {
    supported: boolean;
    filterable?: boolean;
    renderable?: boolean;
    blendable?: boolean;
    storable?: boolean;
};
/** Checks whether linear filtering (interpolated sampling) is available for floating point textures */
export declare function isTextureFormatFilterable(gl: WebGL2RenderingContext, format: TextureFormat, extensions: GLExtensions): boolean;
export declare function isTextureFormatRenderable(gl: WebGL2RenderingContext, format: TextureFormat, extensions: GLExtensions): boolean;
/** Get parameters necessary to work with format in WebGL: internalFormat, dataFormat, type, compressed, */
export declare function getWebGLTextureParameters(format: TextureFormat): {
    format: GL;
    dataFormat: GL;
    type: number;
    compressed: any;
};
export declare function getDepthStencilAttachmentWebGL(format: TextureFormat): GL.DEPTH_ATTACHMENT | GL.STENCIL_ATTACHMENT | GL.DEPTH_STENCIL_ATTACHMENT;
/** TODO - VERY roundabout legacy way of calculating bytes per pixel */
export declare function getTextureFormatBytesPerPixel(format: TextureFormat): number;
export {};
//# sourceMappingURL=texture-formats.d.ts.map