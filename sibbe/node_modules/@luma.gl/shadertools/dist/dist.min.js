(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['luma'] = factory();
  else root['luma'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var jn=Object.create;var ue=Object.defineProperty;var $n=Object.getOwnPropertyDescriptor;var Kn=Object.getOwnPropertyNames;var Zn=Object.getPrototypeOf,Jn=Object.prototype.hasOwnProperty;var eo=(t,e,r)=>e in t?ue(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r;var to=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),ro=(t,e)=>{for(var r in e)ue(t,r,{get:e[r],enumerable:!0})},ve=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Kn(e))!Jn.call(t,o)&&o!==r&&ue(t,o,{get:()=>e[o],enumerable:!(n=$n(e,o))||n.enumerable});return t},Ae=(t,e,r)=>(ve(t,e,"default"),r&&ve(r,e,"default")),or=(t,e,r)=>(r=t!=null?jn(Zn(t)):{},ve(e||!t||!t.__esModule?ue(r,"default",{value:t,enumerable:!0}):r,t)),no=t=>ve(ue({},"__esModule",{value:!0}),t);var ir=(t,e,r)=>(eo(t,typeof e!="symbol"?e+"":e,r),r);var $e=to((Ri,sr)=>{sr.exports=globalThis.luma});var xe={};ro(xe,{ShaderAssembler:()=>pe,ShaderModuleInstance:()=>C,_ShaderModuleInstance:()=>C,_getDependencyGraph:()=>be,_resolveModules:()=>re,_warp:()=>ce,assembleShaderPairGLSL:()=>Pe,brightnessContrast:()=>Gr,bulgePinch:()=>ln,capitalize:()=>K,colorHalftone:()=>rn,combineInjects:()=>mr,convertToVec4:()=>it,denoise:()=>Hr,dirlight:()=>Qt,dirlight1:()=>Qn,dotScreen:()=>nn,edgeWork:()=>on,fp32:()=>Ur,fp64:()=>pn,fp64arithmetic:()=>Ht,fxaa:()=>un,generateShaderForModule:()=>Ir,geometry1:()=>dn,getPassthroughFS:()=>Nr,getQualifierDetails:()=>kr,getShaderInfo:()=>ye,getShaderLayoutFromWGSL:()=>Or,glsl:()=>ar,gouraudLighting:()=>Vn,gouraudMaterial:()=>Bt,hexagonalPixelate:()=>sn,hueSaturation:()=>Wr,ink:()=>an,lighting:()=>Q,lights1:()=>te,magnify:()=>cn,noise:()=>jr,normalizeShaderModule:()=>Sr,pbr:()=>Wn,pbrMaterial:()=>qr,phongLighting:()=>qn,phongMaterial:()=>Vt,picking:()=>zr,project1:()=>je,random:()=>B,sepia:()=>$r,swirl:()=>fn,tiltShift:()=>Jr,triangleBlur:()=>en,typeToChannelCount:()=>Tr,typeToChannelSuffix:()=>Er,vibrance:()=>Kr,vignette:()=>Zr,zoomBlur:()=>tn});Ae(xe,or($e(),1));var ar=t=>`${t}`;function z(t,e){if(!t)throw new Error(e||"shadertools: assertion failed.")}var Ke={number:{type:"number",validate(t,e){return Number.isFinite(t)&&typeof e=="object"&&(e.max===void 0||t<=e.max)&&(e.min===void 0||t>=e.min)}},array:{type:"array",validate(t,e){return Array.isArray(t)||ArrayBuffer.isView(t)}}};function lr(t){let e={};for(let[r,n]of Object.entries(t))e[r]=oo(n);return e}function fr(t,e,r){let n={};for(let[o,i]of Object.entries(e))t&&o in t&&!i.private?(i.validate&&z(i.validate(t[o],i),`${r}: invalid ${o}`),n[o]=t[o]):n[o]=i.value;return n}function oo(t){let e=cr(t);if(e!=="object")return{value:t,...Ke[e],type:e};if(typeof t=="object")return t?t.type!==void 0?{...t,...Ke[t.type],type:t.type}:t.value===void 0?{type:"object",value:t}:(e=cr(t.value),{...t,...Ke[e],type:e}):{type:"object",value:null};throw new Error("props")}function cr(t){return Array.isArray(t)||ArrayBuffer.isView(t)?"array":typeof t}var ur=`#ifdef MODULE_LOGDEPTH
logdepth_adjustPosition(gl_Position);
#endif
`,_r=`#ifdef MODULE_MATERIAL
gl_FragColor = material_filterColor(gl_FragColor);
#endif
#ifdef MODULE_LIGHTING
gl_FragColor = lighting_filterColor(gl_FragColor);
#endif
#ifdef MODULE_FOG
gl_FragColor = fog_filterColor(gl_FragColor);
#endif
#ifdef MODULE_PICKING
gl_FragColor = picking_filterHighlightColor(gl_FragColor);
gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif
#ifdef MODULE_LOGDEPTH
logdepth_setFragDepth();
#endif
`;var io={vertex:ur,fragment:_r},hr=/void\s+main\s*\([^)]*\)\s*\{\n?/,pr=/}\n?[^{}]*$/,Ze=[],_e="__LUMA_INJECT_DECLARATIONS__";function dr(t){let e={vertex:{},fragment:{}};for(let r in t){let n=t[r],o=so(r);typeof n=="string"&&(n={order:0,injection:n}),e[o][r]=n}return e}function so(t){let e=t.slice(0,2);switch(e){case"vs":return"vertex";case"fs":return"fragment";default:throw new Error(e)}}function he(t,e,r,n=!1){let o=e==="vertex";for(let i in r){let a=r[i];a.sort((u,h)=>u.order-h.order),Ze.length=a.length;for(let u=0,h=a.length;u<h;++u)Ze[u]=a[u].injection;let f=`${Ze.join(`
`)}
`;switch(i){case"vs:#decl":o&&(t=t.replace(_e,f));break;case"vs:#main-start":o&&(t=t.replace(hr,u=>u+f));break;case"vs:#main-end":o&&(t=t.replace(pr,u=>f+u));break;case"fs:#decl":o||(t=t.replace(_e,f));break;case"fs:#main-start":o||(t=t.replace(hr,u=>u+f));break;case"fs:#main-end":o||(t=t.replace(pr,u=>f+u));break;default:t=t.replace(i,u=>u+f)}}return t=t.replace(_e,""),n&&(t=t.replace(/\}\s*$/,i=>i+io[e])),t}function mr(t){let e={};return z(Array.isArray(t)&&t.length>1),t.forEach(r=>{for(let n in r)e[n]=e[n]?`${e[n]}
${r[n]}`:r[n]}),e}var ao=1,C=class{name;vs;fs;getModuleUniforms;dependencies;deprecations;defines;injections;uniforms={};uniformTypes={};static instantiateModules(e){return e.map(r=>{if(r instanceof C)return r;z(typeof r!="string",`Shader module use by name is deprecated. Import shader module '${JSON.stringify(r)}' and use it directly.`),r.name||(console.warn("shader module has no name"),r.name=`shader-module-${ao++}`);let n=new C(r);return n.dependencies=C.instantiateModules(r.dependencies||[]),n})}constructor(e){let{name:r,vs:n,fs:o,dependencies:i=[],uniformPropTypes:a={},getUniforms:f,deprecations:u=[],defines:h={},inject:p={}}=e;z(typeof r=="string"),this.name=r,this.vs=n,this.fs=o,this.getModuleUniforms=f,this.dependencies=C.instantiateModules(i),this.deprecations=this._parseDeprecationDefinitions(u),this.defines=h,this.injections=dr(p),a&&(this.uniforms=lr(a))}getModuleSource(e){let r;switch(e){case"vertex":r=this.vs||"";break;case"fragment":r=this.fs||"";break;default:z(!1)}let n=this.name.toUpperCase().replace(/[^0-9a-z]/gi,"_");return`// ----- MODULE ${this.name} ---------------

#define MODULE_${n}
${r}

`}getUniforms(e,r){return this.getModuleUniforms?this.getModuleUniforms(e,r):fr(e,this.uniforms,this.name)}getDefines(){return this.defines}checkDeprecations(e,r){this.deprecations.forEach(n=>{n.regex?.test(e)&&(n.deprecated?r.deprecated(n.old,n.new)():r.removed(n.old,n.new)())})}_parseDeprecationDefinitions(e){return e.forEach(r=>{switch(r.type){case"function":r.regex=new RegExp(`\\b${r.old}\\(`);break;default:r.regex=new RegExp(`${r.type} ${r.old};`)}}),e}_defaultGetUniforms(e={}){let r={},n=this.uniforms;for(let o in n){let i=n[o];o in e&&!i.private?(i.validate&&z(i.validate(e[o],i),`${this.name}: invalid ${o}`),r[o]=e[o]):r[o]=i.value}return r}};function Je(t){if(t.source&&t.platformInfo.type==="webgpu")return{...t,vs:void 0,fs:void 0};if(!t.vs)throw new Error("no vertex shader");let e=gr(t.platformInfo,t.vs),r;return t.fs&&(r=gr(t.platformInfo,t.fs)),{...t,vs:e,fs:r}}function gr(t,e){if(typeof e=="string")return e;switch(t.type){case"webgpu":if(e?.wgsl)return e.wgsl;throw new Error("WebGPU does not support GLSL shaders");default:if(e?.glsl)return e.glsl;throw new Error("WebGL does not support WGSL shaders")}}function re(t){let e=C.instantiateModules(t);return co(e)}function co(t){let e={},r={};return be({modules:t,level:0,moduleMap:e,moduleDepth:r}),Object.keys(r).sort((n,o)=>r[o]-r[n]).map(n=>e[n])}function be(t){let{modules:e,level:r,moduleMap:n,moduleDepth:o}=t;if(r>=5)throw new Error("Possible loop in shader dependency graph");for(let i of e)n[i.name]=i,(o[i.name]===void 0||o[i.name]<r)&&(o[i.name]=r);for(let i of e)i.dependencies&&be({modules:i.dependencies,level:r+1,moduleMap:n,moduleDepth:o})}function xr(t){switch(t?.gpu.toLowerCase()){case"apple":return`#define APPLE_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;case"nvidia":return`#define NVIDIA_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;case"intel":return`#define INTEL_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;case"amd":return`#define AMD_GPU
`;default:return`#define DEFAULT_GPU
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`}}function Ar(t,e){if(Number(t.match(/^#version[ \t]+(\d+)/m)?.[1]||100)!==300)throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");switch(e){case"vertex":return t=vr(t,lo),t;case"fragment":return t=vr(t,fo),t;default:throw new Error(e)}}var br=[[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,`#version 300 es
`],[/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,"textureLod("],[/\btexture(2D|2DProj|Cube)(EXT)?\(/g,"texture("]],lo=[...br,[et("attribute"),"in $1"],[et("varying"),"out $1"]],fo=[...br,[et("varying"),"in $1"]];function vr(t,e){for(let[r,n]of e)t=t.replace(r,n);return t}function et(t){return new RegExp(`\\b${t}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`,"g")}function tt(t,e){let r="";for(let n in t){let o=t[n];if(r+=`void ${o.signature} {
`,o.header&&(r+=`  ${o.header}`),e[n]){let i=e[n];i.sort((a,f)=>a.order-f.order);for(let a of i)r+=`  ${a.injection}
`}o.footer&&(r+=`  ${o.footer}`),r+=`}
`}return r}function rt(t){let e={vertex:{},fragment:{}};for(let r of t){let n,o;typeof r!="string"?(n=r,o=n.hook):(n={},o=r),o=o.trim();let[i,a]=o.split(":"),f=o.replace(/\(.+/,""),u=Object.assign(n,{signature:a});switch(i){case"vs":e.vertex[f]=u;break;case"fs":e.fragment[f]=u;break;default:throw new Error(i)}}return e}function ye(t,e){return{name:uo(t,e),language:"glsl",version:_o(t)}}function uo(t,e="unnamed"){let n=/#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(t);return n?n[1]:e}function _o(t){let e=100,r=t.match(/[^\s]+/g);if(r&&r.length>=2&&r[0]==="#version"){let n=parseInt(r[1],10);Number.isFinite(n)&&(e=n)}if(e!==100&&e!==300)throw new Error(`Invalid GLSL version ${e}`);return e}var Pr=`

${_e}
`,ho=`precision highp float;
`;function wr(t){let e=re(t.modules||[]);return{source:nt(t.platformInfo,{...t,source:t.source,stage:"vertex",modules:e}),getUniforms:ot(e)}}function Lr(t){let e=re(t.modules||[]);return{vs:nt(t.platformInfo,{...t,source:t.vs,stage:"vertex",modules:e}),fs:nt(t.platformInfo,{...t,source:t.fs,stage:"fragment",modules:e}),getUniforms:ot(e)}}function Pe(t){let{vs:e,fs:r}=t,n=re(t.modules||[]);return{vs:yr(t.platformInfo,{...t,source:e,stage:"vertex",modules:n}),fs:yr(t.platformInfo,{...t,source:r,stage:"fragment",modules:n}),getUniforms:ot(n)}}function nt(t,e){let{source:r,stage:n,modules:o,hookFunctions:i=[],inject:a={},log:f}=e;z(typeof r=="string","shader source must be a string");let u=r,h="",p=rt(i),d={},m={},x={};for(let g in a){let A=typeof a[g]=="string"?{injection:a[g],order:0}:a[g],L=/^(v|f)s:(#)?([\w-]+)$/.exec(g);if(L){let v=L[2],y=L[3];v?y==="decl"?m[g]=[A]:x[g]=[A]:d[g]=[A]}else x[g]=[A]}let w=t.type!=="webgpu"?o:[];for(let g of w){f&&g.checkDeprecations(u,f);let A=g.getModuleSource(n,"wgsl");h+=A;let L=g.injections[n];for(let v in L){let y=/^(v|f)s:#([\w-]+)$/.exec(v);if(y){let b=y[2]==="decl"?m:x;b[v]=b[v]||[],b[v].push(L[v])}else d[v]=d[v]||[],d[v].push(L[v])}}return h+=Pr,h=he(h,n,m),h+=tt(p[n],d),h+=u,h=he(h,n,x),h}function yr(t,e){let{id:r,source:n,stage:o,language:i="glsl",modules:a,defines:f={},hookFunctions:u=[],inject:h={},prologue:p=!0,log:d}=e;z(typeof n=="string","shader source must be a string");let m=i==="glsl"?ye(n).version:-1,x=t.shaderLanguageVersion,w=m===100?"#version 100":"#version 300 es",A=n.split(`
`).slice(1).join(`
`),L={};a.forEach(k=>{Object.assign(L,k.getDefines())}),Object.assign(L,f);let v="";switch(i){case"wgsl":break;case"glsl":v=p?`${w}

// ----- PROLOGUE -------------------------
${po({id:r,source:n,stage:o})}
${`#define SHADER_TYPE_${o.toUpperCase()}`}
${xr(t)}
${o==="fragment"?ho:""}

// ----- APPLICATION DEFINES -------------------------

${mo(L)}

`:`${w}
`;break}let y=rt(u),P={},b={},S={};for(let k in h){let F=typeof h[k]=="string"?{injection:h[k],order:0}:h[k],M=/^(v|f)s:(#)?([\w-]+)$/.exec(k);if(M){let N=M[2],I=M[3];N?I==="decl"?b[k]=[F]:S[k]=[F]:P[k]=[F]}else S[k]=[F]}for(let k of a){d&&k.checkDeprecations(A,d);let F=k.getModuleSource(o);v+=F;let M=k.injections[o];for(let N in M){let I=/^(v|f)s:#([\w-]+)$/.exec(N);if(I){let R=I[2]==="decl"?b:S;R[N]=R[N]||[],R[N].push(M[N])}else P[N]=P[N]||[],P[N].push(M[N])}}return v+="// ----- MAIN SHADER SOURCE -------------------------",v+=Pr,v=he(v,o,b),v+=tt(y[o],P),v+=A,v=he(v,o,S),i==="glsl"&&m!==x&&(v=Ar(v,o)),v.trim()}function ot(t){return function(r){let n={};for(let o of t){let i=o.getUniforms(r,n);Object.assign(n,i)}return n}}function po(t){let{id:e,source:r,stage:n}=t;return e&&r.indexOf("SHADER_NAME")===-1?`
#define SHADER_NAME ${e}_${n}

`:""}function mo(t={}){let e="";for(let r in t){let n=t[r];(n||Number.isFinite(n))&&(e+=`#define ${r.toUpperCase()} ${t[r]}
`)}return e}var ne=class{_hookFunctions=[];_defaultModules=[];static getDefaultShaderAssembler(){return ne.defaultShaderAssembler=ne.defaultShaderAssembler||new ne,ne.defaultShaderAssembler}addDefaultModule(e){this._defaultModules.find(r=>r.name===(typeof e=="string"?e:e.name))||this._defaultModules.push(e)}removeDefaultModule(e){let r=typeof e=="string"?e:e.name;this._defaultModules=this._defaultModules.filter(n=>n.name!==r)}addShaderHook(e,r){r&&(e=Object.assign(r,{hook:e})),this._hookFunctions.push(e)}assembleShader(e){let r=this._getModuleList(e.modules),n=this._hookFunctions,o=Je(e);return{...wr({platformInfo:e.platformInfo,...o,modules:r,hookFunctions:n}),modules:r}}assembleShaderPair(e){let r=Je(e),n=this._getModuleList(e.modules),o=this._hookFunctions,{platformInfo:i}=e;return{...e.platformInfo.shaderLanguage==="wgsl"?Lr({platformInfo:i,...r,modules:n,hookFunctions:o}):Pe({platformInfo:i,...r,modules:n,hookFunctions:o}),modules:n}}_getModuleList(e=[]){let r=new Array(this._defaultModules.length+e.length),n={},o=0;for(let i=0,a=this._defaultModules.length;i<a;++i){let f=this._defaultModules[i],u=f.name;r[o++]=f,n[u]=!0}for(let i=0,a=e.length;i<a;++i){let f=e[i],u=f.name;n[u]||(r[o++]=f,n[u]=!0)}return r.length=o,C.instantiateModules(r)}},pe=ne;ir(pe,"defaultShaderAssembler");function Sr(t){if(!t.normalized&&(t.normalized=!0,t.uniformPropTypes&&!t.getUniforms)){let e=new C(t);t.getUniforms=e.getUniforms.bind(e)}return t}var go=`out vec4 transform_output;
void main() {
transform_output = vec4(0);
}`,xo=`#version 300 es
${go}`;function kr(t,e){e=Array.isArray(e)?e:[e];let r=t.replace(/^\s+/,"").split(/\s+/),[n,o,i]=r;if(!e.includes(n)||!o||!i)return null;let a=i.split(";")[0];return{qualifier:n,type:o,name:a}}function Nr(t){let{input:e,inputChannels:r,output:n}=t||{};if(!e)return xo;if(!r)throw new Error("inputChannels");let o=vo(r),i=it(e,r);return`#version 300 es
in ${o} ${e};
out vec4 ${n};
void main() {
  ${n} = ${i};
}`}function Er(t){switch(t){case"float":return"x";case"vec2":return"xy";case"vec3":return"xyz";case"vec4":return"xyzw";default:throw new Error(t)}}function Tr(t){switch(t){case"float":return 1;case"vec2":return 2;case"vec3":return 3;case"vec4":return 4;default:throw new Error(t)}}function vo(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error(`invalid channels: ${t}`)}}function it(t,e){switch(e){case 1:return`vec4(${t}, 0.0, 0.0, 1.0)`;case 2:return`vec4(${t}, 0.0, 1.0)`;case 3:return`vec4(${t}, 1.0)`;case 4:return t;default:throw new Error(`invalid channels: ${e}`)}}function K(t){return typeof t=="string"?t.charAt(0).toUpperCase()+t.slice(1):t}function Mr(t,e){return Ao(t,e)}function Ao(t,e){let r=[];switch(e.uniforms){case"scoped-interface-blocks":case"unscoped-interface-blocks":r.push(`uniform ${K(t.name)} {`);break;case"uniforms":}for(let[n,o]of Object.entries(t.uniformTypes||{})){let i=bo(o);switch(e.uniforms){case"scoped-interface-blocks":r.push(`  ${i} ${n};`);break;case"unscoped-interface-blocks":r.push(`  ${i} ${t.name}_${n};`);break;case"uniforms":r.push(`uniform ${i} ${t.name}_${n};`)}}switch(e.uniforms){case"scoped-interface-blocks":r.push(`} ${t.name};`);break;case"unscoped-interface-blocks":r.push("};");break;case"uniforms":}return r.push(""),r.join(`
`)}function bo(t){return{f32:"float",i32:"int",u32:"uint","vec2<f32>":"vec2","vec3<f32>":"vec3","vec4<f32>":"vec4","vec2<i32>":"ivec2","vec3<i32>":"ivec3","vec4<i32>":"ivec4","vec2<u32>":"uvec2","vec3<u32>":"uvec3","vec4<u32>":"uvec4","mat2x2<f32>":"mat2","mat2x3<f32>":"mat2x3","mat2x4<f32>":"mat2x4","mat3x2<f32>":"mat3x2","mat3x3<f32>":"mat3","mat3x4<f32>":"mat3x4","mat4x2<f32>":"mat4x2","mat4x3<f32>":"mat4x3","mat4x4<f32>":"mat4"}[t]}function Fr(t,e){return yo(t,e)}function yo(t,e){let r=[];r.push(`struct ${K(t.name)} {`);for(let[n,o]of Object.entries(t?.uniformTypes||{})){let i=o;r.push(`  ${n} : ${i};`)}return r.push("};"),r.push(`var<uniform> ${t.name} : ${K(t.name)};`),r.join(`
`)}function Ir(t,e){switch(e.shaderLanguage){case"glsl":return Mr(t,e);case"wgsl":return Fr(t,e)}}var Rr=or($e(),1);var st=class{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}},q=class{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}},T=class extends q{constructor(){super()}},we=class extends T{constructor(e,r,n,o){super(),this.name=e,this.args=r,this.returnType=n,this.body=o}get astNodeType(){return"function"}},at=class extends T{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}},ct=class extends T{constructor(e,r){super(),this.condition=e,this.body=r}get astNodeType(){return"while"}},lt=class extends T{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}},ft=class extends T{constructor(e,r,n,o){super(),this.init=e,this.condition=r,this.increment=n,this.body=o}get astNodeType(){return"for"}},j=class extends T{constructor(e,r,n,o,i){super(),this.name=e,this.type=r,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"var"}},Le=class extends T{constructor(e,r,n){super(),this.name=e,this.type=r,this.value=n}get astNodeType(){return"override"}},Se=class extends T{constructor(e,r,n,o,i){super(),this.name=e,this.type=r,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"let"}},ke=class extends T{constructor(e,r,n,o,i){super(),this.name=e,this.type=r,this.storage=n,this.access=o,this.value=i}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}},ae;(function(t){t.increment="++",t.decrement="--"})(ae||(ae={}));(function(t){function e(r){let n=r;if(n=="parse")throw new Error("Invalid value for IncrementOperator");return t[n]}t.parse=e})(ae||(ae={}));var ut=class extends T{constructor(e,r){super(),this.operator=e,this.variable=r}get astNodeType(){return"increment"}},me;(function(t){t.assign="=",t.addAssign="+=",t.subtractAssin="-=",t.multiplyAssign="*=",t.divideAssign="/=",t.moduloAssign="%=",t.andAssign="&=",t.orAssign="|=",t.xorAssign="^=",t.shiftLeftAssign="<<=",t.shiftRightAssign=">>="})(me||(me={}));(function(t){function e(r){let n=r;if(n=="parse")throw new Error("Invalid value for AssignOperator");return t[n]}t.parse=e})(me||(me={}));var _t=class extends T{constructor(e,r,n){super(),this.operator=e,this.variable=r,this.value=n}get astNodeType(){return"assign"}},ht=class extends T{constructor(e,r){super(),this.name=e,this.args=r}get astNodeType(){return"call"}},pt=class extends T{constructor(e,r){super(),this.body=e,this.continuing=r}get astNodeType(){return"loop"}},dt=class extends T{constructor(e,r){super(),this.condition=e,this.body=r}get astNodeType(){return"body"}},mt=class extends T{constructor(e,r,n,o){super(),this.condition=e,this.body=r,this.elseif=n,this.else=o}get astNodeType(){return"if"}},gt=class extends T{constructor(e){super(),this.value=e}get astNodeType(){return"return"}},xt=class extends T{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}},Ne=class extends T{constructor(e,r){super(),this.name=e,this.type=r}get astNodeType(){return"alias"}},vt=class extends T{constructor(){super()}get astNodeType(){return"discard"}},At=class extends T{constructor(){super()}get astNodeType(){return"break"}},bt=class extends T{constructor(){super()}get astNodeType(){return"continue"}},G=class extends T{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}},V=class extends G{constructor(e,r){super(e),this.members=r}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let r=0;r<this.members.length;r++)if(this.members[r].name==e)return r;return-1}},Ee=class extends G{constructor(e,r,n){super(e),this.format=r,this.access=n}get astNodeType(){return"template"}},yt=class extends G{constructor(e,r,n,o){super(e),this.storage=r,this.type=n,this.access=o}get astNodeType(){return"pointer"}},Te=class extends G{constructor(e,r,n,o){super(e),this.attributes=r,this.format=n,this.count=o}get astNodeType(){return"array"}get isArray(){return!0}},Z=class extends G{constructor(e,r,n){super(e),this.format=r,this.access=n}get astNodeType(){return"sampler"}},X=class extends q{constructor(){super()}},Me=class extends X{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}},J=class extends X{constructor(e,r){super(),this.type=e,this.args=r}get astNodeType(){return"createExpr"}},Pt=class extends X{constructor(e,r){super(),this.name=e,this.args=r}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return this.args[0].evaluate(e)*180/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}},wt=class extends X{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}},Fe=class extends X{constructor(e,r){super(),this.name=e,this.initializer=r}get astNodeType(){return"constExpr"}evaluate(e){var r,n;if(this.initializer instanceof J){let o=(r=this.postfix)===null||r===void 0?void 0:r.evaluateString(e),i=(n=this.initializer.type)===null||n===void 0?void 0:n.name,a=e.structs.get(i),f=a?.getMemberIndex(o);if(f!=-1)return this.initializer.args[f].evaluate(e);console.log(f)}return this.initializer.evaluate(e)}},Ie=class extends X{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}},Lt=class extends X{constructor(e,r){super(),this.type=e,this.value=r}get astNodeType(){return"bitcastExpr"}},St=class extends X{constructor(e,r){super(),this.type=e,this.args=r}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}},Ce=class extends X{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}},Re=class extends X{constructor(){super()}},kt=class extends Re{constructor(e,r){super(),this.operator=e,this.right=r}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}},D=class extends Re{constructor(e,r,n){super(),this.operator=e,this.left=r,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}},Oe=class extends q{constructor(){super()}},Nt=class extends Oe{constructor(e,r){super(),this.selector=e,this.body=r}get astNodeType(){return"case"}},Et=class extends Oe{constructor(e){super(),this.body=e}get astNodeType(){return"default"}},Tt=class extends q{constructor(e,r,n){super(),this.name=e,this.type=r,this.attributes=n}get astNodeType(){return"argument"}},Mt=class extends q{constructor(e,r){super(),this.condition=e,this.body=r}get astNodeType(){return"elseif"}},Ft=class extends q{constructor(e,r,n){super(),this.name=e,this.type=r,this.attributes=n}get astNodeType(){return"member"}},Ue=class extends q{constructor(e,r){super(),this.name=e,this.value=r}get astNodeType(){return"attribute"}},_,l;(function(t){t[t.token=0]="token",t[t.keyword=1]="keyword",t[t.reserved=2]="reserved"})(l||(l={}));var c=class{constructor(e,r,n){this.name=e,this.type=r,this.rule=n}toString(){return this.name}},s=class{};_=s;s.none=new c("",l.reserved,"");s.eof=new c("EOF",l.token,"");s.reserved={asm:new c("asm",l.reserved,"asm"),bf16:new c("bf16",l.reserved,"bf16"),do:new c("do",l.reserved,"do"),enum:new c("enum",l.reserved,"enum"),f16:new c("f16",l.reserved,"f16"),f64:new c("f64",l.reserved,"f64"),handle:new c("handle",l.reserved,"handle"),i8:new c("i8",l.reserved,"i8"),i16:new c("i16",l.reserved,"i16"),i64:new c("i64",l.reserved,"i64"),mat:new c("mat",l.reserved,"mat"),premerge:new c("premerge",l.reserved,"premerge"),regardless:new c("regardless",l.reserved,"regardless"),typedef:new c("typedef",l.reserved,"typedef"),u8:new c("u8",l.reserved,"u8"),u16:new c("u16",l.reserved,"u16"),u64:new c("u64",l.reserved,"u64"),unless:new c("unless",l.reserved,"unless"),using:new c("using",l.reserved,"using"),vec:new c("vec",l.reserved,"vec"),void:new c("void",l.reserved,"void")};s.keywords={array:new c("array",l.keyword,"array"),atomic:new c("atomic",l.keyword,"atomic"),bool:new c("bool",l.keyword,"bool"),f32:new c("f32",l.keyword,"f32"),i32:new c("i32",l.keyword,"i32"),mat2x2:new c("mat2x2",l.keyword,"mat2x2"),mat2x3:new c("mat2x3",l.keyword,"mat2x3"),mat2x4:new c("mat2x4",l.keyword,"mat2x4"),mat3x2:new c("mat3x2",l.keyword,"mat3x2"),mat3x3:new c("mat3x3",l.keyword,"mat3x3"),mat3x4:new c("mat3x4",l.keyword,"mat3x4"),mat4x2:new c("mat4x2",l.keyword,"mat4x2"),mat4x3:new c("mat4x3",l.keyword,"mat4x3"),mat4x4:new c("mat4x4",l.keyword,"mat4x4"),ptr:new c("ptr",l.keyword,"ptr"),sampler:new c("sampler",l.keyword,"sampler"),sampler_comparison:new c("sampler_comparison",l.keyword,"sampler_comparison"),struct:new c("struct",l.keyword,"struct"),texture_1d:new c("texture_1d",l.keyword,"texture_1d"),texture_2d:new c("texture_2d",l.keyword,"texture_2d"),texture_2d_array:new c("texture_2d_array",l.keyword,"texture_2d_array"),texture_3d:new c("texture_3d",l.keyword,"texture_3d"),texture_cube:new c("texture_cube",l.keyword,"texture_cube"),texture_cube_array:new c("texture_cube_array",l.keyword,"texture_cube_array"),texture_multisampled_2d:new c("texture_multisampled_2d",l.keyword,"texture_multisampled_2d"),texture_storage_1d:new c("texture_storage_1d",l.keyword,"texture_storage_1d"),texture_storage_2d:new c("texture_storage_2d",l.keyword,"texture_storage_2d"),texture_storage_2d_array:new c("texture_storage_2d_array",l.keyword,"texture_storage_2d_array"),texture_storage_3d:new c("texture_storage_3d",l.keyword,"texture_storage_3d"),texture_depth_2d:new c("texture_depth_2d",l.keyword,"texture_depth_2d"),texture_depth_2d_array:new c("texture_depth_2d_array",l.keyword,"texture_depth_2d_array"),texture_depth_cube:new c("texture_depth_cube",l.keyword,"texture_depth_cube"),texture_depth_cube_array:new c("texture_depth_cube_array",l.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new c("texture_depth_multisampled_2d",l.keyword,"texture_depth_multisampled_2d"),texture_external:new c("texture_external",l.keyword,"texture_external"),u32:new c("u32",l.keyword,"u32"),vec2:new c("vec2",l.keyword,"vec2"),vec3:new c("vec3",l.keyword,"vec3"),vec4:new c("vec4",l.keyword,"vec4"),bitcast:new c("bitcast",l.keyword,"bitcast"),block:new c("block",l.keyword,"block"),break:new c("break",l.keyword,"break"),case:new c("case",l.keyword,"case"),continue:new c("continue",l.keyword,"continue"),continuing:new c("continuing",l.keyword,"continuing"),default:new c("default",l.keyword,"default"),discard:new c("discard",l.keyword,"discard"),else:new c("else",l.keyword,"else"),enable:new c("enable",l.keyword,"enable"),fallthrough:new c("fallthrough",l.keyword,"fallthrough"),false:new c("false",l.keyword,"false"),fn:new c("fn",l.keyword,"fn"),for:new c("for",l.keyword,"for"),function:new c("function",l.keyword,"function"),if:new c("if",l.keyword,"if"),let:new c("let",l.keyword,"let"),const:new c("const",l.keyword,"const"),loop:new c("loop",l.keyword,"loop"),while:new c("while",l.keyword,"while"),private:new c("private",l.keyword,"private"),read:new c("read",l.keyword,"read"),read_write:new c("read_write",l.keyword,"read_write"),return:new c("return",l.keyword,"return"),storage:new c("storage",l.keyword,"storage"),switch:new c("switch",l.keyword,"switch"),true:new c("true",l.keyword,"true"),alias:new c("alias",l.keyword,"alias"),type:new c("type",l.keyword,"type"),uniform:new c("uniform",l.keyword,"uniform"),var:new c("var",l.keyword,"var"),override:new c("override",l.keyword,"override"),workgroup:new c("workgroup",l.keyword,"workgroup"),write:new c("write",l.keyword,"write"),r8unorm:new c("r8unorm",l.keyword,"r8unorm"),r8snorm:new c("r8snorm",l.keyword,"r8snorm"),r8uint:new c("r8uint",l.keyword,"r8uint"),r8sint:new c("r8sint",l.keyword,"r8sint"),r16uint:new c("r16uint",l.keyword,"r16uint"),r16sint:new c("r16sint",l.keyword,"r16sint"),r16float:new c("r16float",l.keyword,"r16float"),rg8unorm:new c("rg8unorm",l.keyword,"rg8unorm"),rg8snorm:new c("rg8snorm",l.keyword,"rg8snorm"),rg8uint:new c("rg8uint",l.keyword,"rg8uint"),rg8sint:new c("rg8sint",l.keyword,"rg8sint"),r32uint:new c("r32uint",l.keyword,"r32uint"),r32sint:new c("r32sint",l.keyword,"r32sint"),r32float:new c("r32float",l.keyword,"r32float"),rg16uint:new c("rg16uint",l.keyword,"rg16uint"),rg16sint:new c("rg16sint",l.keyword,"rg16sint"),rg16float:new c("rg16float",l.keyword,"rg16float"),rgba8unorm:new c("rgba8unorm",l.keyword,"rgba8unorm"),rgba8unorm_srgb:new c("rgba8unorm_srgb",l.keyword,"rgba8unorm_srgb"),rgba8snorm:new c("rgba8snorm",l.keyword,"rgba8snorm"),rgba8uint:new c("rgba8uint",l.keyword,"rgba8uint"),rgba8sint:new c("rgba8sint",l.keyword,"rgba8sint"),bgra8unorm:new c("bgra8unorm",l.keyword,"bgra8unorm"),bgra8unorm_srgb:new c("bgra8unorm_srgb",l.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new c("rgb10a2unorm",l.keyword,"rgb10a2unorm"),rg11b10float:new c("rg11b10float",l.keyword,"rg11b10float"),rg32uint:new c("rg32uint",l.keyword,"rg32uint"),rg32sint:new c("rg32sint",l.keyword,"rg32sint"),rg32float:new c("rg32float",l.keyword,"rg32float"),rgba16uint:new c("rgba16uint",l.keyword,"rgba16uint"),rgba16sint:new c("rgba16sint",l.keyword,"rgba16sint"),rgba16float:new c("rgba16float",l.keyword,"rgba16float"),rgba32uint:new c("rgba32uint",l.keyword,"rgba32uint"),rgba32sint:new c("rgba32sint",l.keyword,"rgba32sint"),rgba32float:new c("rgba32float",l.keyword,"rgba32float"),static_assert:new c("static_assert",l.keyword,"static_assert")};s.tokens={decimal_float_literal:new c("decimal_float_literal",l.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new c("hex_float_literal",l.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new c("int_literal",l.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new c("uint_literal",l.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new c("ident",l.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new c("and",l.token,"&"),and_and:new c("and_and",l.token,"&&"),arrow:new c("arrow ",l.token,"->"),attr:new c("attr",l.token,"@"),attr_left:new c("attr_left",l.token,"[["),attr_right:new c("attr_right",l.token,"]]"),forward_slash:new c("forward_slash",l.token,"/"),bang:new c("bang",l.token,"!"),bracket_left:new c("bracket_left",l.token,"["),bracket_right:new c("bracket_right",l.token,"]"),brace_left:new c("brace_left",l.token,"{"),brace_right:new c("brace_right",l.token,"}"),colon:new c("colon",l.token,":"),comma:new c("comma",l.token,","),equal:new c("equal",l.token,"="),equal_equal:new c("equal_equal",l.token,"=="),not_equal:new c("not_equal",l.token,"!="),greater_than:new c("greater_than",l.token,">"),greater_than_equal:new c("greater_than_equal",l.token,">="),shift_right:new c("shift_right",l.token,">>"),less_than:new c("less_than",l.token,"<"),less_than_equal:new c("less_than_equal",l.token,"<="),shift_left:new c("shift_left",l.token,"<<"),modulo:new c("modulo",l.token,"%"),minus:new c("minus",l.token,"-"),minus_minus:new c("minus_minus",l.token,"--"),period:new c("period",l.token,"."),plus:new c("plus",l.token,"+"),plus_plus:new c("plus_plus",l.token,"++"),or:new c("or",l.token,"|"),or_or:new c("or_or",l.token,"||"),paren_left:new c("paren_left",l.token,"("),paren_right:new c("paren_right",l.token,")"),semicolon:new c("semicolon",l.token,";"),star:new c("star",l.token,"*"),tilde:new c("tilde",l.token,"~"),underscore:new c("underscore",l.token,"_"),xor:new c("xor",l.token,"^"),plus_equal:new c("plus_equal",l.token,"+="),minus_equal:new c("minus_equal",l.token,"-="),times_equal:new c("times_equal",l.token,"*="),division_equal:new c("division_equal",l.token,"/="),modulo_equal:new c("modulo_equal",l.token,"%="),and_equal:new c("and_equal",l.token,"&="),or_equal:new c("or_equal",l.token,"|="),xor_equal:new c("xor_equal",l.token,"^="),shift_right_equal:new c("shift_right_equal",l.token,">>="),shift_left_equal:new c("shift_left_equal",l.token,"<<=")};s.storage_class=[_.keywords.function,_.keywords.private,_.keywords.workgroup,_.keywords.uniform,_.keywords.storage];s.access_mode=[_.keywords.read,_.keywords.write,_.keywords.read_write];s.sampler_type=[_.keywords.sampler,_.keywords.sampler_comparison];s.sampled_texture_type=[_.keywords.texture_1d,_.keywords.texture_2d,_.keywords.texture_2d_array,_.keywords.texture_3d,_.keywords.texture_cube,_.keywords.texture_cube_array];s.multisampled_texture_type=[_.keywords.texture_multisampled_2d];s.storage_texture_type=[_.keywords.texture_storage_1d,_.keywords.texture_storage_2d,_.keywords.texture_storage_2d_array,_.keywords.texture_storage_3d];s.depth_texture_type=[_.keywords.texture_depth_2d,_.keywords.texture_depth_2d_array,_.keywords.texture_depth_cube,_.keywords.texture_depth_cube_array,_.keywords.texture_depth_multisampled_2d];s.texture_external_type=[_.keywords.texture_external];s.any_texture_type=[..._.sampled_texture_type,..._.multisampled_texture_type,..._.storage_texture_type,..._.depth_texture_type,..._.texture_external_type];s.texel_format=[_.keywords.r8unorm,_.keywords.r8snorm,_.keywords.r8uint,_.keywords.r8sint,_.keywords.r16uint,_.keywords.r16sint,_.keywords.r16float,_.keywords.rg8unorm,_.keywords.rg8snorm,_.keywords.rg8uint,_.keywords.rg8sint,_.keywords.r32uint,_.keywords.r32sint,_.keywords.r32float,_.keywords.rg16uint,_.keywords.rg16sint,_.keywords.rg16float,_.keywords.rgba8unorm,_.keywords.rgba8unorm_srgb,_.keywords.rgba8snorm,_.keywords.rgba8uint,_.keywords.rgba8sint,_.keywords.bgra8unorm,_.keywords.bgra8unorm_srgb,_.keywords.rgb10a2unorm,_.keywords.rg11b10float,_.keywords.rg32uint,_.keywords.rg32sint,_.keywords.rg32float,_.keywords.rgba16uint,_.keywords.rgba16sint,_.keywords.rgba16float,_.keywords.rgba32uint,_.keywords.rgba32sint,_.keywords.rgba32float];s.const_literal=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal,_.keywords.true,_.keywords.false];s.literal_or_ident=[_.tokens.ident,_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal];s.element_count_expression=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.ident];s.template_types=[_.keywords.vec2,_.keywords.vec3,_.keywords.vec4,_.keywords.mat2x2,_.keywords.mat2x3,_.keywords.mat2x4,_.keywords.mat3x2,_.keywords.mat3x3,_.keywords.mat3x4,_.keywords.mat4x2,_.keywords.mat4x3,_.keywords.mat4x4,_.keywords.atomic,_.keywords.bitcast,..._.any_texture_type];s.attribute_name=[_.tokens.ident,_.keywords.block];s.assignment_operators=[_.tokens.equal,_.tokens.plus_equal,_.tokens.minus_equal,_.tokens.times_equal,_.tokens.division_equal,_.tokens.modulo_equal,_.tokens.and_equal,_.tokens.or_equal,_.tokens.xor_equal,_.tokens.shift_right_equal,_.tokens.shift_left_equal];s.increment_operators=[_.tokens.plus_plus,_.tokens.minus_minus];var ze=class{constructor(e,r,n){this.type=e,this.lexeme=r,this.line=n}toString(){return this.lexeme}isTemplateType(){return s.template_types.indexOf(this.type)!=-1}isArrayType(){return this.type==s.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}},It=class{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=e??""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new ze(s.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if(e==`
`)return this._line++,!0;if(this._isWhitespace(e))return!0;if(e=="/"){if(this._peekAhead()=="/"){for(;e!=`
`;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}else if(this._peekAhead()=="*"){this._advance();let n=1;for(;n>0;){if(this._isAtEnd())return!0;if(e=this._advance(),e==`
`)this._line++;else if(e=="*"){if(this._peekAhead()=="/"&&(this._advance(),n--,n==0))return!0}else e=="/"&&this._peekAhead()=="*"&&(this._advance(),n++)}return!0}}let r=s.none;for(;;){let n=this._findType(e),o=this._peekAhead();if(e==">"&&(o==">"||o=="=")){let i=!1,a=this._tokens.length-1;for(let f=0;f<5&&a>=0;++f,--a)if(this._tokens[a].type===s.tokens.less_than){a>0&&this._tokens[a-1].isArrayOrTemplateType()&&(i=!0);break}if(i)return this._addToken(n),!0}if(n===s.none){let i=e,a=0,f=2;for(let u=0;u<f;++u)if(i+=this._peekAhead(u),n=this._findType(i),n!==s.none){a=u;break}if(n===s.none)return r===s.none?!1:(this._current--,this._addToken(r),!0);e=i,this._current+=a+1}if(r=n,this._isAtEnd())break;e+=this._advance()}return r===s.none?!1:(this._addToken(r),!0)}_findType(e){for(let r in s.keywords){let n=s.keywords[r];if(this._match(e,n.rule))return n}for(let r in s.tokens){let n=s.tokens[r];if(this._match(e,n.rule))return n}return s.none}_match(e,r){if(typeof r=="string"){if(r==e)return!0}else{let n=r.exec(e);if(n&&n.index==0&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return e==" "||e=="	"||e=="\r"}_advance(e=0){let r=this._source[this._current];return e=e||0,e++,this._current+=e,r}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){let r=this._source.substring(this._start,this._current);this._tokens.push(new ze(e,r,this._line))}},Ct=class{constructor(){this._tokens=[],this._current=0,this._context=new st}parse(e){this._initialize(e);let r=[];for(;!this._isAtEnd();){let n=this._global_decl_or_directive();if(!n)break;r.push(n)}return r}_initialize(e){if(e)if(typeof e=="string"){let r=new It(e);this._tokens=r.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,r){return console.error(e,r),{token:e,message:r,toString:function(){return`${r}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==s.eof}_match(e){if(e instanceof c)return this._check(e)?(this._advance(),!0):!1;for(let r=0,n=e.length;r<n;++r){let o=e[r];if(this._check(o))return this._advance(),!0}return!1}_consume(e,r){if(this._check(e))return this._advance();throw this._error(this._peek(),r)}_check(e){if(this._isAtEnd())return!1;let r=this._peek();if(e instanceof Array){let n=r.type;return e.indexOf(n)!=-1}return r.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(s.tokens.semicolon)&&!this._isAtEnd(););if(this._match(s.keywords.alias)){let r=this._type_alias();return this._consume(s.tokens.semicolon,"Expected ';'"),r}if(this._match(s.keywords.enable)){let r=this._enable_directive();return this._consume(s.tokens.semicolon,"Expected ';'"),r}let e=this._attribute();if(this._check(s.keywords.var)){let r=this._global_variable_decl();return r!=null&&(r.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),r}if(this._check(s.keywords.override)){let r=this._override_variable_decl();return r!=null&&(r.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),r}if(this._check(s.keywords.let)){let r=this._global_let_decl();return r!=null&&(r.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),r}if(this._check(s.keywords.const)){let r=this._global_const_decl();return r!=null&&(r.attributes=e),this._consume(s.tokens.semicolon,"Expected ';'."),r}if(this._check(s.keywords.struct)){let r=this._struct_decl();return r!=null&&(r.attributes=e),r}if(this._check(s.keywords.fn)){let r=this._function_decl();return r!=null&&(r.attributes=e),r}return null}_function_decl(){if(!this._match(s.keywords.fn))return null;let e=this._consume(s.tokens.ident,"Expected function name.").toString();this._consume(s.tokens.paren_left,"Expected '(' for function arguments.");let r=[];if(!this._check(s.tokens.paren_right))do{if(this._check(s.tokens.paren_right))break;let i=this._attribute(),a=this._consume(s.tokens.ident,"Expected argument name.").toString();this._consume(s.tokens.colon,"Expected ':' for argument type.");let f=this._attribute(),u=this._type_decl();u!=null&&(u.attributes=f,r.push(new Tt(a,u,i)))}while(this._match(s.tokens.comma));this._consume(s.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(s.tokens.arrow)){let i=this._attribute();n=this._type_decl(),n!=null&&(n.attributes=i)}let o=this._compound_statement();return new we(e,r,n,o)}_compound_statement(){let e=[];for(this._consume(s.tokens.brace_left,"Expected '{' for block.");!this._check(s.tokens.brace_right);){let r=this._statement();r!==null&&e.push(r)}return this._consume(s.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(s.tokens.semicolon)&&!this._isAtEnd(););if(this._check(s.keywords.if))return this._if_statement();if(this._check(s.keywords.switch))return this._switch_statement();if(this._check(s.keywords.loop))return this._loop_statement();if(this._check(s.keywords.for))return this._for_statement();if(this._check(s.keywords.while))return this._while_statement();if(this._check(s.keywords.continuing))return this._continuing_statement();if(this._check(s.keywords.static_assert))return this._static_assert_statement();if(this._check(s.tokens.brace_left))return this._compound_statement();let e=null;return this._check(s.keywords.return)?e=this._return_statement():this._check([s.keywords.var,s.keywords.let,s.keywords.const])?e=this._variable_statement():this._match(s.keywords.discard)?e=new vt:this._match(s.keywords.break)?e=new At:this._match(s.keywords.continue)?e=new bt:e=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),e!=null&&this._consume(s.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(s.keywords.static_assert))return null;let e=this._optional_paren_expression();return new at(e)}_while_statement(){if(!this._match(s.keywords.while))return null;let e=this._optional_paren_expression(),r=this._compound_statement();return new ct(e,r)}_continuing_statement(){if(!this._match(s.keywords.continuing))return null;let e=this._compound_statement();return new lt(e)}_for_statement(){if(!this._match(s.keywords.for))return null;this._consume(s.tokens.paren_left,"Expected '('.");let e=this._check(s.tokens.semicolon)?null:this._for_init();this._consume(s.tokens.semicolon,"Expected ';'.");let r=this._check(s.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(s.tokens.semicolon,"Expected ';'.");let n=this._check(s.tokens.paren_right)?null:this._for_increment();this._consume(s.tokens.paren_right,"Expected ')'.");let o=this._compound_statement();return new ft(e,r,n,o)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(s.keywords.var)){let e=this._variable_decl();if(e===null)throw this._error(this._peek(),"Variable declaration expected.");let r=null;return this._match(s.tokens.equal)&&(r=this._short_circuit_or_expression()),new j(e.name,e.type,e.storage,e.access,r)}if(this._match(s.keywords.let)){let e=this._consume(s.tokens.ident,"Expected name for let.").toString(),r=null;if(this._match(s.tokens.colon)){let o=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=o)}this._consume(s.tokens.equal,"Expected '=' for let.");let n=this._short_circuit_or_expression();return new Se(e,r,null,null,n)}if(this._match(s.keywords.const)){let e=this._consume(s.tokens.ident,"Expected name for const.").toString(),r=null;if(this._match(s.tokens.colon)){let o=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=o)}this._consume(s.tokens.equal,"Expected '=' for const.");let n=this._short_circuit_or_expression();return new ke(e,r,null,null,n)}return null}_increment_decrement_statement(){let e=this._current,r=this._unary_expression();if(r==null)return null;if(!this._check(s.increment_operators))return this._current=e,null;let n=this._consume(s.increment_operators,"Expected increment operator");return new ut(n.type===s.tokens.plus_plus?ae.increment:ae.decrement,r)}_assignment_statement(){let e=null;if(this._check(s.tokens.brace_right))return null;let r=this._match(s.tokens.underscore);if(r||(e=this._unary_expression()),!r&&e==null)return null;let n=this._consume(s.assignment_operators,"Expected assignment operator."),o=this._short_circuit_or_expression();return new _t(me.parse(n.lexeme),e,o)}_func_call_statement(){if(!this._check(s.tokens.ident))return null;let e=this._current,r=this._consume(s.tokens.ident,"Expected function name."),n=this._argument_expression_list();return n===null?(this._current=e,null):new ht(r.lexeme,n)}_loop_statement(){if(!this._match(s.keywords.loop))return null;this._consume(s.tokens.brace_left,"Expected '{' for loop.");let e=[],r=this._statement();for(;r!==null;){if(Array.isArray(r))for(let o of r)e.push(o);else e.push(r);r=this._statement()}let n=null;return this._match(s.keywords.continuing)&&(n=this._compound_statement()),this._consume(s.tokens.brace_right,"Expected '}' for loop."),new pt(e,n)}_switch_statement(){if(!this._match(s.keywords.switch))return null;let e=this._optional_paren_expression();this._consume(s.tokens.brace_left,"Expected '{' for switch.");let r=this._switch_body();if(r==null||r.length==0)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(s.tokens.brace_right,"Expected '}' for switch."),new dt(e,r)}_switch_body(){let e=[];if(this._match(s.keywords.case)){let r=this._case_selectors();this._match(s.tokens.colon),this._consume(s.tokens.brace_left,"Exected '{' for switch case.");let n=this._case_body();this._consume(s.tokens.brace_right,"Exected '}' for switch case."),e.push(new Nt(r,n))}if(this._match(s.keywords.default)){this._match(s.tokens.colon),this._consume(s.tokens.brace_left,"Exected '{' for switch default.");let r=this._case_body();this._consume(s.tokens.brace_right,"Exected '}' for switch default."),e.push(new Et(r))}if(this._check([s.keywords.default,s.keywords.case])){let r=this._switch_body();e.push(r[0])}return e}_case_selectors(){var e,r,n,o;let i=[(r=(e=this._shift_expression())===null||e===void 0?void 0:e.evaluate(this._context).toString())!==null&&r!==void 0?r:""];for(;this._match(s.tokens.comma);)i.push((o=(n=this._shift_expression())===null||n===void 0?void 0:n.evaluate(this._context).toString())!==null&&o!==void 0?o:"");return i}_case_body(){if(this._match(s.keywords.fallthrough))return this._consume(s.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(e==null)return[];e instanceof Array||(e=[e]);let r=this._case_body();return r.length==0?e:[...e,r[0]]}_if_statement(){if(!this._match(s.keywords.if))return null;let e=this._optional_paren_expression(),r=this._compound_statement(),n=[];this._match_elseif()&&(n=this._elseif_statement(n));let o=null;return this._match(s.keywords.else)&&(o=this._compound_statement()),new mt(e,r,n,o)}_match_elseif(){return this._tokens[this._current].type===s.keywords.else&&this._tokens[this._current+1].type===s.keywords.if?(this._advance(),this._advance(),!0):!1}_elseif_statement(e=[]){let r=this._optional_paren_expression(),n=this._compound_statement();return e.push(new Mt(r,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(s.keywords.return))return null;let e=this._short_circuit_or_expression();return new gt(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(s.tokens.or_or);)e=new D(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(s.tokens.and_and);)e=new D(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(s.tokens.or);)e=new D(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(s.tokens.xor);)e=new D(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(s.tokens.and);)e=new D(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){let e=this._relational_expression();return this._match([s.tokens.equal_equal,s.tokens.not_equal])?new D(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([s.tokens.less_than,s.tokens.greater_than,s.tokens.less_than_equal,s.tokens.greater_than_equal]);)e=new D(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([s.tokens.shift_left,s.tokens.shift_right]);)e=new D(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([s.tokens.plus,s.tokens.minus]);)e=new D(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([s.tokens.star,s.tokens.forward_slash,s.tokens.modulo]);)e=new D(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([s.tokens.minus,s.tokens.bang,s.tokens.tilde,s.tokens.star,s.tokens.and])?new kt(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){let e=this._primary_expression(),r=this._postfix_expression();return r&&(e.postfix=r),e}_postfix_expression(){if(this._match(s.tokens.bracket_left)){let e=this._short_circuit_or_expression();this._consume(s.tokens.bracket_right,"Expected ']'.");let r=this._postfix_expression();return r&&(e.postfix=r),e}if(this._match(s.tokens.period)){let e=this._consume(s.tokens.ident,"Expected member name."),r=this._postfix_expression(),n=new Me(e.lexeme);return r&&(n.postfix=r),n}return null}_getStruct(e){return this._context.aliases.has(e)?this._context.aliases.get(e).type:this._context.structs.has(e)?this._context.structs.get(e):null}_primary_expression(){if(this._match(s.tokens.ident)){let n=this._previous().toString();if(this._check(s.tokens.paren_left)){let o=this._argument_expression_list(),i=this._getStruct(n);return i!=null?new J(i,o):new Pt(n,o)}if(this._context.constants.has(n)){let o=this._context.constants.get(n);return new Fe(n,o.value)}return new wt(n)}if(this._match(s.const_literal))return new Ie(parseFloat(this._previous().toString()));if(this._check(s.tokens.paren_left))return this._paren_expression();if(this._match(s.keywords.bitcast)){this._consume(s.tokens.less_than,"Expected '<'.");let n=this._type_decl();this._consume(s.tokens.greater_than,"Expected '>'.");let o=this._paren_expression();return new Lt(n,o)}let e=this._type_decl(),r=this._argument_expression_list();return new St(e,r)}_argument_expression_list(){if(!this._match(s.tokens.paren_left))return null;let e=[];do{if(this._check(s.tokens.paren_right))break;let r=this._short_circuit_or_expression();e.push(r)}while(this._match(s.tokens.comma));return this._consume(s.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(s.tokens.paren_left);let e=this._short_circuit_or_expression();return this._match(s.tokens.paren_right),new Ce([e])}_paren_expression(){this._consume(s.tokens.paren_left,"Expected '('.");let e=this._short_circuit_or_expression();return this._consume(s.tokens.paren_right,"Expected ')'."),new Ce([e])}_struct_decl(){if(!this._match(s.keywords.struct))return null;let e=this._consume(s.tokens.ident,"Expected name for struct.").toString();this._consume(s.tokens.brace_left,"Expected '{' for struct body.");let r=[];for(;!this._check(s.tokens.brace_right);){let o=this._attribute(),i=this._consume(s.tokens.ident,"Expected variable name.").toString();this._consume(s.tokens.colon,"Expected ':' for struct member type.");let a=this._attribute(),f=this._type_decl();f!=null&&(f.attributes=a),this._check(s.tokens.brace_right)?this._match(s.tokens.comma):this._consume(s.tokens.comma,"Expected ',' for struct member."),r.push(new Ft(i,f,o))}this._consume(s.tokens.brace_right,"Expected '}' after struct body.");let n=new V(e,r);return this._context.structs.set(e,n),n}_global_variable_decl(){let e=this._variable_decl();return e&&this._match(s.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){let e=this._override_decl();return e&&this._match(s.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(s.keywords.const))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),r=null;if(this._match(s.tokens.colon)){let i=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=i)}let n=null;if(this._match(s.tokens.equal)){let i=this._short_circuit_or_expression();if(i instanceof J)n=i;else if(i instanceof Fe&&i.initializer instanceof J)n=i.initializer;else try{let a=i.evaluate(this._context);n=new Ie(a)}catch{n=i}}let o=new ke(e.toString(),r,"","",n);return this._context.constants.set(o.name,o),o}_global_let_decl(){if(!this._match(s.keywords.let))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),r=null;if(this._match(s.tokens.colon)){let o=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=o)}let n=null;return this._match(s.tokens.equal)&&(n=this._const_expression()),new Se(e.toString(),r,"","",n)}_const_expression(){if(this._match(s.const_literal))return new Me(this._previous().toString());let e=this._type_decl();this._consume(s.tokens.paren_left,"Expected '('.");let r=[];for(;!this._check(s.tokens.paren_right)&&(r.push(this._const_expression()),!!this._check(s.tokens.comma));)this._advance();return this._consume(s.tokens.paren_right,"Expected ')'."),new J(e,r)}_variable_decl(){if(!this._match(s.keywords.var))return null;let e="",r="";this._match(s.tokens.less_than)&&(e=this._consume(s.storage_class,"Expected storage_class.").toString(),this._match(s.tokens.comma)&&(r=this._consume(s.access_mode,"Expected access_mode.").toString()),this._consume(s.tokens.greater_than,"Expected '>'."));let n=this._consume(s.tokens.ident,"Expected variable name"),o=null;if(this._match(s.tokens.colon)){let i=this._attribute();o=this._type_decl(),o!=null&&(o.attributes=i)}return new j(n.toString(),o,e,r,null)}_override_decl(){if(!this._match(s.keywords.override))return null;let e=this._consume(s.tokens.ident,"Expected variable name"),r=null;if(this._match(s.tokens.colon)){let n=this._attribute();r=this._type_decl(),r!=null&&(r.attributes=n)}return new Le(e.toString(),r,null)}_enable_directive(){let e=this._consume(s.tokens.ident,"identity expected.");return new xt(e.toString())}_type_alias(){let e=this._consume(s.tokens.ident,"identity expected.");this._consume(s.tokens.equal,"Expected '=' for type alias.");let r=this._type_decl();if(r===null)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(r.name)&&(r=this._context.aliases.get(r.name).type);let n=new Ne(e.toString(),r);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([s.tokens.ident,...s.texel_format,s.keywords.bool,s.keywords.f32,s.keywords.i32,s.keywords.u32])){let n=this._advance(),o=n.toString();return this._context.structs.has(o)?this._context.structs.get(o):this._context.aliases.has(o)?this._context.aliases.get(o).type:new G(n.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(s.template_types)){let n=this._advance().toString(),o=null,i=null;return this._match(s.tokens.less_than)&&(o=this._type_decl(),i=null,this._match(s.tokens.comma)&&(i=this._consume(s.access_mode,"Expected access_mode for pointer").toString()),this._consume(s.tokens.greater_than,"Expected '>' for type.")),new Ee(n,o,i)}if(this._match(s.keywords.ptr)){let n=this._previous().toString();this._consume(s.tokens.less_than,"Expected '<' for pointer.");let o=this._consume(s.storage_class,"Expected storage_class for pointer");this._consume(s.tokens.comma,"Expected ',' for pointer.");let i=this._type_decl(),a=null;return this._match(s.tokens.comma)&&(a=this._consume(s.access_mode,"Expected access_mode for pointer").toString()),this._consume(s.tokens.greater_than,"Expected '>' for pointer."),new yt(n,o.toString(),i,a)}let r=this._attribute();if(this._match(s.keywords.array)){let n=null,o=-1,i=this._previous();if(this._match(s.tokens.less_than)){n=this._type_decl(),this._context.aliases.has(n.name)&&(n=this._context.aliases.get(n.name).type);let a="";this._match(s.tokens.comma)&&(a=this._shift_expression().evaluate(this._context).toString()),this._consume(s.tokens.greater_than,"Expected '>' for array."),o=a?parseInt(a):0}return new Te(i.toString(),r,n,o)}return null}_texture_sampler_types(){if(this._match(s.sampler_type))return new Z(this._previous().toString(),null,null);if(this._match(s.depth_texture_type))return new Z(this._previous().toString(),null,null);if(this._match(s.sampled_texture_type)||this._match(s.multisampled_texture_type)){let e=this._previous();this._consume(s.tokens.less_than,"Expected '<' for sampler type.");let r=this._type_decl();return this._consume(s.tokens.greater_than,"Expected '>' for sampler type."),new Z(e.toString(),r,null)}if(this._match(s.storage_texture_type)){let e=this._previous();this._consume(s.tokens.less_than,"Expected '<' for sampler type.");let r=this._consume(s.texel_format,"Invalid texel format.").toString();this._consume(s.tokens.comma,"Expected ',' after texel format.");let n=this._consume(s.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(s.tokens.greater_than,"Expected '>' for sampler type."),new Z(e.toString(),r,n)}return null}_attribute(){let e=[];for(;this._match(s.tokens.attr);){let r=this._consume(s.attribute_name,"Expected attribute name"),n=new Ue(r.toString(),null);if(this._match(s.tokens.paren_left)){if(n.value=this._consume(s.literal_or_ident,"Expected attribute value").toString(),this._check(s.tokens.comma)){this._advance();do{let o=this._consume(s.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(o)}while(this._match(s.tokens.comma))}this._consume(s.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(s.tokens.attr_left);){if(!this._check(s.tokens.attr_right))do{let r=this._consume(s.attribute_name,"Expected attribute name"),n=new Ue(r.toString(),null);if(this._match(s.tokens.paren_left)){if(n.value=[this._consume(s.literal_or_ident,"Expected attribute value").toString()],this._check(s.tokens.comma)){this._advance();do{let o=this._consume(s.literal_or_ident,"Expected attribute value").toString();n.value.push(o)}while(this._match(s.tokens.comma))}this._consume(s.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(s.tokens.comma));this._consume(s.tokens.attr_right,"Expected ']]' after attribute declarations")}return e.length==0?null:e}},$=class{constructor(e,r){this.name=e,this.attributes=r,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}},De=class{constructor(e,r,n){this.name=e,this.type=r,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray?this.type.format:this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}},oe=class extends ${constructor(e,r){super(e,r),this.members=[],this.align=0}get isStruct(){return!0}},de=class extends ${constructor(e,r){super(e,r),this.count=0,this.stride=0}get isArray(){return!0}},Ye=class extends ${constructor(e,r,n,o){super(e,n),this.format=r,this.access=o}get isTemplate(){return!0}},W;(function(t){t[t.Uniform=0]="Uniform",t[t.Storage=1]="Storage",t[t.Texture=2]="Texture",t[t.Sampler=3]="Sampler",t[t.StorageTexture=4]="StorageTexture"})(W||(W={}));var ie=class{constructor(e,r,n,o,i,a,f){this.name=e,this.type=r,this.group=n,this.binding=o,this.attributes=i,this.resourceType=a,this.access=f}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray?this.type.format:this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}},Rt=class{constructor(e,r){this.name=e,this.type=r}},se=class{constructor(e,r){this.align=e,this.size=r}},Ot=class{constructor(e,r,n,o){this.name=e,this.type=r,this.locationType=n,this.location=o,this.interpolation=null}},Xe=class{constructor(e,r,n,o){this.name=e,this.type=r,this.locationType=n,this.location=o}},Ut=class{constructor(e,r=null){this.stage=null,this.inputs=[],this.outputs=[],this.name=e,this.stage=r}},zt=class{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}},Dt=class{constructor(e,r,n,o){this.name=e,this.type=r,this.attributes=n,this.id=o}},Y=class{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new zt,this._types=new Map,e&&this.update(e)}_isStorageTexture(e){return e.name=="texture_storage_1d"||e.name=="texture_storage_2d"||e.name=="texture_storage_2d_array"||e.name=="texture_storage_3d"}update(e){let n=new Ct().parse(e);for(let o of n){if(o instanceof V){let i=this._getTypeInfo(o,null);i instanceof oe&&this.structs.push(i);continue}if(o instanceof Ne){this.aliases.push(this._getAliasInfo(o));continue}if(o instanceof Le){let i=o,a=this._getAttributeNum(i.attributes,"id",0),f=i.type!=null?this._getTypeInfo(i.type,i.attributes):null;this.overrides.push(new Dt(i.name,f,i.attributes,a));continue}if(this._isUniformVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),f=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=new ie(i.name,u,a,f,i.attributes,W.Uniform,i.access);this.uniforms.push(h);continue}if(this._isStorageVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),f=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=this._isStorageTexture(u),p=new ie(i.name,u,a,f,i.attributes,h?W.StorageTexture:W.Storage,i.access);this.storage.push(p);continue}if(this._isTextureVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),f=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=this._isStorageTexture(u),p=new ie(i.name,u,a,f,i.attributes,h?W.StorageTexture:W.Texture,i.access);h?this.storage.push(p):this.textures.push(p);continue}if(this._isSamplerVar(o)){let i=o,a=this._getAttributeNum(i.attributes,"group",0),f=this._getAttributeNum(i.attributes,"binding",0),u=this._getTypeInfo(i.type,i.attributes),h=new ie(i.name,u,a,f,i.attributes,W.Sampler,i.access);this.samplers.push(h);continue}if(o instanceof we){let i=this._getAttribute(o,"vertex"),a=this._getAttribute(o,"fragment"),f=this._getAttribute(o,"compute"),u=i||a||f;if(u){let h=new Ut(o.name,u.name);h.inputs=this._getInputs(o.args),h.outputs=this._getOutputs(o.returnType),this.entry[u.name].push(h)}continue}}}getBindGroups(){let e=[];function r(n,o){n>=e.length&&(e.length=n+1),e[n]===void 0&&(e[n]=[]),o>=e[n].length&&(e[n].length=o+1)}for(let n of this.uniforms){r(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.storage){r(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.textures){r(n.group,n.binding);let o=e[n.group];o[n.binding]=n}for(let n of this.samplers){r(n.group,n.binding);let o=e[n.group];o[n.binding]=n}return e}_getOutputs(e,r=void 0){if(r===void 0&&(r=[]),e instanceof V)this._getStructOutputs(e,r);else{let n=this._getOutputInfo(e);n!==null&&r.push(n)}return r}_getStructOutputs(e,r){for(let n of e.members)if(n.type instanceof V)this._getStructOutputs(n.type,r);else{let o=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(o!==null){let i=this._getTypeInfo(n.type,n.type.attributes),a=this._parseInt(o.value),f=new Xe(n.name,i,o.name,a);r.push(f)}}}_getOutputInfo(e){let r=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(r!==null){let n=this._getTypeInfo(e,e.attributes),o=this._parseInt(r.value);return new Xe("",n,r.name,o)}return null}_getInputs(e,r=void 0){r===void 0&&(r=[]);for(let n of e)if(n.type instanceof V)this._getStructInputs(n.type,r);else{let o=this._getInputInfo(n);o!==null&&r.push(o)}return r}_getStructInputs(e,r){for(let n of e.members)if(n.type instanceof V)this._getStructInputs(n.type,r);else{let o=this._getInputInfo(n);o!==null&&r.push(o)}}_getInputInfo(e){let r=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(r!==null){let n=this._getAttribute(e,"interpolation"),o=this._getTypeInfo(e.type,e.attributes),i=this._parseInt(r.value),a=new Ot(e.name,o,r.name,i);return n!==null&&(a.interpolation=this._parseString(n.value)),a}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);let r=parseInt(e);return isNaN(r)?e:r}_getAlias(e){for(let r of this.aliases)if(r.name==e)return r.type;return null}_getAliasInfo(e){return new Rt(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,r){if(this._types.has(e))return this._types.get(e);if(e instanceof Te){let o=e,i=this._getTypeInfo(o.format,o.attributes),a=new de(o.name,r);return a.format=i,a.count=o.count,this._types.set(e,a),this._updateTypeInfo(a),a}if(e instanceof V){let o=e,i=new oe(o.name,r);for(let a of o.members){let f=this._getTypeInfo(a.type,a.attributes);i.members.push(new De(a.name,f,a.attributes))}return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof Z){let o=e,i=o.format instanceof G,a=o.format?i?this._getTypeInfo(o.format,null):new $(o.format,null):null,f=new Ye(o.name,a,r,o.access);return this._types.set(e,f),this._updateTypeInfo(f),f}if(e instanceof Ee){let o=e,i=o.format?this._getTypeInfo(o.format,null):null,a=new Ye(o.name,i,r,o.access);return this._types.set(e,a),this._updateTypeInfo(a),a}let n=new $(e.name,r);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var r,n;let o=this._getTypeSize(e);if(e.size=(r=o?.size)!==null&&r!==void 0?r:0,e instanceof de){let i=this._getTypeSize(e.format);e.stride=(n=i?.size)!==null&&n!==void 0?n:0,this._updateTypeInfo(e.format)}e instanceof oe&&this._updateStructInfo(e)}_updateStructInfo(e){var r;let n=0,o=0,i=0,a=0;for(let f=0,u=e.members.length;f<u;++f){let h=e.members[f],p=this._getTypeSize(h);if(!p)continue;(r=this._getAlias(h.type.name))!==null&&r!==void 0||h.type;let d=p.align,m=p.size;n=this._roundUp(d,n+o),o=m,i=n,a=Math.max(a,d),h.offset=n,h.size=m,this._updateTypeInfo(h.type)}e.size=this._roundUp(a,i+o),e.align=a}_getTypeSize(e){var r;if(e==null)return null;let n=this._getAttributeNum(e.attributes,"size",0),o=this._getAttributeNum(e.attributes,"align",0);if(e instanceof De&&(e=e.type),e instanceof $){let i=this._getAlias(e.name);i!==null&&(e=i)}{let i=Y._typeInfo[e.name];if(i!==void 0){let a=e.format==="f16"?2:1;return new se(Math.max(o,i.align/a),Math.max(n,i.size/a))}}{let i=Y._typeInfo[e.name.substring(0,e.name.length-1)];if(i){let a=e.name[e.name.length-1]==="h"?2:1;return new se(Math.max(o,i.align/a),Math.max(n,i.size/a))}}if(e instanceof de){let i=e,a=8,f=8,u=this._getTypeSize(i.format);u!==null&&(f=u.size,a=u.align);let h=i.count,p=this._getAttributeNum((r=e?.attributes)!==null&&r!==void 0?r:null,"stride",this._roundUp(a,f));return f=h*p,n&&(f=n),new se(Math.max(o,a),Math.max(n,f))}if(e instanceof oe){let i=0,a=0,f=0,u=0,h=0;for(let p of e.members){let d=this._getTypeSize(p.type);d!==null&&(i=Math.max(d.align,i),f=this._roundUp(d.align,f+u),u=d.size,h=f)}return a=this._roundUp(i,h+u),new se(Math.max(o,i),Math.max(n,a))}return null}_isUniformVar(e){return e instanceof j&&e.storage=="uniform"}_isStorageVar(e){return e instanceof j&&e.storage=="storage"}_isTextureVar(e){return e instanceof j&&e.type!==null&&Y._textureTypes.indexOf(e.type.name)!=-1}_isSamplerVar(e){return e instanceof j&&e.type!==null&&Y._samplerTypes.indexOf(e.type.name)!=-1}_getAttribute(e,r){let n=e;if(!n||!n.attributes)return null;let o=n.attributes;for(let i of o)if(i.name==r)return i;return null}_getAttributeNum(e,r,n){if(e===null)return n;for(let o of e)if(o.name==r){let i=o!==null&&o.value!==null?o.value:n;return i instanceof Array&&(i=i[0]),typeof i=="number"?i:typeof i=="string"?parseInt(i):n}return n}_roundUp(e,r){return Math.ceil(r/e)*e}};Y._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}};Y._textureTypes=s.any_texture_type.map(t=>t.name);Y._samplerTypes=s.sampler_type.map(t=>t.name);function Or(t){let e={attributes:[],bindings:[]},r;try{r=Po(t)}catch(i){return Rr.log.error(i.message)(),e}for(let i of r.uniforms){let a=[];for(let f of i.type.members)a.push({name:f.name,type:Cr(f.type)});e.bindings.push({type:"uniform",name:i.name,location:i.binding,group:i.group,members:a})}let n=r.entry.vertex[0],o=n?.inputs.length||0;for(let i=0;i<o;i++){let a=n.inputs[i];if(a.locationType==="location"){let f=Cr(a.type);e.attributes.push({name:a.name,location:a.location,type:f})}}return e}function Cr(t){return t.format?`${t.name}<${t.format.name}>`:t.name}function Po(t){try{return new Y(t)}catch(e){if(e instanceof Error)throw e;let r="WGSL parse error";throw typeof e=="object"&&e?.message&&(r+=`: ${e.message} `),typeof e=="object"&&e?.token&&(r+=e.token.line||""),new Error(r,{cause:e})}}var wo=`float random(vec3 scale, float seed) {
return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
}
`,B={name:"random",fs:wo};var Lo=`#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;
const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;
const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;
const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;
float sin_taylor_fp32(float a) {
float r, s, t, x;
if (a == 0.0) {
return 0.0;
}
x = -a * a;
s = a;
r = a;
r = r * x;
t = r * INVERSE_FACTORIAL_3;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_5;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_7;
s = s + t;
r = r * x;
t = r * INVERSE_FACTORIAL_9;
s = s + t;
return s;
}
void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
if (a == 0.0) {
sin_t = 0.0;
cos_t = 1.0;
}
sin_t = sin_taylor_fp32(a);
cos_t = sqrt(1.0 - sin_t * sin_t);
}
float tan_taylor_fp32(float a) {
float sin_a;
float cos_a;
if (a == 0.0) {
return 0.0;
}
float z = floor(a / TWO_PI);
float r = a - TWO_PI * z;
float t;
float q = floor(r / PI_2 + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return 1.0 / 0.0;
}
t = r - PI_2 * q;
q = floor(t / PI_16 + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return 1.0 / 0.0;
} else {
t = t - PI_16 * q;
}
float u = 0.0;
float v = 0.0;
float sin_t, cos_t;
float s, c;
sincos_taylor_fp32(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0;
v = SIN_TABLE_0;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1;
v = SIN_TABLE_1;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2;
v = SIN_TABLE_2;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3;
v = SIN_TABLE_3;
}
if (k > 0) {
s = u * sin_t + v * cos_t;
c = u * cos_t - v * sin_t;
} else {
s = u * sin_t - v * cos_t;
c = u * cos_t + v * sin_t;
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return sin_a / cos_a;
}
#endif
float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
return tan_taylor_fp32(a);
#else
return tan(a);
#endif
}
`,Ur={name:"fp32",vs:Lo};var So=new Float32Array([0,1,1,1]),ko=`uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
out vec4 picking_vRGBcolor_Avalid;
vec3 picking_normalizeColor(vec3 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
vec4 picking_normalizeColor(vec4 color) {
return picking.useFloatColors > 0.5 ? color : color / 255.0;
}
bool picking_isColorZero(vec3 color) {
return dot(color, vec3(1.0)) < 0.00001;
}
bool picking_isColorValid(vec3 color) {
return dot(color, vec3(1.0)) > 0.00001;
}
bool isVertexHighlighted(vec3 vertexColor) {
vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
return
bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}
void picking_setPickingColor(vec3 pickingColor) {
pickingColor = picking_normalizeColor(pickingColor);
if (bool(picking.isActive)) {
picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));
if (!bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = pickingColor;
}
} else {
picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
}
}
void picking_setPickingAttribute(float value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.r = value;
}
}
void picking_setPickingAttribute(vec2 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rg = value;
}
}
void picking_setPickingAttribute(vec3 value) {
if (bool(picking.isAttribute)) {
picking_vRGBcolor_Avalid.rgb = value;
}
}
`,No=`uniform pickingUniforms {
float isActive;
float isAttribute;
float isHighlightActive;
float useFloatColors;
vec3 highlightedObjectColor;
vec4 highlightColor;
} picking;
in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
if (picking.isActive > 0.5) {
return color;
}
bool selected = bool(picking_vRGBcolor_Avalid.a);
if (selected) {
float highLightAlpha = picking.highlightColor.a;
float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
float highLightRatio = highLightAlpha / blendedAlpha;
vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
return vec4(blendedRGB, blendedAlpha);
} else {
return color;
}
}
vec4 picking_filterPickingColor(vec4 color) {
if (bool(picking.isActive)) {
if (picking_vRGBcolor_Avalid.a == 0.0) {
discard;
}
return picking_vRGBcolor_Avalid;
}
return color;
}
vec4 picking_filterColor(vec4 color) {
vec4 highlightColor = picking_filterHighlightColor(color);
return picking_filterPickingColor(highlightColor);
}
`,zr={name:"picking",vs:ko,fs:No,uniformTypes:{isActive:"f32",isAttribute:"f32",isHighlightActive:"f32",useFloatColors:"f32",highlightedObjectColor:"vec3<f32>",highlightColor:"vec4<f32>"},defaultUniforms:{isActive:!1,isAttribute:!1,isHighlightActive:!1,useFloatColors:!0,highlightedObjectColor:new Float32Array([0,0,0]),highlightColor:So},getUniforms:Eo};function Eo(t={},e){let r={};if(t.highlightedObjectColor!==void 0)if(t.highlightedObjectColor===null)r.isHighlightActive=!1;else{r.isHighlightActive=!0;let n=t.highlightedObjectColor.slice(0,3);r.highlightedObjectColor=n}if(t.highlightColor){let n=Array.from(t.highlightColor,o=>o/255);Number.isFinite(n[3])||(n[3]=1),r.highlightColor=n}return t.isActive!==void 0&&(r.isActive=Boolean(t.isActive),r.isAttribute=Boolean(t.isAttribute)),t.useFloatColors!==void 0&&(r.useFloatColors=Boolean(t.useFloatColors)),r}var Yt=`precision highp int;
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform lightingUniforms {
int enabled;
int pointLightCount;
int directionalLightCount;
vec3 ambientColor;
int lightType;
vec3 lightColor;
vec3 lightDirection;
vec3 lightPosition;
vec3 lightAttenuation;
} lighting;
PointLight lighting_getPointLight(int index) {
return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}
DirectionalLight lighting_getDirectionalLight(int index) {
return DirectionalLight(lighting.lightColor, lighting.lightDirection);
}
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
`;var To=5,Mo=255,ge;(function(t){t[t.POINT=0]="POINT",t[t.DIRECTIONAL=1]="DIRECTIONAL"})(ge||(ge={}));var Q={name:"lighting",vs:Yt,fs:Yt,getUniforms(t,e){return Fo(t)},defines:{MAX_LIGHTS:To},uniformTypes:{enabled:"i32",ambientLightColor:"vec3<f32>",numberOfLights:"i32",lightType:"i32",lightColor:"vec3<f32>",lightPosition:"vec3<f32>",lightDirection:"vec3<f32>",lightAttenuation:"vec3<f32>"},defaultUniforms:{enabled:1,ambientLightColor:[.1,.1,.1],numberOfLights:0,lightType:ge.POINT,lightColor:[1,1,1],lightPosition:[1,1,2],lightDirection:[1,1,1],lightAttenuation:[1,1,1]}};function Fo(t,e={}){if(t=t&&{...t},!t)return{...Q.defaultUniforms};t.lights&&(t={...t,...Co(t.lights),lights:void 0});let{ambientLight:r,pointLights:n,directionalLights:o}=t||{};if(!(r||n&&n.length>0||o&&o.length>0))return{...Q.defaultUniforms,enabled:0};let a={...Q.defaultUniforms,...e,...Io({ambientLight:r,pointLights:n,directionalLights:o})};return t.enabled!==void 0&&(a.enabled=t.enabled?1:0),a}function Io({ambientLight:t,pointLights:e=[],directionalLights:r=[]}){let n={};n.ambientLightColor=Xt(t);let o=0;for(let i of e)n.lightType=ge.POINT,n.lightColor=Xt(i),n.lightPosition=i.position,n.lightAttenuation=[i.attenuation||1,0,0],o++;for(let i of r)n.lightType=ge.DIRECTIONAL,n.lightColor=Xt(i),n.lightPosition=i.position,n.lightDirection=i.direction,o++;return n.numberOfLights=o,n}function Co(t){let e={pointLights:[],directionalLights:[]};for(let r of t||[])switch(r.type){case"ambient":e.ambientLight=r;break;case"directional":e.directionalLights?.push(r);break;case"point":e.pointLights?.push(r);break;default:}return e}function Xt(t={}){let{color:e=[0,0,0],intensity:r=1}=t;return e.map(n=>n*r/Mo)}var Ro=`out vec3 dirlight_vNormal;
void dirlight_setNormal(vec3 normal) {
dirlight_vNormal = normalize(normal);
}
`,Oo=`uniform dirlightUniforms {
vec3 lightDirection;
} dirlight;
in vec3 dirlight_vNormal;
vec4 dirlight_filterColor(vec4 color) {
float d = abs(dot(dirlight_vNormal, normalize(dirlight.lightDirection)));
return vec4(color.rgb * d, color.a);
}
`,Qt={name:"dirlight",dependencies:[],vs:Ro,fs:Oo,uniformTypes:{lightDirection:"vec3<f32>"},defaultUniforms:{lightDirection:new Float32Array([1,1,2])},getUniforms:Uo};function Uo(t=Qt.defaultUniforms){let e={};return t.lightDirection&&(e.dirlight_uLightDirection=t.lightDirection),e}var Dr=`uniform materialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
`,Yr=`uniform materialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, material.shininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting.enabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = material.ambient * surfaceColor * lighting.ambientColor;
if (lighting.lightType == 0) {
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
} else if (lighting.lightType == 1) {
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting.enabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
switch (lighting.lightType) {
case 0:
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
break;
case 1:
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
break;
}
}
return lightColor;
}
`;var Bt={name:"gouraud-lighting",vs:Dr,fs:Yr,defines:{LIGHTING_VERTEX:1},dependencies:[Q],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(t){return{...Bt.defaultUniforms,...t}}};var Xr=`uniform phongMaterialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
`,Qr=`uniform phongMaterialUniforms {
uniform float ambient;
uniform float diffuse;
uniform float shininess;
uniform vec3  specularColor;
} material;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, material.shininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting.enabled == 0) {
return lightColor;
}
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = material.ambient * surfaceColor * lighting.ambientColor;
if (lighting.lightType == 0) {
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
} else if (lighting.lightType == 1) {
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting.enabled == 0) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
switch (lighting.lightType) {
case 0:
PointLight pointLight = lighting_getPointLight(0);
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
break;
case 1:
DirectionalLight directionalLight = lighting_getDirectionalLight(0);
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
break;
}
}
return lightColor;
}
`;var Vt={name:"phong-lighting",vs:Xr,fs:Qr,defines:{LIGHTING_FRAGMENT:1},dependencies:[Q],uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(t){return{...Vt.defaultUniforms,...t}}};var Br=`uniform projection {
mat4 u_MVPMatrix;
mat4 u_ModelMatrix;
mat4 u_NormalMatrix;
vec3 u_Camera;
}
varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`;var Vr=`precision highp float;
uniform Projection {
uniform vec3 u_Camera;
};
uniform pbrMaterial {
bool unlit;
bool baseColorMapEnabled;
vec4 baseColorFactor;
bool normalMapEnabled;
float normalScale;
bool emissiveMapEnabled;
vec3 emissiveFactor;
vec2 metallicRoughnessValues;
bool metallicRoughnessMapEnabled;
bool occlusionMapEnabled;
float occlusionStrength;
bool alphaCutoffEnabled;
float alphaCutoff;
bool IBLenabled;
vec2 scaleIBLAmbient;
vec4 scaleDiffBaseMR;
vec4 scaleFGDSpec;
} u_pbrMaterial;
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
#endif
varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo {
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_pbrMaterial.normalScale, u_pbrMaterial.normalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInfo.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);
diffuse *= u_pbrMaterial.scaleIBLAmbient.x;
specular *= u_pbrMaterial.scaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInfo)
{
return pbrInfo.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInfo)
{
return pbrInfo.reflectance0 +
(pbrInfo.reflectance90 - pbrInfo.reflectance0) *
pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInfo)
{
float NdotL = pbrInfo.NdotL;
float NdotV = pbrInfo.NdotV;
float r = pbrInfo.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInfo)
{
float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
pbrInfo.NdotL = 1.0;
pbrInfo.NdotH = 0.0;
pbrInfo.LdotH = 0.0;
pbrInfo.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
vec3 n = pbrInfo.n;
vec3 v = pbrInfo.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
vec3 F = specularReflection(pbrInfo);
float G = geometricOcclusion(pbrInfo);
float D = microfacetDistribution(pbrInfo);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_pbrMaterial.baseColorFactor;
#else
vec4 baseColor = u_pbrMaterial.baseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_pbrMaterial.alphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(u_pbrMaterial.unlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_pbrMaterial.metallicRoughnessValues.y;
float metallic = u_pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInfo = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInfo);
color += calculateFinalColor(pbrInfo, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInfo, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInfo, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInfo, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInfo, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
if (u_pbrMateral.IBLEnabled) {
color += getIBLContribution(pbrInfo, n, reflection);
}
#endif
#ifdef HAS_OCCLUSIONMAP
if (u_pbrMaterial.occlusionMapEnabled) {
float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_pbrMaterial.occlusionStrength);
}
#endif
#ifdef HAS_EMISSIVEMAP
if (u_pbrMaterial.emmissiveMapEnabled) {
vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_pbrMaterial.emissiveFactor;
color += emissive;
}
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_pbrMaterial.scaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_pbrMaterial.scaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_pbrMaterial.scaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;var qr={name:"pbr",vs:Br,fs:Vr,defines:{LIGHTING_FRAGMENT:1,HAS_NORMALMAP:0,HAS_EMISSIVEMAP:0,HAS_OCCLUSIONMAP:0,HAS_BASECOLORMAP:0,HAS_METALROUGHNESSMAP:0,ALPHA_CUTOFF:0,USE_IBL:0,PBR_DEBUG:0},uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"},bindings:{baseColorSampler:{type:"texture",location:8},normalSampler:{type:"texture",location:9},emissiveSampler:{type:"texture",location:10},metallicRoughnessSampler:{type:"texture",location:11},occlusionSampler:{type:"texture",location:12},diffuseEnvSampler:{type:"texture",location:13},specularEnvSampler:{type:"texture",location:14},brdfLUT:{type:"texture",location:15}},dependencies:[Q]};var zo=`uniform brightnessContrastUniforms {
float brightness;
float contrast;
} brightnessContrast;
vec4 brightnessContrast_filterColor(vec4 color) {
color.rgb += brightnessContrast.brightness;
if (brightnessContrast.contrast > 0.0) {
color.rgb = (color.rgb - 0.5) / (1.0 - brightnessContrast.contrast) + 0.5;
} else {
color.rgb = (color.rgb - 0.5) * (1.0 + brightnessContrast.contrast) + 0.5;
}
return color;
}
vec4 brightnessContrast_filterColor(vec4 color, vec2 texSize, vec2 texCoords) {
return brightnessContrast_filterColor(color);
}
`,Gr={name:"brightnessContrast",uniformTypes:{brightness:"f32",contrast:"f32"},uniformPropTypes:{brightness:{format:"f32",value:0,min:-1,max:1},contrast:{format:"f32",value:0,min:-1,max:1}},fs:zo,passes:[{filter:!0}]};var Do=`uniform denoiseUniforms {
float strength;
} noise;
vec4 denoise_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
float adjustedExponent = 3. + 200. * pow(1. - noise.strength, 4.);
vec4 center = texture(source, texCoord);
vec4 color = vec4(0.0);
float total = 0.0;
for (float x = -4.0; x <= 4.0; x += 1.0) {
for (float y = -4.0; y <= 4.0; y += 1.0) {
vec4 offsetColor = texture(source, texCoord + vec2(x, y) / texSize);
float weight = 1.0 - abs(dot(offsetColor.rgb - center.rgb, vec3(0.25)));
weight = pow(weight, adjustedExponent);
color += offsetColor * weight;
total += weight;
}
}
return color / total;
}
`,Hr={name:"denoise",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{format:"f32",value:.5,min:0,max:1}},fs:Do,passes:[{sampler:!0},{sampler:!0}]};var Yo=`uniform hueSaturationUniforms {
float hue;
float saturation;
} hueSaturation;
vec4 hueSaturation_filterColor(vec4 color) {
float angle = hueSaturation.hue * 3.14159265;
float s = sin(angle), c = cos(angle);
vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;
float len = length(color.rgb);
color.rgb = vec3(
dot(color.rgb, weights.xyz),
dot(color.rgb, weights.zxy),
dot(color.rgb, weights.yzx)
);
float average = (color.r + color.g + color.b) / 3.0;
if (hueSaturation.saturation > 0.0) {
color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - hueSaturation.saturation));
} else {
color.rgb += (average - color.rgb) * (-hueSaturation.saturation);
}
return color;
}
vec4 hueSaturation_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return hueSaturation_filterColor(color);
}
`,Wr={name:"hueSaturation",uniformTypes:{hue:"f32",saturation:"f32"},uniformPropTypes:{hue:{value:0,min:-1,max:1},saturation:{value:0,min:-1,max:1}},fs:Yo,passes:[{filter:!0}]};var Xo=`uniform noiseUniforms {
float amount;
} noise;
float rand(vec2 co) {
return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec4 noise_filterColor(vec4 color, vec2 texCoord) {
float diff = (rand(texCoord) - 0.5) * noise.amount;
color.r += diff;
color.g += diff;
color.b += diff;
return color;
}
vec4 noise_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return noise_filterColor(color, texCoord);
}
`,jr={name:"noise",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:Xo,passes:[{filter:!0}]};var Qo=`uniform sepiaUniforms {
float amount;
} sepia;
vec4 sepia_filterColor(vec4 color) {
float r = color.r;
float g = color.g;
float b = color.b;
color.r =
min(1.0, (r * (1.0 - (0.607 * sepia.amount))) + (g * (0.769 * sepia.amount)) + (b * (0.189 * sepia.amount)));
color.g = min(1.0, (r * 0.349 * sepia.amount) + (g * (1.0 - (0.314 * sepia.amount))) + (b * 0.168 * sepia.amount));
color.b = min(1.0, (r * 0.272 * sepia.amount) + (g * 0.534 * sepia.amount) + (b * (1.0 - (0.869 * sepia.amount))));
return color;
}
vec4 sepia_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return sepia_filterColor(color);
}
`,$r={name:"sepia",uniformTypes:{amount:"f32"},uniformPropTypes:{amount:{value:.5,min:0,max:1}},fs:Qo,passes:[{filter:!0}]};var Bo=`uniform vibranceUniforms {
float amount;
} vibrance;
vec4 vibrance_filterColor(vec4 color) {
float average = (color.r + color.g + color.b) / 3.0;
float mx = max(color.r, max(color.g, color.b));
float amt = (mx - average) * (-vibrance.amount * 3.0);
color.rgb = mix(color.rgb, vec3(mx), amt);
return color;
}
vec4 vibrance_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return vibrance_filterColor(color);
}
`,Kr={name:"vibrance",uniformPropTypes:{amount:{value:0,min:-1,max:1}},fs:Bo,passes:[{filter:!0}]};var Vo=`uniform vignetteUniforms {
float radius;
float amount;
} vignette;
vec4 vignette_filterColor(vec4 color, vec2 texCoord) {
float dist = distance(texCoord, vec2(0.5, 0.5));
float ratio = smoothstep(0.8, vignette.radius * 0.799, dist * (vignette.amount + vignette.radius));
return color.rgba * ratio + (1.0 - ratio)*vec4(0.0, 0.0, 0.0, 1.0);
}
vec4 vignette_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
return vignette_filterColor(color, texCoord);
}
`,Zr={name:"vignette",fs:Vo,uniformTypes:{radius:"f32",amount:"f32"},uniformPropTypes:{radius:{value:.5,min:0,max:1},amount:{value:.5,min:0,max:1}},passes:[{filter:!0}]};var qo=`uniform tiltShiftUniforms {
float blurRadius;
float gradientRadius;
vec2 start;
vec2 end;
bool invert;
} tiltShift;
vec2 tiltShift_getDelta(vec2 texSize) {
vec2 vector = normalize((tiltShift.end - tiltShift.start) * texSize);
return tiltShift.invert ? vec2(-vector.y, vector.x) : vector;
}
vec4 tiltShift_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
vec2 normal = normalize(vec2((tiltShift.start.y - tiltShift.end.y) * texSize.y, (tiltShift.end.x - tiltShift.start.x) * texSize.x));
float radius = smoothstep(0.0, 1.0,
abs(dot(texCoord * texSize - tiltShift.start * texSize, normal)) / tiltShift.gradientRadius) * tiltShift.blurRadius;
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec4 offsetColor = texture(source, texCoord + tiltShift_getDelta(texSize) / texSize * percent * radius);
offsetColor.rgb *= offsetColor.a;
color += offsetColor * weight;
total += weight;
}
color = color / total;
color.rgb /= color.a + 0.00001;
return color;
}
`,Jr={name:"tiltShift",uniformTypes:{blurRadius:"f32",gradientRadius:"f32",start:"vec2<f32>",end:"vec2<f32>",invert:"i32"},uniformPropTypes:{blurRadius:{value:15,min:0,max:50},gradientRadius:{value:200,min:0,max:400},start:{value:[0,0]},end:{value:[1,1]},invert:{value:!1,private:!0}},passes:[{sampler:!0,uniforms:{invert:!1}},{sampler:!0,uniforms:{invert:!0}}],dependencies:[B],fs:qo};var Go=`uniform triangleBlurUniforms {
float radius;
vec2 delta;
} triangleBlur;
vec4 triangleBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 adjustedDelta = triangleBlur.delta * triangleBlur.radius / texSize;
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec4 offsetColor = texture(source, texCoord + adjustedDelta * percent);
offsetColor.rgb *= offsetColor.a;
color += offsetColor * weight;
total += weight;
}
color = color / total;
color.rgb /= color.a + 0.00001;
return color;
}
`,en={name:"triangleBlur",uniformTypes:{radius:"f32",delta:"vec2<f32>"},uniformPropTypes:{radius:{value:20,min:0,softMax:100},delta:{value:[1,0],private:!0}},fs:Go,dependencies:[B],passes:[{sampler:!0,uniforms:{delta:[1,0]}},{sampler:!0,uniforms:{delta:[0,1]}}]};var Ho=`
uniform zoomBlurUniforms {
  vec2 center;
  float strength;
} zoomBlur;

vec4 zoomBlur_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
  vec4 color = vec4(0.0);
  float total = 0.0;
  vec2 toCenter = zoomBlur.center * texSize - texCoord * texSize;

  /* randomize the lookup values to hide the fixed number of samples */
  float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

  for (float t = 0.0; t <= 40.0; t++) {
    float percent = (t + offset) / 40.0;
    float weight = 4.0 * (percent - percent * percent);
    vec4 offsetColor = texture(source, texCoord + toCenter * percent * zoomBlur.strength / texSize);

    /* switch to pre-multiplied alpha to correctly blur transparent images */
    offsetColor.rgb *= offsetColor.a;

    color += offsetColor * weight;
    total += weight;
  }

  color = color / total;

  /* switch back from pre-multiplied alpha */
  color.rgb /= color.a + 0.00001;

  return color;
}
`,tn={name:"zoomBlur",uniformTypes:{center:"vec2<f32>",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},strength:{value:.3,min:0,softMax:1}},fs:Ho,dependencies:[B],passes:[{sampler:!0}]};var Wo=`uniform colorHalftoneUniforms {
vec2 center;
float angle;
float size;
} colorHalftone;
float pattern(float angle, float scale, vec2 texSize, vec2 texCoord) {
float s = sin(angle), c = cos(angle);
vec2 tex = texCoord * texSize - colorHalftone.center * texSize;
vec2 point = vec2(
c * tex.x - s * tex.y,
s * tex.x + c * tex.y
) * scale;
return (sin(point.x) * sin(point.y)) * 4.0;
}
vec4 colorHalftone_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
float scale = 3.1514 / colorHalftone.size;
vec3 cmy = 1.0 - color.rgb;
float k = min(cmy.x, min(cmy.y, cmy.z));
cmy = (cmy - k) / (1.0 - k);
cmy = clamp(
cmy * 10.0 - 3.0 + vec3(
pattern(colorHalftone.angle + 0.26179, scale, texSize, texCoord),
pattern(colorHalftone.angle + 1.30899, scale, texSize, texCoord),
pattern(colorHalftone.angle, scale, texSize, texCoord)
),
0.0,
1.0
);
k = clamp(k * 10.0 - 5.0 + pattern(colorHalftone.angle + 0.78539, scale, texSize, texCoord), 0.0, 1.0);
return vec4(1.0 - cmy - k, color.a);
}
`,rn={name:"colorHalftone",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:4,min:1,softMin:3,softMax:20}},fs:Wo,passes:[{filter:!0}]};var jo=`uniform dotScreenUniforms {
vec2 center;
float angle;
float size;
} dotScreen;
float pattern(vec2 texSize, vec2 texCoord) {
float scale = 3.1415 / dotScreen.size;
float s = sin(dotScreen.angle), c = cos(dotScreen.angle);
vec2 tex = texCoord * texSize - dotScreen.center * texSize;
vec2 point = vec2(
c * tex.x - s * tex.y,
s * tex.x + c * tex.y
) * scale;
return (sin(point.x) * sin(point.y)) * 4.0;
}
vec4 dotScreen_filterColor(vec4 color, vec2 texSize, vec2 texCoord) {
float average = (color.r + color.g + color.b) / 3.0;
return vec4(vec3(average * 10.0 - 5.0 + pattern(texSize, texCoord)), color.a);
}
`,nn={name:"dotScreen",uniformTypes:{center:"vec2<f32>",angle:"f32",size:"f32"},uniformPropTypes:{center:{value:[.5,.5]},angle:{value:1.1,softMin:0,softMax:Math.PI/2},size:{value:3,min:1,softMin:3,softMax:20}},fs:jo,passes:[{filter:!0}]};var $o=`uniform edgeWorkUniforms {
float radius;
vec2 delta;
} edgeWork;
vec4 edgeWork_sampleColor1(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;
vec2 color = vec2(0.0);
vec2 total = vec2(0.0);
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec3 sampleColor = texture(source, texCoord + relativeDelta * percent).rgb;
float average = (sampleColor.r + sampleColor.g + sampleColor.b) / 3.0;
color.x += average * weight;
total.x += weight;
if (abs(t) < 15.0) {
weight = weight * 2.0 - 1.0;
color.y += average * weight;
total.y += weight;
}
}
return vec4(color / total, 0.0, 1.0);
}
vec4 edgeWork_sampleColor2(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 relativeDelta = edgeWork.radius * edgeWork.delta / texSize;
vec2 color = vec2(0.0);
vec2 total = vec2(0.0);
float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
for (float t = -30.0; t <= 30.0; t++) {
float percent = (t + offset - 0.5) / 30.0;
float weight = 1.0 - abs(percent);
vec2 sampleColor = texture(source, texCoord + relativeDelta * percent).xy;
color.x += sampleColor.x * weight;
total.x += weight;
if (abs(t) < 15.0) {
weight = weight * 2.0 - 1.0;
color.y += sampleColor.y * weight;
total.y += weight;
}
}
float c = clamp(10000.0 * (color.y / total.y - color.x / total.x) + 0.5, 0.0, 1.0);
return vec4(c, c, c, 1.0);
}
`,on={name:"edgeWork",uniformPropTypes:{radius:{value:2,min:1,softMax:50},delta:{value:[1,0],private:!0}},fs:$o,dependencies:[B],passes:[{sampler:"edgeWork_sampleColor1",uniformPropTypes:{delta:[1,0]}},{sampler:"edgeWork_sampleColor2",uniformPropTypes:{delta:[0,1]}}]};var Ko=`uniform hexagonalPixelateUniforms {
vec2 center;
float scale;
} hexagonalPixelate;
vec4 hexagonalPixelate_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 tex = (texCoord * texSize - hexagonalPixelate.center * texSize) / hexagonalPixelate.scale;
tex.y /= 0.866025404;
tex.x -= tex.y * 0.5;
vec2 a;
if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0) {
a = vec2(floor(tex.x), floor(tex.y));
}
else a = vec2(ceil(tex.x), ceil(tex.y));
vec2 b = vec2(ceil(tex.x), floor(tex.y));
vec2 c = vec2(floor(tex.x), ceil(tex.y));
vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);
vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);
vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);
vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);
float alen = length(TEX - A);
float blen = length(TEX - B);
float clen = length(TEX - C);
vec2 choice;
if (alen < blen) {
if (alen < clen) choice = a;
else choice = c;
} else {
if (blen < clen) choice = b;
else choice = c;
}
choice.x += choice.y * 0.5;
choice.y *= 0.866025404;
choice *= hexagonalPixelate.scale / texSize;
return texture(source, choice + hexagonalPixelate.center);
}
`,sn={name:"hexagonalPixelate",uniformTypes:{center:"vec2<f32>",scale:"f32"},uniformPropTypes:{center:{value:[.5,.5],hint:"screenspace"},scale:{value:10,min:1,softMin:5,softMax:50}},fs:Ko,passes:[{sampler:!0}]};var Zo=`uniform inkUniforms {
float strength;
} ink;
vec4 ink_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 dx = vec2(1.0 / texSize.x, 0.0);
vec2 dy = vec2(0.0, 1.0 / texSize.y);
vec4 color = texture(source, texCoord);
float bigTotal = 0.0;
float smallTotal = 0.0;
vec3 bigAverage = vec3(0.0);
vec3 smallAverage = vec3(0.0);
for (float x = -2.0; x <= 2.0; x += 1.0) {
for (float y = -2.0; y <= 2.0; y += 1.0) {
vec3 offsetColor = texture(source, texCoord + dx * x + dy * y).rgb;
bigAverage += offsetColor;
bigTotal += 1.0;
if (abs(x) + abs(y) < 2.0) {
smallAverage += offsetColor;
smallTotal += 1.0;
}
}
}
vec3 edge = max(vec3(0.0), bigAverage / bigTotal - smallAverage / smallTotal);
float power = ink.strength * ink.strength * ink.strength * ink.strength * ink.strength;
return vec4(color.rgb - dot(edge, edge) * power * 100000.0, color.a);
}
`,an={name:"ink",uniformTypes:{strength:"f32"},uniformPropTypes:{strength:{value:.25,min:0,softMax:1}},fs:Zo,passes:[{sampler:!0}]};var Jo=`uniform magnifyUniforms {
vec2 screenXY;
float radiusPixels;
float zoom;
float borderWidthPixels;
vec4 borderColor;
} magnify;
vec4 magnify_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 pos = vec2(magnify.screenXY.x, 1.0 - magnify.screenXY.y);
float dist = distance(texCoord * texSize, pos * texSize);
if (dist < magnify.radiusPixels) {
return texture(source, (texCoord - pos) / magnify.zoom + pos);
}
if (dist <= magnify.radiusPixels + magnify.borderWidthPixels) {
return magnify.borderColor;
}
return texture(source, texCoord);
}
`,cn={name:"magnify",uniformTypes:{screenXY:"vec2<f32>",radiusPixels:"f32",zoom:"f32",borderWidthPixels:"f32",borderColor:"vec4<f32>"},uniformPropTypes:{screenXY:{value:[0,0]},radiusPixels:200,zoom:2,borderWidthPixels:0,borderColor:{value:[255,255,255,255]}},fs:Jo,passes:[{sampler:!0}]};var ei=`vec4 warp_sampleColor(sampler2D source, vec2 texSize, vec2 coord) {
vec4 color = texture(source, coord / texSize);
vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);
if (coord != clampedCoord) {
color.a *= max(0.0, 1.0 - length(coord - clampedCoord));
}
return color;
}
`,ce={name:"warp",passes:[],fs:ei};var ti=`uniform bulgePinchUniforms {
float radius;
float strength;
vec2 center;
} bulgePinch;
vec2 bulgePinch_warp(vec2 coord, vec2 texCenter) {
coord -= texCenter;
float distance = length(coord);
if (distance < bulgePinch.radius) {
float percent = distance / bulgePinch.radius;
if (bulgePinch.strength > 0.0) {
coord *= mix(1.0, smoothstep(0.0, bulgePinch.radius / distance, percent), bulgePinch.strength * 0.75);
} else {
coord *= mix(1.0, pow(percent, 1.0 + bulgePinch.strength * 0.75) * bulgePinch.radius / distance, 1.0 - percent);
}
}
coord += texCenter;
return coord;
}
vec4 bulgePinch_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 coord = texCoord * texSize;
coord = bulgePinch_warp(coord, bulgePinch.center * texSize);
return warp_sampleColor(source, texSize, coord);
}
`,ln={name:"bulgePinch",fs:ti,uniformTypes:{center:"vec2<f32>",radius:"f32",strength:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},strength:{value:.5,min:-1,max:1}},dependencies:[ce],passes:[{sampler:!0}]};var ri=`uniform swirlUniforms {
float radius;
float angle;
vec2 center;
} swirl;
vec2 swirl_warp(vec2 coord, vec2 texCenter) {
coord -= texCenter;
float distance = length(coord);
if (distance < swirl.radius) {
float percent = (swirl.radius - distance) / swirl.radius;
float theta = percent * percent * swirl.angle;
float s = sin(theta);
float c = cos(theta);
coord = vec2(
coord.x * c - coord.y * s,
coord.x * s + coord.y * c
);
}
coord += texCenter;
return coord;
}
vec4 swirl_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
vec2 coord = texCoord * texSize;
coord = swirl_warp(coord, swirl.center * texSize);
return warp_sampleColor(source, texSize, coord);
}
`,fn={name:"swirl",fs:ri,uniformTypes:{center:"vec2<f32>",radius:"f32",angle:"f32"},uniformPropTypes:{center:{value:[.5,.5]},radius:{value:200,min:1,softMax:600},angle:{value:3,softMin:-25,softMax:25}},dependencies:[ce],passes:[{sampler:!0}]};var ni=`
#define FXAA_QUALITY_PRESET 29

#if (FXAA_QUALITY_PRESET == 10)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 3.0
    #define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 3.0
    #define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 4.0
    #define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 4.0
    #define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 4.0
    #define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 2.0
    #define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 3.0
    #define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
    #define FXAA_QUALITY_PS 9
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 4.0
    #define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
    #define FXAA_QUALITY_PS 10
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 4.0
    #define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
    #define FXAA_QUALITY_PS 11
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 4.0
    #define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.0
    #define FXAA_QUALITY_P2 1.0
    #define FXAA_QUALITY_P3 1.0
    #define FXAA_QUALITY_P4 1.0
    #define FXAA_QUALITY_P5 1.5
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif

#define FxaaBool bool
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 vec2
#define FxaaTex sampler2D

#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTexTop(t, p) texture(t, p)
#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))

FxaaFloat FxaaLuma_(FxaaFloat4 rgba) { return dot(rgba.rgb, vec3(0.2126, 0.7152, 0.0722)); }

FxaaFloat4 FxaaPixelShader_(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {___a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_SUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin
) {
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posM;
    posM.x = pos.x;
    posM.y = pos.y;
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
    #define lumaM rgbyM.y
    FxaaFloat lumaS = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaN = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat maxSM = max(lumaS, lumaM);
    FxaaFloat minSM = min(lumaS, lumaM);
    FxaaFloat maxESM = max(lumaE, maxSM);
    FxaaFloat minESM = min(lumaE, minSM);
    FxaaFloat maxWN = max(lumaN, lumaW);
    FxaaFloat minWN = min(lumaN, lumaW);
    FxaaFloat rangeMax = max(maxWN, maxESM);
    FxaaFloat rangeMin = min(minWN, minESM);
    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
    FxaaFloat range = rangeMax - rangeMin;
    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
    FxaaBool earlyExit = range < rangeMaxClamped;
/*--------------------------------------------------------------------------*/
    if(earlyExit)
        return rgbyM;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaNE = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSW = FxaaLuma_(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNS = lumaN + lumaS;
    FxaaFloat lumaWE = lumaW + lumaE;
    FxaaFloat subpixRcpRange = 1.0/range;
    FxaaFloat subpixNSWE = lumaNS + lumaWE;
    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNESE = lumaNE + lumaSE;
    FxaaFloat lumaNWNE = lumaNW + lumaNE;
    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNWSW = lumaNW + lumaSW;
    FxaaFloat lumaSWSE = lumaSW + lumaSE;
    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
/*--------------------------------------------------------------------------*/
    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
    FxaaBool horzSpan = edgeHorz >= edgeVert;
    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
/*--------------------------------------------------------------------------*/
    if(!horzSpan) lumaN = lumaW;
    if(!horzSpan) lumaS = lumaE;
    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
/*--------------------------------------------------------------------------*/
    FxaaFloat gradientN = lumaN - lumaM;
    FxaaFloat gradientS = lumaS - lumaM;
    FxaaFloat lumaNN = lumaN + lumaM;
    FxaaFloat lumaSS = lumaS + lumaM;
    FxaaBool pairN = abs(gradientN) >= abs(gradientS);
    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
    if(pairN) lengthSign = -lengthSign;
    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posB;
    posB.x = posM.x;
    posB.y = posM.y;
    FxaaFloat2 offNP;
    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
    if(!horzSpan) posB.x += lengthSign * 0.5;
    if( horzSpan) posB.y += lengthSign * 0.5;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posN;
    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
    FxaaFloat2 posP;
    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
    FxaaFloat lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN));
    FxaaFloat subpixE = subpixC * subpixC;
    FxaaFloat lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP));
/*--------------------------------------------------------------------------*/
    if(!pairN) lumaNN = lumaSS;
    FxaaFloat gradientScaled = gradient * 1.0/4.0;
    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
    FxaaFloat subpixF = subpixD * subpixE;
    FxaaBool lumaMLTZero = lumaMM < 0.0;
/*--------------------------------------------------------------------------*/
    lumaEndN -= lumaNN * 0.5;
    lumaEndP -= lumaNN * 0.5;
    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
    FxaaBool doneNP = (!doneN) || (!doneP);
    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
/*--------------------------------------------------------------------------*/
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 3)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 4)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 5)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 6)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
/*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITY_PS > 7)
                        if(doneNP) {
                            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
                            doneNP = (!doneN) || (!doneP);
                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
/*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITY_PS > 8)
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 9)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 10)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 11)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 12)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma_(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma_(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
    #endif
/*--------------------------------------------------------------------------*/
                        }
                        #endif
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
/*--------------------------------------------------------------------------*/
    FxaaFloat dstN = posM.x - posN.x;
    FxaaFloat dstP = posP.x - posM.x;
    if(!horzSpan) dstN = posM.y - posN.y;
    if(!horzSpan) dstP = posP.y - posM.y;
/*--------------------------------------------------------------------------*/
    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
    FxaaFloat spanLength = (dstP + dstN);
    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
    FxaaFloat spanLengthRcp = 1.0/spanLength;
/*--------------------------------------------------------------------------*/
    FxaaBool directionN = dstN < dstP;
    FxaaFloat dst = min(dstN, dstP);
    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
    FxaaFloat subpixG = subpixF * subpixF;
    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
/*--------------------------------------------------------------------------*/
    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
    return FxaaTexTop(tex, posM);
}

vec4 fxaa_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
    const float fxaa_QualitySubpix = 0.5;
    const float fxaa_QualityEdgeThreshold = 0.125;
    const float fxaa_QualityEdgeThresholdMin = 0.0833;

    return FxaaPixelShader_(
        texCoord,
        source,
        vec2(1.0) / texSize,
        fxaa_QualitySubpix,
        fxaa_QualityEdgeThreshold,
        fxaa_QualityEdgeThresholdMin
    );
}
`,un={name:"fxaa",uniformPropTypes:{},fs:ni,passes:[{sampler:!0}]};function Qe(t,e=[],r=0){let n=Math.fround(t),o=t-n;return e[r]=n,e[r+1]=o,e}function qt(t){return t-Math.fround(t)}function Gt(t){let e=new Float32Array(32);for(let r=0;r<4;++r)for(let n=0;n<4;++n){let o=r*4+n;Qe(t[n*4+r],e,o*2)}return e}var _n=`uniform float ONE;
vec2 split(float a) {
const float SPLIT = 4097.0;
float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float a_hi = t * ONE - (t - a);
float a_lo = a * ONE - a_hi;
#else
float a_hi = t - (t - a);
float a_lo = a - a_hi;
#endif
return vec2(a_hi, a_lo);
}
vec2 split2(vec2 a) {
vec2 b = split(a.x);
b.y += a.y;
return b;
}
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float sum = (a + b) * ONE;
float err = b - (sum - a) * ONE;
#else
float sum = a + b;
float err = b - (sum - a);
#endif
return vec2(sum, err);
}
vec2 twoSum(float a, float b) {
float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
float v = s - a;
float err = (a - (s - v)) + (b - v);
#endif
return vec2(s, err);
}
vec2 twoSub(float a, float b) {
float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float v = (s * ONE - a) * ONE;
float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
float v = s - a;
float err = (a - (s - v)) - (b + v);
#endif
return vec2(s, err);
}
vec2 twoSqr(float a) {
float prod = a * a;
vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
return vec2(prod, err);
}
vec2 twoProd(float a, float b) {
float prod = a * b;
vec2 a_fp64 = split(a);
vec2 b_fp64 = split(b);
float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
return vec2(prod, err);
}
vec2 sum_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSum(a.x, b.x);
t = twoSum(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 sub_fp64(vec2 a, vec2 b) {
vec2 s, t;
s = twoSub(a.x, b.x);
t = twoSub(a.y, b.y);
s.y += t.x;
s = quickTwoSum(s.x, s.y);
s.y += t.y;
s = quickTwoSum(s.x, s.y);
return s;
}
vec2 mul_fp64(vec2 a, vec2 b) {
vec2 prod = twoProd(a.x, b.x);
prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
prod = split2(prod);
#endif
prod = quickTwoSum(prod.x, prod.y);
return prod;
}
vec2 div_fp64(vec2 a, vec2 b) {
float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
vec2 yn = a * xn;
#endif
float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
vec2 prod = twoProd(xn, diff);
return sum_fp64(yn, prod);
}
vec2 sqrt_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
float x = 1.0 / sqrt(a.x);
float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
vec2 yn_sqr = twoSqr(yn) * ONE;
#else
vec2 yn_sqr = twoSqr(yn);
#endif
float diff = sub_fp64(a, yn_sqr).x;
vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
return sum_fp64(split(yn), prod);
#else
return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`;var hn=`const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);
const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);
const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);
const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);
float nint(float d) {
if (d == floor(d)) return d;
return floor(d + 0.5);
}
vec2 nint_fp64(vec2 a) {
float hi = nint(a.x);
float lo;
vec2 tmp;
if (hi == a.x) {
lo = nint(a.y);
tmp = quickTwoSum(hi, lo);
} else {
lo = 0.0;
if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
hi -= 1.0;
}
tmp = vec2(hi, lo);
}
return tmp;
}
vec2 exp_fp64(vec2 a) {
const int k_power = 4;
const float k = 16.0;
const float inv_k = 1.0 / k;
if (a.x <= -88.0) return vec2(0.0, 0.0);
if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
if (a.x == 1.0 && a.y == 0.0) return E_FP64;
float m = floor(a.x / LOG2_FP64.x + 0.5);
vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
vec2 s, t, p;
p = mul_fp64(r, r);
s = sum_fp64(r, p * 0.5);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
p = mul_fp64(p, r);
t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
for (int i = 0; i < k_power; i++) {
s = sum_fp64(s * 2.0, mul_fp64(s, s));
}
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = sum_fp64(s, vec2(ONE, 0.0));
#else
s = sum_fp64(s, vec2(1.0, 0.0));
#endif
return s * pow(2.0, m);
}
vec2 log_fp64(vec2 a)
{
if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
vec2 x = vec2(log(a.x), 0.0);
vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
s = vec2(ONE, 0.0);
#else
s = vec2(1.0, 0.0);
#endif
x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
return x;
}
vec2 sin_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
x = -mul_fp64(a, a);
s = a;
r = a;
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
s = sum_fp64(s, t);
return s;
}
vec2 cos_taylor_fp64(vec2 a) {
vec2 r, s, t, x;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
x = -mul_fp64(a, a);
r = x;
s = sum_fp64(vec2(1.0, 0.0), r * 0.5);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
s = sum_fp64(s, t);
r = mul_fp64(r, x);
t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
s = sum_fp64(s, t);
return s;
}
void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
if (a.x == 0.0 && a.y == 0.0) {
sin_t = vec2(0.0, 0.0);
cos_t = vec2(1.0, 0.0);
}
sin_t = sin_taylor_fp64(a);
cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}
vec2 sin_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return sin_taylor_fp64(t);
} else if (j == 1) {
return cos_taylor_fp64(t);
} else if (j == -1) {
return -cos_taylor_fp64(t);
} else {
return -sin_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else if (j == 1) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
}
} else {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
}
return result;
}
vec2 cos_fp64(vec2 a) {
if (a.x == 0.0 && a.y == 0.0) {
return vec2(1.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
if (k == 0) {
if (j == 0) {
return cos_taylor_fp64(t);
} else if (j == 1) {
return -sin_taylor_fp64(t);
} else if (j == -1) {
return sin_taylor_fp64(t);
} else {
return -cos_taylor_fp64(t);
}
}
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
vec2 sin_t, cos_t;
sincos_taylor_fp64(t, sin_t, cos_t);
vec2 result = vec2(0.0, 0.0);
if (j == 0) {
if (k > 0) {
result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
} else if (j == 1) {
if (k > 0) {
result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
}
} else if (j == -1) {
if (k > 0) {
result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
} else {
result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
}
} else {
if (k > 0) {
result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
} else {
result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
return result;
}
vec2 tan_fp64(vec2 a) {
vec2 sin_a;
vec2 cos_a;
if (a.x == 0.0 && a.y == 0.0) {
return vec2(0.0, 0.0);
}
vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));
vec2 t;
float q = floor(r.x / PI_2_FP64.x + 0.5);
int j = int(q);
if (j < -2 || j > 2) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
}
t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));
q = floor(t.x / PI_16_FP64.x + 0.5);
int k = int(q);
int abs_k = int(abs(float(k)));
if (abs_k > 4) {
return vec2(0.0 / 0.0, 0.0 / 0.0);
} else {
t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
}
vec2 u = vec2(0.0, 0.0);
vec2 v = vec2(0.0, 0.0);
vec2 sin_t, cos_t;
vec2 s, c;
sincos_taylor_fp64(t, sin_t, cos_t);
if (k == 0) {
s = sin_t;
c = cos_t;
} else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
if (abs(float(abs_k) - 1.0) < 0.5) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs(float(abs_k) - 2.0) < 0.5) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs(float(abs_k) - 3.0) < 0.5) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs(float(abs_k) - 4.0) < 0.5) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#else
if (abs_k == 1) {
u = COS_TABLE_0_FP64;
v = SIN_TABLE_0_FP64;
} else if (abs_k == 2) {
u = COS_TABLE_1_FP64;
v = SIN_TABLE_1_FP64;
} else if (abs_k == 3) {
u = COS_TABLE_2_FP64;
v = SIN_TABLE_2_FP64;
} else if (abs_k == 4) {
u = COS_TABLE_3_FP64;
v = SIN_TABLE_3_FP64;
}
#endif
if (k > 0) {
s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
} else {
s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
}
}
if (j == 0) {
sin_a = s;
cos_a = c;
} else if (j == 1) {
sin_a = c;
cos_a = -s;
} else if (j == -1) {
sin_a = -c;
cos_a = s;
} else {
sin_a = -s;
cos_a = -c;
}
return div_fp64(sin_a, cos_a);
}
vec2 radians_fp64(vec2 degree) {
return mul_fp64(degree, PI_180_FP64);
}
vec2 mix_fp64(vec2 a, vec2 b, float x) {
vec2 range = sub_fp64(b, a);
return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sum_fp64(a[0], b[0]);
out_val[1] = sum_fp64(a[1], b[1]);
}
void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = sub_fp64(a[0], b[0]);
out_val[1] = sub_fp64(a[1], b[1]);
}
void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = mul_fp64(a[0], b[0]);
out_val[1] = mul_fp64(a[1], b[1]);
}
void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
out_val[0] = div_fp64(a[0], b[0]);
out_val[1] = div_fp64(a[1], b[1]);
}
void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
vec2 range[2];
vec2_sub_fp64(y, x, range);
vec2 portion[2];
portion[0] = range[0] * a;
portion[1] = range[1] * a;
vec2_sum_fp64(x, portion, out_val);
}
vec2 vec2_length_fp64(vec2 x[2]) {
return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}
void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
vec2 length = vec2_length_fp64(x);
vec2 length_vec2[2];
length_vec2[0] = length;
length_vec2[1] = length;
vec2_div_fp64(x, length_vec2, out_val);
}
vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
vec2 diff[2];
vec2_sub_fp64(x, y, diff);
return vec2_length_fp64(diff);
}
vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
vec2 v[2];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
return sum_fp64(v[0], v[1]);
}
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
for (int i = 0; i < 3; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
vec2 vec3_length_fp64(vec2 x[3]) {
return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
mul_fp64(x[2], x[2])));
}
vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
vec2 diff[3];
vec3_sub_fp64(x, y, diff);
return vec3_length_fp64(diff);
}
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
out_val[0].x = a[0];
out_val[0].y = 0.0;
out_val[1].x = a[1];
out_val[1].y = 0.0;
out_val[2].x = a[2];
out_val[2].y = 0.0;
out_val[3].x = a[3];
out_val[3].y = 0.0;
}
void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
out_val[0] = mul_fp64(a[0], b);
out_val[1] = mul_fp64(a[1], b);
out_val[2] = mul_fp64(a[2], b);
out_val[3] = mul_fp64(a[3], b);
}
void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
for (int i = 0; i < 4; i++) {
out_val[i] = sum_fp64(a[i], b[i]);
}
}
void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
vec2 v[4];
v[0] = mul_fp64(a[0], b[0]);
v[1] = mul_fp64(a[1], b[1]);
v[2] = mul_fp64(a[2], b[2]);
v[3] = mul_fp64(a[3], b[3]);
out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}
void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
vec2 tmp[4];
for (int i = 0; i < 4; i++)
{
for (int j = 0; j < 4; j++)
{
tmp[j] = b[j + i * 4];
}
vec4_dot_fp64(a, tmp, out_val[i]);
}
}
`;var oi={ONE:1};function ii(){return oi}var Ht={name:"fp64-arithmetic",vs:_n,getUniforms:ii,fp64ify:Qe,fp64LowPart:qt,fp64ifyMatrix4:Gt},pn={name:"fp64",vs:hn,dependencies:[Ht],fp64ify:Qe,fp64LowPart:qt,fp64ifyMatrix4:Gt};var si=`varying vec4 geometry_vPosition;
varying vec3 geometry_vNormal;
void geometry_setNormal(vec3 normal) {
geometry_vNormal = normal;
}
void geometry_setPosition(vec4 position) {
geometry_vPosition = position;
}
void geometry_setPosition(vec3 position) {
geometry_vPosition = vec4(position, 1.);
}
`,ai=`varying vec4 geometry_vPosition;
varying vec3 geometry_vNormal;
vec4 geometry_getPosition() {
return geometry_vPosition;
}
vec3 geometry_getNormal() {
return geometry_vNormal;
}
`,dn={name:"geometry",vs:si,fs:ai};var Ea=1/Math.PI*180,Ta=1/180*Math.PI,ci={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...ci}};var O=globalThis.mathgl.config;function mn(t,{precision:e=O.precision}={}){return t=li(t),`${parseFloat(t.toPrecision(e))}`}function Be(t){return Array.isArray(t)||ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Wt(t,e,r){let n=O.EPSILON;r&&(O.EPSILON=r);try{if(t===e)return!0;if(Be(t)&&Be(e)){if(t.length!==e.length)return!1;for(let o=0;o<t.length;++o)if(!Wt(t[o],e[o]))return!1;return!0}return t&&t.equals?t.equals(e):e&&e.equals?e.equals(t):typeof t=="number"&&typeof e=="number"?Math.abs(t-e)<=O.EPSILON*Math.max(1,Math.abs(t),Math.abs(e)):!1}finally{O.EPSILON=n}}function li(t){return Math.round(t/O.EPSILON)*O.EPSILON}var Ve=class extends Array{clone(){return new this.constructor().copy(this)}fromArray(e,r=0){for(let n=0;n<this.ELEMENTS;++n)this[n]=e[n+r];return this.check()}toArray(e=[],r=0){for(let n=0;n<this.ELEMENTS;++n)e[r+n]=this[n];return e}toObject(e){return e}from(e){return Array.isArray(e)?this.copy(e):this.fromObject(e)}to(e){return e===this?this:Be(e)?this.toArray(e):this.toObject(e)}toTarget(e){return e?this.to(e):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(O)}formatString(e){let r="";for(let n=0;n<this.ELEMENTS;++n)r+=(n>0?", ":"")+mn(this[n],e);return`${e.printTypes?this.constructor.name:""}[${r}]`}equals(e){if(!e||this.length!==e.length)return!1;for(let r=0;r<this.ELEMENTS;++r)if(!Wt(this[r],e[r]))return!1;return!0}exactEquals(e){if(!e||this.length!==e.length)return!1;for(let r=0;r<this.ELEMENTS;++r)if(this[r]!==e[r])return!1;return!0}negate(){for(let e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}lerp(e,r,n){if(n===void 0)return this.lerp(this,e,r);for(let o=0;o<this.ELEMENTS;++o){let i=e[o],a=typeof r=="number"?r:r[o];this[o]=i+n*(a-i)}return this.check()}min(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=Math.min(e[r],this[r]);return this.check()}max(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=Math.max(e[r],this[r]);return this.check()}clamp(e,r){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e[n]),r[n]);return this.check()}add(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]+=r[n];return this.check()}subtract(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]-=r[n];return this.check()}scale(e){if(typeof e=="number")for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;else for(let r=0;r<this.ELEMENTS&&r<e.length;++r)this[r]*=e[r];return this.check()}multiplyByScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;return this.check()}check(){if(O.debug&&!this.validate())throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);return this}validate(){let e=this.length===this.ELEMENTS;for(let r=0;r<this.ELEMENTS;++r)e=e&&Number.isFinite(this[r]);return e}sub(e){return this.subtract(e)}setScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=e;return this.check()}addScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]+=e;return this.check()}subScalar(e){return this.addScalar(-e)}multiplyScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;return this.check()}divideScalar(e){return this.multiplyByScalar(1/e)}clampScalar(e,r){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e),r);return this.check()}get elements(){return this}};function fi(t,e){if(t.length!==e)return!1;for(let r=0;r<t.length;++r)if(!Number.isFinite(t[r]))return!1;return!0}function gn(t){if(!Number.isFinite(t))throw new Error(`Invalid number ${JSON.stringify(t)}`);return t}function qe(t,e,r=""){if(O.debug&&!fi(t,e))throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);return t}var H=typeof Float32Array<"u"?Float32Array:Array;var Oa=Math.PI/180;function ui(){let t=new H(2);return H!=Float32Array&&(t[0]=0,t[1]=0),t}function An(t,e,r){let n=e[0],o=e[1];return t[0]=r[0]*n+r[4]*o+r[12],t[1]=r[1]*n+r[5]*o+r[13],t}var Ua=function(){let t=ui();return function(e,r,n,o,i,a){let f,u;for(r||(r=2),n||(n=0),o?u=Math.min(o*r+n,e.length):u=e.length,f=n;f<u;f+=r)t[0]=e[f],t[1]=e[f+1],i(t,t,a),e[f]=t[0],e[f+1]=t[1];return e}}();function bn(t,e,r){let n=e[0],o=e[1],i=r[3]*n+r[7]*o||1;return t[0]=(r[0]*n+r[4]*o)/i,t[1]=(r[1]*n+r[5]*o)/i,t}function yn(t,e,r){let n=e[0],o=e[1],i=e[2],a=r[3]*n+r[7]*o+r[11]*i||1;return t[0]=(r[0]*n+r[4]*o+r[8]*i)/a,t[1]=(r[1]*n+r[5]*o+r[9]*i)/a,t[2]=(r[2]*n+r[6]*o+r[10]*i)/a,t}function _i(){let t=new H(3);return H!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function Pn(t,e,r){let n=e[0],o=e[1],i=e[2],a=r[3]*n+r[7]*o+r[11]*i+r[15];return a=a||1,t[0]=(r[0]*n+r[4]*o+r[8]*i+r[12])/a,t[1]=(r[1]*n+r[5]*o+r[9]*i+r[13])/a,t[2]=(r[2]*n+r[6]*o+r[10]*i+r[14])/a,t}var Ya=function(){let t=_i();return function(e,r,n,o,i,a){let f,u;for(r||(r=3),n||(n=0),o?u=Math.min(o*r+n,e.length):u=e.length,f=n;f<u;f+=r)t[0]=e[f],t[1]=e[f+1],t[2]=e[f+2],i(t,t,a),e[f]=t[0],e[f+1]=t[1],e[f+2]=t[2];return e}}();var Ge=class extends Ve{toString(){let e="[";if(O.printRowMajor){e+="row-major:";for(let r=0;r<this.RANK;++r)for(let n=0;n<this.RANK;++n)e+=` ${this[n*this.RANK+r]}`}else{e+="column-major:";for(let r=0;r<this.ELEMENTS;++r)e+=` ${this[r]}`}return e+="]",e}getElementIndex(e,r){return r*this.RANK+e}getElement(e,r){return this[r*this.RANK+e]}setElement(e,r,n){return this[r*this.RANK+e]=gn(n),this}getColumn(e,r=new Array(this.RANK).fill(-0)){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)r[o]=this[n+o];return r}setColumn(e,r){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)this[n+o]=r[o];return this}};function hi(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function wn(t,e){if(t===e){let r=e[1],n=e[2],o=e[3],i=e[6],a=e[7],f=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=i,t[11]=e[14],t[12]=o,t[13]=a,t[14]=f}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function Ln(t,e){let r=e[0],n=e[1],o=e[2],i=e[3],a=e[4],f=e[5],u=e[6],h=e[7],p=e[8],d=e[9],m=e[10],x=e[11],w=e[12],g=e[13],A=e[14],L=e[15],v=r*f-n*a,y=r*u-o*a,P=r*h-i*a,b=n*u-o*f,S=n*h-i*f,k=o*h-i*u,F=p*g-d*w,M=p*A-m*w,N=p*L-x*w,I=d*A-m*g,U=d*L-x*g,R=m*L-x*A,E=v*R-y*U+P*I+b*N-S*M+k*F;return E?(E=1/E,t[0]=(f*R-u*U+h*I)*E,t[1]=(o*U-n*R-i*I)*E,t[2]=(g*k-A*S+L*b)*E,t[3]=(m*S-d*k-x*b)*E,t[4]=(u*N-a*R-h*M)*E,t[5]=(r*R-o*N+i*M)*E,t[6]=(A*P-w*k-L*y)*E,t[7]=(p*k-m*P+x*y)*E,t[8]=(a*U-f*N+h*F)*E,t[9]=(n*N-r*U-i*F)*E,t[10]=(w*S-g*P+L*v)*E,t[11]=(d*P-p*S-x*v)*E,t[12]=(f*M-a*I-u*F)*E,t[13]=(r*I-n*M+o*F)*E,t[14]=(g*y-w*b-A*v)*E,t[15]=(p*b-d*y+m*v)*E,t):null}function Sn(t){let e=t[0],r=t[1],n=t[2],o=t[3],i=t[4],a=t[5],f=t[6],u=t[7],h=t[8],p=t[9],d=t[10],m=t[11],x=t[12],w=t[13],g=t[14],A=t[15],L=e*a-r*i,v=e*f-n*i,y=r*f-n*a,P=h*w-p*x,b=h*g-d*x,S=p*g-d*w,k=e*S-r*b+n*P,F=i*S-a*b+f*P,M=h*y-p*v+d*L,N=x*y-w*v+g*L;return u*k-o*F+A*M-m*N}function $t(t,e,r){let n=e[0],o=e[1],i=e[2],a=e[3],f=e[4],u=e[5],h=e[6],p=e[7],d=e[8],m=e[9],x=e[10],w=e[11],g=e[12],A=e[13],L=e[14],v=e[15],y=r[0],P=r[1],b=r[2],S=r[3];return t[0]=y*n+P*f+b*d+S*g,t[1]=y*o+P*u+b*m+S*A,t[2]=y*i+P*h+b*x+S*L,t[3]=y*a+P*p+b*w+S*v,y=r[4],P=r[5],b=r[6],S=r[7],t[4]=y*n+P*f+b*d+S*g,t[5]=y*o+P*u+b*m+S*A,t[6]=y*i+P*h+b*x+S*L,t[7]=y*a+P*p+b*w+S*v,y=r[8],P=r[9],b=r[10],S=r[11],t[8]=y*n+P*f+b*d+S*g,t[9]=y*o+P*u+b*m+S*A,t[10]=y*i+P*h+b*x+S*L,t[11]=y*a+P*p+b*w+S*v,y=r[12],P=r[13],b=r[14],S=r[15],t[12]=y*n+P*f+b*d+S*g,t[13]=y*o+P*u+b*m+S*A,t[14]=y*i+P*h+b*x+S*L,t[15]=y*a+P*p+b*w+S*v,t}function kn(t,e,r){let n=r[0],o=r[1],i=r[2],a,f,u,h,p,d,m,x,w,g,A,L;return e===t?(t[12]=e[0]*n+e[4]*o+e[8]*i+e[12],t[13]=e[1]*n+e[5]*o+e[9]*i+e[13],t[14]=e[2]*n+e[6]*o+e[10]*i+e[14],t[15]=e[3]*n+e[7]*o+e[11]*i+e[15]):(a=e[0],f=e[1],u=e[2],h=e[3],p=e[4],d=e[5],m=e[6],x=e[7],w=e[8],g=e[9],A=e[10],L=e[11],t[0]=a,t[1]=f,t[2]=u,t[3]=h,t[4]=p,t[5]=d,t[6]=m,t[7]=x,t[8]=w,t[9]=g,t[10]=A,t[11]=L,t[12]=a*n+p*o+w*i+e[12],t[13]=f*n+d*o+g*i+e[13],t[14]=u*n+m*o+A*i+e[14],t[15]=h*n+x*o+L*i+e[15]),t}function Nn(t,e,r){let n=r[0],o=r[1],i=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*o,t[5]=e[5]*o,t[6]=e[6]*o,t[7]=e[7]*o,t[8]=e[8]*i,t[9]=e[9]*i,t[10]=e[10]*i,t[11]=e[11]*i,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function En(t,e,r,n){let o=n[0],i=n[1],a=n[2],f=Math.sqrt(o*o+i*i+a*a),u,h,p,d,m,x,w,g,A,L,v,y,P,b,S,k,F,M,N,I,U,R,E,fe;return f<1e-6?null:(f=1/f,o*=f,i*=f,a*=f,h=Math.sin(r),u=Math.cos(r),p=1-u,d=e[0],m=e[1],x=e[2],w=e[3],g=e[4],A=e[5],L=e[6],v=e[7],y=e[8],P=e[9],b=e[10],S=e[11],k=o*o*p+u,F=i*o*p+a*h,M=a*o*p-i*h,N=o*i*p-a*h,I=i*i*p+u,U=a*i*p+o*h,R=o*a*p+i*h,E=i*a*p-o*h,fe=a*a*p+u,t[0]=d*k+g*F+y*M,t[1]=m*k+A*F+P*M,t[2]=x*k+L*F+b*M,t[3]=w*k+v*F+S*M,t[4]=d*N+g*I+y*U,t[5]=m*N+A*I+P*U,t[6]=x*N+L*I+b*U,t[7]=w*N+v*I+S*U,t[8]=d*R+g*E+y*fe,t[9]=m*R+A*E+P*fe,t[10]=x*R+L*E+b*fe,t[11]=w*R+v*E+S*fe,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function Tn(t,e,r){let n=Math.sin(r),o=Math.cos(r),i=e[4],a=e[5],f=e[6],u=e[7],h=e[8],p=e[9],d=e[10],m=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=i*o+h*n,t[5]=a*o+p*n,t[6]=f*o+d*n,t[7]=u*o+m*n,t[8]=h*o-i*n,t[9]=p*o-a*n,t[10]=d*o-f*n,t[11]=m*o-u*n,t}function Mn(t,e,r){let n=Math.sin(r),o=Math.cos(r),i=e[0],a=e[1],f=e[2],u=e[3],h=e[8],p=e[9],d=e[10],m=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*o-h*n,t[1]=a*o-p*n,t[2]=f*o-d*n,t[3]=u*o-m*n,t[8]=i*n+h*o,t[9]=a*n+p*o,t[10]=f*n+d*o,t[11]=u*n+m*o,t}function Fn(t,e,r){let n=Math.sin(r),o=Math.cos(r),i=e[0],a=e[1],f=e[2],u=e[3],h=e[4],p=e[5],d=e[6],m=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*o+h*n,t[1]=a*o+p*n,t[2]=f*o+d*n,t[3]=u*o+m*n,t[4]=h*o-i*n,t[5]=p*o-a*n,t[6]=d*o-f*n,t[7]=m*o-u*n,t}function In(t,e){let r=e[0],n=e[1],o=e[2],i=e[3],a=r+r,f=n+n,u=o+o,h=r*a,p=n*a,d=n*f,m=o*a,x=o*f,w=o*u,g=i*a,A=i*f,L=i*u;return t[0]=1-d-w,t[1]=p+L,t[2]=m-A,t[3]=0,t[4]=p-L,t[5]=1-h-w,t[6]=x+g,t[7]=0,t[8]=m+A,t[9]=x-g,t[10]=1-h-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function Cn(t,e,r,n,o,i,a){let f=1/(r-e),u=1/(o-n),h=1/(i-a);return t[0]=i*2*f,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i*2*u,t[6]=0,t[7]=0,t[8]=(r+e)*f,t[9]=(o+n)*u,t[10]=(a+i)*h,t[11]=-1,t[12]=0,t[13]=0,t[14]=a*i*2*h,t[15]=0,t}function pi(t,e,r,n,o){let i=1/Math.tan(e/2);if(t[0]=i/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,o!=null&&o!==1/0){let a=1/(n-o);t[10]=(o+n)*a,t[14]=2*o*n*a}else t[10]=-1,t[14]=-2*n;return t}var Rn=pi;function di(t,e,r,n,o,i,a){let f=1/(e-r),u=1/(n-o),h=1/(i-a);return t[0]=-2*f,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*h,t[11]=0,t[12]=(e+r)*f,t[13]=(o+n)*u,t[14]=(a+i)*h,t[15]=1,t}var On=di;function Un(t,e,r,n){let o,i,a,f,u,h,p,d,m,x,w=e[0],g=e[1],A=e[2],L=n[0],v=n[1],y=n[2],P=r[0],b=r[1],S=r[2];return Math.abs(w-P)<1e-6&&Math.abs(g-b)<1e-6&&Math.abs(A-S)<1e-6?hi(t):(d=w-P,m=g-b,x=A-S,o=1/Math.sqrt(d*d+m*m+x*x),d*=o,m*=o,x*=o,i=v*x-y*m,a=y*d-L*x,f=L*m-v*d,o=Math.sqrt(i*i+a*a+f*f),o?(o=1/o,i*=o,a*=o,f*=o):(i=0,a=0,f=0),u=m*f-x*a,h=x*i-d*f,p=d*a-m*i,o=Math.sqrt(u*u+h*h+p*p),o?(o=1/o,u*=o,h*=o,p*=o):(u=0,h=0,p=0),t[0]=i,t[1]=u,t[2]=d,t[3]=0,t[4]=a,t[5]=h,t[6]=m,t[7]=0,t[8]=f,t[9]=p,t[10]=x,t[11]=0,t[12]=-(i*w+a*g+f*A),t[13]=-(u*w+h*g+p*A),t[14]=-(d*w+m*g+x*A),t[15]=1,t)}function mi(){let t=new H(4);return H!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function zn(t,e,r){let n=e[0],o=e[1],i=e[2],a=e[3];return t[0]=r[0]*n+r[4]*o+r[8]*i+r[12]*a,t[1]=r[1]*n+r[5]*o+r[9]*i+r[13]*a,t[2]=r[2]*n+r[6]*o+r[10]*i+r[14]*a,t[3]=r[3]*n+r[7]*o+r[11]*i+r[15]*a,t}var Ha=function(){let t=mi();return function(e,r,n,o,i,a){let f,u;for(r||(r=4),n||(n=0),o?u=Math.min(o*r+n,e.length):u=e.length,f=n;f<u;f+=r)t[0]=e[f],t[1]=e[f+1],t[2]=e[f+2],t[3]=e[f+3],i(t,t,a),e[f]=t[0],e[f+1]=t[1],e[f+2]=t[2],e[f+3]=t[3];return e}}();var Jt;(function(t){t[t.COL0ROW0=0]="COL0ROW0",t[t.COL0ROW1=1]="COL0ROW1",t[t.COL0ROW2=2]="COL0ROW2",t[t.COL0ROW3=3]="COL0ROW3",t[t.COL1ROW0=4]="COL1ROW0",t[t.COL1ROW1=5]="COL1ROW1",t[t.COL1ROW2=6]="COL1ROW2",t[t.COL1ROW3=7]="COL1ROW3",t[t.COL2ROW0=8]="COL2ROW0",t[t.COL2ROW1=9]="COL2ROW1",t[t.COL2ROW2=10]="COL2ROW2",t[t.COL2ROW3=11]="COL2ROW3",t[t.COL3ROW0=12]="COL3ROW0",t[t.COL3ROW1=13]="COL3ROW1",t[t.COL3ROW2=14]="COL3ROW2",t[t.COL3ROW3=15]="COL3ROW3"})(Jt||(Jt={}));var gi=45*Math.PI/180,xi=1,Kt=.1,Zt=500,vi=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),ee=class extends Ge{static get IDENTITY(){return bi()}static get ZERO(){return Ai()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return Jt}constructor(e){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):this.identity()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this[9]=e[9],this[10]=e[10],this[11]=e[11],this[12]=e[12],this[13]=e[13],this[14]=e[14],this[15]=e[15],this.check()}set(e,r,n,o,i,a,f,u,h,p,d,m,x,w,g,A){return this[0]=e,this[1]=r,this[2]=n,this[3]=o,this[4]=i,this[5]=a,this[6]=f,this[7]=u,this[8]=h,this[9]=p,this[10]=d,this[11]=m,this[12]=x,this[13]=w,this[14]=g,this[15]=A,this.check()}setRowMajor(e,r,n,o,i,a,f,u,h,p,d,m,x,w,g,A){return this[0]=e,this[1]=i,this[2]=h,this[3]=x,this[4]=r,this[5]=a,this[6]=p,this[7]=w,this[8]=n,this[9]=f,this[10]=d,this[11]=g,this[12]=o,this[13]=u,this[14]=m,this[15]=A,this.check()}toRowMajor(e){return e[0]=this[0],e[1]=this[4],e[2]=this[8],e[3]=this[12],e[4]=this[1],e[5]=this[5],e[6]=this[9],e[7]=this[13],e[8]=this[2],e[9]=this[6],e[10]=this[10],e[11]=this[14],e[12]=this[3],e[13]=this[7],e[14]=this[11],e[15]=this[15],e}identity(){return this.copy(vi)}fromObject(e){return this.check()}fromQuaternion(e){return In(this,e),this.check()}frustum(e){let{left:r,right:n,bottom:o,top:i,near:a=Kt,far:f=Zt}=e;return f===1/0?yi(this,r,n,o,i,a):Cn(this,r,n,o,i,a,f),this.check()}lookAt(e){let{eye:r,center:n=[0,0,0],up:o=[0,1,0]}=e;return Un(this,r,n,o),this.check()}ortho(e){let{left:r,right:n,bottom:o,top:i,near:a=Kt,far:f=Zt}=e;return On(this,r,n,o,i,a,f),this.check()}orthographic(e){let{fovy:r=gi,aspect:n=xi,focalDistance:o=1,near:i=Kt,far:a=Zt}=e;Dn(r);let f=r/2,u=o*Math.tan(f),h=u*n;return this.ortho({left:-h,right:h,bottom:-u,top:u,near:i,far:a})}perspective(e){let{fovy:r=45*Math.PI/180,aspect:n=1,near:o=.1,far:i=500}=e;return Dn(r),Rn(this,r,n,o,i),this.check()}determinant(){return Sn(this)}getScale(e=[-0,-0,-0]){return e[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),e[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),e[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),e}getTranslation(e=[-0,-0,-0]){return e[0]=this[12],e[1]=this[13],e[2]=this[14],e}getRotation(e,r){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],r=r||[-0,-0,-0];let n=this.getScale(r),o=1/n[0],i=1/n[1],a=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*i,e[2]=this[2]*a,e[3]=0,e[4]=this[4]*o,e[5]=this[5]*i,e[6]=this[6]*a,e[7]=0,e[8]=this[8]*o,e[9]=this[9]*i,e[10]=this[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}getRotationMatrix3(e,r){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0],r=r||[-0,-0,-0];let n=this.getScale(r),o=1/n[0],i=1/n[1],a=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*i,e[2]=this[2]*a,e[3]=this[4]*o,e[4]=this[5]*i,e[5]=this[6]*a,e[6]=this[8]*o,e[7]=this[9]*i,e[8]=this[10]*a,e}transpose(){return wn(this,this),this.check()}invert(){return Ln(this,this),this.check()}multiplyLeft(e){return $t(this,e,this),this.check()}multiplyRight(e){return $t(this,this,e),this.check()}rotateX(e){return Tn(this,this,e),this.check()}rotateY(e){return Mn(this,this,e),this.check()}rotateZ(e){return Fn(this,this,e),this.check()}rotateXYZ(e){return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])}rotateAxis(e,r){return En(this,this,e,r),this.check()}scale(e){return Nn(this,this,Array.isArray(e)?e:[e,e,e]),this.check()}translate(e){return kn(this,this,e),this.check()}transform(e,r){return e.length===4?(r=zn(r||[-0,-0,-0,-0],e,this),qe(r,4),r):this.transformAsPoint(e,r)}transformAsPoint(e,r){let{length:n}=e,o;switch(n){case 2:o=An(r||[-0,-0],e,this);break;case 3:o=Pn(r||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return qe(o,e.length),o}transformAsVector(e,r){let n;switch(e.length){case 2:n=bn(r||[-0,-0],e,this);break;case 3:n=yn(r||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return qe(n,e.length),n}transformPoint(e,r){return this.transformAsPoint(e,r)}transformVector(e,r){return this.transformAsPoint(e,r)}transformDirection(e,r){return this.transformAsVector(e,r)}makeRotationX(e){return this.identity().rotateX(e)}makeTranslation(e,r,n){return this.identity().translate([e,r,n])}},He,We;function Ai(){return He||(He=new ee([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(He)),He}function bi(){return We||(We=new ee,Object.freeze(We)),We}function Dn(t){if(t>Math.PI*2)throw Error("expected radians")}function yi(t,e,r,n,o,i){let a=2*i/(r-e),f=2*i/(o-n),u=(r+e)/(r-e),h=(o+n)/(o-n),p=-1,d=-1,m=-2*i;return t[0]=a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=f,t[6]=0,t[7]=0,t[8]=u,t[9]=h,t[10]=p,t[11]=d,t[12]=0,t[13]=0,t[14]=m,t[15]=0,t}var er=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],Pi={modelMatrix:er,viewMatrix:er,projectionMatrix:er,cameraPositionWorld:[0,0,0]};function wi(t=Pi,e={}){let r={};return t.modelMatrix!==void 0&&(r.modelMatrix=t.modelMatrix),t.viewMatrix!==void 0&&(r.viewMatrix=t.viewMatrix),t.projectionMatrix!==void 0&&(r.projectionMatrix=t.projectionMatrix),t.cameraPositionWorld!==void 0&&(r.cameraPositionWorld=t.cameraPositionWorld),(t.projectionMatrix!==void 0||t.viewMatrix!==void 0)&&(r.viewProjectionMatrix=new ee(t.projectionMatrix).multiplyRight(t.viewMatrix)),r}var Yn=`varying vec4 project_vPositionWorld;
varying vec3 project_vNormalWorld;
vec4 project_getPosition_World() {
return project_vPositionWorld;
}
vec3 project_getNormal_World() {
return project_vNormalWorld;
}
`,Li=`${Yn}

// Unprefixed uniforms
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewProjectionMatrix;
uniform vec3 cameraPositionWorld;

struct World {
  vec3 position;
  vec3 normal;
};

World world;

void project_setPosition(vec4 position) {
  project_vPositionWorld = position;
}

void project_setNormal(vec3 normal) {
  project_vNormalWorld = normal;
}

void project_setPositionAndNormal_World(vec3 position, vec3 normal) {
  world.position = position;
  world.normal = normal;
}

void project_setPositionAndNormal_Model(vec3 position, vec3 normal) {
  world.position = (modelMatrix * vec4(position, 1.)).xyz;
  world.normal = mat3(modelMatrix) * normal;
}

vec4 project_model_to_clipspace(vec4 position) {
  return viewProjectionMatrix * modelMatrix * position;
}

vec4 project_model_to_clipspace(vec3 position) {
  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);
}

vec4 project_world_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}

vec4 project_view_to_clipspace(vec3 position) {
  return projectionMatrix * vec4(position, 1.);
}

vec4 project_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}
`,Si=`
${Yn}`,je={name:"project",getUniforms:wi,vs:Li,fs:Si};var tr=`#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
vec3 color;
};
struct PointLight {
vec3 color;
vec3 position;
vec3 attenuation;
};
struct DirectionalLight {
vec3 color;
vec3 direction;
};
uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;
uniform bool lighting_uEnabled;
float getPointLightAttenuation(PointLight pointLight, float distance) {
return pointLight.attenuation.x
+ pointLight.attenuation.y * distance
+ pointLight.attenuation.z * distance * distance;
}
#endif
`;var ki={lightSources:{}};function rr(t={}){let{color:e=[0,0,0],intensity:r=1}=t;return e.map(n=>n*r/255)}function Ni({ambientLight:t,pointLights:e=[],directionalLights:r=[]}){let n={};return t?n["lighting_uAmbientLight.color"]=rr(t):n["lighting_uAmbientLight.color"]=[0,0,0],e.forEach((o,i)=>{n[`lighting_uPointLight[${i}].color`]=rr(o),n[`lighting_uPointLight[${i}].position`]=o.position,n[`lighting_uPointLight[${i}].attenuation`]=o.attenuation||[1,0,0]}),n.lighting_uPointLightCount=e.length,r.forEach((o,i)=>{n[`lighting_uDirectionalLight[${i}].color`]=rr(o),n[`lighting_uDirectionalLight[${i}].direction`]=o.direction}),n.lighting_uDirectionalLightCount=r.length,n}function Xn(t=ki){if("lightSources"in t){let{ambientLight:e,pointLights:r,directionalLights:n}=t.lightSources||{};return e||r&&r.length>0||n&&n.length>0?Object.assign({},Ni({ambientLight:e,pointLights:r,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in t){let e={pointLights:[],directionalLights:[]};for(let r of t.lights||[])switch(r.type){case"ambient":e.ambientLight=r;break;case"directional":e.directionalLights?.push(r);break;case"point":e.pointLights?.push(r);break;default:}return Xn({lightSources:e})}return{}}var te={name:"lights",vs:tr,fs:tr,getUniforms:Xn,defines:{MAX_LIGHTS:3}};var Ei={lightDirection:new Float32Array([1,1,2])};function Ti(t=Ei){let e={};return t.lightDirection&&(e.dirlight_uLightDirection=t.lightDirection),e}var Mi=`uniform vec3 dirlight_uLightDirection;
vec4 dirlight_filterColor(vec4 color) {
vec3 normal = project_getNormal_World();
float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));
return vec4(color.rgb * d, color.a);
}
`,Qn={name:"dirlight",fs:Mi,getUniforms:Ti,dependencies:[je]};var nr=`uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
vec3 halfway_direction = normalize(light_direction + view_direction);
float lambertian = dot(light_direction, normal_worldspace);
float specular = 0.0;
if (lambertian > 0.0) {
float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
specular = pow(specular_angle, lighting_uShininess);
}
lambertian = max(lambertian, 0.0);
return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}
vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = surfaceColor;
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
vec3 lightColor = vec3(0, 0, 0);
vec3 surfaceColor = vec3(0, 0, 0);
if (lighting_uEnabled) {
vec3 view_direction = normalize(cameraPosition - position_worldspace);
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uPointLightCount) {
break;
}
PointLight pointLight = lighting_uPointLight[i];
vec3 light_position_worldspace = pointLight.position;
vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
}
for (int i = 0; i < MAX_LIGHTS; i++) {
if (i >= lighting_uDirectionalLightCount) {
break;
}
DirectionalLight directionalLight = lighting_uDirectionalLight[i];
lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
}
}
return lightColor;
}
`;var Fi={};function Ii(t){let{ambient:e=.35,diffuse:r=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:e,lighting_uDiffuse:r,lighting_uShininess:n,lighting_uSpecularColor:o.map(i=>i/255)}}function Bn(t=Fi){if(!("material"in t))return{};let{material:e}=t;return e?Ii(e):{lighting_uEnabled:!1}}var Vn={name:"gouraud-lighting",dependencies:[te],vs:nr,defines:{LIGHTING_VERTEX:1},getUniforms:Bn},qn={name:"phong-lighting",dependencies:[te],fs:nr,defines:{LIGHTING_FRAGMENT:1},getUniforms:Bn};var Gn=`uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
out vec3 pbr_vPosition;
out vec2 pbr_vUV;
#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif
void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
vec4 pos = u_ModelMatrix * position;
pbr_vPosition = vec3(pos.xyz) / pos.w;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0.,0.);
#endif
}
`;var Hn=`precision highp float;
uniform bool pbr_uUnlit;
#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif
#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif
#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif
uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;
uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif
in vec3 pbr_vPosition;
in vec2 pbr_vUV;
#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif
struct PBRInfo
{
float NdotL;
float NdotV;
float NdotH;
float LdotH;
float VdotH;
float perceptualRoughness;
float metalness;
vec3 reflectance0;
vec3 reflectance90;
float alphaRoughness;
vec3 diffuseColor;
vec3 specularColor;
vec3 n;
vec3 v;
};
const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
return vec4(linOut,srgbIn.w);;
#else
return srgbIn;
#endif
}
vec3 getNormal()
{
#ifndef HAS_TANGENTS
vec3 pos_dx = dFdx(pbr_vPosition);
vec3 pos_dy = dFdy(pbr_vPosition);
vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);
#ifdef HAS_NORMALS
vec3 ng = normalize(pbr_vNormal);
#else
vec3 ng = cross(pos_dx, pos_dy);
#endif
t = normalize(t - ng * dot(ng, t));
vec3 b = normalize(cross(ng, t));
mat3 tbn = mat3(t, b, ng);
#else
mat3 tbn = pbr_vTBN;
#endif
#ifdef HAS_NORMALMAP
vec3 n = texture(u_NormalSampler, pbr_vUV).rgb;
n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
vec3 n = normalize(tbn[2].xyz);
#endif
return n;
}
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
float mipCount = 9.0;
float lod = (pbrInputs.perceptualRoughness * mipCount);
vec3 brdf = SRGBtoLINEAR(texture(u_brdfLUT,
vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;
#ifdef USE_TEX_LOD
vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif
vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
diffuse *= u_ScaleIBLAmbient.x;
specular *= u_ScaleIBLAmbient.y;
return diffuse + specular;
}
#endif
vec3 diffuse(PBRInfo pbrInputs)
{
return pbrInputs.diffuseColor / M_PI;
}
vec3 specularReflection(PBRInfo pbrInputs)
{
return pbrInputs.reflectance0 +
(pbrInputs.reflectance90 - pbrInputs.reflectance0) *
pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}
float geometricOcclusion(PBRInfo pbrInputs)
{
float NdotL = pbrInputs.NdotL;
float NdotV = pbrInputs.NdotV;
float r = pbrInputs.alphaRoughness;
float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
return attenuationL * attenuationV;
}
float microfacetDistribution(PBRInfo pbrInputs)
{
float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
return roughnessSq / (M_PI * f * f);
}
void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
pbrInputs.NdotL = 1.0;
pbrInputs.NdotH = 0.0;
pbrInputs.LdotH = 0.0;
pbrInputs.VdotH = 1.0;
}
void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
vec3 n = pbrInputs.n;
vec3 v = pbrInputs.v;
vec3 l = normalize(lightDirection);
vec3 h = normalize(l+v);
pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}
void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}
vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
vec3 F = specularReflection(pbrInputs);
float G = geometricOcclusion(pbrInputs);
float D = microfacetDistribution(pbrInputs);
vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}
vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
vec4 baseColor = SRGBtoLINEAR(texture(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
vec4 baseColor = u_BaseColorFactor;
#endif
#ifdef ALPHA_CUTOFF
if (baseColor.a < u_AlphaCutoff) {
discard;
}
#endif
vec3 color = vec3(0, 0, 0);
if(pbr_uUnlit){
color.rgb = baseColor.rgb;
}
else{
float perceptualRoughness = u_MetallicRoughnessValues.y;
float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
vec4 mrSample = texture(u_MetallicRoughnessSampler, pbr_vUV);
perceptualRoughness = mrSample.g * perceptualRoughness;
metallic = mrSample.b * metallic;
#endif
perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
metallic = clamp(metallic, 0.0, 1.0);
float alphaRoughness = perceptualRoughness * perceptualRoughness;
vec3 f0 = vec3(0.04);
vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
diffuseColor *= 1.0 - metallic;
vec3 specularColor = mix(f0, baseColor.rgb, metallic);
float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);
float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
vec3 specularEnvironmentR0 = specularColor.rgb;
vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;
vec3 n = getNormal();
vec3 v = normalize(u_Camera - pbr_vPosition);
float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
vec3 reflection = -normalize(reflect(v, n));
PBRInfo pbrInputs = PBRInfo(
0.0,
NdotV,
0.0,
0.0,
0.0,
perceptualRoughness,
metallic,
specularEnvironmentR0,
specularEnvironmentR90,
alphaRoughness,
diffuseColor,
specularColor,
n,
v
);
#ifdef USE_LIGHTS
PBRInfo_setAmbientLight(pbrInputs);
color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
for(int i = 0; i < lighting_uDirectionalLightCount; i++) {
if (i < lighting_uDirectionalLightCount) {
PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
}
}
for(int i = 0; i < lighting_uPointLightCount; i++) {
if (i < lighting_uPointLightCount) {
PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
}
}
#endif
#ifdef USE_IBL
color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
float ao = texture(u_OcclusionSampler, pbr_vUV).r;
color = mix(color, color * ao, u_OcclusionStrength);
#endif
#ifdef HAS_EMISSIVEMAP
vec3 emissive = SRGBtoLINEAR(texture(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
color += emissive;
#endif
#ifdef PBR_DEBUG
color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif
}
return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;var Wn={name:"pbr",vs:Gn,fs:Hn,defines:{LIGHTING_FRAGMENT:1},dependencies:[te]};return no(xe);})();
/**
 * ORIGINAL LICENCE
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
      return __exports__;
      });
