/**
 * @class Alias
 * @extends Statement
 * @category AST
 */
export class Alias extends Statement {
    constructor(name: any, type: any);
    name: any;
    type: any;
}
export class AliasInfo {
    constructor(name: any, type: any);
    name: any;
    type: any;
}
/**
 * @class Argument
 * @extends Node
 * @category AST
 */
export class Argument extends Node {
    constructor(name: any, type: any, attributes: any);
    name: any;
    type: any;
    attributes: any;
}
export class ArrayInfo extends TypeInfo {
    count: number;
    stride: number;
}
/**
 * @class ArrayType
 * @extends Type
 * @category AST
 */
export class ArrayType extends Type {
    constructor(name: any, attributes: any, format: any, count: any);
    attributes: any;
    format: any;
    count: any;
}
/**
 * @class Assign
 * @extends Statement
 * @category AST
 */
export class Assign extends Statement {
    constructor(operator: any, variable: any, value: any);
    operator: any;
    variable: any;
    value: any;
}
export var AssignOperator: any;
/**
 * @class Attribute
 * @extends Node
 * @category AST
 */
export class Attribute extends Node {
    constructor(name: any, value: any);
    name: any;
    value: any;
}
/**
 * @class BinaryOperator
 * @extends Operator
 * @category AST
 * @property {string} operator +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||
 */
export class BinaryOperator extends Operator {
    constructor(operator: any, left: any, right: any);
    operator: any;
    left: any;
    right: any;
    evaluate(context: any): any;
}
/**
 * @class BitcastExpr
 * @extends Expression
 * @category AST
 */
export class BitcastExpr extends Expression {
    constructor(type: any, value: any);
    type: any;
    value: any;
}
/**
 * @class Break
 * @extends Statement
 * @category AST
 */
export class Break extends Statement {
}
/**
 * @class Call
 * @extends Statement
 * @category AST
 */
export class Call extends Statement {
    constructor(name: any, args: any);
    name: any;
    args: any;
}
/**
 * @class CallExpr
 * @extends Expression
 * @category AST
 */
export class CallExpr extends Expression {
    constructor(name: any, args: any);
    name: any;
    args: any;
    evaluate(context: any): any;
}
/**
 * @class Case
 * @extends SwitchCase
 * @category AST
 */
export class Case extends SwitchCase {
    constructor(selector: any, body: any);
    selector: any;
    body: any;
}
/**
 * @class Const
 * @extends Statement
 * @category AST
 */
export class Const extends Statement {
    constructor(name: any, type: any, storage: any, access: any, value: any);
    name: any;
    type: any;
    storage: any;
    access: any;
    value: any;
    evaluate(context: any): any;
}
/**
 * @class ConstExpr
 * @extends Expression
 * @category AST
 */
export class ConstExpr extends Expression {
    constructor(name: any, initializer: any);
    name: any;
    initializer: any;
    evaluate(context: any): any;
}
/**
 * @class Continue
 * @extends Statement
 * @category AST
 */
export class Continue extends Statement {
}
/**
 * @class Continuing
 * @extends Statement
 * @category AST
 */
export class Continuing extends Statement {
    constructor(body: any);
    body: any;
}
/**
 * @class CreateExpr
 * @extends Expression
 * @category AST
 */
export class CreateExpr extends Expression {
    constructor(type: any, args: any);
    type: any;
    args: any;
}
/**
 * @class Default
 * @extends SwitchCase
 * @category AST
 */
export class Default extends SwitchCase {
    constructor(body: any);
    body: any;
}
/**
 * @class Discard
 * @extends Statement
 * @category AST
 */
export class Discard extends Statement {
}
/**
 * @class ElseIf
 * @extends Node
 * @category AST
 */
export class ElseIf extends Node {
    constructor(condition: any, body: any);
    condition: any;
    body: any;
}
/**
 * @class Enable
 * @extends Statement
 * @category AST
 */
export class Enable extends Statement {
    constructor(name: any);
    name: any;
}
export class EntryFunctions {
    vertex: any[];
    fragment: any[];
    compute: any[];
}
/**
 * @class Expression
 * @extends Node
 * @category AST
 */
export class Expression extends Node {
}
/**
 * @class For
 * @extends Statement
 * @category AST
 */
export class For extends Statement {
    constructor(init: any, condition: any, increment: any, body: any);
    init: any;
    condition: any;
    increment: any;
    body: any;
}
/**
 * @class Function
 * @extends Statement
 * @category AST
 */
export class Function extends Statement {
    constructor(name: any, args: any, returnType: any, body: any);
    name: any;
    args: any;
    returnType: any;
    body: any;
}
export class FunctionInfo {
    constructor(name: any, stage?: any);
    stage: any;
    inputs: any[];
    outputs: any[];
    name: any;
}
/**
 * @class GroupingExpr
 * @extends Expression
 * @category AST
 */
export class GroupingExpr extends Expression {
    constructor(contents: any);
    contents: any;
    evaluate(context: any): any;
}
/**
 * @class If
 * @extends Statement
 * @category AST
 */
export class If extends Statement {
    constructor(condition: any, body: any, elseif: any, _else: any);
    condition: any;
    body: any;
    elseif: any;
    else: any;
}
/**
 * @class Increment
 * @extends Statement
 * @category AST
 */
export class Increment extends Statement {
    constructor(operator: any, variable: any);
    operator: any;
    variable: any;
}
export var IncrementOperator: any;
export class InputInfo {
    constructor(name: any, type: any, locationType: any, location: any);
    name: any;
    type: any;
    locationType: any;
    location: any;
    interpolation: any;
}
/**
 * @class Let
 * @extends Statement
 * @category AST
 */
export class Let extends Statement {
    constructor(name: any, type: any, storage: any, access: any, value: any);
    name: any;
    type: any;
    storage: any;
    access: any;
    value: any;
}
/**
 * @class LiteralExpr
 * @extends Expression
 * @category AST
 */
export class LiteralExpr extends Expression {
    constructor(value: any);
    value: any;
    evaluate(): any;
}
/**
 * @class Loop
 * @extends Statement
 * @category AST
 */
export class Loop extends Statement {
    constructor(body: any, continuing: any);
    body: any;
    continuing: any;
}
/**
 * @class Member
 * @extends Node
 * @category AST
 */
export class Member extends Node {
    constructor(name: any, type: any, attributes: any);
    name: any;
    type: any;
    attributes: any;
}
export class MemberInfo {
    constructor(name: any, type: any, attributes: any);
    name: any;
    type: any;
    attributes: any;
    offset: number;
    size: number;
    get isArray(): any;
    get isStruct(): any;
    get isTemplate(): any;
    get align(): any;
    get members(): any;
    get format(): any;
    get count(): any;
    get stride(): any;
}
/**
 * @class Node
 * @category AST
 * Base class for AST nodes parsed from a WGSL shader.
 */
export class Node {
    get isAstNode(): boolean;
    get astNodeType(): string;
    evaluate(context: any): void;
    evaluateString(context: any): any;
}
/**
 * @class Operator
 * @extends Expression
 * @category AST
 */
export class Operator extends Expression {
}
export class OutputInfo {
    constructor(name: any, type: any, locationType: any, location: any);
    name: any;
    type: any;
    locationType: any;
    location: any;
}
/**
 * @class Override
 * @extends Statement
 * @category AST
 */
export class Override extends Statement {
    constructor(name: any, type: any, value: any);
    name: any;
    type: any;
    value: any;
}
export class OverrideInfo {
    constructor(name: any, type: any, attributes: any, id: any);
    name: any;
    type: any;
    attributes: any;
    id: any;
}
export class ParseContext {
    constants: Map<any, any>;
    aliases: Map<any, any>;
    structs: Map<any, any>;
}
/**
 * @class PointerType
 * @extends Type
 * @category AST
 */
export class PointerType extends Type {
    constructor(name: any, storage: any, type: any, access: any);
    storage: any;
    type: any;
    access: any;
}
export var ResourceType: any;
/**
 * @class Return
 * @extends Statement
 * @category AST
 */
export class Return extends Statement {
    constructor(value: any);
    value: any;
}
/**
 * @class SamplerType
 * @extends Type
 * @category AST
 */
export class SamplerType extends Type {
    constructor(name: any, format: any, access: any);
    format: any;
    access: any;
}
/**
 * @class Statement
 * @extends Node
 * @category AST
 */
export class Statement extends Node {
}
/**
 * @class StaticAssert
 * @extends Statement
 * @category AST
 */
export class StaticAssert extends Statement {
    constructor(expression: any);
    expression: any;
}
/**
 * @class StringExpr
 * @extends Expression
 * @category AST
 */
export class StringExpr extends Expression {
    constructor(value: any);
    value: any;
    toString(): any;
    evaluateString(): any;
}
/**
 * @class StructType
 * @extends Type
 * @category AST
 */
export class Struct extends Type {
    constructor(name: any, members: any);
    members: any;
    getMemberIndex(name: any): number;
}
export class StructInfo extends TypeInfo {
    members: any[];
    align: number;
}
/**
 * @class Switch
 * @extends Statement
 * @category AST
 */
export class Switch extends Statement {
    constructor(condition: any, body: any);
    condition: any;
    body: any;
}
/**
 * @class SwitchCase
 * @extends Node
 * @category AST
 */
export class SwitchCase extends Node {
}
export class TemplateInfo extends TypeInfo {
    constructor(name: any, format: any, attributes: any, access: any);
    format: any;
    access: any;
}
/**
 * @class TemplateType
 * @extends Type
 * @category AST
 */
export class TemplateType extends Type {
    constructor(name: any, format: any, access: any);
    format: any;
    access: any;
}
export class Token {
    constructor(type: any, lexeme: any, line: any);
    type: any;
    lexeme: any;
    line: any;
    toString(): any;
    isTemplateType(): boolean;
    isArrayType(): boolean;
    isArrayOrTemplateType(): boolean;
}
export var TokenClass: any;
export class TokenType {
    constructor(name: any, type: any, rule: any);
    name: any;
    type: any;
    rule: any;
    toString(): any;
}
export class TokenTypes {
}
export namespace TokenTypes {
    let none: TokenType;
    let eof: TokenType;
    namespace reserved {
        export let asm: TokenType;
        export let bf16: TokenType;
        let _do: TokenType;
        export { _do as do };
        let _enum: TokenType;
        export { _enum as enum };
        export let f16: TokenType;
        export let f64: TokenType;
        export let handle: TokenType;
        export let i8: TokenType;
        export let i16: TokenType;
        export let i64: TokenType;
        export let mat: TokenType;
        export let premerge: TokenType;
        export let regardless: TokenType;
        export let typedef: TokenType;
        export let u8: TokenType;
        export let u16: TokenType;
        export let u64: TokenType;
        export let unless: TokenType;
        export let using: TokenType;
        export let vec: TokenType;
        let _void: TokenType;
        export { _void as void };
    }
    namespace keywords {
        export let array: TokenType;
        export let atomic: TokenType;
        export let bool: TokenType;
        export let f32: TokenType;
        export let i32: TokenType;
        export let mat2x2: TokenType;
        export let mat2x3: TokenType;
        export let mat2x4: TokenType;
        export let mat3x2: TokenType;
        export let mat3x3: TokenType;
        export let mat3x4: TokenType;
        export let mat4x2: TokenType;
        export let mat4x3: TokenType;
        export let mat4x4: TokenType;
        export let ptr: TokenType;
        export let sampler: TokenType;
        export let sampler_comparison: TokenType;
        export let struct: TokenType;
        export let texture_1d: TokenType;
        export let texture_2d: TokenType;
        export let texture_2d_array: TokenType;
        export let texture_3d: TokenType;
        export let texture_cube: TokenType;
        export let texture_cube_array: TokenType;
        export let texture_multisampled_2d: TokenType;
        export let texture_storage_1d: TokenType;
        export let texture_storage_2d: TokenType;
        export let texture_storage_2d_array: TokenType;
        export let texture_storage_3d: TokenType;
        export let texture_depth_2d: TokenType;
        export let texture_depth_2d_array: TokenType;
        export let texture_depth_cube: TokenType;
        export let texture_depth_cube_array: TokenType;
        export let texture_depth_multisampled_2d: TokenType;
        export let texture_external: TokenType;
        export let u32: TokenType;
        export let vec2: TokenType;
        export let vec3: TokenType;
        export let vec4: TokenType;
        export let bitcast: TokenType;
        export let block: TokenType;
        let _break: TokenType;
        export { _break as break };
        let _case: TokenType;
        export { _case as case };
        let _continue: TokenType;
        export { _continue as continue };
        export let continuing: TokenType;
        let _default: TokenType;
        export { _default as default };
        export let discard: TokenType;
        let _else: TokenType;
        export { _else as else };
        export let enable: TokenType;
        export let fallthrough: TokenType;
        let _false: TokenType;
        export { _false as false };
        export let fn: TokenType;
        let _for: TokenType;
        export { _for as for };
        let _function: TokenType;
        export { _function as function };
        let _if: TokenType;
        export { _if as if };
        let _let: TokenType;
        export { _let as let };
        let _const: TokenType;
        export { _const as const };
        export let loop: TokenType;
        let _while: TokenType;
        export { _while as while };
        let _private: TokenType;
        export { _private as private };
        export let read: TokenType;
        export let read_write: TokenType;
        let _return: TokenType;
        export { _return as return };
        export let storage: TokenType;
        let _switch: TokenType;
        export { _switch as switch };
        let _true: TokenType;
        export { _true as true };
        export let alias: TokenType;
        export let type: TokenType;
        export let uniform: TokenType;
        let _var: TokenType;
        export { _var as var };
        export let override: TokenType;
        export let workgroup: TokenType;
        export let write: TokenType;
        export let r8unorm: TokenType;
        export let r8snorm: TokenType;
        export let r8uint: TokenType;
        export let r8sint: TokenType;
        export let r16uint: TokenType;
        export let r16sint: TokenType;
        export let r16float: TokenType;
        export let rg8unorm: TokenType;
        export let rg8snorm: TokenType;
        export let rg8uint: TokenType;
        export let rg8sint: TokenType;
        export let r32uint: TokenType;
        export let r32sint: TokenType;
        export let r32float: TokenType;
        export let rg16uint: TokenType;
        export let rg16sint: TokenType;
        export let rg16float: TokenType;
        export let rgba8unorm: TokenType;
        export let rgba8unorm_srgb: TokenType;
        export let rgba8snorm: TokenType;
        export let rgba8uint: TokenType;
        export let rgba8sint: TokenType;
        export let bgra8unorm: TokenType;
        export let bgra8unorm_srgb: TokenType;
        export let rgb10a2unorm: TokenType;
        export let rg11b10float: TokenType;
        export let rg32uint: TokenType;
        export let rg32sint: TokenType;
        export let rg32float: TokenType;
        export let rgba16uint: TokenType;
        export let rgba16sint: TokenType;
        export let rgba16float: TokenType;
        export let rgba32uint: TokenType;
        export let rgba32sint: TokenType;
        export let rgba32float: TokenType;
        export let static_assert: TokenType;
    }
    namespace tokens {
        let decimal_float_literal: TokenType;
        let hex_float_literal: TokenType;
        let int_literal: TokenType;
        let uint_literal: TokenType;
        let ident: TokenType;
        let and: TokenType;
        let and_and: TokenType;
        let arrow: TokenType;
        let attr: TokenType;
        let attr_left: TokenType;
        let attr_right: TokenType;
        let forward_slash: TokenType;
        let bang: TokenType;
        let bracket_left: TokenType;
        let bracket_right: TokenType;
        let brace_left: TokenType;
        let brace_right: TokenType;
        let colon: TokenType;
        let comma: TokenType;
        let equal: TokenType;
        let equal_equal: TokenType;
        let not_equal: TokenType;
        let greater_than: TokenType;
        let greater_than_equal: TokenType;
        let shift_right: TokenType;
        let less_than: TokenType;
        let less_than_equal: TokenType;
        let shift_left: TokenType;
        let modulo: TokenType;
        let minus: TokenType;
        let minus_minus: TokenType;
        let period: TokenType;
        let plus: TokenType;
        let plus_plus: TokenType;
        let or: TokenType;
        let or_or: TokenType;
        let paren_left: TokenType;
        let paren_right: TokenType;
        let semicolon: TokenType;
        let star: TokenType;
        let tilde: TokenType;
        let underscore: TokenType;
        let xor: TokenType;
        let plus_equal: TokenType;
        let minus_equal: TokenType;
        let times_equal: TokenType;
        let division_equal: TokenType;
        let modulo_equal: TokenType;
        let and_equal: TokenType;
        let or_equal: TokenType;
        let xor_equal: TokenType;
        let shift_right_equal: TokenType;
        let shift_left_equal: TokenType;
    }
    let storage_class: TokenType[];
    let access_mode: TokenType[];
    let sampler_type: TokenType[];
    let sampled_texture_type: TokenType[];
    let multisampled_texture_type: TokenType[];
    let storage_texture_type: TokenType[];
    let depth_texture_type: TokenType[];
    let texture_external_type: TokenType[];
    let any_texture_type: TokenType[];
    let texel_format: TokenType[];
    let const_literal: TokenType[];
    let literal_or_ident: TokenType[];
    let element_count_expression: TokenType[];
    let template_types: TokenType[];
    let attribute_name: TokenType[];
    let assignment_operators: TokenType[];
    let increment_operators: TokenType[];
}
/**
 * @class Type
 * @extends Statement
 * @category AST
 */
export class Type extends Statement {
    constructor(name: any);
    name: any;
    get isStruct(): boolean;
    get isArray(): boolean;
}
/**
 * @author Brendan Duncan / https://github.com/brendan-duncan
 */
export class TypeInfo {
    constructor(name: any, attributes: any);
    name: any;
    attributes: any;
    size: number;
    get isArray(): boolean;
    get isStruct(): boolean;
    get isTemplate(): boolean;
}
/**
 * @class TypecastExpr
 * @extends Expression
 * @category AST
 */
export class TypecastExpr extends Expression {
    constructor(type: any, args: any);
    type: any;
    args: any;
    evaluate(context: any): any;
}
/**
 * @class UnaryOperator
 * @extends Operator
 * @category AST
 * @property {string} operator +, -, !, ~
 */
export class UnaryOperator extends Operator {
    constructor(operator: any, right: any);
    operator: any;
    right: any;
    evaluate(context: any): any;
}
/**
 * @class Var
 * @extends Statement
 * @category AST
 */
export class Var extends Statement {
    constructor(name: any, type: any, storage: any, access: any, value: any);
    name: any;
    type: any;
    storage: any;
    access: any;
    value: any;
}
/**
 * @class VariableExpr
 * @extends Expression
 * @category AST
 */
export class VariableExpr extends Expression {
    constructor(name: any);
    name: any;
}
export class VariableInfo {
    constructor(name: any, type: any, group: any, binding: any, attributes: any, resourceType: any, access: any);
    name: any;
    type: any;
    group: any;
    binding: any;
    attributes: any;
    resourceType: any;
    access: any;
    get isArray(): any;
    get isStruct(): any;
    get isTemplate(): any;
    get size(): any;
    get align(): any;
    get members(): any;
    get format(): any;
    get count(): any;
    get stride(): any;
}
/**
 * @author Brendan Duncan / https://github.com/brendan-duncan
 */
export class WgslParser {
    _tokens: any[];
    _current: number;
    _context: ParseContext;
    parse(tokensOrCode: any): (Function | Var | Override | Let | Const | Enable | Alias | Struct)[];
    _initialize(tokensOrCode: any): void;
    _error(token: any, message: any): {
        token: any;
        message: any;
        toString: () => string;
    };
    _isAtEnd(): boolean;
    _match(types: any): boolean;
    _consume(types: any, message: any): any;
    _check(types: any): boolean;
    _advance(): any;
    _peek(): any;
    _previous(): any;
    _global_decl_or_directive(): Function | Var | Override | Let | Const | Enable | Alias | Struct;
    _function_decl(): Function;
    _compound_statement(): any;
    _statement(): any;
    _static_assert_statement(): StaticAssert;
    _while_statement(): any;
    _continuing_statement(): any;
    _for_statement(): any;
    _for_init(): Var | Let | Const | Assign | Call;
    _for_increment(): Increment | Assign | Call;
    _variable_statement(): Var | Let | Const;
    _increment_decrement_statement(): Increment;
    _assignment_statement(): Assign;
    _func_call_statement(): Call;
    _loop_statement(): any;
    _switch_statement(): any;
    _switch_body(): any;
    _case_selectors(): any[];
    _case_body(): any;
    _if_statement(): any;
    _match_elseif(): boolean;
    _elseif_statement(elseif?: any[]): any[];
    _return_statement(): Return;
    _short_circuit_or_expression(): any;
    _short_circuit_and_expr(): any;
    _inclusive_or_expression(): any;
    _exclusive_or_expression(): any;
    _and_expression(): any;
    _equality_expression(): any;
    _relational_expression(): any;
    _shift_expression(): any;
    _additive_expression(): any;
    _multiplicative_expression(): any;
    _unary_expression(): any;
    _singular_expression(): any;
    _postfix_expression(): any;
    _getStruct(name: any): any;
    _primary_expression(): any;
    _argument_expression_list(): any;
    _optional_paren_expression(): GroupingExpr;
    _paren_expression(): any;
    _struct_decl(): Struct;
    _global_variable_decl(): Var;
    _override_variable_decl(): Override;
    _global_const_decl(): Const;
    _global_let_decl(): Let;
    _const_expression(): any;
    _variable_decl(): Var;
    _override_decl(): Override;
    _enable_directive(): Enable;
    _type_alias(): Alias;
    _type_decl(): any;
    _texture_sampler_types(): any;
    _attribute(): Attribute[];
}
export class WgslReflect {
    constructor(code: any);
    uniforms: any[];
    storage: any[];
    textures: any[];
    samplers: any[];
    aliases: any[];
    overrides: any[];
    structs: any[];
    entry: EntryFunctions;
    _types: Map<any, any>;
    _isStorageTexture(type: any): boolean;
    update(code: any): void;
    getBindGroups(): any[];
    _getOutputs(type: any, outputs?: any): any;
    _getStructOutputs(struct: any, outputs: any): void;
    _getOutputInfo(type: any): OutputInfo;
    _getInputs(args: any, inputs?: any): any;
    _getStructInputs(struct: any, inputs: any): void;
    _getInputInfo(node: any): InputInfo;
    _parseString(s: any): any;
    _parseInt(s: any): any;
    _getAlias(name: any): any;
    _getAliasInfo(node: any): AliasInfo;
    _getTypeInfo(type: any, attributes: any): any;
    _updateTypeInfo(type: any): void;
    _updateStructInfo(struct: any): void;
    _getTypeSize(type: any): _TypeSize;
    _isUniformVar(node: any): boolean;
    _isStorageVar(node: any): boolean;
    _isTextureVar(node: any): boolean;
    _isSamplerVar(node: any): boolean;
    _getAttribute(node: any, name: any): any;
    _getAttributeNum(attributes: any, name: any, defaultValue: any): any;
    _roundUp(k: any, n: any): number;
}
export namespace WgslReflect {
    namespace _typeInfo {
        export namespace f16_1 {
            let align: number;
            let size: number;
        }
        export { f16_1 as f16 };
        export namespace i32_1 {
            let align_1: number;
            export { align_1 as align };
            let size_1: number;
            export { size_1 as size };
        }
        export { i32_1 as i32 };
        export namespace u32_1 {
            let align_2: number;
            export { align_2 as align };
            let size_2: number;
            export { size_2 as size };
        }
        export { u32_1 as u32 };
        export namespace f32_1 {
            let align_3: number;
            export { align_3 as align };
            let size_3: number;
            export { size_3 as size };
        }
        export { f32_1 as f32 };
        export namespace atomic_1 {
            let align_4: number;
            export { align_4 as align };
            let size_4: number;
            export { size_4 as size };
        }
        export { atomic_1 as atomic };
        export namespace vec2_1 {
            let align_5: number;
            export { align_5 as align };
            let size_5: number;
            export { size_5 as size };
        }
        export { vec2_1 as vec2 };
        export namespace vec3_1 {
            let align_6: number;
            export { align_6 as align };
            let size_6: number;
            export { size_6 as size };
        }
        export { vec3_1 as vec3 };
        export namespace vec4_1 {
            let align_7: number;
            export { align_7 as align };
            let size_7: number;
            export { size_7 as size };
        }
        export { vec4_1 as vec4 };
        export namespace mat2x2_1 {
            let align_8: number;
            export { align_8 as align };
            let size_8: number;
            export { size_8 as size };
        }
        export { mat2x2_1 as mat2x2 };
        export namespace mat3x2_1 {
            let align_9: number;
            export { align_9 as align };
            let size_9: number;
            export { size_9 as size };
        }
        export { mat3x2_1 as mat3x2 };
        export namespace mat4x2_1 {
            let align_10: number;
            export { align_10 as align };
            let size_10: number;
            export { size_10 as size };
        }
        export { mat4x2_1 as mat4x2 };
        export namespace mat2x3_1 {
            let align_11: number;
            export { align_11 as align };
            let size_11: number;
            export { size_11 as size };
        }
        export { mat2x3_1 as mat2x3 };
        export namespace mat3x3_1 {
            let align_12: number;
            export { align_12 as align };
            let size_12: number;
            export { size_12 as size };
        }
        export { mat3x3_1 as mat3x3 };
        export namespace mat4x3_1 {
            let align_13: number;
            export { align_13 as align };
            let size_13: number;
            export { size_13 as size };
        }
        export { mat4x3_1 as mat4x3 };
        export namespace mat2x4_1 {
            let align_14: number;
            export { align_14 as align };
            let size_14: number;
            export { size_14 as size };
        }
        export { mat2x4_1 as mat2x4 };
        export namespace mat3x4_1 {
            let align_15: number;
            export { align_15 as align };
            let size_15: number;
            export { size_15 as size };
        }
        export { mat3x4_1 as mat3x4 };
        export namespace mat4x4_1 {
            let align_16: number;
            export { align_16 as align };
            let size_16: number;
            export { size_16 as size };
        }
        export { mat4x4_1 as mat4x4 };
    }
    let _textureTypes: any[];
    let _samplerTypes: any[];
}
export class WgslScanner {
    constructor(source: any);
    _tokens: any[];
    _start: number;
    _current: number;
    _line: number;
    _source: any;
    scanTokens(): any[];
    scanToken(): boolean;
    _findType(lexeme: any): any;
    _match(lexeme: any, rule: any): boolean;
    _isAtEnd(): boolean;
    _isWhitespace(c: any): boolean;
    _advance(amount?: number): any;
    _peekAhead(offset?: number): any;
    _addToken(type: any): void;
}
/**
 * @class While
 * @extends Statement
 * @category AST
 */
export class While extends Statement {
    constructor(condition: any, body: any);
    condition: any;
    body: any;
}
declare class _TypeSize {
    constructor(align: any, size: any);
    align: any;
    size: any;
}
export {};
//# sourceMappingURL=wgsl_reflect.module.d.ts.map