{
  "version": 3,
  "sources": ["index.js", "pbr/parse-pbr-material.js", "pbr/pbr-environment.js", "gltf/gltf-instantiator.js", "gltf/gltf-animator.js", "gltf/create-gltf-model.js", "gltf/create-gltf-objects.js"],
  "sourcesContent": ["// luma.gl, MIT license\nexport { parsePBRMaterial } from \"./pbr/parse-pbr-material.js\";\nexport { loadPBREnvironment } from \"./pbr/pbr-environment.js\";\n// glTF Scenegraph Instantiator\nexport { createScenegraphsFromGLTF } from \"./gltf/create-gltf-objects.js\";\nexport { GLTFAnimator } from \"./gltf/gltf-animator.js\";\n", "import { log } from '@luma.gl/core';\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\nvar GLEnum;\n(function (GLEnum) {\n    GLEnum[GLEnum[\"FUNC_ADD\"] = 32774] = \"FUNC_ADD\";\n    GLEnum[GLEnum[\"ONE\"] = 1] = \"ONE\";\n    GLEnum[GLEnum[\"SRC_ALPHA\"] = 770] = \"SRC_ALPHA\";\n    GLEnum[GLEnum[\"ONE_MINUS_SRC_ALPHA\"] = 771] = \"ONE_MINUS_SRC_ALPHA\";\n    GLEnum[GLEnum[\"TEXTURE_MIN_FILTER\"] = 10241] = \"TEXTURE_MIN_FILTER\";\n    GLEnum[GLEnum[\"LINEAR\"] = 9729] = \"LINEAR\";\n    GLEnum[GLEnum[\"LINEAR_MIPMAP_NEAREST\"] = 9985] = \"LINEAR_MIPMAP_NEAREST\";\n    GLEnum[GLEnum[\"UNPACK_FLIP_Y_WEBGL\"] = 37440] = \"UNPACK_FLIP_Y_WEBGL\";\n})(GLEnum || (GLEnum = {}));\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(device, material, attributes, options) {\n    const parsedMaterial = {\n        defines: {\n            // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n            MANUAL_SRGB: 1,\n            SRGB_FAST_APPROXIMATION: 1\n        },\n        bindings: {},\n        uniforms: {\n            // TODO: find better values?\n            u_Camera: [0, 0, 0], // Model should override\n            u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n        },\n        parameters: {},\n        glParameters: {},\n        generatedTextures: []\n    };\n    // TODO - always available\n    parsedMaterial.defines.USE_TEX_LOD = 1;\n    const { imageBasedLightingEnvironment } = options;\n    if (imageBasedLightingEnvironment) {\n        parsedMaterial.bindings.u_DiffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler;\n        parsedMaterial.bindings.u_SpecularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler;\n        parsedMaterial.bindings.u_brdfLUT = imageBasedLightingEnvironment.brdfLutTexture;\n        parsedMaterial.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n    if (options?.pbrDebug) {\n        parsedMaterial.defines.PBR_DEBUG = 1;\n        // Override final color for reference app visualization of various parameters in the lighting equation.\n        parsedMaterial.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n        parsedMaterial.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n    if (attributes.NORMAL)\n        parsedMaterial.defines.HAS_NORMALS = 1;\n    if (attributes.TANGENT && options?.useTangents)\n        parsedMaterial.defines.HAS_TANGENTS = 1;\n    if (attributes.TEXCOORD_0)\n        parsedMaterial.defines.HAS_UV = 1;\n    if (options?.imageBasedLightingEnvironment)\n        parsedMaterial.defines.USE_IBL = 1;\n    if (options?.lights)\n        parsedMaterial.defines.USE_LIGHTS = 1;\n    if (material) {\n        parseMaterial(device, material, parsedMaterial);\n    }\n    return parsedMaterial;\n}\n/** Parse GLTF material record */\nfunction parseMaterial(device, material, parsedMaterial) {\n    parsedMaterial.uniforms.pbr_uUnlit = Boolean(material.unlit);\n    if (material.pbrMetallicRoughness) {\n        parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n    }\n    if (material.normalTexture) {\n        addTexture(device, material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP', parsedMaterial);\n        const { scale = 1 } = material.normalTexture;\n        parsedMaterial.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n        addTexture(device, material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP', parsedMaterial);\n        const { strength = 1 } = material.occlusionTexture;\n        parsedMaterial.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n        addTexture(device, material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP', parsedMaterial);\n        parsedMaterial.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    switch (material.alphaMode) {\n        case 'MASK':\n            const { alphaCutoff = 0.5 } = material;\n            parsedMaterial.defines.ALPHA_CUTOFF = 1;\n            parsedMaterial.uniforms.u_AlphaCutoff = alphaCutoff;\n            break;\n        case 'BLEND':\n            log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n            // WebGPU style parameters\n            parsedMaterial.parameters.blendColorOperation = 'add';\n            parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n            parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n            parsedMaterial.parameters.blendAlphaOperation = 'add';\n            parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n            parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n            // GL parameters\n            parsedMaterial.glParameters.blend = true;\n            parsedMaterial.glParameters.blendEquation = GLEnum.FUNC_ADD;\n            parsedMaterial.glParameters.blendFunc = [\n                GLEnum.SRC_ALPHA,\n                GLEnum.ONE_MINUS_SRC_ALPHA,\n                GLEnum.ONE,\n                GLEnum.ONE_MINUS_SRC_ALPHA\n            ];\n            break;\n    }\n}\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n        addTexture(device, pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP', parsedMaterial);\n    }\n    parsedMaterial.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n        addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP', parsedMaterial);\n    }\n    const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;\n    parsedMaterial.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(device, gltfTexture, uniformName, define = null, parsedMaterial) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n        textureOptions = image;\n        specialTextureParameters = {\n            [GLEnum.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GLEnum.LINEAR_MIPMAP_NEAREST : GLEnum.LINEAR\n        };\n    }\n    else {\n        // Texture2D accepts a promise that returns an image as data (Async Textures)\n        textureOptions = { data: image };\n    }\n    const texture = device.createTexture({\n        id: gltfTexture.uniformName || gltfTexture.id,\n        parameters: {\n            ...parameters,\n            ...specialTextureParameters\n        },\n        pixelStore: {\n            [GLEnum.UNPACK_FLIP_Y_WEBGL]: false\n        },\n        ...textureOptions\n    });\n    parsedMaterial.bindings[uniformName] = texture;\n    if (define)\n        parsedMaterial.defines[define] = 1;\n    parsedMaterial.generatedTextures.push(texture);\n}\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, number | boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.pbr_uUnlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n", "import { loadImageTexture } from '@loaders.gl/textures';\n/** Loads textures for PBR environment */\nexport function loadPBREnvironment(device, props) {\n    const brdfLutTexture = device.createTexture({\n        id: 'brdfLUT',\n        sampler: {\n            wrapS: 'clamp-to-edge',\n            wrapT: 'clamp-to-edge',\n            minFilter: 'linear',\n            maxFilter: 'linear'\n        },\n        // Texture accepts a promise that returns an image as data (Async Textures)\n        data: loadImageTexture(props.brdfLutUrl)\n    });\n    const diffuseEnvSampler = makeCube(device, {\n        id: 'DiffuseEnvSampler',\n        getTextureForFace: dir => loadImageTexture(props.getTexUrl('diffuse', dir, 0)),\n        sampler: {\n            wrapS: 'clamp-to-edge',\n            wrapT: 'clamp-to-edge',\n            minFilter: 'linear',\n            maxFilter: 'linear'\n        }\n    });\n    const specularEnvSampler = makeCube(device, {\n        id: 'SpecularEnvSampler',\n        getTextureForFace: (dir) => {\n            const imageArray = [];\n            for (let lod = 0; lod <= props.specularMipLevels - 1; lod++) {\n                imageArray.push(loadImageTexture(props.getTexUrl('specular', dir, lod)));\n            }\n            return imageArray;\n        },\n        sampler: {\n            wrapS: 'clamp-to-edge',\n            wrapT: 'clamp-to-edge',\n            minFilter: 'linear', // [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n            maxFilter: 'linear'\n        }\n    });\n    return {\n        brdfLutTexture,\n        diffuseEnvSampler,\n        specularEnvSampler\n    };\n}\n// TODO put somewhere common\nconst FACES = [0, 1, 2, 3, 4, 5];\nfunction makeCube(device, { id, getTextureForFace, sampler }) {\n    const data = {};\n    FACES.forEach(face => {\n        data[String(face)] = getTextureForFace(face);\n    });\n    return device.createTexture({\n        id,\n        dimension: 'cube',\n        mipmaps: false,\n        sampler,\n        data\n    });\n}\n", "import { Geometry, GroupNode } from '@luma.gl/engine';\nimport { Matrix4 } from '@math.gl/core';\nimport { GLTFAnimator } from \"./gltf-animator.js\";\nimport { createGLTFModel } from \"./create-gltf-model.js\";\nconst DEFAULT_OPTIONS = {\n    modelOptions: {},\n    pbrDebug: false,\n    imageBasedLightingEnvironment: null,\n    lights: true,\n    useTangents: false\n};\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport class GLTFInstantiator {\n    device;\n    options;\n    gltf;\n    constructor(device, options = {}) {\n        this.device = device;\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n    }\n    instantiate(gltf) {\n        this.gltf = gltf;\n        const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n        return scenes;\n    }\n    createAnimator() {\n        if (Array.isArray(this.gltf.animations)) {\n            return new GLTFAnimator(this.gltf);\n        }\n        return null;\n    }\n    createScene(gltfScene) {\n        const gltfNodes = gltfScene.nodes || [];\n        const nodes = gltfNodes.map(node => this.createNode(node));\n        const scene = new GroupNode({\n            id: gltfScene.name || gltfScene.id,\n            children: nodes\n        });\n        return scene;\n    }\n    createNode(gltfNode) {\n        if (!gltfNode._node) {\n            const gltfChildren = gltfNode.children || [];\n            const children = gltfChildren.map(child => this.createNode(child));\n            // Node can have children nodes and meshes at the same time\n            if (gltfNode.mesh) {\n                children.push(this.createMesh(gltfNode.mesh));\n            }\n            const node = new GroupNode({\n                id: gltfNode.name || gltfNode.id,\n                children\n            });\n            if (gltfNode.matrix) {\n                node.setMatrix(gltfNode.matrix);\n            }\n            else {\n                node.matrix.identity();\n                if (gltfNode.translation) {\n                    node.matrix.translate(gltfNode.translation);\n                }\n                if (gltfNode.rotation) {\n                    const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n                    node.matrix.multiplyRight(rotationMatrix);\n                }\n                if (gltfNode.scale) {\n                    node.matrix.scale(gltfNode.scale);\n                }\n            }\n            gltfNode._node = node;\n        }\n        return gltfNode._node;\n    }\n    createMesh(gltfMesh) {\n        // TODO: avoid changing the gltf\n        if (!gltfMesh._mesh) {\n            const gltfPrimitives = gltfMesh.primitives || [];\n            const primitives = gltfPrimitives.map((gltfPrimitive, i) => this.createPrimitive(gltfPrimitive, i, gltfMesh));\n            const mesh = new GroupNode({\n                id: gltfMesh.name || gltfMesh.id,\n                children: primitives\n            });\n            gltfMesh._mesh = mesh;\n        }\n        return gltfMesh._mesh;\n    }\n    createPrimitive(gltfPrimitive, i, gltfMesh) {\n        const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n        const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n        const vertexCount = gltfPrimitive.indices\n            ? gltfPrimitive.indices.count\n            : this.getVertexCount(gltfPrimitive.attributes);\n        const modelNode = createGLTFModel(this.device, {\n            id,\n            geometry: this.createGeometry(id, gltfPrimitive, topology),\n            material: gltfPrimitive.material,\n            materialOptions: this.options,\n            modelOptions: this.options.modelOptions,\n            vertexCount\n        });\n        modelNode.bounds = [\n            gltfPrimitive.attributes.POSITION.min,\n            gltfPrimitive.attributes.POSITION.max\n        ];\n        // TODO this holds on to all the CPU side texture and attribute data\n        // modelNode.material =  gltfPrimitive.material;\n        return modelNode;\n    }\n    getVertexCount(attributes) {\n        throw new Error('getVertexCount not implemented');\n    }\n    createGeometry(id, gltfPrimitive, topology) {\n        const attributes = {};\n        for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n            const { components, size, value } = attribute;\n            attributes[attributeName] = { size: size ?? components, value };\n        }\n        return new Geometry({\n            id,\n            topology,\n            indices: gltfPrimitive.indices.value,\n            attributes\n        });\n    }\n    createBuffer(attribute, usage) {\n        if (!attribute.bufferView) {\n            // Draco decoded files do not have a bufferView\n            attribute.bufferView = {};\n        }\n        const { bufferView } = attribute;\n        if (!bufferView.lumaBuffers) {\n            bufferView.lumaBuffers = {};\n        }\n        if (!bufferView.lumaBuffers[usage]) {\n            bufferView.lumaBuffers[usage] = this.device.createBuffer({\n                id: `from-${bufferView.id}`,\n                // Draco decoded files have attribute.value\n                data: bufferView.data || attribute.value\n            });\n        }\n        return bufferView.lumaBuffers[usage];\n    }\n    // TODO - create sampler in WebGL2\n    createSampler(gltfSampler) {\n        return gltfSampler;\n    }\n    // Helper methods (move to GLTFLoader.resolve...?)\n    needsPOT() {\n        // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n        // Has a minification filter (minFilter) that uses mipmapping\n        // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n        // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n        return false;\n    }\n}\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\nvar GLEnum;\n(function (GLEnum) {\n    GLEnum[GLEnum[\"POINTS\"] = 0] = \"POINTS\";\n    GLEnum[GLEnum[\"LINES\"] = 1] = \"LINES\";\n    GLEnum[GLEnum[\"LINE_LOOP\"] = 2] = \"LINE_LOOP\";\n    GLEnum[GLEnum[\"LINE_STRIP\"] = 3] = \"LINE_STRIP\";\n    GLEnum[GLEnum[\"TRIANGLES\"] = 4] = \"TRIANGLES\";\n    GLEnum[GLEnum[\"TRIANGLE_STRIP\"] = 5] = \"TRIANGLE_STRIP\";\n    GLEnum[GLEnum[\"TRIANGLE_FAN\"] = 6] = \"TRIANGLE_FAN\";\n})(GLEnum || (GLEnum = {}));\nexport function convertGLDrawModeToTopology(drawMode) {\n    switch (drawMode) {\n        case GLEnum.POINTS:\n            return 'point-list';\n        case GLEnum.LINES:\n            return 'line-list';\n        case GLEnum.LINE_STRIP:\n            return 'line-strip';\n        case GLEnum.LINE_LOOP:\n            return 'line-loop-webgl';\n        case GLEnum.TRIANGLES:\n            return 'triangle-list';\n        case GLEnum.TRIANGLE_STRIP:\n            return 'triangle-strip';\n        case GLEnum.TRIANGLE_FAN:\n            return 'triangle-fan-webgl';\n        default:\n            throw new Error(drawMode);\n    }\n}\n", "import { assert, log } from '@luma.gl/core';\nimport { Matrix4, Quaternion } from '@math.gl/core';\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nclass GLTFAnimation {\n    name;\n    startTime = 0;\n    playing = true;\n    speed = 1;\n    channels = [];\n    constructor(props) {\n        Object.assign(this, props);\n    }\n    animate(timeMs) {\n        if (!this.playing) {\n            return;\n        }\n        const absTime = timeMs / 1000;\n        const time = (absTime - this.startTime) * this.speed;\n        this.channels.forEach(({ sampler, target, path }) => {\n            interpolate(time, sampler, target, path);\n            applyTranslationRotationScale(target, target._node);\n        });\n    }\n}\nexport class GLTFAnimator {\n    animations;\n    constructor(gltf) {\n        this.animations = gltf.animations.map((animation, index) => {\n            const name = animation.name || `Animation-${index}`;\n            const samplers = animation.samplers.map(({ input, interpolation = 'LINEAR', output }) => ({\n                input: accessorToJsArray(gltf.accessors[input]),\n                interpolation,\n                output: accessorToJsArray(gltf.accessors[output])\n            }));\n            const channels = animation.channels.map(({ sampler, target }) => ({\n                sampler: samplers[sampler],\n                target: gltf.nodes[target.node],\n                path: target.path\n            }));\n            return new GLTFAnimation({ name, channels });\n        });\n    }\n    /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n    animate(time) {\n        this.setTime(time);\n    }\n    setTime(time) {\n        this.animations.forEach(animation => animation.animate(time));\n    }\n    getAnimations() {\n        return this.animations;\n    }\n}\n//\nfunction accessorToJsArray(accessor) {\n    if (!accessor._animation) {\n        const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n        const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n        const length = components * accessor.count;\n        const { buffer, byteOffset } = accessor.bufferView.data;\n        const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n        if (components === 1) {\n            accessor._animation = Array.from(array);\n        }\n        else {\n            // Slice array\n            const slicedArray = [];\n            for (let i = 0; i < array.length; i += components) {\n                slicedArray.push(Array.from(array.slice(i, i + components)));\n            }\n            accessor._animation = slicedArray;\n        }\n    }\n    return accessor._animation;\n}\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n    node.matrix.identity();\n    if (gltfNode.translation) {\n        node.matrix.translate(gltfNode.translation);\n    }\n    if (gltfNode.rotation) {\n        const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n        node.matrix.multiplyRight(rotationMatrix);\n    }\n    if (gltfNode.scale) {\n        node.matrix.scale(gltfNode.scale);\n    }\n}\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n    if (path === 'rotation') {\n        // SLERP when path is rotation\n        quaternion.slerp({ start, target: stop, ratio });\n        for (let i = 0; i < quaternion.length; i++) {\n            target[path][i] = quaternion[i];\n        }\n    }\n    else {\n        // regular interpolation\n        for (let i = 0; i < start.length; i++) {\n            target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n        }\n    }\n}\nfunction cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t }) {\n    // TODO: Quaternion might need normalization\n    for (let i = 0; i < target[path].length; i++) {\n        const m0 = outTangent0[i] * tDiff;\n        const m1 = inTangent1[i] * tDiff;\n        target[path][i] =\n            (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n                (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n                (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n                (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n    }\n}\nfunction stepInterpolate(target, path, value) {\n    for (let i = 0; i < value.length; i++) {\n        target[path][i] = value[i];\n    }\n}\nfunction interpolate(time, { input, interpolation, output }, target, path) {\n    const maxTime = input[input.length - 1];\n    const animationTime = time % maxTime;\n    const nextIndex = input.findIndex(t => t >= animationTime);\n    const previousIndex = Math.max(0, nextIndex - 1);\n    if (!Array.isArray(target[path])) {\n        switch (path) {\n            case 'translation':\n                target[path] = [0, 0, 0];\n                break;\n            case 'rotation':\n                target[path] = [0, 0, 0, 1];\n                break;\n            case 'scale':\n                target[path] = [1, 1, 1];\n                break;\n            default:\n                log.warn(`Bad animation path ${path}`)();\n        }\n    }\n    assert(target[path].length === output[previousIndex].length);\n    const previousTime = input[previousIndex];\n    const nextTime = input[nextIndex];\n    switch (interpolation) {\n        case 'STEP':\n            stepInterpolate(target, path, output[previousIndex]);\n            break;\n        case 'LINEAR':\n            if (nextTime > previousTime) {\n                const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n                linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n            }\n            break;\n        case 'CUBICSPLINE':\n            if (nextTime > previousTime) {\n                const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n                const tDiff = nextTime - previousTime;\n                const p0 = output[3 * previousIndex + 1];\n                const outTangent0 = output[3 * previousIndex + 2];\n                const inTangent1 = output[3 * nextIndex + 0];\n                const p1 = output[3 * nextIndex + 1];\n                cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });\n            }\n            break;\n        default:\n            log.warn(`Interpolation ${interpolation} not supported`)();\n            break;\n    }\n}\n", "import { log } from '@luma.gl/core';\nimport { pbr } from '@luma.gl/shadertools';\nimport { Model, ModelNode } from '@luma.gl/engine';\nimport { parsePBRMaterial } from \"../pbr/parse-pbr-material.js\";\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = `\n#pragma vscode_glsllint_stage: vert\n#if (__VERSION__ < 300)\n  #define _attr attribute\n#else\n  #define _attr in\n#endif\n\n  // _attr vec4 POSITION;\n  _attr vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // _attr vec4 NORMAL;\n    _attr vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    _attr vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // _attr vec2 TEXCOORD_0;\n    _attr vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n`;\nconst fs = `\n#pragma vscode_glsllint_stage: frag\n#if (__VERSION__ < 300)\n  #define fragmentColor gl_FragColor\n#else\n  out vec4 fragmentColor;\n#endif\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\nexport function createGLTFModel(device, options) {\n    const { id, geometry, material, vertexCount, materialOptions, modelOptions } = options;\n    const parsedMaterial = parsePBRMaterial(device, material, geometry.attributes, materialOptions);\n    log.info(4, 'createGLTFModel defines: ', parsedMaterial.defines)();\n    // Calculate managedResources\n    // TODO: Implement resource management logic that will\n    // not deallocate resources/textures/buffers that are shared\n    const managedResources = [];\n    // managedResources.push(...parsedMaterial.generatedTextures);\n    // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n    const parameters = {\n        depthWriteEnabled: true,\n        depthCompare: 'less',\n        depthFormat: 'depth24plus',\n        cullMode: 'back'\n    };\n    const modelProps = {\n        id,\n        geometry,\n        topology: geometry.topology,\n        vertexCount,\n        modules: [pbr],\n        vs: addVersionToShader(device, vs),\n        fs: addVersionToShader(device, fs),\n        ...modelOptions,\n        bindings: { ...parsedMaterial.bindings, ...modelOptions.bindings },\n        defines: { ...parsedMaterial.defines, ...modelOptions.defines },\n        parameters: { ...parameters, ...parsedMaterial.parameters, ...modelOptions.parameters },\n        uniforms: { ...parsedMaterial.uniforms, ...modelOptions.uniforms }\n    };\n    const model = new Model(device, modelProps);\n    return new ModelNode({ managedResources, model });\n}\nfunction addVersionToShader(device, source) {\n    return `#version 300 es\\n${source}`;\n}\n", "import { GLTFInstantiator } from \"./gltf-instantiator.js\";\nexport function createScenegraphsFromGLTF(device, gltf, options) {\n    const instantiator = new GLTFInstantiator(device, options);\n    const scenes = instantiator.instantiate(gltf);\n    const animator = instantiator.createAnimator();\n    return { scenes, animator };\n}\n"],
  "mappings": "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",
  "names": ["GLEnum", "import_engine", "import_core", "import_core", "import_core", "GLEnum"]
}
