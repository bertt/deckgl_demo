import r from"jsep";export{default as parse}from"jsep";const t={"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10},e={"||":function(r,t){return r||t},"&&":function(r,t){return r&&t},"|":function(r,t){return r|t},"^":function(r,t){return r^t},"&":function(r,t){return r&t},"==":function(r,t){return r==t},"!=":function(r,t){return r!=t},"===":function(r,t){return r===t},"!==":function(r,t){return r!==t},"<":function(r,t){return r<t},">":function(r,t){return r>t},"<=":function(r,t){return r<=t},">=":function(r,t){return r>=t},"<<":function(r,t){return r<<t},">>":function(r,t){return r>>t},">>>":function(r,t){return r>>>t},"+":function(r,t){return r+t},"-":function(r,t){return r-t},"*":function(r,t){return r*t},"/":function(r,t){return r/t},"%":function(r,t){return r%t}},n={"-":function(r){return-r},"+":function(r){return+r},"~":function(r){return~r},"!":function(r){return!r}};function o(r,t){return r.map(function(r){return s(r,t)})}async function a(r,t){return await Promise.all(r.map(r=>c(r,t)))}function i(r,t){const e=s(r.object,t);let n;if(n=r.computed?s(r.property,t):r.property.name,/^__proto__|prototype|constructor$/.test(n))throw Error(`Access to member "${n}" disallowed.`);return[e,e[n]]}async function u(r,t){const e=await c(r.object,t);let n;if(n=r.computed?await c(r.property,t):r.property.name,/^__proto__|prototype|constructor$/.test(n))throw Error(`Access to member "${n}" disallowed.`);return[e,e[n]]}function s(r,t){const a=r;switch(a.type){case"ArrayExpression":return o(a.elements,t);case"BinaryExpression":return e[a.operator](s(a.left,t),s(a.right,t));case"CallExpression":let r,u,c;if("MemberExpression"===a.callee.type?(c=i(a.callee,t),r=c[0],u=c[1]):u=s(a.callee,t),"function"!=typeof u)return;return u.apply(r,o(a.arguments,t));case"ConditionalExpression":return s(a.test,t)?s(a.consequent,t):s(a.alternate,t);case"Identifier":return t[a.name];case"Literal":return a.value;case"LogicalExpression":return"||"===a.operator?s(a.left,t)||s(a.right,t):"&&"===a.operator?s(a.left,t)&&s(a.right,t):e[a.operator](s(a.left,t),s(a.right,t));case"MemberExpression":return i(a,t)[1];case"ThisExpression":return t;case"UnaryExpression":return n[a.operator](s(a.argument,t));default:return}}async function c(r,t){const o=r;switch(o.type){case"ArrayExpression":return await a(o.elements,t);case"BinaryExpression":{const[r,n]=await Promise.all([c(o.left,t),c(o.right,t)]);return e[o.operator](r,n)}case"CallExpression":{let r,e,n;if("MemberExpression"===o.callee.type?(n=await u(o.callee,t),r=n[0],e=n[1]):e=await c(o.callee,t),"function"!=typeof e)return;return await e.apply(r,await a(o.arguments,t))}case"ConditionalExpression":return await c(o.test,t)?await c(o.consequent,t):await c(o.alternate,t);case"Identifier":return t[o.name];case"Literal":return o.value;case"LogicalExpression":{if("||"===o.operator)return await c(o.left,t)||await c(o.right,t);if("&&"===o.operator)return await c(o.left,t)&&await c(o.right,t);const[r,n]=await Promise.all([c(o.left,t),c(o.right,t)]);return e[o.operator](r,n)}case"MemberExpression":return(await u(o,t))[1];case"ThisExpression":return t;case"UnaryExpression":return n[o.operator](await c(o.argument,t));default:return}}function p(t){return s.bind(null,r(t))}function f(t){return c.bind(null,r(t))}function l(t,e){r.addUnaryOp(t),n[t]=e}function m(n,o,a){a?(r.addBinaryOp(n,o),e[n]=a):(r.addBinaryOp(n,t[n]||1),e[n]=o)}export{m as addBinaryOp,l as addUnaryOp,p as compile,f as compileAsync,s as eval,c as evalAsync};
//# sourceMappingURL=expression-eval.modern.js.map
